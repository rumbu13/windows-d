// Written in the D programming language.

module windows.mediafoundation;

public import windows.core;
public import windows.audio : IPropertyStore;
public import windows.automation : BSTR, VARIANT;
public import windows.com : HRESULT, IClassFactory, IUnknown;
public import windows.coreaudio : AudioObjectType, ISpatialAudioMetadataItems;
public import windows.direct3d11 : D3D11_AUTHENTICATED_PROTECTION_FLAGS, ID3D11DeviceChild,
                                   ID3D11Resource, ID3D11Texture2D, ID3D11View;
public import windows.direct3d12 : D3D12_COMMAND_LIST_SUPPORT_FLAGS, D3D12_DISCARD_REGION,
                                   D3D12_PREDICATION_OP, D3D12_QUERY_TYPE,
                                   D3D12_RESOURCE_BARRIER, D3D12_WRITEBUFFERIMMEDIATE_MODE,
                                   D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
                                   ID3D12CommandAllocator, ID3D12CommandList,
                                   ID3D12Pageable, ID3D12ProtectedResourceSession,
                                   ID3D12QueryHeap, ID3D12Resource;
public import windows.direct3d9 : D3DAUTHENTICATEDCHANNELTYPE, D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT,
                                  D3DDEVTYPE, D3DDISPLAYMODEEX, D3DDISPLAYROTATION,
                                  D3DENCRYPTED_BLOCK_INFO, D3DFORMAT, D3DPOOL,
                                  IDirect3DDevice9, IDirect3DDevice9Ex,
                                  IDirect3DSurface9;
public import windows.directshow : AM_MEDIA_TYPE, BITMAPINFOHEADER, DMO_MEDIA_TYPE,
                                   IMediaBuffer, MPEG1VIDEOINFO, MPEG2VIDEOINFO,
                                   VIDEOINFOHEADER, VIDEOINFOHEADER2;
public import windows.displaydevices : POINT, RECT, SIZE;
public import windows.dxgi : DXGI_COLOR_SPACE_TYPE, DXGI_FORMAT, DXGI_HDR_METADATA_TYPE,
                             DXGI_RATIONAL;
public import windows.gdi : HDC, HMONITOR;
public import windows.kernel : LUID;
public import windows.multimedia : WAVEFORMATEX;
public import windows.shell : INamedPropertyStore;
public import windows.streamingmedia : IMFDeviceTransform;
public import windows.structuredstorage : IStream, PROPVARIANT;
public import windows.systemservices : BOOL, HANDLE, PSTR, PWSTR;
public import windows.winrt : IInspectable;
public import windows.windowsandmessaging : HWND;
public import windows.windowsprogramming : FILETIME;

extern(Windows) @nogc nothrow:


// Enums


///Specifies the object type for the IMFPluginControl interface.
alias MF_Plugin_Type = int;
enum : int
{
    ///Media Foundation transform (MFT).
    MF_Plugin_Type_MFT                 = 0x00000000,
    ///Media source.
    MF_Plugin_Type_MediaSource         = 0x00000001,
    ///Match output type.
    MF_Plugin_Type_MFT_MatchOutputType = 0x00000002,
    ///Other.
    MF_Plugin_Type_Other               = 0xffffffff,
}

///Specifies how a video frame is interlaced.
alias D3D12_VIDEO_FIELD_TYPE = int;
enum : int
{
    ///The frame is progressive.
    D3D12_VIDEO_FIELD_TYPE_NONE                          = 0x00000000,
    ///The frame is interlaced. The top field of each frame is displayed first.
    D3D12_VIDEO_FIELD_TYPE_INTERLACED_TOP_FIELD_FIRST    = 0x00000001,
    ///The frame is interlaced. The bottom field of each frame is displayed first.
    D3D12_VIDEO_FIELD_TYPE_INTERLACED_BOTTOM_FIELD_FIRST = 0x00000002,
}

///Defines the layout in memory of a stereo 3D video frame. All drivers that support stereo must support all of the
///defined formats.
alias D3D12_VIDEO_FRAME_STEREO_FORMAT = int;
enum : int
{
    ///No stereo format is specified.
    D3D12_VIDEO_FRAME_STEREO_FORMAT_NONE       = 0x00000000,
    ///The sample does not contain stereo data. If the stereo format is not specified, this value is the default.
    D3D12_VIDEO_FRAME_STEREO_FORMAT_MONO       = 0x00000001,
    ///Frame 0 and frame 1 are packed side-by-side, as shown in the following diagram. ![Horizontal stereo format
    ///showing the frame 0 pixels on the left of a grid of pixels and the frame 1 pixels on the
    ///right](./images/stereo_format_horizontal.png)
    D3D12_VIDEO_FRAME_STEREO_FORMAT_HORIZONTAL = 0x00000002,
    ///Frame 0 and frame 1 are packed top-to-bottom, as shown in the following diagram. ![Vertical stereo format showing
    ///the frame 0 pixels on the top of a grid of pixels and the frame 1 pixels on the
    ///bottom](./images/stereo_format_horizontal.png)
    D3D12_VIDEO_FRAME_STEREO_FORMAT_VERTICAL   = 0x00000003,
    ///Frame 0 and frame 1 are placed in separate resources
    D3D12_VIDEO_FRAME_STEREO_FORMAT_SEPARATE   = 0x00000004,
}

///Specifies the interlace type of coded video frames.
alias D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE = int;
enum : int
{
    ///The coded frames are not interlaced, often referred to as "progressive".
    D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE_NONE        = 0x00000000,
    ///The coded frames may be interlaced.
    D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE_FIELD_BASED = 0x00000001,
}

///Specifies a Direct3D 12 video feature or feature set to query about. When you want to query for the level to which an
///adapter supports a feature, pass one of these values to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md).
alias D3D12_FEATURE_VIDEO = int;
enum : int
{
    ///Check if a decode profile, bitstream encryption, resolution, and format are supported. The result is a
    ///D3D12_VIDEO_DECODE_TIER indicating the level of support. The associated data structure is
    ///D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT.
    D3D12_FEATURE_VIDEO_DECODE_SUPPORT                       = 0x00000000,
    ///Retrieve the list of decode profiles supported by the adapter. Call **CheckFeatureSupport** specifying the
    ///feature D3D12_FEATURE_VIDEO_DECODE_PROFILE_COUNT to get the number of profiles before calling
    ///**CheckFeatureSupport** for the D3D12_FEATURE_VIDEO_DECODE_PROFILES feature. The associated data structure is
    ///D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES.
    D3D12_FEATURE_VIDEO_DECODE_PROFILES                      = 0x00000001,
    ///Retrieves the list of supported decode formats for a D3D12_VIDEO_DECODE_CONFIGURATION. Call
    ///**CheckFeatureSupport** specifying the feature D3D12_FEATURE_VIDEO_DECODE_FORMAT_COUNT to get the number of
    ///profiles before calling **CheckFeatureSupport** for the D3D12_FEATURE_VIDEO_DECODE_PROFILES feature.The
    ///associated data structure is D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS.
    D3D12_FEATURE_VIDEO_DECODE_FORMATS                       = 0x00000002,
    ///Check if a colorspace conversion, format conversion, and scale are supported. The associated data structure is
    ///D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT.
    D3D12_FEATURE_VIDEO_DECODE_CONVERSION_SUPPORT            = 0x00000003,
    ///Retrieves the video processor capabilities. The associated data structure is
    ///D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT.
    D3D12_FEATURE_VIDEO_PROCESS_SUPPORT                      = 0x00000005,
    ///Retrieves the maximum number of streams that can be enabled at the same time. The associated data structure is
    ///D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS.
    D3D12_FEATURE_VIDEO_PROCESS_MAX_INPUT_STREAMS            = 0x00000006,
    ///Retrieves the number of past and future frames required for a given deinterlace mode, filters, frame rate
    ///conversion, and features. The associated data structure is D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO.
    D3D12_FEATURE_VIDEO_PROCESS_REFERENCE_INFO               = 0x00000007,
    ///Checks the allocation size of a video decoder heap. The associated data structure is
    ///D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE. For information on residency budgeting for heaps, see
    ///[Residency](/windows/win32/direct3d12/residency).
    D3D12_FEATURE_VIDEO_DECODER_HEAP_SIZE                    = 0x00000008,
    ///Checks the allocation size of a video processor heap. The associated data structure is
    ///D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE. For information on residency budgeting for heaps, see
    ///[Residency](/windows/win32/direct3d12/residency).
    D3D12_FEATURE_VIDEO_PROCESSOR_SIZE                       = 0x00000009,
    ///Retrieves the number of supported decoder profiles. The returned count is used when querying for
    ///**D3D12_FEATURE_VIDEO_DECODE_PROFILES**.
    D3D12_FEATURE_VIDEO_DECODE_PROFILE_COUNT                 = 0x0000000a,
    ///Retrieves the number of supported decoder profiles. The returned count is used when querying for
    ///**D3D12_FEATURE_VIDEO_DECODE_FORMATS**.
    D3D12_FEATURE_VIDEO_DECODE_FORMAT_COUNT                  = 0x0000000b,
    ///Indicates if the video engine is IO coherent with the CPU.
    D3D12_FEATURE_VIDEO_ARCHITECTURE                         = 0x00000011,
    ///Retrieves the supported components, bin count, and counter bit depth for the a decode histogram with the
    ///specified decode profile, resolution, and format. The associated data structure is
    ///D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM.
    D3D12_FEATURE_VIDEO_DECODE_HISTOGRAM                     = 0x00000012,
    D3D12_FEATURE_VIDEO_FEATURE_AREA_SUPPORT                 = 0x00000013,
    ///Retrieves the supported resolutions, search block sizes, and precision for motion estimation. The associated data
    ///structure is
    ///[D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR](ns-d3d12video-d3d12_feature_data_video_motion_estimator.md).
    D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR                     = 0x00000014,
    ///Checks the allocation size of a motion estimator heap. The associated data structure is
    ///[D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE](ns-d3d12video-d3d12_feature_data_video_motion_estimator_size.md).
    D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR_SIZE                = 0x00000015,
    ///Retrieves the supported number of video extension commands. The associated data structure is
    ///[D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT](ns-d3d12video-d3d12_feature_data_video_extension_command_count.md).
    D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_COUNT              = 0x00000016,
    ///Retrieves a list of [D3D12_VIDEO_EXTENSION_COMMAND_INFO](ns-d3d12video-d3d12_video_extension_command_info.md)
    ///structures describing video extension commands. The associated data structure is
    ///[D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT](ns-d3d12video-d3d12_feature_data_video_extension_command_count.md).
    D3D12_FEATURE_VIDEO_EXTENSION_COMMANDS                   = 0x00000017,
    ///Retrieves the parameter count for the specified parameter stage. The associated data structure is
    ///[D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT](ns-d3d12video-d3d12_feature_data_video_extension_command_parameter_count.md).
    D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT    = 0x00000018,
    ///Retrieves a list of
    ///[D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO](ns-d3d12video-d3d12_video_extension_command_parameter_info.md)
    ///structures describing video extension command parameters for the specified parameter stage. The associated data
    ///structure is
    ///[D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS](ns-d3d12video-d3d12_feature_data_video_extension_command_parameters.md).
    D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETERS         = 0x00000019,
    ///Queries for command-defined support information. The associated data structure is
    ///[D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT](ns-d3d12video-d3d12_feature_data_video_extension_command_support.md).
    D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_SUPPORT            = 0x0000001a,
    ///Checks the allocation size of a video extension command. The associated data structure is
    ///[D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE](ns-d3d12video-d3d12_feature_data_video_extension_command_size.md).
    D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_SIZE               = 0x0000001b,
    D3D12_FEATURE_VIDEO_DECODE_PROTECTED_RESOURCES           = 0x0000001c,
    D3D12_FEATURE_VIDEO_PROCESS_PROTECTED_RESOURCES          = 0x0000001d,
    ///Checks support for motion estimation with protected resources. The associated data structure is
    ///[D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES](ns-d3d12video-d3d12_feature_data_video_motion_estimator_protected_resources.md).
    D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES = 0x0000001e,
    D3D12_FEATURE_VIDEO_DECODER_HEAP_SIZE1                   = 0x0000001f,
    D3D12_FEATURE_VIDEO_PROCESSOR_SIZE1                      = 0x00000020,
}

///Specifies a bitstream encryption type. This enumeration is used by the
///[D3D12\_VIDEO\_DECODE\_CONFIGURATION](ns-d3d12video-d3d12_video_decode_configuration.md) which describes the
///configuration for a video decoder.
alias D3D12_BITSTREAM_ENCRYPTION_TYPE = int;
enum : int
{
    ///The bistream is not encrypted.
    D3D12_BITSTREAM_ENCRYPTION_TYPE_NONE = 0x00000000,
}

alias D3D12_VIDEO_PROCESS_FILTER = int;
enum : int
{
    D3D12_VIDEO_PROCESS_FILTER_BRIGHTNESS         = 0x00000000,
    D3D12_VIDEO_PROCESS_FILTER_CONTRAST           = 0x00000001,
    D3D12_VIDEO_PROCESS_FILTER_HUE                = 0x00000002,
    D3D12_VIDEO_PROCESS_FILTER_SATURATION         = 0x00000003,
    D3D12_VIDEO_PROCESS_FILTER_NOISE_REDUCTION    = 0x00000004,
    D3D12_VIDEO_PROCESS_FILTER_EDGE_ENHANCEMENT   = 0x00000005,
    D3D12_VIDEO_PROCESS_FILTER_ANAMORPHIC_SCALING = 0x00000006,
    D3D12_VIDEO_PROCESS_FILTER_STEREO_ADJUSTMENT  = 0x00000007,
}

///Specifies support for the image filters.
alias D3D12_VIDEO_PROCESS_FILTER_FLAGS = int;
enum : int
{
    ///The video processor doesn't support any filters.
    D3D12_VIDEO_PROCESS_FILTER_FLAG_NONE               = 0x00000000,
    ///The video processor can adjust the brightness level.
    D3D12_VIDEO_PROCESS_FILTER_FLAG_BRIGHTNESS         = 0x00000001,
    ///The video processor can adjust the contrast level.
    D3D12_VIDEO_PROCESS_FILTER_FLAG_CONTRAST           = 0x00000002,
    ///The video processor can adjust hue.
    D3D12_VIDEO_PROCESS_FILTER_FLAG_HUE                = 0x00000004,
    ///The video processor can adjust the saturation level.
    D3D12_VIDEO_PROCESS_FILTER_FLAG_SATURATION         = 0x00000008,
    ///The video processor can perform noise reduction.
    D3D12_VIDEO_PROCESS_FILTER_FLAG_NOISE_REDUCTION    = 0x00000010,
    ///The video processor can perform edge enhancement.
    D3D12_VIDEO_PROCESS_FILTER_FLAG_EDGE_ENHANCEMENT   = 0x00000020,
    ///The video processor can perform anamorphic scaling. Anamorphic scaling can be used to stretch 4:3 content to a
    ///widescreen 16:9 aspect ratio.
    D3D12_VIDEO_PROCESS_FILTER_FLAG_ANAMORPHIC_SCALING = 0x00000040,
    ///For stereo 3D video, the video processor can adjust the offset between the left and right views, allowing the
    ///user to reduce potential eye strain.
    D3D12_VIDEO_PROCESS_FILTER_FLAG_STEREO_ADJUSTMENT  = 0x00000080,
}

///Specifies the deinterlacing video processor capabilities.
alias D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS = int;
enum : int
{
    ///No deinterlacing capabilities are available.
    D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_NONE   = 0x00000000,
    ///The video processor can perform bob deinterlacing. In bob deinterlacing, missing field lines are interpolated
    ///from the lines above and below. Bob deinterlacing does not require reference frames.
    D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_BOB    = 0x00000001,
    ///The video processor can perform a custom high-quality deinterlacing, which requires the number of reference
    ///frames indicated in *PastFrames* and *FutureFrames* output fields of the
    ///D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO populated by a call to ID3D12VideoDevice::CheckFeatureSupport
    ///when the feature specified is D3D12_FEATURE_VIDEO_PROCESS_REFERENCE_INFO. If the video processor doesnâ€™t have
    ///the necessary number of reference frames, it falls back to bob deinterlacing.
    D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_CUSTOM = 0x80000000,
}

///Specifies the alpha fill mode for video processing. This value is used by the
///[D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC](ns-d3d12video-d3d12_video_process_output_stream_desc.md) structure.
alias D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE = int;
enum : int
{
    ///Alpha values inside the target rectangle are set to opaque.
    D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_OPAQUE        = 0x00000000,
    ///Alpha values inside the target rectangle are set to the alpha value specified in the background color.
    D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_BACKGROUND    = 0x00000001,
    ///Existing alpha values remain unchanged in the output surface.
    D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_DESTINATION   = 0x00000002,
    ///Alpha values are taken from an input stream, scaled, and copied to the corresponding destination rectangle for
    ///that stream. The input stream is specified in the *AlphaFillModeSourceStreamIndex* member of
    ///D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS. If the input stream does not have alpha data, the video processor
    ///sets the alpha values in the target rectangle to opaque. If the input stream is disabled or the source rectangle
    ///is empty, the alpha values in the target rectangle are not modified.
    D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_SOURCE_STREAM = 0x00000003,
}

///Specifies the decoding tier of a hardware video decoder, which determines the required format of application-defined
///textures and buffers.
alias D3D12_VIDEO_DECODE_TIER = int;
enum : int
{
    ///Video decoding is not supported.
    D3D12_VIDEO_DECODE_TIER_NOT_SUPPORTED = 0x00000000,
    ///In tier 1, the hardware decoder requires that the application allocate reference textures as a texture array.
    ///This is to accomodate hardware requirements that the textures be "close" in address space because the hardware
    ///doesn't support a full size pointer for each individual picture buffer. Instead it has one pointer and a more
    ///limited bit offset. For more information on texture arrays, see [Introduction To Textures in Direct3D
    ///11](/windows/win32/direct3d11/overviews-direct3d-11-resources-textures-intro). If the decoder hardware requires a
    ///unique memory layout that is not supported for operations on other engines or different video operations, the
    ///decoder may set the D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_REFERENCE_ONLY_ALLOCATIONS_REQUIRED configuration flag
    ///in the D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT structure when queried for profile support. This flag indicates
    ///that the application must allocate references with the D3D12_RESOURCE_FLAG_VIDEO_DECODE_REFERENCE_ONLY flag. The
    ///application should use the D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS structure to set a reference-only output if
    ///the output is needed as a future reference frame. The output frame passed to ID3D12VideoCommandList::DecodeFrame
    ///is a D3D12 resource that can be consumed by other portions of the pipeline and must not have the
    ///D3D12_RESOURCE_FLAG_VIDEO_DECODE_REFERENCE_ONLY flag.
    D3D12_VIDEO_DECODE_TIER_1             = 0x00000001,
    ///In decode tier 2, textures can be referenced as a texture array or as an array of separate texture 2D resources
    ///(each resource having array size of 1). This is more flexible for the caller and is important in scenarios where
    ///the resolution changes frequently such as in streaming video, because a texture array can only be allocated and
    ///deallocated as an single unit, but separate texture 2D resources can be allocated and deallocated individually.
    ///If decode hardware requires a unique tiling format that is not supported for operations on other engines or
    ///different video operations, the decoder may set the
    ///D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_REFERENCE_ONLY_ALLOCATIONS_REQUIRED configuration flag in the
    ///D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT structure when queried for profile support. This flag indicates that the
    ///application must allocate references with the D3D12_RESOURCE_FLAG_VIDEO_DECODE_REFERENCE_ONLY flag. The
    ///application should use the D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS structure to set a reference only output if
    ///the output is needed as a future reference frame. The output frame passed to ID3D12VideoCommandList::DecodeFrame
    ///is a D3D12 resource that can be consumed by other portions of the pipeline and must not have the
    ///D3D12_RESOURCE_FLAG_VIDEO_DECODE_REFERENCE_ONLY flag.
    D3D12_VIDEO_DECODE_TIER_2             = 0x00000002,
    ///This field is reserved.
    D3D12_VIDEO_DECODE_TIER_3             = 0x00000003,
}

///Specifies whether a video decoding operation is supported.
alias D3D12_VIDEO_DECODE_SUPPORT_FLAGS = int;
enum : int
{
    ///The video decoding operation isn't supported.
    D3D12_VIDEO_DECODE_SUPPORT_FLAG_NONE      = 0x00000000,
    ///The video decoding operation is supported.
    D3D12_VIDEO_DECODE_SUPPORT_FLAG_SUPPORTED = 0x00000001,
}

///Specifies the configuration for video decoding.
alias D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS = int;
enum : int
{
    ///No configuration flags.
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_NONE                                     = 0x00000000,
    ///The height of the output decoded surfaces must be a multiple of 32.
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_HEIGHT_ALIGNMENT_MULTIPLE_32_REQUIRED    = 0x00000001,
    ///The driver supports post processing. If this flag is set, the host decoder can set up post-processing by using
    ///the conversion flags in the D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS.
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_POST_PROCESSING_SUPPORTED                = 0x00000002,
    ///Reference resources must be allocated with the D3D12_RESOURCE_FLAG_VIDEO_DECODE_REFERENCE_ONLY resource flag.
    ///References textures must be separate from output textures, similar to performing a format conversion or
    ///downscale. This flag must not be set for [D3D12_VIDEO_DECODE_TIER_3](ne-d3d12video-d3d12_video_decode_tier.md) or
    ///greater.
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_REFERENCE_ONLY_ALLOCATIONS_REQUIRED      = 0x00000004,
    ///The decode resolution can be changed on a non-key frame.
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_ALLOW_RESOLUTION_CHANGE_ON_NON_KEY_FRAME = 0x00000008,
}

///Specifes the status of a video decode operation. This enumeration is used in the status field of a
///[D3D12_VIDEO_DECODE_STATUS](ne-d3d12video-d3d12_video_decode_status.md) structure.
alias D3D12_VIDEO_DECODE_STATUS = int;
enum : int
{
    ///The operation succeeded.
    D3D12_VIDEO_DECODE_STATUS_OK                    = 0x00000000,
    ///There was a minor problem in the data format, but the host decoder should continue processing.
    D3D12_VIDEO_DECODE_STATUS_CONTINUE              = 0x00000001,
    ///There was a significant problem in the data format. The host decoder should continue processing, but should skip
    ///display.
    D3D12_VIDEO_DECODE_STATUS_CONTINUE_SKIP_DISPLAY = 0x00000002,
    ///There was a severe problem in the data format. The host decoder should restart the entire decoding process,
    ///starting at a sequence or random-access entry point.
    D3D12_VIDEO_DECODE_STATUS_RESTART               = 0x00000003,
    D3D12_VIDEO_DECODE_STATUS_RATE_EXCEEDED         = 0x00000004,
}

///Specifies the argument type of a
///[D3D12_VIDEO_DECODE_FRAME_ARGUMENT](ns-d3d12video-d3d12_video_decode_frame_argument.md).
alias D3D12_VIDEO_DECODE_ARGUMENT_TYPE = int;
enum : int
{
    ///The argument is a picture decoding parameter buffer.
    D3D12_VIDEO_DECODE_ARGUMENT_TYPE_PICTURE_PARAMETERS          = 0x00000000,
    ///The argument is an inverse quantization matrix buffer.
    D3D12_VIDEO_DECODE_ARGUMENT_TYPE_INVERSE_QUANTIZATION_MATRIX = 0x00000001,
    ///The argument is a slice control buffer.
    D3D12_VIDEO_DECODE_ARGUMENT_TYPE_SLICE_CONTROL               = 0x00000002,
    ///TBD
    D3D12_VIDEO_DECODE_ARGUMENT_TYPE_MAX_VALID                   = 0x00000003,
}

///Specifies indices for arrays of per component histogram information.
alias D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT = int;
enum : int
{
    ///If the format is a YUV format, indicates a histogram for the Y component.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_Y = 0x00000000,
    ///If the format is a YUV format, indicates a histogram for the U component.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_U = 0x00000001,
    ///If the format is a YUV format, indicates a histogram for the V component.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_V = 0x00000002,
    ///If the format is an RGB/BGR format, indicates a histogram for the R component.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_R = 0x00000000,
    ///If the format is an RGB/BGR format, indicates a histogram for the G component.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_G = 0x00000001,
    ///If the format is an RGB/BGR format, indicates a histogram for the B component.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_B = 0x00000002,
    ///If the format has an alpha channel, indicates a histogram for the A component.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_A = 0x00000003,
}

///Flags for indicating a subset of components used with video decode histogram. This enumeration is used by the
///[D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM](ns-d3d12video-d3d12_feature_data_video_decode_histogram.md) structure.
alias D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS = int;
enum : int
{
    ///No associated component.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_NONE = 0x00000000,
    ///If the format is a YUV format, indicates the Y component.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_Y    = 0x00000001,
    ///If the format is a YUV format, indicates the U component.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_U    = 0x00000002,
    ///If the format is a YUV format, indicates the V component.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_V    = 0x00000004,
    ///If the format is an RGB/BGR format, indicates the R component.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_R    = 0x00000001,
    ///If the format is an RGB/BGR format, indicates the G component.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_G    = 0x00000002,
    ///If the format is an RGB/BGR format, indicates the B component.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_B    = 0x00000004,
    ///If the format is an RGB/BGR format, indicates the A component.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_A    = 0x00000008,
}

///Specifies whether a video decode conversion operation is supported.
alias D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS = int;
enum : int
{
    ///The video decode conversion operation isn't supported.
    D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAG_NONE      = 0x00000000,
    ///The video decode conversion operation is supported.
    D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAG_SUPPORTED = 0x00000001,
}

///Specifies the scaling capabilities of the video scaler.
alias D3D12_VIDEO_SCALE_SUPPORT_FLAGS = int;
enum : int
{
    ///All possible output size width/height combinations that exist between the maximum size and minimum size for the
    ///extent, inclusive, are supported.
    D3D12_VIDEO_SCALE_SUPPORT_FLAG_NONE                 = 0x00000000,
    ///The scaler only supports output sizes at a power of two scale factors within the range. The x and y scale factors
    ///must be the same for both dimensions when this flag is set.
    D3D12_VIDEO_SCALE_SUPPORT_FLAG_POW2_ONLY            = 0x00000001,
    ///The scaler only supports output sizes with even output dimensions.
    D3D12_VIDEO_SCALE_SUPPORT_FLAG_EVEN_DIMENSIONS_ONLY = 0x00000002,
}

///Specifies the features that a video processor can support.
alias D3D12_VIDEO_PROCESS_FEATURE_FLAGS = int;
enum : int
{
    ///No features are supported.
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_NONE               = 0x00000000,
    ///The video processor can set alpha values on the output pixels. The alpha fill mode is used in
    ///D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC. D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_OPAQUE must be always supported. The
    ///background, destination, and source stream modes are only supported when the driver reports
    ///D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_FILL.
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_FILL         = 0x00000001,
    ///The video processor can perform luma keying. Luma keying is configured via the **D3D12_VIDEO_PROCESS_LUMA_KEY**
    ///member of the D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS structure. For more information see <a
    ///href=ns-d3d12video-d3d12_video_process_luma_key"">D3D12_VIDEO_PROCESS_LUMA_KEY</a>.
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_LUMA_KEY           = 0x00000002,
    ///The video processor can support 3D stereo video. For more information, see D3D12_VIDEO_FRAME_STEREO_FORMAT. All
    ///drivers setting this capability must support the following stereo formats:
    ///D3D12_VIDEO_PROCESS_STEREO_FORMAT_HORIZONTAL, D3D12_VIDEO_PROCESS_STEREO_FORMAT_VERTICAL, and
    ///D3D12_VIDEO_PROCESS_STEREO_FORMAT_SEPARATE.
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_STEREO             = 0x00000004,
    ///The driver can rotate the input data either 90, 180, or 270 degrees clockwise as part of the video processing
    ///operation.
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_ROTATION           = 0x00000008,
    ///The driver can flip the input data horizontally or vertically, together or separately with a video rotation
    ///operation.
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_FLIP               = 0x00000010,
    ///Alpha blending and a planar alpha may be set in the **AlphaBlending** member of the
    ///D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS structure. For more information see
    ///D3D12_VIDEO_PROCESS_ALPHA_BLENDING.
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_BLENDING     = 0x00000020,
    ///The driver supports changing the pixel aspect ratio. If the driver does not report this capability, then the
    ///**SourceAspectRatio** and **DestinationAspectRatio** members of D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS
    ///structure must indicate a 1:1 aspect ratio.
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_PIXEL_ASPECT_RATIO = 0x00000040,
}

///Specifies the automatic processing features that a video processor can support.
alias D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = int;
enum : int
{
    ///No automatic processing features are supported.
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_NONE                = 0x00000000,
    ///Denoise is supported.
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_DENOISE             = 0x00000001,
    ///Deringing is supported.
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_DERINGING           = 0x00000002,
    ///Edge enhancement is supported.
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_EDGE_ENHANCEMENT    = 0x00000004,
    ///Color correction is supported.
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_COLOR_CORRECTION    = 0x00000008,
    ///Flesh tone mapping is supported.
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_FLESH_TONE_MAPPING  = 0x00000010,
    ///Image stabilization is supported.
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_IMAGE_STABILIZATION = 0x00000020,
    ///Enhanced image resolution is supported.
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_SUPER_RESOLUTION    = 0x00000040,
    ///Anamorphic scaling is supported.
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_ANAMORPHIC_SCALING  = 0x00000080,
    ///Additional processing features, not described by the other flags, are available.
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_CUSTOM              = 0x80000000,
}

///Specifies an orientation operation to be performed by a video processor.
alias D3D12_VIDEO_PROCESS_ORIENTATION = int;
enum : int
{
    ///No change in orientation. 0 degrees.
    D3D12_VIDEO_PROCESS_ORIENTATION_DEFAULT                       = 0x00000000,
    ///The image is flipped horizontally.
    D3D12_VIDEO_PROCESS_ORIENTATION_FLIP_HORIZONTAL               = 0x00000001,
    ///The image is rotated 90 degrees clockwise.
    D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_90                  = 0x00000002,
    ///The image is rotated 90 degrees clockwise and then flipped horizontally.
    D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_90_FLIP_HORIZONTAL  = 0x00000003,
    ///The image is rotated 180 degrees clockwise.
    D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_180                 = 0x00000004,
    ///The image is flipped vertically.
    D3D12_VIDEO_PROCESS_ORIENTATION_FLIP_VERTICAL                 = 0x00000005,
    ///The image is rotated 270 degrees clockwise.
    D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_270                 = 0x00000006,
    ///The image is rotated 270 degrees clockwise and then flipped horizontally.
    D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_270_FLIP_HORIZONTAL = 0x00000007,
}

///Specifies flags for video processing input streams. Used by the
///[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS](ns-d3d12video-d3d12_video_process_input_stream_arguments.md) structure.
alias D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS = int;
enum : int
{
    ///No flags specified.
    D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_NONE                = 0x00000000,
    ///Set this flag when not processing frames in order, such as seeking between frames
    D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_FRAME_DISCONTINUITY = 0x00000001,
    ///Set this flag when applying video process operation to the same set of inputs.
    D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_FRAME_REPEAT        = 0x00000002,
}

///Specifies whether a video format and colorspace conversion operation is supported.
alias D3D12_VIDEO_PROCESS_SUPPORT_FLAGS = int;
enum : int
{
    ///The conversion from the source format and colorspace to destination format and colorspace are not supported.
    D3D12_VIDEO_PROCESS_SUPPORT_FLAG_NONE      = 0x00000000,
    ///The conversion from the source format and colorspace to destination format and colorspace are are supported.
    D3D12_VIDEO_PROCESS_SUPPORT_FLAG_SUPPORTED = 0x00000001,
}

///Defines search block sizes for video motion estimation.
alias D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE = int;
enum : int
{
    ///The search block size is 8x8 pixels.
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_8X8   = 0x00000000,
    ///The search block size is 16x16 pixels.
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_16X16 = 0x00000001,
}

///Specifies the motion estimation search block sizes that a video encoder supports.
alias D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS = int;
enum : int
{
    ///Search block size is not supported by the encoder.
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_NONE  = 0x00000000,
    ///The encoder supports a search block size of 8x8 pixels.
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_8X8   = 0x00000001,
    ///The encoder supports a search block size of 16x16 pixels.
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_16X16 = 0x00000002,
}

///Defines vector precision values for video motion estimation.
alias D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION = int;
enum : int
{
    ///The vector precision is quarter-pixel motion.
    D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_QUARTER_PEL = 0x00000000,
}

///Specifies the motion estimation vector precision that a video encoder supports.
alias D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS = int;
enum : int
{
    ///Vector precision is not supported by the encoder.
    D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAG_NONE        = 0x00000000,
    ///The vector precision is quarter-pixel motion.
    D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAG_QUARTER_PEL = 0x00000001,
}

///Specifies support for protected resources in video operations.
alias D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS = int;
enum : int
{
    ///Protected resources are not supported.
    D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAG_NONE      = 0x00000000,
    ///Protected resources are supported.
    D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAG_SUPPORTED = 0x00000001,
}

///Specifies the parameter stages for video extension commands.
alias D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE = int;
enum : int
{
    ///The parameter stage is in video extension command creation.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CREATION              = 0x00000000,
    ///The parameter stage is in video extension command initialization.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_INITIALIZATION        = 0x00000001,
    ///The parameter stage is in video extension command execution.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_EXECUTION             = 0x00000002,
    ///The parameter stage is input parameters passed to capabilities queries.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CAPS_INPUT            = 0x00000003,
    ///The parameter stage is output parameters passed to capabilities queries.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CAPS_OUTPUT           = 0x00000004,
    ///The parameter stage is device execution input.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_DEVICE_EXECUTE_INPUT  = 0x00000005,
    ///The parameter stage is device execution output.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_DEVICE_EXECUTE_OUTPUT = 0x00000006,
}

///Specifies the types of parameters for video extension commands.
alias D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE = int;
enum : int
{
    ///Unsigned 8-bit integer.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT8    = 0x00000000,
    ///Unsigned 16-bit integer.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT16   = 0x00000001,
    ///Unsigned 32-bit integer.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT32   = 0x00000002,
    ///Unsigned 64-bit integer.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT64   = 0x00000003,
    ///Signed 8-bit integer.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT8    = 0x00000004,
    ///Signed 16-bit integer.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT16   = 0x00000005,
    ///Signed 32-bit integer.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT32   = 0x00000006,
    ///Signed 64-bit integer.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT64   = 0x00000007,
    ///IEEE 32-bit floating point number
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_FLOAT    = 0x00000008,
    ///IEEE 64-bit floating point number
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_DOUBLE   = 0x00000009,
    ///A D3D12DDI_HRESOURCE handle. The caller must use resource barriers to transition to the state appropriate for the
    ///parameter. | D3D12_COMMAND_LIST_SUPPORT_FLAGS value | Read | Write |
    ///|-------------------|---------------------------|------------------------| |
    ///D3D12_COMMAND_LIST_SUPPORT_FLAG_VIDEO_DECODE | D3D12_RESOURCE_STATE_VIDEO_DECODE_READ |
    ///D3D12_RESOURCE_STATE_VIDEO_DECODE_WRITE | | D3D12_COMMAND_LIST_SUPPORT_FLAG_VIDEO_PROCESS |
    ///D3D12_RESOURCE_STATE_VIDEO_PROCESS_READ | D3D12_RESOURCE_STATE_VIDEO_PROCESS_WRITE | |
    ///D3D12_COMMAND_LIST_SUPPORT_FLAG_VIDEO_ENCODE | D3D12_RESOURCE_STATE_VIDEO_ENCODE_READ |
    ///D3D12_RESOURCE_STATE_VIDEO_ENCODE_WRITE |
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_RESOURCE = 0x0000000a,
}

///Specifies the usage of the associated video extension command parameter.
alias D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS = int;
enum : int
{
    ///None. Set for simple data type parameters.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_NONE  = 0x00000000,
    ///The resource parameter is read. This flag is for **ID3D12Resource** only and is not valid for simple data type
    ///parameters.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_READ  = 0x00000001,
    ///The resource parameter is written. This flag is for **ID3D12Resource** only and is not valid for simple data type
    ///parameters.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_WRITE = 0x00000002,
}

alias _DMO_INPUT_DATA_BUFFER_FLAGS = int;
enum : int
{
    DMO_INPUT_DATA_BUFFERF_SYNCPOINT     = 0x00000001,
    DMO_INPUT_DATA_BUFFERF_TIME          = 0x00000002,
    DMO_INPUT_DATA_BUFFERF_TIMELENGTH    = 0x00000004,
    DMO_INPUT_DATA_BUFFERF_DISCONTINUITY = 0x00000008,
}

alias _DMO_OUTPUT_DATA_BUFFER_FLAGS = int;
enum : int
{
    DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT     = 0x00000001,
    DMO_OUTPUT_DATA_BUFFERF_TIME          = 0x00000002,
    DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH    = 0x00000004,
    DMO_OUTPUT_DATA_BUFFERF_DISCONTINUITY = 0x00000008,
    DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE    = 0x01000000,
}

alias _DMO_INPUT_STATUS_FLAGS = int;
enum : int
{
    DMO_INPUT_STATUSF_ACCEPT_DATA = 0x00000001,
}

alias _DMO_INPUT_STREAM_INFO_FLAGS = int;
enum : int
{
    DMO_INPUT_STREAMF_WHOLE_SAMPLES            = 0x00000001,
    DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER = 0x00000002,
    DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE        = 0x00000004,
    DMO_INPUT_STREAMF_HOLDS_BUFFERS            = 0x00000008,
}

alias _DMO_OUTPUT_STREAM_INFO_FLAGS = int;
enum : int
{
    DMO_OUTPUT_STREAMF_WHOLE_SAMPLES            = 0x00000001,
    DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER = 0x00000002,
    DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE        = 0x00000004,
    DMO_OUTPUT_STREAMF_DISCARDABLE              = 0x00000008,
    DMO_OUTPUT_STREAMF_OPTIONAL                 = 0x00000010,
}

alias _DMO_SET_TYPE_FLAGS = int;
enum : int
{
    DMO_SET_TYPEF_TEST_ONLY = 0x00000001,
    DMO_SET_TYPEF_CLEAR     = 0x00000002,
}

alias _DMO_PROCESS_OUTPUT_FLAGS = int;
enum : int
{
    DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER = 0x00000001,
}

alias _DMO_INPLACE_PROCESS_FLAGS = int;
enum : int
{
    DMO_INPLACE_NORMAL = 0x00000000,
    DMO_INPLACE_ZERO   = 0x00000001,
}

alias _DMO_QUALITY_STATUS_FLAGS = int;
enum : int
{
    DMO_QUALITY_STATUS_ENABLED = 0x00000001,
}

alias _DMO_VIDEO_OUTPUT_STREAM_FLAGS = int;
enum : int
{
    DMO_VOSF_NEEDS_PREVIOUS_SAMPLE = 0x00000001,
}

///Defines the data types used for the codec and DSP properties that are accessed by using the methods of the
///IWMCodecProps interface.
alias WMT_PROP_DATATYPE = int;
enum : int
{
    ///Specifies a double-word value.
    WMT_PROP_TYPE_DWORD  = 0x00000000,
    ///Specifies a string value.
    WMT_PROP_TYPE_STRING = 0x00000001,
    ///Specifies a binary value.
    WMT_PROP_TYPE_BINARY = 0x00000002,
    ///Specifies a Boolean value.
    WMT_PROP_TYPE_BOOL   = 0x00000003,
    ///Specifies a quadruple-word value.
    WMT_PROP_TYPE_QWORD  = 0x00000004,
    ///Specifies a word value.
    WMT_PROP_TYPE_WORD   = 0x00000005,
    ///Specifies a GUID value.
    WMT_PROP_TYPE_GUID   = 0x00000006,
}

alias WMV_DYNAMIC_FLAGS = int;
enum : int
{
    WMV_DYNAMIC_BITRATE    = 0x00000001,
    WMV_DYNAMIC_RESOLUTION = 0x00000002,
    WMV_DYNAMIC_COMPLEXITY = 0x00000004,
}

alias MF_AUVRHP_ROOMMODEL = int;
enum : int
{
    VRHP_SMALLROOM      = 0x00000000,
    VRHP_MEDIUMROOM     = 0x00000001,
    VRHP_BIGROOM        = 0x00000002,
    VRHP_CUSTUMIZEDROOM = 0x00000003,
}

///Specifies the processing mode for the voice capture DSP. This enumeration is used with the
///MFPKEY_WMAAECMA_SYSTEM_MODE property.
alias AEC_SYSTEM_MODE = int;
enum : int
{
    ///AEC processing only.
    SINGLE_CHANNEL_AEC     = 0x00000000,
    ///Reserved.
    ADAPTIVE_ARRAY_ONLY    = 0x00000001,
    ///Microphone array processing only.
    OPTIBEAM_ARRAY_ONLY    = 0x00000002,
    ///Reserved.
    ADAPTIVE_ARRAY_AND_AEC = 0x00000003,
    ///Microphone array processing and AEC processing.
    OPTIBEAM_ARRAY_AND_AEC = 0x00000004,
    ///No microphone array processing and no AEC processing.
    SINGLE_CHANNEL_NSAGC   = 0x00000005,
    ///Uninitialized. This value is the initial value of the MFPKEY_WMAAECMA_SYSTEM_MODE property. Do not set this
    ///value.
    MODE_NOT_SET           = 0x00000006,
}

///Specifies the type of voice activity detection (VAD) for the voice capture DSP. This enumeration is used with the
///MFPKEY_WMAAECMA_FEATR_VAD property.
alias AEC_VAD_MODE = int;
enum : int
{
    ///Voice activity detection is disabled.
    AEC_VAD_DISABLED                = 0x00000000,
    ///General purpose VAD. This setting attempts to balance the false detection rate and the missed detection rate. The
    ///output can have the following values. <table> <tr> <th>Value</th> <th>Description</th> </tr> <tr> <td>0</td>
    ///<td>Non-speech.</td> </tr> <tr> <td>1</td> <td>Voiced speech.</td> </tr> <tr> <td>2</td> <td>Unvoiced
    ///speech.</td> </tr> <tr> <td>3</td> <td>Mixture of voiced and unvoiced speech.</td> </tr> </table>
    AEC_VAD_NORMAL                  = 0x00000001,
    ///Voice activity detection for automatic gain control and noise suppression. In this mode, the VAD threshold is
    ///higher than the normal mode, to reduce the false detection rate. The output distinguishes voiced speech from
    ///other sounds (non-speech or unvoiced speech). The output can have the following values. <table> <tr>
    ///<th>Value</th> <th>Description</th> </tr> <tr> <td>0</td> <td>Non-speech or unvoiced speech.</td> </tr> <tr>
    ///<td>1</td> <td>Voiced speech.</td> </tr> </table>
    AEC_VAD_FOR_AGC                 = 0x00000002,
    ///Voice activity detection for silence suppression. In this mode, the output distinguishes speech (voiced or
    ///unvoiced) from non-speech. The output can have the following values. <table> <tr> <th>Value</th>
    ///<th>Description</th> </tr> <tr> <td>0</td> <td>Non-speech.</td> </tr> <tr> <td>1</td> <td>Voiced or unvoiced
    ///speech.</td> </tr> </table>
    AEC_VAD_FOR_SILENCE_SUPPRESSION = 0x00000003,
}

alias AEC_INPUT_STREAM = int;
enum : int
{
    AEC_CAPTURE_STREAM   = 0x00000000,
    AEC_REFERENCE_STREAM = 0x00000001,
}

///Specifies how the voice capture DSP performs microphone array processing. This enumeration is used with the
///MFPKEY_WMAAECMA_FEATR_MICARR_MODE property.
alias MIC_ARRAY_MODE = int;
enum : int
{
    ///Use a single channel. Specify the channel number in the last 8 bits of the value.
    MICARRAY_SINGLE_CHAN = 0x00000000,
    ///Sum all of the channels.
    MICARRAY_SIMPLE_SUM  = 0x00000100,
    ///Use beam forming with a beam selected by the DSP. After processing starts, you can query which beam was selected
    ///by reading the MFPKEY_WMAAECMA_FEATR_MICARR_BEAM property.
    MICARRAY_SINGLE_BEAM = 0x00000200,
    ///Use beam forming with the center beam.
    MICARRAY_FIXED_BEAM  = 0x00000400,
    ///Use beam forming with a beam selected by the application. If you set this value, set the
    ///MFPKEY_WMAAECMA_FEATR_MICARR_BEAM property to specify the beam.
    MICARRAY_EXTERN_BEAM = 0x00000800,
}

///Specifies the processing mode of the Video Stabilization MFT.
alias MFVideoDSPMode = int;
enum : int
{
    ///Pass-through mode. Video stabilization is not applied.
    MFVideoDSPMode_Passthrough   = 0x00000001,
    ///Video stabilization is applied.
    MFVideoDSPMode_Stabilization = 0x00000004,
}

///The <b>TOC_POS_TYPE</b> enumeration contains members that specify the position type of a table of contents.
alias TOC_POS_TYPE = int;
enum : int
{
    ///Specifies that the table of contents is stored in the header of the media file.
    TOC_POS_INHEADER       = 0x00000000,
    ///Specifies that the table of contents is stored in the body of the media file as a top level object.
    TOC_POS_TOPLEVELOBJECT = 0x00000001,
}

alias FILE_OPENMODE = int;
enum : int
{
    OPENMODE_FAIL_IF_NOT_EXIST = 0x00000000,
    OPENMODE_FAIL_IF_EXIST     = 0x00000001,
    OPENMODE_RESET_IF_EXIST    = 0x00000002,
    OPENMODE_APPEND_IF_EXIST   = 0x00000003,
    OPENMODE_DELETE_IF_EXIST   = 0x00000004,
}

alias SEEK_ORIGIN = int;
enum : int
{
    _msoBegin   = 0x00000000,
    _msoCurrent = 0x00000001,
}

alias FILE_ACCESSMODE = int;
enum : int
{
    ACCESSMODE_READ            = 0x00000001,
    ACCESSMODE_WRITE           = 0x00000002,
    ACCESSMODE_READWRITE       = 0x00000003,
    ACCESSMODE_WRITE_EXCLUSIVE = 0x00000004,
}

alias DXVA_SampleFormat = int;
enum : int
{
    DXVA_SampleFormatMask                = 0x000000ff,
    DXVA_SampleUnknown                   = 0x00000000,
    DXVA_SamplePreviousFrame             = 0x00000001,
    DXVA_SampleProgressiveFrame          = 0x00000002,
    DXVA_SampleFieldInterleavedEvenFirst = 0x00000003,
    DXVA_SampleFieldInterleavedOddFirst  = 0x00000004,
    DXVA_SampleFieldSingleEven           = 0x00000005,
    DXVA_SampleFieldSingleOdd            = 0x00000006,
    DXVA_SampleSubStream                 = 0x00000007,
}

alias DXVA_VideoTransferFunction = int;
enum : int
{
    DXVA_VideoTransFuncShift         = 0x0000001b,
    DXVA_VideoTransFuncMask          = 0xf8000000,
    DXVA_VideoTransFunc_Unknown      = 0x00000000,
    DXVA_VideoTransFunc_10           = 0x00000001,
    DXVA_VideoTransFunc_18           = 0x00000002,
    DXVA_VideoTransFunc_20           = 0x00000003,
    DXVA_VideoTransFunc_22           = 0x00000004,
    DXVA_VideoTransFunc_22_709       = 0x00000005,
    DXVA_VideoTransFunc_22_240M      = 0x00000006,
    DXVA_VideoTransFunc_22_8bit_sRGB = 0x00000007,
    DXVA_VideoTransFunc_28           = 0x00000008,
}

alias DXVA_VideoPrimaries = int;
enum : int
{
    DXVA_VideoPrimariesShift          = 0x00000016,
    DXVA_VideoPrimariesMask           = 0x07c00000,
    DXVA_VideoPrimaries_Unknown       = 0x00000000,
    DXVA_VideoPrimaries_reserved      = 0x00000001,
    DXVA_VideoPrimaries_BT709         = 0x00000002,
    DXVA_VideoPrimaries_BT470_2_SysM  = 0x00000003,
    DXVA_VideoPrimaries_BT470_2_SysBG = 0x00000004,
    DXVA_VideoPrimaries_SMPTE170M     = 0x00000005,
    DXVA_VideoPrimaries_SMPTE240M     = 0x00000006,
    DXVA_VideoPrimaries_EBU3213       = 0x00000007,
    DXVA_VideoPrimaries_SMPTE_C       = 0x00000008,
}

alias DXVA_VideoLighting = int;
enum : int
{
    DXVA_VideoLightingShift    = 0x00000012,
    DXVA_VideoLightingMask     = 0x003c0000,
    DXVA_VideoLighting_Unknown = 0x00000000,
    DXVA_VideoLighting_bright  = 0x00000001,
    DXVA_VideoLighting_office  = 0x00000002,
    DXVA_VideoLighting_dim     = 0x00000003,
    DXVA_VideoLighting_dark    = 0x00000004,
}

alias DXVA_VideoTransferMatrix = int;
enum : int
{
    DXVA_VideoTransferMatrixShift      = 0x0000000f,
    DXVA_VideoTransferMatrixMask       = 0x00038000,
    DXVA_VideoTransferMatrix_Unknown   = 0x00000000,
    DXVA_VideoTransferMatrix_BT709     = 0x00000001,
    DXVA_VideoTransferMatrix_BT601     = 0x00000002,
    DXVA_VideoTransferMatrix_SMPTE240M = 0x00000003,
}

alias DXVA_NominalRange = int;
enum : int
{
    DXVA_NominalRangeShift    = 0x0000000c,
    DXVA_NominalRangeMask     = 0x00007000,
    DXVA_NominalRange_Unknown = 0x00000000,
    DXVA_NominalRange_Normal  = 0x00000001,
    DXVA_NominalRange_Wide    = 0x00000002,
    DXVA_NominalRange_0_255   = 0x00000001,
    DXVA_NominalRange_16_235  = 0x00000002,
    DXVA_NominalRange_48_208  = 0x00000003,
}

alias DXVA_VideoChromaSubsampling = int;
enum : int
{
    DXVA_VideoChromaSubsamplingShift                           = 0x00000008,
    DXVA_VideoChromaSubsamplingMask                            = 0x00000f00,
    DXVA_VideoChromaSubsampling_Unknown                        = 0x00000000,
    DXVA_VideoChromaSubsampling_ProgressiveChroma              = 0x00000008,
    DXVA_VideoChromaSubsampling_Horizontally_Cosited           = 0x00000004,
    DXVA_VideoChromaSubsampling_Vertically_Cosited             = 0x00000002,
    DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes = 0x00000001,
    DXVA_VideoChromaSubsampling_MPEG2                          = 0x00000005,
    DXVA_VideoChromaSubsampling_MPEG1                          = 0x00000001,
    DXVA_VideoChromaSubsampling_DV_PAL                         = 0x00000006,
    DXVA_VideoChromaSubsampling_Cosited                        = 0x00000007,
}

alias DXVA_VideoProcessCaps = int;
enum : int
{
    DXVA_VideoProcess_None               = 0x00000000,
    DXVA_VideoProcess_YUV2RGB            = 0x00000001,
    DXVA_VideoProcess_StretchX           = 0x00000002,
    DXVA_VideoProcess_StretchY           = 0x00000004,
    DXVA_VideoProcess_AlphaBlend         = 0x00000008,
    DXVA_VideoProcess_SubRects           = 0x00000010,
    DXVA_VideoProcess_SubStreams         = 0x00000020,
    DXVA_VideoProcess_SubStreamsExtended = 0x00000040,
    DXVA_VideoProcess_YUV2RGBExtended    = 0x00000080,
    DXVA_VideoProcess_AlphaBlendExtended = 0x00000100,
}

alias DXVA_DeinterlaceTech = int;
enum : int
{
    DXVA_DeinterlaceTech_Unknown                = 0x00000000,
    DXVA_DeinterlaceTech_BOBLineReplicate       = 0x00000001,
    DXVA_DeinterlaceTech_BOBVerticalStretch     = 0x00000002,
    DXVA_DeinterlaceTech_BOBVerticalStretch4Tap = 0x00000100,
    DXVA_DeinterlaceTech_MedianFiltering        = 0x00000004,
    DXVA_DeinterlaceTech_EdgeFiltering          = 0x00000010,
    DXVA_DeinterlaceTech_FieldAdaptive          = 0x00000020,
    DXVA_DeinterlaceTech_PixelAdaptive          = 0x00000040,
    DXVA_DeinterlaceTech_MotionVectorSteered    = 0x00000080,
}

alias DXVA_SampleFlags = int;
enum : int
{
    DXVA_SampleFlagsMask              = 0x0000000f,
    DXVA_SampleFlag_Palette_Changed   = 0x00000001,
    DXVA_SampleFlag_SrcRect_Changed   = 0x00000002,
    DXVA_SampleFlag_DstRect_Changed   = 0x00000004,
    DXVA_SampleFlag_ColorData_Changed = 0x00000008,
}

alias DXVA_DestinationFlags = int;
enum : int
{
    DXVA_DestinationFlagMask                = 0x0000000f,
    DXVA_DestinationFlag_Background_Changed = 0x00000001,
    DXVA_DestinationFlag_TargetRect_Changed = 0x00000002,
    DXVA_DestinationFlag_ColorData_Changed  = 0x00000004,
    DXVA_DestinationFlag_Alpha_Changed      = 0x00000008,
}

alias DXVA_ProcAmpControlProp = int;
enum : int
{
    DXVA_ProcAmp_None       = 0x00000000,
    DXVA_ProcAmp_Brightness = 0x00000001,
    DXVA_ProcAmp_Contrast   = 0x00000002,
    DXVA_ProcAmp_Hue        = 0x00000004,
    DXVA_ProcAmp_Saturation = 0x00000008,
}

///Describes how a video stream is interlaced.
alias DXVAHD_FRAME_FORMAT = int;
enum : int
{
    ///Frames are progressive.
    DXVAHD_FRAME_FORMAT_PROGRESSIVE                   = 0x00000000,
    ///Frames are interlaced. The top field of each frame is displayed first.
    DXVAHD_FRAME_FORMAT_INTERLACED_TOP_FIELD_FIRST    = 0x00000001,
    ///Frame are interlaced. The bottom field of each frame is displayed first.
    DXVAHD_FRAME_FORMAT_INTERLACED_BOTTOM_FIELD_FIRST = 0x00000002,
}

///Specifies the intended use for a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.
alias DXVAHD_DEVICE_USAGE = int;
enum : int
{
    ///Normal video playback. The graphics driver should expose a set of capabilities that are appropriate for real-time
    ///video playback.
    DXVAHD_DEVICE_USAGE_PLAYBACK_NORMAL = 0x00000000,
    ///Optimal speed. The graphics driver should expose a minimal set of capabilities that are optimized for
    ///performance. Use this setting if you want better performance and can accept some reduction in video quality. For
    ///example, you might use this setting in power-saving mode or to play video thumbnails.
    DXVAHD_DEVICE_USAGE_OPTIMAL_SPEED   = 0x00000001,
    ///Optimal quality. The grahics driver should expose its maximum set of capabilities. Specify this setting to get
    ///the best video quality possible. It is appropriate for tasks such as video editing, when quality is more
    ///important than speed. It is not appropriate for real-time playback.
    DXVAHD_DEVICE_USAGE_OPTIMAL_QUALITY = 0x00000002,
}

///Specifies the type of video surface created by a Microsoft DirectX Video Acceleration High Definition (DXVA-HD)
///device.
alias DXVAHD_SURFACE_TYPE = int;
enum : int
{
    ///A surface for an input stream. This surface type is equivalent to an off-screen plain surface in Microsoft
    ///Direct3D. The application can use the surface in Direct3D calls.
    DXVAHD_SURFACE_TYPE_VIDEO_INPUT         = 0x00000000,
    ///A private surface for an input stream. This surface type is equivalent to an off-screen plain surface, except
    ///that the application cannot use the surface in Direct3D calls.
    DXVAHD_SURFACE_TYPE_VIDEO_INPUT_PRIVATE = 0x00000001,
    ///A surface for an output stream. This surface type is equivalent to an off-screen plain surface in Direct3D. The
    ///application can use the surface in Direct3D calls. This surface type is recommended for video processing
    ///applications that need to lock the surface and access the surface memory. For video playback with optimal
    ///performance, a render-target surface or swap chain is recommended instead.
    DXVAHD_SURFACE_TYPE_VIDEO_OUTPUT        = 0x00000002,
}

///Specifies the type of Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.
alias DXVAHD_DEVICE_TYPE = int;
enum : int
{
    ///Hardware device. Video processing is performed in the GPU by the driver.
    DXVAHD_DEVICE_TYPE_HARDWARE  = 0x00000000,
    ///Software device. Video processing is performed in the CPU by a software plug-in.
    DXVAHD_DEVICE_TYPE_SOFTWARE  = 0x00000001,
    ///Reference device. Video processing is performed in the CPU by a software plug-in.
    DXVAHD_DEVICE_TYPE_REFERENCE = 0x00000002,
    ///Other. The device is neither a hardware device nor a software plug-in.
    DXVAHD_DEVICE_TYPE_OTHER     = 0x00000003,
}

///Defines video processing capabilities for a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.
alias DXVAHD_DEVICE_CAPS = int;
enum : int
{
    ///The device can blend video content in linear color space. Most video content is gamma corrected, resulting in
    ///nonlinear values. If the DXVA-HD device sets this flag, it means the device converts colors to linear space
    ///before blending, which produces better results.
    DXVAHD_DEVICE_CAPS_LINEAR_SPACE            = 0x00000001,
    ///The device supports the xvYCC color space for YCbCr data.
    DXVAHD_DEVICE_CAPS_xvYCC                   = 0x00000002,
    ///The device can perform range conversion when the input and output are both RGB but use different color ranges
    ///(0-255 or 16-235, for 8-bit RGB).
    DXVAHD_DEVICE_CAPS_RGB_RANGE_CONVERSION    = 0x00000004,
    ///The device can apply a matrix conversion to YCbCr values when the input and output are both YCbCr. For example,
    ///the driver can convert colors from BT.601 to BT.709.
    DXVAHD_DEVICE_CAPS_YCbCr_MATRIX_CONVERSION = 0x00000008,
}

///Defines features that a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device can support.
alias DXVAHD_FEATURE_CAPS = int;
enum : int
{
    ///The device can set the alpha values on the video output. See DXVAHD_BLT_STATE_ALPHA_FILL_DATA.
    DXVAHD_FEATURE_CAPS_ALPHA_FILL    = 0x00000001,
    ///The device can downsample the video output. See DXVAHD_BLT_STATE_CONSTRICTION_DATA.
    DXVAHD_FEATURE_CAPS_CONSTRICTION  = 0x00000002,
    ///The device can perform luma keying. See DXVAHD_STREAM_STATE_LUMA_KEY_DATA.
    DXVAHD_FEATURE_CAPS_LUMA_KEY      = 0x00000004,
    ///The device can apply alpha values from color palette entries. See DXVAHD_STREAM_STATE_ALPHA_DATA.
    DXVAHD_FEATURE_CAPS_ALPHA_PALETTE = 0x00000008,
}

///Defines capabilities related to image adjustment and filtering for a Microsoft DirectX Video Acceleration High
///Definition (DXVA-HD) device.
alias DXVAHD_FILTER_CAPS = int;
enum : int
{
    ///The device can adjust the brightness level.
    DXVAHD_FILTER_CAPS_BRIGHTNESS         = 0x00000001,
    ///The device can adjust the contrast level.
    DXVAHD_FILTER_CAPS_CONTRAST           = 0x00000002,
    ///The device can adjust hue.
    DXVAHD_FILTER_CAPS_HUE                = 0x00000004,
    ///The device can adjust the saturation level.
    DXVAHD_FILTER_CAPS_SATURATION         = 0x00000008,
    ///The device can perform noise reduction.
    DXVAHD_FILTER_CAPS_NOISE_REDUCTION    = 0x00000010,
    ///The device can perform edge enhancement.
    DXVAHD_FILTER_CAPS_EDGE_ENHANCEMENT   = 0x00000020,
    ///The device can perform <i>anamorphic scaling</i>. Anamorphic scaling can be used to stretch 4:3 content to a
    ///widescreen 16:9 aspect ratio.
    DXVAHD_FILTER_CAPS_ANAMORPHIC_SCALING = 0x00000040,
}

///Defines capabilities related to input formats for a Microsoft DirectX Video Acceleration High Definition (DXVA-HD)
///device.
alias DXVAHD_INPUT_FORMAT_CAPS = int;
enum : int
{
    ///The device can deinterlace an input stream that contains interlaced RGB video.
    DXVAHD_INPUT_FORMAT_CAPS_RGB_INTERLACED     = 0x00000001,
    ///The device can perform color adjustment on RGB video.
    DXVAHD_INPUT_FORMAT_CAPS_RGB_PROCAMP        = 0x00000002,
    ///The device can perform luma keying on RGB video.
    DXVAHD_INPUT_FORMAT_CAPS_RGB_LUMA_KEY       = 0x00000004,
    ///The device can deinterlace input streams with palettized color formats.
    DXVAHD_INPUT_FORMAT_CAPS_PALETTE_INTERLACED = 0x00000008,
}

///Specifies the processing capabilities of a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video
///processor.
alias DXVAHD_PROCESSOR_CAPS = int;
enum : int
{
    ///The video processor can perform blend deinterlacing. In <i>blend deinterlacing</i>, the two fields from an
    ///interlaced frame are blended into a single progressive frame. A video processor uses blend deinterlacing when it
    ///deinterlaces at half rate, as when converting 60i to 30p. Blend deinterlacing does not require reference frames.
    DXVAHD_PROCESSOR_CAPS_DEINTERLACE_BLEND               = 0x00000001,
    ///The video processor can perform bob deinterlacing. In <i>bob deinterlacing</i>, missing field lines are
    ///interpolated from the lines above and below. Bob deinterlacing does not require reference frames.
    DXVAHD_PROCESSOR_CAPS_DEINTERLACE_BOB                 = 0x00000002,
    ///The video processor can perform adaptive deinterlacing. <i>Adaptive deinterlacing</i> uses spatial or temporal
    ///interpolation, and switches between the two on a field-by-field basis, depending on the amount of motion. If the
    ///video processor does not receive enough reference frames to perform adaptive deinterlacing, it falls back to bob
    ///deinterlacing.
    DXVAHD_PROCESSOR_CAPS_DEINTERLACE_ADAPTIVE            = 0x00000004,
    ///The video processor can perform motion-compensated deinterlacing. <i>Motion-compensated deinterlacing</i> uses
    ///motion vectors to recreate missing lines. If the video processor does not receive enough reference frames to
    ///perform motion-compensated deinterlacing, it falls back to bob deinterlacing.
    DXVAHD_PROCESSOR_CAPS_DEINTERLACE_MOTION_COMPENSATION = 0x00000008,
    ///The video processor can perform inverse telecine (IVTC). If the video processor supports this capability, the
    ///<b>ITelecineCaps</b> member of the DXVAHD_VPCAPS structure specifies which IVTC modes are supported.
    DXVAHD_PROCESSOR_CAPS_INVERSE_TELECINE                = 0x00000010,
    ///The video processor can convert the frame rate by interpolating frames.
    DXVAHD_PROCESSOR_CAPS_FRAME_RATE_CONVERSION           = 0x00000020,
}

///Specifies the inverse telecine (IVTC) capabilities of a Microsoft DirectX Video Acceleration High Definition
///(DXVA-HD) video processor.
alias DXVAHD_ITELECINE_CAPS = int;
enum : int
{
    ///The video processor can reverse 3:2 pulldown.
    DXVAHD_ITELECINE_CAPS_32           = 0x00000001,
    ///The video processor can reverse 2:2 pulldown.
    DXVAHD_ITELECINE_CAPS_22           = 0x00000002,
    ///The video processor can reverse 2:2:2:4 pulldown.
    DXVAHD_ITELECINE_CAPS_2224         = 0x00000004,
    ///The video processor can reverse 2:3:3:2 pulldown.
    DXVAHD_ITELECINE_CAPS_2332         = 0x00000008,
    ///The video processor can reverse 3:2:3:2:2 pulldown.
    DXVAHD_ITELECINE_CAPS_32322        = 0x00000010,
    ///The video processor can reverse 5:5 pulldown.
    DXVAHD_ITELECINE_CAPS_55           = 0x00000020,
    ///The video processor can reverse 6:4 pulldown.
    DXVAHD_ITELECINE_CAPS_64           = 0x00000040,
    ///The video processor can reverse 8:7 pulldown.
    DXVAHD_ITELECINE_CAPS_87           = 0x00000080,
    ///The video processor can reverse 2:2:2:2:2:2:2:2:2:2:2:3 pulldown.
    DXVAHD_ITELECINE_CAPS_222222222223 = 0x00000100,
    ///The video processor can reverse other telecine modes not listed here.
    DXVAHD_ITELECINE_CAPS_OTHER        = 0x80000000,
}

///Specifies image filters for Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video processing.
alias DXVAHD_FILTER = int;
enum : int
{
    ///Adjusts brightness.
    DXVAHD_FILTER_BRIGHTNESS         = 0x00000000,
    ///Adjusts contrast.
    DXVAHD_FILTER_CONTRAST           = 0x00000001,
    ///Adjusts hue.
    DXVAHD_FILTER_HUE                = 0x00000002,
    ///Adjusts saturation.
    DXVAHD_FILTER_SATURATION         = 0x00000003,
    ///Applies noise reduction.
    DXVAHD_FILTER_NOISE_REDUCTION    = 0x00000004,
    ///Applies edge enhancement.
    DXVAHD_FILTER_EDGE_ENHANCEMENT   = 0x00000005,
    ///Performs <i>anamorphic scaling</i>. Anamorphic scaling can be used to stretch 4:3 content to a widescreen 16:9
    ///aspect ratio.
    DXVAHD_FILTER_ANAMORPHIC_SCALING = 0x00000006,
}

///Specifies state parameters for blit operations when using Microsoft DirectX Video Acceleration High Definition
///(DXVA-HD). To set a state parameter, call the IDXVAHD_VideoProcessor::SetVideoProcessBltState method. This method
///takes a <b>DXVAHD_BLT_STATE</b> value and a byte array as input. The byte array contains state data, the structure of
///which is defined by the <b>DXVAHD_BLT_STATE</b> value.
alias DXVAHD_BLT_STATE = int;
enum : int
{
    ///Specifies the target rectangle, which is the area within the destination surface where the output will be drawn.
    ///The state data is a DXVAHD_BLT_STATE_TARGET_RECT_DATA structure.
    DXVAHD_BLT_STATE_TARGET_RECT        = 0x00000000,
    ///Specifies the background color. The state data is a DXVAHD_BLT_STATE_BACKGROUND_COLOR_DATA structure.
    DXVAHD_BLT_STATE_BACKGROUND_COLOR   = 0x00000001,
    ///Specifies the output color space. The state data is a DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA structure.
    DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE = 0x00000002,
    ///Specifies how DXVA-HD device calculates output alpha values. The state data is a DXVAHD_BLT_STATE_ALPHA_FILL_DATA
    ///structure.
    DXVAHD_BLT_STATE_ALPHA_FILL         = 0x00000003,
    ///Specifies the amount of downsampling to perform on the output. The state data is a
    ///DXVAHD_BLT_STATE_CONSTRICTION_DATA structure.
    DXVAHD_BLT_STATE_CONSTRICTION       = 0x00000004,
    ///Specifies that the state data contains a private DXVA-HD blit state. Use this state for proprietary or
    ///device-specific parameters. The state data is a DXVAHD_BLT_STATE_PRIVATE_DATA structure.
    DXVAHD_BLT_STATE_PRIVATE            = 0x000003e8,
}

///Specifies how the output alpha values are calculated for Microsoft DirectX Video Acceleration High Definition
///(DXVA-HD) blit operations.
alias DXVAHD_ALPHA_FILL_MODE = int;
enum : int
{
    ///Alpha values inside the target rectangle are set to opaque.
    DXVAHD_ALPHA_FILL_MODE_OPAQUE        = 0x00000000,
    ///Alpha values inside the target rectangle are set to the alpha value specified in the background color. See
    ///DXVAHD_BLT_STATE_BACKGROUND_COLOR.
    DXVAHD_ALPHA_FILL_MODE_BACKGROUND    = 0x00000001,
    ///Existing alpha values remain unchanged in the output surface.
    DXVAHD_ALPHA_FILL_MODE_DESTINATION   = 0x00000002,
    ///Alpha values from the input stream are scaled and copied to the corresponding destination rectangle for that
    ///stream. If the input stream does not have alpha data, the DXVA-HD device sets the alpha values in the target
    ///rectangle to an opaque value. If the input stream is disabled or the source rectangle is empty, the alpha values
    ///in the target rectangle are not modified.
    DXVAHD_ALPHA_FILL_MODE_SOURCE_STREAM = 0x00000003,
}

///Specifies state parameters for an input stream to a Microsoft DirectX Video Acceleration High Definition (DXVA-HD)
///video processor. To set a state parameter, call IDXVAHD_VideoProcessor::SetVideoProcessStreamState. This method takes
///a <b>DXVAHD_STREAM_STATE</b> value and a byte array as input. The byte array contains state data, the structure of
///which is defined by the <b>DXVAHD_STREAM_STATE</b> value.
alias DXVAHD_STREAM_STATE = int;
enum : int
{
    ///Specifies the video format of the input stream. The state data is a DXVAHD_STREAM_STATE_D3DFORMAT_DATA structure.
    DXVAHD_STREAM_STATE_D3DFORMAT                 = 0x00000000,
    ///Specifies how the input stream is interlaced. The state data is a DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA
    ///structure.
    DXVAHD_STREAM_STATE_FRAME_FORMAT              = 0x00000001,
    ///Specifies the color space for the input stream. The state data is a DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA
    ///structure.
    DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE         = 0x00000002,
    ///Specifies the output frame rate. The state data is a DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA structure.
    DXVAHD_STREAM_STATE_OUTPUT_RATE               = 0x00000003,
    ///Specifies the source rectangle. The source rectangle defines which portion of the input sample is blitted to the
    ///destination surface. The state data is a DXVAHD_STREAM_STATE_SOURCE_RECT_DATA structure.
    DXVAHD_STREAM_STATE_SOURCE_RECT               = 0x00000004,
    ///Specifies the destination rectangle. The destination rectangle defines which portion of the destination rectangle
    ///receives the blit. The state data is a DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA structure.
    DXVAHD_STREAM_STATE_DESTINATION_RECT          = 0x00000005,
    ///Specifies the planar alpha value for this input stream. The state data is a DXVAHD_STREAM_STATE_ALPHA_DATA
    ///structure.
    DXVAHD_STREAM_STATE_ALPHA                     = 0x00000006,
    ///Specifies the color-palette entries. The state data is a DXVAHD_STREAM_STATE_PALETTE_DATA structure. This setting
    ///is used for palettized input formats, such as AI44 and IA44.
    DXVAHD_STREAM_STATE_PALETTE                   = 0x00000007,
    ///Specifies the luma key. The state data is a DXVAHD_STREAM_STATE_LUMA_KEY_DATA structure. This state is applicable
    ///only if the device supports luma keying. To find out if the device supports luma keying, check for the
    ///<b>DXVAHD_FEATURE_CAPS_LUMA_KEY</b> flag in the <b>FeatureCaps </b> member of the DXVAHD_VPDEVCAPS capabilities
    ///structure.
    DXVAHD_STREAM_STATE_LUMA_KEY                  = 0x00000008,
    ///Specifies the pixel aspect ratio of the source and destination surfaces. The state data is a
    ///DXVAHD_STREAM_STATE_ASPECT_RATIO_DATA structure.
    DXVAHD_STREAM_STATE_ASPECT_RATIO              = 0x00000009,
    ///Specifies the brightness filter. The state data is a DXVAHD_STREAM_STATE_FILTER_DATA structure.
    DXVAHD_STREAM_STATE_FILTER_BRIGHTNESS         = 0x00000064,
    ///Specifies the contrast filter. The state data is a DXVAHD_STREAM_STATE_FILTER_DATA structure.
    DXVAHD_STREAM_STATE_FILTER_CONTRAST           = 0x00000065,
    ///Specifies the hue filter. The state data is a DXVAHD_STREAM_STATE_FILTER_DATA structure.
    DXVAHD_STREAM_STATE_FILTER_HUE                = 0x00000066,
    ///Specifies the saturation filter. The state data is a DXVAHD_STREAM_STATE_FILTER_DATA structure.
    DXVAHD_STREAM_STATE_FILTER_SATURATION         = 0x00000067,
    ///Specifies the noise-reduction filter. The state data is a DXVAHD_STREAM_STATE_FILTER_DATA structure.
    DXVAHD_STREAM_STATE_FILTER_NOISE_REDUCTION    = 0x00000068,
    ///Specifies the edge-enhancement filter. The state data is a DXVAHD_STREAM_STATE_FILTER_DATA structure.
    DXVAHD_STREAM_STATE_FILTER_EDGE_ENHANCEMENT   = 0x00000069,
    ///Specifies the anamorphic-scaling value. The state data is a DXVAHD_STREAM_STATE_FILTER_DATA structure.
    DXVAHD_STREAM_STATE_FILTER_ANAMORPHIC_SCALING = 0x0000006a,
    ///Specifies that the state data contains a private DXVA-HD stream state. The state data is a
    ///DXVAHD_STREAM_STATE_PRIVATE_DATA structure. Use this state for proprietary or device-specific parameters.
    DXVAHD_STREAM_STATE_PRIVATE                   = 0x000003e8,
}

///Specifies the output frame rates for an input stream, when using Microsoft DirectX Video Acceleration High Definition
///(DXVA-HD). This enumeration type is used in the DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA structure.
alias DXVAHD_OUTPUT_RATE = int;
enum : int
{
    ///The frame output is at the normal rate. For progressive input, every frame produces one output frame. For
    ///interlaced input, every frame (two fields) produces two progressive output frames.
    DXVAHD_OUTPUT_RATE_NORMAL = 0x00000000,
    ///The frame output is at half rate. For progressive input, every frame produces one output frame, just as with
    ///<b>DXVAHD_OUTPUT_RATE_NORMAL</b>. For interlaced input, every frame produces one progressive output frame.
    DXVAHD_OUTPUT_RATE_HALF   = 0x00000001,
    ///Frame output is at a custom rate. Use this value for frame-rate conversion or inverse telecine. The exact rate is
    ///given in the <b>OutputRate</b> member of the DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA structure. To get the list of
    ///custom rates supported by the video processor, call the IDXVAHD_Device::GetVideoProcessorCustomRates method.
    DXVAHD_OUTPUT_RATE_CUSTOM = 0x00000002,
}

///Describes the content of a video sample. These flags are used in the DXVA2_ExtendedFormat structure.
alias DXVA2_SampleFormat = int;
enum : int
{
    ///Bitmask to validate flag values. This value is not a valid flag.
    DXVA2_SampleFormatMask                = 0x000000ff,
    ///Unknown format. Default to DXVA2_SampleProgressiveFrame.
    DXVA2_SampleUnknown                   = 0x00000000,
    ///The sample contains a progressive (non-interlaced) frame.
    DXVA2_SampleProgressiveFrame          = 0x00000002,
    ///The sample contains two interleaved fields. The even field should be displayed first.
    DXVA2_SampleFieldInterleavedEvenFirst = 0x00000003,
    ///The sample contains two interleaved fields. The odd field should be displayed first.
    DXVA2_SampleFieldInterleavedOddFirst  = 0x00000004,
    ///The sample contains a single even field.
    DXVA2_SampleFieldSingleEven           = 0x00000005,
    ///The sample contains a single odd field.
    DXVA2_SampleFieldSingleOdd            = 0x00000006,
    ///The sample contains a video substream frame. Use this value for substream mixing.
    DXVA2_SampleSubStream                 = 0x00000007,
}

///Describes how chroma values are positioned relative to the luma samples in a YUV video frame. These flags are used in
///the DXVA2_ExtendedFormat structure.
alias DXVA2_VideoChromaSubSampling = int;
enum : int
{
    ///Bitmask to validate flag values. This value is not a valid flag.
    DXVA2_VideoChromaSubsamplingMask                            = 0x0000000f,
    ///Unknown encoding scheme.
    DXVA2_VideoChromaSubsampling_Unknown                        = 0x00000000,
    ///Chroma should be reconstructed as if the underlying video was progressive content, rather than skipping fields or
    ///applying chroma filtering to minimize artifacts from reconstructing 4:2:0 interlaced chroma.
    DXVA2_VideoChromaSubsampling_ProgressiveChroma              = 0x00000008,
    ///Horizontally cosited. Chroma samples are aligned horizontally with multiples of the luma samples. If this flag is
    ///not set, chroma samples are located 1/2 pixel to the right of the corresponding luma samples.
    DXVA2_VideoChromaSubsampling_Horizontally_Cosited           = 0x00000004,
    ///Vertically cosited. Chroma samples are aligned vertically with multiples of the luma samples. If this flag is not
    ///set, chroma samples are located 1/2 pixel down from the corresponding luma samples.
    DXVA2_VideoChromaSubsampling_Vertically_Cosited             = 0x00000002,
    ///The chroma planes are vertically aligned. If this flag is not set, chroma planes are out of phase by 1/2 chroma
    ///sample, and the Cb and Cr samples are sited on alternate lines.
    DXVA2_VideoChromaSubsampling_Vertically_AlignedChromaPlanes = 0x00000001,
    ///Specifies the chroma encoding scheme for MPEG-2 video. Chroma samples are aligned horizontally with the luma
    ///samples, but are not aligned vertically. The U and V planes are aligned vertically.
    DXVA2_VideoChromaSubsampling_MPEG2                          = 0x00000005,
    ///Specifies the chroma encoding scheme for MPEG-1 video.
    DXVA2_VideoChromaSubsampling_MPEG1                          = 0x00000001,
    ///Specifies the chroma encoding scheme for PAL DV video.
    DXVA2_VideoChromaSubsampling_DV_PAL                         = 0x00000006,
    ///Horizontally and vertically cosited. Chroma samples are aligned vertically and horizontally with the luma
    ///samples. YUV formats such as 4:4:4, 4:2:2, and 4:1:1 are always cosited in both directions and should use this
    ///flag.
    DXVA2_VideoChromaSubsampling_Cosited                        = 0x00000007,
}

///Describes how to map color data to a normalized [0...1] range. These flags are used in the DXVA2_ExtendedFormat
///structure. They indicate whether the range of color values includes headroom (values above 100% white) and toeroom
///(values below reference black).
alias DXVA2_NominalRange = int;
enum : int
{
    ///Bitmask to validate flag values. This value is not a valid flag.
    DXVA2_NominalRangeMask     = 0x00000007,
    ///Unknown or unspecified nominal range. If this value is used in the <b>DestFormat</b> member of the
    ///DXVA2_VideoProcessBltParams structure, the driver will determine the optimal nominal range based on the
    ///destination color space. For example, the destination surface is usually sRGB, which has a nominal range of 0-255
    ///per channel. However, a driver might use a technique such as automatic gain control to maximize the dynamic range
    ///while preserving values above reference white.
    DXVA2_NominalRange_Unknown = 0x00000000,
    ///Equivalent to DXVA2_NominalRange_0_255.
    DXVA2_NominalRange_Normal  = 0x00000001,
    ///Equivalent to DXVA2_NominalRange_16_235.
    DXVA2_NominalRange_Wide    = 0x00000002,
    ///The normalized range [0...1] maps to [0...255] for 8-bit samples or [0...1023] for 10-bit samples.
    DXVA2_NominalRange_0_255   = 0x00000001,
    ///The normalized range [0...1] maps to [16...235] for 8-bit samples or [64...940] for 10-bit samples.
    DXVA2_NominalRange_16_235  = 0x00000002,
    ///The normalized range [0..1] maps to [48...208] for 8-bit samples or [192...832] for 10-bit samples.
    DXVA2_NominalRange_48_208  = 0x00000003,
}

///Describes the conversion matrices between Y'PbPr (component video) and studio R'G'B'. These flags are used in the
///DXVA2_ExtendedFormat structure.
alias DXVA2_VideoTransferMatrix = int;
enum : int
{
    ///Bitmask to validate flag values. This value is not a valid flag.
    DXVA2_VideoTransferMatrixMask       = 0x00000007,
    ///Unknown. For standard-definition content, treat as DXVA2_VideoTransferMatrix_BT601. For high-definition content,
    ///treat as DXVA2_VideoTransferMatrix_BT709. (High-definition content is defined for this purpose as anything with a
    ///source height greater than 576 lines.)
    DXVA2_VideoTransferMatrix_Unknown   = 0x00000000,
    ///ITU-R BT.709 transfer matrix.
    DXVA2_VideoTransferMatrix_BT709     = 0x00000001,
    ///ITU-R BT.601 transfer matrix. Also used for SMPTE 170 and ITU-R BT.470-2 System B,G.
    DXVA2_VideoTransferMatrix_BT601     = 0x00000002,
    ///SMPTE 240M transfer matrix.
    DXVA2_VideoTransferMatrix_SMPTE240M = 0x00000003,
}

///Describes the intended lighting conditions for viewing video content. These flags are used in the
///DXVA2_ExtendedFormat structure.
alias DXVA2_VideoLighting = int;
enum : int
{
    ///Bitmask to validate flag values. This value is not a valid flag.
    DXVA2_VideoLightingMask     = 0x0000000f,
    ///Unknown. Treat as DXVA2_VideoLighting_dim.
    DXVA2_VideoLighting_Unknown = 0x00000000,
    ///Outdoor lighting.
    DXVA2_VideoLighting_bright  = 0x00000001,
    ///Medium brightness; for example, an office.
    DXVA2_VideoLighting_office  = 0x00000002,
    ///Dim; for example, a living room with a television and some additional low lighting.
    DXVA2_VideoLighting_dim     = 0x00000003,
    ///Dark; for example, a movie theater.
    DXVA2_VideoLighting_dark    = 0x00000004,
}

///Specifies the color primaries of a video source. These flags are used in the DXVA2_ExtendedFormat structure.
alias DXVA2_VideoPrimaries = int;
enum : int
{
    ///Bitmask to validate flag values. This value is not a valid flag.
    DXVA2_VideoPrimariesMask           = 0x0000001f,
    ///Unknown. Treat as <b>DXVA2_VideoPrimaries_BT709</b>.
    DXVA2_VideoPrimaries_Unknown       = 0x00000000,
    ///Reserved. Do not use.
    DXVA2_VideoPrimaries_reserved      = 0x00000001,
    ///ITU-R BT.709. Also used for sRGB and scRGB.
    DXVA2_VideoPrimaries_BT709         = 0x00000002,
    ///ITU-R BT.470-4 System M (NTSC).
    DXVA2_VideoPrimaries_BT470_2_SysM  = 0x00000003,
    ///ITU-R BT.470-4 System B,G (PAL).
    DXVA2_VideoPrimaries_BT470_2_SysBG = 0x00000004,
    ///SMPTE 170M.
    DXVA2_VideoPrimaries_SMPTE170M     = 0x00000005,
    ///SMPTE 240M.
    DXVA2_VideoPrimaries_SMPTE240M     = 0x00000006,
    ///EBU Tech. 3213.
    DXVA2_VideoPrimaries_EBU3213       = 0x00000007,
    ///SMPTE C (SMPTE RP 145).
    DXVA2_VideoPrimaries_SMPTE_C       = 0x00000008,
}

///Specifies the conversion function from linear RGB to non-linear RGB (R'G'B'). These flags are used in the
///DXVA2_ExtendedFormat Structure.
alias DXVA2_VideoTransferFunction = int;
enum : int
{
    ///Bitmask to validate flag values. This value is not a valid flag.
    DXVA2_VideoTransFuncMask     = 0x0000001f,
    ///Unknown. Treat as DXVA2_VideoTransFunc_709.
    DXVA2_VideoTransFunc_Unknown = 0x00000000,
    ///Linear RGB (gamma = 1.0).
    DXVA2_VideoTransFunc_10      = 0x00000001,
    ///True 1.8 gamma, L' = L^1/1.8.
    DXVA2_VideoTransFunc_18      = 0x00000002,
    ///True 2.0 gamma, L' = L^1/2.0.
    DXVA2_VideoTransFunc_20      = 0x00000003,
    ///True 2.2 gamma, L' = L^1/2.2. This transfer function is used in ITU-R BT.470-2 System M (NTSC).
    DXVA2_VideoTransFunc_22      = 0x00000004,
    ///ITU-R BT.709 transfer function. Gamma 2.2 curve with a linear segment in the lower range. This transfer function
    ///is used in BT.709, BT.601, SMPTE 296M, SMPTE 170M, BT.470, and SMPTE 274M. In addition BT-1361 uses this function
    ///within the range [0...1].
    DXVA2_VideoTransFunc_709     = 0x00000005,
    ///SMPTE 240M transfer function. Gamma 2.2 curve with a linear segment in the lower range.
    DXVA2_VideoTransFunc_240M    = 0x00000006,
    ///sRGB transfer function. Gamma 2.4 curve with a linear segment in the lower range.
    DXVA2_VideoTransFunc_sRGB    = 0x00000007,
    ///True 2.8 gamma. L' = L^1/2.8. This transfer function is used in ITU-R BT.470-2 System B, G (PAL).
    DXVA2_VideoTransFunc_28      = 0x00000008,
}

alias __MIDL___MIDL_itf_dxva2api_0000_0000_0003 = int;
enum : int
{
    DXVA2_DeinterlaceTech_Unknown                = 0x00000000,
    DXVA2_DeinterlaceTech_BOBLineReplicate       = 0x00000001,
    DXVA2_DeinterlaceTech_BOBVerticalStretch     = 0x00000002,
    DXVA2_DeinterlaceTech_BOBVerticalStretch4Tap = 0x00000004,
    DXVA2_DeinterlaceTech_MedianFiltering        = 0x00000008,
    DXVA2_DeinterlaceTech_EdgeFiltering          = 0x00000010,
    DXVA2_DeinterlaceTech_FieldAdaptive          = 0x00000020,
    DXVA2_DeinterlaceTech_PixelAdaptive          = 0x00000040,
    DXVA2_DeinterlaceTech_MotionVectorSteered    = 0x00000080,
    DXVA2_DeinterlaceTech_InverseTelecine        = 0x00000100,
    DXVA2_DeinterlaceTech_Mask                   = 0x000001ff,
}

alias __MIDL___MIDL_itf_dxva2api_0000_0000_0004 = int;
enum : int
{
    DXVA2_NoiseFilterLumaLevel        = 0x00000001,
    DXVA2_NoiseFilterLumaThreshold    = 0x00000002,
    DXVA2_NoiseFilterLumaRadius       = 0x00000003,
    DXVA2_NoiseFilterChromaLevel      = 0x00000004,
    DXVA2_NoiseFilterChromaThreshold  = 0x00000005,
    DXVA2_NoiseFilterChromaRadius     = 0x00000006,
    DXVA2_DetailFilterLumaLevel       = 0x00000007,
    DXVA2_DetailFilterLumaThreshold   = 0x00000008,
    DXVA2_DetailFilterLumaRadius      = 0x00000009,
    DXVA2_DetailFilterChromaLevel     = 0x0000000a,
    DXVA2_DetailFilterChromaThreshold = 0x0000000b,
    DXVA2_DetailFilterChromaRadius    = 0x0000000c,
}

alias __MIDL___MIDL_itf_dxva2api_0000_0000_0005 = int;
enum : int
{
    DXVA2_NoiseFilterTech_Unsupported   = 0x00000000,
    DXVA2_NoiseFilterTech_Unknown       = 0x00000001,
    DXVA2_NoiseFilterTech_Median        = 0x00000002,
    DXVA2_NoiseFilterTech_Temporal      = 0x00000004,
    DXVA2_NoiseFilterTech_BlockNoise    = 0x00000008,
    DXVA2_NoiseFilterTech_MosquitoNoise = 0x00000010,
    DXVA2_NoiseFilterTech_Mask          = 0x0000001f,
}

alias __MIDL___MIDL_itf_dxva2api_0000_0000_0006 = int;
enum : int
{
    DXVA2_DetailFilterTech_Unsupported = 0x00000000,
    DXVA2_DetailFilterTech_Unknown     = 0x00000001,
    DXVA2_DetailFilterTech_Edge        = 0x00000002,
    DXVA2_DetailFilterTech_Sharpening  = 0x00000004,
    DXVA2_DetailFilterTech_Mask        = 0x00000007,
}

alias __MIDL___MIDL_itf_dxva2api_0000_0000_0007 = int;
enum : int
{
    DXVA2_ProcAmp_None       = 0x00000000,
    DXVA2_ProcAmp_Brightness = 0x00000001,
    DXVA2_ProcAmp_Contrast   = 0x00000002,
    DXVA2_ProcAmp_Hue        = 0x00000004,
    DXVA2_ProcAmp_Saturation = 0x00000008,
    DXVA2_ProcAmp_Mask       = 0x0000000f,
}

alias __MIDL___MIDL_itf_dxva2api_0000_0000_0008 = int;
enum : int
{
    DXVA2_VideoProcess_None                       = 0x00000000,
    DXVA2_VideoProcess_YUV2RGB                    = 0x00000001,
    DXVA2_VideoProcess_StretchX                   = 0x00000002,
    DXVA2_VideoProcess_StretchY                   = 0x00000004,
    DXVA2_VideoProcess_AlphaBlend                 = 0x00000008,
    DXVA2_VideoProcess_SubRects                   = 0x00000010,
    DXVA2_VideoProcess_SubStreams                 = 0x00000020,
    DXVA2_VideoProcess_SubStreamsExtended         = 0x00000040,
    DXVA2_VideoProcess_YUV2RGBExtended            = 0x00000080,
    DXVA2_VideoProcess_AlphaBlendExtended         = 0x00000100,
    DXVA2_VideoProcess_Constriction               = 0x00000200,
    DXVA2_VideoProcess_NoiseFilter                = 0x00000400,
    DXVA2_VideoProcess_DetailFilter               = 0x00000800,
    DXVA2_VideoProcess_PlanarAlpha                = 0x00001000,
    DXVA2_VideoProcess_LinearScaling              = 0x00002000,
    DXVA2_VideoProcess_GammaCompensated           = 0x00004000,
    DXVA2_VideoProcess_MaintainsOriginalFieldData = 0x00008000,
    DXVA2_VideoProcess_Mask                       = 0x0000ffff,
}

alias __MIDL___MIDL_itf_dxva2api_0000_0000_0009 = int;
enum : int
{
    DXVA2_VPDev_HardwareDevice = 0x00000001,
    DXVA2_VPDev_EmulatedDXVA1  = 0x00000002,
    DXVA2_VPDev_SoftwareDevice = 0x00000004,
    DXVA2_VPDev_Mask           = 0x00000007,
}

alias __MIDL___MIDL_itf_dxva2api_0000_0000_0010 = int;
enum : int
{
    DXVA2_SampleData_RFF             = 0x00000001,
    DXVA2_SampleData_TFF             = 0x00000002,
    DXVA2_SampleData_RFF_TFF_Present = 0x00000004,
    DXVA2_SampleData_Mask            = 0x0000ffff,
}

alias __MIDL___MIDL_itf_dxva2api_0000_0000_0011 = int;
enum : int
{
    DXVA2_DestData_RFF             = 0x00000001,
    DXVA2_DestData_TFF             = 0x00000002,
    DXVA2_DestData_RFF_TFF_Present = 0x00000004,
    DXVA2_DestData_Mask            = 0x0000ffff,
}

alias __MIDL___MIDL_itf_dxva2api_0000_0000_0012 = int;
enum : int
{
    DXVA2_PictureParametersBufferType         = 0x00000000,
    DXVA2_MacroBlockControlBufferType         = 0x00000001,
    DXVA2_ResidualDifferenceBufferType        = 0x00000002,
    DXVA2_DeblockingControlBufferType         = 0x00000003,
    DXVA2_InverseQuantizationMatrixBufferType = 0x00000004,
    DXVA2_SliceControlBufferType              = 0x00000005,
    DXVA2_BitStreamDateBufferType             = 0x00000006,
    DXVA2_MotionVectorBuffer                  = 0x00000007,
    DXVA2_FilmGrainBuffer                     = 0x00000008,
}

alias __MIDL___MIDL_itf_dxva2api_0000_0000_0013 = int;
enum : int
{
    DXVA2_VideoDecoderRenderTarget   = 0x00000000,
    DXVA2_VideoProcessorRenderTarget = 0x00000001,
    DXVA2_VideoSoftwareRenderTarget  = 0x00000002,
}

///Describes a DirectX surface type for DirectX Video Acceleration (DXVA).
alias DXVA2_SurfaceType = int;
enum : int
{
    ///The surface is a decoder render target.
    DXVA2_SurfaceType_DecoderRenderTarget    = 0x00000000,
    ///The surface is a video processor render target.
    DXVA2_SurfaceType_ProcessorRenderTarget  = 0x00000001,
    ///The surface is a Direct3D texture render target.
    DXVA2_SurfaceType_D3DRenderTargetTexture = 0x00000002,
}

alias __MIDL___MIDL_itf_opmapi_0000_0000_0001 = int;
enum : int
{
    OPM_OMAC_SIZE                                = 0x00000010,
    OPM_128_BIT_RANDOM_NUMBER_SIZE               = 0x00000010,
    OPM_ENCRYPTED_INITIALIZATION_PARAMETERS_SIZE = 0x00000100,
    OPM_CONFIGURE_SETTING_DATA_SIZE              = 0x00000fd8,
    OPM_GET_INFORMATION_PARAMETERS_SIZE          = 0x00000fd8,
    OPM_REQUESTED_INFORMATION_SIZE               = 0x00000fec,
    OPM_HDCP_KEY_SELECTION_VECTOR_SIZE           = 0x00000005,
    OPM_PROTECTION_TYPE_SIZE                     = 0x00000004,
    OPM_BUS_TYPE_MASK                            = 0x0000ffff,
    OPM_BUS_IMPLEMENTATION_MODIFIER_MASK         = 0x00007fff,
}

///Specifies whether the IOPMVideoOutput interface will use Output Protection Manager (OPM) semantics or Certified
///Output Protection Protocol (COPP) semantics.
alias OPM_VIDEO_OUTPUT_SEMANTICS = int;
enum : int
{
    ///The interface will use COPP semantics.
    OPM_VOS_COPP_SEMANTICS       = 0x00000000,
    ///The interface will use OPM semantics.
    OPM_VOS_OPM_SEMANTICS        = 0x00000001,
    OPM_VOS_OPM_INDIRECT_DISPLAY = 0x00000002,
}

alias __MIDL___MIDL_itf_opmapi_0000_0000_0002 = int;
enum : int
{
    OPM_HDCP_FLAG_NONE     = 0x00000000,
    OPM_HDCP_FLAG_REPEATER = 0x00000001,
}

alias __MIDL___MIDL_itf_opmapi_0000_0000_0003 = int;
enum : int
{
    OPM_STATUS_NORMAL                       = 0x00000000,
    OPM_STATUS_LINK_LOST                    = 0x00000001,
    OPM_STATUS_RENEGOTIATION_REQUIRED       = 0x00000002,
    OPM_STATUS_TAMPERING_DETECTED           = 0x00000004,
    OPM_STATUS_REVOKED_HDCP_DEVICE_ATTACHED = 0x00000008,
}

alias __MIDL___MIDL_itf_opmapi_0000_0000_0004 = int;
enum : int
{
    OPM_CONNECTOR_TYPE_OTHER                             = 0xffffffff,
    OPM_CONNECTOR_TYPE_VGA                               = 0x00000000,
    OPM_CONNECTOR_TYPE_SVIDEO                            = 0x00000001,
    OPM_CONNECTOR_TYPE_COMPOSITE_VIDEO                   = 0x00000002,
    OPM_CONNECTOR_TYPE_COMPONENT_VIDEO                   = 0x00000003,
    OPM_CONNECTOR_TYPE_DVI                               = 0x00000004,
    OPM_CONNECTOR_TYPE_HDMI                              = 0x00000005,
    OPM_CONNECTOR_TYPE_LVDS                              = 0x00000006,
    OPM_CONNECTOR_TYPE_D_JPN                             = 0x00000008,
    OPM_CONNECTOR_TYPE_SDI                               = 0x00000009,
    OPM_CONNECTOR_TYPE_DISPLAYPORT_EXTERNAL              = 0x0000000a,
    OPM_CONNECTOR_TYPE_DISPLAYPORT_EMBEDDED              = 0x0000000b,
    OPM_CONNECTOR_TYPE_UDI_EXTERNAL                      = 0x0000000c,
    OPM_CONNECTOR_TYPE_UDI_EMBEDDED                      = 0x0000000d,
    OPM_CONNECTOR_TYPE_RESERVED                          = 0x0000000e,
    OPM_CONNECTOR_TYPE_MIRACAST                          = 0x0000000f,
    OPM_CONNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_A = 0x00000010,
    OPM_CONNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_B = 0x00000011,
    OPM_COPP_COMPATIBLE_CONNECTOR_TYPE_INTERNAL          = 0x80000000,
}

alias __MIDL___MIDL_itf_opmapi_0000_0000_0005 = int;
enum : int
{
    OPM_DVI_CHARACTERISTIC_1_0          = 0x00000001,
    OPM_DVI_CHARACTERISTIC_1_1_OR_ABOVE = 0x00000002,
}

alias OPM_OUTPUT_HARDWARE_PROTECTION = int;
enum : int
{
    OPM_OUTPUT_HARDWARE_PROTECTION_NOT_SUPPORTED = 0x00000000,
    OPM_OUTPUT_HARDWARE_PROTECTION_SUPPORTED     = 0x00000001,
}

alias __MIDL___MIDL_itf_opmapi_0000_0000_0006 = int;
enum : int
{
    OPM_BUS_TYPE_OTHER                                                      = 0x00000000,
    OPM_BUS_TYPE_PCI                                                        = 0x00000001,
    OPM_BUS_TYPE_PCIX                                                       = 0x00000002,
    OPM_BUS_TYPE_PCIEXPRESS                                                 = 0x00000003,
    OPM_BUS_TYPE_AGP                                                        = 0x00000004,
    OPM_BUS_IMPLEMENTATION_MODIFIER_INSIDE_OF_CHIPSET                       = 0x00010000,
    OPM_BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP          = 0x00020000,
    OPM_BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET        = 0x00030000,
    OPM_BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR                = 0x00040000,
    OPM_BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE = 0x00050000,
    OPM_BUS_IMPLEMENTATION_MODIFIER_NON_STANDARD                            = 0x80000000,
    OPM_COPP_COMPATIBLE_BUS_TYPE_INTEGRATED                                 = 0x80000000,
}

///Specifies the protection level for DisplayPort Content Protection (DPCP).
alias OPM_DPCP_PROTECTION_LEVEL = int;
enum : int
{
    ///DPCP is disabled.
    OPM_DPCP_OFF         = 0x00000000,
    ///DPCP is enabled.
    OPM_DPCP_ON          = 0x00000001,
    ///Reserved.
    OPM_DPCP_FORCE_ULONG = 0x7fffffff,
}

///Specifies the protection level for High-Bandwidth Digital Content Protection (HDCP).
alias OPM_HDCP_PROTECTION_LEVEL = int;
enum : int
{
    ///HDCP is disabled.
    OPM_HDCP_OFF         = 0x00000000,
    ///HDCP is enabled.
    OPM_HDCP_ON          = 0x00000001,
    ///Reserved.
    OPM_HDCP_FORCE_ULONG = 0x7fffffff,
}

alias OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL = int;
enum : int
{
    OPM_TYPE_ENFORCEMENT_HDCP_OFF                         = 0x00000000,
    OPM_TYPE_ENFORCEMENT_HDCP_ON_WITH_NO_TYPE_RESTRICTION = 0x00000001,
    OPM_TYPE_ENFORCEMENT_HDCP_ON_WITH_TYPE1_RESTRICTION   = 0x00000002,
    OPM_TYPE_ENFORCEMENT_HDCP_FORCE_ULONG                 = 0x7fffffff,
}

alias __MIDL___MIDL_itf_opmapi_0000_0000_0007 = int;
enum : int
{
    OPM_CGMSA_OFF                             = 0x00000000,
    OPM_CGMSA_COPY_FREELY                     = 0x00000001,
    OPM_CGMSA_COPY_NO_MORE                    = 0x00000002,
    OPM_CGMSA_COPY_ONE_GENERATION             = 0x00000003,
    OPM_CGMSA_COPY_NEVER                      = 0x00000004,
    OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED = 0x00000008,
}

///Specifies the protection level for Analog Copy Protection (ACP).
alias OPM_ACP_PROTECTION_LEVEL = int;
enum : int
{
    ///ACP is disabled.
    OPM_ACP_OFF         = 0x00000000,
    ///ACP protection level 1.
    OPM_ACP_LEVEL_ONE   = 0x00000001,
    ///ACP protection level 2.
    OPM_ACP_LEVEL_TWO   = 0x00000002,
    ///ACP protection level 3.
    OPM_ACP_LEVEL_THREE = 0x00000003,
    ///Reserved.
    OPM_ACP_FORCE_ULONG = 0x7fffffff,
}

alias __MIDL___MIDL_itf_opmapi_0000_0000_0008 = int;
enum : int
{
    OPM_PROTECTION_TYPE_OTHER                 = 0x80000000,
    OPM_PROTECTION_TYPE_NONE                  = 0x00000000,
    OPM_PROTECTION_TYPE_COPP_COMPATIBLE_HDCP  = 0x00000001,
    OPM_PROTECTION_TYPE_ACP                   = 0x00000002,
    OPM_PROTECTION_TYPE_CGMSA                 = 0x00000004,
    OPM_PROTECTION_TYPE_HDCP                  = 0x00000008,
    OPM_PROTECTION_TYPE_DPCP                  = 0x00000010,
    OPM_PROTECTION_TYPE_TYPE_ENFORCEMENT_HDCP = 0x00000020,
}

alias __MIDL___MIDL_itf_opmapi_0000_0000_0009 = int;
enum : int
{
    OPM_PROTECTION_STANDARD_OTHER               = 0x80000000,
    OPM_PROTECTION_STANDARD_NONE                = 0x00000000,
    OPM_PROTECTION_STANDARD_IEC61880_525I       = 0x00000001,
    OPM_PROTECTION_STANDARD_IEC61880_2_525I     = 0x00000002,
    OPM_PROTECTION_STANDARD_IEC62375_625P       = 0x00000004,
    OPM_PROTECTION_STANDARD_EIA608B_525         = 0x00000008,
    OPM_PROTECTION_STANDARD_EN300294_625I       = 0x00000010,
    OPM_PROTECTION_STANDARD_CEA805A_TYPEA_525P  = 0x00000020,
    OPM_PROTECTION_STANDARD_CEA805A_TYPEA_750P  = 0x00000040,
    OPM_PROTECTION_STANDARD_CEA805A_TYPEA_1125I = 0x00000080,
    OPM_PROTECTION_STANDARD_CEA805A_TYPEB_525P  = 0x00000100,
    OPM_PROTECTION_STANDARD_CEA805A_TYPEB_750P  = 0x00000200,
    OPM_PROTECTION_STANDARD_CEA805A_TYPEB_1125I = 0x00000400,
    OPM_PROTECTION_STANDARD_ARIBTRB15_525I      = 0x00000800,
    OPM_PROTECTION_STANDARD_ARIBTRB15_525P      = 0x00001000,
    OPM_PROTECTION_STANDARD_ARIBTRB15_750P      = 0x00002000,
    OPM_PROTECTION_STANDARD_ARIBTRB15_1125I     = 0x00004000,
}

///Specifies the aspect ratio for ETSI EN 300 294.
alias OPM_IMAGE_ASPECT_RATIO_EN300294 = int;
enum : int
{
    ///Full format 4:3.
    OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_4_BY_3                  = 0x00000000,
    ///Box 14:9 center.
    OPM_ASPECT_RATIO_EN300294_BOX_14_BY_9_CENTER                  = 0x00000001,
    ///Box 14:9 top.
    OPM_ASPECT_RATIO_EN300294_BOX_14_BY_9_TOP                     = 0x00000002,
    ///Box 16:9 center.
    OPM_ASPECT_RATIO_EN300294_BOX_16_BY_9_CENTER                  = 0x00000003,
    ///Box 16:9 top.
    OPM_ASPECT_RATIO_EN300294_BOX_16_BY_9_TOP                     = 0x00000004,
    ///Box &gt; 16:9 center.
    OPM_ASPECT_RATIO_EN300294_BOX_GT_16_BY_9_CENTER               = 0x00000005,
    ///Full format 4:3 (shoot and protect 14:9 center).
    OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_4_BY_3_PROTECTED_CENTER = 0x00000006,
    ///Full format 16:9 (anamorphic).
    OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_16_BY_9_ANAMORPHIC      = 0x00000007,
    ///Reserved.
    OPM_ASPECT_RATIO_FORCE_ULONG                                  = 0x7fffffff,
}

alias KSMETHOD_OPMVIDEOOUTPUT = int;
enum : int
{
    KSMETHOD_OPMVIDEOOUTPUT_STARTINITIALIZATION  = 0x00000000,
    KSMETHOD_OPMVIDEOOUTPUT_FINISHINITIALIZATION = 0x00000001,
    KSMETHOD_OPMVIDEOOUTPUT_GETINFORMATION       = 0x00000002,
}

///Defines the data type for a key/value pair.
alias MF_ATTRIBUTE_TYPE = int;
enum : int
{
    ///Unsigned 32-bit integer.
    MF_ATTRIBUTE_UINT32   = 0x00000013,
    ///Unsigned 64-bit integer.
    MF_ATTRIBUTE_UINT64   = 0x00000015,
    ///Floating-point number.
    MF_ATTRIBUTE_DOUBLE   = 0x00000005,
    ///<b>GUID</b> value.
    MF_ATTRIBUTE_GUID     = 0x00000048,
    ///NULL-terminated wide-character string.
    MF_ATTRIBUTE_STRING   = 0x0000001f,
    ///Byte array.
    MF_ATTRIBUTE_BLOB     = 0x00001011,
    ///<b>IUnknown</b> pointer.
    MF_ATTRIBUTE_IUNKNOWN = 0x0000000d,
}

///Specifies how to compare the attributes on two objects.
alias MF_ATTRIBUTES_MATCH_TYPE = int;
enum : int
{
    ///Check whether all the attributes in <i>pThis</i> exist in <i>pTheirs</i> and have the same data, where
    ///<i>pThis</i> is the object whose Compare method is being called and <i>pTheirs</i> is the object given in the
    ///<i>pTheirs</i> parameter.
    MF_ATTRIBUTES_MATCH_OUR_ITEMS    = 0x00000000,
    ///Check whether all the attributes in <i>pTheirs</i> exist in <i>pThis</i> and have the same data, where
    ///<i>pThis</i> is the object whose Compare method is being called and <i>pTheirs</i> is the object given in the
    ///<i>pTheirs</i> parameter.
    MF_ATTRIBUTES_MATCH_THEIR_ITEMS  = 0x00000001,
    ///Check whether both objects have identical attributes with the same data.
    MF_ATTRIBUTES_MATCH_ALL_ITEMS    = 0x00000002,
    ///Check whether the attributes that exist in both objects have the same data.
    MF_ATTRIBUTES_MATCH_INTERSECTION = 0x00000003,
    ///Find the object with the fewest number of attributes, and check if those attributes exist in the other object and
    ///have the same data.
    MF_ATTRIBUTES_MATCH_SMALLER      = 0x00000004,
}

///Defines flags for serializing and deserializing attribute stores.
alias MF_ATTRIBUTE_SERIALIZE_OPTIONS = int;
enum : int
{
    ///If this flag is set, <b>IUnknown</b> pointers in the attribute store are marshaled to and from the stream. If
    ///this flag is absent, <b>IUnknown</b> pointers in the attribute store are not marshaled or serialized.
    MF_ATTRIBUTE_SERIALIZE_UNKNOWN_BYREF = 0x00000001,
}

///Contains flags for the IMF2DBuffer2::Lock2DSize method.
alias MF2DBuffer_LockFlags = int;
enum : int
{
    ///Reserved.
    MF2DBuffer_LockFlags_LockTypeMask = 0x00000003,
    ///Lock the buffer for reading.
    MF2DBuffer_LockFlags_Read         = 0x00000001,
    ///Lock the buffer for writing.
    MF2DBuffer_LockFlags_Write        = 0x00000002,
    ///Lock the buffer for both reading and writing.
    MF2DBuffer_LockFlags_ReadWrite    = 0x00000003,
    ///Reserved. This member forces the enumeration type to compile as a <b>DWORD</b> value.
    MF2DBuffer_LockFlags_ForceDWORD   = 0x7fffffff,
}

///Specifies how a video stream is interlaced. In the descriptions that follow, upper field refers to the field that
///contains the leading half scan line. Lower field refers to the field that contains the first full scan line.
enum MFVideoInterlaceMode : int
{
    ///The type of interlacing is not known.
    MFVideoInterlace_Unknown                     = 0x00000000,
    ///Progressive frames.
    MFVideoInterlace_Progressive                 = 0x00000002,
    ///Interlaced frames. Each frame contains two fields. The field lines are interleaved, with the upper field
    ///appearing on the first line.
    MFVideoInterlace_FieldInterleavedUpperFirst  = 0x00000003,
    ///Interlaced frames. Each frame contains two fields. The field lines are interleaved, with the lower field
    ///appearing on the first line.
    MFVideoInterlace_FieldInterleavedLowerFirst  = 0x00000004,
    ///Interlaced frames. Each frame contains one field, with the upper field appearing first.
    MFVideoInterlace_FieldSingleUpper            = 0x00000005,
    ///Interlaced frames. Each frame contains one field, with the lower field appearing first.
    MFVideoInterlace_FieldSingleLower            = 0x00000006,
    ///The stream contains a mix of interlaced and progressive modes.
    MFVideoInterlace_MixedInterlaceOrProgressive = 0x00000007,
    ///Reserved.
    MFVideoInterlace_Last                        = 0x00000008,
    ///Reserved. This member forces the enumeration type to compile as a <b>DWORD</b> value.
    MFVideoInterlace_ForceDWORD                  = 0x7fffffff,
}

///Specifies the conversion function from linear RGB to non-linear RGB (R'G'B').
enum MFVideoTransferFunction : int
{
    ///Unknown. Treat as MFVideoTransFunc_709.
    MFVideoTransFunc_Unknown    = 0x00000000,
    ///Linear RGB (gamma = 1.0).
    MFVideoTransFunc_10         = 0x00000001,
    ///True 1.8 gamma, L' = L^1/1.8.
    MFVideoTransFunc_18         = 0x00000002,
    ///True 2.0 gamma, L' = L^1/2.0.
    MFVideoTransFunc_20         = 0x00000003,
    ///True 2.2 gamma, L' = L^1/2.2. This transfer function is used in ITU-R BT.470-2 System M (NTSC).
    MFVideoTransFunc_22         = 0x00000004,
    ///ITU-R BT.709 transfer function. Gamma 2.2 curve with a linear segment in the lower range. This transfer function
    ///is used in BT.709, BT.601, SMPTE 296M, SMPTE 170M, BT.470, and SPMTE 274M. In addition BT-1361 uses this function
    ///within the range [0...1].
    MFVideoTransFunc_709        = 0x00000005,
    ///SPMTE 240M transfer function. Gamma 2.2 curve with a linear segment in the lower range.
    MFVideoTransFunc_240M       = 0x00000006,
    ///sRGB transfer function. Gamma 2.4 curve with a linear segment in the lower range.
    MFVideoTransFunc_sRGB       = 0x00000007,
    ///True 2.8 gamma. L' = L^1/2.8. This transfer function is used in ITU-R BT.470-2 System B, G (PAL).
    MFVideoTransFunc_28         = 0x00000008,
    ///Logarithmic transfer (100:1 range); for example, as used in H.264 video. <div class="alert"><b>Note</b> Requires
    ///Windows 7 or later.</div> <div> </div>
    MFVideoTransFunc_Log_100    = 0x00000009,
    ///Logarithmic transfer (316.22777:1 range); for example, as used in H.264 video. <div class="alert"><b>Note</b>
    ///Requires Windows 7 or later.</div> <div> </div>
    MFVideoTransFunc_Log_316    = 0x0000000a,
    ///Symmetric ITU-R BT.709. <div class="alert"><b>Note</b> Requires Windows 7 or later.</div> <div> </div>
    MFVideoTransFunc_709_sym    = 0x0000000b,
    ///Constant luminance ITU-R BT.2020. See Recommendation ITU-R BT.2020-2. <div class="alert"><b>Note</b> Requires
    ///Windows 8 or later.</div> <div> </div>
    MFVideoTransFunc_2020_const = 0x0000000c,
    ///Non-constant luminance ITU-R BT.2020. See Recommendation ITU-R BT.2020-2. <div class="alert"><b>Note</b> Requires
    ///Windows 8 or later.</div> <div> </div>
    MFVideoTransFunc_2020       = 0x0000000d,
    ///True 2.6 gamma, Lâ€™=L^1/2.6 <div class="alert"><b>Note</b> Requires Windows 8 or later.</div> <div> </div>
    MFVideoTransFunc_26         = 0x0000000e,
    ///SMPTE ST.2084 also known as PQ. Also defined in ITU-R BT.2100 <div class="alert"><b>Note</b> Requires Windows 10,
    ///version 1703 or later.</div> <div> </div>
    MFVideoTransFunc_2084       = 0x0000000f,
    ///Hybrid Log-Gamma, ARIB STD-B67 <div class="alert"><b>Note</b> Requires Windows 10, version 1703 or later.</div>
    ///<div> </div>
    MFVideoTransFunc_HLG        = 0x00000010,
    MFVideoTransFunc_10_rel     = 0x00000011,
    ///Reserved.
    MFVideoTransFunc_Last       = 0x00000012,
    ///Reserved. This member forces the enumeration type to compile as a <b>DWORD</b> value.
    MFVideoTransFunc_ForceDWORD = 0x7fffffff,
}

///Specifies the color primaries of a video source. The color primaries define how to convert colors from RGB color
///space to CIE XYZ color space.
enum MFVideoPrimaries : int
{
    ///The color primaries are unknown.
    MFVideoPrimaries_Unknown       = 0x00000000,
    ///Reserved.
    MFVideoPrimaries_reserved      = 0x00000001,
    ///ITU-R BT.709. Also used for sRGB and scRGB.
    MFVideoPrimaries_BT709         = 0x00000002,
    ///ITU-R BT.470-4 System M (NTSC).
    MFVideoPrimaries_BT470_2_SysM  = 0x00000003,
    ///ITU-R BT.470-4 System B,G (NTSC).
    MFVideoPrimaries_BT470_2_SysBG = 0x00000004,
    ///SMPTE 170M.
    MFVideoPrimaries_SMPTE170M     = 0x00000005,
    ///SMPTE 240M.
    MFVideoPrimaries_SMPTE240M     = 0x00000006,
    ///EBU 3213.
    MFVideoPrimaries_EBU3213       = 0x00000007,
    ///SMPTE C (SMPTE RP 145).
    MFVideoPrimaries_SMPTE_C       = 0x00000008,
    ///ITU-R BT.2020 color primaries. <div class="alert"><b>Note</b> Requires Windows 8 or later.</div> <div> </div>
    MFVideoPrimaries_BT2020        = 0x00000009,
    ///CIE 1931 XYZ (see: CIE 1931 color space). Note that this color space is only well-defined for floating point
    ///representations. <div class="alert"><b>Note</b> Requires Windows 8 or later.</div> <div> </div>
    MFVideoPrimaries_XYZ           = 0x0000000a,
    ///DCI-P3 <div class="alert"><b>Note</b> Requires Windows 10, version 1703 or later.</div> <div> </div>
    MFVideoPrimaries_DCI_P3        = 0x0000000b,
    ///Academy Color Encoding System <div class="alert"><b>Note</b> Requires Windows 10, version 1703 or later.</div>
    ///<div> </div>
    MFVideoPrimaries_ACES          = 0x0000000c,
    ///Reserved.
    MFVideoPrimaries_Last          = 0x0000000d,
    ///Reserved. This member forces the enumeration type to compile as a <b>DWORD</b> value.
    MFVideoPrimaries_ForceDWORD    = 0x7fffffff,
}

///Describes the optimal lighting for viewing a particular set of video content.
enum MFVideoLighting : int
{
    ///The optimal lighting is unknown.
    MFVideoLighting_Unknown    = 0x00000000,
    ///Bright lighting; for example, outdoors.
    MFVideoLighting_bright     = 0x00000001,
    ///Medium brightness; for example, normal office lighting.
    MFVideoLighting_office     = 0x00000002,
    ///Dim; for example, a living room with a television and additional low lighting.
    MFVideoLighting_dim        = 0x00000003,
    ///Dark; for example, a movie theater.
    MFVideoLighting_dark       = 0x00000004,
    ///Reserved.
    MFVideoLighting_Last       = 0x00000005,
    ///Reserved. This member forces the enumeration type to compile as a <b>DWORD</b> value.
    MFVideoLighting_ForceDWORD = 0x7fffffff,
}

///Describes the conversion matrices between Y'PbPr (component video) and studio R'G'B'.
enum MFVideoTransferMatrix : int
{
    ///Unknown transfer matrix. Treat as MFVideoTransferMatrix_BT709.
    MFVideoTransferMatrix_Unknown    = 0x00000000,
    ///ITU-R BT.709 transfer matrix.
    MFVideoTransferMatrix_BT709      = 0x00000001,
    ///ITU-R BT.601 transfer matrix. Also used for SMPTE 170 and ITU-R BT.470-2 System B,G.
    MFVideoTransferMatrix_BT601      = 0x00000002,
    ///SMPTE 240M transfer matrix.
    MFVideoTransferMatrix_SMPTE240M  = 0x00000003,
    MFVideoTransferMatrix_BT2020_10  = 0x00000004,
    MFVideoTransferMatrix_BT2020_12  = 0x00000005,
    ///Reserved.
    MFVideoTransferMatrix_Last       = 0x00000006,
    ///Reserved. This member forces the enumeration type to compile as a <b>DWORD</b> value.
    MFVideoTransferMatrix_ForceDWORD = 0x7fffffff,
}

///Contains flags that define the chroma encoding scheme for Y'Cb'Cr' data.
enum MFVideoChromaSubsampling : int
{
    ///Unknown encoding scheme.
    MFVideoChromaSubsampling_Unknown                        = 0x00000000,
    ///Chroma should be reconstructed as if the underlying video was progressive content, rather than skipping fields or
    ///applying chroma filtering to minimize artifacts from reconstructing 4:2:0 interlaced chroma.
    MFVideoChromaSubsampling_ProgressiveChroma              = 0x00000008,
    ///Chroma samples are aligned horizontally with the luma samples, or with multiples of the luma samples. If this
    ///flag is not set, chroma samples are located 1/2 pixel to the right of the corresponding luma sample.
    MFVideoChromaSubsampling_Horizontally_Cosited           = 0x00000004,
    ///Chroma samples are aligned vertically with the luma samples, or with multiples of the luma samples. If this flag
    ///is not set, chroma samples are located 1/2 pixel down from the corresponding luma sample.
    MFVideoChromaSubsampling_Vertically_Cosited             = 0x00000002,
    ///The U and V planes are aligned vertically. If this flag is not set, the chroma planes are assumed to be out of
    ///phase by 1/2 chroma sample, alternating between a line of U followed by a line of V.
    MFVideoChromaSubsampling_Vertically_AlignedChromaPlanes = 0x00000001,
    ///Specifies the chroma encoding scheme for MPEG-2 video. Chroma samples are aligned horizontally with the luma
    ///samples, but are not aligned vertically. The U and V planes are aligned vertically.
    MFVideoChromaSubsampling_MPEG2                          = 0x00000005,
    ///Specifies the chroma encoding scheme for MPEG-1 video.
    MFVideoChromaSubsampling_MPEG1                          = 0x00000001,
    ///Specifies the chroma encoding scheme for PAL DV video.
    MFVideoChromaSubsampling_DV_PAL                         = 0x00000006,
    ///Chroma samples are aligned vertically and horizontally with the luma samples. YUV formats such as 4:4:4, 4:2:2,
    ///and 4:1:1 are always cosited in both directions and should use this flag.
    MFVideoChromaSubsampling_Cosited                        = 0x00000007,
    ///Reserved.
    MFVideoChromaSubsampling_Last                           = 0x00000008,
    ///Reserved. This member forces the enumeration type to compile as a <b>DWORD</b> value.
    MFVideoChromaSubsampling_ForceDWORD                     = 0x7fffffff,
}

///Specifies whether color data includes headroom and toeroom. Headroom allows for values beyond 1.0 white ("whiter than
///white"), and toeroom allows for values below reference 0.0 black ("blacker than black").
enum MFNominalRange : int
{
    ///Unknown nominal range.
    MFNominalRange_Unknown    = 0x00000000,
    ///Equivalent to MFNominalRange_0_255.
    MFNominalRange_Normal     = 0x00000001,
    ///Equivalent to MFNominalRange_16_235.
    MFNominalRange_Wide       = 0x00000002,
    ///The normalized range [0...1] maps to [0...255] for 8-bit samples or [0...1023] for 10-bit samples.
    MFNominalRange_0_255      = 0x00000001,
    ///The normalized range [0...1] maps to [16...235] for 8-bit samples or [64...940] for 10-bit samples.
    MFNominalRange_16_235     = 0x00000002,
    ///The normalized range [0..1] maps to [48...208] for 8-bit samples or [64...940] for 10-bit samples.
    MFNominalRange_48_208     = 0x00000003,
    ///The normalized range [0..1] maps to [64...127] for 8-bit samples or [256...508] for 10-bit samples. This range is
    ///used in the xRGB color space. <div class="alert"><b>Note</b> Requires Windows 7 or later.</div> <div> </div>
    MFNominalRange_64_127     = 0x00000004,
    MFNominalRange_Last       = 0x00000005,
    MFNominalRange_ForceDWORD = 0x7fffffff,
}

///Contains flags that describe a video stream. These flags are used in the MFVideoInfo structure, which is part of the
///MFVIDEOFORMAT structure.
enum MFVideoFlags : int
{
    ///Use this value to mask out the next three flags, which describe the effective aspect ratio of the image. This
    ///value by itself is not a valid flag.
    MFVideoFlag_PAD_TO_Mask           = 0x00000003,
    ///Do not modify the picture aspect ratio.
    MFVideoFlag_PAD_TO_None           = 0x00000000,
    ///Display the image in a 4 x 3 area. If this flag is set, the geometrical aperture of the picture should be
    ///expanded to a 4 x 3 area by letterboxing or pillarboxing. The geometrical aperture is the portion of the image
    ///that is intended to be viewed, without any overscan region.
    MFVideoFlag_PAD_TO_4x3            = 0x00000001,
    ///Display the image in a 16 x 9 area. If this flag is set, the geometrical aperture of the picture should be
    ///expanded to a 16 x 9 area by letterboxing or pillarboxing.
    MFVideoFlag_PAD_TO_16x9           = 0x00000002,
    ///Use this value to mask out the next three flags, which describe the source content. This value by itself is not a
    ///valid flag.
    MFVideoFlag_SrcContentHintMask    = 0x0000001c,
    ///There is no additional information about the source content .
    MFVideoFlag_SrcContentHintNone    = 0x00000000,
    ///The source is a 16 x 9 image encoded within a 4 x 3 area.
    MFVideoFlag_SrcContentHint16x9    = 0x00000004,
    ///The source is a 2.35:1 image encoded within a 16 x 9 or 4 x 3 area.
    MFVideoFlag_SrcContentHint235_1   = 0x00000008,
    ///Analog copy protection should be applied.
    MFVideoFlag_AnalogProtected       = 0x00000020,
    ///Digital copy protection should be applied.
    MFVideoFlag_DigitallyProtected    = 0x00000040,
    ///The video source is progressive content encoded as interlaced video, possibly using 3:2 pulldown. This flag is
    ///obsolete. See Remarks.
    MFVideoFlag_ProgressiveContent    = 0x00000080,
    ///Used to extract the field repeat count. This flag is obsolete. See Remarks.
    MFVideoFlag_FieldRepeatCountMask  = 0x00000700,
    ///Used to extract the field repeat count. This flag is obsolete. See Remarks.
    MFVideoFlag_FieldRepeatCountShift = 0x00000008,
    ///The progressive sequence was disrupted and the sequence is interlaced at the break. This flag is obsolete. See
    ///Remarks.
    MFVideoFlag_ProgressiveSeqReset   = 0x00000800,
    ///Apply the pan and scan rectangle on the output.
    MFVideoFlag_PanScanEnabled        = 0x00020000,
    ///The sample contains the lower field. This flag applies only if the interlace mode is single fields
    ///(MFVideoInterlace_FieldSingleUpperFirst or MFVideoInterlace_FieldSingleLowerFirst). This flag is obsolete. See
    ///Remarks.
    MFVideoFlag_LowerFieldFirst       = 0x00040000,
    ///The image is represented bottom-up in memory. This flag should be used only with RGB formats.
    MFVideoFlag_BottomUpLinearRep     = 0x00080000,
    ///Reserved. Do not use.
    MFVideoFlags_DXVASurface          = 0x00100000,
    ///Reserved. Do not use.
    MFVideoFlags_RenderTargetSurface  = 0x00400000,
    ///Reserved. This member forces the enumeration type to compile as a <b>QWORD</b> value.
    MFVideoFlags_ForceQWORD           = 0x7fffffff,
}

///Contains values that specify common video formats.
enum MFStandardVideoFormat : int
{
    ///Reserved; do not use.
    MFStdVideoFormat_reserved     = 0x00000000,
    ///NTSC television (720 x 480i).
    MFStdVideoFormat_NTSC         = 0x00000001,
    ///PAL television (720 x 576i).
    MFStdVideoFormat_PAL          = 0x00000002,
    ///DVD, NTSC standard (720 x 480).
    MFStdVideoFormat_DVD_NTSC     = 0x00000003,
    ///DVD, PAL standard (720 x 576).
    MFStdVideoFormat_DVD_PAL      = 0x00000004,
    ///DV video, PAL standard.
    MFStdVideoFormat_DV_PAL       = 0x00000005,
    ///DV video, NTSC standard.
    MFStdVideoFormat_DV_NTSC      = 0x00000006,
    ///ATSC digital television, SD (480i).
    MFStdVideoFormat_ATSC_SD480i  = 0x00000007,
    ///ATSC digital television, HD interlaced (1080i)
    MFStdVideoFormat_ATSC_HD1080i = 0x00000008,
    ///ATSC digital television, HD progressive (720p)
    MFStdVideoFormat_ATSC_HD720p  = 0x00000009,
}

alias __MIDL___MIDL_itf_mfobjects_0000_0012_0001 = int;
enum : int
{
    MEUnknown                                  = 0x00000000,
    MEError                                    = 0x00000001,
    MEExtendedType                             = 0x00000002,
    MENonFatalError                            = 0x00000003,
    MEGenericV1Anchor                          = 0x00000003,
    MESessionUnknown                           = 0x00000064,
    MESessionTopologySet                       = 0x00000065,
    MESessionTopologiesCleared                 = 0x00000066,
    MESessionStarted                           = 0x00000067,
    MESessionPaused                            = 0x00000068,
    MESessionStopped                           = 0x00000069,
    MESessionClosed                            = 0x0000006a,
    MESessionEnded                             = 0x0000006b,
    MESessionRateChanged                       = 0x0000006c,
    MESessionScrubSampleComplete               = 0x0000006d,
    MESessionCapabilitiesChanged               = 0x0000006e,
    MESessionTopologyStatus                    = 0x0000006f,
    MESessionNotifyPresentationTime            = 0x00000070,
    MENewPresentation                          = 0x00000071,
    MELicenseAcquisitionStart                  = 0x00000072,
    MELicenseAcquisitionCompleted              = 0x00000073,
    MEIndividualizationStart                   = 0x00000074,
    MEIndividualizationCompleted               = 0x00000075,
    MEEnablerProgress                          = 0x00000076,
    MEEnablerCompleted                         = 0x00000077,
    MEPolicyError                              = 0x00000078,
    MEPolicyReport                             = 0x00000079,
    MEBufferingStarted                         = 0x0000007a,
    MEBufferingStopped                         = 0x0000007b,
    MEConnectStart                             = 0x0000007c,
    MEConnectEnd                               = 0x0000007d,
    MEReconnectStart                           = 0x0000007e,
    MEReconnectEnd                             = 0x0000007f,
    MERendererEvent                            = 0x00000080,
    MESessionStreamSinkFormatChanged           = 0x00000081,
    MESessionV1Anchor                          = 0x00000081,
    MESourceUnknown                            = 0x000000c8,
    MESourceStarted                            = 0x000000c9,
    MEStreamStarted                            = 0x000000ca,
    MESourceSeeked                             = 0x000000cb,
    MEStreamSeeked                             = 0x000000cc,
    MENewStream                                = 0x000000cd,
    MEUpdatedStream                            = 0x000000ce,
    MESourceStopped                            = 0x000000cf,
    MEStreamStopped                            = 0x000000d0,
    MESourcePaused                             = 0x000000d1,
    MEStreamPaused                             = 0x000000d2,
    MEEndOfPresentation                        = 0x000000d3,
    MEEndOfStream                              = 0x000000d4,
    MEMediaSample                              = 0x000000d5,
    MEStreamTick                               = 0x000000d6,
    MEStreamThinMode                           = 0x000000d7,
    MEStreamFormatChanged                      = 0x000000d8,
    MESourceRateChanged                        = 0x000000d9,
    MEEndOfPresentationSegment                 = 0x000000da,
    MESourceCharacteristicsChanged             = 0x000000db,
    MESourceRateChangeRequested                = 0x000000dc,
    MESourceMetadataChanged                    = 0x000000dd,
    MESequencerSourceTopologyUpdated           = 0x000000de,
    MESourceV1Anchor                           = 0x000000de,
    MESinkUnknown                              = 0x0000012c,
    MEStreamSinkStarted                        = 0x0000012d,
    MEStreamSinkStopped                        = 0x0000012e,
    MEStreamSinkPaused                         = 0x0000012f,
    MEStreamSinkRateChanged                    = 0x00000130,
    MEStreamSinkRequestSample                  = 0x00000131,
    MEStreamSinkMarker                         = 0x00000132,
    MEStreamSinkPrerolled                      = 0x00000133,
    MEStreamSinkScrubSampleComplete            = 0x00000134,
    MEStreamSinkFormatChanged                  = 0x00000135,
    MEStreamSinkDeviceChanged                  = 0x00000136,
    MEQualityNotify                            = 0x00000137,
    MESinkInvalidated                          = 0x00000138,
    MEAudioSessionNameChanged                  = 0x00000139,
    MEAudioSessionVolumeChanged                = 0x0000013a,
    MEAudioSessionDeviceRemoved                = 0x0000013b,
    MEAudioSessionServerShutdown               = 0x0000013c,
    MEAudioSessionGroupingParamChanged         = 0x0000013d,
    MEAudioSessionIconChanged                  = 0x0000013e,
    MEAudioSessionFormatChanged                = 0x0000013f,
    MEAudioSessionDisconnected                 = 0x00000140,
    MEAudioSessionExclusiveModeOverride        = 0x00000141,
    MESinkV1Anchor                             = 0x00000141,
    MECaptureAudioSessionVolumeChanged         = 0x00000142,
    MECaptureAudioSessionDeviceRemoved         = 0x00000143,
    MECaptureAudioSessionFormatChanged         = 0x00000144,
    MECaptureAudioSessionDisconnected          = 0x00000145,
    MECaptureAudioSessionExclusiveModeOverride = 0x00000146,
    MECaptureAudioSessionServerShutdown        = 0x00000147,
    MESinkV2Anchor                             = 0x00000147,
    METrustUnknown                             = 0x00000190,
    MEPolicyChanged                            = 0x00000191,
    MEContentProtectionMessage                 = 0x00000192,
    MEPolicySet                                = 0x00000193,
    METrustV1Anchor                            = 0x00000193,
    MEWMDRMLicenseBackupCompleted              = 0x000001f4,
    MEWMDRMLicenseBackupProgress               = 0x000001f5,
    MEWMDRMLicenseRestoreCompleted             = 0x000001f6,
    MEWMDRMLicenseRestoreProgress              = 0x000001f7,
    MEWMDRMLicenseAcquisitionCompleted         = 0x000001fa,
    MEWMDRMIndividualizationCompleted          = 0x000001fc,
    MEWMDRMIndividualizationProgress           = 0x00000201,
    MEWMDRMProximityCompleted                  = 0x00000202,
    MEWMDRMLicenseStoreCleaned                 = 0x00000203,
    MEWMDRMRevocationDownloadCompleted         = 0x00000204,
    MEWMDRMV1Anchor                            = 0x00000204,
    METransformUnknown                         = 0x00000258,
    METransformNeedInput                       = 0x00000259,
    METransformHaveOutput                      = 0x0000025a,
    METransformDrainComplete                   = 0x0000025b,
    METransformMarker                          = 0x0000025c,
    METransformInputStreamStateChanged         = 0x0000025d,
    MEByteStreamCharacteristicsChanged         = 0x000002bc,
    MEVideoCaptureDeviceRemoved                = 0x00000320,
    MEVideoCaptureDevicePreempted              = 0x00000321,
    MEStreamSinkFormatInvalidated              = 0x00000322,
    MEEncodingParameters                       = 0x00000323,
    MEContentProtectionMetadata                = 0x00000384,
    MEDeviceThermalStateChanged                = 0x000003b6,
    MEReservedMax                              = 0x00002710,
}

///Specifies the origin for a seek request.
alias MFBYTESTREAM_SEEK_ORIGIN = int;
enum : int
{
    ///The seek position is specified relative to the start of the stream.
    msoBegin   = 0x00000000,
    ///The seek position is specified relative to the current read/write position in the stream.
    msoCurrent = 0x00000001,
}

///Specifies the requested access mode for opening a file.
alias MF_FILE_ACCESSMODE = int;
enum : int
{
    ///Read mode.
    MF_ACCESSMODE_READ      = 0x00000001,
    ///Write mode.
    MF_ACCESSMODE_WRITE     = 0x00000002,
    ///Read and write mode.
    MF_ACCESSMODE_READWRITE = 0x00000003,
}

///Specifies how to open or create a file.
alias MF_FILE_OPENMODE = int;
enum : int
{
    ///Open an existing file. Fail if the file does not exist.
    MF_OPENMODE_FAIL_IF_NOT_EXIST = 0x00000000,
    ///Create a new file. Fail if the file already exists.
    MF_OPENMODE_FAIL_IF_EXIST     = 0x00000001,
    ///Open an existing file and truncate it, so that the size is zero bytes. Fail if the file does not already exist.
    MF_OPENMODE_RESET_IF_EXIST    = 0x00000002,
    ///If the file does not exist, create a new file. If the file exists, open it.
    MF_OPENMODE_APPEND_IF_EXIST   = 0x00000003,
    ///Create a new file. If the file exists, overwrite the file.
    MF_OPENMODE_DELETE_IF_EXIST   = 0x00000004,
}

///Specifies the behavior when opening a file.
alias MF_FILE_FLAGS = int;
enum : int
{
    ///Use the default behavior.
    MF_FILEFLAGS_NONE                = 0x00000000,
    ///Open the file with no system caching.
    MF_FILEFLAGS_NOBUFFERING         = 0x00000001,
    ///Subsequent open operations can have write access to the file. <div class="alert"><b>Note</b> Requires Windows 7
    ///or later.</div> <div> </div>
    MF_FILEFLAGS_ALLOW_WRITE_SHARING = 0x00000002,
}

///Defines policy settings for the IMFPluginControl2::SetPolicy method.
alias MF_PLUGIN_CONTROL_POLICY = int;
enum : int
{
    ///Enumerate all registered sources and transforms.
    MF_PLUGIN_CONTROL_POLICY_USE_ALL_PLUGINS          = 0x00000000,
    ///Enumerate only approved sources and transforms. Third-party components are excluded unless the component is
    ///registered with a valid merit value, or the component was registered locally by the application.
    MF_PLUGIN_CONTROL_POLICY_USE_APPROVED_PLUGINS     = 0x00000001,
    ///Restrict enumeration to components intended for use in a web browser.
    MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS          = 0x00000002,
    MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS_EDGEMODE = 0x00000003,
}

alias MF_STREAM_STATE = int;
enum : int
{
    MF_STREAM_STATE_STOPPED = 0x00000000,
    MF_STREAM_STATE_PAUSED  = 0x00000001,
    MF_STREAM_STATE_RUNNING = 0x00000002,
}

///Defines flags for the IMFTransform::ProcessInput method. Currently no flags are defined.
alias _MFT_INPUT_DATA_BUFFER_FLAGS = int;
enum : int
{
    ///Reserved. Do not use.
    MFT_INPUT_DATA_BUFFER_PLACEHOLDER = 0xffffffff,
}

///Defines flags for the IMFTransform::ProcessOutput method.
alias _MFT_OUTPUT_DATA_BUFFER_FLAGS = int;
enum : int
{
    ///The MFT can still generate output from this stream without receiving any more input. Call ProcessOutput again to
    ///process the next batch of input data.
    MFT_OUTPUT_DATA_BUFFER_INCOMPLETE    = 0x01000000,
    ///The format has changed on this output stream, or there is a new preferred format for this stream. When this flag
    ///is set, the MFT clears the media type for the stream. The ProcessOutput method returns
    ///MF_E_TRANSFORM_STREAM_CHANGE and generates no output for any stream. Further calls to IMFTransform::ProcessInput
    ///or <b>ProcessOutput</b> will fail until the client sets a new media type.
    MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE = 0x00000100,
    ///The MFT has removed this output stream. The output stream must have the MFT_OUTPUT_STREAM_REMOVABLE flag. (See
    ///IMFTransform::GetOutputStreamInfo.) When the MFT removes an output stream, the MFT returns this status code on
    ///the next call to ProcessOutput after the last output sample has been produced. When the MFT returns this status
    ///code, it does not modify any sample contained in the <b>pSample</b> member of the MFT_OUTPUT_DATA_BUFFER
    ///structure, nor does it allocate a new sample if <b>pSample</b> is <b>NULL</b>. After this status code is
    ///returned, the stream identifier for this output stream is no longer valid. The client should no longer provide an
    ///MFT_OUTPUT_DATA_BUFFER structure for that stream when it calls ProcessOutput. The ProcessOutput method does not
    ///return <b>MF_E_TRANSFORM_STREAM_CHANGE</b> when a stream ends, unless there is a change in another stream that
    ///requires this return code.
    MFT_OUTPUT_DATA_BUFFER_STREAM_END    = 0x00000200,
    ///There is no sample ready for this stream. This flag might be set if the MFT has multiple output streams that
    ///produce data at different times. It sets this flag for each stream that is not ready to produce data. It does not
    ///modify the output sample contained in the <b>pSample</b> member of the MFT_OUTPUT_DATA_BUFFER structure, nor does
    ///it allocate a new sample is <b>pSample</b> is <b>NULL</b>. If no streams are ready to produce output, the MFT
    ///does not set this flag. Instead, the ProcessOutput method returns MF_E_TRANSFORM_NEED_MORE_INPUT.
    MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE     = 0x00000300,
}

///Indicates the status of an input stream on a Media Foundation transform (MFT).
alias _MFT_INPUT_STATUS_FLAGS = int;
enum : int
{
    ///The input stream can receive more data at this time. To deliver more input data, call IMFTransform::ProcessInput.
    MFT_INPUT_STATUS_ACCEPT_DATA = 0x00000001,
}

///Indicates whether a Media Foundation transform (MFT) can produce output data.
alias _MFT_OUTPUT_STATUS_FLAGS = int;
enum : int
{
    ///There is a sample available for at least one output stream. To retrieve the available output samples, call
    ///IMFTransform::ProcessOutput.
    MFT_OUTPUT_STATUS_SAMPLE_READY = 0x00000001,
}

///Describes an input stream on a Media Foundation transform (MFT).
alias _MFT_INPUT_STREAM_INFO_FLAGS = int;
enum : int
{
    ///Each media sample (IMFSample interface) of input data must contain complete, unbroken units of data. The
    ///definition of a <i>unit of data</i> depends on the media type: For uncompressed video, a video frame; for
    ///compressed data, a compressed packet; for uncompressed audio, a single audio frame. For uncompressed audio
    ///formats, this flag is always implied. (It is valid to set the flag, but not required.) An uncompressed audio
    ///frame should never span more than one media sample.
    MFT_INPUT_STREAM_WHOLE_SAMPLES            = 0x00000001,
    ///Each media sample that the client provides as input must contain exactly one unit of data, as defined for the
    ///MFT_INPUT_STREAM_WHOLE_SAMPLES flag. If this flag is present, the MFT_INPUT_STREAM_WHOLE_SAMPLES flag must also
    ///be present. An MFT that processes uncompressed audio should not set this flag. The MFT should accept buffers that
    ///contain more than a single audio frame, for efficiency.
    MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER = 0x00000002,
    ///All input samples must be the same size. The size is given in the <b>cbSize</b> member of the
    ///MFT_INPUT_STREAM_INFO structure. The MFT must provide this value. During processing, the MFT should verify the
    ///size of input samples, and may drop samples with incorrect size.
    MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE        = 0x00000004,
    ///The MFT might hold one or more input samples after IMFTransform::ProcessOutput is called. If this flag is
    ///present, the <b>hnsMaxLatency</b> member of the MFT_INPUT_STREAM_INFO structure gives the maximum latency, and
    ///the <b>cbMaxLookahead</b> member gives the maximum number of bytes of lookahead.
    MFT_INPUT_STREAM_HOLDS_BUFFERS            = 0x00000008,
    ///The MFT does not hold input samples after the IMFTransform::ProcessInput method returns. It releases the sample
    ///before the <b>ProcessInput</b> method returns. If this flag is absent, the MFT might hold a reference count on
    ///the samples that are passed to the ProcessInput method. The client must not re-use or delete the buffer memory
    ///until the MFT releases the sample's IMFSample pointer. If this flag is absent, it does not guarantee that the MFT
    ///holds a reference count on the input samples. It is valid for an MFT to release input samples in ProcessInput
    ///even if the MFT does not set this flag. However, setting this flag might enable to client to optimize how it
    ///re-uses buffers. An MFT should not set this flag if it ever holds onto an input sample after returning from
    ///ProcessInput.
    MFT_INPUT_STREAM_DOES_NOT_ADDREF          = 0x00000100,
    ///This input stream can be removed by calling IMFTransform::DeleteInputStream.
    MFT_INPUT_STREAM_REMOVABLE                = 0x00000200,
    ///This input stream is optional. The transform can produce output without receiving input from this stream. The
    ///caller can deselect the stream by not setting a media type or by setting a <b>NULL</b> media type. It is possible
    ///for every input stream on a transform to be optional, but at least one input must be selected in order to produce
    ///output.
    MFT_INPUT_STREAM_OPTIONAL                 = 0x00000400,
    ///The MFT can perform in-place processing. In this mode, the MFT directly modifies the input buffer. When the
    ///client calls ProcessOutput, the same sample that was delivered to this stream is returned in the output stream
    ///that has a matching stream identifier. This flag implies that the MFT holds onto the input buffer, so this flag
    ///cannot combined with the MFT_INPUT_STREAM_DOES_NOT_ADDREF flag. If this flag is present, the MFT must set the
    ///MFT_OUTPUT_STREAM_PROVIDES_SAMPLES or MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES flag for the output stream that
    ///corresponds to this input stream. (See IMFTransform::GetOutputStreamInfo).
    MFT_INPUT_STREAM_PROCESSES_IN_PLACE       = 0x00000800,
}

///Describes an output stream on a Media Foundation transform (MFT).
alias _MFT_OUTPUT_STREAM_INFO_FLAGS = int;
enum : int
{
    ///Each media sample (IMFSample interface) of output data from the MFT contains complete, unbroken units of data.
    ///The definition of a <i>unit of data</i> depends on the media type: For uncompressed video, a video frame; for
    ///compressed data, a compressed packet; for uncompressed audio, a single audio frame. For uncompressed audio
    ///formats, this flag is always implied. (It is valid to set the flag, but not required.) An uncompressed audio
    ///frame should never span more than one media sample.
    MFT_OUTPUT_STREAM_WHOLE_SAMPLES            = 0x00000001,
    ///Each output sample contains exactly one unit of data, as defined for the MFT_OUTPUT_STREAM_WHOLE_SAMPLES flag. If
    ///this flag is present, the MFT_OUTPUT_STREAM_WHOLE_SAMPLES flag must also be present. An MFT that outputs
    ///uncompressed audio should not set this flag. For efficiency, it should output more than one audio frame at a
    ///time.
    MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER = 0x00000002,
    ///All output samples are the same size.
    MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE        = 0x00000004,
    ///The MFT can discard the output data from this output stream, if requested by the client. To discard the output,
    ///set the MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER flag in the IMFTransform::ProcessOutput method.
    MFT_OUTPUT_STREAM_DISCARDABLE              = 0x00000008,
    ///This output stream is optional. The client can deselect the stream by not setting a media type or by setting a
    ///<b>NULL</b> media type. When an optional stream is deselected, it does not produce any output data.
    MFT_OUTPUT_STREAM_OPTIONAL                 = 0x00000010,
    ///The MFT provides the output samples for this stream, either by allocating them internally or by operating
    ///directly on the input samples. The MFT cannot use output samples provided by the client for this stream. If this
    ///flag is not set, the MFT must set <b>cbSize</b> to a nonzero value in the MFT_OUTPUT_STREAM_INFO structure, so
    ///that the client can allocate the correct buffer size. For more information, see
    ///IMFTransform::GetOutputStreamInfo. This flag cannot be combined with the MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES
    ///flag.
    MFT_OUTPUT_STREAM_PROVIDES_SAMPLES         = 0x00000100,
    ///The MFT can either provide output samples for this stream or it can use samples that the client allocates. This
    ///flag cannot be combined with the MFT_OUTPUT_STREAM_PROVIDES_SAMPLES flag. If the MFT does not set this flag or
    ///the MFT_OUTPUT_STREAM_PROVIDES_SAMPLES flag, the client must allocate the samples for this output stream. The MFT
    ///will not provide its own samples.
    MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES      = 0x00000200,
    ///The MFT does not require the client to process the output for this stream. If the client continues to send input
    ///data without getting the output from this stream, the MFT simply discards the previous input.
    MFT_OUTPUT_STREAM_LAZY_READ                = 0x00000400,
    ///The MFT might remove this output stream during streaming. This flag typically applies to demultiplexers, where
    ///the input data contains multiple streams that can start and stop during streaming. For more information, see
    ///IMFTransform::ProcessOutput.
    MFT_OUTPUT_STREAM_REMOVABLE                = 0x00000800,
}

///Defines flags for the setting or testing the media type on a Media Foundation transform (MFT).
alias _MFT_SET_TYPE_FLAGS = int;
enum : int
{
    ///Test the proposed media type, but do not set it.
    MFT_SET_TYPE_TEST_ONLY = 0x00000001,
}

///Defines flags for processing output samples in a Media Foundation transform (MFT).
alias _MFT_PROCESS_OUTPUT_FLAGS = int;
enum : int
{
    ///Do not produce output for streams in which the <b>pSample</b> member of the MFT_OUTPUT_DATA_BUFFER structure is
    ///<b>NULL</b>. This flag is not valid unless the MFT has marked the output stream with the
    ///MFT_OUTPUT_STREAM_DISCARDABLE or MFT_OUTPUT_STREAM_LAZY_READ flag. For more information, see
    ///IMFTransform::GetOutputStreamInfo.
    MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER = 0x00000001,
    ///Regenerates the last output sample. This flag is only used by video processing MFTs. <b>Note</b> Requires Windows
    ///8.
    MFT_PROCESS_OUTPUT_REGENERATE_LAST_OUTPUT = 0x00000002,
}

///Indicates the status of a call to IMFTransform::ProcessOutput.
alias _MFT_PROCESS_OUTPUT_STATUS = int;
enum : int
{
    ///The Media Foundation transform (MFT) has created one or more new output streams.
    MFT_PROCESS_OUTPUT_STATUS_NEW_STREAMS = 0x00000100,
}

///Not supported. <div class="alert"><b>Note</b> Earlier versions of this documentation described the
///<b>_MFT_DRAIN_TYPE</b> enumeration incorrectly. The enumeration is not supported. For more information, see
///MFT_MESSAGE_TYPE.</div><div> </div>
alias MFT_DRAIN_TYPE = int;
enum : int
{
    ///Reserved.
    MFT_DRAIN_PRODUCE_TAILS = 0x00000000,
    ///Reserved.
    MFT_DRAIN_NO_TAILS      = 0x00000001,
}

///Defines messages for a Media Foundation transform (MFT). To send a message to an MFT, call
///IMFTransform::ProcessMessage.
alias MFT_MESSAGE_TYPE = int;
enum : int
{
    ///Requests the MFT to flush all stored data. See MFT_MESSAGE_COMMAND_FLUSH.
    MFT_MESSAGE_COMMAND_FLUSH                   = 0x00000000,
    ///Requests the MFT to drain any stored data. See MFT_MESSAGE_COMMAND_DRAIN.
    MFT_MESSAGE_COMMAND_DRAIN                   = 0x00000001,
    ///Sets or clears the Direct3D Device Manager for DirectX Video Accereration (DXVA). See
    ///MFT_MESSAGE_SET_D3D_MANAGER.
    MFT_MESSAGE_SET_D3D_MANAGER                 = 0x00000002,
    ///<b>Note</b> Requires Windows 7.
    MFT_MESSAGE_DROP_SAMPLES                    = 0x00000003,
    ///<b>Note</b> Requires Windows 8.
    MFT_MESSAGE_COMMAND_TICK                    = 0x00000004,
    ///Notifies the MFT that streaming is about to begin. See MFT_MESSAGE_NOTIFY_BEGIN_STREAMING.
    MFT_MESSAGE_NOTIFY_BEGIN_STREAMING          = 0x10000000,
    ///Notifies the MFT that streaming is about to end. See MFT_MESSAGE_NOTIFY_END_STREAMING.
    MFT_MESSAGE_NOTIFY_END_STREAMING            = 0x10000001,
    ///Notifies the MFT that an input stream has ended. See MFT_MESSAGE_NOTIFY_END_OF_STREAM.
    MFT_MESSAGE_NOTIFY_END_OF_STREAM            = 0x10000002,
    ///Notifies the MFT that the first sample is about to be processed. See MFT_MESSAGE_NOTIFY_START_OF_STREAM.
    MFT_MESSAGE_NOTIFY_START_OF_STREAM          = 0x10000003,
    MFT_MESSAGE_NOTIFY_RELEASE_RESOURCES        = 0x10000004,
    MFT_MESSAGE_NOTIFY_REACQUIRE_RESOURCES      = 0x10000005,
    MFT_MESSAGE_NOTIFY_EVENT                    = 0x10000006,
    MFT_MESSAGE_COMMAND_SET_OUTPUT_STREAM_STATE = 0x10000007,
    MFT_MESSAGE_COMMAND_FLUSH_OUTPUT_STREAM     = 0x10000008,
    ///Marks a point in the stream. This message applies only to asynchronous MFTs. See MFT_MESSAGE_COMMAND_MARKER. <div
    ///class="alert"><b>Note</b> Requires Windows 7</div> <div> </div>
    MFT_MESSAGE_COMMAND_MARKER                  = 0x20000000,
}

enum DeviceStreamState : int
{
    DeviceStreamState_Stop     = 0x00000000,
    DeviceStreamState_Pause    = 0x00000001,
    DeviceStreamState_Run      = 0x00000002,
    DeviceStreamState_Disabled = 0x00000003,
}

///Specifies how to output a 3D stereoscopic video stream.
enum MF3DVideoOutputType : int
{
    ///Output the base view only. Discard the other view.
    MF3DVideoOutputType_BaseView = 0x00000000,
    ///Output a stereo view (two buffers).
    MF3DVideoOutputType_Stereo   = 0x00000001,
}

alias MFT_AUDIO_DECODER_DEGRADATION_REASON = int;
enum : int
{
    MFT_AUDIO_DECODER_DEGRADATION_REASON_NONE                  = 0x00000000,
    MFT_AUDIO_DECODER_DEGRADATION_REASON_LICENSING_REQUIREMENT = 0x00000001,
}

alias MFT_AUDIO_DECODER_DEGRADATION_TYPE = int;
enum : int
{
    MFT_AUDIO_DECODER_DEGRADATION_TYPE_NONE            = 0x00000000,
    MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX2CHANNEL = 0x00000001,
    MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX6CHANNEL = 0x00000002,
    MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX8CHANNEL = 0x00000003,
}

///Defines the behavior of the IMFMediaSession::SetTopology method.
alias MFSESSION_SETTOPOLOGY_FLAGS = int;
enum : int
{
    ///Stop the current presentation, clear all pending presentations, and immediately queue the new topology (specified
    ///by the <i>pTopology</i> parameter). If the <i>pTopology</i> parameter is <b>NULL</b>, this flag has no effect.
    MFSESSION_SETTOPOLOGY_IMMEDIATE     = 0x00000001,
    ///The topology does not need to be resolved. Use this flag if you are setting a full topology.
    MFSESSION_SETTOPOLOGY_NORESOLUTION  = 0x00000002,
    ///<div class="alert"><b>Note</b> Requires Windows 7.</div> <div> </div> Clear the current topology, as follows:
    ///<ul> <li>If <i>pTopology</i> is not <b>NULL</b>, the topology is cleared only if <i>pTopology</i> matches the
    ///current topology (that is, only if <i>pTopology</i> points to the current topology). </li> <li>If the
    ///<i>pTopology</i> parameter is <b>NULL</b>, the current topology is cleared, regardless of which topology is
    ///current.</li> </ul> Pending topologies are not removed from the playback queue. If there is a pending topology on
    ///the queue, that topology will be loaded after the current topology is cleared. Otherwise, playback simply stops.
    ///To remove all of the pending topologies from the queue, call IMFMediaSession::ClearTopologies.
    MFSESSION_SETTOPOLOGY_CLEAR_CURRENT = 0x00000004,
}

///Defines flags for the IMFMediaSession::GetFullTopology method.
alias MFSESSION_GETFULLTOPOLOGY_FLAGS = int;
enum : int
{
    ///Get the full topology for the presentation that the Media Session is currently playing.
    MFSESSION_GETFULLTOPOLOGY_CURRENT = 0x00000001,
}

///Contains flags that define the behavior of the MFCreatePMPMediaSession function.
alias MFPMPSESSION_CREATION_FLAGS = int;
enum : int
{
    ///If this flag is set, the Protected Media Path (PMP) Media Session is created in an unprotected process. You can
    ///use the unprotected process to play clear content but not protected content. If this flag is not set, the PMP
    ///Media Session is created in a protected process. In that case, the protected process is used for both protected
    ///content and clear content.
    MFPMPSESSION_UNPROTECTED_PROCESS = 0x00000001,
    MFPMPSESSION_IN_PROCESS          = 0x00000002,
}

///Defines the object types that are created by the source resolver.
alias MF_OBJECT_TYPE = int;
enum : int
{
    ///Media source. You can query the object for the IMFMediaSource interface.
    MF_OBJECT_MEDIASOURCE = 0x00000000,
    ///Byte stream. You can query the object for the IMFByteStream interface.
    MF_OBJECT_BYTESTREAM  = 0x00000001,
    ///Invalid type.
    MF_OBJECT_INVALID     = 0x00000002,
}

alias __MIDL___MIDL_itf_mfidl_0000_0001_0001 = int;
enum : int
{
    MF_RESOLUTION_MEDIASOURCE                                           = 0x00000001,
    MF_RESOLUTION_BYTESTREAM                                            = 0x00000002,
    MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE = 0x00000010,
    MF_RESOLUTION_KEEP_BYTE_STREAM_ALIVE_ON_FAIL                        = 0x00000020,
    MF_RESOLUTION_DISABLE_LOCAL_PLUGINS                                 = 0x00000040,
    MF_RESOLUTION_PLUGIN_CONTROL_POLICY_APPROVED_ONLY                   = 0x00000080,
    MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY                        = 0x00000100,
    MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE               = 0x00000200,
    MF_RESOLUTION_ENABLE_STORE_PLUGINS                                  = 0x00000400,
    MF_RESOLUTION_READ                                                  = 0x00010000,
    MF_RESOLUTION_WRITE                                                 = 0x00020000,
}

///Specifies how the topology loader connects a topology node. This enumeration is used with the
///MF_TOPONODE_CONNECT_METHOD attribute.
alias MF_CONNECT_METHOD = int;
enum : int
{
    ///Connect the node directly to its upstream neighbor. Fail otherwise.
    MF_CONNECT_DIRECT                          = 0x00000000,
    ///Add a converter transform upstream from this node, if needed to complete the connection. Converter transforms
    ///include color-space converters for video, and audio resamplers for audio.
    MF_CONNECT_ALLOW_CONVERTER                 = 0x00000001,
    ///Add a decoder transform upstream upstream from this node, if needed to complete the connection. The numeric value
    ///of this flag includes the <b>MF_CONNECT_ALLOW_CONVERTER</b> flag. Therefore, setting the
    ///<b>MF_CONNECT_ALLOW_DECODER</b> flag sets the <b>MF_CONNECT_ALLOW_CONVERTER</b> flag as well.
    MF_CONNECT_ALLOW_DECODER                   = 0x00000003,
    ///Controls the order in which the topology loader attempts to use different output types from this node. Currently,
    ///this flag applies only to source nodes. For more information, see MF_TOPOLOGY_ENUMERATE_SOURCE_TYPES. <div
    ///class="alert"><b>Note</b> Requires Windows 7 or later.</div> <div> </div>
    MF_CONNECT_RESOLVE_INDEPENDENT_OUTPUTTYPES = 0x00000004,
    ///This node is optional. If the topology loader cannot connect this node, it will skip the node and continue.
    MF_CONNECT_AS_OPTIONAL                     = 0x00010000,
    ///The entire topology branch starting at this node is optional. If the topology loader cannot resolve this branch,
    ///it will skip the branch and continue.
    MF_CONNECT_AS_OPTIONAL_BRANCH              = 0x00020000,
}

///Defines status flags for the MF_TOPOLOGY_RESOLUTION_STATUS attribute.
alias MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS = int;
enum : int
{
    ///The topology was resolved successfully.
    MF_TOPOLOGY_RESOLUTION_SUCCEEDED            = 0x00000000,
    ///An optional topology node was rejected because the topology loader could not find a media type for the
    ///connection.
    MF_OPTIONAL_NODE_REJECTED_MEDIA_TYPE        = 0x00000001,
    ///An optional topology node was rejected because it could not be loaded into a protected process.
    MF_OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS = 0x00000002,
}

///Defines the characteristics of a media source. These flags are retrieved by the IMFMediaSource::GetCharacteristics
///method.
alias MFMEDIASOURCE_CHARACTERISTICS = int;
enum : int
{
    ///This flag indicates a data source that runs constantly, such as a live presentation. If the source is stopped and
    ///then restarted, there will be a gap in the content.
    MFMEDIASOURCE_IS_LIVE                    = 0x00000001,
    ///The media source supports seeking.
    MFMEDIASOURCE_CAN_SEEK                   = 0x00000002,
    ///The source can pause.
    MFMEDIASOURCE_CAN_PAUSE                  = 0x00000004,
    ///The media source downloads content. It might take a long time to seek to parts of the content that have not been
    ///downloaded.
    MFMEDIASOURCE_HAS_SLOW_SEEK              = 0x00000008,
    ///The media source delivers a playlist, which might contain more than one entry. After the first playlist entry has
    ///completed, the media source signals the start of each new playlist entry by sending an MENewPresentation event.
    ///The event contains a presentation descriptor for the entry. <div class="alert"><b>Note</b> Requires Windows 7 or
    ///later.</div> <div> </div>
    MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS = 0x00000010,
    ///The media source can skip forward in the playlist. Applies only if the MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS
    ///flag is present. <div class="alert"><b>Note</b> Requires Windows 7 or later.</div> <div> </div>
    MFMEDIASOURCE_CAN_SKIPFORWARD            = 0x00000020,
    ///The media source can skip backward in the playlist. <div class="alert"><b>Note</b> Requires Windows 7 or
    ///later.</div> <div> </div>
    MFMEDIASOURCE_CAN_SKIPBACKWARD           = 0x00000040,
    ///The media source is not currently using the network to receive the content. Networking hardware may enter a power
    ///saving state when this bit is set. <div class="alert"><b>Note</b> Requires Windows 8 or later.</div> <div> </div>
    MFMEDIASOURCE_DOES_NOT_USE_NETWORK       = 0x00000080,
}

///Defines stream marker information for the IMFStreamSink::PlaceMarker method. The PlaceMarker method places a marker
///on the stream between samples. The <b>MFSTREAMSINK_MARKER_TYPE</b> enumeration defines the marker type and the type
///of information associated with the marker.
alias MFSTREAMSINK_MARKER_TYPE = int;
enum : int
{
    ///This marker is for the application's use and does not convey any information to the stream sink.
    MFSTREAMSINK_MARKER_DEFAULT      = 0x00000000,
    ///This marker indicates the end of a segment within a presentation. There might be a gap in the stream until the
    ///next segment starts. There is no data associated with this marker.
    MFSTREAMSINK_MARKER_ENDOFSEGMENT = 0x00000001,
    ///This marker indicates that there is a gap in the stream. The marker data is a <b>LONGLONG</b> value (VT_I8) that
    ///specifies the time for the missing sample. The next sample received after this marker might but will not
    ///necessarily have the discontinuity flag: the data might remain continuous after the time gap. This marker
    ///corresponds to an MEStreamTick event from the stream.
    MFSTREAMSINK_MARKER_TICK         = 0x00000002,
    ///This marker contains a media event. The marker data is a pointer to the event's IMFMediaEvent interface
    ///(VT_UNKNOWN).
    MFSTREAMSINK_MARKER_EVENT        = 0x00000003,
}

///Specifies how to rotate a video image.
alias MF_VIDEO_PROCESSOR_ROTATION = int;
enum : int
{
    ///Do not rotate the image.
    ROTATION_NONE   = 0x00000000,
    ///Rotate the image to the correct viewing orientation.
    ROTATION_NORMAL = 0x00000001,
}

///Specifies how to flip a video image.
alias MF_VIDEO_PROCESSOR_MIRROR = int;
enum : int
{
    ///Do not flip the image.
    MIRROR_NONE       = 0x00000000,
    ///Flip the image horizontally.
    MIRROR_HORIZONTAL = 0x00000001,
    ///Flip the image vertically.
    MIRROR_VERTICAL   = 0x00000002,
}

enum MFVideoSphericalFormat : int
{
    MFVideoSphericalFormat_Unsupported     = 0x00000000,
    MFVideoSphericalFormat_Equirectangular = 0x00000001,
    MFVideoSphericalFormat_CubeMap         = 0x00000002,
    MFVideoSphericalFormat_3DMesh          = 0x00000003,
}

enum MFVideoSphericalProjectionMode : int
{
    MFVideoSphericalProjectionMode_Spherical = 0x00000000,
    MFVideoSphericalProjectionMode_Flat      = 0x00000001,
}

///Specifies whether the topology loader enables Microsoft DirectX Video Acceleration (DXVA) in the topology.
alias MFTOPOLOGY_DXVA_MODE = int;
enum : int
{
    ///The topology loader enables DXVA on the decoder if possible, and drops optional Media Foundation transforms
    ///(MFTs) that do not support DXVA.
    MFTOPOLOGY_DXVA_DEFAULT = 0x00000000,
    ///The topology loader disables all video acceleration. This setting forces software processing, even when the
    ///decoder supports DXVA.
    MFTOPOLOGY_DXVA_NONE    = 0x00000001,
    ///The topology loader enables DXVA on every MFT that supports it.
    MFTOPOLOGY_DXVA_FULL    = 0x00000002,
}

///Specifies whether the topology loader will insert hardware-based Media Foundation transforms (MFTs) into the
///topology.
alias MFTOPOLOGY_HARDWARE_MODE = int;
enum : int
{
    ///Use only software MFTs. Do not use hardware-based MFTs. This mode is the default, for backward compatibility with
    ///existing applications.
    MFTOPOLOGY_HWMODE_SOFTWARE_ONLY     = 0x00000000,
    ///Use hardware-based MFTs when possible, and software MFTs otherwise. This mode is the recommended one.
    MFTOPOLOGY_HWMODE_USE_HARDWARE      = 0x00000001,
    ///If hardware-based MFTs are available, the topoloader will insert them. If not, the connection will fail.
    ///Supported in Windows 8.1 and later.
    MFTOPOLOGY_HWMODE_USE_ONLY_HARDWARE = 0x00000002,
}

///Defines the type of a topology node.
alias MF_TOPOLOGY_TYPE = int;
enum : int
{
    ///Output node. Represents a media sink in the topology.
    MF_TOPOLOGY_OUTPUT_NODE       = 0x00000000,
    ///Source node. Represents a media stream in the topology.
    MF_TOPOLOGY_SOURCESTREAM_NODE = 0x00000001,
    ///Transform node. Represents a Media Foundation Transform (MFT) in the topology.
    MF_TOPOLOGY_TRANSFORM_NODE    = 0x00000002,
    ///Tee node. A tee node does not hold a pointer to an object. Instead, it represents a fork in the stream. A tee
    ///node has one input and multiple outputs, and samples from the upstream node are delivered to all of the
    ///downstream nodes.
    MF_TOPOLOGY_TEE_NODE          = 0x00000003,
    ///Reserved.
    MF_TOPOLOGY_MAX               = 0xffffffff,
}

///Defines when a transform in a topology is flushed.
alias MF_TOPONODE_FLUSH_MODE = int;
enum : int
{
    ///The transform is flushed whenever the stream changes, including seeks and new segments.
    MF_TOPONODE_FLUSH_ALWAYS = 0x00000000,
    ///The transform is flushed when seeking is performed on the stream.
    MF_TOPONODE_FLUSH_SEEK   = 0x00000001,
    ///The transform is never flushed during streaming. It is flushed only when the object is released.
    MF_TOPONODE_FLUSH_NEVER  = 0x00000002,
}

///Defines at what times a transform in a topology is drained.
alias MF_TOPONODE_DRAIN_MODE = int;
enum : int
{
    ///The transform is drained when the end of a stream is reached. It is not drained when markout is reached at the
    ///end of a segment.
    MF_TOPONODE_DRAIN_DEFAULT = 0x00000000,
    ///The transform is drained whenever a topology ends.
    MF_TOPONODE_DRAIN_ALWAYS  = 0x00000001,
    ///The transform is never drained.
    MF_TOPONODE_DRAIN_NEVER   = 0x00000002,
}

///Contains flags that describe the characteristics of a clock. These flags are returned by the
///IMFClock::GetClockCharacteristics method.
alias MFCLOCK_CHARACTERISTICS_FLAGS = int;
enum : int
{
    ///The clock times returned by the IMFClock::GetCorrelatedTime method are in units of 100 nanoseconds. If this flag
    ///is absent, call IMFClock::GetProperties to get the clock frequency. The clock frequency is given in the
    ///<b>qwClockFrequency</b> member of the MFCLOCK_PROPERTIES structure returned by that method.
    MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ = 0x00000002,
    ///The clock is always running. If this flag is present, the clock cannot be paused or stopped. If this flag is
    ///absent, call the IMFClock::GetState method to get the current state.
    MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING  = 0x00000004,
    ///The clock times are generated from the system clock.
    MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK = 0x00000008,
}

///Defines the state of a clock.
alias MFCLOCK_STATE = int;
enum : int
{
    ///The clock is invalid. A clock might be invalid for several reasons. Some clocks return this state before the
    ///first start. This state can also occur if the underlying device is lost.
    MFCLOCK_STATE_INVALID = 0x00000000,
    ///The clock is running. While the clock is running, the time advances at the clock's frequency and current rate.
    MFCLOCK_STATE_RUNNING = 0x00000001,
    ///The clock is stopped. While stopped, the clock reports a time of 0.
    MFCLOCK_STATE_STOPPED = 0x00000002,
    ///The clock is paused. While paused, the clock reports the time it was paused.
    MFCLOCK_STATE_PAUSED  = 0x00000003,
}

///Defines properties of a clock.
alias MFCLOCK_RELATIONAL_FLAGS = int;
enum : int
{
    ///Jitter values are always negative. In other words, the time returned by IMFClock::GetCorrelatedTime might jitter
    ///behind the actual clock time, but will never jitter ahead of the actual time. If this flag is not present, the
    ///clock might jitter in either direction.
    MFCLOCK_RELATIONAL_FLAG_JITTER_NEVER_AHEAD = 0x00000001,
}

///Contains flags for the IMFTimer::SetTimer method.
alias MFTIMER_FLAGS = int;
enum : int
{
    ///The time passed to the timer is relative to the current time. If this flag is absent, the time is expressed as an
    ///absolute clock time.
    MFTIMER_RELATIVE = 0x00000001,
}

alias __MIDL___MIDL_itf_mfidl_0000_0029_0001 = int;
enum : int
{
    MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL = 0x00000001,
}

alias __MIDL___MIDL_itf_mfidl_0000_0029_0002 = int;
enum : int
{
    MF_ACTIVATE_CUSTOM_PRESENTER_ALLOWFAIL = 0x00000001,
}

///Describes the current status of a call to the IMFShutdown::Shutdown method.
alias MFSHUTDOWN_STATUS = int;
enum : int
{
    ///The shutdown operation has started but is not yet complete.
    MFSHUTDOWN_INITIATED = 0x00000000,
    ///Shutdown is complete.
    MFSHUTDOWN_COMPLETED = 0x00000001,
}

///Indicates whether the URL is from a trusted source.
alias MF_URL_TRUST_STATUS = int;
enum : int
{
    ///The validity of the URL cannot be guaranteed because it is not signed. The application should warn the user.
    MF_LICENSE_URL_UNTRUSTED = 0x00000000,
    ///The URL is the original one provided with the content.
    MF_LICENSE_URL_TRUSTED   = 0x00000001,
    ///The URL was originally signed and has been tampered with. The file should be considered corrupted, and the
    ///application should not navigate to the URL without issuing a strong warning the user.
    MF_LICENSE_URL_TAMPERED  = 0x00000002,
}

///Specifies the direction of playback (forward or reverse).
alias MFRATE_DIRECTION = int;
enum : int
{
    ///Forward playback.
    MFRATE_FORWARD = 0x00000000,
    ///Reverse playback.
    MFRATE_REVERSE = 0x00000001,
}

///Specifies how aggressively a pipeline component should drop samples.
alias MF_QUALITY_DROP_MODE = int;
enum : int
{
    ///Normal processing of samples. Drop mode is disabled.
    MF_DROP_MODE_NONE = 0x00000000,
    ///First drop mode (least aggressive).
    MF_DROP_MODE_1    = 0x00000001,
    ///Second drop mode.
    MF_DROP_MODE_2    = 0x00000002,
    ///Third drop mode.
    MF_DROP_MODE_3    = 0x00000003,
    ///Fourth drop mode.
    MF_DROP_MODE_4    = 0x00000004,
    ///Fifth drop mode (most aggressive, if it is supported; see Remarks).
    MF_DROP_MODE_5    = 0x00000005,
    ///Maximum number of drop modes. This value is not a valid flag.
    MF_NUM_DROP_MODES = 0x00000006,
}

///Specifies the quality level for a pipeline component. The quality level determines how the component consumes or
///produces samples.
alias MF_QUALITY_LEVEL = int;
enum : int
{
    ///Normal quality.
    MF_QUALITY_NORMAL         = 0x00000000,
    ///One level below normal quality.
    MF_QUALITY_NORMAL_MINUS_1 = 0x00000001,
    ///Two levels below normal quality.
    MF_QUALITY_NORMAL_MINUS_2 = 0x00000002,
    ///Three levels below normal quality.
    MF_QUALITY_NORMAL_MINUS_3 = 0x00000003,
    ///Four levels below normal quality.
    MF_QUALITY_NORMAL_MINUS_4 = 0x00000004,
    ///Five levels below normal quality.
    MF_QUALITY_NORMAL_MINUS_5 = 0x00000005,
    ///Maximum number of quality levels. This value is not a valid flag.
    MF_NUM_QUALITY_LEVELS     = 0x00000006,
}

///Contains flags for the IMFQualityAdvise2::NotifyQualityEvent method.
alias MF_QUALITY_ADVISE_FLAGS = int;
enum : int
{
    ///The decoder has done everything that it can to reduce sample latency, and samples are still late.
    MF_QUALITY_CANNOT_KEEP_UP = 0x00000001,
}

///Contains flags for adding a topology to the sequencer source, or updating a topology already in the queue.
enum MFSequencerTopologyFlags : int
{
    ///This topology is the last topology in the sequence.
    SequencerTopologyFlags_Last = 0x00000001,
}

///Specifies how the credential manager should obtain user credentials.
enum MFNetCredentialRequirements : int
{
    ///The credential manager should prompt the user to provide the credentials.
    REQUIRE_PROMPT        = 0x00000001,
    ///<div class="alert"><b>Note</b> Requires Windows 7 or later.</div> <div> </div> The credentials are saved to
    ///persistent storage. This flag acts as a hint for the application's UI. If the application prompts the user for
    ///credentials, the UI can indicate that the credentials have already been saved.
    REQUIRE_SAVE_SELECTED = 0x00000002,
}

///Describes options for the caching network credentials.
enum MFNetCredentialOptions : int
{
    ///Allow the credential cache object to save credentials in persistant storage.
    MFNET_CREDENTIAL_SAVE             = 0x00000001,
    ///Do not allow the credential cache object to cache the credentials in memory. This flag cannot be combined with
    ///the MFNET_CREDENTIAL_SAVE flag.
    MFNET_CREDENTIAL_DONT_CACHE       = 0x00000002,
    ///The user allows credentials to be sent over the network in clear text. By default,
    ///IMFNetCredentialCache::GetCredential always returns the REQUIRE_PROMPT flag when the authentication flags include
    ///MFNET_AUTHENTICATION_CLEAR_TEXT, even if cached credentials are available. If you set the
    ///MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT option, the <b>GetCredential</b> method will not return REQUIRE_PROMPT for
    ///clear text, if cached credentials are available. Do not set this flag without notifying the user that credentials
    ///might be sent in clear text.
    MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT = 0x00000004,
}

///Specifies how the user's credentials will be used.
enum MFNetAuthenticationFlags : int
{
    ///The credentials will be used to authenticate with a proxy.
    MFNET_AUTHENTICATION_PROXY          = 0x00000001,
    ///The credentials will be sent over the network unencrypted.
    MFNET_AUTHENTICATION_CLEAR_TEXT     = 0x00000002,
    ///The credentials must be from a user who is currently logged on.
    MFNET_AUTHENTICATION_LOGGED_ON_USER = 0x00000004,
}

///Indicates the type of control protocol that is used in streaming or downloading.
alias MFNETSOURCE_PROTOCOL_TYPE = int;
enum : int
{
    ///The protocol type has not yet been determined.
    MFNETSOURCE_UNDEFINED = 0x00000000,
    ///The protocol type is HTTP. This includes HTTPv9, WMSP, and HTTP download.
    MFNETSOURCE_HTTP      = 0x00000001,
    ///The protocol type is Real Time Streaming Protocol (RTSP).
    MFNETSOURCE_RTSP      = 0x00000002,
    ///The content is read from a file. The file might be local or on a remote share.
    MFNETSOURCE_FILE      = 0x00000003,
    ///The protocol type is multicast. <div class="alert"><b>Note</b> Requires Windows 7 or later.</div> <div> </div>
    MFNETSOURCE_MULTICAST = 0x00000004,
}

///Describes the type of transport used in streaming or downloading data (TCP or UDP).
alias MFNETSOURCE_TRANSPORT_TYPE = int;
enum : int
{
    ///The data transport type is UDP.
    MFNETSOURCE_UDP = 0x00000000,
    ///The data transport type is TCP.
    MFNETSOURCE_TCP = 0x00000001,
}

///Defines the status of the cache for a media file or entry.
alias MFNETSOURCE_CACHE_STATE = int;
enum : int
{
    ///The cache for a file or entry does not exist.
    MFNETSOURCE_CACHE_UNAVAILABLE     = 0x00000000,
    ///The cache for a file or entry is growing.
    MFNETSOURCE_CACHE_ACTIVE_WRITING  = 0x00000001,
    ///The cache for a file or entry is completed.
    MFNETSOURCE_CACHE_ACTIVE_COMPLETE = 0x00000002,
}

///Defines statistics collected by the network source. The values in this enumeration define property identifiers (PIDs)
///for the MFNETSOURCE_STATISTICS property. To retrieve statistics from the network source, call
///IMFGetService::GetService with the service identifier <b>MFNETSOURCE_STATISTICS_SERVICE</b> and the interface
///identifier IID_IPropertyStore. The retrieved pointer is an <b>IPropertyStore</b> pointer. To get the value of a
///network statistic, construct a <b>PROPERTYKEY</b> with <b>fmtid</b> equal to <b>MFNETSOURCE_STATISTICS</b> and
///<b>pid</b> equal to a value from this enumeration. Then call <b>IPropertyStore::GetValue</b> with the property key to
///retrieve the value of the statistic as a PROPVARIANT. In the descriptions that follow, the data type and value-type
///tag for the PROPVARIANT are listed in parentheses.
alias MFNETSOURCE_STATISTICS_IDS = int;
enum : int
{
    ///The number of packets received (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_RECVPACKETS_ID              = 0x00000000,
    ///The number of packets lost (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_LOSTPACKETS_ID              = 0x00000001,
    ///The number of requests to resend packets (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_RESENDSREQUESTED_ID         = 0x00000002,
    ///The number of resent packets received (<b>LONG</b>) (<b>VT_I4</b>).
    MFNETSOURCE_RESENDSRECEIVED_ID          = 0x00000003,
    ///The total number of packets recovered by error correction (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_RECOVEREDBYECCPACKETS_ID    = 0x00000004,
    ///The total number of packets recovered by retransmission (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_RECOVEREDBYRTXPACKETS_ID    = 0x00000005,
    ///The total number of packets returned to user, including recovered packets (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_OUTPACKETS_ID               = 0x00000006,
    ///The 10-second average receiving rate (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_RECVRATE_ID                 = 0x00000007,
    ///The average bandwidth of the clip (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_AVGBANDWIDTHBPS_ID          = 0x00000008,
    ///The total number of bytes received (<b>ULONGLONG</b>, <b>VT_UI8</b>).
    MFNETSOURCE_BYTESRECEIVED_ID            = 0x00000009,
    ///The type of control protocol used to receive the data (<b>LONG</b>, <b>VT_I4</b>). The value is a member of the
    ///MFNETSOURCE_PROTOCOL_TYPE enumeration.
    MFNETSOURCE_PROTOCOL_ID                 = 0x0000000a,
    ///The type of control protocol used to receive the data (<b>LONG</b>, <b>VT_I4</b>). The value is a member of the
    ///MFNETSOURCE_TRANSPORT_TYPE enumeration.
    MFNETSOURCE_TRANSPORT_ID                = 0x0000000b,
    ///The status of cache for a media file or entry (<b>LONG</b>, <b>VT_I4</b>). The value is a member of the
    ///MFNETSOURCE_CACHE_STATE enumeration.
    MFNETSOURCE_CACHE_STATE_ID              = 0x0000000c,
    ///The current link bandwidth, in bits per second (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_LINKBANDWIDTH_ID            = 0x0000000d,
    ///The current bit rate of the content (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_CONTENTBITRATE_ID           = 0x0000000e,
    ///The negotiated speed factor used in data transmission (<b>LONG</b>, <b>VT_I4</b>). The sender transmits data at
    ///the rate of the speed factor multiplied by the bit rate of the content.
    MFNETSOURCE_SPEEDFACTOR_ID              = 0x0000000f,
    ///The playout buffer size, in milliseconds (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_BUFFERSIZE_ID               = 0x00000010,
    ///The percentage of the playout buffer filled during buffering. The value is an integer in the range 0â€“100.
    ///(<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_BUFFERPROGRESS_ID           = 0x00000011,
    ///The number of ticks since the last bandwidth switch (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_LASTBWSWITCHTS_ID           = 0x00000012,
    ///The start of the seekable range, in 100-nanosecond units (<b>ULONGLONG</b>, <b>VT_UI8</b>).
    MFNETSOURCE_SEEKRANGESTART_ID           = 0x00000013,
    ///The end of the seekable range, in 100-nanosecond units (<b>ULONGLONG</b>, <b>VT_UI8</b>).
    MFNETSOURCE_SEEKRANGEEND_ID             = 0x00000014,
    ///The number of times buffering has occurred, including the initial buffering (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_BUFFERINGCOUNT_ID           = 0x00000015,
    ///The number of packets that had incorrect signatures (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_INCORRECTLYSIGNEDPACKETS_ID = 0x00000016,
    ///Boolean value indicating whether the current session is signed (<b>VARIANT_BOOL</b>, <b>VT_BOOL</b>).
    MFNETSOURCE_SIGNEDSESSION_ID            = 0x00000017,
    ///The current maximum bit rate of the content (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_MAXBITRATE_ID               = 0x00000018,
    ///The reception quality (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_RECEPTION_QUALITY_ID        = 0x00000019,
    ///The total number of recovered packets (<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_RECOVEREDPACKETS_ID         = 0x0000001a,
    ///Boolean value indicating whether the content has a variable bit rate (<b>VARIANT_BOOL</b>, <b>VT_BOOL</b>).
    MFNETSOURCE_VBR_ID                      = 0x0000001b,
    ///The percentage of the content that has been downloaded. The value is an integer in the range 0â€“100.
    ///(<b>LONG</b>, <b>VT_I4</b>).
    MFNETSOURCE_DOWNLOADPROGRESS_ID         = 0x0000001c,
    MFNETSOURCE_UNPREDEFINEDPROTOCOLNAME_ID = 0x0000001d,
}

///Specifies how the default proxy locator will specify the connection settings to a proxy server. The application must
///set these values in the MFNETSOURCE_PROXYSETTINGS property.
alias MFNET_PROXYSETTINGS = int;
enum : int
{
    ///The proxy locator bypasses all addresses.
    MFNET_PROXYSETTING_NONE    = 0x00000000,
    ///The proxy locator uses manual settings. The application must set the following properties: <ul> <li>
    ///MFNETSOURCE_PROXYHOSTNAME </li> <li> MFNETSOURCE_PROXYPORT </li> <li> MFNETSOURCE_PROXYBYPASSFORLOCAL </li> <li>
    ///MFNETSOURCE_PROXYEXCEPTIONLIST </li> </ul>
    MFNET_PROXYSETTING_MANUAL  = 0x00000001,
    ///The proxy locator automatically discovers proxy servers by using the WinInet auto-proxy detection mechanism.
    MFNET_PROXYSETTING_AUTO    = 0x00000002,
    ///The proxy locator uses the proxy settings of the browser. By default, the proxy locator sets this value for HTTP.
    MFNET_PROXYSETTING_BROWSER = 0x00000003,
}

///Defines actions that can be performed on a stream.
alias MFPOLICYMANAGER_ACTION = int;
enum : int
{
    ///No action.
    PEACTION_NO        = 0x00000000,
    ///Play the stream.
    PEACTION_PLAY      = 0x00000001,
    ///Copy the stream.
    PEACTION_COPY      = 0x00000002,
    ///Export the stream to another format.
    PEACTION_EXPORT    = 0x00000003,
    ///Extract the data from the stream and pass it to the application. For example, acoustic echo cancellation requires
    ///this action.
    PEACTION_EXTRACT   = 0x00000004,
    ///Reserved.
    PEACTION_RESERVED1 = 0x00000005,
    ///Reserved.
    PEACTION_RESERVED2 = 0x00000006,
    ///Reserved.
    PEACTION_RESERVED3 = 0x00000007,
    ///Last member of the enumeration.
    PEACTION_LAST      = 0x00000007,
}

///Defines protection levels for <b>MFPROTECTION_CGMSA</b>.
alias MF_OPM_CGMSA_PROTECTION_LEVEL = int;
enum : int
{
    ///CGMS-A is disabled.
    MF_OPM_CGMSA_OFF                             = 0x00000000,
    ///The protection level is Copy Freely.
    MF_OPM_CGMSA_COPY_FREELY                     = 0x00000001,
    ///The protection level is Copy No More.
    MF_OPM_CGMSA_COPY_NO_MORE                    = 0x00000002,
    ///The protection level is Copy One Generation.
    MF_OPM_CGMSA_COPY_ONE_GENERATION             = 0x00000003,
    ///The protection level is Copy Never.
    MF_OPM_CGMSA_COPY_NEVER                      = 0x00000004,
    ///Redistribution control (also called the broadcast flag) is required. This flag can be combined with the other
    ///flags.
    MF_OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED = 0x00000008,
}

///Defines protection levels for <b>MFPROTECTION_ACP</b>.
alias MF_OPM_ACP_PROTECTION_LEVEL = int;
enum : int
{
    ///Specifies ACP is disabled.
    MF_OPM_ACP_OFF         = 0x00000000,
    ///Specifies ACP is level one.
    MF_OPM_ACP_LEVEL_ONE   = 0x00000001,
    ///Specifies ACP is level two.
    MF_OPM_ACP_LEVEL_TWO   = 0x00000002,
    ///Specifies ACP is level three.
    MF_OPM_ACP_LEVEL_THREE = 0x00000003,
    ///Reserved.
    MF_OPM_ACP_FORCE_ULONG = 0x7fffffff,
}

///Specifies values for audio constriction.
enum MFAudioConstriction : int
{
    ///Audio is not constricted.
    MFaudioConstrictionOff   = 0x00000000,
    ///Audio is down sampled to 48 kHz/16-bit.
    MFaudioConstriction48_16 = 0x00000001,
    ///Audio is down sampled to 44 kHz/16-bit.
    MFaudioConstriction44_16 = 0x00000002,
    ///Audio is down sampled to 14hKz/16-bit.
    MFaudioConstriction14_14 = 0x00000003,
    ///Audio is muted.
    MFaudioConstrictionMute  = 0x00000004,
}

///Defines the version number for sample protection.
alias SAMPLE_PROTECTION_VERSION = int;
enum : int
{
    ///No sample protection.
    SAMPLE_PROTECTION_VERSION_NO         = 0x00000000,
    ///Version 1.
    SAMPLE_PROTECTION_VERSION_BASIC_LOKI = 0x00000001,
    ///Version 2.
    SAMPLE_PROTECTION_VERSION_SCATTER    = 0x00000002,
    ///Version 3.
    SAMPLE_PROTECTION_VERSION_RC4        = 0x00000003,
    SAMPLE_PROTECTION_VERSION_AES128CTR  = 0x00000004,
}

///Defines flags for the MF_TRANSCODE_TOPOLOGYMODE attribute.
alias MF_TRANSCODE_TOPOLOGYMODE_FLAGS = int;
enum : int
{
    ///The topology loader will exclude hardware-based transforms (such as codecs and color converters) from the
    ///topology. It will use only software transforms.
    MF_TRANSCODE_TOPOLOGYMODE_SOFTWARE_ONLY    = 0x00000000,
    ///The topology loader may insert hardware-based transforms into the transcode topology.
    MF_TRANSCODE_TOPOLOGYMODE_HARDWARE_ALLOWED = 0x00000001,
}

///Defines the profile flags that are set in the MF_TRANSCODE_ADJUST_PROFILE attribute. These flags are checked by
///MFCreateTranscodeTopology during topology building. Based on these flags, <b>MFCreateTranscodeTopology</b> adjusts
///the transcode profile by modifying the configuration settings for the streams according to the input requirements of
///the encoder used in the topology. For more information about the stream settings that an application can specify, see
///Using the Transcode API.
alias MF_TRANSCODE_ADJUST_PROFILE_FLAGS = int;
enum : int
{
    ///Media Foundation uses the application-specified settings for audio and video streams. If the required settings
    ///are not provided by the application, the topology is created but the encoding session fails. For the video
    ///stream, the frame rate and the interlace mode settings are modified. For more information, see Remarks.
    MF_TRANSCODE_ADJUST_PROFILE_DEFAULT               = 0x00000000,
    ///For both audio and video streams, the missing stream settings are filled by copying the input source attributes.
    ///This flag ensures the transcoded output file is the closest match to the input file.
    MF_TRANSCODE_ADJUST_PROFILE_USE_SOURCE_ATTRIBUTES = 0x00000001,
}

///Defines algorithms for the video processor which is use by MF_VIDEO_PROCESSOR_ALGORITHM.
alias MF_VIDEO_PROCESSOR_ALGORITHM_TYPE = int;
enum : int
{
    ///default mode favors a balance of quality and speed
    MF_VIDEO_PROCESSOR_ALGORITHM_DEFAULT     = 0x00000000,
    ///The video processor will always internally process in AYUV and use high quality filters.
    MF_VIDEO_PROCESSOR_ALGORITHM_MRF_CRF_444 = 0x00000001,
}

///Specifies the type of a Content Decryption Module (CDM) session, represented by an
///[IMFContentDecryptionModuleSession](../mfcontentdecryptionmodule/nn-mfcontentdecryptionmodule-imfcontentdecryptionmodulesession.md)
///object.
alias MF_MEDIAKEYSESSION_TYPE = int;
enum : int
{
    ///A session for which the license, key(s) and record of or data related to the session are not persisted.
    MF_MEDIAKEYSESSION_TYPE_TEMPORARY                  = 0x00000000,
    ///A session for which the license (and potentially other data related to the session) will be persisted.
    MF_MEDIAKEYSESSION_TYPE_PERSISTENT_LICENSE         = 0x00000001,
    ///A record of license destruction.
    MF_MEDIAKEYSESSION_TYPE_PERSISTENT_RELEASE_MESSAGE = 0x00000002,
    ///A record of license usage.
    MF_MEDIAKEYSESSION_TYPE_PERSISTENT_USAGE_RECORD    = 0x00000003,
}

///Specifies the status of a Content Decryption Module (CDM) session key.
alias MF_MEDIAKEY_STATUS = int;
enum : int
{
    ///The CDM is certain the key is currently usable for decryption.
    MF_MEDIAKEY_STATUS_USABLE             = 0x00000000,
    ///The key is no longer usable for decryption because its expiration time has passed.
    MF_MEDIAKEY_STATUS_EXPIRED            = 0x00000001,
    ///There are output restrictions associated with the key that cannot currently be met. Media data decrypted with
    ///this key may be presented at a lower quality (e.g., resolution), if necessary according to the output
    ///restrictions.
    MF_MEDIAKEY_STATUS_OUTPUT_DOWNSCALED  = 0x00000002,
    ///There are output restrictions associated with the key that disallow output.
    MF_MEDIAKEY_STATUS_OUTPUT_NOT_ALLOWED = 0x00000003,
    ///The status of the key is not yet known and is being determined. The status will be updated with the actual status
    ///when it has been determined.
    MF_MEDIAKEY_STATUS_STATUS_PENDING     = 0x00000004,
    ///The key is not currently usable for decryption because of an error in the CDM unrelated to the other values. This
    ///value is not actionable by the application.
    MF_MEDIAKEY_STATUS_INTERNAL_ERROR     = 0x00000005,
    ///The key itself is no longer available to the CDM, but information about the key, such as a record of license
    ///destruction, is available.
    MF_MEDIAKEY_STATUS_RELEASED           = 0x00000006,
    ///There are output restrictions associated with the key that cannot currently be met. Media data decrypted with
    ///this key may be blocked from presentation, if necessary according to the output restrictions. The application
    ///should avoid using streams that will trigger the output restrictions associated with the key.
    MF_MEDIAKEY_STATUS_OUTPUT_RESTRICTED  = 0x00000007,
}

///Specifies the type of a Content Decryption Module (CDM) message.
alias MF_MEDIAKEYSESSION_MESSAGETYPE = int;
enum : int
{
    ///The message contains a request for a new license.
    MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_REQUEST           = 0x00000000,
    ///The message contains a request to renew an existing license.
    MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RENEWAL           = 0x00000001,
    ///The message contains a record of license destruction.
    MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RELEASE           = 0x00000002,
    ///The message contains a request for App-Assisted Individualization (or re-individualization).
    MF_MEDIAKEYSESSION_MESSAGETYPE_INDIVIDUALIZATION_REQUEST = 0x00000003,
}

///<p class="CCE_Message">[Some information relates to pre-released product which may be substantially modified before
///it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information
///provided here.] Maps to the W3C cross origin settings (CORS) attribute used by the HTML5 media element
alias MF_CROSS_ORIGIN_POLICY = int;
enum : int
{
    ///No CORS state.
    MF_CROSS_ORIGIN_POLICY_NONE            = 0x00000000,
    ///Requests for the element will have their mode set to "cors" and their credentials mode set to "same-origin".
    MF_CROSS_ORIGIN_POLICY_ANONYMOUS       = 0x00000001,
    MF_CROSS_ORIGIN_POLICY_USE_CREDENTIALS = 0x00000002,
}

///Specifies the type of a sensor device. A value from this enumeration is returned by IMFSensorDevice::GetDeviceType.
enum MFSensorDeviceType : int
{
    ///The sensor device type is unknown.
    MFSensorDeviceType_Unknown         = 0x00000000,
    ///The sensor device is a physical device. Physical cameras may register as KSCATEGORY_SENSOR_CAMERA or
    ///KSCATEGORY_VIDEO_CAMERA or both.
    MFSensorDeviceType_Device          = 0x00000001,
    ///The sensor device is a custom media source.
    MFSensorDeviceType_MediaSource     = 0x00000002,
    ///The sensor device is a legacy frame provider.
    MFSensorDeviceType_FrameProvider   = 0x00000003,
    MFSensorDeviceType_SensorTransform = 0x00000004,
}

///Specifies whether a stream associated with an IMFSensorDevice is an input or an output stream.
enum MFSensorStreamType : int
{
    ///The sensor stream type is unknown.
    MFSensorStreamType_Unknown = 0x00000000,
    ///The sensor stream is an input stream.
    MFSensorStreamType_Input   = 0x00000001,
    MFSensorStreamType_Output  = 0x00000002,
}

///Specifies the sharing mode of an IMFSensorDevice.
enum MFSensorDeviceMode : int
{
    ///The device is in controller mode, which means its settings can be modified.
    MFSensorDeviceMode_Controller = 0x00000000,
    MFSensorDeviceMode_Shared     = 0x00000001,
}

alias MFCameraIntrinsic_DistortionModelType = int;
enum : int
{
    MFCameraIntrinsic_DistortionModelType_6KT    = 0x00000000,
    MFCameraIntrinsic_DistortionModelType_ArcTan = 0x00000001,
}

///Specifies the allocator usage of components that implement the
///[IMFSampleAllocatorControl](nn-mfidl-imfsampleallocatorcontrol.md) interface.
enum MFSampleAllocatorUsage : int
{
    ///The output stream will use the camera pipeline's sample allocator to allocate new media samples. If the output
    ///stream is producing samples in CPU memory, it is recommended that it use this mode to ensure consistent
    ///performance when used in a cross-container scenario.
    MFSampleAllocatorUsage_UsesProvidedAllocator = 0x00000000,
    ///The output stream will be use a custom allocator for its output samples. It will not use the sample allocator
    ///provided by the camera pipeline.
    MFSampleAllocatorUsage_UsesCustomAllocator   = 0x00000001,
    ///The output stream will not allocate new samples for its output samples. It will not be provided a sample
    ///allocator by the camera pipeline.
    MFSampleAllocatorUsage_DoesNotAllocate       = 0x00000002,
}

///Defines the ASF indexer options.
alias MFASF_INDEXER_FLAGS = int;
enum : int
{
    ///The indexer creates a new index object.
    MFASF_INDEXER_WRITE_NEW_INDEX          = 0x00000001,
    ///The indexer returns values for reverse playback.
    MFASF_INDEXER_READ_FOR_REVERSEPLAYBACK = 0x00000002,
    ///The indexer creates an index object for a live ASF stream.
    MFASF_INDEXER_WRITE_FOR_LIVEREAD       = 0x00000004,
}

///Defines the ASF splitter options.
alias MFASF_SPLITTERFLAGS = int;
enum : int
{
    ///The splitter delivers samples for the ASF content in reverse order to accommodate reverse playback.
    MFASF_SPLITTER_REVERSE = 0x00000001,
    ///The splitter delivers samples for streams that are protected with Windows Media Digital Rights Management.
    MFASF_SPLITTER_WMDRM   = 0x00000002,
}

///Defines status conditions for the IMFASFSplitter::GetNextSample method.
alias ASF_STATUSFLAGS = int;
enum : int
{
    ///The operation is incomplete.
    ASF_STATUSFLAGS_INCOMPLETE     = 0x00000001,
    ///One or more non-critical errors occurred while parsing the ASF data.
    ASF_STATUSFLAGS_NONFATAL_ERROR = 0x00000002,
}

///Defines the ASF multiplexer options.
alias MFASF_MULTIPLEXERFLAGS = int;
enum : int
{
    ///The multiplexer automatically adjusts the bit rate of the ASF content in response to the characteristics of the
    ///streams being multiplexed.
    MFASF_MULTIPLEXER_AUTOADJUST_BITRATE = 0x00000001,
}

///Defines the ASF stream selector options.
alias MFASF_STREAMSELECTOR_FLAGS = int;
enum : int
{
    ///The stream selector will not set thinning. Thinning is the process of removing samples from a stream to reduce
    ///the bit rate.
    MFASF_STREAMSELECTOR_DISABLE_THINNING    = 0x00000001,
    ///The stream selector will use the average bit rate of streams when selecting streams.
    MFASF_STREAMSELECTOR_USE_AVERAGE_BITRATE = 0x00000002,
}

///Defines the selection options for an ASF stream.
alias ASF_SELECTION_STATUS = int;
enum : int
{
    ///No samples from the stream are delivered.
    ASF_STATUS_NOTSELECTED     = 0x00000000,
    ///Only samples from the stream that are clean points are delivered.
    ASF_STATUS_CLEANPOINTSONLY = 0x00000001,
    ///All samples from the stream are delivered.
    ASF_STATUS_ALLDATAUNITS    = 0x00000002,
}

///Specifies how the ASF file sink should apply Windows Media DRM.
alias MFSINK_WMDRMACTION = int;
enum : int
{
    ///Undefined action.
    MFSINK_WMDRMACTION_UNDEFINED  = 0x00000000,
    ///Encode the content using Windows Media DRM. Use this flag if the source content does not have DRM protection.
    MFSINK_WMDRMACTION_ENCODE     = 0x00000001,
    ///Transcode the content using Windows Media DRM. Use this flag if the source content has Windows Media DRM
    ///protection and you want to change the encoding parameters but not the DRM protection.
    MFSINK_WMDRMACTION_TRANSCODE  = 0x00000002,
    ///Transcrypt the content. Use this flag if the source content has DRM protection and you want to change the DRM
    ///protection; for example, if you want to convert from Windows Media DRM version 1 to Windows Media DRM version 7
    ///or later.
    MFSINK_WMDRMACTION_TRANSCRYPT = 0x00000003,
    ///Reserved. Do not use.
    MFSINK_WMDRMACTION_LAST       = 0x00000003,
}

///Specifies a type of capture device.
alias MF_CAPTURE_ENGINE_DEVICE_TYPE = int;
enum : int
{
    ///An audio capture device, such as a microphone.
    MF_CAPTURE_ENGINE_DEVICE_TYPE_AUDIO = 0x00000000,
    ///A video capture device, such as a webcam.
    MF_CAPTURE_ENGINE_DEVICE_TYPE_VIDEO = 0x00000001,
}

///Specifies a type of capture sink.
alias MF_CAPTURE_ENGINE_SINK_TYPE = int;
enum : int
{
    ///A recording sink, for capturing audio and video to a file.
    MF_CAPTURE_ENGINE_SINK_TYPE_RECORD  = 0x00000000,
    ///A preview sink, for previewing live audio or video.
    MF_CAPTURE_ENGINE_SINK_TYPE_PREVIEW = 0x00000001,
    ///A photo sink, for capturing still images.
    MF_CAPTURE_ENGINE_SINK_TYPE_PHOTO   = 0x00000002,
}

alias __MIDL___MIDL_itf_mfcaptureengine_0000_0000_0001 = int;
enum : int
{
    MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW = 0xfffffffa,
    MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_RECORD  = 0xfffffff9,
    MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_PHOTO         = 0xfffffff8,
    MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_AUDIO         = 0xfffffff7,
    MF_CAPTURE_ENGINE_MEDIASOURCE                               = 0xffffffff,
}

///Defines the values for the source stream category.
alias MF_CAPTURE_ENGINE_STREAM_CATEGORY = int;
enum : int
{
    ///Specifies a video preview stream.
    MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_PREVIEW     = 0x00000000,
    ///Specifies a video capture stream.
    MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_CAPTURE     = 0x00000001,
    ///Specifies an independent photo stream.
    MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_INDEPENDENT = 0x00000002,
    ///Specifies a dependent photo stream.
    MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_DEPENDENT   = 0x00000003,
    ///Specifies an audio stream.
    MF_CAPTURE_ENGINE_STREAM_CATEGORY_AUDIO             = 0x00000004,
    ///Specifies an unsupported stream.
    MF_CAPTURE_ENGINE_STREAM_CATEGORY_UNSUPPORTED       = 0x00000005,
}

alias MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE = int;
enum : int
{
    MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_OTHER          = 0x00000000,
    MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_COMMUNICATIONS = 0x00000001,
    MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_MEDIA          = 0x00000002,
    MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_GAMECHAT       = 0x00000003,
    MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_SPEECH         = 0x00000004,
}

alias MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE = int;
enum : int
{
    MF_CAPTURE_ENGINE_AUDIO_PROCESSING_DEFAULT = 0x00000000,
    MF_CAPTURE_ENGINE_AUDIO_PROCESSING_RAW     = 0x00000001,
}

///Specifies the type of work queue for the MFAllocateWorkQueueEx function to create.
alias MFASYNC_WORKQUEUE_TYPE = int;
enum : int
{
    ///Create a work queue without a message loop.
    MF_STANDARD_WORKQUEUE      = 0x00000000,
    ///Create a work queue with a message loop.
    MF_WINDOW_WORKQUEUE        = 0x00000001,
    ///Create a multithreaded work queue. This type of work queue uses a thread pool to dispatch work items. The caller
    ///is responsible for serializing the work items.
    MF_MULTITHREADED_WORKQUEUE = 0x00000002,
}

///Specifies the status of a topology during playback.
alias MF_TOPOSTATUS = int;
enum : int
{
    ///This value is not used.
    MF_TOPOSTATUS_INVALID         = 0x00000000,
    ///The topology is ready to start. After this status flag is received, you can use the Media Session's
    ///IMFGetService::GetService method to query the topology for services, such as rate control.
    MF_TOPOSTATUS_READY           = 0x00000064,
    ///The Media Session has started to read data from the media sources in the topology.
    MF_TOPOSTATUS_STARTED_SOURCE  = 0x000000c8,
    ///The Media Session modified the topology, because the format of a stream changed.
    MF_TOPOSTATUS_DYNAMIC_CHANGED = 0x000000d2,
    ///The media sinks have switched from the previous topology to this topology. This status value is not sent for the
    ///first topology that is played. For the first topology, the MESessionStarted event indicates that the media sinks
    ///have started receiving data.
    MF_TOPOSTATUS_SINK_SWITCHED   = 0x0000012c,
    ///Playback of this topology is complete. The Media Session might still use the topology internally. The Media
    ///Session does not completely release the topology until it sends the next <b>MF_TOPOSTATUS_STARTED_SOURCE</b>
    ///status event or the MESessionEnded event.
    MF_TOPOSTATUS_ENDED           = 0x00000190,
}

///Specifies the supported protection schemes for encrypted samples.
enum MFSampleEncryptionProtectionScheme : int
{
    ///No encryption scheme.
    MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_NONE    = 0x00000000,
    ///The encryption scheme is AES counter mode (CTR).
    MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CTR = 0x00000001,
    ///The encryption scheme is Cipher Block Chaining (CBC).
    MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CBC = 0x00000002,
}

///Contains flags for registering and enumeration Media Foundation transforms (MFTs). These flags are used in the
///following functions: <ul> <li> MFTEnumEx: These flags control which Media Foundation transforms (MFTs) are
///enumerated, as well as the enumeration order.</li> <li> MFTRegister: A subset of these flags are used when
///registering an MFT.</li> </ul>
alias _MFT_ENUM_FLAG = int;
enum : int
{
    ///The MFT performs synchronous data processing in software. This flag does not apply to hardware transforms.
    MFT_ENUM_FLAG_SYNCMFT                         = 0x00000001,
    ///The MFT performs asynchronous data processing in software. See Asynchronous MFTs. This flag does not apply to
    ///hardware transforms.
    MFT_ENUM_FLAG_ASYNCMFT                        = 0x00000002,
    ///The MFT performs hardware-based data processing, using either the AVStream driver or a GPU-based proxy MFT. MFTs
    ///in this category always process data asynchronously. See Hardware MFTs. <div class="alert"><b>Note</b> This flag
    ///applies to video codecs and video processors that perform their work entirely in hardware. It does not apply to
    ///software decoders that use DirectX Video Acceleration to assist decoding.</div> <div> </div>
    MFT_ENUM_FLAG_HARDWARE                        = 0x00000004,
    ///The MFT that must be unlocked by the application before use. Unlocking is performed using the
    ///IMFFieldOfUseMFTUnlock interface. For more information, see Field of Use Restrictions. This flag does not apply
    ///to hardware transforms.
    MFT_ENUM_FLAG_FIELDOFUSE                      = 0x00000008,
    ///For enumeration, include MFTs that were registered in the caller's process. To register an MFT in the caller's
    ///process, call the either the MFTRegisterLocal or MFTRegisterLocalByCLSID function. This flag does not apply to
    ///hardware transforms. Do not set this flag in the MFTRegister function.
    MFT_ENUM_FLAG_LOCALMFT                        = 0x00000010,
    ///The MFT is optimized for transcoding rather than playback.
    MFT_ENUM_FLAG_TRANSCODE_ONLY                  = 0x00000020,
    ///For enumeration, sort and filter the results. For more information, see the Remarks section of MFTEnumEx. Do not
    ///set this flag in the MFTRegister function.
    MFT_ENUM_FLAG_SORTANDFILTER                   = 0x00000040,
    MFT_ENUM_FLAG_SORTANDFILTER_APPROVED_ONLY     = 0x000000c0,
    MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY          = 0x00000140,
    MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY_EDGEMODE = 0x00000240,
    MFT_ENUM_FLAG_UNTRUSTED_STOREMFT              = 0x00000400,
    ///Bitwise <b>OR</b> of all the flags, excluding <b>MFT_ENUM_FLAG_SORTANDFILTER</b>. Do not set this flag in the
    ///MFTRegister function.
    MFT_ENUM_FLAG_ALL                             = 0x0000003f,
}

///Describes the type of data provided by a frame source.
enum MFFrameSourceTypes : int
{
    ///The frame source provides color data.
    MFFrameSourceTypes_Color    = 0x00000001,
    ///The frame source provides infrared data.
    MFFrameSourceTypes_Infrared = 0x00000002,
    ///The frame source provides depth data.
    MFFrameSourceTypes_Depth    = 0x00000004,
    ///The frame source provides image data. <b>Note</b> This value was added in Windows 10, version 1803.
    MFFrameSourceTypes_Image    = 0x00000008,
    ///The frame source provides custom data.
    MFFrameSourceTypes_Custom   = 0x00000080,
}

///Specifies how 3D video frames are stored in memory.
enum MFVideo3DFormat : int
{
    ///The base view is stored in a single buffer. The other view is discarded.
    MFVideo3DSampleFormat_BaseView         = 0x00000000,
    ///Each media sample contains multiple buffers, one for each view.
    MFVideo3DSampleFormat_MultiView        = 0x00000001,
    ///Each media sample contains one buffer, with both views packed side-by-side into a single frame.
    MFVideo3DSampleFormat_Packed_LeftRight = 0x00000002,
    ///Each media sample contains one buffer, with both views packed top-and-bottom into a single frame.
    MFVideo3DSampleFormat_Packed_TopBottom = 0x00000003,
}

///Specifies how a 3D video frame is stored in a media sample.
enum MFVideo3DSampleFormat : int
{
    ///Each view is stored in a separate buffer. The sample contains one buffer per view.
    MFSampleExtension_3DVideo_MultiView = 0x00000001,
    ///All of the views are stored in the same buffer. The sample contains a single buffer.
    MFSampleExtension_3DVideo_Packed    = 0x00000000,
}

///Describes the rotation of the video image in the counter-clockwise direction.
enum MFVideoRotationFormat : int
{
    ///The image is not rotated.
    MFVideoRotationFormat_0   = 0x00000000,
    ///The image is rotated 90 degrees counter-clockwise.
    MFVideoRotationFormat_90  = 0x0000005a,
    ///The image is rotated 180 degrees.
    MFVideoRotationFormat_180 = 0x000000b4,
    ///The image is rotated 270 degrees counter-clockwise.
    MFVideoRotationFormat_270 = 0x0000010e,
}

///Specifies the measurement system for a depth value in a video frame.
enum MFDepthMeasurement : int
{
    ///The measurement is the distance to the focal plane.
    DistanceToFocalPlane    = 0x00000000,
    ///The measurement is the distance to the optical center.
    DistanceToOpticalCenter = 0x00000001,
}

alias MF_CUSTOM_DECODE_UNIT_TYPE = int;
enum : int
{
    MF_DECODE_UNIT_NAL = 0x00000000,
    MF_DECODE_UNIT_SEI = 0x00000001,
}

///Specifies the type of copy protection required for a video stream.
enum MFVideoDRMFlags : int
{
    ///No copy protection is required.
    MFVideoDRMFlag_None               = 0x00000000,
    ///Analog copy protection should be applied.
    MFVideoDRMFlag_AnalogProtected    = 0x00000001,
    ///Digital copy protection should be applied.
    MFVideoDRMFlag_DigitallyProtected = 0x00000002,
}

///Specifies whether to pad a video image so that it fits within a specified aspect ratio.
enum MFVideoPadFlags : int
{
    ///Do not pad the image.
    MFVideoPadFlag_PAD_TO_None = 0x00000000,
    ///Pad the image so that it can be displayed in a 4Ã—3 area.
    MFVideoPadFlag_PAD_TO_4x3  = 0x00000001,
    ///Pad the image so that it can be displayed in a 16Ã—9 area.
    MFVideoPadFlag_PAD_TO_16x9 = 0x00000002,
}

///Describes the intended aspect ratio for a video stream.
enum MFVideoSrcContentHintFlags : int
{
    ///The aspect ratio is unknown.
    MFVideoSrcContentHintFlag_None  = 0x00000000,
    ///The source is 16Ã—9 content encoded within a 4Ã—3 area.
    MFVideoSrcContentHintFlag_16x9  = 0x00000001,
    ///The source is 2.35:1 content encoded within a 16Ã—9 or 4Ã—3 area.
    MFVideoSrcContentHintFlag_235_1 = 0x00000002,
}

///Contains flags that specify how to convert an audio media type.
enum MFWaveFormatExConvertFlags : int
{
    ///Convert the media type to a <b>WAVEFORMATEX</b> structure if possible, or a <b>WAVEFORMATEXTENSIBLE</b> structure
    ///otherwise.
    MFWaveFormatExConvertFlag_Normal          = 0x00000000,
    ///Convert the media type to a <b>WAVEFORMATEXTENSIBLE</b> structure.
    MFWaveFormatExConvertFlag_ForceExtensible = 0x00000001,
}

enum EAllocationType : int
{
    eAllocationTypeDynamic  = 0x00000000,
    eAllocationTypeRT       = 0x00000001,
    eAllocationTypePageable = 0x00000002,
    eAllocationTypeIgnore   = 0x00000003,
}

///Defines error status codes for the Media Engine.
alias MF_MEDIA_ENGINE_ERR = int;
enum : int
{
    ///No error.
    MF_MEDIA_ENGINE_ERR_NOERROR           = 0x00000000,
    ///The process of fetching the media resource was stopped at the user's request.
    MF_MEDIA_ENGINE_ERR_ABORTED           = 0x00000001,
    ///A network error occurred while fetching the media resource.
    MF_MEDIA_ENGINE_ERR_NETWORK           = 0x00000002,
    ///An error occurred while decoding the media resource.
    MF_MEDIA_ENGINE_ERR_DECODE            = 0x00000003,
    ///The media resource is not supported.
    MF_MEDIA_ENGINE_ERR_SRC_NOT_SUPPORTED = 0x00000004,
    ///An error occurred while encrypting the media resource. Supported in Windows 8.1 and later.
    MF_MEDIA_ENGINE_ERR_ENCRYPTED         = 0x00000005,
}

///Defines event codes for the Media Engine.
alias MF_MEDIA_ENGINE_EVENT = int;
enum : int
{
    ///The Media Engine has started to load the source. See IMFMediaEngine::Load.
    MF_MEDIA_ENGINE_EVENT_LOADSTART              = 0x00000001,
    ///The Media Engine is loading the source.
    MF_MEDIA_ENGINE_EVENT_PROGRESS               = 0x00000002,
    ///The Media Engine has suspended a load operation.
    MF_MEDIA_ENGINE_EVENT_SUSPEND                = 0x00000003,
    ///The Media Engine cancelled a load operation that was in progress.
    MF_MEDIA_ENGINE_EVENT_ABORT                  = 0x00000004,
    ///An error occurred. <table> <tr> <th>Event Parameter</th> <th>Description</th> </tr> <tr> <td><i>param1</i></td>
    ///<td>A member of the MF_MEDIA_ENGINE_ERR enumeration.</td> </tr> <tr> <td><i>param2</i></td> <td>An <b>HRESULT</b>
    ///error code, or zero.</td> </tr> </table>
    MF_MEDIA_ENGINE_EVENT_ERROR                  = 0x00000005,
    ///The Media Engine has switched to the <b>MF_MEDIA_ENGINE_NETWORK_EMPTY</b> state. This can occur when the
    ///IMFMediaEngine::Load method is called, or if an error occurs during the <b>Load</b> method. See
    ///IMFMediaEngine::GetNetworkState.
    MF_MEDIA_ENGINE_EVENT_EMPTIED                = 0x00000006,
    ///The Load algorithm is stalled, waiting for data.
    MF_MEDIA_ENGINE_EVENT_STALLED                = 0x00000007,
    ///The Media Engine is switching to the playing state. See IMFMediaEngine::Play.
    MF_MEDIA_ENGINE_EVENT_PLAY                   = 0x00000008,
    ///The media engine has paused. See IMFMediaEngine::Pause.
    MF_MEDIA_ENGINE_EVENT_PAUSE                  = 0x00000009,
    ///The Media Engine has loaded enough source data to determine the duration and dimensions of the source.
    MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA         = 0x0000000a,
    ///The Media Engine has loaded enough data to render some content (for example, a video frame).
    MF_MEDIA_ENGINE_EVENT_LOADEDDATA             = 0x0000000b,
    ///Playback has stopped because the next frame is not available.
    MF_MEDIA_ENGINE_EVENT_WAITING                = 0x0000000c,
    ///Playback has started. See IMFMediaEngine::Play.
    MF_MEDIA_ENGINE_EVENT_PLAYING                = 0x0000000d,
    ///Playback can start, but the Media Engine might need to stop to buffer more data.
    MF_MEDIA_ENGINE_EVENT_CANPLAY                = 0x0000000e,
    ///The Media Engine can probably play through to the end of the resource, without stopping to buffer data.
    MF_MEDIA_ENGINE_EVENT_CANPLAYTHROUGH         = 0x0000000f,
    ///The Media Engine has started seeking to a new playback position. See IMFMediaEngine::SetCurrentTime.
    MF_MEDIA_ENGINE_EVENT_SEEKING                = 0x00000010,
    ///The Media Engine has seeked to a new playback position. See IMFMediaEngine::SetCurrentTime.
    MF_MEDIA_ENGINE_EVENT_SEEKED                 = 0x00000011,
    ///The playback position has changed. See IMFMediaEngine::GetCurrentTime.
    MF_MEDIA_ENGINE_EVENT_TIMEUPDATE             = 0x00000012,
    ///Playback has reached the end of the source. This event is not sent if the GetLoopis <b>TRUE</b>.
    MF_MEDIA_ENGINE_EVENT_ENDED                  = 0x00000013,
    ///The playback rate has changed. See IMFMediaEngine::SetPlaybackRate.
    MF_MEDIA_ENGINE_EVENT_RATECHANGE             = 0x00000014,
    ///The duration of the media source has changed. See IMFMediaEngine::GetDuration.
    MF_MEDIA_ENGINE_EVENT_DURATIONCHANGE         = 0x00000015,
    ///The audio volume changed. See IMFMediaEngine::SetVolume.
    MF_MEDIA_ENGINE_EVENT_VOLUMECHANGE           = 0x00000016,
    ///The output format of the media source has changed. <table> <tr> <th>Event Parameter</th> <th>Description</th>
    ///</tr> <tr> <td><i>param1</i></td> <td>Zero if the video format changed, 1 if the audio format changed.</td> </tr>
    ///<tr> <td><i>param2</i></td> <td>Zero.</td> </tr> </table>
    MF_MEDIA_ENGINE_EVENT_FORMATCHANGE           = 0x000003e8,
    ///The Media Engine flushed any pending events from its queue.
    MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS      = 0x000003e9,
    ///The playback position reached a timeline marker. See IMFMediaEngineEx::SetTimelineMarkerTimer.
    MF_MEDIA_ENGINE_EVENT_TIMELINE_MARKER        = 0x000003ea,
    ///The audio balance changed. See IMFMediaEngineEx::SetBalance.
    MF_MEDIA_ENGINE_EVENT_BALANCECHANGE          = 0x000003eb,
    ///The Media Engine has finished downloading the source data.
    MF_MEDIA_ENGINE_EVENT_DOWNLOADCOMPLETE       = 0x000003ec,
    ///The media source has started to buffer data.
    MF_MEDIA_ENGINE_EVENT_BUFFERINGSTARTED       = 0x000003ed,
    ///The media source has stopped buffering data.
    MF_MEDIA_ENGINE_EVENT_BUFFERINGENDED         = 0x000003ee,
    ///The IMFMediaEngineEx::FrameStep method completed.
    MF_MEDIA_ENGINE_EVENT_FRAMESTEPCOMPLETED     = 0x000003ef,
    ///The Media Engine's Load algorithm is waiting to start. <table> <tr> <th>Event Parameter</th> <th>Description</th>
    ///</tr> <tr> <td><i>param1</i></td> <td>A handle to a waitable event, of type <b>HANDLE</b>.</td> </tr> <tr>
    ///<td><i>param2</i></td> <td>Zero.</td> </tr> </table> If Media Engine is created with the
    ///<b>MF_MEDIA_ENGINE_WAITFORSTABLE_STATE</b> flag, the Media Engine sends the
    ///<b>MF_MEDIA_ENGINE_EVENT_NOTIFYSTABLESTATE</b> event at the start of the Load algorithm. The <i>param1</i>
    ///parameter is a handle to a waitable event. The <b>Load</b> thread waits for the application to signal the event
    ///by calling SetEvent. If the Media Engine is not created with the <b>MF_MEDIA_ENGINE_WAITFORSTABLE_STATE</b>, it
    ///does not send this event, and the Load thread does not wait to be signalled.
    MF_MEDIA_ENGINE_EVENT_NOTIFYSTABLESTATE      = 0x000003f0,
    ///The first frame of the media source is ready to render.
    MF_MEDIA_ENGINE_EVENT_FIRSTFRAMEREADY        = 0x000003f1,
    ///Raised when a new track is added or removed. Supported in Windows 8.1 and later.
    MF_MEDIA_ENGINE_EVENT_TRACKSCHANGE           = 0x000003f2,
    ///Raised when there is new information about the Output Protection Manager (OPM). This event will be raised when an
    ///OPM failure occurs, but ITA allows fallback without the OPM. In this case, constriction can be applied. This
    ///event will not be raised when there is an OPM failure and the fallback also fails. For example, if ITA blocks
    ///playback entirely when OPM cannot be established. Supported in Windows 8.1 and later.
    MF_MEDIA_ENGINE_EVENT_OPMINFO                = 0x000003f3,
    MF_MEDIA_ENGINE_EVENT_RESOURCELOST           = 0x000003f4,
    MF_MEDIA_ENGINE_EVENT_DELAYLOADEVENT_CHANGED = 0x000003f5,
    ///Raised when one of the component streams of a media stream fails. This event is only raised if the media stream
    ///contains other component streams that did not fail.
    MF_MEDIA_ENGINE_EVENT_STREAMRENDERINGERROR   = 0x000003f6,
    MF_MEDIA_ENGINE_EVENT_SUPPORTEDRATES_CHANGED = 0x000003f7,
    MF_MEDIA_ENGINE_EVENT_AUDIOENDPOINTCHANGE    = 0x000003f8,
}

///Defines network status codes for the Media Engine.
alias MF_MEDIA_ENGINE_NETWORK = int;
enum : int
{
    ///The initial state.
    MF_MEDIA_ENGINE_NETWORK_EMPTY     = 0x00000000,
    ///The Media Engine has started the resource selection algorithm, and has selected a media resource, but is not
    ///using the network.
    MF_MEDIA_ENGINE_NETWORK_IDLE      = 0x00000001,
    ///The Media Engine is loading a media resource.
    MF_MEDIA_ENGINE_NETWORK_LOADING   = 0x00000002,
    ///The Media Engine has started the resource selection algorithm, but has not selected a media resource.
    MF_MEDIA_ENGINE_NETWORK_NO_SOURCE = 0x00000003,
}

///Defines ready-state values for the Media Engine.
alias MF_MEDIA_ENGINE_READY = int;
enum : int
{
    ///No data is available.
    MF_MEDIA_ENGINE_READY_HAVE_NOTHING      = 0x00000000,
    ///Some metadata is available, including the duration and, for video files, the video dimensions. No media data is
    ///available.
    MF_MEDIA_ENGINE_READY_HAVE_METADATA     = 0x00000001,
    ///There is media data for the current playback position, but not enough data for playback or seeking.
    MF_MEDIA_ENGINE_READY_HAVE_CURRENT_DATA = 0x00000002,
    ///There is enough media data to enable some playback or seeking. The amount of data might be a little as the next
    ///video frame.
    MF_MEDIA_ENGINE_READY_HAVE_FUTURE_DATA  = 0x00000003,
    ///There is enough data to play the resource, based on the current rate at which the resource is being fetched.
    MF_MEDIA_ENGINE_READY_HAVE_ENOUGH_DATA  = 0x00000004,
}

///Specifies the likelihood that the Media Engine can play a specified type of media resource.
alias MF_MEDIA_ENGINE_CANPLAY = int;
enum : int
{
    ///The Media Engine cannot play the resource.
    MF_MEDIA_ENGINE_CANPLAY_NOT_SUPPORTED = 0x00000000,
    ///The Media Engine might be able to play the resource.
    MF_MEDIA_ENGINE_CANPLAY_MAYBE         = 0x00000001,
    ///The Media Engine can probably play the resource.
    MF_MEDIA_ENGINE_CANPLAY_PROBABLY      = 0x00000002,
}

///Defines preload hints for the Media Engine. These values correspond to the <b>preload</b> attribute of the
///<b>HTMLMediaElement</b> interface in HTML5.
alias MF_MEDIA_ENGINE_PRELOAD = int;
enum : int
{
    ///The <b>preload</b> attribute is missing.
    MF_MEDIA_ENGINE_PRELOAD_MISSING   = 0x00000000,
    ///The <b>preload</b> attribute is an empty string. This value is equivalent to
    ///<b>MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC</b>.
    MF_MEDIA_ENGINE_PRELOAD_EMPTY     = 0x00000001,
    ///The <b>preload</b> attribute is "none". This value is a hint to the user agent not to preload the resource.
    MF_MEDIA_ENGINE_PRELOAD_NONE      = 0x00000002,
    ///The <b>preload</b> attribute is "metadata". This value is a hint to the user agent to fetch the resource
    ///metadata.
    MF_MEDIA_ENGINE_PRELOAD_METADATA  = 0x00000003,
    ///The <b>preload</b> attribute is "auto". This value is a hint to the user agent to preload the entire resource.
    MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC = 0x00000004,
}

///Specifies the layout for a packed 3D video frame.
alias MF_MEDIA_ENGINE_S3D_PACKING_MODE = int;
enum : int
{
    ///None.
    MF_MEDIA_ENGINE_S3D_PACKING_MODE_NONE         = 0x00000000,
    ///The views are packed side-by-side in a single frame.
    MF_MEDIA_ENGINE_S3D_PACKING_MODE_SIDE_BY_SIDE = 0x00000001,
    ///The views are packed top-to-bottom in a single frame.
    MF_MEDIA_ENGINE_S3D_PACKING_MODE_TOP_BOTTOM   = 0x00000002,
}

///Identifies statistics that the Media Engine tracks during playback. To get a playback statistic from the Media
///Engine, call IMFMediaEngineEx::GetStatistics. In the descriptions that follow, the data type and value-type tag for
///the PROPVARIANT are listed in parentheses.
alias MF_MEDIA_ENGINE_STATISTIC = int;
enum : int
{
    ///The number of rendered video frames. (<b>ULONG</b>, <b>VT_UI4</b>)
    MF_MEDIA_ENGINE_STATISTIC_FRAMES_RENDERED   = 0x00000000,
    ///The number of dropped video frames. (<b>ULONG</b>, <b>VT_UI4</b>)
    MF_MEDIA_ENGINE_STATISTIC_FRAMES_DROPPED    = 0x00000001,
    ///The number of bytes that have been downloaded since the last HTTP range request. (<b>ULARGE_INTEGER</b>,
    ///<b>VT_UI8</b>).
    MF_MEDIA_ENGINE_STATISTIC_BYTES_DOWNLOADED  = 0x00000002,
    ///The percentage of the playout buffer filled during buffering. The value is an integer in the range 0â€“100.
    ///(<b>LONG</b>, <b>VT_I4</b>)
    MF_MEDIA_ENGINE_STATISTIC_BUFFER_PROGRESS   = 0x00000003,
    ///The frames per second. (<b>FLOAT</b>, <b>VT_R4</b>)
    MF_MEDIA_ENGINE_STATISTIC_FRAMES_PER_SECOND = 0x00000004,
    ///The amount of playback jitter. (<b>DOUBLE</b>, <b>VT_R8</b>) Supported in Windows 8.1 and later.
    MF_MEDIA_ENGINE_STATISTIC_PLAYBACK_JITTER   = 0x00000005,
    ///The number of corrupted frames. (<b>ULONG</b>, <b>VT_UI4</b>) Supported in Windows 8.1 and later.
    MF_MEDIA_ENGINE_STATISTIC_FRAMES_CORRUPTED  = 0x00000006,
    ///The total amount of frame delay. (<b>DOUBLE</b>, <b>VT_R8</b>) Supported in Windows 8.1 and later.
    MF_MEDIA_ENGINE_STATISTIC_TOTAL_FRAME_DELAY = 0x00000007,
}

///Defines values for the media engine seek mode.
alias MF_MEDIA_ENGINE_SEEK_MODE = int;
enum : int
{
    ///Specifies normal seek.
    MF_MEDIA_ENGINE_SEEK_MODE_NORMAL      = 0x00000000,
    ///Specifies an approximate seek.
    MF_MEDIA_ENGINE_SEEK_MODE_APPROXIMATE = 0x00000001,
}

///Specifies media engine extension types.
alias MF_MEDIA_ENGINE_EXTENSION_TYPE = int;
enum : int
{
    MF_MEDIA_ENGINE_EXTENSION_TYPE_MEDIASOURCE = 0x00000000,
    MF_MEDIA_ENGINE_EXTENSION_TYPE_BYTESTREAM  = 0x00000001,
}

///Specifies the content protection requirements for a video frame.
alias MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS = int;
enum : int
{
    ///The video frame should be protected.
    MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_PROTECTED                              = 0x00000001,
    ///Direct3D surface protection must be applied to any surface that contains the frame.
    MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_SURFACE_PROTECTION            = 0x00000002,
    ///Direct3D anti-screen-scrape protection must be applied to any surface that contains the frame.
    MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_ANTI_SCREEN_SCRAPE_PROTECTION = 0x00000004,
}

alias MF_MSE_VP9_SUPPORT_TYPE = int;
enum : int
{
    MF_MSE_VP9_SUPPORT_DEFAULT = 0x00000000,
    MF_MSE_VP9_SUPPORT_ON      = 0x00000001,
    MF_MSE_VP9_SUPPORT_OFF     = 0x00000002,
}

alias MF_MSE_OPUS_SUPPORT_TYPE = int;
enum : int
{
    MF_MSE_OPUS_SUPPORT_ON  = 0x00000000,
    MF_MSE_OPUS_SUPPORT_OFF = 0x00000001,
}

alias MF_MSE_APPEND_MODE = int;
enum : int
{
    MF_MSE_APPEND_MODE_SEGMENTS = 0x00000000,
    MF_MSE_APPEND_MODE_SEQUENCE = 0x00000001,
}

///Defines the different ready states of the Media Source Extension.
alias MF_MSE_READY = int;
enum : int
{
    ///The media source is closed.
    MF_MSE_READY_CLOSED = 0x00000001,
    ///The media source is open.
    MF_MSE_READY_OPEN   = 0x00000002,
    ///The media source is ended.
    MF_MSE_READY_ENDED  = 0x00000003,
}

///Defines the different error states of the Media Source Extension.
alias MF_MSE_ERROR = int;
enum : int
{
    ///Specifies no error.
    MF_MSE_ERROR_NOERROR       = 0x00000000,
    ///Specifies an error with the network.
    MF_MSE_ERROR_NETWORK       = 0x00000001,
    ///Specifies an error with decoding.
    MF_MSE_ERROR_DECODE        = 0x00000002,
    ///Specifies an unknown error.
    MF_MSE_ERROR_UNKNOWN_ERROR = 0x00000003,
}

///Defines media key error codes for the media engine.
alias MF_MEDIA_ENGINE_KEYERR = int;
enum : int
{
    ///Unknown error occurred.
    MF_MEDIAENGINE_KEYERR_UNKNOWN        = 0x00000001,
    ///An error with the client occurred.
    MF_MEDIAENGINE_KEYERR_CLIENT         = 0x00000002,
    ///An error with the service occurred.
    MF_MEDIAENGINE_KEYERR_SERVICE        = 0x00000003,
    ///An error with the output occurred.
    MF_MEDIAENGINE_KEYERR_OUTPUT         = 0x00000004,
    ///An error occurred related to a hardware change.
    MF_MEDIAENGINE_KEYERR_HARDWARECHANGE = 0x00000005,
    ///An error with the domain occurred.
    MF_MEDIAENGINE_KEYERR_DOMAIN         = 0x00000006,
}

alias MF_HDCP_STATUS = int;
enum : int
{
    MF_HDCP_STATUS_ON                       = 0x00000000,
    MF_HDCP_STATUS_OFF                      = 0x00000001,
    MF_HDCP_STATUS_ON_WITH_TYPE_ENFORCEMENT = 0x00000002,
}

///Defines the status of the Output Protection Manager (OPM).
alias MF_MEDIA_ENGINE_OPM_STATUS = int;
enum : int
{
    ///Default status. Used to return the correct status when the content is unprotected.
    MF_MEDIA_ENGINE_OPM_NOT_REQUESTED          = 0x00000000,
    ///OPM successfully established.
    MF_MEDIA_ENGINE_OPM_ESTABLISHED            = 0x00000001,
    ///OPM failed because running in a virtual machined (VM).
    MF_MEDIA_ENGINE_OPM_FAILED_VM              = 0x00000002,
    ///OPM failed because there is no graphics driver and the system is using Basic Display Adapter (BDA).
    MF_MEDIA_ENGINE_OPM_FAILED_BDA             = 0x00000003,
    ///OPM failed because the graphics driver is not PE signed, falling back to WARP.
    MF_MEDIA_ENGINE_OPM_FAILED_UNSIGNED_DRIVER = 0x00000004,
    ///OPM failed for other reasons.
    MF_MEDIA_ENGINE_OPM_FAILED                 = 0x00000005,
}

///Contains flags for the IMFMediaEngineClassFactory::CreateInstance method.
alias MF_MEDIA_ENGINE_CREATEFLAGS = int;
enum : int
{
    ///The Media Engine will play audio only. It will not play video.
    MF_MEDIA_ENGINE_AUDIOONLY             = 0x00000001,
    ///The Media Engine's resource loading algorithm waits for the application to signal the thread that loads the
    ///resource. For more information, see the remarks for <b>MF_MEDIA_ENGINE_EVENT_NOTIFYSTABLESTATE</b> in the
    ///MF_MEDIA_ENGINE_EVENT enumeration.
    MF_MEDIA_ENGINE_WAITFORSTABLE_STATE   = 0x00000002,
    ///Always mute the audio.
    MF_MEDIA_ENGINE_FORCEMUTE             = 0x00000004,
    ///Enable low-latency mode in the rendering pipeline. This can be changed at a later time by calling
    ///IMFMediaEngineEx::SetRealTimeMode.
    MF_MEDIA_ENGINE_REAL_TIME_MODE        = 0x00000008,
    ///Disable locally registered media plugins. If this flag is set, the Media Engine will not load decoders or other
    ///media plugins that the application registered for the local process.
    MF_MEDIA_ENGINE_DISABLE_LOCAL_PLUGINS = 0x00000010,
    ///Reserved.
    MF_MEDIA_ENGINE_CREATEFLAGS_MASK      = 0x0000001f,
}

///Contains flags that specify whether the Media Engine will play protected content, and whether the Media Engine will
///use the Protected Media Path (PMP).
alias MF_MEDIA_ENGINE_PROTECTION_FLAGS = int;
enum : int
{
    ///Enable playback of protected content. The Media Engine will not play DRM-protected content unless this flag is
    ///set. If you set this flag, also set the MF_MEDIA_ENGINE_CONTENT_PROTECTION_MANAGER attribute.
    MF_MEDIA_ENGINE_ENABLE_PROTECTED_CONTENT = 0x00000001,
    ///Use the Protected Media Path (PMP) for all playback, including clear (non-protected) content.
    MF_MEDIA_ENGINE_USE_PMP_FOR_ALL_CONTENT  = 0x00000002,
    ///Create the PMP inside an unprotected process. You can use this option to play clear content, but not to play
    ///protected content.
    MF_MEDIA_ENGINE_USE_UNPROTECTED_PMP      = 0x00000004,
}

///Specifies the kind of timed text track.
alias MF_TIMED_TEXT_TRACK_KIND = int;
enum : int
{
    ///The kind of timed text track is unknown.
    MF_TIMED_TEXT_TRACK_KIND_UNKNOWN   = 0x00000000,
    ///The kind of timed text track is subtitles.
    MF_TIMED_TEXT_TRACK_KIND_SUBTITLES = 0x00000001,
    ///The kind of timed text track is closed captions.
    MF_TIMED_TEXT_TRACK_KIND_CAPTIONS  = 0x00000002,
    ///The kind of timed text track is metadata.
    MF_TIMED_TEXT_TRACK_KIND_METADATA  = 0x00000003,
}

///Specifies the units in which the timed text is measured.
alias MF_TIMED_TEXT_UNIT_TYPE = int;
enum : int
{
    ///The timed text is measured in pixels.
    MF_TIMED_TEXT_UNIT_TYPE_PIXELS     = 0x00000000,
    ///The timed text is measured as a percentage.
    MF_TIMED_TEXT_UNIT_TYPE_PERCENTAGE = 0x00000001,
}

///Specifies the font style of the timed text.
alias MF_TIMED_TEXT_FONT_STYLE = int;
enum : int
{
    ///The font style is normal, sometimes referred to as roman.
    MF_TIMED_TEXT_FONT_STYLE_NORMAL  = 0x00000000,
    ///The font style is oblique.
    MF_TIMED_TEXT_FONT_STYLE_OBLIQUE = 0x00000001,
    ///The font style is italic.
    MF_TIMED_TEXT_FONT_STYLE_ITALIC  = 0x00000002,
}

///Specifies how text is aligned in its parent block element.
alias MF_TIMED_TEXT_ALIGNMENT = int;
enum : int
{
    ///Text is aligned at the start of its parent block element.
    MF_TIMED_TEXT_ALIGNMENT_START  = 0x00000000,
    ///Text is aligned at the end of its parent block element.
    MF_TIMED_TEXT_ALIGNMENT_END    = 0x00000001,
    ///Text is aligned in the center of its parent block element.
    MF_TIMED_TEXT_ALIGNMENT_CENTER = 0x00000002,
}

///Specifies how text is aligned with the display.
alias MF_TIMED_TEXT_DISPLAY_ALIGNMENT = int;
enum : int
{
    ///Text is aligned before an element.
    MF_TIMED_TEXT_DISPLAY_ALIGNMENT_BEFORE = 0x00000000,
    ///Text is aligned after an element.
    MF_TIMED_TEXT_DISPLAY_ALIGNMENT_AFTER  = 0x00000001,
    ///Text is aligned in the center between elements.
    MF_TIMED_TEXT_DISPLAY_ALIGNMENT_CENTER = 0x00000002,
}

///Specifies how text is decorated (underlined and so on).
alias MF_TIMED_TEXT_DECORATION = int;
enum : int
{
    ///Text isn't decorated.
    MF_TIMED_TEXT_DECORATION_NONE         = 0x00000000,
    ///Text is underlined.
    MF_TIMED_TEXT_DECORATION_UNDERLINE    = 0x00000001,
    ///Text has a line through it.
    MF_TIMED_TEXT_DECORATION_LINE_THROUGH = 0x00000002,
    ///Text has a line over it.
    MF_TIMED_TEXT_DECORATION_OVERLINE     = 0x00000004,
}

///Specifies the sequence in which text is written on its parent element.
alias MF_TIMED_TEXT_WRITING_MODE = int;
enum : int
{
    ///Text is written from left to right and top to bottom.
    MF_TIMED_TEXT_WRITING_MODE_LRTB = 0x00000000,
    ///Text is written from right to left and top to bottom.
    MF_TIMED_TEXT_WRITING_MODE_RLTB = 0x00000001,
    ///Text is written from top to bottom and right to left.
    MF_TIMED_TEXT_WRITING_MODE_TBRL = 0x00000002,
    ///Text is written from top to bottom and left to right.
    MF_TIMED_TEXT_WRITING_MODE_TBLR = 0x00000003,
    ///Text is written from left to right.
    MF_TIMED_TEXT_WRITING_MODE_LR   = 0x00000004,
    ///Text is written from right to left.
    MF_TIMED_TEXT_WRITING_MODE_RL   = 0x00000005,
    ///Text is written from top to bottom.
    MF_TIMED_TEXT_WRITING_MODE_TB   = 0x00000006,
}

///Specifies how text appears when the parent element is scrolled.
alias MF_TIMED_TEXT_SCROLL_MODE = int;
enum : int
{
    ///Text pops on when the parent element is scrolled.
    MF_TIMED_TEXT_SCROLL_MODE_POP_ON  = 0x00000000,
    ///Text rolls up when the parent element is scrolled.
    MF_TIMED_TEXT_SCROLL_MODE_ROLL_UP = 0x00000001,
}

///Specifies the kind error that occurred with a timed text track.
alias MF_TIMED_TEXT_ERROR_CODE = int;
enum : int
{
    ///No error occurred.
    MF_TIMED_TEXT_ERROR_CODE_NOERROR     = 0x00000000,
    ///A fatal error occurred.
    MF_TIMED_TEXT_ERROR_CODE_FATAL       = 0x00000001,
    ///An error occurred with the data format of the timed text track.
    MF_TIMED_TEXT_ERROR_CODE_DATA_FORMAT = 0x00000002,
    ///A network error occurred when trying to load the timed text track.
    MF_TIMED_TEXT_ERROR_CODE_NETWORK     = 0x00000003,
    ///An internal error occurred.
    MF_TIMED_TEXT_ERROR_CODE_INTERNAL    = 0x00000004,
}

///Specifies the type of a timed text cue event.
alias MF_TIMED_TEXT_CUE_EVENT = int;
enum : int
{
    ///The cue has become active.
    MF_TIMED_TEXT_CUE_EVENT_ACTIVE   = 0x00000000,
    ///The cue has become inactive.
    MF_TIMED_TEXT_CUE_EVENT_INACTIVE = 0x00000001,
    ///All cues have been deactivated.
    MF_TIMED_TEXT_CUE_EVENT_CLEAR    = 0x00000002,
}

alias MF_TIMED_TEXT_TRACK_READY_STATE = int;
enum : int
{
    MF_TIMED_TEXT_TRACK_READY_STATE_NONE    = 0x00000000,
    MF_TIMED_TEXT_TRACK_READY_STATE_LOADING = 0x00000001,
    MF_TIMED_TEXT_TRACK_READY_STATE_LOADED  = 0x00000002,
    MF_TIMED_TEXT_TRACK_READY_STATE_ERROR   = 0x00000003,
}

///Identifies the kind of media stream that failed.
alias MF_MEDIA_ENGINE_STREAMTYPE_FAILED = int;
enum : int
{
    ///The stream type is unknown.
    MF_MEDIA_ENGINE_STREAMTYPE_FAILED_UNKNOWN = 0x00000000,
    ///The stream is an audio stream.
    MF_MEDIA_ENGINE_STREAMTYPE_FAILED_AUDIO   = 0x00000001,
    ///The stream is a video stream.
    MF_MEDIA_ENGINE_STREAMTYPE_FAILED_VIDEO   = 0x00000002,
}

alias MF_MEDIAKEYS_REQUIREMENT = int;
enum : int
{
    MF_MEDIAKEYS_REQUIREMENT_REQUIRED    = 0x00000001,
    MF_MEDIAKEYS_REQUIREMENT_OPTIONAL    = 0x00000002,
    MF_MEDIAKEYS_REQUIREMENT_NOT_ALLOWED = 0x00000003,
}

///Contains flags that indicate the status of the IMFSourceReader::ReadSample method.
alias MF_SOURCE_READER_FLAG = int;
enum : int
{
    ///An error occurred. If you receive this flag, do not make any further calls to IMFSourceReader methods.
    MF_SOURCE_READERF_ERROR                   = 0x00000001,
    ///The source reader reached the end of the stream.
    MF_SOURCE_READERF_ENDOFSTREAM             = 0x00000002,
    ///One or more new streams were created. Respond to this flag by doing at least one of the following: <ul> <li>Set
    ///the output types on the new streams.</li> <li>Update the stream selection by selecting or deselecting
    ///streams.</li> </ul>
    MF_SOURCE_READERF_NEWSTREAM               = 0x00000004,
    ///The <i>native format</i> has changed for one or more streams. The native format is the format delivered by the
    ///media source before any decoders are inserted.
    MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED  = 0x00000010,
    ///The current media has type changed for one or more streams. To get the current media type, call the
    ///IMFSourceReader::GetCurrentMediaType method.
    MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED = 0x00000020,
    ///There is a gap in the stream. This flag corresponds to an MEStreamTick event from the media source.
    MF_SOURCE_READERF_STREAMTICK              = 0x00000100,
    ///All transforms inserted by the application have been removed for a particular stream. This could be due to a
    ///dynamic format change from a source or decoder that prevents custom transforms from being used because they
    ///cannot handle the new media type.
    MF_SOURCE_READERF_ALLEFFECTSREMOVED       = 0x00000200,
}

///Contains flags for the IMFSourceReader::ReadSample method.
alias MF_SOURCE_READER_CONTROL_FLAG = int;
enum : int
{
    ///Retrieve any pending samples, but do not request any more samples from the media source. To get all of the
    ///pending samples, call ReadSample with this flag until the method returns a <b>NULL</b> media sample pointer.
    MF_SOURCE_READER_CONTROLF_DRAIN = 0x00000001,
}

alias __MIDL___MIDL_itf_mfreadwrite_0000_0001_0001 = int;
enum : int
{
    MF_SOURCE_READER_INVALID_STREAM_INDEX = 0xffffffff,
    MF_SOURCE_READER_ALL_STREAMS          = 0xfffffffe,
    MF_SOURCE_READER_ANY_STREAM           = 0xfffffffe,
    MF_SOURCE_READER_FIRST_AUDIO_STREAM   = 0xfffffffd,
    MF_SOURCE_READER_FIRST_VIDEO_STREAM   = 0xfffffffc,
    MF_SOURCE_READER_MEDIASOURCE          = 0xffffffff,
}

alias __MIDL___MIDL_itf_mfreadwrite_0000_0001_0002 = int;
enum : int
{
    MF_SOURCE_READER_CURRENT_TYPE_INDEX = 0xffffffff,
}

alias __MIDL___MIDL_itf_mfreadwrite_0000_0005_0001 = int;
enum : int
{
    MF_SINK_WRITER_INVALID_STREAM_INDEX = 0xffffffff,
    MF_SINK_WRITER_ALL_STREAMS          = 0xfffffffe,
    MF_SINK_WRITER_MEDIASINK            = 0xffffffff,
}

///Specifies the aspect-ratio mode.
enum MFVideoAspectRatioMode : int
{
    ///Do not maintain the aspect ratio of the video. Stretch the video to fit the output rectangle.
    MFVideoARMode_None             = 0x00000000,
    ///Preserve the aspect ratio of the video by letterboxing or within the output rectangle.
    MFVideoARMode_PreservePicture  = 0x00000001,
    ///<div class="alert"><b>Note</b> Currently the EVR ignores this flag.</div> <div> </div> Correct the aspect ratio
    ///if the physical size of the display device does not match the display resolution. For example, if the native
    ///resolution of the monitor is 1600 by 1200 (4:3) but the display resolution is 1280 by 1024 (5:4), the monitor
    ///will display non-square pixels. If this flag is set, you must also set the <b>MFVideoARMode_PreservePicture</b>
    ///flag.
    MFVideoARMode_PreservePixel    = 0x00000002,
    ///Apply a non-linear horizontal stretch if the aspect ratio of the destination rectangle does not match the aspect
    ///ratio of the source rectangle. The non-linear stretch algorithm preserves the aspect ratio in the middle of the
    ///picture and stretches (or shrinks) the image progressively more toward the left and right. This mode is useful
    ///when viewing 4:3 content full-screen on a 16:9 display, instead of pillar-boxing. Non-linear vertical stretch is
    ///not supported, because the visual results are generally poor. This mode may cause performance degradation. If
    ///this flag is set, you must also set the <b>MFVideoARMode_PreservePixel</b> and
    ///<b>MFVideoARMode_PreservePicture</b> flags.
    MFVideoARMode_NonLinearStretch = 0x00000004,
    ///Bitmask to validate flag values. This value is not a valid flag.
    MFVideoARMode_Mask             = 0x00000007,
}

///Contains flags that define how the enhanced video renderer (EVR) displays the video.
enum MFVideoRenderPrefs : int
{
    ///If this flag is set, the EVR does not draw the border color. By default, the EVR draws a border on areas of the
    ///destination rectangle that have no video. See IMFVideoDisplayControl::SetBorderColor.
    MFVideoRenderPrefs_DoNotRenderBorder     = 0x00000001,
    ///If this flag is set, the EVR does not clip the video when the video window straddles two monitors. By default, if
    ///the video window straddles two monitors, the EVR clips the video to the monitor that contains the largest area of
    ///video.
    MFVideoRenderPrefs_DoNotClipToDevice     = 0x00000002,
    ///<div class="alert"><b>Note</b> Requires Windows 7 or later.</div> <div> </div> Allow the EVR to limit its output
    ///to match GPU bandwidth.
    MFVideoRenderPrefs_AllowOutputThrottling = 0x00000004,
    ///<div class="alert"><b>Note</b> Requires Windows 7 or later.</div> <div> </div> Force the EVR to limit its output
    ///to match GPU bandwidth.
    MFVideoRenderPrefs_ForceOutputThrottling = 0x00000008,
    ///<div class="alert"><b>Note</b> Requires Windows 7 or later.</div> <div> </div> Force the EVR to batch Direct3D
    ///<b>Present</b> calls. This optimization enables the system to enter to idle states more frequently, which can
    ///reduce power consumption.
    MFVideoRenderPrefs_ForceBatching         = 0x00000010,
    ///<div class="alert"><b>Note</b> Requires Windows 7 or later.</div> <div> </div> Allow the EVR to batch Direct3D
    ///<b>Present</b> calls.
    MFVideoRenderPrefs_AllowBatching         = 0x00000020,
    ///<div class="alert"><b>Note</b> Requires Windows 7 or later.</div> <div> </div> Force the EVR to mix the video
    ///inside a rectangle that is smaller than the output rectangle. The EVR will then scale the result to the correct
    ///output size. The effective resolution will be lower if this setting is applied.
    MFVideoRenderPrefs_ForceScaling          = 0x00000040,
    ///<div class="alert"><b>Note</b> Requires Windows 7 or later.</div> <div> </div> Allow the EVR to mix the video
    ///inside a rectangle that is smaller than the output rectangle.
    MFVideoRenderPrefs_AllowScaling          = 0x00000080,
    ///<div class="alert"><b>Note</b> Requires Windows 7 or later.</div> <div> </div> Prevent the EVR from repainting
    ///the video window after a stop command. By default, the EVR repaints the video window black after a stop command.
    MFVideoRenderPrefs_DoNotRepaintOnStop    = 0x00000100,
    ///Bitmask to validate flag values. This value is not a valid flag.
    MFVideoRenderPrefs_Mask                  = 0x000001ff,
}

///Defines messages for an enhanced video renderer (EVR) presenter. This enumeration is used with the
///IMFVideoPresenter::ProcessMessage method.
alias MFVP_MESSAGE_TYPE = int;
enum : int
{
    ///The presenter should discard any pending samples. The <i>ulParam</i> parameter is not used and should be zero.
    MFVP_MESSAGE_FLUSH               = 0x00000000,
    ///The mixer's output format has changed. The EVR will initiate format negotiation. The <i>ulParam</i> parameter is
    ///not used and should be zero.
    MFVP_MESSAGE_INVALIDATEMEDIATYPE = 0x00000001,
    ///One input stream on the mixer has received a new sample. The <i>ulParam</i> parameter is not used and should be
    ///zero.
    MFVP_MESSAGE_PROCESSINPUTNOTIFY  = 0x00000002,
    ///The EVR switched from stopped to paused. The presenter should allocate resources. The <i>ulParam</i> parameter is
    ///not used and should be zero.
    MFVP_MESSAGE_BEGINSTREAMING      = 0x00000003,
    ///The EVR switched from running or paused to stopped. The presenter should free resources. The <i>ulParam</i>
    ///parameter is not used and should be zero.
    MFVP_MESSAGE_ENDSTREAMING        = 0x00000004,
    ///All streams have ended. The <i>ulParam</i> parameter is not used and should be zero.
    MFVP_MESSAGE_ENDOFSTREAM         = 0x00000005,
    ///Requests a frame step. The lower <b>DWORD</b> of the <i>ulParam</i> parameter contains the number of frames to
    ///step. If the value is <i>N</i>, the presenter should skip <i>N</i>â€“1 frames and display the <i>N</i> th frame.
    ///When that frame has been displayed, the presenter should send an <b>EC_STEP_COMPLETE</b> event to the EVR. If the
    ///presenter is not paused when it receives this message, it should return MF_E_INVALIDREQUEST.
    MFVP_MESSAGE_STEP                = 0x00000006,
    ///Cancels a frame step. The <i>ulParam</i> parameter is not used and should be zero.
    MFVP_MESSAGE_CANCELSTEP          = 0x00000007,
}

///Contains flags that are used to configure how the enhanced video renderer (EVR) performs deinterlacing.
enum MFVideoMixPrefs : int
{
    ///Force the EVR to skip the second field (in temporal order) of every interlaced frame.
    MFVideoMixPrefs_ForceHalfInterlace       = 0x00000001,
    ///If the EVR is falling behind, allow it to skip the second field (in temporal order) of every interlaced frame.
    MFVideoMixPrefs_AllowDropToHalfInterlace = 0x00000002,
    ///If the EVR is falling behind, allow it to use bob deinterlacing, even if the driver supports a higher-quality
    ///deinterlacing mode.
    MFVideoMixPrefs_AllowDropToBob           = 0x00000004,
    ///Force the EVR to use bob deinterlacing, even if the driver supports a higher-quality mode.
    MFVideoMixPrefs_ForceBob                 = 0x00000008,
    MFVideoMixPrefs_EnableRotation           = 0x00000010,
    ///The bitmask of valid flag values. This constant is not itself a valid flag.
    MFVideoMixPrefs_Mask                     = 0x0000001f,
}

///Contains flags that are used to configure the Microsoft DirectShow enhanced video renderer (EVR) filter.
enum EVRFilterConfigPrefs : int
{
    ///Enables dynamic adjustments to video quality during playback.
    EVRFilterConfigPrefs_EnableQoS = 0x00000001,
    ///The bitmask of valid flag values. This constant is not itself a valid flag.
    EVRFilterConfigPrefs_Mask      = 0x00000001,
}

alias MF_SERVICE_LOOKUP_TYPE = int;
enum : int
{
    MF_SERVICE_LOOKUP_UPSTREAM          = 0x00000000,
    MF_SERVICE_LOOKUP_UPSTREAM_DIRECT   = 0x00000001,
    MF_SERVICE_LOOKUP_DOWNSTREAM        = 0x00000002,
    MF_SERVICE_LOOKUP_DOWNSTREAM_DIRECT = 0x00000003,
    MF_SERVICE_LOOKUP_ALL               = 0x00000004,
    MF_SERVICE_LOOKUP_GLOBAL            = 0x00000005,
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Specifies options for the MFPCreateMediaPlayer
///function.
alias MFP_CREATION_OPTIONS = int;
enum : int
{
    ///Use the default creation options.
    MFP_OPTION_NONE                           = 0x00000000,
    ///If set, the MFPlay player object invokes the application's IMFPMediaPlayerCallback callback on another thread,
    ///and not the thread that called the MFPCreateMediaPlayer function. Therefore, the callback must be thread safe. If
    ///this flag is not set, the player object invokes the callback on the same thread that calls MFPCreateMediaPlayer.
    ///This thread must have a message loop. Internally, the player object creates a hidden window to dispatch the
    ///callback, similar to the mechanism used for single-threaded apartments (STAs) in COM.
    MFP_OPTION_FREE_THREADED_CALLBACK         = 0x00000001,
    ///Do not register the playback topology with the Multimedia Class Scheduler Service (MMCSS). By default, the MFPlay
    ///object registers the playback topology with MMCSS, which typically results in a better playback experience. For
    ///more information, see IMFWorkQueueServices.
    MFP_OPTION_NO_MMCSS                       = 0x00000002,
    ///Disables optimizations that are otherwise performed when the application runs in a Remote Desktop Services (RDS,
    ///formerly Terminal Services) environment.
    MFP_OPTION_NO_REMOTE_DESKTOP_OPTIMIZATION = 0x00000004,
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Specifies the current playback state.
alias MFP_MEDIAPLAYER_STATE = int;
enum : int
{
    ///Initial state. No media items have been set on the player object.
    MFP_MEDIAPLAYER_STATE_EMPTY    = 0x00000000,
    ///Playback is stopped.
    MFP_MEDIAPLAYER_STATE_STOPPED  = 0x00000001,
    ///Playback is in progress.
    MFP_MEDIAPLAYER_STATE_PLAYING  = 0x00000002,
    ///Playback is paused.
    MFP_MEDIAPLAYER_STATE_PAUSED   = 0x00000003,
    ///The player object was shut down. This state is returned after the application calls IMFPMediaPlayer::Shutdown.
    MFP_MEDIAPLAYER_STATE_SHUTDOWN = 0x00000004,
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Contains flags that describe a media item.
alias _MFP_MEDIAITEM_CHARACTERISTICS = int;
enum : int
{
    ///The media item represents a live data source, such as video camera. If playback is stopped and then restarted,
    ///there will be a gap in the content.
    MFP_MEDIAITEM_IS_LIVE       = 0x00000001,
    ///The media item supports seeking. If this flag is absent, the IMFPMediaPlayer::SetPosition method will fail.
    MFP_MEDIAITEM_CAN_SEEK      = 0x00000002,
    ///The media item can pause. If this flag is absent, the IMFPMediaPlayer::Pause method will likely fail.
    MFP_MEDIAITEM_CAN_PAUSE     = 0x00000004,
    ///Seeking can take a long time. For example, the source might download content through HTTP.
    MFP_MEDIAITEM_HAS_SLOW_SEEK = 0x00000008,
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Contains flags for the
///MFP_ACQUIRE_USER_CREDENTIAL_EVENT structure. Some of these flags, marked [out], convey information back to the MFPlay
///player object. The application should set or clear these flags as appropriate, before returning from the
///IMFPMediaPlayerCallback::OnMediaPlayerEvent callback method.
alias _MFP_CREDENTIAL_FLAGS = int;
enum : int
{
    ///The player object does not have any stored credentials and requires them from the application. If the player
    ///object can provide cached or stored credentials to the server, it does not set this flag.
    MFP_CREDENTIAL_PROMPT         = 0x00000001,
    ///The credentials are saved to persistent storage. This flag acts as a hint for the application's UI. If the
    ///application prompts the user for credentials, the UI can indicate that the credentials have already been saved.
    ///[out] If the application sets this flag, the player object saves the user credentials in persistent storage.
    ///Otherwise, the player object does not save the credentials.
    MFP_CREDENTIAL_SAVE           = 0x00000002,
    ///[out] If the application sets this flag, the player object does not cache the user credentials in memory.
    ///Otherwise, the player object does not cache the credentials. If you set this flag, do not set the
    ///<b>MFP_CREDENTIAL_SAVE</b> flag.
    MFP_CREDENTIAL_DO_NOT_CACHE   = 0x00000004,
    ///The credentials will be sent in clear text. The application should warn the user that the credentials will be
    ///sent over the network without encryption. [out] On output, set this flag to allow the player object to send
    ///credentials in clear text, without prompting the user to re-enter the credentials.
    MFP_CREDENTIAL_CLEAR_TEXT     = 0x00000008,
    ///The credentials will be used to authenticate with a proxy.
    MFP_CREDENTIAL_PROXY          = 0x00000010,
    ///The authentication scheme supports authentication of the user who is currently logged on.
    MFP_CREDENTIAL_LOGGED_ON_USER = 0x00000020,
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Defines event types for the IMFPMediaPlayerCallback
///interface.
alias MFP_EVENT_TYPE = int;
enum : int
{
    ///Playback has started. This event is sent when the IMFPMediaPlayer::Play method completes.
    MFP_EVENT_TYPE_PLAY                    = 0x00000000,
    ///Playback has paused. This event is sent when the IMFPMediaPlayer::Pause method completes.
    MFP_EVENT_TYPE_PAUSE                   = 0x00000001,
    ///Playback has stopped. This event is sent when the IMFPMediaPlayer::Stop method completes.
    MFP_EVENT_TYPE_STOP                    = 0x00000002,
    ///The MFPlay player object has seeked to a new playback position. This event is sent when the
    ///IMFPMediaPlayer::SetPosition method completes.
    MFP_EVENT_TYPE_POSITION_SET            = 0x00000003,
    ///The playback rate has changed. This event is sent when the IMFPMediaPlayer::SetRate method completes.
    MFP_EVENT_TYPE_RATE_SET                = 0x00000004,
    ///A new media item was created. This event is sent when the IMFPMediaPlayer::CreateMediaItemFromURL or
    ///CreateMediaItemFromObject method completes.
    MFP_EVENT_TYPE_MEDIAITEM_CREATED       = 0x00000005,
    ///A media item is ready for playback. This event is sent when the IMFPMediaPlayer::SetMediaItem method completes.
    MFP_EVENT_TYPE_MEDIAITEM_SET           = 0x00000006,
    ///A frame-step operation has completed. This event is sent when the IMFPMediaPlayer::FrameStep method completes.
    MFP_EVENT_TYPE_FRAME_STEP              = 0x00000007,
    ///The current media item was cleared. This event is sent when the IMFPMediaPlayer::ClearMediaItem method completes.
    MFP_EVENT_TYPE_MEDIAITEM_CLEARED       = 0x00000008,
    ///A pipeline object sent an event. The player object forwards certain pipeline events to the application. For more
    ///information, see MFP_MF_EVENT.
    MFP_EVENT_TYPE_MF                      = 0x00000009,
    ///A playback error has occurred.
    MFP_EVENT_TYPE_ERROR                   = 0x0000000a,
    ///Playback has ended. The player object sends this event when playback reaches the end of the media file.
    MFP_EVENT_TYPE_PLAYBACK_ENDED          = 0x0000000b,
    ///The media source requires authentication before it can play the file.
    MFP_EVENT_TYPE_ACQUIRE_USER_CREDENTIAL = 0x0000000c,
}

///Defines events that are sent by the sharing engine.
alias MF_SHARING_ENGINE_EVENT = int;
enum : int
{
    ///Reserved for internal use.
    MF_SHARING_ENGINE_EVENT_DISCONNECT            = 0x000007d0,
    ///Reserved for internal use.
    MF_SHARING_ENGINE_EVENT_LOCALRENDERINGSTARTED = 0x000007d1,
    ///Reserved for internal use.
    MF_SHARING_ENGINE_EVENT_LOCALRENDERINGENDED   = 0x000007d2,
    ///The device has stopped.
    MF_SHARING_ENGINE_EVENT_STOPPED               = 0x000007d3,
    MF_SHARING_ENGINE_EVENT_ERROR                 = 0x000009c5,
}

alias MF_MEDIA_SHARING_ENGINE_EVENT = int;
enum : int
{
    MF_MEDIA_SHARING_ENGINE_EVENT_DISCONNECT = 0x000007d0,
}

///Contains flags for the IPlayToSourceClassFactory::CreateInstance method.
alias PLAYTO_SOURCE_CREATEFLAGS = int;
enum : int
{
    PLAYTO_SOURCE_NONE      = 0x00000000,
    ///Share images.
    PLAYTO_SOURCE_IMAGE     = 0x00000001,
    ///Share audio.
    PLAYTO_SOURCE_AUDIO     = 0x00000002,
    ///Share video.
    PLAYTO_SOURCE_VIDEO     = 0x00000004,
    ///Share DRM protected media. Supported in Windows 8.1 and later.
    PLAYTO_SOURCE_PROTECTED = 0x00000008,
}

///Defines flags for the MFVideoAlphaBitmapParams structure.
enum MFVideoAlphaBitmapFlags : int
{
    ///Alpha-blend the entire DirectDraw suface. If you are alpha-blending a DirectDraw surface, you can set this flag
    ///when you call IMFVideoMixerBitmap::SetAlphaBitmap. If this flag is set, the mixer ignores the <b>rcSrc</b> member
    ///of the MFVideoAlphaBitmapParams structure. If this flag is absent, the <b>rcSrc</b> member specifies the source
    ///rectangle. This flag cannot be used if you specify a GDI bitmap for alpha-blending. For a GDI bitmap, you must
    ///fill in the <b>rcSrc</b> member when you call SetAlphaBitmap. This flag does not apply to the
    ///IMFVideoMixerBitmap::UpdateAlphaBitmapParameters method.
    MFVideoAlphaBitmap_EntireDDS   = 0x00000001,
    ///If this flag is set, the <b>clrSrcKey</b> member of the MFVideoAlphaBitmapParams structure specifies a color key
    ///for alpha-blending. If this flag is absent, the <b>clrSrcKey</b> member is ignored. This flag is not valid if you
    ///are alpha-blending a Direct3D surface with per-pixel alpha (D3DFMT_A8R8G8B8). When the DirectDraw surface has
    ///per-pixel alpha, the pixel alpha values are used for the alpha-blending operation.
    MFVideoAlphaBitmap_SrcColorKey = 0x00000002,
    ///Update the source rectangle. This flag applies to the UpdateAlphaBitmapParameters method. If this flag is set,
    ///the <b>rcSrc</b> member of the MFVideoAlphaBitmapParams structure updates the source rectangle. If this flag is
    ///absent, the <b>rcSrc</b> member is ignored. By setting this flag, you can animate the image by selecting
    ///different portions of the bitmap. This flag does not apply to the SetAlphaBitmap method.
    MFVideoAlphaBitmap_SrcRect     = 0x00000004,
    ///If this flag is set, the <b>nrcDest</b> member of the MFVideoAlphaBitmapParams structure specifies a normalized
    ///rectangle for scaling the bitmap. If this flag is absent, the <b>nrcDest</b> member is ignored.
    MFVideoAlphaBitmap_DestRect    = 0x00000008,
    ///If this flag is set, the <b>dwFilterMode</b> member of the MFVideoAlphaBitmapParams structure specifies a
    ///Direct3D filtering mode. If this flag is absent, the <b>dwFilterMode</b> member is ignored.
    MFVideoAlphaBitmap_FilterMode  = 0x00000010,
    ///If this flag is set, the <b>fAlpha</b> member of the MFVideoAlphaBitmapParams structure specifies an alpha value
    ///to apply to the entire image. If this flag is absent, the <b>fAlpha</b> member is ignored.
    MFVideoAlphaBitmap_Alpha       = 0x00000020,
    ///Bitmask to validate flag values. This value is not a valid flag.
    MFVideoAlphaBitmap_BitMask     = 0x0000003f,
}

///Specifies a type of compressed buffer for decoding.
alias D3D11_VIDEO_DECODER_BUFFER_TYPE = int;
enum : int
{
    ///Picture decoding parameter buffer.
    D3D11_VIDEO_DECODER_BUFFER_PICTURE_PARAMETERS          = 0x00000000,
    ///Macroblock control command buffer.
    D3D11_VIDEO_DECODER_BUFFER_MACROBLOCK_CONTROL          = 0x00000001,
    ///Residual difference block data buffer.
    D3D11_VIDEO_DECODER_BUFFER_RESIDUAL_DIFFERENCE         = 0x00000002,
    ///Deblocking filter control command buffer.
    D3D11_VIDEO_DECODER_BUFFER_DEBLOCKING_CONTROL          = 0x00000003,
    ///Inverse quantization matrix buffer.
    D3D11_VIDEO_DECODER_BUFFER_INVERSE_QUANTIZATION_MATRIX = 0x00000004,
    ///Slice-control buffer.
    D3D11_VIDEO_DECODER_BUFFER_SLICE_CONTROL               = 0x00000005,
    ///Bitstream data buffer.
    D3D11_VIDEO_DECODER_BUFFER_BITSTREAM                   = 0x00000006,
    ///Motion vector buffer.
    D3D11_VIDEO_DECODER_BUFFER_MOTION_VECTOR               = 0x00000007,
    ///Film grain synthesis data buffer.
    D3D11_VIDEO_DECODER_BUFFER_FILM_GRAIN                  = 0x00000008,
}

///Specifies how a video format can be used for video processing.
alias D3D11_VIDEO_PROCESSOR_FORMAT_SUPPORT = int;
enum : int
{
    ///The format can be used as the input to the video processor.
    D3D11_VIDEO_PROCESSOR_FORMAT_SUPPORT_INPUT  = 0x00000001,
    ///The format can be used as the output from the video processor.
    D3D11_VIDEO_PROCESSOR_FORMAT_SUPPORT_OUTPUT = 0x00000002,
}

///Defines video processing capabilities for a Microsoft Direct3D 11 video processor.
alias D3D11_VIDEO_PROCESSOR_DEVICE_CAPS = int;
enum : int
{
    ///The video processor can blend video content in linear color space. Most video content is gamma corrected,
    ///resulting in nonlinear values. This capability flag means that the video processor converts colors to linear
    ///space before blending, which produces better results.
    D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_LINEAR_SPACE            = 0x00000001,
    ///The video processor supports the xvYCC color space for YCbCr data.
    D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_xvYCC                   = 0x00000002,
    ///The video processor can perform range conversion when the input and output are both RGB but use different color
    ///ranges (0-255 or 16-235, for 8-bit RGB).
    D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_RGB_RANGE_CONVERSION    = 0x00000004,
    ///The video processor can apply a matrix conversion to YCbCr values when the input and output are both YCbCr. For
    ///example, the driver can convert colors from BT.601 to BT.709.
    D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_YCbCr_MATRIX_CONVERSION = 0x00000008,
    ///The video processor supports YUV nominal range . Supported in Windows 8.1 and later.
    D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_NOMINAL_RANGE           = 0x00000010,
}

///Defines features that a Microsoft Direct3D 11 video processor can support.
alias D3D11_VIDEO_PROCESSOR_FEATURE_CAPS = int;
enum : int
{
    ///The video processor can set alpha values on the output pixels. For more information, see
    ///ID3D11VideoContext::VideoProcessorSetOutputAlphaFillMode.
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ALPHA_FILL         = 0x00000001,
    ///The video processor can downsample the video output. For more information, see
    ///ID3D11VideoContext::VideoProcessorSetOutputConstriction.
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_CONSTRICTION       = 0x00000002,
    ///The video processor can perform luma keying. For more information, see
    ///ID3D11VideoContext::VideoProcessorSetStreamLumaKey.
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_LUMA_KEY           = 0x00000004,
    ///The video processor can apply alpha values from color palette entries.
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ALPHA_PALETTE      = 0x00000008,
    ///The driver does not support full video processing capabilities. If this capability flag is set, the video
    ///processor has the following limitations: <ul> <li>A maximum of two streams are supported:<ul> <li>The first
    ///stream must be either NV12 or YUY2.</li> <li>The second stream must be AYUV, AI44, or IA44.</li> </ul> </li>
    ///<li>Image adjustment (proc amp) controls are applied to the entire video processing blit, rather than per
    ///stream.</li> <li>Support for per-stream planar alpha is not reliable. (Per-pixel alpha is supported,
    ///however.)</li> </ul>
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_LEGACY             = 0x00000010,
    ///The video processor can support 3D stereo video. For more information, see
    ///ID3D11VideoContext::VideoProcessorSetStreamStereoFormat. All drivers setting this caps must support the following
    ///stereo formats: D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_HORIZONTAL,
    ///<b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_VERTICAL</b>, and <b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_SEPARATE</b>.
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_STEREO             = 0x00000020,
    ///The driver can rotate the input data either 90, 180, or 270 degrees clockwise as part of the video processing
    ///operation.
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ROTATION           = 0x00000040,
    ///The driver supports the VideoProcessorSetStreamAlpha call.
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ALPHA_STREAM       = 0x00000080,
    ///The driver supports the VideoProcessorSetStreamPixelAspectRatio call.
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_PIXEL_ASPECT_RATIO = 0x00000100,
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_MIRROR             = 0x00000200,
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_SHADER_USAGE       = 0x00000400,
    D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_METADATA_HDR10     = 0x00000800,
}

///Defines image filter capabilities for a Microsoft Direct3D 11 video processor.
alias D3D11_VIDEO_PROCESSOR_FILTER_CAPS = int;
enum : int
{
    ///The video processor can adjust the brightness level.
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_BRIGHTNESS         = 0x00000001,
    ///The video processor can adjust the contrast level.
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_CONTRAST           = 0x00000002,
    ///The video processor can adjust hue.
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_HUE                = 0x00000004,
    ///The video processor can adjust the saturation level.
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_SATURATION         = 0x00000008,
    ///The video processor can perform noise reduction.
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_NOISE_REDUCTION    = 0x00000010,
    ///The video processor can perform edge enhancement.
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_EDGE_ENHANCEMENT   = 0x00000020,
    ///The video processor can perform anamorphic scaling. Anamorphic scaling can be used to stretch 4:3 content to a
    ///widescreen 16:9 aspect ratio.
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_ANAMORPHIC_SCALING = 0x00000040,
    ///For stereo 3D video, the video processor can adjust the offset between the left and right views, allowing the
    ///user to reduce potential eye strain.
    D3D11_VIDEO_PROCESSOR_FILTER_CAPS_STEREO_ADJUSTMENT  = 0x00000080,
}

///Defines capabilities related to input formats for a Microsoft Direct3D 11 video processor.
alias D3D11_VIDEO_PROCESSOR_FORMAT_CAPS = int;
enum : int
{
    ///The video processor can deinterlace an input stream that contains interlaced RGB video.
    D3D11_VIDEO_PROCESSOR_FORMAT_CAPS_RGB_INTERLACED     = 0x00000001,
    ///The video processor can perform color adjustment on RGB video.
    D3D11_VIDEO_PROCESSOR_FORMAT_CAPS_RGB_PROCAMP        = 0x00000002,
    ///The video processor can perform luma keying on RGB video.
    D3D11_VIDEO_PROCESSOR_FORMAT_CAPS_RGB_LUMA_KEY       = 0x00000004,
    ///The video processor can deinterlace input streams with palettized color formats.
    D3D11_VIDEO_PROCESSOR_FORMAT_CAPS_PALETTE_INTERLACED = 0x00000008,
}

///Specifies the automatic image processing capabilities of the video processor.
alias D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS = int;
enum : int
{
    ///Denoise.
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_DENOISE             = 0x00000001,
    ///Deringing.
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_DERINGING           = 0x00000002,
    ///Edge enhancement.
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_EDGE_ENHANCEMENT    = 0x00000004,
    ///Color correction.
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_COLOR_CORRECTION    = 0x00000008,
    ///Flesh-tone mapping.
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_FLESH_TONE_MAPPING  = 0x00000010,
    ///Image stabilization.
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_IMAGE_STABILIZATION = 0x00000020,
    ///Enhanced image resolution.
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_SUPER_RESOLUTION    = 0x00000040,
    ///Anamorphic scaling.
    D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_ANAMORPHIC_SCALING  = 0x00000080,
}

///Defines stereo 3D capabilities for a Microsoft Direct3D 11 video processor.
alias D3D11_VIDEO_PROCESSOR_STEREO_CAPS = int;
enum : int
{
    ///The video processor supports the <b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO_OFFSET</b> format.
    D3D11_VIDEO_PROCESSOR_STEREO_CAPS_MONO_OFFSET        = 0x00000001,
    ///The video processor supports the <b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_ROW_INTERLEAVED</b> format.
    D3D11_VIDEO_PROCESSOR_STEREO_CAPS_ROW_INTERLEAVED    = 0x00000002,
    ///The video processor supports the <b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_COLUMN_INTERLEAVED</b> format.
    D3D11_VIDEO_PROCESSOR_STEREO_CAPS_COLUMN_INTERLEAVED = 0x00000004,
    ///The video processor supports the <b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_CHECKERBOARD</b> format.
    D3D11_VIDEO_PROCESSOR_STEREO_CAPS_CHECKERBOARD       = 0x00000008,
    ///The video processor can flip one or both views. For more information, see D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE.
    D3D11_VIDEO_PROCESSOR_STEREO_CAPS_FLIP_MODE          = 0x00000010,
}

///Specifies video processing capabilities that relate to deinterlacing, inverse telecine (IVTC), and frame-rate
///conversion.
alias D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS = int;
enum : int
{
    ///The video processor can perform blend deinterlacing. In blend deinterlacing, the two fields from an interlaced
    ///frame are blended into a single progressive frame. A video processor uses blend deinterlacing when it
    ///deinterlaces at half rate, as when converting 60i to 30p. Blend deinterlacing does not require reference frames.
    D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_DEINTERLACE_BLEND               = 0x00000001,
    ///The video processor can perform bob deinterlacing. In bob deinterlacing, missing field lines are interpolated
    ///from the lines above and below. Bob deinterlacing does not require reference frames.
    D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_DEINTERLACE_BOB                 = 0x00000002,
    ///The video processor can perform adaptive deinterlacing. Adaptive deinterlacing uses spatial or temporal
    ///interpolation, and switches between the two on a field-by-field basis, depending on the amount of motion. If the
    ///video processor does not receive enough reference frames to perform adaptive deinterlacing, it falls back to bob
    ///deinterlacing.
    D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_DEINTERLACE_ADAPTIVE            = 0x00000004,
    ///The video processor can perform motion-compensated deinterlacing. Motion-compensated deinterlacing uses motion
    ///vectors to recreate missing lines. If the video processor does not receive enough reference frames to perform
    ///motion-compensated deinterlacing, it falls back to bob deinterlacing.
    D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_DEINTERLACE_MOTION_COMPENSATION = 0x00000008,
    ///The video processor can perform inverse telecine (IVTC). If the video processor supports this capability, the
    ///<b>ITelecineCaps</b> member of the D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS structure specifies which IVTC
    ///modes are supported.
    D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_INVERSE_TELECINE                = 0x00000010,
    ///The video processor can convert the frame rate by interpolating frames.
    D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_FRAME_RATE_CONVERSION           = 0x00000020,
}

///Specifies the inverse telecine (IVTC) capabilities of a video processor.
alias D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS = int;
enum : int
{
    ///The video processor can reverse 3:2 pulldown.
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_32           = 0x00000001,
    ///The video processor can reverse 2:2 pulldown.
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_22           = 0x00000002,
    ///The video processor can reverse 2:2:2:4 pulldown.
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_2224         = 0x00000004,
    ///The video processor can reverse 2:3:3:2 pulldown.
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_2332         = 0x00000008,
    ///The video processor can reverse 3:2:3:2:2 pulldown.
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_32322        = 0x00000010,
    ///The video processor can reverse 5:5 pulldown.
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_55           = 0x00000020,
    ///The video processor can reverse 6:4 pulldown.
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_64           = 0x00000040,
    ///The video processor can reverse 8:7 pulldown.
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_87           = 0x00000080,
    ///The video processor can reverse 2:2:2:2:2:2:2:2:2:2:2:3 pulldown.
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_222222222223 = 0x00000100,
    ///The video processor can reverse other telecine modes not listed here.
    D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_OTHER        = 0x80000000,
}

///Contains flags that describe content-protection capabilities.
alias D3D11_CONTENT_PROTECTION_CAPS = int;
enum : int
{
    ///The content protection is implemented in software by the driver.
    D3D11_CONTENT_PROTECTION_CAPS_SOFTWARE                                  = 0x00000001,
    ///The content protection is implemented in hardware by the GPU.
    D3D11_CONTENT_PROTECTION_CAPS_HARDWARE                                  = 0x00000002,
    ///Content protection is always applied to a protected surface, regardless of whether the application explicitly
    ///enables protection.
    D3D11_CONTENT_PROTECTION_CAPS_PROTECTION_ALWAYS_ON                      = 0x00000004,
    ///The driver can use partially encrypted buffers. If this capability is not present, the entire buffer must be
    ///either encrypted or clear.
    D3D11_CONTENT_PROTECTION_CAPS_PARTIAL_DECRYPTION                        = 0x00000008,
    ///The driver can encrypt data using a separate content key that is encrypted using the session key.
    D3D11_CONTENT_PROTECTION_CAPS_CONTENT_KEY                               = 0x00000010,
    ///The driver can refresh the session key without renegotiating the key.
    D3D11_CONTENT_PROTECTION_CAPS_FRESHEN_SESSION_KEY                       = 0x00000020,
    ///The driver can read back encrypted data from a protected surface. For more information, see
    ///ID3D11VideoContext::EncryptionBlt.
    D3D11_CONTENT_PROTECTION_CAPS_ENCRYPTED_READ_BACK                       = 0x00000040,
    ///The driver requires a separate key to read encrypted data from a protected surface.
    D3D11_CONTENT_PROTECTION_CAPS_ENCRYPTED_READ_BACK_KEY                   = 0x00000080,
    ///If the encryption type is <b>D3DCRYPTOTYPE_AES128_CTR</b>, the application must use a sequential count in the
    ///D3D11_AES_CTR_IV structure.
    D3D11_CONTENT_PROTECTION_CAPS_SEQUENTIAL_CTR_IV                         = 0x00000100,
    ///The driver supports encrypted slice data, but does not support any other encrypted data in the compressed buffer.
    ///The caller should not encrypt any data within the buffer other than the slice data. <div
    ///class="alert"><b>Note</b> The driver should only report this flag for the specific profiles that have this
    ///limitation.</div> <div> </div>
    D3D11_CONTENT_PROTECTION_CAPS_ENCRYPT_SLICEDATA_ONLY                    = 0x00000200,
    ///The driver can copy encrypted data from one resource to another, decrypting the data as part of the process.
    D3D11_CONTENT_PROTECTION_CAPS_DECRYPTION_BLT                            = 0x00000400,
    ///The hardware supports the protection of specific resources. This means that: <ul> <li>The contents of a protected
    ///allocation can never be read by the CPU.</li> <li>The hardware can ensure a protected resource cannot be copied
    ///to an unprotected resource.</li> </ul> <b>Note</b> This enumeration value is supported starting with Windows 10.
    D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_PROTECT_UNCOMPRESSED             = 0x00000800,
    ///Physical pages of a protected resource can be evicted and potentially paged to disk in low memory conditions
    ///without losing the contents of the resource when paged back in. <b>Note</b> This enumeration value is supported
    ///starting with Windows 10.
    D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_PROTECTED_MEMORY_PAGEABLE        = 0x00001000,
    ///The hardware supports an automatic teardown mechanism that could trigger hardware keys or protected content to
    ///become lost in some conditions. The application can register to be notified when these events occur. <b>Note</b>
    ///This enumeration value is supported starting with Windows 10.
    D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_TEARDOWN                         = 0x00002000,
    ///The secure environment is tightly coupled with the GPU and an ID3D11CryptoSession should be used for
    ///communication between the user mode DRM component and the secure execution environment. <b>Note</b> This
    ///enumeration value is supported starting with Windows 10.
    D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_DRM_COMMUNICATION                = 0x00004000,
    D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_DRM_COMMUNICATION_MULTI_THREADED = 0x00008000,
}

///Identifies a video processor filter.
alias D3D11_VIDEO_PROCESSOR_FILTER = int;
enum : int
{
    ///Brightness filter.
    D3D11_VIDEO_PROCESSOR_FILTER_BRIGHTNESS         = 0x00000000,
    ///Contrast filter.
    D3D11_VIDEO_PROCESSOR_FILTER_CONTRAST           = 0x00000001,
    ///Hue filter.
    D3D11_VIDEO_PROCESSOR_FILTER_HUE                = 0x00000002,
    ///Saturation filter.
    D3D11_VIDEO_PROCESSOR_FILTER_SATURATION         = 0x00000003,
    ///Noise reduction filter.
    D3D11_VIDEO_PROCESSOR_FILTER_NOISE_REDUCTION    = 0x00000004,
    ///Edge enhancement filter.
    D3D11_VIDEO_PROCESSOR_FILTER_EDGE_ENHANCEMENT   = 0x00000005,
    ///Anamorphic scaling filter.
    D3D11_VIDEO_PROCESSOR_FILTER_ANAMORPHIC_SCALING = 0x00000006,
    ///Stereo adjustment filter. When stereo 3D video is enabled, this filter adjusts the offset between the left and
    ///right views, allowing the user to reduce potential eye strain. The filter value indicates the amount by which the
    ///left and right views are adjusted. A positive value shifts the images away from each other: the left image toward
    ///the left, and the right image toward the right. A negative value shifts the images in the opposite directions,
    ///closer to each other.
    D3D11_VIDEO_PROCESSOR_FILTER_STEREO_ADJUSTMENT  = 0x00000007,
}

///Describes how a video stream is interlaced.
alias D3D11_VIDEO_FRAME_FORMAT = int;
enum : int
{
    ///Frames are progressive.
    D3D11_VIDEO_FRAME_FORMAT_PROGRESSIVE                   = 0x00000000,
    ///Frames are interlaced. The top field of each frame is displayed first.
    D3D11_VIDEO_FRAME_FORMAT_INTERLACED_TOP_FIELD_FIRST    = 0x00000001,
    ///Frame are interlaced. The bottom field of each frame is displayed first.
    D3D11_VIDEO_FRAME_FORMAT_INTERLACED_BOTTOM_FIELD_FIRST = 0x00000002,
}

///Specifies the intended use for a video processor.
alias D3D11_VIDEO_USAGE = int;
enum : int
{
    ///Normal video playback. The graphics driver should expose a set of capabilities that are appropriate for real-time
    ///video playback.
    D3D11_VIDEO_USAGE_PLAYBACK_NORMAL = 0x00000000,
    ///Optimal speed. The graphics driver should expose a minimal set of capabilities that are optimized for
    ///performance. Use this setting if you want better performance and can accept some reduction in video quality. For
    ///example, you might use this setting in power-saving mode or to play video thumbnails.
    D3D11_VIDEO_USAGE_OPTIMAL_SPEED   = 0x00000001,
    ///Optimal quality. The grahics driver should expose its maximum set of capabilities. Specify this setting to get
    ///the best video quality possible. It is appropriate for tasks such as video editing, when quality is more
    ///important than speed. It is not appropriate for real-time playback.
    D3D11_VIDEO_USAGE_OPTIMAL_QUALITY = 0x00000002,
}

///Specifies values for the luminance range of YUV data.
alias D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE = int;
enum : int
{
    ///Driver defaults are used, which should be Studio luminance range [16-235],
    D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE_UNDEFINED = 0x00000000,
    ///Studio luminance range [16-235]
    D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE_16_235    = 0x00000001,
    ///Full luminance range [0-255]
    D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE_0_255     = 0x00000002,
}

///Specifies the alpha fill mode for video processing.
alias D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE = int;
enum : int
{
    ///Alpha values inside the target rectangle are set to opaque.
    D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_OPAQUE        = 0x00000000,
    ///Alpha values inside the target rectangle are set to the alpha value specified in the background color. To set the
    ///background color, call the ID3D11VideoContext::VideoProcessorSetOutputBackgroundColor method.
    D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_BACKGROUND    = 0x00000001,
    ///Existing alpha values remain unchanged in the output surface.
    D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_DESTINATION   = 0x00000002,
    ///Alpha values are taken from an input stream, scaled, and copied to the corresponding destination rectangle for
    ///that stream. The input stream is specified in the <i>StreamIndex</i> parameter of the
    ///ID3D11VideoContext::VideoProcessorSetOutputAlphaFillMode method. If the input stream does not have alpha data,
    ///the video processor sets the alpha values in the target rectangle to opaque. If the input stream is disabled or
    ///the source rectangle is empty, the alpha values in the target rectangle are not modified.
    D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_SOURCE_STREAM = 0x00000003,
}

///Specifies the rate at which the video processor produces output frames from an input stream.
alias D3D11_VIDEO_PROCESSOR_OUTPUT_RATE = int;
enum : int
{
    ///The output is the normal frame rate.
    D3D11_VIDEO_PROCESSOR_OUTPUT_RATE_NORMAL = 0x00000000,
    ///The output is half the frame rate.
    D3D11_VIDEO_PROCESSOR_OUTPUT_RATE_HALF   = 0x00000001,
    ///The output is a custom frame rate.
    D3D11_VIDEO_PROCESSOR_OUTPUT_RATE_CUSTOM = 0x00000002,
}

///Specifies the layout in memory of a stereo 3D video frame.
alias D3D11_VIDEO_PROCESSOR_STEREO_FORMAT = int;
enum : int
{
    ///The sample does not contain stereo data. If the stereo format is not specified, this value is the default.
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO               = 0x00000000,
    ///Frame 0 and frame 1 are packed side-by-side, as shown in the following diagram. <img alt="Side-by-side packing"
    ///src="./images/dxgistereo3d02.png"/> All drivers that support stereo video must support this format.
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_HORIZONTAL         = 0x00000001,
    ///Frame 0 and frame 1 are packed top-to-bottom, as shown in the following diagram. <img alt="Top-to-bottom packing"
    ///src="./images/dxgistereo3d01.png"/> All drivers that support stereo video must support this format.
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_VERTICAL           = 0x00000002,
    ///Frame 0 and frame 1 are placed in separate resources or in separate texture array elements within the same
    ///resource. All drivers that support stereo video must support this format.
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_SEPARATE           = 0x00000003,
    ///The sample contains non-stereo data. However, the driver should create a left/right output of this sample using a
    ///specified offset. The offset is specified in the <i>MonoOffset</i> parameter of the
    ///ID3D11VideoContext::VideoProcessorSetStreamStereoFormat method. This format is primarily intended for subtitles
    ///and other subpicture data, where the entire sample is presented on the same plane. Support for this stereo format
    ///is optional.
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO_OFFSET        = 0x00000004,
    ///Frame 0 and frame 1 are packed into interleaved rows, as shown in the following diagram. <img alt="Interleaved
    ///rows" src="./images/dxgistereo3d03.png"/> Support for this stereo format is optional.
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_ROW_INTERLEAVED    = 0x00000005,
    ///Frame 0 and frame 1 are packed into interleaved columns, as shown in the following diagram. <img alt="Interleaved
    ///columns" src="./images/dxgistereo3d04.png"/> Support for this stereo format is optional.
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_COLUMN_INTERLEAVED = 0x00000006,
    ///Frame 0 and frame 1 are packed in a checkerboard format, as shown in the following diagram. <img
    ///alt="Checkerboard packing" src="./images/dxgistereo3d05.png"/> Support for this stereo format is optional.
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_CHECKERBOARD       = 0x00000007,
}

///For stereo 3D video, specifies whether the data in frame 0 or frame 1 is flipped, either horizontally or vertically.
alias D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE = int;
enum : int
{
    ///Neither frame is flipped.
    D3D11_VIDEO_PROCESSOR_STEREO_FLIP_NONE   = 0x00000000,
    ///The data in frame 0 is flipped.
    D3D11_VIDEO_PROCESSOR_STEREO_FLIP_FRAME0 = 0x00000001,
    ///The data in frame 1 is flipped.
    D3D11_VIDEO_PROCESSOR_STEREO_FLIP_FRAME1 = 0x00000002,
}

///Specifies the video rotation states.
alias D3D11_VIDEO_PROCESSOR_ROTATION = int;
enum : int
{
    ///The video is not rotated.
    D3D11_VIDEO_PROCESSOR_ROTATION_IDENTITY = 0x00000000,
    ///The video is rotated 90 degrees clockwise.
    D3D11_VIDEO_PROCESSOR_ROTATION_90       = 0x00000001,
    ///The video is rotated 180 degrees clockwise.
    D3D11_VIDEO_PROCESSOR_ROTATION_180      = 0x00000002,
    ///The video is rotated 270 degrees clockwise.
    D3D11_VIDEO_PROCESSOR_ROTATION_270      = 0x00000003,
}

///Specifies the type of Microsoft Direct3D authenticated channel.
alias D3D11_AUTHENTICATED_CHANNEL_TYPE = int;
enum : int
{
    ///Direct3D 11 channel. This channel provides communication with the Direct3D runtime.
    D3D11_AUTHENTICATED_CHANNEL_D3D11           = 0x00000001,
    ///Software driver channel. This channel provides communication with a driver that implements content protection
    ///mechanisms in software.
    D3D11_AUTHENTICATED_CHANNEL_DRIVER_SOFTWARE = 0x00000002,
    ///Hardware driver channel. This channel provides communication with a driver that implements content protection
    ///mechanisms in the GPU hardware.
    D3D11_AUTHENTICATED_CHANNEL_DRIVER_HARDWARE = 0x00000003,
}

///Specifies the type of process that is identified in the
///D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_OUTPUT structure.
alias D3D11_AUTHENTICATED_PROCESS_IDENTIFIER_TYPE = int;
enum : int
{
    ///Unknown process type.
    D3D11_PROCESSIDTYPE_UNKNOWN = 0x00000000,
    ///Desktop Window Manager (DWM) process.
    D3D11_PROCESSIDTYPE_DWM     = 0x00000001,
    ///Handle to a process.
    D3D11_PROCESSIDTYPE_HANDLE  = 0x00000002,
}

///Specifies the type of I/O bus that is used by the graphics adapter.
alias D3D11_BUS_TYPE = int;
enum : int
{
    ///Indicates a type of bus other than the types listed here.
    D3D11_BUS_TYPE_OTHER                                            = 0x00000000,
    ///PCI bus.
    D3D11_BUS_TYPE_PCI                                              = 0x00000001,
    ///PCI-X bus.
    D3D11_BUS_TYPE_PCIX                                             = 0x00000002,
    ///PCI Express bus.
    D3D11_BUS_TYPE_PCIEXPRESS                                       = 0x00000003,
    ///Accelerated Graphics Port (AGP) bus.
    D3D11_BUS_TYPE_AGP                                              = 0x00000004,
    ///The implementation for the graphics adapter is in a motherboard chipset's north bridge. This flag implies that
    ///data never goes over an expansion bus (such as PCI or AGP) when it is transferred from main memory to the
    ///graphics adapter.
    D3D11_BUS_IMPL_MODIFIER_INSIDE_OF_CHIPSET                       = 0x00010000,
    ///Indicates that the graphics adapter is connected to a motherboard chipset's north bridge by tracks on the
    ///motherboard, and all of the graphics adapter's chips are soldered to the motherboard. This flag implies that data
    ///never goes over an expansion bus (such as PCI or AGP) when it is transferred from main memory to the graphics
    ///adapter.
    D3D11_BUS_IMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP          = 0x00020000,
    ///The graphics adapter is connected to a motherboard chipset's north bridge by tracks on the motherboard, and all
    ///of the graphics adapter's chips are connected through sockets to the motherboard.
    D3D11_BUS_IMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET        = 0x00030000,
    ///The graphics adapter is connected to the motherboard through a daughterboard connector.
    D3D11_BUS_IMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR                = 0x00040000,
    ///The graphics adapter is connected to the motherboard through a daughterboard connector, and the graphics adapter
    ///is inside an enclosure that is not user accessible.
    D3D11_BUS_IMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE = 0x00050000,
    ///One of the <b>D3D11_BUS_IMPL_MODIFIER_Xxx</b> flags is set.
    D3D11_BUS_IMPL_MODIFIER_NON_STANDARD                            = 0x80000000,
}

///Specifies how to access a resource that is used in a video decoding output view.
alias D3D11_VDOV_DIMENSION = int;
enum : int
{
    ///Not a valid value.
    D3D11_VDOV_DIMENSION_UNKNOWN   = 0x00000000,
    ///The resource will be accessed as a 2D texture.
    D3D11_VDOV_DIMENSION_TEXTURE2D = 0x00000001,
}

///Specifies how to access a resource that is used in a video processor input view.
alias D3D11_VPIV_DIMENSION = int;
enum : int
{
    ///Not a valid value.
    D3D11_VPIV_DIMENSION_UNKNOWN   = 0x00000000,
    ///The resource will be accessed as a 2D texture.
    D3D11_VPIV_DIMENSION_TEXTURE2D = 0x00000001,
}

///Specifies how to access a resource that is used in a video processor output view.
alias D3D11_VPOV_DIMENSION = int;
enum : int
{
    ///Not a valid value.
    D3D11_VPOV_DIMENSION_UNKNOWN        = 0x00000000,
    ///The resource will be accessed as a 2D texture.
    D3D11_VPOV_DIMENSION_TEXTURE2D      = 0x00000001,
    ///The resource will be accessed as an array of 2D textures.
    D3D11_VPOV_DIMENSION_TEXTURE2DARRAY = 0x00000002,
}

///Specifies capabilities of the video decoder.
alias D3D11_VIDEO_DECODER_CAPS = int;
enum : int
{
    ///Indicates that the graphics driver supports at least a subset of downsampling operations.
    D3D11_VIDEO_DECODER_CAPS_DOWNSAMPLE          = 0x00000001,
    ///Indicates that the decoding hardware cannot support the decode operation in real-time. Decoding is still
    ///supported for transcoding scenarios. With this capability, it is possible that decoding can occur in real-time if
    ///downsampling is enabled.
    D3D11_VIDEO_DECODER_CAPS_NON_REAL_TIME       = 0x00000002,
    ///Indicates that the driver supports changing down sample parameters after the initial down sample parameters have
    ///been applied. For more information, see ID3D11VideoContext1::DecoderUpdateDownsampling.
    D3D11_VIDEO_DECODER_CAPS_DOWNSAMPLE_DYNAMIC  = 0x00000004,
    D3D11_VIDEO_DECODER_CAPS_DOWNSAMPLE_REQUIRED = 0x00000008,
    D3D11_VIDEO_DECODER_CAPS_UNSUPPORTED         = 0x00000010,
}

///Specifies flags that indicate the most efficient methods for performing video processing operations.
alias D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINTS = int;
enum : int
{
    ///Multi-plane overlay hardware can perform the rotation operation more efficiently than the
    ///ID3D11VideoContext::VideoProcessorBlt method.
    D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_MULTIPLANE_OVERLAY_ROTATION               = 0x00000001,
    ///Multi-plane overlay hardware can perform the scaling operation more efficiently than the
    ///ID3D11VideoContext::VideoProcessorBlt method.
    D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_MULTIPLANE_OVERLAY_RESIZE                 = 0x00000002,
    ///Multi-plane overlay hardware can perform the colorspace conversion operation more efficiently than the
    ///ID3D11VideoContext::VideoProcessorBlt method.
    D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_MULTIPLANE_OVERLAY_COLOR_SPACE_CONVERSION = 0x00000004,
    ///The video processor output data should be at least triple buffered for optimal performance.
    D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_TRIPLE_BUFFER_OUTPUT                      = 0x00000008,
}

///Represents the status of an ID3D11CryptoSession interface.
alias D3D11_CRYPTO_SESSION_STATUS = int;
enum : int
{
    ///The ID3D11CryptoSession is in a functional state.
    D3D11_CRYPTO_SESSION_STATUS_OK                   = 0x00000000,
    ///The underlying hardware key for the specified ID3D11CryptoSession has become lost.
    D3D11_CRYPTO_SESSION_STATUS_KEY_LOST             = 0x00000001,
    ///The underlying hardware key for the specified ID3D11CryptoSession has become lost and protected content has
    ///become corrupted.
    D3D11_CRYPTO_SESSION_STATUS_KEY_AND_CONTENT_LOST = 0x00000002,
}

///Specifies a Direct3D 11 video feature or feature set to query about. When you want to query for the level to which an
///adapter supports a feature, pass one of these values to <a href =
///"nf-d3d11_4-id3d11videodevice2-checkfeaturesupport.md">ID3D11VideoDevice2::CheckFeatureSupport</a>.
alias D3D11_FEATURE_VIDEO = int;
enum : int
{
    ///Retrieves the supported components, bin count, and counter bit depth for the a decode histogram with the
    ///specified decode profile, resolution, and format. The associated data structure is <a href
    ///="ns-d3d11_4-d3d11_feature_data_video_decoder_histogram.md">D3D11_FEATURE_DATA_VIDEO_DECODER_HISTOGRAM</a>.
    D3D11_FEATURE_VIDEO_DECODER_HISTOGRAM = 0x00000000,
}

// Constants


enum const(wchar)* g_wszSpeechFormatCaps = "SpeechFormatCap";
enum const(wchar)* g_wszWMCPSupportedVBRModes = "_SUPPORTEDVBRMODES";
enum const(wchar)* g_wszWMCPAudioVBRQuality = "_VBRQUALITY";
enum const(wchar)* g_wszWMCPDefaultCrisp = "_DEFAULTCRISP";

enum : int
{
    COPP_ProtectionType_None     = 0x00000000,
    COPP_ProtectionType_HDCP     = 0x00000001,
    COPP_ProtectionType_ACP      = 0x00000002,
    COPP_ProtectionType_CGMSA    = 0x00000004,
    COPP_ProtectionType_Mask     = 0x80000007,
    COPP_ProtectionType_Reserved = 0x7ffffff8,
}

enum : GUID
{
    MF_BYTESTREAM_CONTENT_TYPE       = GUID("fc358289-3cb6-460c-a424-b6681260375a"),
    MF_BYTESTREAM_DURATION           = GUID("fc35828a-3cb6-460c-a424-b6681260375a"),
    MF_BYTESTREAM_LAST_MODIFIED_TIME = GUID("fc35828b-3cb6-460c-a424-b6681260375a"),
    MF_BYTESTREAM_IFO_FILE_URI       = GUID("fc35828c-3cb6-460c-a424-b6681260375a"),
    MF_BYTESTREAM_DLNA_PROFILE_ID    = GUID("fc35828d-3cb6-460c-a424-b6681260375a"),
    MF_BYTESTREAM_EFFECTIVE_URL      = GUID("9afa0209-89d1-42af-8456-1de6b562d691"),
    MF_BYTESTREAM_TRANSCODED         = GUID("b6c5c282-4dc9-4db9-ab48-cf3b6d8bc5e0"),
}

enum GUID MEDeviceStreamCreated = GUID("0252a1cf-3540-43b4-9164-d72eb405fa40");
enum GUID MF_SA_REQUIRED_SAMPLE_COUNT = GUID("18802c61-324b-4952-abd0-176ff5c696ff");
enum GUID MF_SA_AUDIO_ENDPOINT_AWARE = GUID("c0381701-805c-42b2-ac8d-e2b4bf21f4f8");
enum GUID MFT_AUDIO_DECODER_SPATIAL_METADATA_CLIENT = GUID("05987df4-1270-4999-925f-8e939a7c0af7");
enum GUID MF_SA_REQUIRED_SAMPLE_COUNT_PROGRESSIVE = GUID("b172d58e-fa77-4e48-8d2a-1df2d850eac2");
enum GUID MF_SA_MINIMUM_OUTPUT_SAMPLE_COUNT_PROGRESSIVE = GUID("0f5523a5-1cb2-47c5-a550-2eeb84b4d14a");
enum GUID MF_ENABLE_3DVIDEO_OUTPUT = GUID("bdad7bca-0e5f-4b10-ab16-26de381b6293");

enum : GUID
{
    MF_SA_D3D11_USAGE                = GUID("e85fe442-2ca3-486e-a9c7-109dda609880"),
    MF_SA_D3D11_AWARE                = GUID("206b4fc8-fcf9-4c51-afe3-9764369e33a0"),
    MF_SA_D3D11_SHARED               = GUID("7b8f32c3-6d96-4b89-9203-dd38b61414f3"),
    MF_SA_D3D11_SHARED_WITHOUT_MUTEX = GUID("39dbd44d-2e44-4931-a4c8-352d3dc42115"),
}

enum GUID MF_SA_D3D11_HW_PROTECTED = GUID("3a8ba9d9-92ca-4307-a391-6999dbf3b6ce");
enum GUID MFT_DECODER_EXPOSE_OUTPUT_TYPES_IN_NATIVE_ORDER = GUID("ef80833f-f8fa-44d9-80d8-41ed6232670c");
enum GUID MFT_DECODER_QUALITY_MANAGEMENT_RECOVERY_WITHOUT_ARTIFACTS = GUID("d8980deb-0a48-425f-8623-611db41d3810");
enum GUID MFT_DECODER_FINAL_VIDEO_RESOLUTION_HINT = GUID("dc2f8496-15c4-407a-b6f0-1b66ab5fbf53");
enum GUID MFT_ENUM_HARDWARE_VENDOR_ID_Attribute = GUID("3aecb0cc-035b-4bcc-8185-2b8d551ef3af");

enum : GUID
{
    MF_TRANSFORM_ASYNC_UNLOCK       = GUID("e5666d6b-3422-4eb6-a421-da7db1f8e207"),
    MF_TRANSFORM_FLAGS_Attribute    = GUID("9359bb7e-6275-46c4-a025-1c01e45f1a86"),
    MF_TRANSFORM_CATEGORY_Attribute = GUID("ceabba49-506d-4757-a6ff-66c184987e4e"),
}

enum GUID MFT_INPUT_TYPES_Attributes = GUID("4276c9b1-759d-4bf3-9cd0-0d723d138f96");
enum GUID MFT_ENUM_HARDWARE_URL_Attribute = GUID("2fb866ac-b078-4942-ab6c-003d05cda674");

enum : GUID
{
    MFT_CONNECTED_STREAM_ATTRIBUTE = GUID("71eeb820-a59f-4de2-bcec-38db1dd611a4"),
    MFT_CONNECTED_TO_HW_STREAM     = GUID("34e6e728-06d6-4491-a553-4795650db912"),
}

enum GUID MFT_PROCESS_LOCAL_Attribute = GUID("543186e4-4649-4e65-b588-4aa352aff379");
enum GUID MFT_HW_TIMESTAMP_WITH_QPC_Attribute = GUID("8d030fb8-cc43-4258-a22e-9210bef89be4");
enum GUID MFT_CODEC_MERIT_Attribute = GUID("88a7cb15-7b07-4a34-9128-e64c6703c4d3");
enum GUID MFT_AUDIO_DECODER_DEGRADATION_INFO_ATTRIBUTE = GUID("6c3386ad-ec20-430d-b2a5-505c7178d9c4");
enum GUID MFT_USING_HARDWARE_DRM = GUID("34faa77d-d79e-4957-b8ce-362b2684996c");
enum GUID MF_PROGRESSIVE_CODING_CONTENT = GUID("8f020eea-1508-471f-9da6-507d7cfa40db");
enum GUID MF_NALU_LENGTH_INFORMATION = GUID("19124e7c-ad4b-465f-bb18-20186287b6af");

enum : GUID
{
    MF_MPEG4SINK_SPSPPS_PASSTHROUGH               = GUID("5601a134-2005-4ad2-b37d-22a6c554deb2"),
    MF_MPEG4SINK_MOOV_BEFORE_MDAT                 = GUID("f672e3ac-e1e6-4f10-b5ec-5f3b30828816"),
    MF_MPEG4SINK_MINIMUM_PROPERTIES_SIZE          = GUID("dca1ed52-450e-4a22-8c62-4ed452f7a187"),
    MF_MPEG4SINK_MIN_FRAGMENT_DURATION            = GUID("a30b570c-8efd-45e8-94fe-27c84b5bdff6"),
    MF_MPEG4SINK_MAX_CODED_SEQUENCES_PER_FRAGMENT = GUID("fc1b3bd6-692d-4ce5-9299-738aa5463e9a"),
}

enum : GUID
{
    MF_SESSION_GLOBAL_TIME                = GUID("1e83d482-1f1c-4571-8405-88f4b2181f72"),
    MF_SESSION_QUALITY_MANAGER            = GUID("1e83d482-1f1c-4571-8405-88f4b2181f73"),
    MF_SESSION_CONTENT_PROTECTION_MANAGER = GUID("1e83d482-1f1c-4571-8405-88f4b2181f74"),
}

enum GUID MF_SESSION_REMOTE_SOURCE_MODE = GUID("f4033ef4-9bb3-4378-941f-85a0856bc244");
enum GUID MF_PMP_SERVER_CONTEXT = GUID("2f00c910-d2cf-4278-8b6a-d077fac3a25f");
enum GUID MF_SOURCE_STREAM_SUPPORTS_HW_CONNECTION = GUID("a38253aa-6314-42fd-a3ce-bb27b6859946");
enum GUID MF_STREAM_SINK_SUPPORTS_ROTATION = GUID("b3e96280-bd05-41a5-97ad-8a7fee24b912");

enum : GUID
{
    MF_SINK_VIDEO_NATIVE_WIDTH                     = GUID("e6d6a707-1505-4747-9b10-72d2d158cb3a"),
    MF_SINK_VIDEO_NATIVE_HEIGHT                    = GUID("f0ca6705-490c-43e8-941c-c0b3206b9a65"),
    MF_SINK_VIDEO_DISPLAY_ASPECT_RATIO_NUMERATOR   = GUID("d0f33b22-b78a-4879-b455-f03ef3fa82cd"),
    MF_SINK_VIDEO_DISPLAY_ASPECT_RATIO_DENOMINATOR = GUID("6ea1eb97-1fe0-4f10-a6e4-1f4f661564e0"),
}

enum : GUID
{
    MF_LUMA_KEY_ENABLE = GUID("7369820f-76de-43ca-9284-47b8f37e0649"),
    MF_LUMA_KEY_LOWER  = GUID("93d7b8d5-0b81-4715-aea0-8725871621e9"),
    MF_LUMA_KEY_UPPER  = GUID("d09f39bb-4602-4c31-a706-a12171a5110a"),
}

enum GUID MF_INDEPENDENT_STILL_IMAGE = GUID("ea12af41-0710-42c9-a127-daa3e78483a5");

enum : GUID
{
    MF_TOPOLOGY_PROJECTSTART            = GUID("7ed3f802-86bb-4b3f-b7e4-7cb43afd4b80"),
    MF_TOPOLOGY_PROJECTSTOP             = GUID("7ed3f803-86bb-4b3f-b7e4-7cb43afd4b80"),
    MF_TOPOLOGY_NO_MARKIN_MARKOUT       = GUID("7ed3f804-86bb-4b3f-b7e4-7cb43afd4b80"),
    MF_TOPOLOGY_DXVA_MODE               = GUID("1e8d34f6-f5ab-4e23-bb88-874aa3a1a74d"),
    MF_TOPOLOGY_ENABLE_XVP_FOR_PLAYBACK = GUID("1967731f-cd78-42fc-b026-0992a56e5693"),
}

enum : GUID
{
    MF_TOPOLOGY_PLAYBACK_MAX_DIMS  = GUID("5715cf19-5768-44aa-ad6e-8721f1b0f9bb"),
    MF_TOPOLOGY_HARDWARE_MODE      = GUID("d2d362fd-4e4f-4191-a579-c618b66706af"),
    MF_TOPOLOGY_PLAYBACK_FRAMERATE = GUID("c164737a-c2b1-4553-83bb-5a526072448f"),
}

enum GUID MF_TOPOLOGY_ENUMERATE_SOURCE_TYPES = GUID("6248c36d-5d0b-4f40-a0bb-b0b305f77698");
enum GUID MF_DISABLE_LOCALLY_REGISTERED_PLUGINS = GUID("66b16da9-add4-47e0-a16b-5af1fb483634");

enum : GUID
{
    MF_TOPONODE_FLUSH    = GUID("494bbce8-b031-4e38-97c4-d5422dd618dc"),
    MF_TOPONODE_DRAIN    = GUID("494bbce9-b031-4e38-97c4-d5422dd618dc"),
    MF_TOPONODE_D3DAWARE = GUID("494bbced-b031-4e38-97c4-d5422dd618dc"),
}

enum : GUID
{
    MF_TOPONODE_ERRORCODE             = GUID("494bbcee-b031-4e38-97c4-d5422dd618dc"),
    MF_TOPONODE_CONNECT_METHOD        = GUID("494bbcf1-b031-4e38-97c4-d5422dd618dc"),
    MF_TOPONODE_LOCKED                = GUID("494bbcf7-b031-4e38-97c4-d5422dd618dc"),
    MF_TOPONODE_WORKQUEUE_ID          = GUID("494bbcf8-b031-4e38-97c4-d5422dd618dc"),
    MF_TOPONODE_WORKQUEUE_MMCSS_CLASS = GUID("494bbcf9-b031-4e38-97c4-d5422dd618dc"),
}

enum : GUID
{
    MF_TOPONODE_DISCARDABLE              = GUID("494bbcfb-b031-4e38-97c4-d5422dd618dc"),
    MF_TOPONODE_ERROR_MAJORTYPE          = GUID("494bbcfd-b031-4e38-97c4-d5422dd618dc"),
    MF_TOPONODE_ERROR_SUBTYPE            = GUID("494bbcfe-b031-4e38-97c4-d5422dd618dc"),
    MF_TOPONODE_WORKQUEUE_MMCSS_TASKID   = GUID("494bbcff-b031-4e38-97c4-d5422dd618dc"),
    MF_TOPONODE_WORKQUEUE_MMCSS_PRIORITY = GUID("5001f840-2816-48f4-9364-ad1ef661a123"),
    MF_TOPONODE_WORKQUEUE_ITEM_PRIORITY  = GUID("a1ff99be-5e97-4a53-b494-568c642c0ff3"),
}

enum : GUID
{
    MF_TOPONODE_MARKOUT_HERE            = GUID("494bbd01-b031-4e38-97c4-d5422dd618dc"),
    MF_TOPONODE_DECODER                 = GUID("494bbd02-b031-4e38-97c4-d5422dd618dc"),
    MF_TOPONODE_MEDIASTART              = GUID("835c58ea-e075-4bc7-bcba-4de000df9ae6"),
    MF_TOPONODE_MEDIASTOP               = GUID("835c58eb-e075-4bc7-bcba-4de000df9ae6"),
    MF_TOPONODE_SOURCE                  = GUID("835c58ec-e075-4bc7-bcba-4de000df9ae6"),
    MF_TOPONODE_PRESENTATION_DESCRIPTOR = GUID("835c58ed-e075-4bc7-bcba-4de000df9ae6"),
}

enum GUID MF_TOPONODE_SEQUENCE_ELEMENTID = GUID("835c58ef-e075-4bc7-bcba-4de000df9ae6");

enum : GUID
{
    MF_TOPONODE_STREAMID             = GUID("14932f9b-9087-4bb4-8412-5167145cbe04"),
    MF_TOPONODE_NOSHUTDOWN_ON_REMOVE = GUID("14932f9c-9087-4bb4-8412-5167145cbe04"),
}

enum : GUID
{
    MF_TOPONODE_DISABLE_PREROLL = GUID("14932f9e-9087-4bb4-8412-5167145cbe04"),
    MF_TOPONODE_PRIMARYOUTPUT   = GUID("6304ef99-16b2-4ebe-9d67-e4c539b3a259"),
}

enum GUID MF_PD_APP_CONTEXT = GUID("6c990d32-bb8e-477a-8598-0d5d96fcd88a");
enum GUID MF_PD_TOTAL_FILE_SIZE = GUID("6c990d34-bb8e-477a-8598-0d5d96fcd88a");
enum GUID MF_PD_VIDEO_ENCODING_BITRATE = GUID("6c990d36-bb8e-477a-8598-0d5d96fcd88a");
enum GUID MF_PD_LAST_MODIFIED_TIME = GUID("6c990d38-bb8e-477a-8598-0d5d96fcd88a");
enum GUID MF_PD_PREFERRED_LANGUAGE = GUID("6c990d3a-bb8e-477a-8598-0d5d96fcd88a");
enum GUID MF_PD_AUDIO_ISVARIABLEBITRATE = GUID("33026ee0-e387-4582-ae0a-34a2ad3baa18");
enum GUID MF_SD_PROTECTED = GUID("00af2181-bdc2-423c-abca-f503593bc121");
enum GUID MF_SD_MUTUALLY_EXCLUSIVE = GUID("023ef79c-388d-487f-ac17-696cd6e3c6f5");

enum : GUID
{
    MF_ACTIVATE_CUSTOM_VIDEO_MIXER_ACTIVATE     = GUID("ba491361-be50-451e-95ab-6d4accc7dad8"),
    MF_ACTIVATE_CUSTOM_VIDEO_MIXER_FLAGS        = GUID("ba491362-be50-451e-95ab-6d4accc7dad8"),
    MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_CLSID    = GUID("ba491364-be50-451e-95ab-6d4accc7dad8"),
    MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_ACTIVATE = GUID("ba491365-be50-451e-95ab-6d4accc7dad8"),
    MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_FLAGS    = GUID("ba491366-be50-451e-95ab-6d4accc7dad8"),
}

enum GUID MF_ACTIVATE_VIDEO_WINDOW = GUID("9a2dbbdd-f57e-4162-82b9-6831377682d3");

enum : GUID
{
    MF_AUDIO_RENDERER_ATTRIBUTE_SESSION_ID      = GUID("ede4b5e3-f805-4d6c-99b3-db01bf95dfab"),
    MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ID     = GUID("b10aaec3-ef71-4cc3-b873-05a9a08b9f8e"),
    MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ROLE   = GUID("6ba644ff-27c5-4d02-9887-c28619fdb91b"),
    MF_AUDIO_RENDERER_ATTRIBUTE_STREAM_CATEGORY = GUID("a9770471-92ec-4df4-94fe-81c36f0c3a7a"),
}

enum : GUID
{
    MFENABLETYPE_WMDRMV7_LicenseAcquisition = GUID("003306df-4a06-4884-a097-ef6d22ec84a3"),
    MFENABLETYPE_WMDRMV7_Individualization  = GUID("acd2c84a-b303-4f65-bc2c-2c848d01a989"),
}

enum GUID MFENABLETYPE_MF_UpdateUntrustedComponent = GUID("9879f3d6-cee2-48e6-b573-9767ab172f16");
enum GUID MF_METADATA_PROVIDER_SERVICE = GUID("db214084-58a4-4d2e-b84f-6f755b2f7a0d");
enum GUID MF_RATE_CONTROL_SERVICE = GUID("866fa297-b802-4bf8-9dc9-5e3b6a9f53c9");
enum GUID MR_POLICY_VOLUME_SERVICE = GUID("1abaa2ac-9d3b-47c6-ab48-c59506de784d");
enum GUID MR_STREAM_VOLUME_SERVICE = GUID("f8b5fa2f-32ef-46f5-b172-1321212fb2c4");

enum : GUID
{
    MF_SAMPLEGRABBERSINK_SAMPLE_TIME_OFFSET = GUID("62e3d776-8100-4e03-a6e8-bd3857ac9c47"),
    MF_SAMPLEGRABBERSINK_IGNORE_CLOCK       = GUID("0efda2c0-2b69-4e2e-ab8d-46dcbff7d25d"),
}

enum GUID MF_WORKQUEUE_SERVICES = GUID("8e37d489-41e0-413a-9068-287c886d8dda");
enum GUID MF_QUALITY_NOTIFY_SAMPLE_LAG = GUID("30d15206-ed2a-4760-be17-eb4a9f12295c");
enum GUID MF_SOURCE_PRESENTATION_PROVIDER_SERVICE = GUID("e002aadc-f4af-4ee5-9847-053edf840426");
enum GUID MFNETSOURCE_SSLCERTIFICATE_MANAGER = GUID("55e6cb27-e69b-4267-940c-2d7ec5bb8a0f");
enum GUID MFNET_SAVEJOB_SERVICE = GUID("b85a587f-3d02-4e52-9565-55d3ec1e7ff7");

enum : GUID
{
    MFNETSOURCE_STATISTICS                   = GUID("3cb1f274-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_BUFFERINGTIME                = GUID("3cb1f276-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_ACCELERATEDSTREAMINGDURATION = GUID("3cb1f277-0505-4c5d-ae71-0a556344efa1"),
}

enum : GUID
{
    MFNETSOURCE_MAXBUFFERTIMEMS     = GUID("408b24e6-4038-4401-b5b2-fe701a9ebf10"),
    MFNETSOURCE_CONNECTIONBANDWIDTH = GUID("3cb1f278-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_CACHEENABLED        = GUID("3cb1f279-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_AUTORECONNECTLIMIT  = GUID("3cb1f27a-0505-4c5d-ae71-0a556344efa1"),
}

enum : GUID
{
    MFNETSOURCE_THINNINGENABLED    = GUID("3cb1f27c-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_PROTOCOL           = GUID("3cb1f27d-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_TRANSPORT          = GUID("3cb1f27e-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_PREVIEWMODEENABLED = GUID("3cb1f27f-0505-4c5d-ae71-0a556344efa1"),
}

enum : GUID
{
    MFNETSOURCE_PPBANDWIDTH           = GUID("3cb1f281-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_AUTORECONNECTPROGRESS = GUID("3cb1f282-0505-4c5d-ae71-0a556344efa1"),
}

enum : GUID
{
    MFNETSOURCE_BROWSERUSERAGENT   = GUID("3cb1f28b-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_BROWSERWEBPAGE     = GUID("3cb1f28c-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_PLAYERVERSION      = GUID("3cb1f28d-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_PLAYERID           = GUID("3cb1f28e-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_HOSTEXE            = GUID("3cb1f28f-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_HOSTVERSION        = GUID("3cb1f291-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_PLAYERUSERAGENT    = GUID("3cb1f292-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_CLIENTGUID         = GUID("60a2c4a6-f197-4c14-a5bf-88830d2458af"),
    MFNETSOURCE_LOGURL             = GUID("3cb1f293-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_ENABLE_UDP         = GUID("3cb1f294-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_ENABLE_TCP         = GUID("3cb1f295-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_ENABLE_MSB         = GUID("3cb1f296-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_ENABLE_RTSP        = GUID("3cb1f298-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_ENABLE_HTTP        = GUID("3cb1f299-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_ENABLE_STREAMING   = GUID("3cb1f29c-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_ENABLE_DOWNLOAD    = GUID("3cb1f29d-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_ENABLE_PRIVATEMODE = GUID("824779d8-f18b-4405-8cf1-464fb5aa8f71"),
}

enum : GUID
{
    MFNETSOURCE_PROXYINFO                     = GUID("3cb1f29b-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_DRMNET_LICENSE_REPRESENTATION = GUID("47eae1bd-bdfe-42e2-82f3-54a48c17962d"),
}

enum : GUID
{
    MFNETSOURCE_PROXYHOSTNAME           = GUID("3cb1f284-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_PROXYPORT               = GUID("3cb1f288-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_PROXYEXCEPTIONLIST      = GUID("3cb1f285-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_PROXYBYPASSFORLOCAL     = GUID("3cb1f286-0505-4c5d-ae71-0a556344efa1"),
    MFNETSOURCE_PROXYRERUNAUTODETECTION = GUID("3cb1f289-0505-4c5d-ae71-0a556344efa1"),
}

enum : GUID
{
    MFNETSOURCE_LOGPARAMS    = GUID("64936ae8-9418-453a-8cda-3e0a668b353b"),
    MFNETSOURCE_PEERMANAGER  = GUID("48b29adb-febf-45ee-a9bf-efb81c492efc"),
    MFNETSOURCE_FRIENDLYNAME = GUID("5b2a7757-bc6b-447e-aa06-0dda1c646e2f"),
}

enum GUID MF_BYTESTREAM_SERVICE = GUID("ab025e2b-16d9-4180-a127-ba6c70156161");

enum : GUID
{
    MFCONNECTOR_SPDIF                = GUID("0b94a712-ad3e-4cee-83ce-ce32e3db6522"),
    MFCONNECTOR_UNKNOWN              = GUID("ac3aef5c-ce43-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_PCI                  = GUID("ac3aef5d-ce43-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_PCIX                 = GUID("ac3aef5e-ce43-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_PCI_Express          = GUID("ac3aef5f-ce43-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_AGP                  = GUID("ac3aef60-ce43-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_VGA                  = GUID("57cd5968-ce47-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_SVIDEO               = GUID("57cd5969-ce47-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_COMPOSITE            = GUID("57cd596a-ce47-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_COMPONENT            = GUID("57cd596b-ce47-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_DVI                  = GUID("57cd596c-ce47-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_HDMI                 = GUID("57cd596d-ce47-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_LVDS                 = GUID("57cd596e-ce47-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_D_JPN                = GUID("57cd5970-ce47-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_SDI                  = GUID("57cd5971-ce47-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_DISPLAYPORT_EXTERNAL = GUID("57cd5972-ce47-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_DISPLAYPORT_EMBEDDED = GUID("57cd5973-ce47-11d9-92db-000bdb28ff98"),
}

enum : GUID
{
    MFCONNECTOR_UDI_EMBEDDED                      = GUID("57cd5975-ce47-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_MIRACAST                          = GUID("57cd5977-ce47-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_TRANSPORT_AGNOSTIC_DIGITAL_MODE_A = GUID("57cd5978-ce47-11d9-92db-000bdb28ff98"),
    MFCONNECTOR_TRANSPORT_AGNOSTIC_DIGITAL_MODE_B = GUID("57cd5979-ce47-11d9-92db-000bdb28ff98"),
}

enum : GUID
{
    MFPROTECTION_DISABLE               = GUID("8cc6d81b-fec6-4d8f-964b-cfba0b0dad0d"),
    MFPROTECTION_CONSTRICTVIDEO        = GUID("193370ce-c5e4-4c3a-8a66-6959b4da4442"),
    MFPROTECTION_CONSTRICTVIDEO_NOOPM  = GUID("a580e8cd-c247-4957-b983-3c2eebd1ff59"),
    MFPROTECTION_CONSTRICTAUDIO        = GUID("ffc99b44-df48-4e16-8e66-096892c1578a"),
    MFPROTECTION_TRUSTEDAUDIODRIVERS   = GUID("65bdf3d2-0168-4816-a533-55d47b027101"),
    MFPROTECTION_HDCP                  = GUID("ae7cc03d-c828-4021-acb7-d578d27aaf13"),
    MFPROTECTION_CGMSA                 = GUID("e57e69e9-226b-4d31-b4e3-d3db008736dd"),
    MFPROTECTION_ACP                   = GUID("c3fd11c6-f8b7-4d20-b008-1db17d61f2da"),
    MFPROTECTION_WMDRMOTA              = GUID("a267a6a1-362e-47d0-8805-4628598a23e4"),
    MFPROTECTION_FFT                   = GUID("462a56b2-2866-4bb6-980d-6d8d9edb1a8c"),
    MFPROTECTION_PROTECTED_SURFACE     = GUID("4f5d9566-e742-4a25-8d1f-d287b5fa0ade"),
    MFPROTECTION_DISABLE_SCREEN_SCRAPE = GUID("a21179a4-b7cd-40d8-9614-8ef2371ba78d"),
}

enum : GUID
{
    MFPROTECTION_HARDWARE                   = GUID("4ee7f0c1-9ed7-424f-b6be-996b33528856"),
    MFPROTECTION_HDCP_WITH_TYPE_ENFORCEMENT = GUID("a4a585e8-ed60-442d-814d-db4d4220a06d"),
}

enum GUID MFPROTECTIONATTRIBUTE_FAIL_OVER = GUID("8536abc5-38f1-4151-9cce-f55d941229ac");

enum : GUID
{
    MFPROTECTIONATTRIBUTE_CONSTRICTVIDEO_IMAGESIZE = GUID("008476fc-4b58-4d80-a790-e7297673161d"),
    MFPROTECTIONATTRIBUTE_HDCP_SRM                 = GUID("6f302107-3477-4468-8a08-eef9db10e20f"),
}

enum GUID MF_REMOTE_PROXY = GUID("2f00c90e-d2cf-4278-8b6a-d077fac3a25f");
enum GUID MF_SAMI_SERVICE = GUID("49a89ae7-b4d9-4ef2-aa5c-f65a3e05ae4e");
enum GUID MF_SD_SAMI_LANGUAGE = GUID("36fcb98a-6cd0-44cb-acb9-a8f5600dd0bb");

enum : GUID
{
    MFTranscodeContainerType_ASF    = GUID("430f6f6e-b6bf-4fc1-a0bd-9ee46eee2afb"),
    MFTranscodeContainerType_MPEG4  = GUID("dc6cd05d-b9d0-40ef-bd35-fa622c1ab28a"),
    MFTranscodeContainerType_MP3    = GUID("e438b912-83f1-4de6-9e3a-9ffbc6dd24d1"),
    MFTranscodeContainerType_FLAC   = GUID("31344aa3-05a9-42b5-901b-8e9d4257f75e"),
    MFTranscodeContainerType_3GP    = GUID("34c50167-4472-4f34-9ea0-c49fbacf037d"),
    MFTranscodeContainerType_AC3    = GUID("6d8d91c3-8c91-4ed1-8742-8c347d5b44d0"),
    MFTranscodeContainerType_ADTS   = GUID("132fd27d-0f02-43de-a301-38fbbbb3834e"),
    MFTranscodeContainerType_MPEG2  = GUID("bfc2dbf9-7bb4-4f8f-afde-e112c44ba882"),
    MFTranscodeContainerType_WAVE   = GUID("64c3453c-0f26-4741-be63-87bdf8bb935b"),
    MFTranscodeContainerType_AVI    = GUID("7edfe8af-402f-4d76-a33c-619fd157d0f1"),
    MFTranscodeContainerType_FMPEG4 = GUID("9ba876f1-419f-4b77-a1e0-35959d9d4004"),
    MFTranscodeContainerType_AMR    = GUID("025d5ad3-621a-475b-964d-66b1c824f079"),
}

enum : GUID
{
    MF_TRANSCODE_TOPOLOGYMODE         = GUID("3e3df610-394a-40b2-9dea-3bab650bebf2"),
    MF_TRANSCODE_ADJUST_PROFILE       = GUID("9c37c21b-060f-487c-a690-80d7f50d1c72"),
    MF_TRANSCODE_ENCODINGPROFILE      = GUID("6947787c-f508-4ea9-b1e9-a1fe3a49fbc9"),
    MF_TRANSCODE_QUALITYVSSPEED       = GUID("98332df8-03cd-476b-89fa-3f9e442dec9f"),
    MF_TRANSCODE_DONOT_INSERT_ENCODER = GUID("f45aa7ce-ab24-4012-a11b-dc8220201410"),
}

enum GUID MF_XVP_DISABLE_FRC = GUID("2c0afa19-7a97-4d5a-9ee8-16d4fc518d8c");
enum GUID MF_LOCAL_MFT_REGISTRATION_SERVICE = GUID("ddf5cf9c-4506-45aa-abf0-6d5d94dd1b4a");
enum GUID MF_WRAPPED_OBJECT = GUID("2b182c4c-d6ac-49f4-8915-f71887db70cd");
enum GUID CLSID_UrlmonSchemePlugin = GUID("9ec4b4f9-3029-45ad-947b-344de2a249e2");

enum : GUID
{
    MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE                           = GUID("c60ac5fe-252a-478f-a0ef-bc8fa5f7cad3"),
    MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_HW_SOURCE          = GUID("de7046ba-54d6-4487-a2a4-ec7c0d1bd163"),
    MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME                         = GUID("60d0e559-52f8-4fa2-bbce-acdb34a8ec01"),
    MF_DEVSOURCE_ATTRIBUTE_MEDIA_TYPE                            = GUID("56a819ca-0c78-4de4-a0a7-3ddaba0f24d4"),
    MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_CATEGORY           = GUID("77f0ae69-c3bd-4509-941d-467e4d24899e"),
    MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK      = GUID("58f0aad8-22bf-4f8a-bb3d-d2c4978c6e2f"),
    MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_SYMBOLIC_LINK      = GUID("98d24b5e-5930-4614-b5a1-f600f9355a78"),
    MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_MAX_BUFFERS        = GUID("7dd9b730-4f2d-41d5-8f95-0cc9a912ba26"),
    MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_ENDPOINT_ID        = GUID("30da9258-feb9-47a7-a453-763a7a8e1c5f"),
    MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_ROLE               = GUID("bc9d118e-8c67-4a18-85d4-12d300400552"),
    MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_PROVIDER_DEVICE_ID = GUID("36689d42-a06c-40ae-84cf-f5a034067cc4"),
    MF_DEVSOURCE_ATTRIBUTE_SOURCE_XADDRESS                       = GUID("bca0be52-c327-44c7-9b7d-7fa8d9b5bcda"),
    MF_DEVSOURCE_ATTRIBUTE_SOURCE_STREAM_URL                     = GUID("9d7b40d2-3617-4043-93e3-8d6da9bb3492"),
    MF_DEVSOURCE_ATTRIBUTE_SOURCE_USERNAME                       = GUID("05d01add-949f-46eb-bc8e-8b0d2b32d79d"),
    MF_DEVSOURCE_ATTRIBUTE_SOURCE_PASSWORD                       = GUID("a0fd7e16-42d9-49df-84c0-e82c5eab8874"),
}

enum : GUID
{
    MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_GUID = GUID("14dd9a1c-7cff-41be-b1b9-ba1ac6ecb571"),
    MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_GUID = GUID("8ac3587a-4ae7-42d8-99e0-0a6013eef90f"),
}

enum GUID MF_DEVICESTREAM_INDEPENDENT_IMAGE_STREAM = GUID("03eeec7e-d605-4576-8b29-6580b490d7d3");

enum : GUID
{
    MF_DEVICESTREAM_STREAM_CATEGORY        = GUID("2939e7b8-a62e-4579-b674-d4073dfabbba"),
    MF_DEVICESTREAM_FRAMESERVER_SHARED     = GUID("1cb378e9-b279-41d4-af97-34a243e68320"),
    MF_DEVICESTREAM_TRANSFORM_STREAM_ID    = GUID("e63937b7-daaf-4d49-815f-d826f8ad31e7"),
    MF_DEVICESTREAM_EXTENSION_PLUGIN_CLSID = GUID("048e6558-60c4-4173-bd5b-6a3ca2896aee"),
}

enum GUID MF_DEVICESTREAM_EXTENSION_PLUGIN_CONNECTION_POINT = GUID("37f9375c-e664-4ea4-aae4-cb6d1daca1f4");
enum GUID MF_DEVICESTREAM_MAX_FRAME_BUFFERS = GUID("1684cebe-3175-4985-882c-0efd3e8ac11e");
enum GUID MF_DEVICEMFT_CONNECTED_PIN_KSCONTROL = GUID("e63310f7-b244-4ef8-9a7d-24c74e32ebd0");

enum : GUID
{
    MFSampleExtension_DeviceTimestamp                   = GUID("8f3e35e7-2dcd-4887-8622-2a58baa652b0"),
    MFSampleExtension_Spatial_CameraViewTransform       = GUID("4e251fa4-830f-4770-859a-4b8d99aa809b"),
    MFSampleExtension_Spatial_CameraCoordinateSystem    = GUID("9d13c82f-2199-4e67-91cd-d1a4181f2534"),
    MFSampleExtension_Spatial_CameraProjectionTransform = GUID("47f9fcb5-2a02-4f26-a477-792fdf95886a"),
}

enum GUID MF_ACCESS_CONTROLLED_MEDIASOURCE_SERVICE = GUID("014a5031-2f05-4c6a-9f9c-7d0dc4eda5f4");
enum GUID MF_CONTENT_PROTECTION_DEVICE_SERVICE = GUID("ff58436f-76a0-41fe-b566-10cc53962edd");
enum GUID MF_SD_AUDIO_ENCODER_PADDING = GUID("529c7f2c-ac4b-4e3f-bfc3-0902194982cb");
enum GUID CLSID_MSH264EncoderMFT = GUID("6ca50344-051a-4ded-9779-a43305165e35");
enum GUID CLSID_MP3DecMediaObject = GUID("bbeea841-0a63-4f52-a7ab-a9b3a84ed38a");
enum GUID CLSID_MSH265DecoderMFT = GUID("420a51a3-d605-430c-b4fc-45274fa6c562");
enum GUID CLSID_WMADecMediaObject = GUID("2eeb4adf-4578-4d10-bca7-bb955f56320a");
enum GUID CLSID_MSMPEGDecoderMFT = GUID("2d709e52-123f-49b5-9cbc-9af5cde28fb9");

enum : GUID
{
    CLSID_MSVPxDecoder  = GUID("e3aaf548-c9a4-4c6e-234d-5ada374b0000"),
    CLSID_MSOpusDecoder = GUID("63e17c10-2d43-4c42-8fe3-8d8b63e46a6a"),
}

enum GUID MFNETSOURCE_CROSS_ORIGIN_SUPPORT = GUID("9842207c-b02c-4271-a2fc-72e49308e5c2");
enum GUID MF_SD_MEDIASOURCE_STATUS = GUID("1913678b-fc0f-44da-8f43-1ba3b526f4ae");

enum : GUID
{
    MF_SD_VIDEO_SPHERICAL_FORMAT                = GUID("4a8fc407-6ea1-46c8-b567-6971d4a139c3"),
    MF_SD_VIDEO_SPHERICAL_INITIAL_VIEWDIRECTION = GUID("11d25a49-bb62-467f-9db1-c17165716c49"),
}

enum GUID MF_ST_MEDIASOURCE_COLLECTION = GUID("616de972-83ad-4950-8170-630d19cbe307");

enum : GUID
{
    MF_DEVICESTREAM_PIN_KSCONTROL      = GUID("ef3ef9a7-87f2-48ca-be02-674878918e98"),
    MF_DEVICESTREAM_SOURCE_ATTRIBUTES  = GUID("2f8cb617-361b-434f-85ea-99a03e1ce4e0"),
    MF_DEVICESTREAM_FRAMESERVER_HIDDEN = GUID("f402567b-4d91-4179-96d1-74c8480c2034"),
}

enum GUID MF_STF_VERSION_DATE = GUID("31a165d5-df67-4095-8e44-8868fc20dbfd");
enum GUID MF_DEVICESTREAM_REQUIRED_SDDL = GUID("331ae85d-c0d3-49ba-83ba-82a12d63cdd6");
enum GUID MF_DEVICESTREAM_SENSORSTREAM_ID = GUID("e35b9fe4-0659-4cad-bb51-33160be7e413");

enum : GUID
{
    MF_PD_ASF_FILEPROPERTIES_CREATION_TIME   = GUID("3de649b6-d76d-4e66-9ec9-78120fb4c7e3"),
    MF_PD_ASF_FILEPROPERTIES_PACKETS         = GUID("3de649b7-d76d-4e66-9ec9-78120fb4c7e3"),
    MF_PD_ASF_FILEPROPERTIES_PLAY_DURATION   = GUID("3de649b8-d76d-4e66-9ec9-78120fb4c7e3"),
    MF_PD_ASF_FILEPROPERTIES_SEND_DURATION   = GUID("3de649b9-d76d-4e66-9ec9-78120fb4c7e3"),
    MF_PD_ASF_FILEPROPERTIES_PREROLL         = GUID("3de649ba-d76d-4e66-9ec9-78120fb4c7e3"),
    MF_PD_ASF_FILEPROPERTIES_FLAGS           = GUID("3de649bb-d76d-4e66-9ec9-78120fb4c7e3"),
    MF_PD_ASF_FILEPROPERTIES_MIN_PACKET_SIZE = GUID("3de649bc-d76d-4e66-9ec9-78120fb4c7e3"),
    MF_PD_ASF_FILEPROPERTIES_MAX_PACKET_SIZE = GUID("3de649bd-d76d-4e66-9ec9-78120fb4c7e3"),
    MF_PD_ASF_FILEPROPERTIES_MAX_BITRATE     = GUID("3de649be-d76d-4e66-9ec9-78120fb4c7e3"),
}

enum : GUID
{
    MF_PD_ASF_CONTENTENCRYPTION_TYPE              = GUID("8520fe3d-277e-46ea-99e4-e30a86db12be"),
    MF_PD_ASF_CONTENTENCRYPTION_KEYID             = GUID("8520fe3e-277e-46ea-99e4-e30a86db12be"),
    MF_PD_ASF_CONTENTENCRYPTION_SECRET_DATA       = GUID("8520fe3f-277e-46ea-99e4-e30a86db12be"),
    MF_PD_ASF_CONTENTENCRYPTION_LICENSE_URL       = GUID("8520fe40-277e-46ea-99e4-e30a86db12be"),
    MF_PD_ASF_CONTENTENCRYPTIONEX_ENCRYPTION_DATA = GUID("62508be5-ecdf-4924-a359-72bab3397b9d"),
}

enum GUID MF_PD_ASF_LANGLIST_LEGACYORDER = GUID("f23de43d-9977-460d-a6ec-32937f160f7d");

enum : GUID
{
    MF_PD_ASF_SCRIPT                      = GUID("e29cd0d7-d602-4923-a7fe-73fd97ecc650"),
    MF_PD_ASF_CODECLIST                   = GUID("e4bb3509-c18d-4df1-bb99-7a36b3cc4119"),
    MF_PD_ASF_METADATA_IS_VBR             = GUID("5fc6947a-ef60-445d-b449-442ecc78b4c1"),
    MF_PD_ASF_METADATA_V8_VBRPEAK         = GUID("5fc6947b-ef60-445d-b449-442ecc78b4c1"),
    MF_PD_ASF_METADATA_V8_BUFFERAVERAGE   = GUID("5fc6947c-ef60-445d-b449-442ecc78b4c1"),
    MF_PD_ASF_METADATA_LEAKY_BUCKET_PAIRS = GUID("5fc6947d-ef60-445d-b449-442ecc78b4c1"),
}

enum GUID MF_PD_ASF_DATA_LENGTH = GUID("e7d5b3e8-1f29-45d3-8822-3e78fae272ed");

enum : GUID
{
    MF_SD_ASF_EXTSTRMPROP_AVG_DATA_BITRATE = GUID("48f8a523-305d-422d-8524-2502dda33680"),
    MF_SD_ASF_EXTSTRMPROP_AVG_BUFFERSIZE   = GUID("48f8a524-305d-422d-8524-2502dda33680"),
    MF_SD_ASF_EXTSTRMPROP_MAX_DATA_BITRATE = GUID("48f8a525-305d-422d-8524-2502dda33680"),
    MF_SD_ASF_EXTSTRMPROP_MAX_BUFFERSIZE   = GUID("48f8a526-305d-422d-8524-2502dda33680"),
}

enum GUID MF_SD_ASF_METADATA_DEVICE_CONFORMANCE_TEMPLATE = GUID("245e929d-c44e-4f7e-bb3c-77d4dfd27f8a");

enum : GUID
{
    MF_PD_ASF_INFO_HAS_VIDEO           = GUID("80e62296-2296-4a44-b31c-d103c6fed23c"),
    MF_PD_ASF_INFO_HAS_NON_AUDIO_VIDEO = GUID("80e62297-2296-4a44-b31c-d103c6fed23c"),
}

enum GUID MF_ASFPROFILE_MAXPACKETSIZE = GUID("22587627-47de-4168-87f5-b5aa9b12a8f0");
enum GUID MF_ASFSTREAMCONFIG_LEAKYBUCKET2 = GUID("c69b5902-ea1a-4c9b-b692-e2a0d29a8add");

enum : GUID
{
    MFASFSampleExtension_OutputCleanPoint    = GUID("f72a3c6f-6eb4-4ebc-b192-09ad9759e828"),
    MFASFSampleExtension_SMPTE               = GUID("399595ec-8667-4e2d-8fdb-98814ce76c1e"),
    MFASFSampleExtension_FileName            = GUID("e165ec0e-19ed-45d7-b4a7-25cbd1e28e9b"),
    MFASFSampleExtension_ContentType         = GUID("d590dc20-07bc-436c-9cf7-f3bbfbf1a4dc"),
    MFASFSampleExtension_PixelAspectRatio    = GUID("1b1ee554-f9ea-4bc8-821a-376b74e4c4b8"),
    MFASFSampleExtension_Encryption_SampleID = GUID("6698b84e-0afa-4330-aeb2-1c0a98d7a44d"),
    MFASFSampleExtension_Encryption_KeyID    = GUID("76376591-795f-4da1-86ed-9d46eca109a9"),
}

enum : GUID
{
    MFASFMutexType_Bitrate      = GUID("72178c2c-e45b-11d5-bc2a-00b0d0f3f4ab"),
    MFASFMutexType_Presentation = GUID("72178c2d-e45b-11d5-bc2a-00b0d0f3f4ab"),
    MFASFMutexType_Unknown      = GUID("72178c2e-e45b-11d5-bc2a-00b0d0f3f4ab"),
}

enum GUID MFASFINDEXER_TYPE_TIMECODE = GUID("49815231-6bad-44fd-810a-3f60984ec7fd");

enum : GUID
{
    MF_CAPTURE_ENGINE_PREVIEW_STARTED = GUID("a416df21-f9d3-4a74-991b-b817298952c4"),
    MF_CAPTURE_ENGINE_PREVIEW_STOPPED = GUID("13d5143c-1edd-4e50-a2ef-350a47678060"),
    MF_CAPTURE_ENGINE_RECORD_STARTED  = GUID("ac2b027b-ddf9-48a0-89be-38ab35ef45c0"),
    MF_CAPTURE_ENGINE_RECORD_STOPPED  = GUID("55e5200a-f98f-4c0d-a9ec-9eb25ed3d773"),
    MF_CAPTURE_ENGINE_PHOTO_TAKEN     = GUID("3c50c445-7304-48eb-865d-bba19ba3af5c"),
}

enum : GUID
{
    MF_CAPTURE_ENGINE_ERROR               = GUID("46b89fc6-33cc-4399-9dad-784de77d587c"),
    MF_CAPTURE_ENGINE_EFFECT_ADDED        = GUID("aa8dc7b5-a048-4e13-8ebe-f23c46c830c1"),
    MF_CAPTURE_ENGINE_EFFECT_REMOVED      = GUID("c6e8db07-fb09-4a48-89c6-bf92a04222c9"),
    MF_CAPTURE_ENGINE_ALL_EFFECTS_REMOVED = GUID("fded7521-8ed8-431a-a96b-f3e2565e981c"),
}

enum : GUID
{
    MF_CAPTURE_ENGINE_OUTPUT_MEDIA_TYPE_SET                     = GUID("caaad994-83ec-45e9-a30a-1f20aadb9831"),
    MF_CAPTURE_ENGINE_CAMERA_STREAM_BLOCKED                     = GUID("a4209417-8d39-46f3-b759-5912528f4207"),
    MF_CAPTURE_ENGINE_CAMERA_STREAM_UNBLOCKED                   = GUID("9be9eef0-cdaf-4717-8564-834aae66415c"),
    MF_CAPTURE_ENGINE_D3D_MANAGER                               = GUID("76e25e7b-d595-4283-962c-c594afd78ddf"),
    MF_CAPTURE_ENGINE_RECORD_SINK_VIDEO_MAX_UNPROCESSED_SAMPLES = GUID("b467f705-7913-4894-9d42-a215fea23da9"),
    MF_CAPTURE_ENGINE_RECORD_SINK_AUDIO_MAX_UNPROCESSED_SAMPLES = GUID("1cddb141-a7f4-4d58-9896-4d15a53c4efe"),
    MF_CAPTURE_ENGINE_RECORD_SINK_VIDEO_MAX_PROCESSED_SAMPLES   = GUID("e7b4a49e-382c-4aef-a946-aed5490b7111"),
    MF_CAPTURE_ENGINE_RECORD_SINK_AUDIO_MAX_PROCESSED_SAMPLES   = GUID("9896e12a-f707-4500-b6bd-db8eb810b50f"),
}

enum : GUID
{
    MF_CAPTURE_ENGINE_USE_VIDEO_DEVICE_ONLY                   = GUID("7e025171-cf32-4f2e-8f19-410577b73a66"),
    MF_CAPTURE_ENGINE_DISABLE_HARDWARE_TRANSFORMS             = GUID("b7c42a6b-3207-4495-b4e7-81f9c35d5991"),
    MF_CAPTURE_ENGINE_DISABLE_DXVA                            = GUID("f9818862-179d-433f-a32f-74cbcf74466d"),
    MF_CAPTURE_ENGINE_MEDIASOURCE_CONFIG                      = GUID("bc6989d2-0fc1-46e1-a74f-efd36bc788de"),
    MF_CAPTURE_ENGINE_DECODER_MFT_FIELDOFUSE_UNLOCK_Attribute = GUID("2b8ad2e8-7acb-4321-a606-325c4249f4fc"),
}

enum GUID MF_CAPTURE_ENGINE_ENABLE_CAMERA_STREAMSTATE_NOTIFICATION = GUID("4c808e9d-aaed-4713-90fb-cb24064ab8da");

enum : GUID
{
    MF_CAPTURE_ENGINE_AUDIO_PROCESSING            = GUID("10f1be5e-7e11-410b-973d-f4b6109000fe"),
    MF_CAPTURE_ENGINE_EVENT_GENERATOR_GUID        = GUID("abfa8ad5-fc6d-4911-87e0-961945f8f7ce"),
    MF_CAPTURE_ENGINE_EVENT_STREAM_INDEX          = GUID("82697f44-b1cf-42eb-9753-f86d649c8865"),
    MF_CAPTURE_ENGINE_SELECTEDCAMERAPROFILE       = GUID("03160b7e-1c6f-4db2-ad56-a7c430f82392"),
    MF_CAPTURE_ENGINE_SELECTEDCAMERAPROFILE_INDEX = GUID("3ce88613-2214-46c3-b417-82f8a313c9c3"),
}

enum GUID CLSID_MFCaptureEngineClassFactory = GUID("efce38d3-8914-4674-a7df-ae1b3d654b8a");

enum : GUID
{
    MF_MSE_CALLBACK            = GUID("9063a7c0-42c5-4ffd-a8a8-6fcf9ea3d00c"),
    MF_MSE_ACTIVELIST_CALLBACK = GUID("949bda0f-4549-46d5-ad7f-b846e1ab1652"),
}

enum GUID MF_MSE_VP9_SUPPORT = GUID("92d78429-d88b-4ff0-8322-803efa6e9626");

enum : GUID
{
    MF_MEDIA_ENGINE_NEEDKEY_CALLBACK           = GUID("7ea80843-b6e4-432c-8ea4-7848ffe4220e"),
    MF_MEDIA_ENGINE_CALLBACK                   = GUID("c60381b8-83a4-41f8-a3d0-de05076849a9"),
    MF_MEDIA_ENGINE_DXGI_MANAGER               = GUID("065702da-1094-486d-8617-ee7cc4ee4648"),
    MF_MEDIA_ENGINE_EXTENSION                  = GUID("3109fd46-060d-4b62-8dcf-faff811318d2"),
    MF_MEDIA_ENGINE_PLAYBACK_HWND              = GUID("d988879b-67c9-4d92-baa7-6eadd446039d"),
    MF_MEDIA_ENGINE_OPM_HWND                   = GUID("a0be8ee7-0572-4f2c-a801-2a151bd3e726"),
    MF_MEDIA_ENGINE_PLAYBACK_VISUAL            = GUID("6debd26f-6ab9-4d7e-b0ee-c61a73ffad15"),
    MF_MEDIA_ENGINE_COREWINDOW                 = GUID("fccae4dc-0b7f-41c2-9f96-4659948acddc"),
    MF_MEDIA_ENGINE_VIDEO_OUTPUT_FORMAT        = GUID("5066893c-8cf9-42bc-8b8a-472212e52726"),
    MF_MEDIA_ENGINE_CONTENT_PROTECTION_FLAGS   = GUID("e0350223-5aaf-4d76-a7c3-06de70894db4"),
    MF_MEDIA_ENGINE_CONTENT_PROTECTION_MANAGER = GUID("fdd6dfaa-bd85-4af3-9e0f-a01d539d876a"),
}

enum : GUID
{
    MF_MEDIA_ENGINE_AUDIO_CATEGORY                = GUID("c8d4c51d-350e-41f2-ba46-faebbb0857f6"),
    MF_MEDIA_ENGINE_STREAM_CONTAINS_ALPHA_CHANNEL = GUID("5cbfaf44-d2b2-4cfb-80a7-d429c74c789d"),
}

enum : GUID
{
    MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE9     = GUID("052c2d39-40c0-4188-ab86-f828273b7522"),
    MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE10    = GUID("11a47afd-6589-4124-b312-6158ec517fc3"),
    MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE11    = GUID("1cf1315f-ce3f-4035-9391-16142f775189"),
    MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE_EDGE = GUID("a6f3e465-3aca-442c-a3f0-ad6ddad839ae"),
}

enum : GUID
{
    MF_MEDIA_ENGINE_COMPATIBILITY_MODE_WWA_EDGE = GUID("15b29098-9f01-4e4d-b65a-c06c6c89da2a"),
    MF_MEDIA_ENGINE_COMPATIBILITY_MODE_WIN10    = GUID("5b25e089-6ca7-4139-a2cb-fcaab39552a3"),
}

enum : GUID
{
    MF_MEDIA_ENGINE_TRACK_ID                 = GUID("65bea312-4043-4815-8eab-44dce2ef8f2a"),
    MF_MEDIA_ENGINE_TELEMETRY_APPLICATION_ID = GUID("1e7b273b-a7e4-402a-8f51-c48e88a2cabc"),
}

enum GUID MF_MEDIA_ENGINE_MEDIA_PLAYER_MODE = GUID("3ddd8d45-5aa1-4112-82e5-36f6a2197e6e");

enum : GUID
{
    MF_MEDIA_ENGINE_TIMEDTEXT               = GUID("805ea411-92e0-4e59-9b6e-5c7d7915e64f"),
    MF_MEDIA_ENGINE_CONTINUE_ON_CODEC_ERROR = GUID("dbcdb7f9-48e4-4295-b70d-d518234eeb38"),
    MF_MEDIA_ENGINE_EME_CALLBACK            = GUID("494553a7-a481-4cb7-bec5-380903513731"),
}

enum : GUID
{
    MF_MP2DLNA_USE_MMCSS      = GUID("54f3e2ee-a2a2-497d-9834-973afde521eb"),
    MF_MP2DLNA_VIDEO_BIT_RATE = GUID("e88548de-73b4-42d7-9c75-adfa0a2a6e4c"),
    MF_MP2DLNA_AUDIO_BIT_RATE = GUID("2d1c070e-2b5f-4ab3-a7e6-8d943ba8d00a"),
    MF_MP2DLNA_ENCODE_QUALITY = GUID("b52379d7-1d46-4fb6-a317-a4a5f60959f8"),
    MF_MP2DLNA_STATISTICS     = GUID("75e488a3-d5ad-4898-85e0-bcce24a722d7"),
}

enum GUID CLSID_MFSourceReader = GUID("1777133c-0881-411b-a577-ad545f0714c4");

enum : GUID
{
    MF_SOURCE_READER_D3D_MANAGER                 = GUID("ec822da2-e1e9-4b29-a0d8-563c719f5269"),
    MF_SOURCE_READER_DISABLE_DXVA                = GUID("aa456cfd-3943-4a1e-a77d-1838c0ea2e35"),
    MF_SOURCE_READER_MEDIASOURCE_CONFIG          = GUID("9085abeb-0354-48f9-abb5-200df838c68e"),
    MF_SOURCE_READER_MEDIASOURCE_CHARACTERISTICS = GUID("6d23f5c8-c5d7-4a9b-9971-5d11f8bca880"),
}

enum GUID MF_SOURCE_READER_ENABLE_ADVANCED_VIDEO_PROCESSING = GUID("0f81da2c-b537-4672-a8b2-a681b17307a3");
enum GUID MF_SOURCE_READER_DISCONNECT_MEDIASOURCE_ON_SHUTDOWN = GUID("56b67165-219e-456d-a22e-2d3004c7fe56");
enum GUID MF_SOURCE_READER_D3D11_BIND_FLAGS = GUID("33f3197b-f73a-4e14-8d85-0e4c4368788d");

enum : GUID
{
    MF_SINK_WRITER_ASYNC_CALLBACK     = GUID("48cb183e-7b0b-46f4-822e-5e1d2dda4354"),
    MF_SINK_WRITER_DISABLE_THROTTLING = GUID("08b845d8-2b74-4afe-9d53-be16d2d5ae4f"),
    MF_SINK_WRITER_D3D_MANAGER        = GUID("ec822da2-e1e9-4b29-a0d8-563c719f5269"),
    MF_SINK_WRITER_ENCODER_CONFIG     = GUID("ad91cd04-a7cc-4ac7-99b6-a57b9a4a7c70"),
}

enum GUID MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS = GUID("a634a91c-822b-41b9-a494-4de4643612b0");

enum : GUID
{
    MF_READWRITE_MMCSS_PRIORITY       = GUID("43ad19ce-f33f-4ba9-a580-e4cd12f2d144"),
    MF_READWRITE_MMCSS_CLASS_AUDIO    = GUID("430847da-0890-4b0e-938c-054332c547e1"),
    MF_READWRITE_MMCSS_PRIORITY_AUDIO = GUID("273db885-2de2-4db2-a6a7-fdb66fb40b61"),
}

enum GUID MF_MEDIASINK_AUTOFINALIZE_SUPPORTED = GUID("48c131be-135a-41cb-8290-03652509c999");
enum GUID MF_READWRITE_ENABLE_AUTOFINALIZE = GUID("dd7ca129-8cd1-4dc5-9dde-ce168675de61");

enum : GUID
{
    MF_MEDIA_SHARING_ENGINE_DEVICE_NAME = GUID("771e05d1-862f-4299-95ac-ae81fd14f3e7"),
    MF_MEDIA_SHARING_ENGINE_DEVICE      = GUID("b461c58a-7a08-4b98-99a8-70fd5f3badfd"),
}

enum GUID CLSID_MFImageSharingEngineClassFactory = GUID("b22c3339-87f3-4059-a0c5-037aa9707eaf");
enum GUID GUID_PlayToService = GUID("f6a8ff9d-9e14-41c9-bf0f-120a2b3ce120");
enum GUID MF_CONTENTDECRYPTIONMODULE_SERVICE = GUID("15320c45-ff80-484a-9dcb-0df894e69a01");

// Callbacks

///Creates an instance of a software plug-in Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.
///Params:
///    pD3DDevice = A pointer to the <b>IDirect3DDevice9Ex</b> interface of the Direct3D device.
///    phDevice = Receives a handle to the plug-in DXVA-HD device.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_CreateDevice = HRESULT function(IDirect3DDevice9Ex pD3DDevice, HANDLE* phDevice);
///Gets a private surface format from a software plug-in Microsoft DirectX Video Acceleration High Definition (DXVA-HD)
///device.
///Params:
///    hDevice = A handle to the plug-in DXVA-HD device.
///    pFormat = A pointer to a <b>D3DFORMAT</b> value. On input, specifies the surface format that is requested by the
///              application. On output, specifies the private surface format that the plug-in device proposes.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_ProposeVideoPrivateFormat = HRESULT function(HANDLE hDevice, D3DFORMAT* pFormat);
///Gets the capabilities of a software plug-in Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.
///Params:
///    hDevice = A handle to the plug-in DXVA-HD device.
///    pContentDesc = A pointer to a DXVAHD_CONTENT_DESC structure that describes the video content.
///    Usage = A member of the DXVAHD_DEVICE_USAGE enumeration, describing how the device will be used. The value indicates the
///            desired trade-off between speed and video quality.
///    pCaps = A pointer to a DXVAHD_VPDEVCAPS structure that receives the device capabilities.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_GetVideoProcessorDeviceCaps = HRESULT function(HANDLE hDevice, 
                                                               const(DXVAHD_CONTENT_DESC)* pContentDesc, 
                                                               DXVAHD_DEVICE_USAGE Usage, DXVAHD_VPDEVCAPS* pCaps);
///Gets the output formats that are supported by a software plug-in Microsoft DirectX Video Acceleration High Definition
///(DXVA-HD) device.
///Params:
///    hDevice = A handle to the plug-in DXVA-HD device.
///    pContentDesc = A pointer to a DXVAHD_CONTENT_DESC structure that describes the video content.
///    Usage = A member of the DXVAHD_DEVICE_USAGE enumeration, describing how the device will be used.
///    Count = The number of formats to retrieve.
///    pFormats = A pointer to an array of <b>D3DFORMAT</b> values. The <i>Count</i> parameter specifies the number of elements in
///               the array. The function fills the array with a list of output formats.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_GetVideoProcessorOutputFormats = HRESULT function(HANDLE hDevice, 
                                                                  const(DXVAHD_CONTENT_DESC)* pContentDesc, 
                                                                  DXVAHD_DEVICE_USAGE Usage, uint Count, 
                                                                  D3DFORMAT* pFormats);
///Gets the input formats that are supported by a software plug-in Microsoft DirectX Video Acceleration High Definition
///(DXVA-HD) device.
///Params:
///    hDevice = A handle to the plug-in DXVA-HD device.
///    pContentDesc = A pointer to a DXVAHD_CONTENT_DESC structure that describes the video content.
///    Usage = A member of the DXVAHD_DEVICE_USAGE enumeration, describing how the device will be used.
///    Count = The number of formats to retrieve.
///    pFormats = A pointer to an array of <b>D3DFORMAT</b> values. The <i>Count</i> parameter specifies the number of elements in
///               the array. The method fills the array with a list of input formats.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_GetVideoProcessorInputFormats = HRESULT function(HANDLE hDevice, 
                                                                 const(DXVAHD_CONTENT_DESC)* pContentDesc, 
                                                                 DXVAHD_DEVICE_USAGE Usage, uint Count, 
                                                                 D3DFORMAT* pFormats);
///Gets the capabilities of one or more software Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video
///processors.
///Params:
///    hDevice = A handle to the plug-in DXVA-HD device.
///    pContentDesc = A pointer to a DXVAHD_CONTENT_DESC structure that describes the video content.
///    Usage = A member of the DXVAHD_DEVICE_USAGE enumeration, describing how the video processor will be used.
///    Count = The number of elements in the <i>pCaps</i> array.
///    pCaps = A pointer to an array of DXVAHD_VPCAPS structures. The function fills the structures with the capabilities of the
///            plug-in video processors.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_GetVideoProcessorCaps = HRESULT function(HANDLE hDevice, const(DXVAHD_CONTENT_DESC)* pContentDesc, 
                                                         DXVAHD_DEVICE_USAGE Usage, uint Count, DXVAHD_VPCAPS* pCaps);
///Gets the custom rates that a software Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video processor
///supports.
///Params:
///    hDevice = A handle to the plug-in DXVA-HD device.
///    pVPGuid = A GUID that identifies the video processor to query.
///    Count = The number of rates to retrieve.
///    pRates = A pointer to an array of DXVAHD_CUSTOM_RATE_DATA structures. The <i>Count</i> parameter specifies the number of
///             elements in the array. The function fills the array with a list of custom rates.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_GetVideoProcessorCustomRates = HRESULT function(HANDLE hDevice, const(GUID)* pVPGuid, uint Count, 
                                                                DXVAHD_CUSTOM_RATE_DATA* pRates);
///Gets the supported range of image filter values from a software plug-in Microsoft DirectX Video Acceleration High
///Definition (DXVA-HD) device.
///Params:
///    hDevice = A handle to the plug-in DXVA-HD device.
///    Filter = The type of image filter, specified as a member of the DXVAHD_FILTER enumeration.
///    pRange = A pointer to a DXVAHD_FILTER_RANGE_DATA structure. The function fills the structure with the range of values for
///             the specified filter.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_GetVideoProcessorFilterRange = HRESULT function(HANDLE hDevice, DXVAHD_FILTER Filter, 
                                                                DXVAHD_FILTER_RANGE_DATA* pRange);
///Destroys an instance of a software plug-in Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.
///Params:
///    hDevice = A handle to the plug-in DXVA-HD device.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_DestroyDevice = HRESULT function(HANDLE hDevice);
///Creates a software Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video processor plug-in.
///Params:
///    hDevice = A handle to the plug-in DXVA-HD device that creates the video processor.
///    pVPGuid = A GUID that identifies the video processor to create.
///    phVideoProcessor = Receives a handle to the software video processor.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_CreateVideoProcessor = HRESULT function(HANDLE hDevice, const(GUID)* pVPGuid, 
                                                        HANDLE* phVideoProcessor);
///Sets a state parameter for blit operations by a software Microsoft DirectX Video Acceleration High Definition
///(DXVA-HD) video processor.
///Params:
///    hVideoProcessor = A handle to the software DXVA-HD video processor.
///    State = The state parameter to set, specified as a member of the DXVAHD_BLT_STATE enumeration.
///    DataSize = The size of the buffer pointed to by <i>pData</i>, in bytes.
///    pData = A pointer to a buffer that contains the state data.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_SetVideoProcessBltState = HRESULT function(HANDLE hVideoProcessor, DXVAHD_BLT_STATE State, 
                                                           uint DataSize, const(void)* pData);
///Gets a private blit state from a software Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video
///processor.
///Params:
///    hVideoProcessor = A handle to the software DXVA-HD video processor.
///    pData = A pointer to a DXVAHD_BLT_STATE_PRIVATE_DATA structure. On input, the <b>Guid</b> member specifies the private
///            state to query. On output, the structure contains the state information.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_GetVideoProcessBltStatePrivate = HRESULT function(HANDLE hVideoProcessor, 
                                                                  DXVAHD_BLT_STATE_PRIVATE_DATA* pData);
///Sets a state parameter for an input stream on a software Microsoft DirectX Video Acceleration High Definition
///(DXVA-HD) video processor.
///Params:
///    hVideoProcessor = A handle to the software DXVA-HD video processor.
///    StreamNumber = The zero-based index of the input stream.
///    State = The state parameter to set, specified as a member of the DXVAHD_STREAM_STATE enumeration.
///    DataSize = The size of the buffer pointed to by <i>pData</i>, in bytes.
///    pData = A pointer to a buffer that contains the state data.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_SetVideoProcessStreamState = HRESULT function(HANDLE hVideoProcessor, uint StreamNumber, 
                                                              DXVAHD_STREAM_STATE State, uint DataSize, 
                                                              const(void)* pData);
///Gets a private stream state from a software Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video
///processor.
///Params:
///    hVideoProcessor = A handle to the software DXVA-HD video processor.
///    StreamNumber = The zero-based index of the input stream.
///    pData = A pointer to a DXVAHD_STREAM_STATE_PRIVATE_DATA structure. On input, the <b>Guid</b> member specifies the private
///            state to query. On output, the structure contains the state information.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_GetVideoProcessStreamStatePrivate = HRESULT function(HANDLE hVideoProcessor, uint StreamNumber, 
                                                                     DXVAHD_STREAM_STATE_PRIVATE_DATA* pData);
///Performs a video processing blit.
///Params:
///    hVideoProcessor = A handle to the software DXVA-HD video processor.
///    pOutputSurface = A pointer to the <b>IDirect3DSurface9</b> interface of a Direct3D surface that receives the blit.
///    OutputFrame = The frame number of the output video frame, indexed from zero.
///    StreamCount = The number of input streams to process.
///    pStreams = A pointer to an array of DXVAHD_STREAM_DATA structures that contain information about the input streams. The
///               number of elements in the array is given in the <i>StreamCount</i> parameter.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_VideoProcessBltHD = HRESULT function(HANDLE hVideoProcessor, IDirect3DSurface9 pOutputSurface, 
                                                     uint OutputFrame, uint StreamCount, 
                                                     const(DXVAHD_STREAM_DATA)* pStreams);
///Destroys a sofware Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video processor.
///Params:
///    hVideoProcessor = A handle to the software DXVA-HD video processor.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_DestroyVideoProcessor = HRESULT function(HANDLE hVideoProcessor);
///Pointer to a function that initializes a software plug-in device for Microsoft DirectX Video Acceleration High
///Definition (DXVA-HD).
///Params:
///    Size = The size of the structure pointed to by the <i>pCallbacks</i> parameter, in bytes.
///    pCallbacks = A pointer to an uninitialized DXVAHDSW_CALLBACKS structure. The function fills this structure with pointers to
///                 the plug-in device's callback functions.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
alias PDXVAHDSW_Plugin = HRESULT function(uint Size, void* pCallbacks);
alias PDXVAHD_CreateDevice = HRESULT function(IDirect3DDevice9Ex pD3DDevice, 
                                              const(DXVAHD_CONTENT_DESC)* pContentDesc, DXVAHD_DEVICE_USAGE Usage, 
                                              PDXVAHDSW_Plugin pPlugin, IDXVAHD_Device* ppDevice);
///Callback function for the MFAddPeriodicCallback function.
///Params:
///    pContext = Pointer to the <b>IUnknown</b> interface, or <b>NULL</b>. This pointer is specified by the caller in the
///               MFAddPeriodicCallback function.
alias MFPERIODICCALLBACK = void function(IUnknown pContext);

// Structs


///Specifies hardware overlay capabilities for a Direct3D device.
struct D3DOVERLAYCAPS
{
    ///Contains a bitwise <b>OR</b> of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="D3DOVERLAYCAPS_FULLRANGERGB"></a><a id="d3doverlaycaps_fullrangergb"></a><dl>
    ///<dt><b>D3DOVERLAYCAPS_FULLRANGERGB</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The overlay supports
    ///RGB with a nominal range of 0â€“255 per channel. </td> </tr> <tr> <td width="40%"><a
    ///id="D3DOVERLAYCAPS_LIMITEDRANGERGB"></a><a id="d3doverlaycaps_limitedrangergb"></a><dl>
    ///<dt><b>D3DOVERLAYCAPS_LIMITEDRANGERGB</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The overlay
    ///supports RGB with a nominal range of 16â€“235 per channel. Reference black is (16,16,16) and reference white is
    ///(235,235,235). </td> </tr> <tr> <td width="40%"><a id="D3DOVERLAYCAPS_YCbCr_BT601"></a><a
    ///id="d3doverlaycaps_ycbcr_bt601"></a><a id="D3DOVERLAYCAPS_YCBCR_BT601"></a><dl>
    ///<dt><b>D3DOVERLAYCAPS_YCbCr_BT601</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The overlay supports
    ///the BT.601 definition of YUV. </td> </tr> <tr> <td width="40%"><a id="D3DOVERLAYCAPS_YCbCr_BT709"></a><a
    ///id="d3doverlaycaps_ycbcr_bt709"></a><a id="D3DOVERLAYCAPS_YCBCR_BT709"></a><dl>
    ///<dt><b>D3DOVERLAYCAPS_YCbCr_BT709</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> The overlay supports
    ///the BT.709 definition of YUV. </td> </tr> <tr> <td width="40%"><a id="D3DOVERLAYCAPS_YCbCr_BT601_xvYCC"></a><a
    ///id="d3doverlaycaps_ycbcr_bt601_xvycc"></a><a id="D3DOVERLAYCAPS_YCBCR_BT601_XVYCC"></a><dl>
    ///<dt><b>D3DOVERLAYCAPS_YCbCr_BT601_xvYCC</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> The overlay
    ///supports extended YCbCr (xvYCC) for BT.601 YUV. </td> </tr> <tr> <td width="40%"><a
    ///id="D3DOVERLAYCAPS_YCbCr_BT709_xvYCC"></a><a id="d3doverlaycaps_ycbcr_bt709_xvycc"></a><a
    ///id="D3DOVERLAYCAPS_YCBCR_BT709_XVYCC"></a><dl> <dt><b>D3DOVERLAYCAPS_YCbCr_BT709_xvYCC</b></dt>
    ///<dt>0x00000020</dt> </dl> </td> <td width="60%"> The overlay supports extended YCbCr (xvYCC) for BT.709 YUV.
    ///</td> </tr> <tr> <td width="40%"><a id="D3DOVERLAYCAPS_STRETCHX"></a><a id="d3doverlaycaps_stretchx"></a><dl>
    ///<dt><b>D3DOVERLAYCAPS_STRETCHX</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> The device can stretch
    ///and shrink the overlay data arbitrarily in the horizontal direction. </td> </tr> <tr> <td width="40%"><a
    ///id="D3DOVERLAYCAPS_STRETCHY"></a><a id="d3doverlaycaps_stretchy"></a><dl> <dt><b>D3DOVERLAYCAPS_STRETCHY</b></dt>
    ///<dt>0x00000080</dt> </dl> </td> <td width="60%"> The device can stretch and shrink the overlay data arbitrarily
    ///in the vertical direction. </td> </tr> </table>
    uint Caps;
    ///The maximum overlay width after stretching.
    uint MaxOverlayDisplayWidth;
    ///The maximum overlay height after stretching.
    uint MaxOverlayDisplayHeight;
}

///Describes the content protection capabilities of a display driver. To get the capabilities, call
///IDirect3DDevice9Video::GetContentProtectionCaps.
struct D3DCONTENTPROTECTIONCAPS
{
align (4):
    ///Bitwise <b>OR</b> of zero or more flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="D3DCPCAPS_SOFTWARE"></a><a id="d3dcpcaps_software"></a><dl> <dt><b>D3DCPCAPS_SOFTWARE</b></dt>
    ///<dt>0x00000001</dt> </dl> </td> <td width="60%"> The encryption is implemented in software by the driver. </td>
    ///</tr> <tr> <td width="40%"><a id="D3DCPCAPS_HARDWARE"></a><a id="d3dcpcaps_hardware"></a><dl>
    ///<dt><b>D3DCPCAPS_HARDWARE</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The encryption is implemented
    ///in hardware by the GPU. </td> </tr> <tr> <td width="40%"><a id="D3DCPCAPS_PROTECTIONALWAYSON"></a><a
    ///id="d3dcpcaps_protectionalwayson"></a><dl> <dt><b>D3DCPCAPS_PROTECTIONALWAYSON</b></dt> <dt>0x00000004</dt> </dl>
    ///</td> <td width="60%"> Content protection is always applied to a protected Direct3D surface, regardless of
    ///whether the application explicitly enables content protection. </td> </tr> <tr> <td width="40%"><a
    ///id="D3DCPCAPS_PARTIALDECRYPTION"></a><a id="d3dcpcaps_partialdecryption"></a><dl>
    ///<dt><b>D3DCPCAPS_PARTIALDECRYPTION</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> The driver can use
    ///partially encrypted buffers. If this capability is not present, the entire buffer must be either encrypted or
    ///clear. </td> </tr> <tr> <td width="40%"><a id="D3DCPCAPS_CONTENTKEY"></a><a id="d3dcpcaps_contentkey"></a><dl>
    ///<dt><b>D3DCPCAPS_CONTENTKEY</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> The driver can encrypt data
    ///using a separate content key that is encrypted using the session key. For more information, see
    ///IDirect3DCryptoSession9::DecryptionBlt. </td> </tr> <tr> <td width="40%"><a
    ///id="D3DCPCAPS_FRESHENSESSIONKEY"></a><a id="d3dcpcaps_freshensessionkey"></a><dl>
    ///<dt><b>D3DCPCAPS_FRESHENSESSIONKEY</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> The driver can
    ///refresh the session key without renegotiating the key. To refresh the session key, call
    ///IDirect3DCryptoSession9::StartSessionKeyRefresh. </td> </tr> <tr> <td width="40%"><a
    ///id="D3DCPCAPS_ENCRYPTEDREADBACK"></a><a id="d3dcpcaps_encryptedreadback"></a><dl>
    ///<dt><b>D3DCPCAPS_ENCRYPTEDREADBACK</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> The driver can read
    ///back encrypted data from a protected surface, using the IDirect3DCryptoSession9::EncryptionBlt method. </td>
    ///</tr> <tr> <td width="40%"><a id="D3DCPCAPS_ENCRYPTEDREADBACKKEY"></a><a
    ///id="d3dcpcaps_encryptedreadbackkey"></a><dl> <dt><b>D3DCPCAPS_ENCRYPTEDREADBACKKEY</b></dt> <dt>0x00000080</dt>
    ///</dl> </td> <td width="60%"> The driver requires a separate key to read encrypted data from a protected surface.
    ///To get this second key, call IDirect3DCryptoSession9::GetEncryptionBltKey. </td> </tr> <tr> <td width="40%"><a
    ///id="D3DCPCAPS_SEQUENTIAL_CTR_IV"></a><a id="d3dcpcaps_sequential_ctr_iv"></a><dl>
    ///<dt><b>D3DCPCAPS_SEQUENTIAL_CTR_IV</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> If the encryption
    ///type is <b>D3DCRYPTOTYPE_AES128_CTR</b>, the application must use a sequential count in the DXVA2_AES_CTR_IV
    ///structure. For more information, see the remarks for <b>DXVA2_AES_CTR_IV</b>. </td> </tr> </table>
    uint  Caps;
    ///Specifies the type of key exchange required to negotiate the session key. The following GUIDs are defined.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="D3DKEYEXCHANGE_RSAES_OAEP"></a><a
    ///id="d3dkeyexchange_rsaes_oaep"></a><dl> <dt><b>D3DKEYEXCHANGE_RSAES_OAEP</b></dt> </dl> </td> <td width="60%">
    ///The decoder encrypts the session key using RSA Encryption Scheme - Optimal Asymmetric Encryption Padding
    ///(RSAES-OAEP). </td> </tr> <tr> <td width="40%"><a id="D3DKEYEXCHANGE_DXVA"></a><a
    ///id="d3dkeyexchange_dxva"></a><dl> <dt><b>D3DKEYEXCHANGE_DXVA</b></dt> </dl> </td> <td width="60%"> Use the key
    ///exchange mechanism defined for DirectX Video Acceleration 2 (DXVA-2). </td> </tr> </table>
    GUID  KeyExchangeType;
    ///The memory alignment required for buffers used by the GPU cryptographic engine. If the application uses a system
    ///memory buffer to pass encrypted content to the GPU, or to read back encrypted content from the GPU, the buffer's
    ///starting address must be a multiple of this value.
    uint  BufferAlignmentStart;
    ///The block alignment required by the GPU cryptographic engine. The size of data to be encrypted must be a multiple
    ///of this value.
    uint  BlockAlignmentSize;
    ///The total amount of memory that can be used to hold protected surfaces.
    ulong ProtectedMemorySize;
}

///Defines the combination of a pixel format and color space for a resource content description.
struct D3D12_VIDEO_FORMAT
{
    ///A value from the [DXGI_FORMAT](/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format) enumeration, specifying
    ///the DXGI format of the data.
    DXGI_FORMAT Format;
    ///A value from the [DXGI_COLOR_SPACE_TYPE](/windows/desktop/api/dxgicommon/ne-dxgicommon-dxgi_color_space_type)
    ///enumeration, specifying the color space of the data.
    DXGI_COLOR_SPACE_TYPE ColorSpace;
}

///Describes the width, height, format, and color space of a picture buffer.
struct D3D12_VIDEO_SAMPLE
{
    ///The width of the sample.
    uint               Width;
    ///The height of the sample.
    uint               Height;
    ///A [D3D12_VIDEO_FORMAT](ns-d3d12video-d3d12_video_format.md) structure describing the format and colorspace of the
    ///sample.
    D3D12_VIDEO_FORMAT Format;
}

///Describes the configuration for a video decoder.
struct D3D12_VIDEO_DECODE_CONFIGURATION
{
    ///A GUID identifying the profile for the decoder, such as D3D12\_VIDEO\_DECODE\_PROFILE\_H264 or
    ///D3D12\_VIDEO\_DECODE\_PROFILE\_HEVC\_MAIN. For a list of supported GUIDs, see [Direct3D 12 Video
    ///GUIDs](/windows/desktop/medfound/direct3d-12-video-guids).
    GUID DecodeProfile;
    ///A member of the [D3D12\_BITSTREAM\_ENCRYPTION\_TYPE](ne-d3d12video-d3d12_bitstream_encryption_type.md)
    ///enumeration specifying the type of bitstream encryption. For no encryption, use
    ///D3D12\_BITSTREAM\_ENCRYPTION\_TYPE\_NONE.
    D3D12_BITSTREAM_ENCRYPTION_TYPE BitstreamEncryption;
    ///A member of the
    ///[D3D12\_VIDEO\_FRAME\_CODED\_INTERLACE\_TYPE](ne-d3d12video-d3d12_video_frame_coded_interlace_type.md)
    ///enumeration the desired interlace type used by the coded frames.
    D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE InterlaceType;
}

///Describes a [ID3D12VideoDecoder](nn-d3d12video-id3d12videodecoder.md). Pass this structure into
///[ID3D12VideoDevice::CreateVideoDecoder](nf-d3d12video-id3d12videodevice-createvideodecoder.md) to create an instance
///of **ID3D12VideoDecoder**.
struct D3D12_VIDEO_DECODER_DESC
{
    ///The node mask specifying the physical adapter on which the video processor will be used. For single GPU
    ///operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node, i.e. the device's
    ///physical adapter, to which the command queue applies. Each bit in the mask corresponds to a single node. Only 1
    ///bit may be set.
    uint NodeMask;
    ///A [D3D12_VIDEO_DECODE_CONFIGURATION](ns-d3d12video-d3d12_video_decode_configuration.md) structure specifying the
    ///configuration of the video decoder.
    D3D12_VIDEO_DECODE_CONFIGURATION Configuration;
}

///Describes a [ID3D12VideoDecoderHeap](nn-d3d12video-id3d12videodecoderheap.md). Pass this structure into
///[ID3D12VideoDevice::CreateVideoDecoderHeap](nf-d3d12video-id3d12videodevice-createvideodecoderheap.md) to create an
///instance of **ID3D12VideoDecoderHeap**.
struct D3D12_VIDEO_DECODER_HEAP_DESC
{
    ///The node mask specifying the physical adapter on which the video processor will be used. For single GPU
    ///operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node, i.e. the device's
    ///physical adapter, to which the command queue applies. Each bit in the mask corresponds to a single node. Only 1
    ///bit may be set.
    uint          NodeMask;
    ///A [D3D12_VIDEO_DECODE_CONFIGURATION](ns-d3d12video-d3d12_video_decode_configuration.md) structure specifying the
    ///configuration of the video decoder.
    D3D12_VIDEO_DECODE_CONFIGURATION Configuration;
    ///The decode width of the bitstream to be decoded.
    uint          DecodeWidth;
    ///The decode height of the bitstream to be decoded.
    uint          DecodeHeight;
    ///A [DXGI_FORMAT](/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format) structure specifying the format of the
    ///bitstream to be decoded.
    DXGI_FORMAT   Format;
    ///The frame rate of the input video stream. For more information, see the Remarks section.
    DXGI_RATIONAL FrameRate;
    ///The average bits per second data compression rate for the compressed video stream. For more information, see the
    ///Remarks section.
    uint          BitRate;
    ///The maximum number of decode picture buffers this stream can have.
    uint          MaxDecodePictureBufferCount;
}

///Describes the range of supported sizes for a video scaler.
struct D3D12_VIDEO_SIZE_RANGE
{
    ///The largest output width to which content can be scaled. The largest value allowed is
    ///**D3D12\_REQ\_TEXTURE2D\_U\_OR\_V\_DIMENSION** (16384).
    uint MaxWidth;
    ///The largest output height to which content can be scaled. The largest value allowed is
    ///**D3D12\_REQ\_TEXTURE2D\_U\_OR\_V\_DIMENSION** (16384).
    uint MaxHeight;
    ///The smallest output width to which content can be scaled. The smallest allowed value is 1.
    uint MinWidth;
    ///The smallest output height to which content can be scaled. The smallest allowed value is 1.
    uint MinHeight;
}

///Specifies alpha blending parameters for video processing. Used by the
///[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS]ns-d3d12video-d3d12_video_process_input_stream_arguments) structure.
struct D3D12_VIDEO_PROCESS_ALPHA_BLENDING
{
    ///A boolean value specifying whether alpha blending is enabled.
    BOOL  Enable;
    ///The planar alpha value. The value can range from 0.0 (transparent) to 1.0 (opaque). If *Enable* is FALSe, this
    ///parameter is ignored.
    float Alpha;
}

///Specifies the settings used for luma keying. This value is used with the
///[D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC](ns-d3d12video-d3d12_video_process_input_stream_desc.md) structure.
struct D3D12_VIDEO_PROCESS_LUMA_KEY
{
    ///A boolean value specifying whether luma keying is enabled.
    BOOL  Enable;
    ///The lower bound for the luma key. The valid range is [0â€¦1]. If *Enable* is FALSE, this parameter is ignored.
    float Lower;
    ///The upper bound for the luma key. The valid range is [0â€¦1]. If *Enable* is FALSE, this parameter is ignored.
    float Upper;
}

///Specifies the parameters for the input stream for a video process operation.
struct D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC
{
    ///A value from the [DXGI_FORMAT](/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format) enumeration specifying
    ///the format of the input stream. In the case of stereo, this format is the format of both inputs.
    DXGI_FORMAT   Format;
    ///A value from the [DXGI_COLOR_SPACE_TYPE](/windows/desktop/api/dxgicommon/ne-dxgicommon-dxgi_color_space_type)
    ///enumeration specifying the color space of the video processor input and reference surfaces.
    DXGI_COLOR_SPACE_TYPE ColorSpace;
    ///A [DXGI_RATIONAL](/windows/desktop/api/dxgicommon/ns-dxgicommon-dxgi_rational) structure specifying the source
    ///aspect ratio.
    DXGI_RATIONAL SourceAspectRatio;
    ///A [DXGI_RATIONAL](/windows/desktop/api/dxgicommon/ns-dxgicommon-dxgi_rational) structure specifying the
    ///destination aspect ratio.
    DXGI_RATIONAL DestinationAspectRatio;
    ///A [DXGI_RATIONAL](/windows/desktop/api/dxgicommon/ns-dxgicommon-dxgi_rational) structure specifying the frame
    ///rate of the input video stream.
    DXGI_RATIONAL FrameRate;
    ///A [D3D12_VIDEO_SIZE_RANGE](ns-d3d12video-d3d12_video_size_range.md) structure representing the size of the source
    ///rectangle. This argument specifies the input range size this video processor must support for
    ///[ProcessFrames](nf-d3d12video-id3d12videoprocesscommandlist-processframes.md). If a source size exceeds the
    ///range, the video processor must be recreated.
    D3D12_VIDEO_SIZE_RANGE SourceSizeRange;
    ///A [D3D12_VIDEO_SIZE_RANGE](ns-d3d12video-d3d12_video_size_range.md) structure representing the size of the
    ///destination rectangle. This argument specifies the destination range size this video processor must support for
    ///[ProcessFrames](nf-d3d12video-id3d12videoprocesscommandlist-processframes.md). If a source size exceeds the
    ///range, the video processor must be recreated.
    D3D12_VIDEO_SIZE_RANGE DestinationSizeRange;
    ///A boolean value specifying whether the video processor should support all
    ///[D3D12_VIDEO_PROCESS_ORIENTATION](ne-d3d12video-d3d12_video_process_orientation.md) for
    ///[ProcessFrames](nf-d3d12video-id3d12videoprocesscommandlist-processframes.md).
    BOOL          EnableOrientation;
    ///A bitwise OR combination of one or more flags from the
    ///[D3D12_VIDEO_PROCESS_FILTER_FLAGS](ne-d3d12video-d3d12_video_process_filter_flags.md) enumeration specifying the
    ///filters to enable.
    D3D12_VIDEO_PROCESS_FILTER_FLAGS FilterFlags;
    ///A value from the [D3D12_VIDEO_FRAME_STEREO_FORMAT](ne-d3d12video-d3d12_video_frame_stereo_format.md) enumeration
    ///specifies whether the stream is stereo or not. A value of **D3D12_VIDEO_PROCESS_STEREO_FORMAT_SEPARATE**
    ///indicates that there will be two sets of input textures, and two sets of references for the stereo interlaced
    ///case.
    D3D12_VIDEO_FRAME_STEREO_FORMAT StereoFormat;
    ///A value from the [D3D12_VIDEO_FIELD_TYPE](ne-d3d12video-d3d12_video_field_type.md) enumeration specfying the
    ///interlaced field type of the input source. When working with mixed content, use
    ///[ID3D12VideoProcessCommandList1::ProcessFrames1](nf-d3d12video-id3d12videoprocesscommandlist1-processframes1.md)
    ///which supports changing the field type for each call.
    D3D12_VIDEO_FIELD_TYPE FieldType;
    ///A value from the [D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS](ne-d3d12video-d3d12_video_process_deinterlace_flags.md)
    ///enumeration specifying the deinterlace mode to use.
    D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS DeinterlaceMode;
    ///A boolean value specifying whether alpha blending is enabled. Alpha blending settings are provided to
    ///[ProcessFrames](nf-d3d12video-id3d12videoprocesscommandlist-processframes.md) with *AlphaBlending* the field of
    ///the [D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS](ns-d3d12video-d3d12_video_process_input_stream_arguments.md)
    ///structure.
    BOOL          EnableAlphaBlending;
    ///A [D3D12_VIDEO_PROCESS_LUMA_KEY](ns-d3d12video-d3d12_video_process_luma_key.md) structure specifying the luma key
    ///for an input stream on the video processor.
    D3D12_VIDEO_PROCESS_LUMA_KEY LumaKey;
    ///An integer specifying the number of past reference frames.
    uint          NumPastFrames;
    ///An integer specifying the number of future reference frames.
    uint          NumFutureFrames;
    ///A boolean value specifying wither automatic processing features are enabled for the video processor.
    BOOL          EnableAutoProcessing;
}

///Specifies output stream arguments for the output passed to
///[ID3D12VideoProcessCommandList::ProcessFrames](nf-d3d12video-id3d12videoprocesscommandlist-processframes.md).
struct D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC
{
    ///A [DXGI_FORMAT](/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format) structure specifying the format of the
    ///output resources.
    DXGI_FORMAT   Format;
    ///A [DXGI_COLOR_SPACE_TYPE](/windows/desktop/api/dxgicommon/ne-dxgicommon-dxgi_color_space_type) value that
    ///specifies the colorspace for the video processor output surface.
    DXGI_COLOR_SPACE_TYPE ColorSpace;
    ///A value from the [D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE](ne-d3d12video-d3d12_video_process_alpha_fill_mode.md)
    ///enumeration specifying the alpha fill mode for data that the video processor writes to the render target.
    D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE AlphaFillMode;
    ///The zero-based index of an input stream. This parameter is used if *AlphaFillMode* is
    ///[D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_SOURCE_STREAM](ne-d3d12video-d3d12_video_process_alpha_fill_mode.md).
    ///Otherwise, the parameter is ignored.
    uint          AlphaFillModeSourceStreamIndex;
    ///The video processor uses the background color to fill areas of the target rectangle that do not contain a video
    ///image. Areas outside the target rectangle are not affected. The meaning of the values are specified by the
    ///*ColorSpace* parameter. | | YCbCrA | RGBA | |-------------------|----------|---------| | BackgroundColor[0]| Y |
    ///R | | BackgroundColor[1]| Cb | G | | BackgroundColor[2]| Cr | B | | BackgroundColor[3]| A | A |
    float[4]      BackgroundColor;
    ///A [DXGI_RATIONAL](/windows/desktop/api/dxgicommon/ns-dxgicommon-dxgi_rational) structure specifying the frame
    ///rate of the output video stream.
    DXGI_RATIONAL FrameRate;
    ///If TRUE, stereo output is enabled. Otherwise, the video processor produces mono video frames.
    BOOL          EnableStereo;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12\_FEATURE\_VIDEO\_DECODE\_SUPPORT](ne-d3d12video-d3d12_feature_video.md). Retrieves support
///information for video decoding.
struct D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT
{
    ///For single GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the
    ///device's physical adapter) to which the command queue applies. Each bit in the mask corresponds to a single node.
    ///Only 1 bit may be set.
    uint          NodeIndex;
    ///A [D3D12\_VIDEO\_DECODE\_CONFIGURATION](ns-d3d12video-d3d12_video_decode_configuration.md) structure specifying
    ///the decode profile, bitstream encryption, and interlace type of the source stream.
    D3D12_VIDEO_DECODE_CONFIGURATION Configuration;
    ///The decode width of the source stream.
    uint          Width;
    ///The decode height of the source stream
    uint          Height;
    ///The [DXGI\_FORMAT](/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format) to use as the decode format. This
    ///format is the output format if no decoder conversion is specified.
    DXGI_FORMAT   DecodeFormat;
    ///The frame rate of the video format. A value of 0 means the frame rate is unknown.
    DXGI_RATIONAL FrameRate;
    ///The average bits per second data compression rate for the compressed video stream. This information is used by
    ///the driver to determine whether the video can be decoded in real-time. A value of 0 means the bit rate is
    ///unknown.
    uint          BitRate;
    ///A combination of values from the
    ///[D3D12\_VIDEO\_DECODE\_SUPPORT\_FLAGS](ne-d3d12video-d3d12_video_decode_support_flags.md) enumeration indicating
    ///the support for video decoding. This value is populated by the call to **ID3D12Device::CheckFeatureSupport**.
    D3D12_VIDEO_DECODE_SUPPORT_FLAGS SupportFlags;
    ///A combination of values from the
    ///[D3D12\_VIDEO\_DECODE\_CONFIGURATION\_FLAGS](ne-d3d12video-d3d12_video_decode_configuration_flags.md) eumeration
    ///describing the video decode configuration. This value is populated by the call to
    ///**ID3D12Device::CheckFeatureSupport**.
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS ConfigurationFlags;
    ///A member of the [D3D12\_VIDEO\_DECODE\_TIER](ne-d3d12video-d3d12_video_decode_tier.md) enumeration specifying the
    ///decoding tier of a hardware video decoder.
    D3D12_VIDEO_DECODE_TIER DecodeTier;
}

struct D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT
{
    uint NodeIndex;
    uint ProfileCount;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12\_FEATURE\_VIDEO\_DECODE\_PROFILES](ne-d3d12video-d3d12_feature_video.md). Retrieves the list of
///supported profiles.
struct D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES
{
    ///For single GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the
    ///device's physical adapter) to which the command queue applies. Each bit in the mask corresponds to a single node.
    ///Only 1 bit may be set.
    uint  NodeIndex;
    ///The number of profiles to retrieve. This number must match the value returned from a call
    ///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
    ///specified is [D3D12\_FEATURE\_VIDEO\_DECODE\_PROFILE\_COUNT](ne-d3d12video-d3d12_feature_video.md).
    uint  ProfileCount;
    ///A list of GUIDs representing the supported profiles. The calling application must allocate storage for the
    ///profile list before calling **CheckFeatureSupport**.
    GUID* pProfiles;
}

struct D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT
{
    uint NodeIndex;
    D3D12_VIDEO_DECODE_CONFIGURATION Configuration;
    uint FormatCount;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12\_FEATURE\_VIDEO\_DECODE\_FORMAT](ne-d3d12video-d3d12_feature_video.md). Retrieves the list of
///supported formats.
struct D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS
{
    ///For single GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the
    ///device's physical adapter) to which the command queue applies. Each bit in the mask corresponds to a single node.
    ///Only 1 bit may be set.
    uint         NodeIndex;
    ///A [D3D12\_VIDEO\_DECODE\_CONFIGURATION](ns-d3d12video-d3d12_video_decode_configuration.md) structure describing
    ///the decode configuration for the list of formats.
    D3D12_VIDEO_DECODE_CONFIGURATION Configuration;
    ///The number of formats to retrieve. This number must match the value returned from a call
    ///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
    ///specified is [D3D12\_FEATURE\_VIDEO\_DECODE\_FORMAT\_COUNT](ne-d3d12video-d3d12_feature_video.md).
    uint         FormatCount;
    ///A list of [DXGI_FORMAT](/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format) structures representing the
    ///supported formats.
    DXGI_FORMAT* pOutputFormats;
}

struct D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE
{
    BOOL IOCoherent;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12\_FEATURE\_VIDEO\_DECODE\_HISTOGRAM](ne-d3d12video-d3d12_feature_video.md). Retrieves the
///histogram capabilities for the specified decoder configuration.
struct D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM
{
    ///For single GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the
    ///device's physical adapter) to which the command queue applies. Each bit in the mask corresponds to a single node.
    ///Only 1 bit may be set.
    uint        NodeIndex;
    ///A GUID representing the decode profile for which histogram capabilities will be queried. Get a list of available
    ///profile GUIDs by calling
    ///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
    ///specified is [D3D12\_FEATURE\_VIDEO\_DECODE\_PROFILES](ne-d3d12video-d3d12_feature_video.md).
    GUID        DecodeProfile;
    ///The decode width of the source stream.
    uint        Width;
    ///The decode height of the source stream.
    uint        Height;
    ///The [DXGI\_FORMAT](/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format) representing the decode format.
    DXGI_FORMAT DecodeFormat;
    ///A bitwise OR combination of values from the
    ///[D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS](ne-d3d12video-d3d12_video_decode_histogram_component_flags.md)
    ///enumeration specifying the components of a DXGI_FORMAT for which histogram support will be queried.
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS Components;
    ///The number of per component bins supported. This value must be greater than or equal to 64 and must be a power of
    ///2 (e.g. 64, 128, 256, 512...).
    uint        BinCount;
    ///The bit depth of the bin counter. The counter is always stored in a 32-bit value and therefore this value must
    ///specify 32 bits or less. The counter is stored in the lower bits of the 32-bit storage. The upper bits are set to
    ///zero. If the bin count exceeds this bit depth, the value is set to the maximum counter value. Valid values for
    ///*CounterBitDepth* are 16, 24, and 32.
    uint        CounterBitDepth;
}

///Describes the supported scaling range of output sizes for a video scaler.
struct D3D12_VIDEO_SCALE_SUPPORT
{
    ///A [D3D12_VIDEO_SIZE_RANGE](ns-d3d12video-d3d12_video_size_range.md) structure describing the supported output
    ///size range for the scaler.
    D3D12_VIDEO_SIZE_RANGE OutputSizeRange;
    ///A member of the [D3D12_VIDEO_SCALE_SUPPORT_FLAGS](ne-d3d12video-d3d12_video_scale_support_flags.md) enumeration
    ///specifying the supported scaling capabilities of the scaler.
    D3D12_VIDEO_SCALE_SUPPORT_FLAGS Flags;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12\_FEATURE\_VIDEO\_DECODE\_CONVERSION\_SUPPORT](ne-d3d12video-d3d12_feature_video.md). Retrieves
///the list of supported profiles. Check if a colorspace conversion, format conversion, and scale are supported.
struct D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT
{
    ///For single GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the
    ///device's physical adapter) to which the command queue applies. Each bit in the mask corresponds to a single node.
    ///Only 1 bit may be set.
    uint               NodeIndex;
    ///A [D3D12\_VIDEO\_DECODE\_CONFIGURATION](ns-d3d12video-d3d12_video_decode_configuration.md) structure describing
    ///the decode configuration.
    D3D12_VIDEO_DECODE_CONFIGURATION Configuration;
    ///A [D3D12\_VIDEO\_SAMPLE](ns-d3d12video-d3d12_video_sample.md) structure representing the source decoded as sample
    ///description.
    D3D12_VIDEO_SAMPLE DecodeSample;
    ///A [D3D12\_VIDEO\_FORMAT](ns-d3d12video-d3d12_video_format.md) structure containing the output sample description.
    D3D12_VIDEO_FORMAT OutputFormat;
    ///The frame rate of the video content. This is used by the driver to determine whether the video can be decoded in
    ///real-time.
    DXGI_RATIONAL      FrameRate;
    ///The average bits per second data compression rate for the compressed video stream. This is used by the driver to
    ///determine whether the video can be decoded in real-time.
    uint               BitRate;
    ///A combination of values from the
    ///[D3D12\_VIDEO\_DECODE\_CONVERSION\_SUPPORT\_FLAGS](ne-d3d12video-d3d12_video_decode_conversion_support_flags.md)
    ///indicating the support for the specified conversion.
    D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS SupportFlags;
    ///A [D3D12\_VIDEO\_SCALE\_SUPPORT](ns-d3d12video-d3d12_video_scale_support.md) structure representing the output
    ///size range for decode conversion.
    D3D12_VIDEO_SCALE_SUPPORT ScaleSupport;
}

///Describes the allocation size of a video decoder heap.
struct D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE
{
    ///A [D3D12_VIDEO_DECODER_HEAP_DESC](ns-d3d12video-d3d12_video_decoder_heap_desc.md) describing a
    ///[ID3D12VideoDecoderHeap](nn-d3d12video-id3d12videodecoderheap.md).
    D3D12_VIDEO_DECODER_HEAP_DESC VideoDecoderHeapDesc;
    ///The allocation size of the video decoder heap in the L0 memory pool. L0 is the physical system memory pool. When
    ///the adapter is discrete/NUMA, this pool has greater bandwidth for the CPU and less bandwidth for the GPU. When
    ///the adapter is UMA, this pool is the only one which is valid. For more information, see
    ///[Residency](/windows/win32/direct3d12/residency).
    ulong MemoryPoolL0Size;
    ///The allocation size of the video decoder heap in the L1 memory pool. L1 is typically known as the physical video
    ///memory pool. L1 is only available when the adapter is discrete/NUMA, and has greater bandwidth for the GPU and
    ///cannot even be accessed by the CPU. When the adapter is UMA, this pool is not available. For more information,
    ///see [Residency](/windows/win32/direct3d12/residency).
    ulong MemoryPoolL1Size;
}

///Describes the allocation size of a video decoder heap.
struct D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE
{
    ///For single GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the
    ///device's physical adapter) to which the command queue applies. Each bit in the mask corresponds to a single node.
    ///Only 1 bit may be set.
    uint  NodeMask;
    ///A pointer to a D3D12\_VIDEO\_PROCESS\_OUTPUT\_STREAM\_DESC(ns-d3d12video-d3d12_video_process_output_stream_desc)
    ///structure describing the output stream.
    const(D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC)* pOutputStreamDesc;
    ///The number of input streams provided in the *pInputStreamDescs* parameter.
    uint  NumInputStreamDescs;
    ///A pointer to a list of
    ///D3D12\_VIDEO\_PROCESS\_INPUT\_STREAM\_DESC(ns-d3d12video-d3d12_video_process_input_stream_desc) structures the
    ///input streams.
    const(D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC)* pInputStreamDescs;
    ///The allocation size of the video processor in the L0 memory pool. L0 is the physical system memory pool. When the
    ///adapter is discrete/NUMA, this pool has greater bandwidth for the CPU and less bandwidth for the GPU. When the
    ///adapter is UMA, this pool is the only one which is valid. For more information, see
    ///[Residency](/windows/win32/direct3d12/residency).
    ulong MemoryPoolL0Size;
    ///The allocation size of the video processor in the L1 memory pool. L1 is typically known as the physical video
    ///memory pool. L1 is only available when the adapter is discrete/NUMA, and has greater bandwidth for the GPU and
    ///cannot even be accessed by the CPU. When the adapter is UMA, this pool is not available. For more information,
    ///see [Residency](/windows/win32/direct3d12/residency).
    ulong MemoryPoolL1Size;
}

///Represents data for a video decode statistics query invoked by calling
///[ID3D12VideoDecodeCommandList::EndQuery](nf-d3d12video-id3d12videodecodecommandlist-endquery.md).
struct D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS
{
    ///A member of the [D3D12_VIDEO_DECODE_STATUS](ne-d3d12video-d3d12_video_decode_status.md) enumeration indicating
    ///the video decoding status.
    ulong         Status;
    ///If **Status** is not 0, this member contains the accelerator's estimate of the number of super-blocks in the
    ///decoded frame that were adversely affected by the reported problem. If the accelerator does not provide an
    ///estimate, the value is **D3D12\_VIDEO\_DECODE\_MACROBLOCKS\_AFFECTED\_UNKNOWN** (0xFFFFFFFFFFFFFFFF).
    ulong         NumMacroblocksAffected;
    ///The decode frame rate.
    DXGI_RATIONAL FrameRate;
    ///When the **Status** returned is
    ///[D3D12_VIDEO_DECODE_STATUS_RATE_EXCEEDED](ne-d3d12video-d3d12_video_decode_status.md), this field reports the
    ///bitrate that would succeed. This value may be used to recreate the decoder and try again. A value of zero here is
    ///valid to indicate that the worst case bit rate should be assumed. For all other **Status** values, **BitRate** is
    ///set to zero.
    uint          BitRate;
}

///Represents the decode parameters for a frame. Parameter definitions are specified by the codec specification for each
///decode profile.
struct D3D12_VIDEO_DECODE_FRAME_ARGUMENT
{
    ///A member of the [D3D12_VIDEO_DECODE_ARGUMENT_TYPE](ne-d3d12video-d3d12_video_decode_argument_type.md) enumeration
    ///specifying the type of argument.
    D3D12_VIDEO_DECODE_ARGUMENT_TYPE Type;
    ///The size of the data in *pArgument*, in bytes.
    uint  Size;
    ///A pointer to the argument data.
    void* pData;
}

///Contains the list of reference frames for the current decode operation. Either a texture array or an array of
///textures can be specified.
struct D3D12_VIDEO_DECODE_REFERENCE_FRAMES
{
    ///The number of references specified in the *ppTexture2Ds* field.
    uint            NumTexture2Ds;
    ///A list of reference textures. When specifying texture arrays, each entry will be point to the same resource. When
    ///specifying an array of textures, each entry will point to a separate resource.
    ID3D12Resource* ppTexture2Ds;
    ///An array of subresource indices for the reference textures specified in *ppTexture2Ds*. NULL indicates that
    ///subresource 0 should be assumed for each resource. With texture arrays within a single resource, the subresource
    ///indices point to the array index of the first resource plane. With an array of textures in individual resources,
    ///the subresource index is typically zero. The video device driver uses the "PicEntry" indices defined in the DXVA
    ///spec for the codec to dereference this array to find the subresource index to use with the corresponding
    ///resource. For example, in HEVC, the Driver uses
    ///[DXVA_PicEntry_HEVC::Index7Bits](/windows/win32/medfound/dxva-picentry-hevc) as an index for this array.
    uint*           pSubresources;
    ///An array of [ID3D12VideoDecoderHeap](nn-d3d12video-id3d12videodecoderheap.md) objects. This field is used with
    ///formats that support non-key frame resolution changes, allowing the caller to pass in the previous resolution's
    ///heap, relative to the reference it's being used for, in addition to the current resolution heap.
    ID3D12VideoDecoderHeap* ppHeaps;
}

///Represents a compressed bitstream from which video is decoded.
struct D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM
{
    ///A pointer to an [ID3D12Resource](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) representing the source
    ///buffer containing the compressed bitstream to decode.
    ID3D12Resource pBuffer;
    ///The offset to the beginning of the first slice. This offset has alignment requirements based on the tier value of
    ///the video decoder. For more information on decoding tiers, see
    ///[D3D12_VIDEO_DECODE_TIER](ne-d3d12video-d3d12_video_decode_tier.md).
    ulong          Offset;
    ///The size of the subregion of *pBuffer* that contains the bitstream.
    ulong          Size;
}

///Specifies the parameters for decode output conversion.
///[D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1](ns-d3d12video-d3d12_video_decode_conversion_arguments.md) is used for the
///same purpose, but provides additional fields for output width and output height.
struct D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS
{
    ///A boolean value indicating whether decode conversion should be used.
    BOOL           Enable;
    ///A pointer to an [ID3D12Resource](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) containing the native
    ///decoding output. When downsampling is enabled, the output at native decode resolution, color space, and format
    ///may be required for future decode submissions (as reference frames, for instance).
    ID3D12Resource pReferenceTexture2D;
    ///The subresource index of the resource provided in *pDecodeTexture2D* to use.
    uint           ReferenceSubresource;
    ///A value from the [DXGI_COLOR_SPACE_TYPE](/windows/desktop/api/dxgicommon/ne-dxgicommon-dxgi_color_space_type)
    ///enumeration specifying the target color space of the output.
    DXGI_COLOR_SPACE_TYPE OutputColorSpace;
    ///A value from the [DXGI_COLOR_SPACE_TYPE](/windows/desktop/api/dxgicommon/ne-dxgicommon-dxgi_color_space_type)
    ///enumeration specifying the source-decoded color space before conversion.
    DXGI_COLOR_SPACE_TYPE DecodeColorSpace;
}

///Specifies the parameters for the input stream for a video decode operation.
struct D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS
{
    ///The count of frame parameters provided in the *FrameArguments* field. The maximum number of frame arguments is
    ///10.
    uint NumFrameArguments;
    ///An array of [D3D12_VIDEO_DECODE_FRAME_ARGUMENT](ns-d3d12video-d3d12_video_decode_frame_argument.md) structures
    ///containing the parameters to decode a frame.
    D3D12_VIDEO_DECODE_FRAME_ARGUMENT[10] FrameArguments;
    ///A [D3D12_VIDEO_DECODE_REFERENCE_FRAMES](ns-d3d12video-d3d12_video_decode_reference_frames.md) structure
    ///containing the reference frames needed to decode a frame.
    D3D12_VIDEO_DECODE_REFERENCE_FRAMES ReferenceFrames;
    ///A [D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM](ns-d3d12video-d3d12_video_decode_compressed_bitstream.md) structure
    ///representing the compressed bitstream in a single continuous buffer.
    D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM CompressedBitstream;
    ///An [ID3D12VideoDecoderHeap](nn-d3d12video-id3d12videodecoderheap.md) representing a pointer to the heap for the
    ///current decode resolution.
    ID3D12VideoDecoderHeap pHeap;
}

///Specifies the parameters for the output stream for a video decode operation.
///[D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1](ns-d3d12video-d3d12_video_decode_output_stream_arguments1.md) is used
///for the same purpose, but provides an additional field for histograms.
struct D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS
{
    ///An [ID3D12Resource](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) representing the output texture. If
    ///decode conversion is enabled, this texture will contain the post-conversion output. If decode conversion is not
    ///enabled, this texture will contain the decode output.
    ID3D12Resource pOutputTexture2D;
    ///The index of the output subresource of *pOutputTexture2D* to use. This allows you to specify array indices if the
    ///output is an array.
    uint           OutputSubresource;
    ///An optional [D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS](ns-d3d12video-d3d12_video_decode_conversion_arguments.md)
    ///structure containing output conversion parameters.
    D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS ConversionArguments;
}

///Defines the range of supported values for an image filter.
struct D3D12_VIDEO_PROCESS_FILTER_RANGE
{
    ///The minimum value of the filter.
    int   Minimum;
    ///The maximum value of the filter.
    int   Maximum;
    ///The default value of the filter.
    int   Default;
    ///A multiplier. Use the following formula to translate the filter setting into the actual filter value: `Actual
    ///Value = Set Value Ã— Multiplier.`
    float Multiplier;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12\_FEATURE\_VIDEO\_PROCESS\_SUPPORT ](ne-d3d12video-d3d12_feature_video.md).
struct D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT
{
    ///An integer indicating which physical adapter of the device the operation applies to, in a multi-adapter
    ///operation.
    uint               NodeIndex;
    ///A [D3D12\_VIDEO\_SAMPLE](ns-d3d12video-d3d12_video_sample.md) structure defining the width, height, and format of
    ///the input sample.
    D3D12_VIDEO_SAMPLE InputSample;
    ///A member of the [D3D12\_VIDEO\_FIELD\_TYPE](ne-d3d12video-d3d12_video_field_type.md) enumeration specifying the
    ///interlaced field type of the input sample.
    D3D12_VIDEO_FIELD_TYPE InputFieldType;
    ///A member of the [D3D12\_VIDEO\_FRAME\_STEREO\_FORMAT](ne-d3d12video-d3d12_video_frame_stereo_format.md)
    ///enumeration specifying the stereo format of the input sample.
    D3D12_VIDEO_FRAME_STEREO_FORMAT InputStereoFormat;
    ///The input frame rate.
    DXGI_RATIONAL      InputFrameRate;
    ///A [D3D12\_VIDEO\_FORMAT](ns-d3d12video-d3d12_video_format.md) structure specifying the output DXGI format and
    ///color space.
    D3D12_VIDEO_FORMAT OutputFormat;
    ///A member of the [D3D12\_VIDEO\_FRAME\_STEREO\_FORMAT](ne-d3d12video-d3d12_video_frame_stereo_format.md)
    ///enumeration specifying the stereo format of the output.
    D3D12_VIDEO_FRAME_STEREO_FORMAT OutputStereoFormat;
    ///The output frame rate.
    DXGI_RATIONAL      OutputFrameRate;
    ///A member of the [D3D12\_VIDEO\_PROCESS\_SUPPORT\_FLAGS](ne-d3d12video-d3d12_video_process_support_flags.md)
    ///indicating whether the requested format and colorspace conversion is supported. This value is populated by the
    ///call to **ID3D12Device::CheckFeatureSupport**.
    D3D12_VIDEO_PROCESS_SUPPORT_FLAGS SupportFlags;
    ///A [D3D12\_VIDEO\_SCALE\_SUPPORT](ns-d3d12video-d3d12_video_scale_support.md) structure specifying the supported
    ///scaling capabilities. This value is populated by the call to **ID3D12Device::CheckFeatureSupport**.
    D3D12_VIDEO_SCALE_SUPPORT ScaleSupport;
    ///A bitwise OR combination of values from the
    ///[D3D12\_VIDEO\_PROCESS\_FEATURE\_FLAGS](ne-d3d12video-d3d12_video_process_feature_flags.md) enumeration
    ///specifying the supported video processing features. This value is populated by the call to
    ///**ID3D12Device::CheckFeatureSupport**.
    D3D12_VIDEO_PROCESS_FEATURE_FLAGS FeatureSupport;
    ///A member of the
    ///[D3D12\_VIDEO\_PROCESS\_DEINTERLACE\_FLAGS](ne-d3d12video-d3d12_video_process_deinterlace_flags.md) enumeration
    ///specifying the supported deinterlacing capabilities. This value is populated by the call to
    ///**ID3D12Device::CheckFeatureSupport**.
    D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS DeinterlaceSupport;
    ///A member of the
    ///[D3D12\_VIDEO\_PROCESS\_AUTO\_PROCESSING\_FLAGS](ne-d3d12video-d3d12_video_process_auto_processing_flags.md)
    ///specifying the supported automatic processing capabilities. This value is populated by the call to
    ///**ID3D12Device::CheckFeatureSupport**.
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS AutoProcessingSupport;
    ///A bitwise OR combination of values from the
    ///[D3D12\_VIDEO\_PROCESS\_FILTER\_FLAGS](ne-d3d12video-d3d12_video_process_filter_flags.md) enumeration specifying
    ///the supported video filtering features. This value is populated by the call to
    ///**ID3D12Device::CheckFeatureSupport**.
    D3D12_VIDEO_PROCESS_FILTER_FLAGS FilterSupport;
    ///An array of [D3D12\_VIDEO\_PROCESS\_FILTER\_RANGE](ns-d3d12video-d3d12_video_process_filter_range.md) structures
    ///representing the filter range values. This value is populated by the call to
    ///**ID3D12Device::CheckFeatureSupport**. The calling application must allocate the memory for the filter range list
    ///before calling **CheckFeatureSupport**.
    D3D12_VIDEO_PROCESS_FILTER_RANGE[32] FilterRangeSupport;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12\_FEATURE\_VIDEO\_PROCESS\_MAX\_INPUT\_STREAMS](ne-d3d12video-d3d12_feature_video.md). Retrieves
///the maximum number of enabled input streams supported by the video processor.
struct D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS
{
    ///An integer indicating which physical adapter of the device the operation applies to, in a multi-adapter
    ///operation.
    uint NodeIndex;
    ///The maximum number of streams that can be enabled for the video processor at the same time.
    uint MaxInputStreams;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12\_FEATURE\_VIDEO\_PROCESS\_REFERENCE\_INFO](ne-d3d12video-d3d12_feature_video.md). Retrieves the
///number of past and future reference frames required for the specified deinterlace mode, filter, rate conversion, or
///auto processing features.
struct D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO
{
    ///An integer indicating which physical adapter of the device the operation applies to, in a multi-adapter
    ///operation.
    uint          NodeIndex;
    ///A member of the
    ///[D3D12\_VIDEO\_PROCESS\_DEINTERLACE\_FLAGS](ne-d3d12video-d3d12_video_process_deinterlace_flags.md) enumeration
    ///specifying the deinterlacing mode for which the required past and future reference frame counts are retrieved.
    D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS DeinterlaceMode;
    ///A bitwise OR combination of values from the
    ///[D3D12\_VIDEO\_PROCESS\_FILTER\_FLAGS](ne-d3d12video-d3d12_video_process_filter_flags.md) enumeration specifying
    ///the filters for which the required past and future reference frame counts are retrieved.
    D3D12_VIDEO_PROCESS_FILTER_FLAGS Filters;
    ///A bitwise OR combination of values from the
    ///[D3D12\_VIDEO\_PROCESS\_FEATURE\_FLAGS](ne-d3d12video-d3d12_video_process_feature_flags.md) enumeration
    ///specifying the features for which the required past and future reference frame counts are retrieved.
    D3D12_VIDEO_PROCESS_FEATURE_FLAGS FeatureSupport;
    ///The input frame rate of the stream for which the required past and future reference frame counts are retrieved.
    DXGI_RATIONAL InputFrameRate;
    ///The output frame rate of the stream for which the required past and future reference frame counts are retrieved.
    DXGI_RATIONAL OutputFrameRate;
    ///True if autoprocessing will be used; otherwise, false.
    BOOL          EnableAutoProcessing;
    ///The number of past frames required to support the specified processing features.
    uint          PastFrames;
    ///The number of future frames required to support the specified processing features.
    uint          FutureFrames;
}

///Contains the reference frames needed to perform video processing.
struct D3D12_VIDEO_PROCESS_REFERENCE_SET
{
    ///The number of past reference frames provided in *ppPastFrames*.
    uint            NumPastFrames;
    ///A pointer to an array of [ID3D12Resource](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) surfaces. The
    ///number of elements in the array is *NumPastFrames*.
    ID3D12Resource* ppPastFrames;
    ///An array of subresource indices for the list of *ppPastFrames* textures. NULL indicates subresource 0 for each
    ///resource.
    uint*           pPastSubresources;
    ///The number of future reference frames provided in *ppPastFrames*.
    uint            NumFutureFrames;
    ///A pointer to an array of [ID3D12Resource](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) surfaces. The
    ///number of elements in the array is *NumFutureFrames*.
    ID3D12Resource* ppFutureFrames;
    ///An array of subresource indices for the list of *ppFutureFrames* textures. NULL indicates subresource 0 for each
    ///resource.
    uint*           pFutureSubresources;
}

///Specifies transform parameters for video processing. Used by the
///[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS](ns-d3d12video-d3d12_video_process_input_stream_arguments.md) structure.
struct D3D12_VIDEO_PROCESS_TRANSFORM
{
    ///Specifies the source rectangle of the transform. This is the portion of the input surface that is blitted to the
    ///destination surface. The source rectangle is given in pixel coordinates, relative to the input surface.
    RECT SourceRectangle;
    ///Specifies the destination rectangle of the transform. This is the portion of the output surface that receives the
    ///blit for this stream. The destination rectangle is given in pixel coordinates, relative to the output surface.
    RECT DestinationRectangle;
    ///The rotation and flip operation to apply to the source. Source and Destination rectangles are specified in post
    ///orientation coordinates.
    D3D12_VIDEO_PROCESS_ORIENTATION Orientation;
}

///Provides information about the stream rate.
struct D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE
{
    ///The zero-based index number of the output frame. The OutputIndex member is a zero-based cyclic number that
    ///indicates the frame index number of the output. The driver uses this output-index information to perform the
    ///video processing in a certain pattern or cycle, especially when the driver performs deinterlacing or frame-rate
    ///conversion. For example, with the following output-index pattern, the driver performs the indicated video
    ///processing: - Progressive format at normal and half rate: - *OutputInde* = 0, 0,... - Progressive format at 2/1
    ///custom rate (double frame-rate conversion, OutputFrames=2): - *OutputInde* = 0, 1, 0, 1,... - Interlaced format
    ///at normal rate: - *OutputInde* = 0, 1, 0, 1,... (0: first field, 1: second field) - Interlaced format at half
    ///rate: - *OutputInde* = 0, 0,... (for example, first and second fields are blended to one frame) - Interlaced at
    ///4/5 custom rate (3:2 inverse telecine, OutputFrames=4): - *OutputInde* = 0, 1, 2, 3, 0, 1, 2, 3,... (0:A, 1:B,
    ///2:C, 3:D film frame)
    uint OutputIndex;
    ///The zero-based index number of the input frame or field. The InputFrameOrField member is a zero-based number that
    ///indicates the frame or the field number of the input surface. For example, with the following
    ///input-frame-or-field number, the driver can perform the indicated video processing: - Progressive format and
    ///interlaced format at normal rate: - *InputFrameOrField* = 0, 1, 2,... - Progressive format and interlaced format
    ///at half rate: - *InputFrameOrField* = 0, 2, 4,... - Interlaced format at 4/5 custom rate (3:2 inverse telecine,
    ///OutputFrames=4 and InputFrameOrField=10): - *InputFrameOrField* = 0, 0, 0, 0, 10, 10, 10, 10, 20, 20, 20, 20,...
    ///- Interlaced format at 4/15 custom rate (8:7 inverse telecine, OutputFrames=2 and InputFrameOrField=15): -
    ///*InputFrameOrField* = 0, 0, 15, 15, 30, 30,...
    uint InputFrameOrField;
}

///Contains input information for the video processor blend functionality.
struct D3D12_VIDEO_PROCESS_INPUT_STREAM
{
    ///An [ID3D12Resource](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) representing the current input field or
    ///frame.
    ID3D12Resource pTexture2D;
    ///The subresource index to use of the *pInputTexture* argument.
    uint           Subresource;
    ///A [D3D12_VIDEO_PROCESS_REFERENCE_SET](ns-d3d12video-d3d12_video_process_reference_set.md) containing the set of
    ///references for video processing. Some video processing algorithms require forward or backward frame references.
    ///For more information, see [D3D12_FEATURE_VIDEO_PROCESS_REFERENCE_INFO](ne-d3d12video-d3d12_feature_video.md).
    D3D12_VIDEO_PROCESS_REFERENCE_SET ReferenceSet;
}

///Specifies input stream arguments for an input stream passed
///to[ID3D12VideoCommandList::ProcessFrames](nf-d3d12video-id3d12videoprocesscommandlist-processframes.md).
struct D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS
{
    ///An array of [D3D12_VIDEO_PROCESS_INPUT_STREAM](ns-d3d12video-d3d12_video_process_input_stream.md) structures
    ///containing the set of references for video processing. If the stereo format is
    ///[D3D12_VIDEO_PROCESS_STEREO_FORMAT_SEPARATE](ne-d3d12video-d3d12_video_frame_stereo_format.md), then two sets of
    ///input streams must be supplied. For all other stereo formats, the first set of reference must be supplied, and
    ///the second should be zero initialized.
    D3D12_VIDEO_PROCESS_INPUT_STREAM[2] InputStream;
    ///A [D3D12_VIDEO_PROCESS_TRANSFORM](ns-d3d12video-d3d12_video_process_transform.md) structure specifying the flip,
    ///rotation, scale and destination translation for the video input.
    D3D12_VIDEO_PROCESS_TRANSFORM Transform;
    ///A value from the
    ///[D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS](ne-d3d12video-d3d12_video_process_input_stream_flags.md) enumeration
    ///specifying the options for the input stream.
    D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS Flags;
    ///A [D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE](ns-d3d12video-d3d12_video_process_input_stream_rate.md) structure
    ///specifying the framerate and input and output indicies for framerate conversion and deinterlacing.
    D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE RateInfo;
    ///The level to apply for each enabled filter. The filter level is specified in the order that filters appear in the
    ///[D3D12_VIDEO_PROCESS_FILTER_FLAGS](ne-d3d12video-d3d12_video_process_filter_flags.md) enumeration. Specify 0 if a
    ///filter is not enabled or the filter index is reserved.
    int[32] FilterLevels;
    ///A [D3D12_VIDEO_PROCESS_ALPHA_BLENDING](ns-d3d12video-d3d12_video_process_alpha_blending.md) structure specifying
    ///the planar alpha for an input stream on the video processor.
    D3D12_VIDEO_PROCESS_ALPHA_BLENDING AlphaBlending;
}

///Represents the output stream for video processing commands. Points to the target surface for the processing
///operation.
struct D3D12_VIDEO_PROCESS_OUTPUT_STREAM
{
    ///A pointer to a [ID3D12Resource](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) representing the output
    ///surfaces for the video process command.
    ID3D12Resource pTexture2D;
    ///The subresource indices to use within the resource specified *pTexture2D* resource.
    uint           Subresource;
}

///Specifies output stream arguments for the output passed to
///[ID3D12VideoCommandList::ProcessFrames](nf-d3d12video-id3d12videoprocesscommandlist-processframes.md).
struct D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS
{
    ///An array of [D3D12_VIDEO_PROCESS_OUTPUT_STREAM](ns-d3d12video-d3d12_video_process_output_stream.md) structures
    ///representing the output surfaces for the video process command. If stereo output is enabled, index zero contains
    ///the left output while index 1 contains the right input. If stereo output is not enabled, only index 0 is used to
    ///specify the output while index 1 should be set to nullptr.
    D3D12_VIDEO_PROCESS_OUTPUT_STREAM[2] OutputStream;
    ///The target rectangle is the area within the destination surface where the output will be drawn. The target
    ///rectangle is given in pixel coordinates, relative to the destination surface.
    RECT TargetRectangle;
}

///Represents the histogram output buffer for a single component.
struct D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM
{
    ///The offset location in *pBuffer* to write the component histogram. Must be 256-byte aligned. Set to zero when a
    ///component is disabled.
    ulong          Offset;
    ///And [ID3D12Resource](../d3d12/nn-d3d12-id3d12resource.md) representing the target buffer for hardware to write
    ///the components histogram. Set to a nullptr when the component histogram is disabled.
    ID3D12Resource pBuffer;
}

///Specifies the parameters for decode output conversion.
///[D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS](ns-d3d12video-d3d12_video_decode_conversion_arguments.md) is used for the
///same purpose, but does not contain fields for output width and output height.
struct D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1
{
    ///A boolean value indicating whether decode conversion should be used.
    BOOL           Enable;
    ///A pointer to an [ID3D12Resource](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) containing the native
    ///decoding output. When downsampling is enabled, the output at native decode resolution, color space, and format
    ///may be required for future decode submissions (as reference frames, for instance).
    ID3D12Resource pReferenceTexture2D;
    ///The subresource index of the resource provided in *pDecodeTexture2D* to use.
    uint           ReferenceSubresource;
    ///A value from the [DXGI_COLOR_SPACE_TYPE](/windows/desktop/api/dxgicommon/ne-dxgicommon-dxgi_color_space_type)
    ///enumeration specifying the target color space of the output.
    DXGI_COLOR_SPACE_TYPE OutputColorSpace;
    ///A value from the [DXGI_COLOR_SPACE_TYPE](/windows/desktop/api/dxgicommon/ne-dxgicommon-dxgi_color_space_type)
    ///enumeration specifying the source-decoded color space before conversion.
    DXGI_COLOR_SPACE_TYPE DecodeColorSpace;
    ///The output width, in pixels.
    uint           OutputWidth;
    ///The output width, in pixels.
    uint           OutputHeight;
}

///Specifies the parameters for the output stream for a video decode operation.
///[D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS](ns-d3d12video-d3d12_video_decode_output_stream_arguments.md) is used for
///the same purpose, but does not provide a field for histograms.
struct D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1
{
    ///An [ID3D12Resource](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) representing the output texture. If
    ///decode conversion is enabled, this texture will contain the post-conversion output. If decode conversion is not
    ///enabled, this texture will contain the decode output.
    ID3D12Resource pOutputTexture2D;
    ///The index of the output subresource of *pOutputTexture2D* to use. This allows you to specify array indices if the
    ///output is an array.
    uint           OutputSubresource;
    ///An optional [D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS](ns-d3d12video-d3d12_video_decode_conversion_arguments.md)
    ///structure containing output conversion parameters.
    D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 ConversionArguments;
    ///An array of [D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM](ns-d3d12video-d3d12_video_decode_output_histogram.md)
    ///structures that are populated with histogram data. The maximum size of the array is 4.
    D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM[4] Histograms;
}

///Specifies input stream arguments for an input stream passed to
///[ID3D12VideoProcessCommandList1::ProcessFrames1](nf-d3d12video-id3d12videoprocesscommandlist1-processframes1.md),
///which supports changing the field type for each call.
struct D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1
{
    ///An array of [D3D12_VIDEO_PROCESS_INPUT_STREAM](ns-d3d12video-d3d12_video_process_input_stream.md) structures
    ///containing the set of references for video processing. If the stereo format is
    ///[D3D12_VIDEO_PROCESS_STEREO_FORMAT_SEPARATE](ne-d3d12video-d3d12_video_frame_stereo_format.md), then two sets of
    ///input streams must be supplied. For all other stereo formats, the first set of reference must be supplied, and
    ///the second should be zero initialized.
    D3D12_VIDEO_PROCESS_INPUT_STREAM[2] InputStream;
    ///A [D3D12_VIDEO_PROCESS_TRANSFORM](ns-d3d12video-d3d12_video_process_transform.md) structure specifying the flip,
    ///rotation, scale and destination translation for the video input.
    D3D12_VIDEO_PROCESS_TRANSFORM Transform;
    ///A value from the
    ///[D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS](ne-d3d12video-d3d12_video_process_input_stream_flags.md) enumeration
    ///specifying the options for the input stream.
    D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS Flags;
    ///A [D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE](ns-d3d12video-d3d12_video_process_input_stream_rate.md) structure
    ///specifying the framerate and input and output indicies for framerate conversion and deinterlacing.
    D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE RateInfo;
    ///The level to apply for each enabled filter. The filter level is specified in the order that filters appear in the
    ///[D3D12_VIDEO_PROCESS_FILTER_FLAGS](ne-d3d12video-d3d12_video_process_filter_flags.md) enumeration. Specify 0 if a
    ///filter is not enabled or the filter index is reserved.
    int[32] FilterLevels;
    ///A [D3D12_VIDEO_PROCESS_ALPHA_BLENDING](ns-d3d12video-d3d12_video_process_alpha_blending.md) structure specifying
    ///the planar alpha for an input stream on the video processor.
    D3D12_VIDEO_PROCESS_ALPHA_BLENDING AlphaBlending;
    ///A value from the [D3D12_VIDEO_FIELD_TYPE](ne-d3d12video-d3d12_video_field_type.md) enumeration specfying the
    ///interlaced field type of the input source. When working with mixed content, use
    ///[ID3D12VideoProcessCommandList1::ProcessFrames1](nf-d3d12video-id3d12videoprocesscommandlist1-processframes1.md)
    ///which supports changing the field type for each call.
    D3D12_VIDEO_FIELD_TYPE FieldType;
}

struct D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT
{
    uint NodeIndex;
    BOOL VideoDecodeSupport;
    BOOL VideoProcessSupport;
    BOOL VideoEncodeSupport;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR](ne-d3d12video-d3d12_feature_video.md). Retrieves the motion
///estimation capabilities for a video encoder.
struct D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR
{
    ///In multi-adapter operation, identifies the physical adapter of the device this operation applies to.
    uint        NodeIndex;
    ///A [DXGI_FORMAT](/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format) structure specifying the format of the
    ///input resources.
    DXGI_FORMAT InputFormat;
    ///A bitwise OR combination of values from the
    ///[D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS](ne-d3d12video-d3d12_video_motion_estimator_search_block_size_flags.md)
    ///enumeration specifying the encoder's supported search block sizes for motion estimation.
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS BlockSizeFlags;
    ///A bitwise OR combination of values from the
    ///[D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS](ne-d3d12video-d3d12_video_motion_estimator_vector_precision_flags.md)
    ///enumeration specifying the encoder's supported vector precision for motion estimation.
    D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS PrecisionFlags;
    ///A [D3D12_VIDEO_SIZE_RANGE](ns-d3d12video-d3d12_video_size_range.md) structure representing the minimum and
    ///maximum input size supported by the driver. The driver sets the fields of this structure to zero if motion
    ///estimation is unsupported.
    D3D12_VIDEO_SIZE_RANGE SizeRange;
}

///Describes the allocation size of a video motion estimator heap.
struct D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE
{
    ///In multi-adapter operation, identifies the physical adapter of the device this operation applies to.
    uint        NodeIndex;
    ///A [DXGI_FORMAT](/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format) structure specifying the format of the
    ///input and reference resources.
    DXGI_FORMAT InputFormat;
    ///A value from the
    ///[D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE](ne-d3d12video-d3d12_video_motion_estimator_search_block_size.md)
    ///specifying the search block size for motion estimation.
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE BlockSize;
    ///A value from the
    ///[D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION](ne-d3d12video-d3d12_video_motion_estimator_vector_precision.md)
    ///specifying the search block size for motion estimation.
    D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION Precision;
    ///A [D3D12_VIDEO_SIZE_RANGE](ns-d3d12video-d3d12_video_size_range.md) structure representing the minimum and
    ///maximum input and reference frame size, in pixels, used by the motion estimator.
    D3D12_VIDEO_SIZE_RANGE SizeRange;
    ///TRUE if the motion estimator operates on protected resource input and produces protected output; otherwise,
    ///FALSE.
    BOOL        Protected;
    ///The allocation size of the motion vector heap in the L0 memory pool. L0 is the physical system memory pool. When
    ///the adapter is discrete/NUMA, this pool has greater bandwidth for the CPU and less bandwidth for the GPU. When
    ///the adapter is UMA, this pool is the only one which is valid. For more information, see
    ///[Residency](/windows/win32/direct3d12/residency).
    ulong       MotionVectorHeapMemoryPoolL0Size;
    ///The allocation size of the motion vector heap in the L1 memory pool. L1 is typically known as the physical video
    ///memory pool. L1 is only available when the adapter is discrete/NUMA, and has greater bandwidth for the GPU and
    ///cannot even be accessed by the CPU. When the adapter is UMA, this pool is not available. For more information,
    ///see [Residency](/windows/win32/direct3d12/residency).
    ulong       MotionVectorHeapMemoryPoolL1Size;
    ///The allocation size of the motion estimator heap in the L0 memory pool. L0 is the physical system memory pool.
    ///When the adapter is discrete/NUMA, this pool has greater bandwidth for the CPU and less bandwidth for the GPU.
    ///When the adapter is UMA, this pool is the only one which is valid. For more information, see
    ///[Residency](/windows/win32/direct3d12/residency).
    ulong       MotionEstimatorMemoryPoolL0Size;
    ///The allocation size of the motion estimator heap in the L1 memory pool. L1 is typically known as the physical
    ///video memory pool. L1 is only available when the adapter is discrete/NUMA, and has greater bandwidth for the GPU
    ///and cannot even be accessed by the CPU. When the adapter is UMA, this pool is not available. For more
    ///information, see [Residency](/windows/win32/direct3d12/residency).
    ulong       MotionEstimatorMemoryPoolL1Size;
}

///Describes a [ID3D12VideoMotionEstimator](nn-d3d12video-id3d12videomotionestimator.md). Pass this structure into
///[ID3D12VideoDevice1::CreateVideoMotionEstimator](nf-d3d12video-id3d12videodevice1-createvideomotionestimator.md) to
///create an instance of **ID3D12VideoMotionEstimator**.
struct D3D12_VIDEO_MOTION_ESTIMATOR_DESC
{
    ///The node mask specifying the physical adapter on which the video processor will be used. For single GPU
    ///operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node, i.e. the device's
    ///physical adapter, to which the command queue applies. Each bit in the mask corresponds to a single node. Only 1
    ///bit may be set.
    uint        NodeMask;
    ///A value from the [DXGI_FORMAT](/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format) enumeration specifying
    ///the format of the input and reference frames.
    DXGI_FORMAT InputFormat;
    ///A value from the
    ///[D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE](ne-d3d12video-d3d12_video_motion_estimator_search_block_size.md)
    ///enumeration specifying the search block size the video motion estimator will use.
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE BlockSize;
    ///A value from the
    ///[D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION](ne-d3d12video-d3d12_video_motion_estimator_vector_precision.md)
    ///enumeration specifying the vector precision the video motion estimator will use.
    D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION Precision;
    ///A [D3D12_VIDEO_SIZE_RANGE](ns-d3d12video-d3d12_video_size_range.md) structure representing the minimum and
    ///maximum input and reference frame size, in pixels, that the motion estimator will accept.
    D3D12_VIDEO_SIZE_RANGE SizeRange;
}

///Describes a [ID3D12VideoMotionEstimatorHeap](nn-d3d12video-id3d12videomotionvectorheap.md). Pass this structure into
///[ID3D12VideoDevice1::CreateVideoMotionVectorHeap](nf-d3d12video-id3d12videodevice1-createvideomotionvectorheap.md) to
///create an instance of **ID3D12VideoMotionEstimatorHeap**.
struct D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC
{
    ///The node mask specifying the physical adapter on which the video processor will be used. For single GPU
    ///operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node, i.e. the device's
    ///physical adapter, to which the command queue applies. Each bit in the mask corresponds to a single node. Only 1
    ///bit may be set.
    uint        NodeMask;
    ///A value from the [DXGI_FORMAT](/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format) enumeration specifying
    ///the format of the input and reference frames.
    DXGI_FORMAT InputFormat;
    ///A value from the
    ///[D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE](ne-d3d12video-d3d12_video_motion_estimator_search_block_size.md)
    ///enumeration specifying the search block size the video motion estimator will use.
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE BlockSize;
    ///A value from the
    ///[D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION](ne-d3d12video-d3d12_video_motion_estimator_vector_precision.md)
    ///enumeration specifying the vector precision the video motion estimator will use.
    D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION Precision;
    ///A [D3D12_VIDEO_SIZE_RANGE](ns-d3d12video-d3d12_video_size_range.md) structure representing the minimum and
    ///maximum input and reference frame size, in pixels, that the motion estimator will accept.
    D3D12_VIDEO_SIZE_RANGE SizeRange;
}

///Describes the coordinates of a resource.
struct D3D12_RESOURCE_COORDINATE
{
    ///The x-coordinate of the resource.
    ulong X;
    ///The y-coordinate of the resource.
    uint  Y;
    ///The z-coordinate of the resource.
    uint  Z;
    ///The index of the subresource for the resource.
    uint  SubresourceIndex;
}

///Specifies the output parameters for calls to
///[ID3D12VideoEncodeCommandList::EstimateMotion](nf-d3d12video-id3d12videoencodecommandlist-estimatemotion.md).
struct D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT
{
    ///An [ID3D12VideoMotionVectorHeap](nn-d3d12video-id3d12videomotionvectorheap.md) containing the resolved motion
    ///estimation vectors. Motion vectors are resolved to a
    ///[DXGI_FORMAT_R16G16_SINT](../dxgiformat/ne-dxgiformat-dxgi_format.md) 2D texture. The resolved data is a signed
    ///16-byte integer with quarter PEL units with the X vector component stored in the R component and the Y vector
    ///component stored in the G component. Motion vectors are stored in a 2D layout that corresponds to the pixel
    ///layout of the original input textures.
    ID3D12VideoMotionVectorHeap pMotionVectorHeap;
}

///Specifies the input parameters for calls to
///[ID3D12VideoEncodeCommandList::EstimateMotion](nf-d3d12video-id3d12videoencodecommandlist-estimatemotion.md).
struct D3D12_VIDEO_MOTION_ESTIMATOR_INPUT
{
    ///An [ID3D12Resource](../d3d12/nn-d3d12-id3d12resource.md) representing the current frame. The motion estimation
    ///operation applies to the entire frame.
    ID3D12Resource pInputTexture2D;
    ///The base plane of the MIP and array slice to use for the input.
    uint           InputSubresourceIndex;
    ///An [ID3D12Resource](../d3d12/nn-d3d12-id3d12resource.md) representing the reference frame, or past frame, used
    ///for motion estimation.
    ID3D12Resource pReferenceTexture2D;
    ///The base plane of the MIP and array slice to use for the reference.
    uint           ReferenceSubresourceIndex;
    ///An [ID3D12VideoMotionVectorHeap](nn-d3d12video-id3d12videomotionvectorheap.md) representing the buffer containing
    ///the hardware-dependent output of the previous motion estimator operation which may be used for hinting the
    ///current operation. This parameter may be NULL, indicating that previous motion estimator output should not be
    ///considered for the current operation.
    ID3D12VideoMotionVectorHeap pHintMotionVectorHeap;
}

///Receives output data from calls to
///[ID3D12VideoEncodeCommandList::ResolveMotionVectorHeap](nf-d3d12video-id3d12videoencodecommandlist-resolvemotionvectorheap.md).
struct D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT
{
    ///An [ID3D12Resource](../d3d12/nn-d3d12-id3d12resource.md) representing the output resource for resolved motion
    ///vectors. Motion vectors are resolved to [DXGI_FORMAT_R16G16_SINT](../dxgiformat/ne-dxgiformat-dxgi_format.md) 2D
    ///textures. The resolved data is a signed 16-byte integer with quarter PEL units with the X vector component stored
    ///in the R component and the Y vector component stored in the G component. Motion vectors are stored in a 2D layout
    ///that corresponds to the pixel layout of the original input textures.
    ID3D12Resource pMotionVectorTexture2D;
    ///A [D3D12_RESOURCE_COORDINATE](ns-d3d12video-d3d12_resource_coordinate.md) structure specifying the output origin
    ///of the motion vectors. The remaining sub-region must be large enough to store all motion vectors per block
    ///specified by the input pixel with and pixel height and the specified
    ///[D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE](ne-d3d12video-d3d12_video_motion_estimator_search_block_size.md).
    D3D12_RESOURCE_COORDINATE MotionVectorCoordinate;
}

///Provides input data for calls to
///[ID3D12VideoEncodeCommandList::ResolveMotionVectorHeap](nf-d3d12video-id3d12videoencodecommandlist-resolvemotionvectorheap.md).
struct D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT
{
    ///The [ID3D12VideoMotionVectorHeap](nn-d3d12video-id3d12videomotionvectorheap.md) containing the hardware-dependent
    ///data layout of the motion search.
    ID3D12VideoMotionVectorHeap pMotionVectorHeap;
    ///The pixel width of the texture that the motion estimation operation was performed on. The motion estimator heap
    ///may be allocated to support a size range, this parameter informs the size of the last motion estimation
    ///operation.
    uint PixelWidth;
    ///The pixel height of the texture that the motion estimation operation was performed on. The motion estimator heap
    ///may be allocated to support a size range, this parameter informs the size of the last motion estimation
    ///operation.
    uint PixelHeight;
}

struct D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES
{
    uint NodeIndex;
    D3D12_VIDEO_DECODE_CONFIGURATION Configuration;
    D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS SupportFlags;
}

struct D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES
{
    uint NodeIndex;
    D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS SupportFlags;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES](ne-d3d12video-d3d12_feature_video.md).
///Retrieves the protected resources support for video motion estimation.
struct D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES
{
    ///In multi-adapter operation, identifies the physical adapter of the device this operation applies to.
    uint NodeIndex;
    ///A member of the
    ///[D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS](ne-d3d12video-d3d12_video_protected_resource_support_flags.md)
    ///enumeration specifying support for protected resources.
    D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS SupportFlags;
}

struct D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1
{
    D3D12_VIDEO_DECODER_HEAP_DESC VideoDecoderHeapDesc;
    BOOL  Protected;
    ulong MemoryPoolL0Size;
    ulong MemoryPoolL1Size;
}

struct D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1
{
    uint  NodeMask;
    const(D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC)* pOutputStreamDesc;
    uint  NumInputStreamDescs;
    const(D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC)* pInputStreamDescs;
    BOOL  Protected;
    ulong MemoryPoolL0Size;
    ulong MemoryPoolL1Size;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_COUNT](ne-d3d12video-d3d12_feature_video.md). Retrieves the
///supported number of video extension commands.
struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT
{
    ///For single GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the
    ///device's physical adapter) to which the command queue applies. Each bit in the mask corresponds to a single node.
    ///Only 1 bit may be set.
    uint NodeIndex;
    ///The supported number of video extension commands.
    uint CommandCount;
}

///Describes a video extension command.
struct D3D12_VIDEO_EXTENSION_COMMAND_INFO
{
    ///The unique identifier for the video extension command.
    GUID         CommandId;
    ///A pointer to a wide string containing the name of the command.
    const(PWSTR) Name;
    ///A member of the [D3D12_COMMAND_LIST_SUPPORT_FLAGS](../d3d12/ne-d3d12-d3d12_command_list_support_flags.md)
    ///enumeration. Indicates the video command queue that the video extension targets. Only one value from the
    ///enumeration can be set.
    D3D12_COMMAND_LIST_SUPPORT_FLAGS CommandListSupportFlags;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12_FEATURE_VIDEO_EXTENSION_COMMANDS](ne-d3d12video-d3d12_feature_video.md). Retrieves the list of
///video extension commands from the driver.
struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS
{
    ///For single GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the
    ///device's physical adapter) to which the command queue applies. Each bit in the mask corresponds to a single node.
    ///Only 1 bit may be set.
    uint NodeIndex;
    ///The supported number of video extension commands. This value must be the count returned by a call
    ///to[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) with
    ///[D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_COUNT](ne-d3d12video-d3d12_feature_video.md) specified as the feature.
    uint CommandCount;
    ///Receives a list of [D3D12_VIDEO_EXTENSION_COMMAND_INFO](ns-d3d12video-d3d12_video_extension_command_info.md)
    ///structures describing video extension commands.
    D3D12_VIDEO_EXTENSION_COMMAND_INFO* pCommandInfos;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT](ne-d3d12video-d3d12_feature_video.md). Retrieves
///the number of video extension command parameters for the specified parameter stage.
struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT
{
    ///The unique identifier for the video extension command for which the parameter count is queried.
    GUID CommandId;
    ///A member of the
    ///[D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE](ne-d3d12video-d3d12_video_extension_command_parameter_stage.md)
    ///enumeration specifying the parameter stage for which the parameter count is retrieved.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE Stage;
    ///Receives the number of parameters in the parameter stage.
    uint ParameterCount;
    ///Receives the parameter packing for the parameter stage.
    uint ParameterPacking;
}

///Describes a video extension command parameter.
struct D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO
{
    ///A pointer to a wide string containing the name of the command.
    const(PWSTR) Name;
    ///A member of the
    ///[D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE](ne-d3d12video-d3d12_video_extension_command_parameter_type.md)
    ///specifying the type of the parameter.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE Type;
    ///A member of the
    ///[D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS](ne-d3d12video-d3d12_video_extension_command_parameter_flags.md)
    ///enumeration specifying the usage of the parameter.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS Flags;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETERS](ne-d3d12video-d3d12_feature_video.md). Retrieves the
///list of video extension command parameters for the specified parameter stage.
struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS
{
    ///The unique identifier for the video extension command for which parameters are retrieved.
    GUID CommandId;
    ///A member of the
    ///[D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE](ne-d3d12video-d3d12_video_extension_command_parameter_stage.md)
    ///enumeration specifying the parameter stage for which the parameters are retrieved.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE Stage;
    ///The supported number of video extension command parameters. This value must be the count returned by a call
    ///to[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) with
    ///[D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT](ne-d3d12video-d3d12_feature_video.md) specified as the
    ///feature.
    uint ParameterCount;
    ///Receives a list of
    ///[D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO](ns-d3d12video-d3d12_video_extension_command_parameter_info.md)
    ///structures describing video extension command parameters.
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO* pParameterInfos;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_SUPPORT](ne-d3d12video-d3d12_feature_video.md). Retrieves video
///extension command support using command-defined input and output structures.
struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT
{
    ///For single GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the
    ///device's physical adapter) to which the command queue applies. Each bit in the mask corresponds to a single node.
    ///Only 1 bit may be set.
    uint         NodeIndex;
    ///The unique identifier for the video extension command for which support is queried.
    GUID         CommandId;
    ///Input data for the capability query allocated by the caller with a size of *InputDataSizeInBytes*. This struct is
    ///enumerable as the
    ///[D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CAPS_INPUT](ne-d3d12video-d3d12_video_extension_command_parameter_stage.md)
    ///parameter stage.
    const(void)* pInputData;
    ///The byte size of the input data allocation.
    size_t       InputDataSizeInBytes;
    ///Output data for the capability query allocated by the caller with a size of *OutputDataSizeInBytes*. This struct
    ///is enumerable as the
    ///[D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CAPS_OUTPUT](ne-d3d12video-d3d12_video_extension_command_parameter_stage.md)
    ///parameter stage.
    void*        pOutputData;
    ///The byte size of the output data allocation.
    size_t       OutputDataSizeInBytes;
}

///Provides data for calls to
///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) when the feature
///specified is [D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_SIZE](ne-d3d12video-d3d12_feature_video.md). Checks the
///allocation size of a video extension command.
struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE
{
    ///For single GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the
    ///device's physical adapter) to which the command queue applies. Each bit in the mask corresponds to a single node.
    ///Only 1 bit may be set.
    uint         NodeIndex;
    ///The unique identifier for the video extension command for which size is queried.
    GUID         CommandId;
    ///A pointer to the creation parameters structure, which is defined by the command. The parameters structure must
    ///match the parameters enumerated by a call to
    ///[ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) with the feature
    ///value of [D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETERS](ne-d3d12video-d3d12_feature_video.md) and a parameter
    ///stage value of
    ///[D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CREATION](ne-d3d12video-d3d12_video_extension_command_parameter_stage.md).
    const(void)* pCreationParameters;
    ///The size of the *pCreationParameters* parameter structure, in bytes.
    size_t       CreationParametersSizeInBytes;
    ///The allocation size of the video extension command in the L0 memory pool. L0 is the physical system memory pool.
    ///When the adapter is discrete/NUMA, this pool has greater bandwidth for the CPU and less bandwidth for the GPU.
    ///When the adapter is UMA, this pool is the only one which is valid. For more information, see
    ///[Residency](/windows/win32/direct3d12/residency).
    ulong        MemoryPoolL0Size;
    ///The allocation size of the video extension command heap in the L1 memory pool. L1 is typically known as the
    ///physical video memory pool. L1 is only available when the adapter is discrete/NUMA, and has greater bandwidth for
    ///the GPU and cannot even be accessed by the CPU. When the adapter is UMA, this pool is not available. For more
    ///information, see [Residency](/windows/win32/direct3d12/residency).
    ulong        MemoryPoolL1Size;
}

///Describes a video extension command.
struct D3D12_VIDEO_EXTENSION_COMMAND_DESC
{
    ///For single GPU operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node (the
    ///device's physical adapter) to which the command queue applies. Each bit in the mask corresponds to a single node.
    ///Only 1 bit may be set.
    uint NodeMask;
    ///The unique identifier for the video extension command.
    GUID CommandId;
}

///Contains quality metrics for acoustic echo cancellation (AEC). This structure is used with the
///MFPKEY_WMAAECMA_RETRIEVE_TS_STATS property.
struct AecQualityMetrics_Struct
{
    ///Time stamp that indicates when the quality metrics were collected.
    long  i64Timestamp;
    ///AEC convergence flag.
    ubyte ConvergenceFlag;
    ///If <b>TRUE</b>, the input signal from the audio capture device was clipped.
    ubyte MicClippedFlag;
    ///If <b>TRUE</b>, the input signal from the audio capture device was silent or too quiet.
    ubyte MicSilenceFlag;
    ///If <b>TRUE</b>, positive feedback is causing a chirping sound.
    ubyte PstvFeadbackFlag;
    ///If <b>TRUE</b>, the input signal from the audio rendering device was clipped.
    ubyte SpkClippedFlag;
    ///If <b>TRUE</b>, the input signal from the audio rendering device was silent or too quiet.
    ubyte SpkMuteFlag;
    ///A glitch occurred in the input data.
    ubyte GlitchFlag;
    ///Double talk flag.
    ubyte DoubleTalkFlag;
    ///Number of glitches.
    uint  uGlitchCount;
    ///Number of times the audio capture signal was clipped.
    uint  uMicClipCount;
    ///Running duration of the AEC process.
    float fDuration;
    ///Long-term average variance in the time stamps.
    float fTSVariance;
    ///Long-term average drift rate in the time stamps.
    float fTSDriftRate;
    ///Near-end voice level after AEC processing.
    float fVoiceLevel;
    ///Noise level of the audio capture signal.
    float fNoiseLevel;
    ///Echo return loss enhancement (ERLE).
    float fERLE;
    ///Average ERLE over the entire duration of AEC processing.
    float fAvgERLE;
    ///Reserved
    uint  dwReserved;
}

///The <b>TOC_DESCRIPTOR</b> structure holds descriptive information for a table of contents.
struct TOC_DESCRIPTOR
{
    ///A globally unique identifier (<b>GUID</b>) that identifies an individual table of contents. This identifier has
    ///meaning only to the you, the developer. TOC Parser does not inspect or interpret this identifier.
    GUID   guidID;
    ///Not used.
    ushort wStreamNumber;
    ///A globally unique identifier (<b>GUID</b>) that identifies a table of contents as belonging to a particular type.
    ///This identifier has meaning only to you, the developer. TOC Parser does not inspect or interpret this identifier.
    ///See Remarks.
    GUID   guidType;
    ///An integer that identifies the language of a table of contents. This index has meaning only to you, the
    ///developer. TOC Parser does not inspect or interpret this index.
    ushort wLanguageIndex;
}

///The <b>TOC_ENTRY_DESCRIPTOR</b> structure holds descriptive information for an entry in a table of contents. An entry
///in a table of contents describes a portion of a media file. For example, an entry might describe a ten-second chunk
///of video that starts 90 seconds after the beginning of a video file.
struct TOC_ENTRY_DESCRIPTOR
{
    ///The start time, in 100-nanosecond units, of the portion of a media file represented by an entry in a table of
    ///contents.
    ulong qwStartTime;
    ///The end time, in 100-nanosecond units, of the portion of a media file represented by an entry in a table of
    ///contents.
    ulong qwEndTime;
    ///Not used.
    ulong qwStartPacketOffset;
    ///Not used.
    ulong qwEndPacketOffset;
    ///The presentation time, in 100-nanosecond units, of a frame that is a good representation of the entry. This frame
    ///could be used for a thumbnail image that represents the entry.
    ulong qwRepresentativeFrameTime;
}

struct DXVA_AYUVsample2
{
    ubyte bCrValue;
    ubyte bCbValue;
    ubyte bY_Value;
    ubyte bSampleAlpha8;
}

struct DXVA_BufferDescription
{
align (1):
    uint dwTypeIndex;
    uint dwBufferIndex;
    uint dwDataOffset;
    uint dwDataSize;
    uint dwFirstMBaddress;
    uint dwNumMBsInBuffer;
    uint dwWidth;
    uint dwHeight;
    uint dwStride;
    uint dwReservedBits;
}

struct DXVA_ConfigPictureDecode
{
align (1):
    uint    dwFunction;
    uint[3] dwReservedBits;
    GUID    guidConfigBitstreamEncryption;
    GUID    guidConfigMBcontrolEncryption;
    GUID    guidConfigResidDiffEncryption;
    ubyte   bConfigBitstreamRaw;
    ubyte   bConfigMBcontrolRasterOrder;
    ubyte   bConfigResidDiffHost;
    ubyte   bConfigSpatialResid8;
    ubyte   bConfigResid8Subtraction;
    ubyte   bConfigSpatialHost8or9Clipping;
    ubyte   bConfigSpatialResidInterleaved;
    ubyte   bConfigIntraResidUnsigned;
    ubyte   bConfigResidDiffAccelerator;
    ubyte   bConfigHostInverseScan;
    ubyte   bConfigSpecificIDCT;
    ubyte   bConfig4GroupedCoefs;
}

struct DXVA_PictureParameters
{
align (1):
    ushort wDecodedPictureIndex;
    ushort wDeblockedPictureIndex;
    ushort wForwardRefPictureIndex;
    ushort wBackwardRefPictureIndex;
    ushort wPicWidthInMBminus1;
    ushort wPicHeightInMBminus1;
    ubyte  bMacroblockWidthMinus1;
    ubyte  bMacroblockHeightMinus1;
    ubyte  bBlockWidthMinus1;
    ubyte  bBlockHeightMinus1;
    ubyte  bBPPminus1;
    ubyte  bPicStructure;
    ubyte  bSecondField;
    ubyte  bPicIntra;
    ubyte  bPicBackwardPrediction;
    ubyte  bBidirectionalAveragingMode;
    ubyte  bMVprecisionAndChromaRelation;
    ubyte  bChromaFormat;
    ubyte  bPicScanFixed;
    ubyte  bPicScanMethod;
    ubyte  bPicReadbackRequests;
    ubyte  bRcontrol;
    ubyte  bPicSpatialResid8;
    ubyte  bPicOverflowBlocks;
    ubyte  bPicExtrapolation;
    ubyte  bPicDeblocked;
    ubyte  bPicDeblockConfined;
    ubyte  bPic4MVallowed;
    ubyte  bPicOBMC;
    ubyte  bPicBinPB;
    ubyte  bMV_RPS;
    ubyte  bReservedBits;
    ushort wBitstreamFcodes;
    ushort wBitstreamPCEelements;
    ubyte  bBitstreamConcealmentNeed;
    ubyte  bBitstreamConcealmentMethod;
}

///Specifies the dimensions and pixel format of the uncompressed surfaces for DirectX Video Acceleration (DXVA) video
///decoding.
struct DXVAUncompDataInfo
{
    ///The width of the uncompressed data, in pixels.
    uint      UncompWidth;
    ///The height of the uncompressed data, in pixels.
    uint      UncompHeight;
    ///The pixel format of the uncompressed data, specified as a <b>D3DFORMAT</b> value.
    D3DFORMAT UncompFormat;
}

///Specifies the requirements for compressed surfaces for DirectX Video Acceleration (DXVA). To get this information,
///call IDirect3DVideoDevice9::GetDXVACompressedBufferInfo. Each <b>DXVACompBufferInfo</b> structure gives the
///requirements for a specific DXVA surface type. The surface type is defined implicitly by the index of the array that
///is passed into the <i>pBufferInfo</i> parameter.
struct DXVACompBufferInfo
{
    ///The number of surfaces of this type to create.
    uint      NumCompBuffers;
    ///The width of the surface, in pixels.
    uint      WidthToCreate;
    ///The height of the surface, in pixels.
    uint      HeightToCreate;
    ///The size of the surface, in bytes.
    uint      BytesToAllocate;
    ///A bitwise <b>OR</b> of one or more <b>D3DUSAGE</b> constants.
    uint      Usage;
    ///The memory pool in which to create the surface, specified as a <b>D3DPOOL</b> value.
    D3DPOOL   Pool;
    ///The pixel format, specified as a <b>D3DFORMAT</b> value.
    D3DFORMAT Format;
}

///Specifies a buffer for the IDirect3DDXVADevice9::Execute method.
struct DXVABufferInfo
{
    ///A pointer to the <b>IDirect3DSurface9</b> interface.
    void* pCompSurface;
    ///The offset of the relevant data from the beginning of the buffer, in bytes.
    uint  DataOffset;
    ///The size of the relevant data in the buffer, in bytes.
    uint  DataSize;
}

struct DXVA_ExtendedFormat
{
    uint _bitfield64;
}

struct DXVA_Frequency
{
    uint Numerator;
    uint Denominator;
}

struct DXVA_VideoDesc
{
    uint           Size;
    uint           SampleWidth;
    uint           SampleHeight;
    uint           SampleFormat;
    D3DFORMAT      d3dFormat;
    DXVA_Frequency InputSampleFreq;
    DXVA_Frequency OutputFrameFreq;
}

struct DXVA_VideoSample
{
    long              rtStart;
    long              rtEnd;
    DXVA_SampleFormat SampleFormat;
    void*             lpDDSSrcSurface;
}

struct DXVA_VideoSample2
{
    long                 rtStart;
    long                 rtEnd;
    uint                 SampleFormat;
    uint                 SampleFlags;
    void*                lpDDSSrcSurface;
    RECT                 rcSrc;
    RECT                 rcDst;
    DXVA_AYUVsample2[16] Palette;
}

struct DXVA_DeinterlaceCaps
{
    uint                 Size;
    uint                 NumPreviousOutputFrames;
    uint                 InputPool;
    uint                 NumForwardRefSamples;
    uint                 NumBackwardRefSamples;
    D3DFORMAT            d3dOutputFormat;
    DXVA_VideoProcessCaps VideoProcessingCaps;
    DXVA_DeinterlaceTech DeinterlaceTechnology;
}

struct DXVA_DeinterlaceBlt
{
    uint                 Size;
    uint                 Reserved;
    long                 rtTarget;
    RECT                 DstRect;
    RECT                 SrcRect;
    uint                 NumSourceSurfaces;
    float                Alpha;
    DXVA_VideoSample[32] Source;
}

struct DXVA_DeinterlaceBltEx
{
    uint             Size;
    DXVA_AYUVsample2 BackgroundColor;
    RECT             rcTarget;
    long             rtTarget;
    uint             NumSourceSurfaces;
    float            Alpha;
    DXVA_VideoSample2[32] Source;
    uint             DestinationFormat;
    uint             DestinationFlags;
}

struct DXVA_DeinterlaceQueryAvailableModes
{
    uint     Size;
    uint     NumGuids;
    GUID[32] Guids;
}

struct DXVA_DeinterlaceQueryModeCaps
{
    uint           Size;
    GUID           Guid;
    DXVA_VideoDesc VideoDesc;
}

struct DXVA_ProcAmpControlCaps
{
    uint      Size;
    uint      InputPool;
    D3DFORMAT d3dOutputFormat;
    uint      ProcAmpControlProps;
    uint      VideoProcessingCaps;
}

struct DXVA_ProcAmpControlQueryRange
{
    uint           Size;
    DXVA_ProcAmpControlProp ProcAmpControlProp;
    DXVA_VideoDesc VideoDesc;
}

struct DXVA_VideoPropertyRange
{
    float MinValue;
    float MaxValue;
    float DefaultValue;
    float StepSize;
}

struct DXVA_ProcAmpControlBlt
{
    uint  Size;
    RECT  DstRect;
    RECT  SrcRect;
    float Alpha;
    float Brightness;
    float Contrast;
    float Hue;
    float Saturation;
}

struct DXVA_COPPSignature
{
    ubyte[256] Signature;
}

struct DXVA_COPPCommand
{
    GUID        macKDI;
    GUID        guidCommandID;
    uint        dwSequence;
    uint        cbSizeData;
    ubyte[4056] CommandData;
}

struct DXVA_COPPStatusInput
{
    GUID        rApp;
    GUID        guidStatusRequestID;
    uint        dwSequence;
    uint        cbSizeData;
    ubyte[4056] StatusData;
}

struct DXVA_COPPStatusOutput
{
    GUID        macKDI;
    uint        cbSizeData;
    ubyte[4076] COPPStatus;
}

///Contains a rational number (ratio).
struct DXVAHD_RATIONAL
{
    ///The numerator of the ratio.
    uint Numerator;
    ///The denominator of the ratio.
    uint Denominator;
}

///Specifies an RGB color value.
struct DXVAHD_COLOR_RGBA
{
    ///The red value.
    float R;
    ///The green value.
    float G;
    ///The blue value.
    float B;
    ///The alpha value. Values range from 0 (transparent) to 1 (opaque).
    float A;
}

///Specifies a YCbCr color value.
struct DXVAHD_COLOR_YCbCrA
{
    ///The Y (luma) value.
    float Y;
    ///The Cb chroma value.
    float Cb;
    ///The Cr chroma value.
    float Cr;
    ///The alpha value. Values range from 0 (transparent) to 1 (opaque).
    float A;
}

///Defines a color value for DXVA-HD.
union DXVAHD_COLOR
{
    ///A [DXVAHD_COLOR_RGBA](./ns-dxvahd-dxvahd_color_rgba.md) structure that contains an RGB color value.
    DXVAHD_COLOR_RGBA   RGB;
    ///A [DXVAHD_COLOR_YCbCrA](./ns-dxvahd-dxvahd_color_ycbcra.md) structure that contains a YCbCr color value.
    DXVAHD_COLOR_YCbCrA YCbCr;
}

///Describes a video stream for a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video processor. The
///display driver can use the information in this structure to optimize the capabilities of the video processor. For
///example, some capabilities might not be exposed for high-definition (HD) content, for performance reasons.
struct DXVAHD_CONTENT_DESC
{
    ///A member of the DXVAHD_FRAME_FORMAT enumeration that describes how the video stream is interlaced.
    DXVAHD_FRAME_FORMAT InputFrameFormat;
    ///The frame rate of the input video stream, specified as a DXVAHD_RATIONAL structure.
    DXVAHD_RATIONAL     InputFrameRate;
    ///The width of the input frames, in pixels.
    uint                InputWidth;
    ///The height of the input frames, in pixels.
    uint                InputHeight;
    ///The frame rate of the output video stream, specified as a DXVAHD_RATIONAL structure.
    DXVAHD_RATIONAL     OutputFrameRate;
    ///The width of the output frames, in pixels.
    uint                OutputWidth;
    ///The height of the output frames, in pixels.
    uint                OutputHeight;
}

///Specifies the capabilities of a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.
struct DXVAHD_VPDEVCAPS
{
    ///Specifies the device type, as a member of the DXVAHD_DEVICE_TYPE enumeration.
    DXVAHD_DEVICE_TYPE DeviceType;
    ///A bitwise <b>OR</b> of zero or more flags from the DXVAHD_DEVICE_CAPS enumeration.
    uint               DeviceCaps;
    ///A bitwise <b>OR</b> of zero or more flags from the DXVAHD_FEATURE_CAPS enumeration.
    uint               FeatureCaps;
    ///A bitwise <b>OR</b> of zero or more flags from the DXVAHD_FILTER_CAPS enumeration.
    uint               FilterCaps;
    ///A bitwise <b>OR</b> of zero or more flags from the DXVAHD_INPUT_FORMAT_CAPS enumeration.
    uint               InputFormatCaps;
    ///The memory pool that is required for the input video surfaces.
    D3DPOOL            InputPool;
    ///The number of supported output formats. To get the list of output formats, call the
    ///IDXVAHD_Device::GetVideoProcessorOutputFormats method.
    uint               OutputFormatCount;
    ///The number of supported input formats. To get the list of input formats, call the
    ///IDXVAHD_Device::GetVideoProcessorInputFormats method.
    uint               InputFormatCount;
    ///The number of video processors. Each video processor represents a distinct set of processing capabilities. To get
    ///the capabilities of each video processor, call the IDXVAHD_Device::GetVideoProcessorCaps method. To create a
    ///video processor, call the IDXVAHD_Device::CreateVideoProcessor method.
    uint               VideoProcessorCount;
    ///The maximum number of input streams that can be enabled at the same time.
    uint               MaxInputStreams;
    ///The maximum number of input streams for which the device can store state data.
    uint               MaxStreamStates;
}

///Specifies the capabilities of the Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video processor.
struct DXVAHD_VPCAPS
{
    ///A GUID that identifies the video processor. This GUID is defined by the device, and is used in various
    ///IDXVAHD_Device methods to specify the video processor.
    GUID VPGuid;
    ///The number of past reference frames required to perform the optimal video processing.
    uint PastFrames;
    ///The number of future reference frames required to perform the optimal video processing.
    uint FutureFrames;
    ///A bitwise <b>OR</b> of zero or more flags from the DXVAHD_PROCESSOR_CAPS enumeration.
    uint ProcessorCaps;
    ///A bitwise <b>OR</b> of zero or more flags from the DXVAHD_ITELECINE_CAPS enumeration.
    uint ITelecineCaps;
    ///The number of custom output frame rates. To get the list of custom frame rates, call the
    ///IDXVAHD_Device::GetVideoProcessorCustomRates method. Custom frame rates are used for frame-rate conversion and
    ///inverse telecine.
    uint CustomRateCount;
}

///Specifies a custom rate for frame-rate conversion or inverse telecine (IVTC).
struct DXVAHD_CUSTOM_RATE_DATA
{
    ///The ratio of the output frame rate to the input frame rate, expressed as a DXVAHD_RATIONAL structure that holds a
    ///rational number.
    DXVAHD_RATIONAL CustomRate;
    ///The number of output frames that will be generated for every <i>N</i> input samples, where <i>N</i> =
    ///<b>InputFramesOrFields</b>.
    uint            OutputFrames;
    ///If <b>TRUE</b>, the input stream must be interlaced<b></b>. Otherwise, the input stream must be progressive.
    BOOL            InputInterlaced;
    ///The number of input fields or frames for every <i>N</i> output frames that will be generated, where <i>N</i> =
    ///<b>OutputFrames</b>.
    uint            InputFramesOrFields;
}

///Defines the range of supported values for an image filter.
struct DXVAHD_FILTER_RANGE_DATA
{
    ///The minimum value of the filter.
    int   Minimum;
    ///The maximum value of the filter.
    int   Maximum;
    ///The default value of the filter.
    int   Default;
    ///A multiplier. Use the following formula to translate the filter setting into the actual filter value: <i>Actual
    ///Value</i> = <i>Set Value</i> Ã— <i>Multiplier</i>.
    float Multiplier;
}

///Specifies the target rectangle for blitting, when using Microsoft DirectX Video Acceleration High Definition
///(DXVA-HD).
struct DXVAHD_BLT_STATE_TARGET_RECT_DATA
{
    ///Specifies whether to use the target rectangle. The default state value is <b>FALSE</b>. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TRUE"></a><a id="true"></a><dl>
    ///<dt><b>TRUE</b></dt> </dl> </td> <td width="60%"> Use the target rectangle specified by the <b>TargetRect</b>
    ///member. </td> </tr> <tr> <td width="40%"><a id="FALSE"></a><a id="false"></a><dl> <dt><b>FALSE</b></dt> </dl>
    ///</td> <td width="60%"> Use the entire destination surface as the target rectangle. Ignore the <b>TargetRect</b>
    ///member. </td> </tr> </table>
    BOOL Enable;
    ///Specifies the <i>target rectangle</i>. The target rectangle is the area within the destination surface where the
    ///output will be drawn. The target rectangle is given in pixel coordinates, relative to the destination surface.
    ///The default state value is an empty rectangle, (0, 0, 0, 0). If the <b>Enable</b> member is <b>FALSE</b>, the
    ///<b>TargetRect</b> member is ignored.
    RECT TargetRect;
}

///Specifies the background color for blit operations, when using Microsoft DirectX Video Acceleration High Definition
///(DXVA-HD).
struct DXVAHD_BLT_STATE_BACKGROUND_COLOR_DATA
{
    ///If <b>TRUE</b>, the <b>BackgroundColor</b> member specifies a YCbCr color. Otherwise, it specifies an RGB color.
    ///The default device state is <b>FALSE</b> (RGB color).
    BOOL         YCbCr;
    ///A DXVAHD_COLOR union that specifies the background color. The default state value is (0.0, 0.0, 0.0, 1.0).
    DXVAHD_COLOR BackgroundColor;
}

///Specifies the output color space for blit operations, when using Microsoft DirectX Video Acceleration High Definition
///(DXVA-HD).
struct DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA
{
union
    {
struct
        {
            uint _bitfield65;
        }
        uint Value;
    }
}

///Specifies how the output alpha values are calculated for blit operations when using Microsoft DirectX Video
///Acceleration High Definition (DXVA-HD).
struct DXVAHD_BLT_STATE_ALPHA_FILL_DATA
{
    ///Specifies the alpha fill mode, as a member of the DXVAHD_ALPHA_FILL_MODE enumeration. If the <b>FeatureCaps</b>
    ///member of the DXVAHD_VPDEVCAPS structure does not contain the <b>DXVAHD_FEATURE_CAPS_ALPHA_FILL</b> flag, the
    ///alpha fill mode must be set to <b>DXVAHD_ALPHA_FILL_MODE_OPAQUE</b>. The default state value is
    ///<b>DXVAHD_ALPHA_FILL_MODE_OPAQUE</b>.
    DXVAHD_ALPHA_FILL_MODE Mode;
    ///Zero-based index of the input stream to use for the alpha values. This member is used when the alpha fill mode is
    ///<b>DXVAHD_ALPHA_FILL_MODE_SOURCE_STREAM</b>; otherwise, the value is ignored. To get the maximum number of
    ///streams, call IDXVAHD_Device::GetVideoProcessorDeviceCaps and check the <b>MaxStreamStates</b> member of the
    ///DXVAHD_VPDEVCAPS structure.
    uint StreamNumber;
}

///Specifies whether the output is downsampled in a blit operation, when using Microsoft DirectX Video Acceleration High
///Definition (DXVA-HD).
struct DXVAHD_BLT_STATE_CONSTRICTION_DATA
{
    ///If <b>TRUE</b>, downsampling is enabled<b></b>. Otherwise, downsampling is disabled and the <b>Size</b> member is
    ///ignored. The default state value is <b>FALSE</b> (downsampling is disabled).
    BOOL Enable;
    ///The sampling size. The default value is (1,1).
    SIZE Size;
}

///Contains data for a private blit state for Microsoft DirectX Video Acceleration High Definition (DXVA-HD).
struct DXVAHD_BLT_STATE_PRIVATE_DATA
{
    ///A GUID that identifies the private state. The meaning of this value is defined by the device.
    GUID  Guid;
    ///The size, in bytes, of the buffer pointed to by the <b>pData</b> member.
    uint  DataSize;
    ///A pointer to a buffer that contains the private state data. The DXVA-HD runtime passes this buffer directly to
    ///the device without validation.
    void* pData;
}

///Specifies the format for an input stream, when using Microsoft DirectX Video Acceleration High Definition (DXVA-HD).
struct DXVAHD_STREAM_STATE_D3DFORMAT_DATA
{
    ///The surface format, specified as a <b>D3DFORMAT</b> value. You can also use a FOURCC code to specify a format
    ///that is not defined in the <b>D3DFORMAT</b> enumeration. For more information, see Video FOURCCs. The default
    ///state value is <b>D3DFMT_UNKNOWN</b>.
    D3DFORMAT Format;
}

///Specifies how a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) input stream is interlaced.
struct DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA
{
    ///The video interlacing, specified as a DXVAHD_FRAME_FORMAT value. The default state value is
    ///<b>DXVAHD_FRAME_FORMAT_PROGRESSIVE</b> (progressive frames).
    DXVAHD_FRAME_FORMAT FrameFormat;
}

///Specifies the color space for a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) input stream.
struct DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA
{
union
    {
struct
        {
            uint _bitfield66;
        }
        uint Value;
    }
}

///Specifies the output frame rate for an input stream when using Microsoft DirectX Video Acceleration High Definition
///(DXVA-HD).
struct DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA
{
    ///Specifies how the device performs frame-rate conversion, if required. The default state value is <b>FALSE</b>
    ///(interpolation). <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TRUE"></a><a
    ///id="true"></a><dl> <dt><b>TRUE</b></dt> </dl> </td> <td width="60%"> The device repeats frames. </td> </tr> <tr>
    ///<td width="40%"><a id="FALSE"></a><a id="false"></a><dl> <dt><b>FALSE</b></dt> </dl> </td> <td width="60%"> The
    ///device interpolates frames. </td> </tr> </table>
    BOOL               RepeatFrame;
    ///Specifies the output rate, as a member of the DXVAHD_OUTPUT_RATE enumeration.
    DXVAHD_OUTPUT_RATE OutputRate;
    ///Specifies a custom output rate, as a DXVAHD_RATIONAL structure. This member is ignored unless <b>OutputRate</b>
    ///equals <b>DXVAHD_OUTPUT_RATE_CUSTOM</b>. The default state value is 1/1. To get the list of custom rates
    ///supported by the video processor, call IDXVAHD_Device::GetVideoProcessorCustomRates. If a custom rate is used, it
    ///must be taken from this list.
    DXVAHD_RATIONAL    CustomRate;
}

///Specifies the source rectangle for an input stream when using Microsoft DirectX Video Acceleration High Definition
///(DXVA-HD)
struct DXVAHD_STREAM_STATE_SOURCE_RECT_DATA
{
    ///<b></b>Specifies whether to blit the entire input surface or just the source rectangle. The default state value
    ///is <b>FALSE</b>. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TRUE"></a><a
    ///id="true"></a><dl> <dt><b>TRUE</b></dt> </dl> </td> <td width="60%"> Use the source rectangle specified in the
    ///<b>SourceRect</b> member. </td> </tr> <tr> <td width="40%"><a id="FALSE"></a><a id="false"></a><dl>
    ///<dt><b>FALSE</b></dt> </dl> </td> <td width="60%"> Blit the entire input surface. Ignore the <b>SourceRect</b>
    ///member. </td> </tr> </table>
    BOOL Enable;
    ///The <i>source rectangle</i>, which defines the portion of the input sample that is blitted to the destination
    ///surface. The source rectangle is given in pixel coordinates, relative to the input surface. The default state
    ///value is an empty rectangle, (0, 0, 0, 0). If the <b>Enable</b> member is <b>FALSE</b>, the <b>SourceRect</b>
    ///member is ignored.
    RECT SourceRect;
}

///Specifies the destination rectangle for an input stream, when using Microsoft DirectX Video Acceleration High
///Definition (DXVA-HD).
struct DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA
{
    ///Specifies whether to use the destination rectangle, or use the entire output surface. The default state value is
    ///<b>FALSE</b>. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TRUE"></a><a
    ///id="true"></a><dl> <dt><b>TRUE</b></dt> </dl> </td> <td width="60%"> Use the destination rectangle given in the
    ///<b>DestinationRect</b> member. </td> </tr> <tr> <td width="40%"><a id="FALSE"></a><a id="false"></a><dl>
    ///<dt><b>FALSE</b></dt> </dl> </td> <td width="60%"> Use the entire output surface as the destination rectangle.
    ///</td> </tr> </table>
    BOOL Enable;
    ///The <i>destination rectangle</i>, which defines the portion of the output surface where the source rectangle is
    ///blitted. The destination rectangle is given in pixel coordinates, relative to the output surface. The default
    ///value is an empty rectangle, (0, 0, 0, 0). If the <b>Enable</b> member is <b>FALSE</b>, the
    ///<b>DestinationRect</b> member is ignored.
    RECT DestinationRect;
}

///Specifies the planar alpha value for an input stream, when using Microsoft DirectX Video Acceleration High Definition
///(DXVA-HD).
struct DXVAHD_STREAM_STATE_ALPHA_DATA
{
    ///<b>If TRUE</b>, alpha blending is enabled. Otherwise, alpha blending is disabled. The default state value is
    ///<b>FALSE</b>.
    BOOL  Enable;
    ///Specifies the planar alpha value as a floating-point number from 0.0 (transparent) to 1.0 (opaque). If the
    ///<b>Enable</b> member is <b>FALSE</b>, this member is ignored.
    float Alpha;
}

///Contains the color palette entries for an input stream, when using Microsoft DirectX Video Acceleration High
///Definition (DXVA-HD).
struct DXVAHD_STREAM_STATE_PALETTE_DATA
{
    ///The number of palette entries. The default state value is 0.
    uint  Count;
    ///A pointer to an array of <b>D3DCOLOR</b> values. For RGB streams, the palette entries use a D3DFMT_A8R8G8B8
    ///(ARGB-32) representation. For YCbCr streams, the palette entries use an AYUV representation. The alpha channel is
    ///used for alpha blending; see DXVAHD_STREAM_STATE_ALPHA_DATA.
    uint* pEntries;
}

///Specifies the luma key for an input stream, when using Microsoft DirectX Video Acceleration High Definition
///(DXVA-HD).
struct DXVAHD_STREAM_STATE_LUMA_KEY_DATA
{
    ///If <b>TRUE</b>, luma keying is enabled. Otherwise, luma keying is disabled. The default value is <b>FALSE</b>.
    BOOL  Enable;
    ///The lower bound for the luma key. The range is [0â€¦1]. The default state value is 0.0.
    float Lower;
    ///The upper bound for the luma key. The range is [0â€¦1]. The default state value is 0.0.
    float Upper;
}

///Specifies the pixel aspect ratio (PAR) for the source and destination rectangles.
struct DXVAHD_STREAM_STATE_ASPECT_RATIO_DATA
{
    ///<b>If TRUE</b>, the <b>SourceAspectRatio</b> and <b>DestinationAspectRatio</b> members contain valid
    ///values<b></b>. Otherwise, the pixel aspect ratios are unspecified.
    BOOL            Enable;
    ///A DXVAHD_RATIONAL structure that contains the source PAR. The default state value is 1:1 (square pixels).
    DXVAHD_RATIONAL SourceAspectRatio;
    ///A DXVAHD_RATIONAL structure that contains the destination PAR. The default state value is 1:1 (square pixels).
    DXVAHD_RATIONAL DestinationAspectRatio;
}

///Specifies the level for a filtering operation on a Microsoft DirectX Video Acceleration High Definition (DXVA-HD)
///input stream.
struct DXVAHD_STREAM_STATE_FILTER_DATA
{
    ///<b>If TRUE</b>, the filter is enabled. Otherwise, <b>the filter is disabled</b>.
    BOOL Enable;
    ///The level for the filter. The meaning of this value depends on the implementation. To get the range and default
    ///value of a particular filter, call the IDXVAHD_Device::GetVideoProcessorFilterRange method. If the <b>Enable</b>
    ///member is <b>FALSE</b>, the <b>Level</b> member is ignored.
    int  Level;
}

///Contains data for a private stream state, for a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) input
///stream.
struct DXVAHD_STREAM_STATE_PRIVATE_DATA
{
    ///A GUID that identifies the private stream state. The following GUID is defined. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="DXVAHD_STREAM_STATE_PRIVATE_IVTC"></a><a
    ///id="dxvahd_stream_state_private_ivtc"></a><dl> <dt><b>DXVAHD_STREAM_STATE_PRIVATE_IVTC</b></dt> </dl> </td> <td
    ///width="60%"> Retrieves statistics about inverse telecine. The state data (<b>pData</b>) is a
    ///DXVAHD_STREAM_STATE_PRIVATE_IVTC_DATA structure. </td> </tr> </table> A device can define additional GUIDs for
    ///use with custom stream states. The interpretation of the data is then defined by the device.
    GUID  Guid;
    ///The size, in bytes, of the buffer pointed to by the <b>pData</b> member.
    uint  DataSize;
    ///A pointer to a buffer that contains the private state data. The DXVA-HD runtime passes this buffer directly to
    ///the device, without validation.
    void* pData;
}

///Contains per-stream data for the IDXVAHD_VideoProcessor::VideoProcessBltHD method.
struct DXVAHD_STREAM_DATA
{
    ///Specifies whether this input stream is enabled. If the value is <b>TRUE</b>, the VideoProcessBltHD method blits
    ///this stream to the output surface<b></b>. Otherwise, the stream is not blitted. The maximum number of streams
    ///that can be enabled at one time is given in the <b>MaxInputStreams</b> member of the DXVAHD_VPDEVCAPS structure.
    BOOL               Enable;
    ///The zero-based index number of the output frame. See Remarks.
    uint               OutputIndex;
    ///The zero-based index number of the input frame or field. See Remarks.
    uint               InputFrameOrField;
    ///The number of past reference frames. This value must be less than or equal to the value of the <b>PastFrames</b>
    ///member of the DXVAHD_VPCAPS structure.
    uint               PastFrames;
    ///The number of future reference frames. This value must be less than or equal to the value of the
    ///<b>FutureFrames</b> member of the DXVAHD_VPCAPS structure.
    uint               FutureFrames;
    ///A pointer to an array of IDirect3DSurface9 pointers, allocated by the caller. This array contains the past
    ///reference frames for the video processing operation. The number of elements in the array is equal to the value of
    ///the <b>PastFrames</b> member.
    IDirect3DSurface9* ppPastSurfaces;
    ///A pointer to the IDirect3DSurface9 interface of a Microsoft Direct3D surface that contains the current input
    ///frame.
    IDirect3DSurface9  pInputSurface;
    ///A pointer to an array of IDirect3DSurface9 pointers, allocated by the caller. This array contains the future
    ///reference frames for the video processing operation. The number of elements in the array is equal to the value of
    ///the <b>FutureFrames</b> member.
    IDirect3DSurface9* ppFutureSurfaces;
}

///Contains inverse telecine (IVTC) statistics from a Microsoft DirectX Video Acceleration High Definition (DXVA-HD)
///device.
struct DXVAHD_STREAM_STATE_PRIVATE_IVTC_DATA
{
    ///Specifies whether IVTC statistics are enabled. The default state value is <b>FALSE</b>. Setting the value to
    ///<b>TRUE</b> enables IVTC statistics, and resets all of the IVTC statistical data to zero.
    BOOL Enable;
    ///If the driver detects that the frames are telecined, and is able to perform inverse telecine, this field contains
    ///a member of the DXVAHD_ITELECINE_CAPS enumeration. Otherwise, the value is 0.
    uint ITelecineFlags;
    ///The number of consecutive telecined frames that the device has detected.
    uint Frames;
    ///The index of the most recent input field. The value of this member equals the most recent value of the
    ///<b>InputFrameOrField</b> member of the DXVAHD_STREAM_DATA structure.
    uint InputField;
}

///Contains pointers to functions implemented by a software plug-in for Microsoft DirectX Video Acceleration High
///Definition (DXVA-HD).
struct DXVAHDSW_CALLBACKS
{
    ///Function pointer of type PDXVAHDSW_CreateDevice.
    PDXVAHDSW_CreateDevice CreateDevice;
    ///Function pointer of type PDXVAHDSW_ProposeVideoPrivateFormat.
    PDXVAHDSW_ProposeVideoPrivateFormat ProposeVideoPrivateFormat;
    ///Function pointer of type PDXVAHDSW_GetVideoProcessorDeviceCaps.
    PDXVAHDSW_GetVideoProcessorDeviceCaps GetVideoProcessorDeviceCaps;
    ///Function pointer of type PDXVAHDSW_GetVideoProcessorOutputFormats.
    PDXVAHDSW_GetVideoProcessorOutputFormats GetVideoProcessorOutputFormats;
    ///Function pointer of type PDXVAHDSW_GetVideoProcessorInputFormats.
    PDXVAHDSW_GetVideoProcessorInputFormats GetVideoProcessorInputFormats;
    ///Function pointer of type PDXVAHDSW_GetVideoProcessorCaps.
    PDXVAHDSW_GetVideoProcessorCaps GetVideoProcessorCaps;
    ///Function pointer of type PDXVAHDSW_GetVideoProcessorCustomRates.
    PDXVAHDSW_GetVideoProcessorCustomRates GetVideoProcessorCustomRates;
    ///Function pointer of type PDXVAHDSW_GetVideoProcessorFilterRange.
    PDXVAHDSW_GetVideoProcessorFilterRange GetVideoProcessorFilterRange;
    ///Function pointer of type PDXVAHDSW_DestroyDevice.
    PDXVAHDSW_DestroyDevice DestroyDevice;
    ///Function pointer of type PDXVAHDSW_CreateVideoProcessor.
    PDXVAHDSW_CreateVideoProcessor CreateVideoProcessor;
    ///Function pointer of type PDXVAHDSW_SetVideoProcessBltState.
    PDXVAHDSW_SetVideoProcessBltState SetVideoProcessBltState;
    ///Function pointer of type PDXVAHDSW_GetVideoProcessBltStatePrivate.
    PDXVAHDSW_GetVideoProcessBltStatePrivate GetVideoProcessBltStatePrivate;
    ///Function pointer of type PDXVAHDSW_SetVideoProcessStreamState.
    PDXVAHDSW_SetVideoProcessStreamState SetVideoProcessStreamState;
    ///Function pointer of type PDXVAHDSW_GetVideoProcessStreamStatePrivate.
    PDXVAHDSW_GetVideoProcessStreamStatePrivate GetVideoProcessStreamStatePrivate;
    ///Function pointer of type PDXVAHDSW_VideoProcessBltHD.
    PDXVAHDSW_VideoProcessBltHD VideoProcessBltHD;
    ///Function pointer of type PDXVAHDSW_DestroyVideoProcessor.
    PDXVAHDSW_DestroyVideoProcessor DestroyVideoProcessor;
}

struct DXVAHDETW_CREATEVIDEOPROCESSOR
{
    ulong pObject;
    ulong pD3D9Ex;
    GUID  VPGuid;
}

struct DXVAHDETW_VIDEOPROCESSBLTSTATE
{
    ulong            pObject;
    DXVAHD_BLT_STATE State;
    uint             DataSize;
    BOOL             SetState;
}

struct DXVAHDETW_VIDEOPROCESSSTREAMSTATE
{
    ulong               pObject;
    uint                StreamNumber;
    DXVAHD_STREAM_STATE State;
    uint                DataSize;
    BOOL                SetState;
}

struct DXVAHDETW_VIDEOPROCESSBLTHD
{
    ulong     pObject;
    ulong     pOutputSurface;
    RECT      TargetRect;
    D3DFORMAT OutputFormat;
    uint      ColorSpace;
    uint      OutputFrame;
    uint      StreamCount;
    BOOL      Enter;
}

struct DXVAHDETW_VIDEOPROCESSBLTHD_STREAM
{
    ulong               pObject;
    ulong               pInputSurface;
    RECT                SourceRect;
    RECT                DestinationRect;
    D3DFORMAT           InputFormat;
    DXVAHD_FRAME_FORMAT FrameFormat;
    uint                ColorSpace;
    uint                StreamNumber;
    uint                OutputIndex;
    uint                InputFrameOrField;
    uint                PastFrames;
    uint                FutureFrames;
}

struct DXVAHDETW_DESTROYVIDEOPROCESSOR
{
    ulong pObject;
}

///Describes the format of a video stream.
struct DXVA2_ExtendedFormat
{
union
    {
struct
        {
            uint _bitfield67;
        }
        uint value;
    }
}

///Defines a video frequency.
struct DXVA2_Frequency
{
    ///Numerator of the frequency.
    uint Numerator;
    ///Denominator of the frequency.
    uint Denominator;
}

///Describes a video stream for a DXVA decoder device or video processor device.
struct DXVA2_VideoDesc
{
    ///Width of the video frame, in pixels.
    uint                 SampleWidth;
    ///Height of the video frame, in pixels.
    uint                 SampleHeight;
    ///Additional details about the video format, specified as a DXVA2_ExtendedFormat structure.
    DXVA2_ExtendedFormat SampleFormat;
    ///Surface format, specified as a <b>D3DFORMAT</b> value or FOURCC code. A FOURCC code can be constructed using the
    ///<b>D3DFORMAT</b> or <b>MAKEFOURCC</b> macros.
    D3DFORMAT            Format;
    ///Frame rate of the input video stream, specified as a DXVA2_Frequency structure.
    DXVA2_Frequency      InputSampleFreq;
    ///Frame rate of the output video, specified as a DXVA2_Frequency structure.
    DXVA2_Frequency      OutputFrameFreq;
    ///Level of data protection required when the user accessible bus (UAB) is present. If <b>TRUE</b>, the video must
    ///be protected when a UAB is present. If <b>FALSE</b>, the video is not required to be protected.
    uint                 UABProtectionLevel;
    ///Reserved. Must be zero.
    uint                 Reserved;
}

///Describes the capabilities of a DirectX Video Acceleration (DVXA) video processor mode.
struct DXVA2_VideoProcessorCaps
{
    ///Identifies the type of device. The following values are defined. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="DXVA2_VPDev_EmulatedDXVA1"></a><a id="dxva2_vpdev_emulateddxva1"></a><a
    ///id="DXVA2_VPDEV_EMULATEDDXVA1"></a><dl> <dt><b>DXVA2_VPDev_EmulatedDXVA1</b></dt> </dl> </td> <td width="60%">
    ///DXVA 2.0 video processing is emulated by using DXVA 1.0. An emulated device may be missing significant processing
    ///capabilities and have lower image quality and performance. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_VPDev_HardwareDevice"></a><a id="dxva2_vpdev_hardwaredevice"></a><a
    ///id="DXVA2_VPDEV_HARDWAREDEVICE"></a><dl> <dt><b>DXVA2_VPDev_HardwareDevice</b></dt> </dl> </td> <td width="60%">
    ///Hardware device. </td> </tr> <tr> <td width="40%"><a id="DXVA2_VPDev_SoftwareDevice"></a><a
    ///id="dxva2_vpdev_softwaredevice"></a><a id="DXVA2_VPDEV_SOFTWAREDEVICE"></a><dl>
    ///<dt><b>DXVA2_VPDev_SoftwareDevice</b></dt> </dl> </td> <td width="60%"> Software device. </td> </tr> </table>
    uint    DeviceCaps;
    ///The Direct3D memory pool used by the device.
    D3DPOOL InputPool;
    ///Number of forward reference samples the device needs to perform deinterlacing. For the bob, progressive scan, and
    ///software devices, the value is zero.
    uint    NumForwardRefSamples;
    ///Number of backward reference samples the device needs to perform deinterlacing. For the bob, progressive scan,
    ///and software devices, the value is zero.
    uint    NumBackwardRefSamples;
    ///Reserved. Must be zero.
    uint    Reserved;
    ///Identifies the deinteracing technique used by the device. This value is a bitwise <b>OR</b> of one or more of the
    ///following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_DeinterlaceTech_Unknown"></a><a id="dxva2_deinterlacetech_unknown"></a><a
    ///id="DXVA2_DEINTERLACETECH_UNKNOWN"></a><dl> <dt><b>DXVA2_DeinterlaceTech_Unknown</b></dt> </dl> </td> <td
    ///width="60%"> The algorithm is unknown or proprietary. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_DeinterlaceTech_BOBLineReplicate"></a><a id="dxva2_deinterlacetech_boblinereplicate"></a><a
    ///id="DXVA2_DEINTERLACETECH_BOBLINEREPLICATE"></a><dl> <dt><b>DXVA2_DeinterlaceTech_BOBLineReplicate</b></dt> </dl>
    ///</td> <td width="60%"> The algorithm creates missing lines by repeating the line either above or below the
    ///missing line. This algorithm produces a jagged image and is not recommended. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_DeinterlaceTech_BOBVerticalStretch"></a><a id="dxva2_deinterlacetech_bobverticalstretch"></a><a
    ///id="DXVA2_DEINTERLACETECH_BOBVERTICALSTRETCH"></a><dl> <dt><b>DXVA2_DeinterlaceTech_BOBVerticalStretch</b></dt>
    ///</dl> </td> <td width="60%"> The algorithm creates missing lines by averaging two lines. Slight vertical
    ///adjustments are made so that the resulting image does not bob up and down. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_DeinterlaceTech_BOBVerticalStretch4Tap"></a><a id="dxva2_deinterlacetech_bobverticalstretch4tap"></a><a
    ///id="DXVA2_DEINTERLACETECH_BOBVERTICALSTRETCH4TAP"></a><dl>
    ///<dt><b>DXVA2_DeinterlaceTech_BOBVerticalStretch4Tap</b></dt> </dl> </td> <td width="60%"> The algorithm creates
    ///missing lines by applying a [âˆ’1, 9, 9, âˆ’1]/16 filter across four lines. Slight vertical adjustments are made
    ///so that the resulting image does not bob up and down. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_DeinterlaceTech_MedianFiltering"></a><a id="dxva2_deinterlacetech_medianfiltering"></a><a
    ///id="DXVA2_DEINTERLACETECH_MEDIANFILTERING"></a><dl> <dt><b>DXVA2_DeinterlaceTech_MedianFiltering</b></dt> </dl>
    ///</td> <td width="60%"> The algorithm uses median filtering to recreate the pixels in the missing lines. </td>
    ///</tr> <tr> <td width="40%"><a id="DXVA2_DeinterlaceTech_EdgeFiltering"></a><a
    ///id="dxva2_deinterlacetech_edgefiltering"></a><a id="DXVA2_DEINTERLACETECH_EDGEFILTERING"></a><dl>
    ///<dt><b>DXVA2_DeinterlaceTech_EdgeFiltering</b></dt> </dl> </td> <td width="60%"> The algorithm uses an edge
    ///filter to create the missing lines. In this process, spatial directional filters are applied to determine the
    ///orientation of edges in the picture content. Missing pixels are created by filtering along (rather than across)
    ///the detected edges. </td> </tr> <tr> <td width="40%"><a id="DXVA2_DeinterlaceTech_FieldAdaptive"></a><a
    ///id="dxva2_deinterlacetech_fieldadaptive"></a><a id="DXVA2_DEINTERLACETECH_FIELDADAPTIVE"></a><dl>
    ///<dt><b>DXVA2_DeinterlaceTech_FieldAdaptive</b></dt> </dl> </td> <td width="60%"> The algorithm uses spatial or
    ///temporal interpolation, switching between the two on a field-by-field basis, depending on the amount of motion.
    ///</td> </tr> <tr> <td width="40%"><a id="DXVA2_DeinterlaceTech_PixelAdaptive"></a><a
    ///id="dxva2_deinterlacetech_pixeladaptive"></a><a id="DXVA2_DEINTERLACETECH_PIXELADAPTIVE"></a><dl>
    ///<dt><b>DXVA2_DeinterlaceTech_PixelAdaptive</b></dt> </dl> </td> <td width="60%"> The algorithm uses spatial or
    ///temporal interpolation, switching between the two on a pixel-by-pixel basis, depending on the amount of motion.
    ///</td> </tr> <tr> <td width="40%"><a id="DXVA2_DeinterlaceTech_MotionVectorSteered"></a><a
    ///id="dxva2_deinterlacetech_motionvectorsteered"></a><a id="DXVA2_DEINTERLACETECH_MOTIONVECTORSTEERED"></a><dl>
    ///<dt><b>DXVA2_DeinterlaceTech_MotionVectorSteered</b></dt> </dl> </td> <td width="60%"> The algorithm identifies
    ///objects within a sequence of video fields. Before it recreates the missing pixels, it aligns the movement axes of
    ///the individual objects in the scene to make them parallel with the time axis. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_DeinterlaceTech_InverseTelecine"></a><a id="dxva2_deinterlacetech_inversetelecine"></a><a
    ///id="DXVA2_DEINTERLACETECH_INVERSETELECINE"></a><dl> <dt><b>DXVA2_DeinterlaceTech_InverseTelecine</b></dt> </dl>
    ///</td> <td width="60%"> The device can undo the 3:2 pulldown process used in telecine. </td> </tr> </table>
    uint    DeinterlaceTechnology;
    ///Specifies the available video processor (ProcAmp) operations. The value is a bitwise OR of ProcAmp Settings
    ///constants.
    uint    ProcAmpControlCaps;
    ///Specifies operations that the device can perform concurrently with the IDirectXVideoProcessor::VideoProcessBlt
    ///operation. The value is a bitwise <b>OR</b> of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="DXVA2_VideoProcess_YUV2RGB"></a><a id="dxva2_videoprocess_yuv2rgb"></a><a
    ///id="DXVA2_VIDEOPROCESS_YUV2RGB"></a><dl> <dt><b>DXVA2_VideoProcess_YUV2RGB</b></dt> </dl> </td> <td width="60%">
    ///The device can convert the video from YUV color space to RGB color space, with at least 8 bits of precision for
    ///each RGB component. </td> </tr> <tr> <td width="40%"><a id="DXVA2_VideoProcess_StretchX"></a><a
    ///id="dxva2_videoprocess_stretchx"></a><a id="DXVA2_VIDEOPROCESS_STRETCHX"></a><dl>
    ///<dt><b>DXVA2_VideoProcess_StretchX</b></dt> </dl> </td> <td width="60%"> The device can stretch or shrink the
    ///video horizontally. If this capability is present, aspect ratio correction can be performed at the same time as
    ///deinterlacing. </td> </tr> <tr> <td width="40%"><a id="DXVA2_VideoProcess_StretchY"></a><a
    ///id="dxva2_videoprocess_stretchy"></a><a id="DXVA2_VIDEOPROCESS_STRETCHY"></a><dl>
    ///<dt><b>DXVA2_VideoProcess_StretchY</b></dt> </dl> </td> <td width="60%"> The device can stretch or shrink the
    ///video vertically. If this capability is present, image resizing and aspect ratio correction can be performed at
    ///the same time. </td> </tr> <tr> <td width="40%"><a id="DXVA2_VideoProcess_AlphaBlend"></a><a
    ///id="dxva2_videoprocess_alphablend"></a><a id="DXVA2_VIDEOPROCESS_ALPHABLEND"></a><dl>
    ///<dt><b>DXVA2_VideoProcess_AlphaBlend</b></dt> </dl> </td> <td width="60%"> The device can alpha blend the video.
    ///</td> </tr> <tr> <td width="40%"><a id="DXVA2_VideoProcess_SubRects"></a><a
    ///id="dxva2_videoprocess_subrects"></a><a id="DXVA2_VIDEOPROCESS_SUBRECTS"></a><dl>
    ///<dt><b>DXVA2_VideoProcess_SubRects</b></dt> </dl> </td> <td width="60%"> The device can operate on a subrectangle
    ///of the video frame. If this capability is present, source images can be cropped before further processing occurs.
    ///</td> </tr> <tr> <td width="40%"><a id="DXVA2_VideoProcess_SubStreams"></a><a
    ///id="dxva2_videoprocess_substreams"></a><a id="DXVA2_VIDEOPROCESS_SUBSTREAMS"></a><dl>
    ///<dt><b>DXVA2_VideoProcess_SubStreams</b></dt> </dl> </td> <td width="60%"> The device can accept substreams in
    ///addition to the primary video stream, and can composite them. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_VideoProcess_SubStreamsExtended"></a><a id="dxva2_videoprocess_substreamsextended"></a><a
    ///id="DXVA2_VIDEOPROCESS_SUBSTREAMSEXTENDED"></a><dl> <dt><b>DXVA2_VideoProcess_SubStreamsExtended</b></dt> </dl>
    ///</td> <td width="60%"> The device can perform color adjustments on the primary video stream and substreams, at
    ///the same time that it deinterlaces the video and composites the substreams. The destination color space is
    ///defined in the <b>DestFormat</b> member of the DXVA2_VideoProcessBltParams structure. The source color space for
    ///each stream is defined in the SampleFormat member of the DXVA2_VideoSample structure. </td> </tr> <tr> <td
    ///width="40%"><a id="DXVA2_VideoProcess_YUV2RGBExtended"></a><a id="dxva2_videoprocess_yuv2rgbextended"></a><a
    ///id="DXVA2_VIDEOPROCESS_YUV2RGBEXTENDED"></a><dl> <dt><b>DXVA2_VideoProcess_YUV2RGBExtended</b></dt> </dl> </td>
    ///<td width="60%"> The device can convert the video from YUV to RGB color space when it writes the deinterlaced and
    ///composited pixels to the destination surface. An RGB destination surface could be an off-screen surface, texture,
    ///Direct3D render target, or combined texture/render target surface. An RGB destination surface must use at least 8
    ///bits for each color channel. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_VideoProcess_AlphaBlendExtended"></a><a id="dxva2_videoprocess_alphablendextended"></a><a
    ///id="DXVA2_VIDEOPROCESS_ALPHABLENDEXTENDED"></a><dl> <dt><b>DXVA2_VideoProcess_AlphaBlendExtended</b></dt> </dl>
    ///</td> <td width="60%"> The device can perform an alpha blend operation with the destination surface when it
    ///writes the deinterlaced and composited pixels to the destination surface. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_VideoProcess_Constriction"></a><a id="dxva2_videoprocess_constriction"></a><a
    ///id="DXVA2_VIDEOPROCESS_CONSTRICTION"></a><dl> <dt><b>DXVA2_VideoProcess_Constriction</b></dt> </dl> </td> <td
    ///width="60%"> The device can downsample the output frame, as specified by the <b>ConstrictionSize</b> member of
    ///the DXVA2_VideoProcessBltParams structure. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_VideoProcess_NoiseFilter"></a><a id="dxva2_videoprocess_noisefilter"></a><a
    ///id="DXVA2_VIDEOPROCESS_NOISEFILTER"></a><dl> <dt><b>DXVA2_VideoProcess_NoiseFilter</b></dt> </dl> </td> <td
    ///width="60%"> The device can perform noise filtering. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_VideoProcess_DetailFilter"></a><a id="dxva2_videoprocess_detailfilter"></a><a
    ///id="DXVA2_VIDEOPROCESS_DETAILFILTER"></a><dl> <dt><b>DXVA2_VideoProcess_DetailFilter</b></dt> </dl> </td> <td
    ///width="60%"> The device can perform detail filtering. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_VideoProcess_PlanarAlpha"></a><a id="dxva2_videoprocess_planaralpha"></a><a
    ///id="DXVA2_VIDEOPROCESS_PLANARALPHA"></a><dl> <dt><b>DXVA2_VideoProcess_PlanarAlpha</b></dt> </dl> </td> <td
    ///width="60%"> The device can perform a constant alpha blend to the entire video stream when it composites the
    ///video stream and substreams. </td> </tr> <tr> <td width="40%"><a id="DXVA2_VideoProcess_LinearScaling"></a><a
    ///id="dxva2_videoprocess_linearscaling"></a><a id="DXVA2_VIDEOPROCESS_LINEARSCALING"></a><dl>
    ///<dt><b>DXVA2_VideoProcess_LinearScaling</b></dt> </dl> </td> <td width="60%"> The device can perform accurate
    ///linear RGB scaling, rather than performing them in nonlinear gamma space. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_VideoProcess_GammaCompensated"></a><a id="dxva2_videoprocess_gammacompensated"></a><a
    ///id="DXVA2_VIDEOPROCESS_GAMMACOMPENSATED"></a><dl> <dt><b>DXVA2_VideoProcess_GammaCompensated</b></dt> </dl> </td>
    ///<td width="60%"> The device can correct the image to compensate for artifacts introduced when performing scaling
    ///in nonlinear gamma space. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_VideoProcess_MaintainsOriginalFieldData"></a><a
    ///id="dxva2_videoprocess_maintainsoriginalfielddata"></a><a
    ///id="DXVA2_VIDEOPROCESS_MAINTAINSORIGINALFIELDDATA"></a><dl>
    ///<dt><b>DXVA2_VideoProcess_MaintainsOriginalFieldData</b></dt> </dl> </td> <td width="60%"> The deinterlacing
    ///algorithm preserves the original field lines from the interlaced field picture, unless scaling is also applied.
    ///For example, in deinterlacing algorithms such as bob and median filtering, the device copies the original field
    ///into every other scan line and then applies a filter to reconstruct the missing scan lines. As a result, the
    ///original field can be recovered by discarding the scan lines that were interpolated. If the image is scaled
    ///vertically, however, the original field lines cannot be recovered. If the image is scaled horizontally (but not
    ///vertically), the resulting field lines will be equivalent to scaling the original field picture. (In other words,
    ///discarding the interpolated scan lines will yield the same result as stretching the original picture without
    ///deinterlacing.) </td> </tr> </table>
    uint    VideoProcessorOperations;
    ///Specifies the supported noise filters. The value is a bitwise <b>OR</b> of the following flags. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DXVA2_NoiseFilterTech_Unsupported"></a><a
    ///id="dxva2_noisefiltertech_unsupported"></a><a id="DXVA2_NOISEFILTERTECH_UNSUPPORTED"></a><dl>
    ///<dt><b>DXVA2_NoiseFilterTech_Unsupported</b></dt> </dl> </td> <td width="60%"> Noise filtering is not supported.
    ///</td> </tr> <tr> <td width="40%"><a id="DXVA2_NoiseFilterTech_Unknown"></a><a
    ///id="dxva2_noisefiltertech_unknown"></a><a id="DXVA2_NOISEFILTERTECH_UNKNOWN"></a><dl>
    ///<dt><b>DXVA2_NoiseFilterTech_Unknown</b></dt> </dl> </td> <td width="60%"> Unknown or proprietary filter. </td>
    ///</tr> <tr> <td width="40%"><a id="DXVA2_NoiseFilterTech_Median"></a><a id="dxva2_noisefiltertech_median"></a><a
    ///id="DXVA2_NOISEFILTERTECH_MEDIAN"></a><dl> <dt><b>DXVA2_NoiseFilterTech_Median</b></dt> </dl> </td> <td
    ///width="60%"> Median filter. </td> </tr> <tr> <td width="40%"><a id="DXVA2_NoiseFilterTech_Temporal"></a><a
    ///id="dxva2_noisefiltertech_temporal"></a><a id="DXVA2_NOISEFILTERTECH_TEMPORAL"></a><dl>
    ///<dt><b>DXVA2_NoiseFilterTech_Temporal</b></dt> </dl> </td> <td width="60%"> Temporal filter. </td> </tr> <tr> <td
    ///width="40%"><a id="DXVA2_NoiseFilterTech_BlockNoise"></a><a id="dxva2_noisefiltertech_blocknoise"></a><a
    ///id="DXVA2_NOISEFILTERTECH_BLOCKNOISE"></a><dl> <dt><b>DXVA2_NoiseFilterTech_BlockNoise</b></dt> </dl> </td> <td
    ///width="60%"> Block noise filter. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_NoiseFilterTech_MosquitoNoise"></a><a id="dxva2_noisefiltertech_mosquitonoise"></a><a
    ///id="DXVA2_NOISEFILTERTECH_MOSQUITONOISE"></a><dl> <dt><b>DXVA2_NoiseFilterTech_MosquitoNoise</b></dt> </dl> </td>
    ///<td width="60%"> Mosquito noise filter. </td> </tr> </table>
    uint    NoiseFilterTechnology;
    ///Specifies the supported detail filters. The value is a bitwise <b>OR</b> of the following flags. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DXVA2_DetailFilterTech_Unsupported"></a><a
    ///id="dxva2_detailfiltertech_unsupported"></a><a id="DXVA2_DETAILFILTERTECH_UNSUPPORTED"></a><dl>
    ///<dt><b>DXVA2_DetailFilterTech_Unsupported</b></dt> </dl> </td> <td width="60%"> Detail filtering is not
    ///supported. </td> </tr> <tr> <td width="40%"><a id="DXVA2_DetailFilterTech_Unknown"></a><a
    ///id="dxva2_detailfiltertech_unknown"></a><a id="DXVA2_DETAILFILTERTECH_UNKNOWN"></a><dl>
    ///<dt><b>DXVA2_DetailFilterTech_Unknown</b></dt> </dl> </td> <td width="60%"> Unknown or proprietary filter. </td>
    ///</tr> <tr> <td width="40%"><a id="DXVA2_DetailFilterTech_Edge"></a><a id="dxva2_detailfiltertech_edge"></a><a
    ///id="DXVA2_DETAILFILTERTECH_EDGE"></a><dl> <dt><b>DXVA2_DetailFilterTech_Edge</b></dt> </dl> </td> <td
    ///width="60%"> Edge filter. </td> </tr> <tr> <td width="40%"><a id="DXVA2_DetailFilterTech_Sharpening"></a><a
    ///id="dxva2_detailfiltertech_sharpening"></a><a id="DXVA2_DETAILFILTERTECH_SHARPENING"></a><dl>
    ///<dt><b>DXVA2_DetailFilterTech_Sharpening</b></dt> </dl> </td> <td width="60%"> Sharpen filter. </td> </tr>
    ///</table>
    uint    DetailFilterTechnology;
}

///Defines a 32-bit fixed-point number.
struct DXVA2_Fixed32
{
union
    {
struct
        {
            ushort Fraction;
            short  Value;
        }
        int ll;
    }
}

///Defines an 8-bit AYUV pixel value.
struct DXVA2_AYUVSample8
{
    ///Contains the Cr chroma value (also called V).
    ubyte Cr;
    ///Contains the Cb chroma value (also called U).
    ubyte Cb;
    ///Contains the luma value.
    ubyte Y;
    ///Contains the alpha value.
    ubyte Alpha;
}

///Defines a 16-bit AYUV pixel value.
struct DXVA2_AYUVSample16
{
    ///Contains the Cr chroma value (also called V).
    ushort Cr;
    ///Contains the Cb chroma value (also called U).
    ushort Cb;
    ///Contains the luma value.
    ushort Y;
    ///Contains the alpha value.
    ushort Alpha;
}

///Specifies an input sample for the IDirectXVideoProcessor::VideoProcessBlt method.
struct DXVA2_VideoSample
{
    ///Start time of the sample, in 100-nanosecond units. For video substream samples, the value is zero.
    long                 Start;
    ///End time of the sample, in 100-nanosecond units. For video substream samples, the value is zero.
    long                 End;
    ///DXVA2_ExtendedFormat structure that describes the interlacing and extended color information for the sample.
    DXVA2_ExtendedFormat SampleFormat;
    ///Pointer to the IDirect3DSurface9 interface of the Direct3D surface that contains the sample.
    IDirect3DSurface9    SrcSurface;
    ///Source rectangle. The source rectangle defines which portion of the input sample is copied to the destination
    ///surface. The source rectangle is specified using pixel coordinates on the input surface.
    RECT                 SrcRect;
    ///Destination rectangle. The destination rectangle defines the portion of the destination surface where the source
    ///rectangle is copied. The destination rectangle is specified using pixel coordinates on the destination surface.
    RECT                 DstRect;
    ///If the input sample is for a substream and uses a palettized YUV color format, this member contains an array of
    ///DXVA2_AYUVSample8 structures that define the palette entries. For non-palettized pixel formats, the array
    ///elements should all be zero.
    DXVA2_AYUVSample8[16] Pal;
    ///Alpha value that will be applied to this input sample when it is composited.
    DXVA2_Fixed32        PlanarAlpha;
    ///Contains additional flags. The following flags are defined. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="DXVA2_SampleData_RFF"></a><a id="dxva2_sampledata_rff"></a><a
    ///id="DXVA2_SAMPLEDATA_RFF"></a><dl> <dt><b>DXVA2_SampleData_RFF</b></dt> </dl> </td> <td width="60%"> Repeat first
    ///field (RFF) bit. </td> </tr> <tr> <td width="40%"><a id="DXVA2_SampleData_TFF"></a><a
    ///id="dxva2_sampledata_tff"></a><a id="DXVA2_SAMPLEDATA_TFF"></a><dl> <dt><b>DXVA2_SampleData_TFF</b></dt> </dl>
    ///</td> <td width="60%"> Top field first (TFF) bit. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_SampleData_RFF_TFF_Present"></a><a id="dxva2_sampledata_rff_tff_present"></a><a
    ///id="DXVA2_SAMPLEDATA_RFF_TFF_PRESENT"></a><dl> <dt><b>DXVA2_SampleData_RFF_TFF_Present</b></dt> </dl> </td> <td
    ///width="60%"> If set, the RFF and TFF flags are used. </td> </tr> </table> These flags provide a hint to the
    ///deinterlacer when it performs inverse telecine.
    uint                 SampleData;
}

///Defines the range of supported values for a DirectX Video Acceleration (DXVA) operation.
struct DXVA2_ValueRange
{
    ///Minimum supported value.
    DXVA2_Fixed32 MinValue;
    ///Maximum supported value.
    DXVA2_Fixed32 MaxValue;
    ///Default value.
    DXVA2_Fixed32 DefaultValue;
    ///Minimum increment between values.
    DXVA2_Fixed32 StepSize;
}

///Contains values for DirectX Video Acceleration (DXVA) video processing operations.
struct DXVA2_ProcAmpValues
{
    ///Brightness value.
    DXVA2_Fixed32 Brightness;
    ///Contrast value.
    DXVA2_Fixed32 Contrast;
    ///Hue value.
    DXVA2_Fixed32 Hue;
    ///Saturation value.
    DXVA2_Fixed32 Saturation;
}

///Contains parameters for a DirectX Video Acceleration (DXVA) image filter.
struct DXVA2_FilterValues
{
    ///Filter level.
    DXVA2_Fixed32 Level;
    ///Filter threshold.
    DXVA2_Fixed32 Threshold;
    ///Filter radius.
    DXVA2_Fixed32 Radius;
}

///Contains parameters for the IDirectXVideoProcessor::VideoProcessBlt method.
struct DXVA2_VideoProcessBltParams
{
    ///Presentation time for the target frame, in 100-nanosecond units. If the video is interlaced, this value must be
    ///either the start time for the frame or the midpoint for the frame. If the video is progressive, this value must
    ///be the start time.
    long                 TargetFrame;
    ///Specifies the target rectangle, which is the rectangle within the destination surface where the output video
    ///frame is drawn. The target rectangle cannot be larger than the destination surface.
    RECT                 TargetRect;
    ///Size to which the output video should be downsampled. If this feature is supported, the driver sets the
    ///<b>DXVA2_VideoProcess_Constriction</b> flag in the DXVA2_VideoProcessorCaps structure. The downsampling size
    ///cannot be less than zero, or larger than the size of the target rectangle (<b>TargetRect</b>).
    SIZE                 ConstrictionSize;
    ///Reserved. Set to zero.
    uint                 StreamingFlags;
    ///A DXVA2_AYUVSample16 structure that specifies the background color for the destination rectangle. The background
    ///color is used wherever no video image appears, but only within the <b>TargetRect</b> rectangle. The color is
    ///specified as an AYUV color value with 16 bits per channel. The alpha channel (<b>Alpha</b>) must be opaque
    ///(0xFFFF). The DXVA driver should ignore the value of the alpha channel. The color space for the background color
    ///is given by the <b>DestFormat</b> member. Note that the background color is always specified as a YUV color, even
    ///if the destination surface is RGB.
    DXVA2_AYUVSample16   BackgroundColor;
    ///A DXVA2_ExtendedFormat structure that contains extended color information for the destination rectangle. For
    ///video playback, the recommended value for the nominal range is DXVA2_NominalRange_Unknown. For more information,
    ///see DXVA2_NominalRange enumeration.
    DXVA2_ExtendedFormat DestFormat;
    ///A DXVA2_ProcAmpValues structure that specifies color adjustment (ProcAmp) settings. These values must fall within
    ///the ranges returned by the IDirectXVideoProcessor::GetProcAmpRange method.
    DXVA2_ProcAmpValues  ProcAmpValues;
    ///Alpha value that is applied to the composited image when it is copied to the destination surface. The alpha value
    ///is fixed-point value, specified as a DXVA2_Fixed32 structure. To specify 100% opacity, use the
    ///DXVA2_Fixed32OpaqueAlpha function.
    DXVA2_Fixed32        Alpha;
    ///A DXVA2_FilterValues structure that contains parameters for the luma noise filter.
    DXVA2_FilterValues   NoiseFilterLuma;
    ///A DXVA2_FilterValues structure that contains parameters for the chroma noise filter.
    DXVA2_FilterValues   NoiseFilterChroma;
    ///A DXVA2_FilterValues structure that contains parameters for the luma detail filter.
    DXVA2_FilterValues   DetailFilterLuma;
    ///A DXVA2_FilterValues structure that contains parameters for the chroma detail filter.
    DXVA2_FilterValues   DetailFilterChroma;
    ///Contains additional flags. The following flags are defined. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="DXVA2_DestData_RFF"></a><a id="dxva2_destdata_rff"></a><a
    ///id="DXVA2_DESTDATA_RFF"></a><dl> <dt><b>DXVA2_DestData_RFF</b></dt> </dl> </td> <td width="60%"> Repeat first
    ///field (RFF) bit. </td> </tr> <tr> <td width="40%"><a id="DXVA2_DestData_TFF"></a><a
    ///id="dxva2_destdata_tff"></a><a id="DXVA2_DESTDATA_TFF"></a><dl> <dt><b>DXVA2_DestData_TFF</b></dt> </dl> </td>
    ///<td width="60%"> Top field first (TFF) bit. </td> </tr> <tr> <td width="40%"><a
    ///id="DXVA2_DestData_RFF_TFF_Present"></a><a id="dxva2_destdata_rff_tff_present"></a><a
    ///id="DXVA2_DESTDATA_RFF_TFF_PRESENT"></a><dl> <dt><b>DXVA2_DestData_RFF_TFF_Present</b></dt> </dl> </td> <td
    ///width="60%"> If set, the RFF and TFF flags are used. </td> </tr> </table> Currently, these flags are ignored.
    ///They are intended for use with interlaced output, which is not supported at this time.
    uint                 DestData;
}

///Describes the configuration of a DXVA decoder device.
struct DXVA2_ConfigPictureDecode
{
    ///Defines the encryption protocol type for bit-stream data buffers. If no encryption is applied, the value is
    ///DXVA_NoEncrypt. If <b>ConfigBitstreamRaw</b> is 0, the value must be DXVA_NoEncrypt.
    GUID   guidConfigBitstreamEncryption;
    ///Defines the encryption protocol type for macroblock control data buffers. If no encryption is applied, the value
    ///is DXVA_NoEncrypt. If <b>ConfigBitstreamRaw</b> is 1, the value must be DXVA_NoEncrypt.
    GUID   guidConfigMBcontrolEncryption;
    ///Defines the encryption protocol type for residual difference decoding data buffers (buffers containing
    ///spatial-domain data or sets of transform-domain coefficients for accelerator-based IDCT). If no encryption is
    ///applied, the value is DXVA_NoEncrypt. If <b>ConfigBitstreamRaw</b> is 1, the value must be DXVA_NoEncrypt.
    GUID   guidConfigResidDiffEncryption;
    ///Indicates whether the host-decoder sends raw bit-stream data. If the value is 1, the data for the pictures will
    ///be sent in bit-stream buffers as raw bit-stream content. If the value is 0, picture data will be sent using
    ///macroblock control command buffers. If either <b>ConfigResidDiffHost</b> or <b>ConfigResidDiffAccelerator</b> is
    ///1, the value must be 0.
    uint   ConfigBitstreamRaw;
    ///Specifies whether macroblock control commands are in raster scan order or in arbitrary order. If the value is 1,
    ///the macroblock control commands within each macroblock control command buffer are in raster-scan order. If the
    ///value is 0, the order is arbitrary. For some types of bit streams, forcing raster order either greatly increases
    ///the number of required macroblock control buffers that must be processed, or requires host reordering of the
    ///control information. Therefore, supporting arbitrary order can be more efficient.
    uint   ConfigMBcontrolRasterOrder;
    ///Contains the host residual difference configuration. If the value is 1, some residual difference decoding data
    ///may be sent as blocks in the spatial domain from the host. If the value is 0, spatial domain data will not be
    ///sent.
    uint   ConfigResidDiffHost;
    ///Indicates the word size used to represent residual difference spatial-domain blocks for predicted (non-intra)
    ///pictures when using host-based residual difference decoding. If <b>ConfigResidDiffHost</b> is 1 and
    ///<b>ConfigSpatialResid8</b> is 1, the host will send residual difference spatial-domain blocks for non-intra
    ///macroblocks using 8-bit signed samples and for intra macroblocks in predicted (non-intra) pictures in a format
    ///that depends on the value of <b>ConfigIntraResidUnsigned</b>: <ul> <li>If <b>ConfigIntraResidUnsigned</b> is 0,
    ///spatial-domain blocks for intra macroblocks are sent as 8-bit signed integer values relative to a constant
    ///reference value of 2^(BPPâ€“1). </li> <li>If <b>ConfigIntraResidUnsigned</b> is 1, spatial-domain blocks for
    ///intra macroblocks are sent as 8-bit unsigned integer values relative to a constant reference value of 0. </li>
    ///</ul> If <b>ConfigResidDiffHost</b> is 1 and <b>ConfigSpatialResid8</b> is 0, the host will send residual
    ///difference spatial-domain blocks of data for non-intra macroblocks using 16- bit signed samples and for intra
    ///macroblocks in predicted (non-intra) pictures in a format that depends on the value of
    ///<b>ConfigIntraResidUnsigned</b>: <ul> <li>If <b>ConfigIntraResidUnsigned</b> is 0, spatial domain blocks for
    ///intra macroblocks are sent as 16-bit signed integer values relative to a constant reference value of 2^(BPPâ€“1).
    ///</li> <li>If <b>ConfigIntraResidUnsigned</b> is 1, spatial domain blocks for intra macroblocks are sent as 16-bit
    ///unsigned integer values relative to a constant reference value of 0. </li> </ul> If <b>ConfigResidDiffHost</b> is
    ///0, <b>ConfigSpatialResid8</b> must be 0. For intra pictures, spatial-domain blocks must be sent using 8-bit
    ///samples if bits-per-pixel (BPP) is 8, and using 16-bit samples if BPP &gt; 8. If <b>ConfigIntraResidUnsigned</b>
    ///is 0, these samples are sent as signed integer values relative to a constant reference value of 2^(BPPâ€“1), and
    ///if <b>ConfigIntraResidUnsigned</b> is 1, these samples are sent as unsigned integer values relative to a constant
    ///reference value of 0.
    uint   ConfigSpatialResid8;
    ///If the value is 1, 8-bit difference overflow blocks are subtracted rather than added. The value must be 0 unless
    ///<b>ConfigSpatialResid8</b> is 1. The ability to subtract differences rather than add them enables 8-bit
    ///difference decoding to be fully compliant with the full Â±255 range of values required in video decoder
    ///specifications, because +255 cannot be represented as the addition of two signed 8-bit numbers, but any number in
    ///the range Â±255 can be represented as the difference between two signed 8-bit numbers (+255 = +127 minus â€“128).
    uint   ConfigResid8Subtraction;
    ///If the value is 1, spatial-domain blocks for intra macroblocks must be clipped to an 8-bit range on the host and
    ///spatial-domain blocks for non-intra macroblocks must be clipped to a 9-bit range on the host. If the value is 0,
    ///no such clipping is necessary by the host. The value must be 0 unless <b>ConfigSpatialResid8</b> is 0 and
    ///<b>ConfigResidDiffHost</b> is 1.
    uint   ConfigSpatialHost8or9Clipping;
    ///If the value is 1, any spatial-domain residual difference data must be sent in a chrominance-interleaved form
    ///matching the YUV format chrominance interleaving pattern. The value must be 0 unless <b>ConfigResidDiffHost</b>
    ///is 1 and the YUV format is NV12 or NV21.
    uint   ConfigSpatialResidInterleaved;
    ///Indicates the method of representation of spatial-domain blocks of residual difference data for intra blocks when
    ///using host-based difference decoding. If <b>ConfigResidDiffHost</b> is 1 and <b>ConfigIntraResidUnsigned</b> is
    ///0, spatial-domain residual difference data blocks for intra macroblocks must be sent as follows: <ul> <li>In a
    ///non-intra picture, if <b>ConfigSpatialResid8</b> is 0, the spatial-domain residual difference data blocks for
    ///intra macroblocks are sent as 16-bit signed integer values relative to a constant reference value of 2^(BPPâ€“1).
    ///</li> <li>In a non-intra picture, if <b>ConfigSpatialResid8</b> is 1, the spatial-domain residual difference data
    ///blocks for intra macroblocks are sent as 8-bit signed integer values relative to a constant reference value of
    ///2^(BPPâ€“1). </li> <li>In an intra picture, if BPP is 8, the spatial-domain residual difference data blocks for
    ///intra macroblocks are sent as 8-bit signed integer values relative to a constant reference value of 2^(BPPâ€“1),
    ///regardless of the value of <b>ConfigSpatialResid8</b>. </li> </ul> If <b>ConfigResidDiffHost</b> is 1 and
    ///<b>ConfigIntraResidUnsigned</b> is 1, spatial-domain residual difference data blocks for intra macroblocks must
    ///be sent as follows: <ul> <li>In a non-intra picture, if <b>ConfigSpatialResid8</b> is 0, the spatial-domain
    ///residual difference data blocks for intra macroblocks must be sent as 16-bit unsigned integer values relative to
    ///a constant reference value of 0. </li> <li>In a non-intra picture, if <b>ConfigSpatialResid8</b> is 1, the
    ///spatial-domain residual difference data blocks for intra macroblocks are sent as 8-bit unsigned integer values
    ///relative to a constant reference value of 0. </li> <li>In an intra picture, if BPP is 8, the spatial-domain
    ///residual difference data blocks for intra macroblocks are sent as 8-bit unsigned integer values relative to a
    ///constant reference value of 0, regardless of the value of <b>ConfigSpatialResid8</b>. </li> </ul> The value of
    ///the member must be 0 unless <b>ConfigResidDiffHost</b> is 1.
    uint   ConfigIntraResidUnsigned;
    ///If the value is 1, transform-domain blocks of coefficient data may be sent from the host for accelerator-based
    ///IDCT. If the value is 0, accelerator-based IDCT will not be used. If both <b>ConfigResidDiffHost</b> and
    ///<b>ConfigResidDiffAccelerator</b> are 1, this indicates that some residual difference decoding will be done on
    ///the host and some on the accelerator, as indicated by macroblock-level control commands. The value must be 0 if
    ///<b>ConfigBitstreamRaw</b> is 1.
    uint   ConfigResidDiffAccelerator;
    ///If the value is 1, the inverse scan for transform-domain block processing will be performed on the host, and
    ///absolute indices will be sent instead for any transform coefficients. If the value is 0, the inverse scan will be
    ///performed on the accelerator. The value must be 0 if <b>ConfigResidDiffAccelerator</b> is 0 or if
    ///<b>Config4GroupedCoefs</b> is 1.
    uint   ConfigHostInverseScan;
    ///If the value is 1, the IDCT specified in Annex W of ITU-T Recommendation H.263 is used. If the value is 0, any
    ///compliant IDCT can be used for off-host IDCT. The H.263 annex does not comply with the IDCT requirements of
    ///MPEG-2 corrigendum 2, so the value must not be 1 for use with MPEG-2 video. The value must be 0 if
    ///<b>ConfigResidDiffAccelerator</b> is 0, indicating purely host-based residual difference decoding.
    uint   ConfigSpecificIDCT;
    ///If the value is 1, transform coefficients for off-host IDCT will be sent using the DXVA_TCoef4Group structure. If
    ///the value is 0, the DXVA_TCoefSingle structure is used. The value must be 0 if <b>ConfigResidDiffAccelerator</b>
    ///is 0 or if <b>ConfigHostInverseScan</b> is 1.
    uint   Config4GroupedCoefs;
    ///Specifies how many frames the decoder device processes at any one time.
    ushort ConfigMinRenderTargetBuffCount;
    ///Contains decoder-specific configuration information.
    ushort ConfigDecoderSpecific;
}

///Describes a buffer sent from a decoder to a DirectX Video Acceleration (DXVA) device.
struct DXVA2_DecodeBufferDesc
{
    ///Identifies the type of buffer passed to the accelerator. Must be one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DXVA2_PictureParametersBufferType"></a><a
    ///id="dxva2_pictureparametersbuffertype"></a><a id="DXVA2_PICTUREPARAMETERSBUFFERTYPE"></a><dl>
    ///<dt><b>DXVA2_PictureParametersBufferType</b></dt> </dl> </td> <td width="60%"> Picture decoding parameter buffer.
    ///</td> </tr> <tr> <td width="40%"><a id="DXVA2_MacroBlockControlBufferType"></a><a
    ///id="dxva2_macroblockcontrolbuffertype"></a><a id="DXVA2_MACROBLOCKCONTROLBUFFERTYPE"></a><dl>
    ///<dt><b>DXVA2_MacroBlockControlBufferType</b></dt> </dl> </td> <td width="60%"> Macroblock control command buffer.
    ///</td> </tr> <tr> <td width="40%"><a id="DXVA2_ResidualDifferenceBufferType"></a><a
    ///id="dxva2_residualdifferencebuffertype"></a><a id="DXVA2_RESIDUALDIFFERENCEBUFFERTYPE"></a><dl>
    ///<dt><b>DXVA2_ResidualDifferenceBufferType</b></dt> </dl> </td> <td width="60%"> Residual difference block data
    ///buffer. </td> </tr> <tr> <td width="40%"><a id="DXVA2_DeblockingControlBufferType"></a><a
    ///id="dxva2_deblockingcontrolbuffertype"></a><a id="DXVA2_DEBLOCKINGCONTROLBUFFERTYPE"></a><dl>
    ///<dt><b>DXVA2_DeblockingControlBufferType</b></dt> </dl> </td> <td width="60%"> Deblocking filter control command
    ///buffer. </td> </tr> <tr> <td width="40%"><a id="DXVA2_InverseQuantizationMatrixBufferType"></a><a
    ///id="dxva2_inversequantizationmatrixbuffertype"></a><a id="DXVA2_INVERSEQUANTIZATIONMATRIXBUFFERTYPE"></a><dl>
    ///<dt><b>DXVA2_InverseQuantizationMatrixBufferType</b></dt> </dl> </td> <td width="60%"> Inverse quantization
    ///matrix buffer. </td> </tr> <tr> <td width="40%"><a id="DXVA2_SliceControlBufferType"></a><a
    ///id="dxva2_slicecontrolbuffertype"></a><a id="DXVA2_SLICECONTROLBUFFERTYPE"></a><dl>
    ///<dt><b>DXVA2_SliceControlBufferType</b></dt> </dl> </td> <td width="60%"> Slice-control buffer. </td> </tr> <tr>
    ///<td width="40%"><a id="DXVA2_BitStreamDateBufferType"></a><a id="dxva2_bitstreamdatebuffertype"></a><a
    ///id="DXVA2_BITSTREAMDATEBUFFERTYPE"></a><dl> <dt><b>DXVA2_BitStreamDateBufferType</b></dt> </dl> </td> <td
    ///width="60%"> Bitstream data buffer. </td> </tr> <tr> <td width="40%"><a id="DXVA2_MotionVectorBuffer"></a><a
    ///id="dxva2_motionvectorbuffer"></a><a id="DXVA2_MOTIONVECTORBUFFER"></a><dl>
    ///<dt><b>DXVA2_MotionVectorBuffer</b></dt> </dl> </td> <td width="60%"> Motion vector buffer. </td> </tr> <tr> <td
    ///width="40%"><a id="DXVA2_FilmGrainBuffer"></a><a id="dxva2_filmgrainbuffer"></a><a
    ///id="DXVA2_FILMGRAINBUFFER"></a><dl> <dt><b>DXVA2_FilmGrainBuffer</b></dt> </dl> </td> <td width="60%"> Film grain
    ///synthesis data buffer. </td> </tr> </table>
    uint  CompressedBufferType;
    ///Reserved. Set to zero.
    uint  BufferIndex;
    ///Specifies the offset of the relevant data from the beginning of the buffer, in bytes. Currently this value must
    ///be zero.
    uint  DataOffset;
    ///Specifies the amount of relevant data in the buffer, in bytes. The location of the last byte of content in the
    ///buffer is <b>DataOffset</b> + <b>DataSize</b> âˆ’ 1.
    uint  DataSize;
    ///Specifies the macroblock address of the first macroblock in the buffer. The macroblock address is given in raster
    ///scan order.
    uint  FirstMBaddress;
    ///Specifies the number of macroblocks of data in the buffer. This count includes skipped macroblocks. This value
    ///must be zero if the data buffer type is one of the following: picture decoding parameters, inverse-quantization
    ///matrix, AYUV, IA44/AI44, DPXD, Highlight, or DCCMD.
    uint  NumMBsInBuffer;
    ///Reserved. Set to zero.
    uint  Width;
    ///Reserved. Set to zero.
    uint  Height;
    ///Reserved. Set to zero.
    uint  Stride;
    ///Reserved. Set to zero.
    uint  ReservedBits;
    ///Pointer to a byte array that contains an initialization vector (IV) for encrypted data. If the decode buffer does
    ///not contain encrypted data, set this member to <b>NULL</b>. If the decode buffer contains encrypted data, the
    ///contents of <b>pvPVPState</b> depends on the type of encryption. For <b>D3DCRYPTOTYPE_AES128_CTR</b>, the
    ///<b>pvPVPState</b> member points to a DXVA2_AES_CTR_IV structure.
    void* pvPVPState;
}

///Contains an initialization vector (IV) for 128-bit Advanced Encryption Standard CTR mode (AES-CTR) block cipher
///encryption.
struct DXVA2_AES_CTR_IV
{
    ///The IV, in big-endian format.
    ulong IV;
    ///The block count, in big-endian format.
    ulong Count;
}

///Contains private data for the IDirectXVideoDecoder::Execute method.
struct DXVA2_DecodeExtensionData
{
    ///Function number. This can be zero if this argument is the default or is ignored.
    uint  Function;
    ///Pointer to private input data passed to the driver.
    void* pPrivateInputData;
    ///Length of the private input data, in bytes.
    uint  PrivateInputDataSize;
    ///Pointer to private output data passed from the driver to the decoder.
    void* pPrivateOutputData;
    ///Size of the private output data, in bytes.
    uint  PrivateOutputDataSize;
}

///Contains parameters for the IDirectXVideoDecoder::Execute method.
struct DXVA2_DecodeExecuteParams
{
    ///Number of compressed buffers.
    uint NumCompBuffers;
    ///Pointer to an array of DXVA2_DecodeBufferDesc structures that describe the compressed buffers. The number of
    ///elements in the array is given by the <b>NumCompBuffers</b> member.
    DXVA2_DecodeBufferDesc* pCompressedBuffers;
    ///Pointer to a DXVA2_DecodeExtensionData structure that contains private data. Set this member to <b>NULL</b>
    ///unless you need to send private data to or from the driver.
    DXVA2_DecodeExtensionData* pExtensionData;
}

///Contains a 128-bit random number for use with Output Protection Manager (OPM).
struct OPM_RANDOM_NUMBER
{
    ///A 128-bit array that contains a random number.
    ubyte[16] abRandomNumber;
}

///Contains a Message Authentication Code (MAC) for an Output Protection Manager (OPM) message.
struct OPM_OMAC
{
    ///A buffer that contains the cryptographic MAC value of the message.
    ubyte[16] abOMAC;
}

///Contains initialization parameters for an Output Protection Manager (OPM) session.
struct OPM_ENCRYPTED_INITIALIZATION_PARAMETERS
{
    ///Pointer to a buffer that contains encrypted initialization parameters for the session. For more information, see
    ///IOPMVideoOutput::FinishInitialization.
    ubyte[256] abEncryptedInitializationParameters;
}

///Contains parameters for the IOPMVideoOutput::GetInformation method.
struct OPM_GET_INFO_PARAMETERS
{
align (1):
    ///An OPM_OMAC structure that contains a message authentication code (MAC) for the data in the rest of the
    ///structure.
    OPM_OMAC          omac;
    ///An OPM_RANDOM_NUMBER structure that contains a cryptographically secure 128-bit random number.
    OPM_RANDOM_NUMBER rnRandomNumber;
    ///A GUID that defines the status request. For more information, see OPM Status Requests.
    GUID              guidInformation;
    ///The status sequence number. The application must keep a running count of status requests. For each request,
    ///increment the sequence number by 1. On the first call to GetInformation, set <b>ulSequenceNumber</b> equal to the
    ///starting status sequence number, which is specified when the application calls
    ///IOPMVideoOutput::FinishInitialization. On each subsequent call, increment <b>ulSequenceNumber</b> by 1.
    ///Exception: If the status request fails, do not increment the sequence number. Instead, re-use the same number for
    ///the next status request.
    uint              ulSequenceNumber;
    ///The number of bytes of valid data in the <b>abParameters</b> member.
    uint              cbParametersSize;
    ///The data for the status request. The meaning of the data depends on the request. For more information, see OPM
    ///Status Requests.
    ubyte[4056]       abParameters;
}

///Contains parameters for the IOPMVideoOutput::COPPCompatibleGetInformation method.
struct OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS
{
align (1):
    ///An OPM_RANDOM_NUMBER structure that contains a cryptographically secure 128-bit random number.
    OPM_RANDOM_NUMBER rnRandomNumber;
    ///A GUID that defines the status request. For more information, see OPM Status Requests.
    GUID              guidInformation;
    ///The sequence number of the status request. The application must keep a running count of status requests. For each
    ///request, increment the sequence number by one. On the first call to COPPCompatibleGetInformation, set
    ///<b>ulSequenceNumber</b> equal to the starting sequence number, which is specified when the application calls
    ///IOPMVideoOutput::FinishInitialization. On each subsequent call, increment <b>ulSequenceNumber</b> by 1.
    uint              ulSequenceNumber;
    ///The number of bytes of valid data in the <b>abParameters</b> member.
    uint              cbParametersSize;
    ///The data for the status request. The meaning of the data depends on the request. For more information, see OPM
    ///Status Requests.
    ubyte[4056]       abParameters;
}

///Contains the key selection vector (KSV) for a High-Bandwidth Digital Content Protection (HDCP) receiver.
struct OPM_HDCP_KEY_SELECTION_VECTOR
{
    ///A buffer that contains the device's KSV. (This is the value named <i>Bksv</i> in the HDCP specification.)
    ubyte[5] abKeySelectionVector;
}

///Contains the result from an OPM_GET_CONNECTED_HDCP_DEVICE_INFORMATION query.
struct OPM_CONNECTED_HDCP_DEVICE_INFORMATION
{
align (1):
    ///An OPM_RANDOM_NUMBER structure. This structure contains the same 128-bit random number that the application sent
    ///to the driver in the OPM_GET_INFO_PARAMETERS or OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS structure.
    OPM_RANDOM_NUMBER rnRandomNumber;
    ///A bitwise <b>OR</b> of OPM Status Flags.
    uint              ulStatusFlags;
    ///A value that indicates whether the connected device is an HDCP repeater. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="OPM_HDCP_FLAG_NONE"></a><a id="opm_hdcp_flag_none"></a><dl>
    ///<dt><b>OPM_HDCP_FLAG_NONE</b></dt> <dt>0x00</dt> </dl> </td> <td width="60%"> The device is not an HDCP repeater.
    ///</td> </tr> <tr> <td width="40%"><a id="OPM_HDCP_FLAG_REPEATER"></a><a id="opm_hdcp_flag_repeater"></a><dl>
    ///<dt><b>OPM_HDCP_FLAG_REPEATER</b></dt> <dt>0x01</dt> </dl> </td> <td width="60%"> The device is an HDCP repeater.
    ///</td> </tr> </table>
    uint              ulHDCPFlags;
    ///An OPM_HDCP_KEY_SELECTION_VECTOR structure that contains the device's key selection vector (KSV). This is the
    ///value named <i>Bksv</i> in the HDCP specification.
    OPM_HDCP_KEY_SELECTION_VECTOR ksvB;
    ///Reserved for future use. Fill this array with zeros.
    ubyte[11]         Reserved;
    ///Reserved for future use. Fill this array with zeros.
    ubyte[16]         Reserved2;
    ///Reserved for future use. Fill this array with zeros.
    ubyte[16]         Reserved3;
}

///Contains the result of an Output Protection Manager (OPM) status request.
struct OPM_REQUESTED_INFORMATION
{
align (1):
    ///An OPM_OMAC structure that contains a Message Authentication Code (MAC) of the status data. The driver will use
    ///AES-based one-key CBC MAC (OMAC) to calculate this value.
    OPM_OMAC    omac;
    ///The size of the valid data in the <b>abRequestedInformation</b> member, in bytes.
    uint        cbRequestedInformationSize;
    ///A buffer that contains the result of the status request. The meaning of the data depends on the status request.
    ///For more information, see OPM Status Requests.
    ubyte[4076] abRequestedInformation;
}

///Contains the result from an Output Protection Manager (OPM) status request.
struct OPM_STANDARD_INFORMATION
{
align (1):
    ///An OPM_RANDOM_NUMBER structure. This structure contains the same 128-bit random number that the application sent
    ///to the driver in the OPM_GET_INFO_PARAMETERS or OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS structure.
    OPM_RANDOM_NUMBER rnRandomNumber;
    ///A bitwise <b>OR</b> of OPM Status Flags.
    uint              ulStatusFlags;
    ///Response data. The meaning of this value depends on the status request. For more information, see OPM Status
    ///Requests.
    uint              ulInformation;
    ///Reserved for future use. Set to zero.
    uint              ulReserved;
    ///Reserved for future use. Set to zero.
    uint              ulReserved2;
}

///Contains the result of an OPM_GET_ACTUAL_OUTPUT_FORMAT query in Output Protection Manager (OPM).
struct OPM_ACTUAL_OUTPUT_FORMAT
{
align (1):
    ///An OPM_RANDOM_NUMBER structure. This structure contains the same 128-bit random number that the application sent
    ///to the driver in the OPM_GET_INFO_PARAMETERS or OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS structure.
    OPM_RANDOM_NUMBER  rnRandomNumber;
    ///A bitwise <b>OR</b> of OPM Status Flags.
    uint               ulStatusFlags;
    ///The width of the display mode, in pixels.
    uint               ulDisplayWidth;
    ///The height of the display mode, in pixels.
    uint               ulDisplayHeight;
    ///A DXVA2_SampleFormat value that describes the interlace mode.
    DXVA2_SampleFormat dsfSampleInterleaveFormat;
    ///A <b>D3DFORMAT</b> value that describes the video format.
    D3DFORMAT          d3dFormat;
    ///The numerator of the refresh rate of the current display mode.
    uint               ulFrequencyNumerator;
    ///The denominator of the refresh rate of the current display mode.
    uint               ulFrequencyDenominator;
}

///Contains the result from an OPM_GET_ACP_AND_CGMSA_SIGNALING query.
struct OPM_ACP_AND_CGMSA_SIGNALING
{
align (1):
    ///An OPM_RANDOM_NUMBER structure. This structure contains the same 128-bit random number that the application sent
    ///to the driver in the OPM_GET_INFO_PARAMETERS or OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS structure.
    OPM_RANDOM_NUMBER rnRandomNumber;
    ///A bitwise <b>OR</b> of OPM Status Flags.
    uint              ulStatusFlags;
    ///A bitwise <b>OR</b> of zero or more TV Protection Standard Flags. The driver will return flags for all of the
    ///protection standards and resolutions that it supports, regardless of which are now active.
    uint              ulAvailableTVProtectionStandards;
    ///One value from the TV Protection Standard Flags, indicating the protection standard that is currently active.
    uint              ulActiveTVProtectionStandard;
    ///Reserved for future use. Set to zero.
    uint              ulReserved;
    ///A bitmask indicating which bits of <b>ulAspectRatioData1</b> are valid.
    uint              ulAspectRatioValidMask1;
    ///The current aspect ratio. For EN 300 294, the value is a member of the OPM_IMAGE_ASPECT_RATIO_EN300294
    ///enumeration.
    uint              ulAspectRatioData1;
    ///A bitmask indicating which bits of <b>ulAspectRatioData2</b> are valid.
    uint              ulAspectRatioValidMask2;
    ///An additional data element related to aspect ratio for the current protection standard. The presence and meaning
    ///of this data depends on the protection standard. This field can be used to convey End and Q0 bits for EIA-608-B,
    ///or the active format description for CEA-805-A.
    uint              ulAspectRatioData2;
    ///A bitmask indicating which bits of <b>ulAspectRatioData3</b> are valid.
    uint              ulAspectRatioValidMask3;
    ///An additional data element related to aspect ratio for the current protection standard. The presence and meaning
    ///of this data depends on the protection standard.
    uint              ulAspectRatioData3;
    ///Reserved for future use. Fill this array with zeros.
    uint[4]           ulReserved2;
    ///Reserved for future use.Fill this array with zeros.
    uint[4]           ulReserved3;
}

///Contains the result from an OPM_GET_OUTPUT_ID status request.
struct OPM_OUTPUT_ID_DATA
{
align (1):
    ///An OPM_RANDOM_NUMBER structure. This structure contains the same 128-bit random number that the application sent
    ///to the driver in the OPM_GET_INFO_PARAMETERS or OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS structure.
    OPM_RANDOM_NUMBER rnRandomNumber;
    ///A bitwise <b>OR</b> of OPM Status Flags.
    uint              ulStatusFlags;
    ///The unique identifier of the monitor associated with this video output.
    ulong             OutputId;
}

///Contains an Output Protection Manager (OPM) or Certified Output Protection Manager (COPP) command.
struct OPM_CONFIGURE_PARAMETERS
{
align (1):
    ///An OPM_MAC structure. Fill in this structure with the Message Authentication Code (MAC) of the command data. Use
    ///AES-based one-key CBC MAC (OMAC) to calculate this value.
    OPM_OMAC    omac;
    ///A GUID that specifies the command. For more information, see OPM Commands.
    GUID        guidSetting;
    ///A command sequence number. The application must keep a running count of the commands issued. For each command,
    ///increment the sequence number by one. On the first call to IOPMVideoOutput::Configure, set
    ///<b>ulSequenceNumber</b> equal to the starting command sequence number, which is specified when the application
    ///calls IOPMVideoOutput::FinishInitialization. On each subsequent call, increment <b>ulSequenceNumber</b> by 1.
    ///Exception: If the IOPMVideoOutput::Configure method fails, do not increment the sequence number. Instead, re-use
    ///the same number for the next command.
    uint        ulSequenceNumber;
    ///The number of bytes of valid data in the <b>abParameters</b> member.
    uint        cbParametersSize;
    ///The data for the command. The meaning of the data depends on the command. For more information, see OPM Commands.
    ubyte[4056] abParameters;
}

///Contains data for the OPM_SET_PROTECTION_LEVEL command in Output Protection Manager (OPM).
struct OPM_SET_PROTECTION_LEVEL_PARAMETERS
{
align (1):
    ///Identifies the protection mechanism. For a list of possible values, see OPM Protection Type Flags.
    uint ulProtectionType;
    ///Specifies the protection level. The meaning of this value depends on the protection mechanism that is queried.
    ///For each protection mechanism, the value is a flag from a different enumeration, as shown in the following table.
    ///<table> <tr> <th>Protection mechanism</th> <th>Enumeration</th> </tr> <tr> <td>ACP</td> <td>
    ///OPM_ACP_PROTECTION_LEVEL </td> </tr> <tr> <td>CGMS-A</td> <td> CGMS-A Protection Flags </td> </tr> <tr>
    ///<td>DPCP</td> <td> OPM_DPCP_PROTECTION_LEVEL </td> </tr> <tr> <td>HDCP</td> <td> OPM_HDCP_PROTECTION_LEVEL </td>
    ///</tr> </table>
    uint ulProtectionLevel;
    ///Reserved for future use. Set to zero.
    uint Reserved;
    ///Reserved for future use. Set to zero.
    uint Reserved2;
}

///Contains information for the OPM_SET_ACP_AND_CGMSA_SIGNALING command in Output Protection Manager (OPM). This command
///causes the driver to insert Wide Screen Signaling (WSS) codes or other data packets in the television signal, as
///required by some Analog Copy Protection (ACP) and Copy Generation Management System â€” Analog (CGMS-A)
///specifications. For example: <ul> <li>ETSI EN 300 294 (625i PAL): Data packets are inserted into line 23 of the
///signal.</li> <li>CEA-608-B (NTSC): Data packets are inserted into line 21 of the vertical blanking interval
///(VBI).</li> </ul>
struct OPM_SET_ACP_AND_CGMSA_SIGNALING_PARAMETERS
{
align (1):
    ///Specifies the protection standard and format that is currently active. The value is a bitwise <b>OR</b> of TV
    ///Protection Standard Flags.
    uint    ulNewTVProtectionStandard;
    ///A bitmask indicating which bits from <b>ulAspectRatioData1</b> to set in the signal.
    uint    ulAspectRatioChangeMask1;
    ///Specifies the aspect ratio value to be set for the current protection standard. For EN 300 294, use the
    ///OPM_IMAGE_ASPECT_RATIO_EN300294 enumeration.
    uint    ulAspectRatioData1;
    ///A bitmask indicating which bits from <b>ulAspectRatioData2</b> to set in the signal.
    uint    ulAspectRatioChangeMask2;
    ///An additional data element related to aspect ratio. The presence and meaning of this data depends on the
    ///protection standard. This field can be used to convey End and Q0 bits for EIA-608-B, or the active format
    ///description for CEA-805-A.
    uint    ulAspectRatioData2;
    ///A bitmask indicating which bits from <b>ulAspectRatioData3</b> to set in the signal.
    uint    ulAspectRatioChangeMask3;
    ///An additional data element related to aspect ratio for the current protection standard. The presence and meaning
    ///of this data depends on the protection standard.
    uint    ulAspectRatioData3;
    ///Reserved for future use. Set the entire array to zero.
    uint[4] ulReserved;
    ///Reserved for future use. Set the entire array to zero.
    uint[4] ulReserved2;
    ///Reserved for future use. Set to zero.
    uint    ulReserved3;
}

///Contains parameters for the OPM_SET_HDCP_SRM command. This command updates the system renewability message (SRM) for
///High-Bandwidth Digital Content Protection (HDCP).
struct OPM_SET_HDCP_SRM_PARAMETERS
{
align (1):
    ///Contains the SRM version number in little-endian format. This number is contained in the <b>SRM Version</b> field
    ///of the SRM. For more information, see the HDCP specification.
    uint ulSRMVersion;
}

///Contains information for the OPM_GET_CODEC_INFO command.
struct OPM_GET_CODEC_INFO_PARAMETERS
{
align (1):
    ///The amount of valid data in the <b>Verifier</b> array, in bytes.
    uint        cbVerifier;
    ///A byte array that contains one of the following: <ul> <li>The CLSID of the Media Foundation transform (MFT) that
    ///represents the hardware codec.</li> <li>A null-terminated, wide-character string that contains the symbolic link
    ///for the hardware codec. Include the size of the terminating null in the value of the <b>cbVerifier</b> member.
    ///</li> </ul>
    ubyte[4052] Verifier;
}

///Contains the result from an OPM_GET_CODEC_INFO query.
struct OPM_GET_CODEC_INFO_INFORMATION
{
align (1):
    ///An OPM_RANDOM_NUMBER structure. This structure contains the same 128-bit random number that the application sent
    ///to the driver in the OPM_GET_INFO_PARAMETERS structure.
    OPM_RANDOM_NUMBER rnRandomNumber;
    ///The merit value of the codec.
    uint              Merit;
}

///Contains media type information for registering a Media Foundation transform (MFT).
struct MFT_REGISTER_TYPE_INFO
{
    ///The major media type. For a list of possible values, see Major Media Types.
    GUID guidMajorType;
    ///The media subtype. For a list of possible values, see the following topics: <ul> <li> Audio Subtype GUIDs </li>
    ///<li> Video Subtype GUIDs </li> </ul>
    GUID guidSubtype;
}

///Represents a ratio.
struct MFRatio
{
    ///Numerator of the ratio.
    uint Numerator;
    ///Denominator of the ratio.
    uint Denominator;
}

///Specifies an offset as a fixed-point real number.
struct MFOffset
{
    ///The fractional part of the number.
    ushort fract;
    ///The integer part of the number.
    short  value;
}

///Specifies a rectangular area within a video frame.
struct MFVideoArea
{
    ///An MFOffset structure that contains the x-coordinate of the upper-left corner of the rectangle. This coordinate
    ///might have a fractional value.
    MFOffset OffsetX;
    ///An MFOffset structure that contains the y-coordinate of the upper-left corner of the rectangle. This coordinate
    ///might have a fractional value.
    MFOffset OffsetY;
    ///A SIZE structure that contains the width and height of the rectangle.
    SIZE     Area;
}

///Contains video format information that applies to both compressed and uncompressed formats. This structure is used in
///the MFVIDEOFORMAT structure.
struct MFVideoInfo
{
    ///Width of the decoded image, in pixels.
    uint                 dwWidth;
    ///Height of the decoded image, in pixels.
    uint                 dwHeight;
    ///Pixel aspect ratio, specified as an MFRatio structure.
    MFRatio              PixelAspectRatio;
    ///Chroma sub-sampling of the original image, specified as a member of the MFVideoChromaSubsampling enumeration.
    MFVideoChromaSubsampling SourceChromaSubsampling;
    ///Image interlacing, specified as a member of the MFVideoInterlaceMode enumeration.
    MFVideoInterlaceMode InterlaceMode;
    ///R'G'B' gamma curve function, specified as a member of the MFVideoTransferFunction enumeration.
    MFVideoTransferFunction TransferFunction;
    ///Color primaries of the video source, specified as a member of the MFVideoPrimaries enumeration. This value
    ///provides the conversion from R'G'B' to linear RGB.
    MFVideoPrimaries     ColorPrimaries;
    ///Conversion matrix from Y'Cb'Cr' to R'G'B, specified as a member of the MFVideoTransferMatrix enumeration.
    MFVideoTransferMatrix TransferMatrix;
    ///Intended viewing conditions, specified as a member of the MFVideoLighting enumeration.
    MFVideoLighting      SourceLighting;
    ///Frames per second, specified as an MFRatio structure. If the frame rate is unknown or variable, the numerator and
    ///denominator should both be set to zero. It is invalid for only one member of the <b>MFRatio</b> structure to be
    ///zero.
    MFRatio              FramesPerSecond;
    ///Range of valid RGB values, specified as a member of the MFNominalRange enumeration. The value indicates whether
    ///color values contain headroom and toeroom.
    MFNominalRange       NominalRange;
    ///Geometric aperture, specified as an MFVideoArea structure. For more information, see MF_MT_GEOMETRIC_APERTURE.
    MFVideoArea          GeometricAperture;
    ///The display aperture, specified as an MFVideoArea structure. The display aperture is the region of the video
    ///image that is intended to be shown. Any data outside of this area is the overscan region. For more information,
    ///see MF_MT_MINIMUM_DISPLAY_APERTURE.
    MFVideoArea          MinimumDisplayAperture;
    ///Pan-scan rectangle, specified as an MFVideoArea structure. The pan-scan rectangle defines a region of the image
    ///that is displayed in pan-and-scan mode. It can be used when wide-screen content is shown on a 4 x 3 display. The
    ///value is valid only when the <b>VideoFlags</b> member contains the MFVideoFlag_PanScanEnabled flag.
    MFVideoArea          PanScanAperture;
    ///Bitwise <b>OR</b> of zero or more flags from the MFVideoFlags enumeration.
    ulong                VideoFlags;
}

///Describes a 4:4:4:4 Y'Cb'Cr' sample.
struct MFAYUVSample
{
    ///Cr (chroma difference) value.
    ubyte bCrValue;
    ///Cb (chroma difference) value.
    ubyte bCbValue;
    ///Y (luma) value.
    ubyte bYValue;
    ///Alpha value.
    ubyte bSampleAlpha8;
}

///Describes an ARGB color value.
struct MFARGB
{
    ///Blue value.
    ubyte rgbBlue;
    ///Green value.
    ubyte rgbGreen;
    ///Red value.
    ubyte rgbRed;
    ///Alpha value.
    ubyte rgbAlpha;
}

///Contains one palette entry in a color table.
union MFPaletteEntry
{
    ///[MFARGB](./ns-mfobjects-mfargb.md) structure that contains an RGB color.
    MFARGB       ARGB;
    ///[MFAYUVSample](./ns-mfobjects-mfayuvsample.md) structure that contains a Y'Cb'Cr' color.
    MFAYUVSample AYCbCr;
}

///Contains information about an uncompressed video format. This structure is used in the MFVIDEOFORMAT structure.
struct MFVideoSurfaceInfo
{
    ///For compressed formats, this value must be zero. For uncompressed formats, the value is a FOURCC or
    ///<b>D3DFORMAT</b> value that identifies the format. Use the <b>Data1</b> field from the subtype GUID. See Video
    ///Subtype GUIDs.
    uint              Format;
    ///Number of palette entries. The value must be between 0 and 256.
    uint              PaletteEntries;
    ///Array of MFPaletteEntry Unions that contains the color table for a palettized format. The size of the array is
    ///given in the <b>PaletteEntries</b> member. If the format is not palettized, set <b>PaletteEntries</b> to zero.
    MFPaletteEntry[1] Palette;
}

///Contains information about a video compression format. This structure is used in the MFVIDEOFORMAT structure.
struct MFVideoCompressedInfo
{
    ///Average bit rate of the encoded video stream, in bits per second.
    long AvgBitrate;
    ///Expected error rate, in bits per second.
    long AvgBitErrorRate;
    ///Number of frames between key frames.
    uint MaxKeyFrameSpacing;
}

///Describes a video format.
struct MFVIDEOFORMAT
{
    ///Size of the structure, in bytes. This value includes the size of the palette entries that may appear after the
    ///<b>surfaceInfo</b> member.
    uint               dwSize;
    ///MFVideoInfo structure. This structure contains information that applies to both compressed and uncompressed
    ///formats.
    MFVideoInfo        videoInfo;
    ///Video subtype. See Video Subtype GUIDs.
    GUID               guidFormat;
    ///MFVideoCompressedInfo structure. This structure contains information that applies only to compressed formats.
    MFVideoCompressedInfo compressedInfo;
    ///MFVideoSurfaceInfo structure. This structure contains information that applies only to uncompressed formats.
    MFVideoSurfaceInfo surfaceInfo;
}

///Contains information about an input stream on a Media Foundation transform (MFT). To get these values, call
///IMFTransform::GetInputStreamInfo.
struct MFT_INPUT_STREAM_INFO
{
    ///Maximum amount of time between an input sample and the corresponding output sample, in 100-nanosecond units. For
    ///example, an MFT that buffers two samples, each with a duration of 1 second, has a maximum latency of two seconds.
    ///If the MFT always turns input samples directly into output samples, with no buffering, the latency is zero.
    long hnsMaxLatency;
    ///Bitwise <b>OR</b> of zero or more flags from the _MFT_INPUT_STREAM_INFO_FLAGS enumeration.
    uint dwFlags;
    ///The minimum size of each input buffer, in bytes. If the size is variable or the MFT does not require a specific
    ///size, the value is zero. For uncompressed audio, the value should be the audio frame size, which you can get from
    ///the MF_MT_AUDIO_BLOCK_ALIGNMENT attribute in the media type.
    uint cbSize;
    ///Maximum amount of input data, in bytes, that the MFT holds to perform lookahead. <i>Lookahead</i> is the action
    ///of looking forward in the data before processing it. This value should be the worst-case value. If the MFT does
    ///not keep a lookahead buffer, the value is zero.
    uint cbMaxLookahead;
    ///The memory alignment required for input buffers. If the MFT does not require a specific alignment, the value is
    ///zero.
    uint cbAlignment;
}

///Contains information about an output stream on a Media Foundation transform (MFT). To get these values, call
///IMFTransform::GetOutputStreamInfo.
struct MFT_OUTPUT_STREAM_INFO
{
    ///Bitwise <b>OR</b> of zero or more flags from the _MFT_OUTPUT_STREAM_INFO_FLAGS enumeration.
    uint dwFlags;
    ///Minimum size of each output buffer, in bytes. If the MFT does not require a specific size, the value is zero. For
    ///uncompressed audio, the value should be the audio frame size, which you can get from the
    ///MF_MT_AUDIO_BLOCK_ALIGNMENT attribute in the media type. If the <b>dwFlags</b> member contains the
    ///MFT_OUTPUT_STREAM_PROVIDES_SAMPLES flag, the value is zero, because the MFT allocates the output buffers.
    uint cbSize;
    ///The memory alignment required for output buffers. If the MFT does not require a specific alignment, the value is
    ///zero. If the <b>dwFlags</b> member contains the MFT_OUTPUT_STREAM_PROVIDES_SAMPLES flag, this value is the
    ///alignment that the MFT uses internally when it allocates samples. It is recommended, but not required, that MFTs
    ///allocate buffers with at least a 16-byte memory alignment.
    uint cbAlignment;
}

///Contains information about an output buffer for a Media Foundation transform. This structure is used in the
///IMFTransform::ProcessOutput method.
struct MFT_OUTPUT_DATA_BUFFER
{
    ///Output stream identifier. Before calling ProcessOutput, set this member to a valid stream identifier. Exception:
    ///If the IMFTransform::GetStreamIDs method returns E_NOTIMPL, the MFT ignores this member and uses the indexes of
    ///the <i>pOutputSamples</i> array in the ProcessOutput method as the stream identifiers. In other words, it uses
    ///the first element in the array for stream 0, the second for stream 1, and so forth. It is recommended (but not
    ///required) that the caller set <b>dwStreamID</b> equal to the array index in this case.
    uint          dwStreamID;
    ///Pointer to the IMFSample interface. Before calling ProcessOutput, set this member equal to a valid
    ///<b>IMFSample</b> pointer or <b>NULL</b>. See Remarks for more information.
    IMFSample     pSample;
    ///Before calling ProcessOutput, set this member to zero. When the method returns, the MFT might set the member
    ///equal to a value from the _MFT_OUTPUT_DATA_BUFFER_FLAGS enumeration. Otherwise, the MFT leaves this member equal
    ///to zero.
    uint          dwStatus;
    ///Before calling ProcessOutput, set this member to <b>NULL</b>. On output, the MFT might set this member to a valid
    ///IMFCollection interface pointer. The pointer represents a collecton that contains zero or more events. To get
    ///each event, call IMFCollection::GetElement and query the returned <b>IUnknown</b> pointer for the IMFMediaEvent
    ///interface. When the <b>ProcessOutput</b> method returns, the caller is responsible for releasing the
    ///<b>IMFCollection</b> pointer if the pointer is not <b>NULL</b>.
    IMFCollection pEvents;
}

///Not for application use.
struct STREAM_MEDIUM
{
    ///Reserved.
    GUID gidMedium;
    ///Reserved.
    uint unMediumInstance;
}

struct MFAudioDecoderDegradationInfo
{
    MFT_AUDIO_DECODER_DEGRADATION_REASON eDegradationReason;
    MFT_AUDIO_DECODER_DEGRADATION_TYPE eType;
}

struct MFT_STREAM_STATE_PARAM
{
    uint            StreamId;
    MF_STREAM_STATE State;
}

///Defines the properties of a clock.
struct MFCLOCK_PROPERTIES
{
    ///The interval at which the clock correlates its clock time with the system time, in 100-nanosecond units. If the
    ///value is zero, the correlation is made whenever the IMFClock::GetCorrelatedTime method is called.
    ulong qwCorrelationRate;
    ///The unique identifier of the underlying device that provides the time. If two clocks have the same unique
    ///identifier, they are based on the same device. If the underlying device is not shared between two clocks, the
    ///value can be <b>GUID_NULL</b>.
    GUID  guidClockId;
    ///A bitwise <b>OR</b> of flags from the MFCLOCK_RELATIONAL_FLAGS enumeration.
    uint  dwClockFlags;
    ///The clock frequency in Hz. A value of <b>MFCLOCK_FREQUENCY_HNS</b> means that the clock has a frequency of 10 MHz
    ///(100-nanosecond ticks), which is the standard MFTIME time unit in Media Foundation. If the
    ///IMFClock::GetClockCharacteristics method returns the <b>MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ</b> flag,
    ///the value of this field must be <b>MFCLOCK_FREQUENCY_HNS</b>.
    ulong qwClockFrequency;
    ///The amount of inaccuracy that may be present on the clock, in parts per billion (ppb). For example, an inaccuracy
    ///of 50 ppb means the clock might drift up to 50 seconds per billion seconds of real time. If the tolerance is not
    ///known, the value is <b>MFCLOCK_TOLERANCE_UNKNOWN</b>. This constant is equal to 50 parts per million (ppm).
    uint  dwClockTolerance;
    ///The amount of jitter that may be present, in 100-nanosecond units. Jitter is the variation in the frequency due
    ///to sampling the underlying clock. Jitter does not include inaccuracies caused by drift, which is reflected in the
    ///value of <b>dwClockTolerance</b>. For clocks based on a single device, the minimum jitter is the length of the
    ///tick period (the inverse of the frequency). For example, if the frequency is 10 Hz, the jitter is 0.1 second,
    ///which is 1,000,000 in MFTIME units. This value reflects the fact that the clock might be sampled just before the
    ///next tick, resulting in a clock time that is one period less than the actual time. If the frequency is greater
    ///than 10 MHz, the jitter should be set to 1 (the minimum value). If a clock's underlying hardware device does not
    ///directly time stamp the incoming data, the jitter also includes the time required to dispatch the driver's
    ///interrupt service routine (ISR). In that case, the expected jitter should include the following values: <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MFCLOCK_JITTER_ISR"></a><a
    ///id="mfclock_jitter_isr"></a><dl> <dt><b>MFCLOCK_JITTER_ISR</b></dt> </dl> </td> <td width="60%"> Jitter due to
    ///time stamping during the device driver's ISR. </td> </tr> <tr> <td width="40%"><a id="MFCLOCK_JITTER_DPC"></a><a
    ///id="mfclock_jitter_dpc"></a><dl> <dt><b>MFCLOCK_JITTER_DPC</b></dt> </dl> </td> <td width="60%"> Jitter due to
    ///time stamping during the deferred procedure call (DPC) processing. </td> </tr> <tr> <td width="40%"><a
    ///id="MFCLOCK_JITTER_PASSIVE"></a><a id="mfclock_jitter_passive"></a><dl> <dt><b>MFCLOCK_JITTER_PASSIVE</b></dt>
    ///</dl> </td> <td width="60%"> Jitter due to dropping to normal thread execution before time stamping. </td> </tr>
    ///</table>
    uint  dwClockJitter;
}

///Contains information about a revoked component.
struct MFRR_COMPONENT_HASH_INFO
{
    ///Specifies the reason for the revocation. The following values are defined. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="MF_BOOT_DRIVER_VERIFICATION_FAILED"></a><a
    ///id="mf_boot_driver_verification_failed"></a><dl> <dt><b>MF_BOOT_DRIVER_VERIFICATION_FAILED</b></dt> </dl> </td>
    ///<td width="60%"> A boot driver could not be verified. </td> </tr> <tr> <td width="40%"><a
    ///id="MF_COMPONENT_CERT_REVOKED"></a><a id="mf_component_cert_revoked"></a><dl>
    ///<dt><b>MF_COMPONENT_CERT_REVOKED</b></dt> </dl> </td> <td width="60%"> A certificate in a trusted component's
    ///certificate chain was revoked. </td> </tr> <tr> <td width="40%"><a id="MF_COMPONENT_HS_CERT_REVOKED"></a><a
    ///id="mf_component_hs_cert_revoked"></a><dl> <dt><b>MF_COMPONENT_HS_CERT_REVOKED</b></dt> </dl> </td> <td
    ///width="60%"> The high-security certificate for authenticating the protected environment (PE) was revoked. The
    ///high-security certificate is typically used by ITAs that handle high-definition content and next-generation
    ///formats such as HD-DVD. </td> </tr> <tr> <td width="40%"><a id="MF_COMPONENT_INVALID_EKU"></a><a
    ///id="mf_component_invalid_eku"></a><dl> <dt><b>MF_COMPONENT_INVALID_EKU</b></dt> </dl> </td> <td width="60%"> A
    ///certificate's extended key usage (EKU) object is invalid. </td> </tr> <tr> <td width="40%"><a
    ///id="MF_COMPONENT_INVALID_ROOT"></a><a id="mf_component_invalid_root"></a><dl>
    ///<dt><b>MF_COMPONENT_INVALID_ROOT</b></dt> </dl> </td> <td width="60%"> The root certificate is not valid. </td>
    ///</tr> <tr> <td width="40%"><a id="MF_COMPONENT_LS_CERT_REVOKED"></a><a id="mf_component_ls_cert_revoked"></a><dl>
    ///<dt><b>MF_COMPONENT_LS_CERT_REVOKED</b></dt> </dl> </td> <td width="60%"> The low-security certificate for
    ///authenticating the PE was revoked. The low-security certificate is typically used by ITAs that handle
    ///standard-definition content and current-generation formats. </td> </tr> <tr> <td width="40%"><a
    ///id="MF_COMPONENT_REVOKED"></a><a id="mf_component_revoked"></a><dl> <dt><b>MF_COMPONENT_REVOKED</b></dt> </dl>
    ///</td> <td width="60%"> A trusted component was revoked. </td> </tr> <tr> <td width="40%"><a
    ///id="MF_GRL_ABSENT"></a><a id="mf_grl_absent"></a><dl> <dt><b>MF_GRL_ABSENT</b></dt> </dl> </td> <td width="60%">
    ///The GRL was not found. </td> </tr> <tr> <td width="40%"><a id="MF_GRL_LOAD_FAILED"></a><a
    ///id="mf_grl_load_failed"></a><dl> <dt><b>MF_GRL_LOAD_FAILED</b></dt> </dl> </td> <td width="60%"> Could not load
    ///the global revocation list (GRL). </td> </tr> <tr> <td width="40%"><a id="MF_INVALID_GRL_SIGNATURE"></a><a
    ///id="mf_invalid_grl_signature"></a><dl> <dt><b>MF_INVALID_GRL_SIGNATURE</b></dt> </dl> </td> <td width="60%"> The
    ///GRL signature is invalid. </td> </tr> <tr> <td width="40%"><a id="MF_MINCRYPT_FAILURE"></a><a
    ///id="mf_mincrypt_failure"></a><dl> <dt><b>MF_MINCRYPT_FAILURE</b></dt> </dl> </td> <td width="60%"> A certificate
    ///chain was not well-formed, or a boot driver is unsigned or is signed with an untrusted certificate. </td> </tr>
    ///<tr> <td width="40%"><a id="MF_TEST_SIGNED_COMPONENT_LOADING"></a><a
    ///id="mf_test_signed_component_loading"></a><dl> <dt><b>MF_TEST_SIGNED_COMPONENT_LOADING</b></dt> </dl> </td> <td
    ///width="60%"> A component was signed by a test certificate. </td> </tr> </table> In addition, one of the following
    ///flags might be present, indicating the type of component that failed to load. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="MF_USER_MODE_COMPONENT_LOAD"></a><a
    ///id="mf_user_mode_component_load"></a><dl> <dt><b>MF_USER_MODE_COMPONENT_LOAD</b></dt> </dl> </td> <td
    ///width="60%"> User-mode component. </td> </tr> <tr> <td width="40%"><a id="MF_KERNEL_MODE_COMPONENT_LOAD"></a><a
    ///id="mf_kernel_mode_component_load"></a><dl> <dt><b>MF_KERNEL_MODE_COMPONENT_LOAD</b></dt> </dl> </td> <td
    ///width="60%"> Kernel-mode component. </td> </tr> </table>
    uint        ulReason;
    ///Contains a hash of the file header.
    ushort[43]  rgHeaderHash;
    ///Contains a hash of the public key in the component's certificate.
    ushort[43]  rgPublicKeyHash;
    ///File name of the revoked component.
    ushort[260] wszName;
}

///Contains information about one or more revoked components.
struct MFRR_COMPONENTS
{
    ///Revocation information version.
    uint dwRRInfoVersion;
    ///Number of elements in the <b>pRRComponents</b> array.
    uint dwRRComponents;
    ///Array of MFRR_COMPONENT_HASH_INFO structures.
    MFRR_COMPONENT_HASH_INFO* pRRComponents;
}

///Contains an image that is stored as metadata for a media source. This structure is used as the data item for the
///WM/Picture metadata attribute.
struct ASF_FLAT_PICTURE
{
align (1):
    ///Specifies the type of image. This member is equivalent to the <b>bPictureType</b> member in the WM_PICTURE
    ///structure.
    ubyte bPictureType;
    ///Size, in bytes, of the image data.
    uint  dwDataLen;
}

///Contains synchronized lyrics stored as metadata for a media source. This structure is used as the data item for the
///<b>WM/Lyrics_Synchronised</b> metadata attribute.
struct ASF_FLAT_SYNCHRONISED_LYRICS
{
align (1):
    ///Specifies the format of time stamps in the lyrics. This member is equivalent to the <b>bTimeStampFormat</b>
    ///member in the <b>WM_SYNCHRONISED_LYRICS</b> structure. The <b>WM_SYNCHRONISED_LYRICS</b> structure is documented
    ///in the Windows Media Format SDK.
    ubyte bTimeStampFormat;
    ///Specifies the type of synchronized strings that are in the lyric data. This member is equivalent to the
    ///<b>bContentType</b> member in the <b>WM_SYNCHRONISED_LYRICS</b> structure.
    ubyte bContentType;
    ///Size, in bytes, of the lyric data.
    uint  dwLyricsLen;
}

///Specifies a new attribute value for a topology node.
struct MFTOPONODE_ATTRIBUTE_UPDATE
{
    ///The identifier of the topology node to update. To get the identifier of a topology node, call
    ///IMFTopologyNode::GetTopoNodeID.
    ulong             NodeId;
    ///GUID that specifies the attribute to update.
    GUID              guidAttributeKey;
    ///Attribute type, specified as a member of the MF_ATTRIBUTE_TYPE enumeration.
    MF_ATTRIBUTE_TYPE attrType;
union
    {
        uint   u32;
        ulong  u64;
        double d;
    }
}

///Specifies the buffering requirements of a file.
struct MF_LEAKY_BUCKET_PAIR
{
    ///Bit rate, in bits per second.
    uint dwBitrate;
    ///Size of the buffer window, in milliseconds.
    uint msBufferWindow;
}

///Specifies the buffering parameters for a network byte stream.
struct MFBYTESTREAM_BUFFERING_PARAMS
{
    ///Size of the file, in bytes. If the total size is unknown, set this member to -1.
    ulong cbTotalFileSize;
    ///Size of the playable media data in the file, excluding any trailing data that is not useful for playback. If this
    ///value is unknown, set this member to -1.
    ulong cbPlayableDataSize;
    ///Pointer to an array of MF_LEAKY_BUCKET_PAIR structures. Each member of the array gives the buffer window for a
    ///particular bit rate.
    MF_LEAKY_BUCKET_PAIR* prgBuckets;
    ///The number of elements in the <b>prgBuckets</b> array.
    uint  cBuckets;
    ///Amount of data to buffer from the network, in 100-nanosecond units. This value is in addition to the buffer
    ///windows defined in the <b>prgBuckets</b> member.
    ulong qwNetBufferingTime;
    ///Amount of additional data to buffer when seeking, in 100-nanosecond units. This value reflects the fact that
    ///downloading must start from the previous key frame before the seek point. If the value is unknown, set this
    ///member to zero.
    ulong qwExtraBufferingTimeDuringSeek;
    ///The playback duration of the file, in 100-nanosecond units. If the duration is unknown, set this member to zero.
    ulong qwPlayDuration;
    ///Playback rate.
    float dRate;
}

///Specifies a range of bytes.
struct MF_BYTE_STREAM_CACHE_RANGE
{
    ///The offset, in bytes, of the start of the range.
    ulong qwStartOffset;
    ///The offset, in bytes, of the end of the range.
    ulong qwEndOffset;
}

///Contains the authentication information for the credential manager.
struct MFNetCredentialManagerGetParam
{
    ///The response code of the authentication challenge. For example, NS_E_PROXY_ACCESSDENIED.
    HRESULT      hrOp;
    ///Set this flag to <b>TRUE</b> if the currently logged on user's credentials should be used as the default
    ///credentials.
    BOOL         fAllowLoggedOnUser;
    ///If <b>TRUE</b>, the authentication package will send unencrypted credentials over the network. Otherwise, the
    ///authentication package encrypts the credentials.
    BOOL         fClearTextPackage;
    ///The original URL that requires authentication.
    const(PWSTR) pszUrl;
    ///The name of the site or proxy that requires authentication.
    const(PWSTR) pszSite;
    ///The name of the realm for this authentication.
    const(PWSTR) pszRealm;
    ///The name of the authentication package. For example, "Digest" or "MBS_BASIC".
    const(PWSTR) pszPackage;
    ///The number of times that the credential manager should retry after authentication fails.
    int          nRetries;
}

///Describes an action requested by an output trust authority (OTA). The request is sent to an input trust authority
///(ITA).
struct MFINPUTTRUSTAUTHORITY_ACCESS_ACTION
{
    ///Specifies the action as a member of the MFPOLICYMANAGER_ACTION enumeration.
    MFPOLICYMANAGER_ACTION Action;
    ///Pointer to a buffer that contains a ticket object, provided by the OTA.
    ubyte* pbTicket;
    ///Size of the ticket object, in bytes.
    uint   cbTicket;
}

///Contains parameters for the IMFInputTrustAuthority::BindAccess or IMFInputTrustAuthority::UpdateAccess method.
struct MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS
{
    ///Size of the structure, in bytes.
    uint dwSize;
    ///Version number. This value must be zero.
    uint dwVer;
    ///Offset of the signature from the start of the structure, in bytes.
    uint cbSignatureOffset;
    ///Size of the signature, in bytes.
    uint cbSignatureSize;
    ///Offset of the extension blob from the start of the structure, in bytes.
    uint cbExtensionOffset;
    ///Size of the extension blob, in bytes.
    uint cbExtensionSize;
    ///Number of elements in the <b>rgOutputActions</b> array.
    uint cActions;
    ///Array of MFINPUTTRUSTAUTHORITY_ACCESS_ACTION structures. The number of elements in the array is specified in the
    ///<b>cActions</b> member.
    MFINPUTTRUSTAUTHORITY_ACCESS_ACTION[1] rgOutputActions;
}

///Contains information about the audio and video streams for the transcode sink activation object. To get the
///information stored in this structure, call IMFTranscodeSinkInfoProvider::GetSinkInfo.
struct MF_TRANSCODE_SINK_INFO
{
    ///The stream identifier of the video stream.
    uint         dwVideoStreamID;
    ///A pointer to the IMFMediaType interface of the media type for the video stream. This member can be <b>NULL</b>.
    IMFMediaType pVideoMediaType;
    ///The stream identifier of the audio stream.
    uint         dwAudioStreamID;
    ///A pointer to the IMFMediaType interface of the media type for the audio stream. This member can be <b>NULL</b>.
    IMFMediaType pAudioMediaType;
}

///Contains parameters for the IMFLocalMFTRegistration::RegisterMFTs method.
struct MFT_REGISTRATION_INFO
{
    ///CLSID of the Media Foundation transform (MFT) to register.
    GUID         clsid;
    ///GUID that specifies the category of the MFT. For a list of MFT categories, see MFT_CATEGORY.
    GUID         guidCategory;
    ///Bitwise <b>OR</b> of zero or more flags from the _MFT_ENUM_FLAG enumeration.
    uint         uiFlags;
    ///Wide-character string that contains the friendly name of the MFT.
    const(PWSTR) pszName;
    ///Number of elements in the <b>pInTypes</b> array.
    uint         cInTypes;
    ///Pointer to an array of MFT_REGISTER_TYPE_INFO structures. Each member of the array specifies an input format that
    ///the MFT supports. If this member is <b>NULL</b>, the <b>cInTypes</b> member must be zero.
    MFT_REGISTER_TYPE_INFO* pInTypes;
    ///Number of elements in the <b>pOutTypes</b> array.
    uint         cOutTypes;
    ///Pointer to an array of MFT_REGISTER_TYPE_INFO structures. Each member of the array defines an output format that
    ///the MFT supports. If this member is <b>NULL</b>, the <b>cOutTypes</b> member must be zero.
    MFT_REGISTER_TYPE_INFO* pOutTypes;
}

///Contains information about the data that you want to provide as input to a protection system function.
struct MFCONTENTPROTECTIONDEVICE_INPUT_DATA
{
    ///The identifier of the function that you need to run. This value is defined by the implementation of the
    ///protection system.
    uint     HWProtectionFunctionID;
    ///The size of the private data that the implementation of the security processor implementation reserved. You can
    ///determine this value by calling the IMFContentProtectionDevice::GetPrivateDataByteCount method.
    uint     PrivateDataByteCount;
    ///The size of the data provided as input to the protection system function that you want to run.
    uint     HWProtectionDataByteCount;
    ///Reserved.
    uint     Reserved;
    ///The data to provide as input to the protection system function. If the value of the <b>PrivateDataByteCount</b>
    ///member is greater than 0, bytes 0 through <b>PrivateDataByteCount</b> - 1 are reserved for use by the independent
    ///hardware vendor (IHV). Bytes <b>PrivateDataByteCount</b> through <b>HWProtectionDataByteCount</b> +
    ///<b>PrivateDataByteCount</b> - 1 contain the input data for the protection system function. The protection system
    ///specification defines the format and size of the DRM function.
    ubyte[4] InputData;
}

///Contains information about the data you received as output from a protection system function.
struct MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA
{
    ///The size of the private data that the implementation of the security processor reserves, in bytes. You can
    ///determine this value by calling the IMFContentProtectionDevice::GetPrivateDataByteCount method.
    uint     PrivateDataByteCount;
    ///The maximum size of data that the independent hardware vendor (IHV) can return in the output buffer, in bytes.
    uint     MaxHWProtectionDataByteCount;
    ///The size of the data that the IHV wrote to the output buffer, in bytes.
    uint     HWProtectionDataByteCount;
    ///The result of the protection system function.
    HRESULT  Status;
    ///The number of 100 nanosecond units spent transporting the data.
    long     TransportTimeInHundredsOfNanoseconds;
    ///The number of 100 nanosecond units spent running the protection system function.
    long     ExecutionTimeInHundredsOfNanoseconds;
    ///The output of the protection system function. If the value of the <b>PrivateDataByteCount</b> member is greater
    ///than 0, bytes 0 through <b>PrivateDataByteCount</b> - 1 are reserved for IHV use. Bytes
    ///<b>PrivateDataByteCount</b> through <b>MaxHWProtectionDataByteCount</b> + <b>PrivateDataByteCount</b> - 1 contain
    ///the region of the array into which the driver should return the output data from the protection system function.
    ///The protection system specification defines the format and size of the function.
    ubyte[4] OutputData;
}

///Advises the secure processor of the Multimedia Class Scheduler service (MMCSS) parameters so that real-time tasks can
///be scheduled at the expected priority.
struct MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA
{
    ///The identifier for the MMCSS task.
    uint        TaskIndex;
    ///The name of the MMCSS task.
    ushort[260] ClassName;
    ///The base priority of the thread that runs the MMCSS task.
    int         BasePriority;
}

///Reporesents the status of a Content Decryption Module (CDM) session key.
struct MFMediaKeyStatus
{
    ///A byte array representing the identifier of a session key.
    ubyte*             pbKeyId;
    ///The number of bytes in the *pbKeyId* paramater.
    uint               cbKeyId;
    ///A value from the [MF_MEDIAKEY_STATUS](ne-mfidl-mf_mediakey_status) enumeration specifying the status of the
    ///associated session key.
    MF_MEDIAKEY_STATUS eMediaKeyStatus;
}

struct MF_VIDEO_SPHERICAL_VIEWDIRECTION
{
    int iHeading;
    int iPitch;
    int iRoll;
}

///Describes a sensor profile ID.
struct SENSORPROFILEID
{
    ///A Sensor Profile GUID that describes the type of sensor profile.
    GUID Type;
    ///The index of the sensor profile.
    uint Index;
    uint Unused;
}

struct MFCameraIntrinsic_CameraModel
{
    float FocalLength_x;
    float FocalLength_y;
    float PrincipalPoint_x;
    float PrincipalPoint_y;
}

struct MFCameraIntrinsic_DistortionModel6KT
{
    float Radial_k1;
    float Radial_k2;
    float Radial_k3;
    float Radial_k4;
    float Radial_k5;
    float Radial_k6;
    float Tangential_p1;
    float Tangential_p2;
}

struct MFCameraIntrinsic_DistortionModelArcTan
{
    float Radial_k0;
    float DistortionCenter_x;
    float DistortionCenter_y;
    float Tangential_x;
    float Tangential_y;
}

struct MFExtendedCameraIntrinsic_IntrinsicModel
{
    uint Width;
    uint Height;
    uint SplitFrameId;
    MFCameraIntrinsic_CameraModel CameraModel;
}

///Specifies an index for the ASF indexer object.
struct ASF_INDEX_IDENTIFIER
{
    ///The type of index. Currently this value must be GUID_NULL, which specifies time-based indexing.
    GUID   guidIndexType;
    ///The stream number to which this structure applies.
    ushort wStreamNumber;
}

///Describes the indexing configuration for a stream and type of index.
struct ASF_INDEX_DESCRIPTOR
{
    ///ASF_INDEX_IDENTIFIER structure that identifies the stream number and the type of index.
    ASF_INDEX_IDENTIFIER Identifier;
    ///Number of bytes used for each index entry. If the value is MFASFINDEXER_PER_ENTRY_BYTES_DYNAMIC, the index
    ///entries have variable size.
    ushort               cPerEntryBytes;
    ///Optional text description of the index.
    ushort[32]           szDescription;
    ///Indexing interval. The units of this value depend on the index type. A value of MFASFINDEXER_NO_FIXED_INTERVAL
    ///indicates that there is no fixed indexing interval.
    uint                 dwInterval;
}

///Contains statistics about the progress of the ASF multiplexer.
struct ASF_MUX_STATISTICS
{
    ///Number of frames written by the ASF multiplexer.
    uint cFramesWritten;
    ///Number of frames dropped by the ASF multiplexer.
    uint cFramesDropped;
}

///Defines a normalized rectangle, which is used to specify sub-rectangles in a video rectangle. When a rectangle N is
///<i>normalized</i> relative to some other rectangle R, it means the following: <ul> <li> The coordinate (0.0, 0.0) on
///N is mapped to the upper-left corner of R. </li> <li> The coordinate (1.0, 1.0) on N is mapped to the lower-right
///corner of R. </li> </ul> Any coordinates of N that fall outside the range [0...1] are mapped to positions outside the
///rectangle R. A normalized rectangle can be used to specify a region within a video rectangle without knowing the
///resolution or even the aspect ratio of the video. For example, the upper-left quadrant is defined as {0.0, 0.0, 0.5,
///0.5}.
struct MFVideoNormalizedRect
{
    ///X-coordinate of the upper-left corner of the rectangle.
    float left;
    ///Y-coordinate of the upper-left corner of the rectangle.
    float top;
    ///X-coordinate of the lower-right corner of the rectangle.
    float right;
    ///Y-coordinate of the lower-right corner of the rectangle.
    float bottom;
}

struct MOVE_RECT
{
    POINT SourcePoint;
    RECT  DestRect;
}

struct DIRTYRECT_INFO
{
    uint    FrameNumber;
    uint    NumDirtyRects;
    RECT[1] DirtyRects;
}

struct MOVEREGION_INFO
{
    uint         FrameNumber;
    uint         NumMoveRegions;
    MOVE_RECT[1] MoveRegions;
}

///Defines a regions of interest.
struct ROI_AREA
{
    ///The bounds of the region.
    RECT rect;
    ///Specifies the quantization parameter delta for the specified region from the rest of the frame.
    int  QPDelta;
}

struct MACROBLOCK_DATA
{
    uint  flags;
    short motionVectorX;
    short motionVectorY;
    int   QPDelta;
}

///Contains coefficients used to transform multichannel audio into a smaller number of audio channels. This process is
///called <i>fold-down</i>.
struct MFFOLDDOWN_MATRIX
{
    ///Size of the structure, in bytes.
    uint    cbSize;
    ///Number of source channels.
    uint    cSrcChannels;
    ///Number of destination channels.
    uint    cDstChannels;
    ///Specifies the assignment of audio channels to speaker positions in the transformed audio. This member is a
    ///bitwise <b>OR</b> of flags that define the speaker positions. For a list of valid flags, see
    ///MF_MT_AUDIO_CHANNEL_MASK attribute.
    uint    dwChannelMask;
    ///Array that contains the fold-down coefficients. The number of coefficients is
    ///<b>cSrcChannels</b>Ã—<b>cDstChannels</b>. If the number of coefficients is less than the size of the array, the
    ///remaining elements in the array are ignored. For more information about how the coefficients are applied, see
    ///Windows Media Audio Professional Codec Features.
    int[64] Coeff;
}

///Defines custom color primaries for a video source. The color primaries define how to convert colors from RGB color
///space to CIE XYZ color space.
struct MT_CUSTOM_VIDEO_PRIMARIES
{
    ///Red x-coordinate.
    float fRx;
    ///Red y-coordinate.
    float fRy;
    ///Green x-coordinate.
    float fGx;
    ///Green y-coordinate.
    float fGy;
    ///Blue x-coordinate.
    float fBx;
    ///Blue y-coordinate.
    float fBy;
    ///White point x-coordinate.
    float fWx;
    ///White point y-coordinate.
    float fWy;
}

///Contains format data for a binary stream in an Advanced Streaming Format (ASF) file.
struct MT_ARBITRARY_HEADER
{
    ///Major media type. This value is the GUID stored in the Major Media Type field of the Type-Specific Data field of
    ///the ASF file. It might not match the major type GUID from the Media Foundation media type.
    GUID majortype;
    ///Media subtype.
    GUID subtype;
    ///If <b>TRUE</b>, samples have a fixed size in bytes. Otherwise, samples have variable size.
    BOOL bFixedSizeSamples;
    ///If <b>TRUE</b>, the data in this stream uses temporal compression. Otherwise, samples are independent of each
    ///other.
    BOOL bTemporalCompression;
    ///If <b>bFixedSizeSamples</b> is <b>TRUE</b>, this member specifies the sample size in bytes. Otherwise, the value
    ///is ignored and should be 0.
    uint lSampleSize;
    ///Format type GUID. This GUID identifies the structure of the additional format data, which is stored in the
    ///MF_MT_ARBITRARY_FORMAT attribute of the media type. If no additional format data is present, <b>formattype</b>
    ///equals GUID_NULL.
    GUID formattype;
}

///A vector with two components.
struct MF_FLOAT2
{
    ///X component of the vector.
    float x;
    ///Y component of the vector.
    float y;
}

///A vector with three components.
struct MF_FLOAT3
{
    ///X component of the vector.
    float x;
    ///Y component of the vector.
    float y;
    ///Z component of the vector.
    float z;
}

///A four dimensional vector, used to represent a rotation.
struct MF_QUATERNION
{
    ///X component of the vector.
    float x;
    ///Y component of the vector.
    float y;
    ///Z component of the vector.
    float z;
    ///W component of the vector.
    float w;
}

///A transform describing the location of a camera relative to other cameras or an established external reference.
struct MFCameraExtrinsic_CalibratedTransform
{
    ///A reference GUID identifying the calibration process for the data, allowing different consumers to identify
    ///calibration data from the same process.
    GUID          CalibrationId;
    ///The transform position.
    MF_FLOAT3     Position;
    ///The transform rotation.
    MF_QUATERNION Orientation;
}

///Describes the location of a camera relative to other cameras or an established external reference.
struct MFCameraExtrinsics
{
    ///The number of transforms in the <i>CalibratedTransforms</i> array.
    uint TransformCount;
    ///The array of transforms in the extrinsic data.
    MFCameraExtrinsic_CalibratedTransform[1] CalibratedTransforms;
}

///Represents a pinhole camera model.
struct MFCameraIntrinsic_PinholeCameraModel
{
    ///The focal length of the camera.
    MF_FLOAT2 FocalLength;
    ///The principal point of the camera.
    MF_FLOAT2 PrincipalPoint;
}

///Represents a polynomial lens distortion model.
struct MFCameraIntrinsic_DistortionModel
{
    ///The first radial distortion coefficient.
    float Radial_k1;
    ///The second radial distortion coefficient.
    float Radial_k2;
    ///The third radial distortion coefficient.
    float Radial_k3;
    ///The first tangential distortion coefficient.
    float Tangential_p1;
    ///The second tangential distortion coefficient.
    float Tangential_p2;
}

///Represents a pinhole camera intrinsic model for a specified resolution.
struct MFPinholeCameraIntrinsic_IntrinsicModel
{
    ///The width for the pinhole camera intrinsic model, in pixels.
    uint Width;
    ///The height for the pinhole camera intrinsic model, in pixels.
    uint Height;
    ///The pinhole camera model.
    MFCameraIntrinsic_PinholeCameraModel CameraModel;
    ///The lens distortion model.
    MFCameraIntrinsic_DistortionModel DistortionModel;
}

///Contains zero or 1 pinhole camera intrinsic models that describe how to project a 3D point in physical world onto the
///2D image frame of a camera. The conventions assumed by this structure imply a left-handed 3D coordinate system, with
///+X pointing to the right of the sensor, +Y pointing upwards from the sensor, and +Z pointing forward out of the
///sensor through the center (principal point) of the image.
struct MFPinholeCameraIntrinsics
{
    ///The number of camera intrinsic models in the <i>IntrinsicModels</i> array.
    uint IntrinsicModelCount;
    ///The array of camera intrinsic models in the intrinsic data.
    MFPinholeCameraIntrinsic_IntrinsicModel[1] IntrinsicModels;
}

///Contains encoding statistics from the Digital Living Network Alliance (DLNA) media sink. This structure is used with
///the MF_MP2DLNA_STATISTICS attribute.
struct MFMPEG2DLNASINKSTATS
{
    ///Total number of bytes written to the byte stream.
    ulong cBytesWritten;
    ///If <b>TRUE</b>, the video stream is a PAL format. Otherwise, the video stream is an NTSC format.
    BOOL  fPAL;
    ///A FOURCC code that specifies the video format.
    uint  fccVideo;
    ///The width of the video frame, in pixels.
    uint  dwVideoWidth;
    ///The height of the video frame, in pixels.
    uint  dwVideoHeight;
    ///The number of video frames received.
    ulong cVideoFramesReceived;
    ///The number of video frames that have been encoded.
    ulong cVideoFramesEncoded;
    ///The number of video frames that have been skipped.
    ulong cVideoFramesSkipped;
    ///The number of black frames that have been encoded.
    ulong cBlackVideoFramesEncoded;
    ///The number of duplicated video frames.
    ulong cVideoFramesDuplicated;
    ///The audio sample rate, in samples per second.
    uint  cAudioSamplesPerSec;
    ///The number of audio channels.
    uint  cAudioChannels;
    ///The total amount of audio data received, in bytes.
    ulong cAudioBytesReceived;
    ///The number of audio frames that have been encoded.
    ulong cAudioFramesEncoded;
}

///Contains statistics about the performance of the sink writer.
struct MF_SINK_WRITER_STATISTICS
{
    ///The size of the structure, in bytes.
    uint  cb;
    ///The time stamp of the most recent sample given to the sink writer. The sink writer updates this value each time
    ///the application calls IMFSinkWriter::WriteSample.
    long  llLastTimestampReceived;
    ///The time stamp of the most recent sample to be encoded. The sink writer updates this value whenever it calls
    ///IMFTransform::ProcessOutput on the encoder.
    long  llLastTimestampEncoded;
    ///The time stamp of the most recent sample given to the media sink. The sink writer updates this value whenever it
    ///calls IMFStreamSink::ProcessSample on the media sink.
    long  llLastTimestampProcessed;
    ///The time stamp of the most recent stream tick. The sink writer updates this value whenever the application calls
    ///IMFSinkWriter::SendStreamTick.
    long  llLastStreamTickReceived;
    ///The system time of the most recent sample request from the media sink. The sink writer updates this value
    ///whenever it receives an MEStreamSinkRequestSample event from the media sink. The value is the current system
    ///time.
    long  llLastSinkSampleRequest;
    ///The number of samples received.
    ulong qwNumSamplesReceived;
    ///The number of samples encoded.
    ulong qwNumSamplesEncoded;
    ///The number of samples given to the media sink.
    ulong qwNumSamplesProcessed;
    ///The number of stream ticks received.
    ulong qwNumStreamTicksReceived;
    ///The amount of data, in bytes, currently waiting to be processed.
    uint  dwByteCountQueued;
    ///The total amount of data, in bytes, that has been sent to the media sink.
    ulong qwByteCountProcessed;
    ///The number of pending sample requests.
    uint  dwNumOutstandingSinkSampleRequests;
    ///The average rate, in media samples per 100-nanoseconds, at which the application sent samples to the sink writer.
    uint  dwAverageSampleRateReceived;
    ///The average rate, in media samples per 100-nanoseconds, at which the sink writer sent samples to the encoder.
    uint  dwAverageSampleRateEncoded;
    ///The average rate, in media samples per 100-nanoseconds, at which the sink writer sent samples to the media sink.
    uint  dwAverageSampleRateProcessed;
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Contains information that is common to every type of
///MFPlay event.
struct MFP_EVENT_HEADER
{
    ///The type of event, specified as a member of the MFP_EVENT_TYPE enumeration.
    MFP_EVENT_TYPE  eEventType;
    ///Error or success code for the operation that caused the event.
    HRESULT         hrEvent;
    ///Pointer to the IMFPMediaPlayer interface of the MFPlay player object that sent the event.
    IMFPMediaPlayer pMediaPlayer;
    ///The new state of the MFPlay player object, specified as a member of the MFP_MEDIAPLAYER_STATE enumeration.
    MFP_MEDIAPLAYER_STATE eState;
    ///A pointer to the <b>IPropertyStore</b> interface of a property store object. The property store is used to hold
    ///additional event data for some event types. This member might be <b>NULL</b>.
    IPropertyStore  pPropertyStore;
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Event structure for the <b>MFP_EVENT_TYPE_PLAY</b>
///event. This event is sent when the IMFPMediaPlayer::Play method completes.
struct MFP_PLAY_EVENT
{
    ///MFP_EVENT_HEADER structure that contains data common to all IMFPMediaPlayer events.
    MFP_EVENT_HEADER header;
    ///Pointer to the IMFPMediaItem interface of the current media item.
    IMFPMediaItem    pMediaItem;
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Event structure for the <b>MFP_EVENT_TYPE_PAUSE</b>
///event. This event is sent when the IMFPMediaPlayer::Pause method completes.
struct MFP_PAUSE_EVENT
{
    ///MFP_EVENT_HEADER structure that contains data common to all IMFPMediaPlayer events.
    MFP_EVENT_HEADER header;
    ///Pointer to the IMFPMediaItem interface of the current media item.
    IMFPMediaItem    pMediaItem;
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Event structure for the <b>MFP_EVENT_TYPE_STOP</b>
///event. This event is sent when the IMFPMediaPlayer::Stop method completes.
struct MFP_STOP_EVENT
{
    ///MFP_EVENT_HEADER structure that contains data common to all IMFPMediaPlayer events.
    MFP_EVENT_HEADER header;
    ///Pointer to the IMFPMediaItem interface of the current media item.
    IMFPMediaItem    pMediaItem;
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Event structure for the
///<b>MFP_EVENT_TYPE_POSITION_SET</b> event. This event is sent when the IMFPMediaPlayer::SetPosition method completes.
struct MFP_POSITION_SET_EVENT
{
    ///MFP_EVENT_HEADER structure that contains data common to all IMFPMediaPlayer events.
    MFP_EVENT_HEADER header;
    ///Pointer to the IMFPMediaItem interface of the current media item.
    IMFPMediaItem    pMediaItem;
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Event structure for the MFP_EVENT_TYPE_RATE_SET event.
///This event is sent when the IMFPMediaPlayer::SetRate method completes.
struct MFP_RATE_SET_EVENT
{
    ///MFP_EVENT_HEADER structure that contains data common to all IMFPMediaPlayer events.
    MFP_EVENT_HEADER header;
    ///Pointer to the IMFPMediaItem interface of the current media item.
    IMFPMediaItem    pMediaItem;
    ///New playback rate. This value can differ from the requested rate.
    float            flRate;
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Event structure for the
///<b>MFP_EVENT_TYPE_MEDIAITEM_CREATED</b> event. This event is sent when the IMFPMediaPlayer::CreateMediaItemFromURL or
///IMFPMediaPlayer::CreateMediaItemFromObject method completes.
struct MFP_MEDIAITEM_CREATED_EVENT
{
    ///MFP_EVENT_HEADER structure that contains data common to all IMFPMediaPlayer events.
    MFP_EVENT_HEADER header;
    ///Pointer to the IMFPMediaItem interface of the new media item. If creating the media item failed, this member is
    ///<b>NULL</b>.
    IMFPMediaItem    pMediaItem;
    ///Application-defined user data for the media item. This value is specified when the application calls
    ///CreateMediaItemFromURL or CreateMediaItemFromObject.
    size_t           dwUserData;
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Event structure for the
///<b>MFP_EVENT_TYPE_MEDIAITEM_SET</b> event. This event is sent when the IMFPMediaPlayer::SetMediaItem method
///completes.
struct MFP_MEDIAITEM_SET_EVENT
{
    ///MFP_EVENT_HEADER structure that contains data common to all IMFPMediaPlayer events.
    MFP_EVENT_HEADER header;
    ///A pointer to the IMFPMediaItem interface of the media item that was queued for playback.
    IMFPMediaItem    pMediaItem;
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Event structure for the
///<b>MFP_EVENT_TYPE_FRAME_STEP</b> event. This event is sent when the IMFPMediaPlayer::FrameStep method completes.
struct MFP_FRAME_STEP_EVENT
{
    ///MFP_EVENT_HEADER structure that contains data common to all IMFPMediaPlayer events.
    MFP_EVENT_HEADER header;
    ///Pointer to the IMFPMediaItem interface of the current media item.
    IMFPMediaItem    pMediaItem;
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Event structure for the
///<b>MFP_EVENT_TYPE_MEDIAITEM_CLEARED</b> event. This event is sent when the IMFPMediaPlayer::ClearMediaItem method
///completes.
struct MFP_MEDIAITEM_CLEARED_EVENT
{
    ///MFP_EVENT_HEADER structure that contains data common to all IMFPMediaPlayer events.
    MFP_EVENT_HEADER header;
    ///Pointer to the IMFPMediaItem interface of the media item that was cleared.
    IMFPMediaItem    pMediaItem;
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Event structure for the <b>MFP_EVENT_TYPE_MF</b> event.
///The MFPlay player object uses this event to forward certain events from the Media Foundation pipeline to the
///application.
struct MFP_MF_EVENT
{
    ///MFP_EVENT_HEADER structure that contains data common to all IMFPMediaPlayer events.
    MFP_EVENT_HEADER header;
    ///Media Foundation event type. Currently, the MFPlay player object forwards the following pipeline events to the
    ///application: <table> <tr> <th>Event</th> <th>Description</th> </tr> <tr> <td> MEBufferingStarted </td> <td>The
    ///source has started buffering data.</td> </tr> <tr> <td> MEBufferingStopped </td> <td>The source has stopped
    ///buffering data.</td> </tr> <tr> <td> MEExtendedType </td> <td>Custom event type.</td> </tr> <tr> <td>
    ///MEReconnectEnd </td> <td>The source has completed an attempt to reconnect to the server.</td> </tr> <tr> <td>
    ///MEReconnectStart </td> <td>The source is attempting to reconnect to the server.</td> </tr> <tr> <td>
    ///MERendererEvent </td> <td>Event sent by a renderer, such as the Enhanced Video Renderer (EVR).</td> </tr> <tr>
    ///<td> MEStreamSinkFormatChanged </td> <td>A stream format has changed.</td> </tr> </table>
    uint             MFEventType;
    ///Pointer to the IMFMediaEvent interface of the Media Foundation event.
    IMFMediaEvent    pMFMediaEvent;
    ///Pointer to the IMFPMediaItem interface of the current media item.
    IMFPMediaItem    pMediaItem;
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Event structure for the <b>MFP_EVENT_TYPE_ERROR</b>
///event. This event is sent if an error occurs during playback.
struct MFP_ERROR_EVENT
{
    ///MFP_EVENT_HEADER structure that contains data common to all IMFPMediaPlayer events. The <b>hrEvent</b> member of
    ///the structure contains the error code.
    MFP_EVENT_HEADER header;
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Event structure for the
///<b>MFP_EVENT_TYPE_PLAYBACK_ENDED</b> event. This event is sent when the current media item finishes playing.
struct MFP_PLAYBACK_ENDED_EVENT
{
    ///MFP_EVENT_HEADER structure that contains data common to all IMFPMediaPlayer events.
    MFP_EVENT_HEADER header;
    ///Pointer to the IMFPMediaItem interface of the media item that has just ended.
    IMFPMediaItem    pMediaItem;
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Event structure for the
///<b>MFP_EVENT_TYPE_ACQUIRE_USER_CREDENTIAL</b> event. This event is sent if the application plays a media file from a
///server that requires authentication. The application can respond by providing the user credentials.
struct MFP_ACQUIRE_USER_CREDENTIAL_EVENT
{
    ///MFP_EVENT_HEADER structure that contains data common to all IMFPMediaPlayer events.
    MFP_EVENT_HEADER header;
    ///Application-defined user data for the media item. This value is specified when the application calls
    ///IMFPMediaPlayer::CreateMediaItemFromURL or IMFPMediaPlayer::CreateMediaItemFromObject to create the media item.
    ///This event is sent (if at all) before the media item is created and before the application receives the
    ///<b>MFP_EVENT_TYPE_MEDIAITEM_CREATED</b> event. You can use the value of <b>dwUserData</b> to identify which media
    ///item requires authentication.
    size_t           dwUserData;
    ///The application should set this member to either <b>TRUE</b> or <b>FALSE</b> before returning from the
    ///IMFPMediaPlayerCallback::OnMediaPlayerEvent event callback. If the value is <b>TRUE</b> when the callback
    ///returns, MFPlay continues the authentication attempt. Otherwise, authentication fails.
    BOOL             fProceedWithAuthentication;
    ///The response code of the authentication challenge.
    HRESULT          hrAuthenticationStatus;
    ///The original URL that requires authentication.
    const(PWSTR)     pwszURL;
    ///The name of the site or proxy that requires authentication.
    const(PWSTR)     pwszSite;
    ///The name of the realm for this authentication.
    const(PWSTR)     pwszRealm;
    ///The name of the authentication package, such as "Digest" or "MBS_BASIC".
    const(PWSTR)     pwszPackage;
    ///The number of retries. This member is set to zero on the first attempt, and incremented once for each subsequent
    ///attempt.
    int              nRetries;
    ///Bitwise <b>OR</b> of zero or more flags from the _MFP_CREDENTIAL_FLAGS enumeration.
    uint             flags;
    ///Pointer to the IMFNetCredential interface. The application uses this interface to set the user's credentials.
    IMFNetCredential pCredential;
}

///Contains information about a media sharing device.
struct DEVICE_INFO
{
    ///The friendly name of the device.
    BSTR pFriendlyDeviceName;
    ///A string that uniquely identifes the device.
    BSTR pUniqueDeviceName;
    ///The manufacturer name.
    BSTR pManufacturerName;
    ///The model name.
    BSTR pModelName;
    ///The URL of an icon for the device.
    BSTR pIconURL;
}

///Specifies how the enhanced video renderer (EVR) alpha-blends a bitmap with the video.
struct MFVideoAlphaBitmapParams
{
    ///Bitwise OR of one or more flags from the MFVideoAlphaBitmapFlags enumeration. These flags indicate which of the
    ///other structure members contain valid information.
    uint  dwFlags;
    ///Source color key. This member is used if the <b>dwFlags</b> member contains the MFVideoAlphaBitmap_SrcColorKey
    ///flag. Any pixels in the bitmap that match the color key are rendered as transparent pixels. You cannot specify a
    ///color key if you are alpha-blending a Direct3D surface with per-pixel alpha (D3DFMT_A8R8G8B8).
    uint  clrSrcKey;
    ///Source rectangle. The source rectangle defines the region of the bitmap that is alpha-blended with the video. The
    ///source rectangle is given in pixels and is relative to the original bitmap. If you are alpha-blending a GDI
    ///bitmap, you must fill in this structure when you call IMFVideoMixerBitmap::SetAlphaBitmap. If you are
    ///alpha-blending a Direct3D surface and the <b>dwFlags</b> member contains the MFVideoAlphaBitmap_EntireDDS flag,
    ///the <b>rcSrc</b> member is ignored. If the flag is absent, you must fill in the <b>rcSrc</b> member. After
    ///setting the initiali bitmap, you can update the source rectangle by calling
    ///IMFVideoMixerBitmap::UpdateAlphaBitmapParameters. To update the source rectangle, set the
    ///MFVideoAlphaBitmap_SrcColorKey flag in the <b>dwFlags</b> member. The source rectangle cannot be an empty
    ///rectangle, and cannot exceed the bounds of the bitmap.
    RECT  rcSrc;
    ///Destination rectangle. The destination rectangle defines the region of the composited video image that receives
    ///the alpha-blended bitmap. The destination rectangle is specified as a normalized rectangle using the
    ///MFVideoNormalizedRect structure. This member is used if the <b>dwFlags</b> member contains the
    ///MFVideoAlphaBitmap_DestRect flag. Otherwise, the default destination rectangle is {0, 0, 1, 1}.
    MFVideoNormalizedRect nrcDest;
    ///Alpha blending value. This member is used if the <b>dwFlags</b> member contains the MFVideoAlphaBitmap_Alpha
    ///flag. Otherwise, the default value is 1.0 (opaque). The valid range is 0.0 to 1.0, inclusive. This value is
    ///applied to the entire bitmap image. To create transparent regions, use the <b>clrSrcKey</b> member or use a
    ///DirectDraw surface with per-pixel alpha.
    float fAlpha;
    ///Direct3D filtering mode to use when performing the alpha-blend operation. Specify the filter mode as a
    ///D3DTEXTUREFILTERTYPE value. For more information, see the Direct3D documentation. This member is used if the
    ///<b>dwFlags</b> member contains the MFVideoAlphaBitmap_FilterMode flag. Otherwise, the default value is
    ///D3DTEXF_POINT. Point filtering is particularly useful for images that contain text and will not be stretched.
    uint  dwFilterMode;
}

///Specifies a bitmap for the enhanced video renderer (EVR) to alpha-blend with the video.
struct MFVideoAlphaBitmap
{
    ///If <b>TRUE</b>, the <b>hdc</b> member is used. Otherwise, the <b>pDDs</b> member is used.
    BOOL GetBitmapFromDC;
union bitmap
    {
        HDC               hdc;
        IDirect3DSurface9 pDDS;
    }
    ///MFVideoAlphaBitmapParams structure that specifies the parameters for the alpha-blending operation.
    MFVideoAlphaBitmapParams params;
}

///The <b>CodecAPIEventData</b> structure contains event data for the EC_CODECAPI_EVENT event. This event is sent by
///codecs that support the ICodecAPI interface.
struct CodecAPIEventData
{
    ///A GUID that identifies the codec event.
    GUID    guid;
    ///The length of the additional data that follows this structure, in bytes. The value can be zero.
    uint    dataLength;
    ///Reserved; do not use.
    uint[3] reserved;
}

///Describes a video stream for a Microsoft Direct3D 11 video decoder or video processor.
struct D3D11_VIDEO_DECODER_DESC
{
    ///The decoding profile. To get the list of profiles supported by the device, call the
    ///ID3D11VideoDevice::GetVideoDecoderProfile method.
    GUID        Guid;
    ///The width of the video frame, in pixels.
    uint        SampleWidth;
    ///The height of the video frame, in pixels.
    uint        SampleHeight;
    ///The output surface format, specified as a DXGI_FORMAT value.
    DXGI_FORMAT OutputFormat;
}

///Describes the configuration of a Microsoft Direct3D 11 decoder device for DirectX Video Acceleration (DXVA).
struct D3D11_VIDEO_DECODER_CONFIG
{
    ///If the bitstream data buffers are encrypted using the D3D11CryptoSession mechanism, this GUID should be set to
    ///zero. If no encryption is applied, the value is <b>DXVA_NoEncrypt</b>. If <b>ConfigBitstreamRaw</b> is 0, the
    ///value must be <b>DXVA_NoEncrypt</b>.
    GUID   guidConfigBitstreamEncryption;
    ///If the macroblock control data buffers are encrypted using the D3D11CryptoSession mechanism, this GUID should be
    ///set to zero. If no encryption is applied, the value is <b>DXVA_NoEncrypt</b>. If <b>ConfigBitstreamRaw</b> is 1,
    ///the value must be <b>DXVA_NoEncrypt</b>.
    GUID   guidConfigMBcontrolEncryption;
    ///If the residual difference decoding data buffers are encrypted using the D3D11CryptoSession mechanism, this GUID
    ///should be set to zero. If no encryption is applied, the value is <b>DXVA_NoEncrypt</b>. If
    ///<b>ConfigBitstreamRaw</b> is 1, the value must be <b>DXVA_NoEncrypt</b>.
    GUID   guidConfigResidDiffEncryption;
    ///Indicates whether the host-decoder sends raw bit-stream data. If the value is 1, the data for the pictures will
    ///be sent in bit-stream buffers as raw bit-stream content. If the value is 0, picture data will be sent using
    ///macroblock control command buffers. If either <b>ConfigResidDiffHost</b> or <b>ConfigResidDiffAccelerator</b> is
    ///1, the value must be 0.
    uint   ConfigBitstreamRaw;
    ///Specifies whether macroblock control commands are in raster scan order or in arbitrary order. If the value is 1,
    ///the macroblock control commands within each macroblock control command buffer are in raster-scan order. If the
    ///value is 0, the order is arbitrary. For some types of bit streams, forcing raster order either greatly increases
    ///the number of required macroblock control buffers that must be processed, or requires host reordering of the
    ///control information. Therefore, supporting arbitrary order can be more efficient.
    uint   ConfigMBcontrolRasterOrder;
    ///Contains the host residual difference configuration. If the value is 1, some residual difference decoding data
    ///may be sent as blocks in the spatial domain from the host. If the value is 0, spatial domain data will not be
    ///sent.
    uint   ConfigResidDiffHost;
    ///Indicates the word size used to represent residual difference spatial-domain blocks for predicted (non-intra)
    ///pictures when using host-based residual difference decoding. If <b>ConfigResidDiffHost</b> is 1 and
    ///<b>ConfigSpatialResid8</b> is 1, the host will send residual difference spatial-domain blocks for non-intra
    ///macroblocks using 8-bit signed samples and for intra macroblocks in predicted (non-intra) pictures in a format
    ///that depends on the value of <b>ConfigIntraResidUnsigned</b>: <ul> <li>If <b>ConfigIntraResidUnsigned</b> is 0,
    ///spatial-domain blocks for intra macroblocks are sent as 8-bit signed integer values relative to a constant
    ///reference value of 2^(BPPâ€“1). </li> <li>If <b>ConfigIntraResidUnsigned</b> is 1, spatial-domain blocks for
    ///intra macroblocks are sent as 8-bit unsigned integer values relative to a constant reference value of 0. </li>
    ///</ul> If <b>ConfigResidDiffHost</b> is 1 and <b>ConfigSpatialResid8</b> is 0, the host will send residual
    ///difference spatial-domain blocks of data for non-intra macroblocks using 16-bit signed samples and for intra
    ///macroblocks in predicted (non-intra) pictures in a format that depends on the value of
    ///<b>ConfigIntraResidUnsigned</b>: <ul> <li>If <b>ConfigIntraResidUnsigned</b> is 0, spatial domain blocks for
    ///intra macroblocks are sent as 16-bit signed integer values relative to a constant reference value of 2^(BPPâ€“1).
    ///</li> <li>If <b>ConfigIntraResidUnsigned</b> is 1, spatial domain blocks for intra macroblocks are sent as 16-bit
    ///unsigned integer values relative to a constant reference value of 0. </li> </ul> If <b>ConfigResidDiffHost</b> is
    ///0, <b>ConfigSpatialResid8</b> must be 0. For intra pictures, spatial-domain blocks must be sent using 8-bit
    ///samples if bits-per-pixel (BPP) is 8, and using 16-bit samples if BPP &gt; 8. If <b>ConfigIntraResidUnsigned</b>
    ///is 0, these samples are sent as signed integer values relative to a constant reference value of 2^(BPPâ€“1), and
    ///if <b>ConfigIntraResidUnsigned</b> is 1, these samples are sent as unsigned integer values relative to a constant
    ///reference value of 0.
    uint   ConfigSpatialResid8;
    ///If the value is 1, 8-bit difference overflow blocks are subtracted rather than added. The value must be 0 unless
    ///<b>ConfigSpatialResid8</b> is 1. The ability to subtract differences rather than add them enables 8-bit
    ///difference decoding to be fully compliant with the full Â±255 range of values required in video decoder
    ///specifications, because +255 cannot be represented as the addition of two signed 8-bit numbers, but any number in
    ///the range Â±255 can be represented as the difference between two signed 8-bit numbers (+255 = +127 minus â€“128).
    uint   ConfigResid8Subtraction;
    ///If the value is 1, spatial-domain blocks for intra macroblocks must be clipped to an 8-bit range on the host and
    ///spatial-domain blocks for non-intra macroblocks must be clipped to a 9-bit range on the host. If the value is 0,
    ///no such clipping is necessary by the host. The value must be 0 unless <b>ConfigSpatialResid8</b> is 0 and
    ///<b>ConfigResidDiffHost</b> is 1.
    uint   ConfigSpatialHost8or9Clipping;
    ///If the value is 1, any spatial-domain residual difference data must be sent in a chrominance-interleaved form
    ///matching the YUV format chrominance interleaving pattern. The value must be 0 unless <b>ConfigResidDiffHost</b>
    ///is 1 and the YUV format is NV12 or NV21.
    uint   ConfigSpatialResidInterleaved;
    ///Indicates the method of representation of spatial-domain blocks of residual difference data for intra blocks when
    ///using host-based difference decoding. If <b>ConfigResidDiffHost</b> is 1 and <b>ConfigIntraResidUnsigned</b> is
    ///0, spatial-domain residual difference data blocks for intra macroblocks must be sent as follows: <ul> <li>In a
    ///non-intra picture, if <b>ConfigSpatialResid8</b> is 0, the spatial-domain residual difference data blocks for
    ///intra macroblocks are sent as 16-bit signed integer values relative to a constant reference value of 2^(BPPâ€“1).
    ///</li> <li>In a non-intra picture, if <b>ConfigSpatialResid8</b> is 1, the spatial-domain residual difference data
    ///blocks for intra macroblocks are sent as 8-bit signed integer values relative to a constant reference value of
    ///2^(BPPâ€“1). </li> <li>In an intra picture, if BPP is 8, the spatial-domain residual difference data blocks for
    ///intra macroblocks are sent as 8-bit signed integer values relative to a constant reference value of 2^(BPPâ€“1),
    ///regardless of the value of <b>ConfigSpatialResid8</b>. </li> </ul> If <b>ConfigResidDiffHost</b> is 1 and
    ///<b>ConfigIntraResidUnsigned</b> is 1, spatial-domain residual difference data blocks for intra macroblocks must
    ///be sent as follows: <ul> <li>In a non-intra picture, if <b>ConfigSpatialResid8</b> is 0, the spatial-domain
    ///residual difference data blocks for intra macroblocks must be sent as 16-bit unsigned integer values relative to
    ///a constant reference value of 0. </li> <li>In a non-intra picture, if <b>ConfigSpatialResid8</b> is 1, the
    ///spatial-domain residual difference data blocks for intra macroblocks are sent as 8-bit unsigned integer values
    ///relative to a constant reference value of 0. </li> <li>In an intra picture, if BPP is 8, the spatial-domain
    ///residual difference data blocks for intra macroblocks are sent as 8-bit unsigned integer values relative to a
    ///constant reference value of 0, regardless of the value of <b>ConfigSpatialResid8</b>. </li> </ul> The value of
    ///the member must be 0 unless <b>ConfigResidDiffHost</b> is 1.
    uint   ConfigIntraResidUnsigned;
    ///If the value is 1, transform-domain blocks of coefficient data may be sent from the host for accelerator-based
    ///IDCT. If the value is 0, accelerator-based IDCT will not be used. If both <b>ConfigResidDiffHost</b> and
    ///<b>ConfigResidDiffAccelerator</b> are 1, this indicates that some residual difference decoding will be done on
    ///the host and some on the accelerator, as indicated by macroblock-level control commands. The value must be 0 if
    ///<b>ConfigBitstreamRaw</b> is 1.
    uint   ConfigResidDiffAccelerator;
    ///If the value is 1, the inverse scan for transform-domain block processing will be performed on the host, and
    ///absolute indices will be sent instead for any transform coefficients. If the value is 0, the inverse scan will be
    ///performed on the accelerator. The value must be 0 if <b>ConfigResidDiffAccelerator</b> is 0 or if
    ///<b>Config4GroupedCoefs</b> is 1.
    uint   ConfigHostInverseScan;
    ///If the value is 1, the IDCT specified in Annex W of ITU-T Recommendation H.263 is used. If the value is 0, any
    ///compliant IDCT can be used for off-host IDCT. The H.263 annex does not comply with the IDCT requirements of
    ///MPEG-2 corrigendum 2, so the value must not be 1 for use with MPEG-2 video. The value must be 0 if
    ///<b>ConfigResidDiffAccelerator</b> is 0, indicating purely host-based residual difference decoding.
    uint   ConfigSpecificIDCT;
    ///If the value is 1, transform coefficients for off-host IDCT will be sent using the DXVA_TCoef4Group structure. If
    ///the value is 0, the DXVA_TCoefSingle structure is used. The value must be 0 if <b>ConfigResidDiffAccelerator</b>
    ///is 0 or if <b>ConfigHostInverseScan</b> is 1.
    uint   Config4GroupedCoefs;
    ///Specifies how many frames the decoder device processes at any one time.
    ushort ConfigMinRenderTargetBuffCount;
    ///Contains decoder-specific configuration information.
    ushort ConfigDecoderSpecific;
}

///Contains an initialization vector (IV) for 128-bit Advanced Encryption Standard CTR mode (AES-CTR) block cipher
///encryption.
struct D3D11_AES_CTR_IV
{
    ///The IV, in big-endian format.
    ulong IV;
    ///The block count, in big-endian format.
    ulong Count;
}

///Specifies which bytes in a video surface are encrypted.
struct D3D11_ENCRYPTED_BLOCK_INFO
{
    ///The number of bytes that are encrypted at the start of the buffer.
    uint NumEncryptedBytesAtBeginning;
    ///The number of bytes that are skipped after the first <b>NumEncryptedBytesAtBeginning</b> bytes, and then after
    ///each block of <b>NumBytesInEncryptPattern</b> bytes. Skipped bytes are not encrypted.
    uint NumBytesInSkipPattern;
    ///The number of bytes that are encrypted after each block of skipped bytes.
    uint NumBytesInEncryptPattern;
}

///Describes a compressed buffer for decoding.
struct D3D11_VIDEO_DECODER_BUFFER_DESC
{
    ///The type of buffer, specified as a member of the D3D11_VIDEO_DECODER_BUFFER_TYPE enumeration.
    D3D11_VIDEO_DECODER_BUFFER_TYPE BufferType;
    ///Reserved.
    uint  BufferIndex;
    ///The offset of the relevant data from the beginning of the buffer, in bytes. This value must be zero.
    uint  DataOffset;
    uint  DataSize;
    ///The macroblock address of the first macroblock in the buffer. The macroblock address is given in raster scan
    ///order.
    uint  FirstMBaddress;
    ///The number of macroblocks of data in the buffer. This count includes skipped macroblocks.
    uint  NumMBsInBuffer;
    ///Reserved. Set to zero.
    uint  Width;
    ///Reserved. Set to zero.
    uint  Height;
    ///Reserved. Set to zero.
    uint  Stride;
    ///Reserved. Set to zero.
    uint  ReservedBits;
    ///A pointer to a buffer that contains an initialization vector (IV) for encrypted data. If the decode buffer does
    ///not contain encrypted data, set this member to <b>NULL</b>.
    void* pIV;
    ///The size of the buffer specified in the <b>pIV</b> parameter. If <b>pIV</b> is <b>NULL</b>, set this member to
    ///zero.
    uint  IVSize;
    ///If <b>TRUE</b>, the video surfaces are partially encrypted.
    BOOL  PartialEncryption;
    ///A D3D11_ENCRYPTED_BLOCK_INFO structure that specifies which bytes of the surface are encrypted.
    D3D11_ENCRYPTED_BLOCK_INFO EncryptedBlockInfo;
}

///Contains driver-specific data for the ID3D11VideoContext::DecoderExtension method.
struct D3D11_VIDEO_DECODER_EXTENSION
{
    ///The function number. This number identifies the operation to perform. Currently no function numbers are defined.
    uint            Function;
    ///A pointer to a buffer that contains input data for the driver.
    void*           pPrivateInputData;
    ///The size of the <b>pPrivateInputData</b> buffer, in bytes.
    uint            PrivateInputDataSize;
    ///A pointer to a buffer that the driver can use to write output data.
    void*           pPrivateOutputData;
    ///The size of the <b>pPrivateOutputData</b> buffer, in bytes.
    uint            PrivateOutputDataSize;
    ///The number of elements in the <b>ppResourceList</b> array. If <b>ppResourceList</b> is <b>NULL</b>, set
    ///<b>ResourceCount</b> to zero.
    uint            ResourceCount;
    ///The address of an array of ID3D11Resource pointers. Use this member to pass Direct3D resources to the driver.
    ID3D11Resource* ppResourceList;
}

///Describes the capabilities of a Microsoft Direct3D 11 video processor.
struct D3D11_VIDEO_PROCESSOR_CAPS
{
    ///A bitwise <b>OR</b> of zero or more flags from the D3D11_VIDEO_PROCESSOR_DEVICE_CAPS enumeration.
    uint DeviceCaps;
    ///A bitwise <b>OR</b> of zero or more flags from the D3D11_VIDEO_PROCESSOR_FEATURE_CAPS enumeration.
    uint FeatureCaps;
    ///A bitwise <b>OR</b> of zero or more flags from the D3D11_VIDEO_PROCESSPR_FILTER_CAPS enumeration.
    uint FilterCaps;
    ///A bitwise <b>OR</b> of zero or more flags from the D3D11_VIDEO_PROCESSOR_FORMAT_CAPS enumeration.
    uint InputFormatCaps;
    ///A bitwise <b>OR</b> of zero or more flags from the D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS enumeration.
    uint AutoStreamCaps;
    ///A bitwise <b>OR</b> of zero or more flags from the D3D11_VIDEO_PROCESSOR_STEREO_CAPS enumeration.
    uint StereoCaps;
    ///The number of frame-rate conversion capabilities. To enumerate the frame-rate conversion capabilities, call the
    ///ID3D11VideoProcessorEnumerator::GetVideoProcessorRateConversionCaps method.
    uint RateConversionCapsCount;
    ///The maximum number of input streams that can be enabled at the same time.
    uint MaxInputStreams;
    ///The maximum number of input streams for which the device can store state data.
    uint MaxStreamStates;
}

///Defines a group of video processor capabilities that are associated with frame-rate conversion, including
///deinterlacing and inverse telecine.
struct D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS
{
    ///The number of past reference frames required to perform the optimal video processing.
    uint PastFrames;
    ///The number of future reference frames required to perform the optimal video processing.
    uint FutureFrames;
    ///A bitwise <b>OR</b> of zero or more flags from the D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS enumeration.
    uint ProcessorCaps;
    ///A bitwise <b>OR</b> of zero or more flags from the D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS enumeration.
    uint ITelecineCaps;
    ///The number of custom frame rates that the driver supports. To get the list of custom frame rates, call the
    ///ID3D11VideoProcessorEnumerator::GetVideoProcessorCustomRate method.
    uint CustomRateCount;
}

///Describes the content-protection capabilities of a graphics driver.
struct D3D11_VIDEO_CONTENT_PROTECTION_CAPS
{
    ///A bitwise <b>OR</b> of zero or more flags from the D3D11_CONTENT_PROTECTION_CAPS enumeration.
    uint  Caps;
    ///The number of cryptographic key-exchange types that are supported by the driver. To get the list of key-exchange
    ///types, call the ID3D11VideoDevice::CheckCryptoKeyExchange method.
    uint  KeyExchangeTypeCount;
    ///The encyrption block size, in bytes. The size of data to be encrypted must be a multiple of this value.
    uint  BlockAlignmentSize;
    ///The total amount of memory, in bytes, that can be used to hold protected surfaces.
    ulong ProtectedMemorySize;
}

///Specifies a custom rate for frame-rate conversion or inverse telecine (IVTC).
struct D3D11_VIDEO_PROCESSOR_CUSTOM_RATE
{
    ///The ratio of the output frame rate to the input frame rate, expressed as a DXGI_RATIONAL structure that holds a
    ///rational number.
    DXGI_RATIONAL CustomRate;
    ///The number of output frames that will be generated for every <i>N</i> input samples, where <i>N</i> =
    ///<b>InputFramesOrFields</b>.
    uint          OutputFrames;
    ///If <b>TRUE</b>, the input stream must be interlaced. Otherwise, the input stream must be progressive.
    BOOL          InputInterlaced;
    ///The number of input fields or frames for every <i>N</i> output frames that will be generated, where <i>N</i> =
    ///<b>OutputFrames</b>.
    uint          InputFramesOrFields;
}

///Defines the range of supported values for an image filter.
struct D3D11_VIDEO_PROCESSOR_FILTER_RANGE
{
    ///The minimum value of the filter.
    int   Minimum;
    ///The maximum value of the filter.
    int   Maximum;
    ///The default value of the filter.
    int   Default;
    ///A multiplier. Use the following formula to translate the filter setting into the actual filter value: <i>Actual
    ///Value</i> = <i>Set Value</i> Ã— <i>Multiplier</i>.
    float Multiplier;
}

///Describes a video stream for a video processor.
struct D3D11_VIDEO_PROCESSOR_CONTENT_DESC
{
    ///A member of the D3D11_VIDEO_FRAME_FORMAT enumeration that describes how the video stream is interlaced.
    D3D11_VIDEO_FRAME_FORMAT InputFrameFormat;
    ///The frame rate of the input video stream, specified as a DXGI_RATIONAL structure.
    DXGI_RATIONAL     InputFrameRate;
    ///The width of the input frames, in pixels.
    uint              InputWidth;
    ///The height of the input frames, in pixels.
    uint              InputHeight;
    ///The frame rate of the output video stream, specified as a DXGI_RATIONAL structure.
    DXGI_RATIONAL     OutputFrameRate;
    ///The width of the output frames, in pixels.
    uint              OutputWidth;
    ///The height of the output frames, in pixels.
    uint              OutputHeight;
    ///A member of the D3D11_VIDEO_USAGE enumeration that describes how the video processor will be used. The value
    ///indicates the desired trade-off between speed and video quality. The driver uses this flag as a hint when it
    ///creates the video processor.
    D3D11_VIDEO_USAGE Usage;
}

///Specifies an RGB color value.
struct D3D11_VIDEO_COLOR_RGBA
{
    ///The red value.
    float R;
    ///The green value.
    float G;
    ///The blue value.
    float B;
    ///The alpha value. Values range from 0 (transparent) to 1 (opaque).
    float A;
}

///Specifies a YCbCr color value.
struct D3D11_VIDEO_COLOR_YCbCrA
{
    ///The Y luma value.
    float Y;
    ///The Cb chroma value.
    float Cb;
    ///The Cr chroma value.
    float Cr;
    ///The alpha value. Values range from 0 (transparent) to 1 (opaque).
    float A;
}

///Defines a color value for Microsoft Direct3D 11 video.
struct D3D11_VIDEO_COLOR
{
union
    {
        D3D11_VIDEO_COLOR_YCbCrA YCbCr;
        D3D11_VIDEO_COLOR_RGBA RGBA;
    }
}

///Specifies the color space for video processing.
struct D3D11_VIDEO_PROCESSOR_COLOR_SPACE
{
    uint _bitfield68;
}

///Contains stream-level data for the ID3D11VideoContext::VideoProcessorBlt method.
struct D3D11_VIDEO_PROCESSOR_STREAM
{
    ///Specifies whether this input stream is enabled. If the value is <b>TRUE</b>, the VideoProcessorBlt method blits
    ///this stream to the output surface. Otherwise, this stream is not blitted. The maximum number of streams that can
    ///be enabled at one time is given in the <b>MaxInputStreams</b> member of the D3D11_VIDEO_PROCESSOR_CAPS structure.
    BOOL Enable;
    ///The zero-based index number of the output frame.
    uint OutputIndex;
    ///The zero-based index number of the input frame or field.
    uint InputFrameOrField;
    ///The number of past reference frames.
    uint PastFrames;
    ///The number of future reference frames.
    uint FutureFrames;
    ///A pointer to an array of ID3D11VideoProcessorInputView pointers, allocated by the caller. This array contains the
    ///past reference frames for the video processing operation. The number of elements in the array is equal to
    ///<b>PastFrames</b>.
    ID3D11VideoProcessorInputView* ppPastSurfaces;
    ///A pointer to the ID3D11VideoProcessorInputView interface of the surface that contains the current input frame.
    ID3D11VideoProcessorInputView pInputSurface;
    ///A pointer to an array of ID3D11VideoProcessorInputView pointers, allocated by the caller. This array contains the
    ///future reference frames for the video processing operation. The number of elements in the array is equal to
    ///<b>FutureFrames</b>.
    ID3D11VideoProcessorInputView* ppFutureSurfaces;
    ///If the stereo 3D format is <b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_SEPARATE</b>, this member points to an array
    ///that contains the past reference frames for the right view. The number of elements in the array is equal to
    ///<b>PastFrames</b>. For any other stereo 3D format, set this member to <b>NULL</b>. For more information, see
    ///ID3D11VideoContext::VideoProcessorSetStreamStereoFormat.
    ID3D11VideoProcessorInputView* ppPastSurfacesRight;
    ///If the stereo 3D format is <b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_SEPARATE</b>, this member contains a pointer to
    ///the current input frame for the right view. For any other stereo 3D format, set this member to <b>NULL</b>.
    ID3D11VideoProcessorInputView pInputSurfaceRight;
    ///If the stereo 3D format is <b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_SEPARATE</b>, this member points to an array
    ///that contains the future reference frames for the right view. The number of elements in the array is equal to
    ///<b>FutureFrames</b>. For any other stereo 3D format, set this member to <b>NULL</b>.
    ID3D11VideoProcessorInputView* ppFutureSurfacesRight;
}

///Contains a Message Authentication Code (MAC).
struct D3D11_OMAC
{
    ///A byte array that contains the cryptographic MAC value of the message.
    ubyte[16] Omac;
}

///Contains input data for the ID3D11VideoContext::QueryAuthenticatedChannel method.
struct D3D11_AUTHENTICATED_QUERY_INPUT
{
    ///A GUID that specifies the query. The following GUIDs are defined. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ATTRIBUTES"></a><a
    ///id="d3d11_authenticated_query_accessibility_attributes"></a><dl>
    ///<dt><b>D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ATTRIBUTES</b></dt> </dl> </td> <td width="60%"> Returns the type
    ///of I/O bus that is used to send data to the GPU. Output data structure:
    ///D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_OUTPUT </td> </tr> <tr> <td width="40%"><a
    ///id="D3D11_AUTHENTICATED_QUERY_CHANNEL_TYPE"></a><a id="d3d11_authenticated_query_channel_type"></a><dl>
    ///<dt><b>D3D11_AUTHENTICATED_QUERY_CHANNEL_TYPE</b></dt> </dl> </td> <td width="60%"> Returns the type of
    ///authenticated channel. Output data structure: D3D11_AUTHENTICATED_QUERY_CHANNEL_TYPE_OUTPUT </td> </tr> <tr> <td
    ///width="40%"><a id="D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION"></a><a
    ///id="d3d11_authenticated_query_crypto_session"></a><dl> <dt><b>D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION</b></dt>
    ///</dl> </td> <td width="60%"> Returns handles to the cryptographic session and Direct3D device that are associated
    ///with a specified decoder device. Input data structure: D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION_INPUT Output data
    ///structure: D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION_OUTPUT </td> </tr> <tr> <td width="40%"><a
    ///id="D3D11_AUTHENTICATED_QUERY_CURRENT_ENCRYPTION_WHEN_ACCESSIBLE"></a><a
    ///id="d3d11_authenticated_query_current_encryption_when_accessible"></a><dl>
    ///<dt><b>D3D11_AUTHENTICATED_QUERY_CURRENT_ENCRYPTION_WHEN_ACCESSIBLE</b></dt> </dl> </td> <td width="60%"> Returns
    ///the encryption type that is applied before content becomes accessible to the CPU or bus. Output data structure:
    ///D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_COUNT_OUTPUT </td> </tr> <tr> <td width="40%"><a
    ///id="D3D11_AUTHENTICATED_QUERY_DEVICE_HANDLE"></a><a id="d3d11_authenticated_query_device_handle"></a><dl>
    ///<dt><b>D3D11_AUTHENTICATED_QUERY_DEVICE_HANDLE</b></dt> </dl> </td> <td width="60%"> Returns a handle to the
    ///device that is associated with this authenticated channel. Output data structure:
    ///D3D11_AUTHENTICATED_QUERY_DEVICE_HANDLE_OUTPUT </td> </tr> <tr> <td width="40%"><a
    ///id="D3D11_AUTHENTICATED_QUERY_ENCRYPTION_WHEN_ACCESSIBLE_GUID"></a><a
    ///id="d3d11_authenticated_query_encryption_when_accessible_guid"></a><dl>
    ///<dt><b>D3D11_AUTHENTICATED_QUERY_ENCRYPTION_WHEN_ACCESSIBLE_GUID</b></dt> </dl> </td> <td width="60%"> Returns
    ///one of the encryption types that can be used to encrypt content before it becomes accessible to the CPU or bus.
    ///Input data structure: D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_INPUT Output data structure:
    ///D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_OUTPUT </td> </tr> <tr> <td width="40%"><a
    ///id="D3D11_AUTHENTICATED_QUERY_ENCRYPTION_WHEN_ACCESSIBLE_GUID_COUNT"></a><a
    ///id="d3d11_authenticated_query_encryption_when_accessible_guid_count"></a><dl>
    ///<dt><b>D3D11_AUTHENTICATED_QUERY_ENCRYPTION_WHEN_ACCESSIBLE_GUID_COUNT</b></dt> </dl> </td> <td width="60%">
    ///Returns the number of encryption types that can be used to encrypt content before it becomes accessible to the
    ///CPU or bus. Output data structure: D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_COUNT_OUTPUT </td>
    ///</tr> <tr> <td width="40%"><a id="D3D11_AUTHENTICATED_QUERY_OUTPUT_ID"></a><a
    ///id="d3d11_authenticated_query_output_id"></a><dl> <dt><b>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID</b></dt> </dl> </td>
    ///<td width="60%"> Returns one of the output identifiers that is associated with a specified cryptographic session
    ///and Direct3D device. Input data structure: D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_INPUT Output data structure:
    ///D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_OUTPUT </td> </tr> <tr> <td width="40%"><a
    ///id="D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT"></a><a id="d3d11_authenticated_query_output_id_count"></a><dl>
    ///<dt><b>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT</b></dt> </dl> </td> <td width="60%"> Returns the number of
    ///output identifiers that are associated with a specified cryptographic session and Direct3D device. Input data
    ///structure: D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT_INPUT Output data structure:
    ///D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT_OUTPUT </td> </tr> <tr> <td width="40%"><a
    ///id="D3D11_AUTHENTICATED_QUERY_PROTECTION"></a><a id="d3d11_authenticated_query_protection"></a><dl>
    ///<dt><b>D3D11_AUTHENTICATED_QUERY_PROTECTION</b></dt> </dl> </td> <td width="60%"> Returns the current protection
    ///level for the device. Output data structure: D3D11_AUTHENTICATED_QUERY_PROTECTION_OUTPUT </td> </tr> <tr> <td
    ///width="40%"><a id="D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS"></a><a
    ///id="d3d11_authenticated_query_restricted_shared_resource_process"></a><dl>
    ///<dt><b>D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS</b></dt> </dl> </td> <td width="60%"> Returns
    ///information about a process that is allowed to open shared resources with restricted access. Input data
    ///structure: D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_INPUT Output data structure:
    ///D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_OUTPUT </td> </tr> <tr> <td width="40%"><a
    ///id="D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_COUNT"></a><a
    ///id="d3d11_authenticated_query_restricted_shared_resource_process_count"></a><dl>
    ///<dt><b>D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_COUNT</b></dt> </dl> </td> <td width="60%">
    ///Returns the number of processes that are allowed to open shared resources with restricted access. Output data
    ///structure: D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_COUNT_OUTPUT </td> </tr> <tr> <td
    ///width="40%"><a id="D3D11_AUTHENTICATED_QUERY_UNRESTRICTED_PROTECTED_SHARED_RESOURCE_COUNT"></a><a
    ///id="d3d11_authenticated_query_unrestricted_protected_shared_resource_count"></a><dl>
    ///<dt><b>D3D11_AUTHENTICATED_QUERY_UNRESTRICTED_PROTECTED_SHARED_RESOURCE_COUNT</b></dt> </dl> </td> <td
    ///width="60%"> Returns the number of protected shared resources that can be opened by any process with no
    ///restrictions. Output data structure:
    ///D3D11_AUTHENTICATED_QUERY_UNRESTRICTED_PROTECTED_SHARED_RESOURCE_COUNT_OUTPUT </td> </tr> </table>
    GUID   QueryType;
    ///A handle to the authenticated channel. To get the handle, call the ID3D11AuthenticatedChannel::GetChannelHandle
    ///method.
    HANDLE hChannel;
    ///The query sequence number. At the start of the session, generate a cryptographically secure 32-bit random number
    ///to use as the starting sequence number. For each query, increment the sequence number by 1.
    uint   SequenceNumber;
}

///Contains a response from the ID3D11VideoContext::QueryAuthenticatedChannel method.
struct D3D11_AUTHENTICATED_QUERY_OUTPUT
{
    ///A D3D11_OMAC structure that contains a Message Authentication Code (MAC) of the data. The driver uses AESbased
    ///one-key CBC MAC (OMAC) to calculate this value for the block of data that appears after this structure member.
    D3D11_OMAC omac;
    ///A GUID that specifies the query. For a list of possible values, see D3D11_AUTHENTICATED_QUERY_INPUT
    GUID       QueryType;
    ///A handle to the authenticated channel. To get the handle, call the ID3D11AuthenticatedChannel::GetChannelHandle
    ///method.
    HANDLE     hChannel;
    ///The query sequence number.
    uint       SequenceNumber;
    ///The result code for the query.
    HRESULT    ReturnCode;
}

///Contains the response to a <b>D3D11_AUTHENTICATED_QUERY_PROTECTION</b> query.
struct D3D11_AUTHENTICATED_QUERY_PROTECTION_OUTPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_OUTPUT structure that contains a Message Authentication Code (MAC) and other data.
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    ///A D3D11_AUTHENTICATED_PROTECTION_FLAGS union that specifies the protection level.
    D3D11_AUTHENTICATED_PROTECTION_FLAGS ProtectionFlags;
}

///Contains the response to a <b>D3D11_AUTHENTICATED_QUERY_CHANNEL_TYPE</b> query.
struct D3D11_AUTHENTICATED_QUERY_CHANNEL_TYPE_OUTPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_OUTPUT structure that contains a Message Authentication Code (MAC) and other data.
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    ///A D3D11_AUTHENTICATED_CHANNEL_TYPE value that specifies the channel type.
    D3D11_AUTHENTICATED_CHANNEL_TYPE ChannelType;
}

///Contains the response to a <b>D3D11_AUTHENTICATED_QUERY_DEVICE_HANDLE</b> query.
struct D3D11_AUTHENTICATED_QUERY_DEVICE_HANDLE_OUTPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_OUTPUT structure that contains a Message Authentication Code (MAC) and other data.
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    ///A handle to the device.
    HANDLE DeviceHandle;
}

///Contains input data for a <b>D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION</b> query.
struct D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION_INPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_INPUT structure that contains the GUID for the query and other data.
    D3D11_AUTHENTICATED_QUERY_INPUT Input;
    ///A handle to a decoder device.
    HANDLE DecoderHandle;
}

///Contains the response to a <b>D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION</b> query.
struct D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION_OUTPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_OUTPUT structure that contains a Message Authentication Code (MAC) and other data.
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    ///A handle to a decoder device.
    HANDLE DecoderHandle;
    ///A handle to the cryptographic session that is associated with the decoder device.
    HANDLE CryptoSessionHandle;
    ///A handle to the Direct3D device that is associated with the decoder device.
    HANDLE DeviceHandle;
}

///Contains the response to a <b>D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_COUNT</b> query.
struct D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_COUNT_OUTPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_OUTPUT structure that contains a Message Authentication Code (MAC) and other data.
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    ///The number of processes that are allowed to open shared resources that have restricted access. A process cannot
    ///open such a resource unless the process has been granted access.
    uint RestrictedSharedResourceProcessCount;
}

///Contains input data for a <b>D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS</b> query.
struct D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_INPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_INPUT structure that contains the GUID for the query and other data.
    D3D11_AUTHENTICATED_QUERY_INPUT Input;
    ///The index of the process.
    uint ProcessIndex;
}

///Contains the response to a <b>D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS</b> query.
struct D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_OUTPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_OUTPUT structure that contains a Message Authentication Code (MAC) and other data.
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    ///The index of the process in the list of processes.
    uint   ProcessIndex;
    ///A D3D11_AUTHENTICATED_PROCESS_IDENTIFIER_TYPE value that specifies the type of process.
    D3D11_AUTHENTICATED_PROCESS_IDENTIFIER_TYPE ProcessIdentifier;
    ///A process handle. If the <b>ProcessIdentifier</b> member equals <b>D3D11_PROCESSIDTYPE_HANDLE</b>, the
    ///<b>ProcessHandle</b> member contains a valid handle to a process. Otherwise, this member is ignored.
    HANDLE ProcessHandle;
}

///Contains the response to a <b>D3D11_AUTHENTICATED_QUERY_UNRESTRICTED_PROTECTED_SHARED_RESOURCE_COUNT</b> query.
struct D3D11_AUTHENTICATED_QUERY_UNRESTRICTED_PROTECTED_SHARED_RESOURCE_COUNT_OUTPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_OUTPUT structure that contains a Message Authentication Code (MAC) and other data.
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    ///The number of protected, shared resources that can be opened by any process without restrictions.
    uint UnrestrictedProtectedSharedResourceCount;
}

///Contains input data for a <b>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT</b> query.
struct D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT_INPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_INPUT structure that contains the GUID for the query and other data.
    D3D11_AUTHENTICATED_QUERY_INPUT Input;
    ///A handle to the device.
    HANDLE DeviceHandle;
    ///A handle to the cryptographic session.
    HANDLE CryptoSessionHandle;
}

///Contains the response to a <b>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT</b> query.
struct D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT_OUTPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_OUTPUT structure that contains a Message Authentication Code (MAC) and other data.
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    ///A handle to the device.
    HANDLE DeviceHandle;
    ///A handle to the cryptographic session.
    HANDLE CryptoSessionHandle;
    ///The number of output IDs associated with the specified device and cryptographic session.
    uint   OutputIDCount;
}

///Contains input data for a <b>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID</b> query.
struct D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_INPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_INPUT structure that contains the GUID for the query and other data.
    D3D11_AUTHENTICATED_QUERY_INPUT Input;
    ///A handle to the device.
    HANDLE DeviceHandle;
    ///A handle to the cryptographic session.
    HANDLE CryptoSessionHandle;
    ///The index of the output ID.
    uint   OutputIDIndex;
}

///Contains the response to a <b>D3D11_AUTHENTICATED_QUERY_OUTPUT_ID</b> query.
struct D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_OUTPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_OUTPUT structure that contains a Message Authentication Code (MAC) and other data.
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    ///A handle to the device.
    HANDLE DeviceHandle;
    ///A handle to the cryptographic session.
    HANDLE CryptoSessionHandle;
    ///The index of the output ID.
    uint   OutputIDIndex;
    ///An output ID that is associated with the specified device and cryptographic session.
    ulong  OutputID;
}

///Contains the response to a <b>D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ATTRIBUTES</b> query.
struct D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_OUTPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_OUTPUT structure that contains a Message Authentication Code (MAC) and other data.
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    ///A bitwise <b>OR</b> of flags from the D3D11_BUS_TYPE enumeration.
    D3D11_BUS_TYPE BusType;
    ///If <b>TRUE</b>, contiguous blocks of video memory may be accessible to the CPU or the bus.
    BOOL           AccessibleInContiguousBlocks;
    ///If <b>TRUE</b>, non-contiguous blocks of video memory may be accessible to the CPU or the bus.
    BOOL           AccessibleInNonContiguousBlocks;
}

///Contains the response to a <b>D3D11_AUTHENTICATED_QUERY_ENCRYPTION_WHEN_ACCESSIBLE_GUID_COUNT</b> query.
struct D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_COUNT_OUTPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_OUTPUT structure that contains a Message Authentication Code (MAC) and other data.
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    ///The number of encryption GUIDs.
    uint EncryptionGuidCount;
}

///Contains input data for a <b>D3D11_AUTHENTICATED_QUERY_ENCRYPTION_WHEN_ACCESSIBLE_GUID</b> query.
struct D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_INPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_INPUT structure that contains the GUID for the query and other data.
    D3D11_AUTHENTICATED_QUERY_INPUT Input;
    ///The index of the encryption GUID.
    uint EncryptionGuidIndex;
}

///Contains the response to a <b>D3D11_AUTHENTICATED_QUERY_ENCRYPTION_WHEN_ACCESSIBLE_GUID</b> query.
struct D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_OUTPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_OUTPUT structure that contains a Message Authentication Code (MAC) and other data.
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    ///The index of the encryption GUID.
    uint EncryptionGuidIndex;
    ///A GUID that specifies a supported encryption type.
    GUID EncryptionGuid;
}

///Contains the response to a <b>D3D11_AUTHENTICATED_QUERY_CURRENT_ENCRYPTION_WHEN_ACCESSIBLE </b>query.
struct D3D11_AUTHENTICATED_QUERY_CURRENT_ACCESSIBILITY_ENCRYPTION_OUTPUT
{
    ///A D3D11_AUTHENTICATED_QUERY_OUTPUT structure that contains a Message Authentication Code (MAC) and other data.
    D3D11_AUTHENTICATED_QUERY_OUTPUT Output;
    ///A GUID that specifies the current encryption type.
    GUID EncryptionGuid;
}

///Contains input data for the ID3D11VideoContext::ConfigureAuthenticatedChannel method.
struct D3D11_AUTHENTICATED_CONFIGURE_INPUT
{
    ///A D3D11_OMAC structure that contains a Message Authentication Code (MAC) of the data. The driver uses AES-based
    ///one-key CBC MAC (OMAC) to calculate this value for the block of data that appears after this structure member.
    D3D11_OMAC omac;
    ///A GUID that specifies the command. The following GUIDs are defined. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="D3D11_AUTHENTICATED_CONFIGURE_CRYPTO_SESSION"></a><a
    ///id="d3d11_authenticated_configure_crypto_session"></a><dl>
    ///<dt><b>D3D11_AUTHENTICATED_CONFIGURE_CRYPTO_SESSION</b></dt> </dl> </td> <td width="60%"> Associates a
    ///cryptographic session with a decoder device and a Direct3D device. Input data:
    ///D3D11_AUTHENTICATED_CONFIGURE_CRYPTO_SESSION_INPUT </td> </tr> <tr> <td width="40%"><a
    ///id="D3D11_AUTHENTICATED_CONFIGURE_ENCRYPTION_WHEN_ACCESSIBLE"></a><a
    ///id="d3d11_authenticated_configure_encryption_when_accessible"></a><dl>
    ///<dt><b>D3D11_AUTHENTICATED_CONFIGURE_ENCRYPTION_WHEN_ACCESSIBLE</b></dt> </dl> </td> <td width="60%"> Sets the
    ///level of encryption that is performed before protected content becomes accessible to the CPU or bus. Input data:
    ///D3D11_AUTHENTICATED_CONFIGURE_ACCESSIBLE_ENCRYPTION_INPUT </td> </tr> <tr> <td width="40%"><a
    ///id="D3D11_AUTHENTICATED_CONFIGURE_INITIALIZE"></a><a id="d3d11_authenticated_configure_initialize"></a><dl>
    ///<dt><b>D3D11_AUTHENTICATED_CONFIGURE_INITIALIZE</b></dt> </dl> </td> <td width="60%"> Initializes the
    ///authenticated channel. Input data: D3D11_AUTHENTICATED_CONFIGURE_INITIALIZE_INPUT </td> </tr> <tr> <td
    ///width="40%"><a id="D3D11_AUTHENTICATED_CONFIGURE_PROTECTION"></a><a
    ///id="d3d11_authenticated_configure_protection"></a><dl> <dt><b>D3D11_AUTHENTICATED_CONFIGURE_PROTECTION</b></dt>
    ///</dl> </td> <td width="60%"> Enables or disables protection for the device. Input data:
    ///D3D11_AUTHENTICATED_CONFIGURE_PROTECTION_INPUT </td> </tr> <tr> <td width="40%"><a
    ///id="D3D11_AUTHENTICATED_CONFIGURE_SHARED_RESOURCE"></a><a
    ///id="d3d11_authenticated_configure_shared_resource"></a><dl>
    ///<dt><b>D3D11_AUTHENTICATED_CONFIGURE_SHARED_RESOURCE</b></dt> </dl> </td> <td width="60%"> Enables a process to
    ///open a shared resource, or disables a process from opening shared resources. Input data:
    ///D3D11_AUTHENTICATED_CONFIGURE_SHARED_RESOURCE_INPUT </td> </tr> </table>
    GUID       ConfigureType;
    ///A handle to the authenticated channel. To get the handle, call the ID3D11AuthenticatedChannel::GetChannelHandle
    ///method.
    HANDLE     hChannel;
    ///The query sequence number. At the start of the session, generate a cryptographically secure 32-bit random number
    ///to use as the starting sequence number. For each query, increment the sequence number by 1.
    uint       SequenceNumber;
}

///Contains the response from the ID3D11VideoContext::ConfigureAuthenticatedChannel method.
struct D3D11_AUTHENTICATED_CONFIGURE_OUTPUT
{
    ///A D3D11_OMAC structure that contains a Message Authentication Code (MAC) of the data. The driver uses AES-based
    ///one-key CBC MAC (OMAC) to calculate this value for the block of data that appears after this structure member.
    D3D11_OMAC omac;
    ///A GUID that specifies the command. For a list of GUIDs, see D3D11_AUTHENTICATED_CONFIGURE_INPUT.
    GUID       ConfigureType;
    ///A handle to the authenticated channel.
    HANDLE     hChannel;
    ///The command sequence number.
    uint       SequenceNumber;
    ///The result code for the command.
    HRESULT    ReturnCode;
}

///Contains input data for a <b>D3D11_AUTHENTICATED_CONFIGURE_INITIALIZE</b> command.
struct D3D11_AUTHENTICATED_CONFIGURE_INITIALIZE_INPUT
{
    ///A D3D11_AUTHENTICATED_CONFIGURE_INPUT structure that contains the command GUID and other data.
    D3D11_AUTHENTICATED_CONFIGURE_INPUT Parameters;
    ///The initial sequence number for queries.
    uint StartSequenceQuery;
    ///The initial sequence number for commands.
    uint StartSequenceConfigure;
}

///Contains input data for a <b>D3D11_AUTHENTICATED_CONFIGURE_PROTECTION</b> command.
struct D3D11_AUTHENTICATED_CONFIGURE_PROTECTION_INPUT
{
    ///A D3D11_AUTHENTICATED_CONFIGURE_INPUT structure that contains the command GUID and other data.
    D3D11_AUTHENTICATED_CONFIGURE_INPUT Parameters;
    ///A D3D11_AUTHENTICATED_PROTECTION_FLAGS union that specifies the protection level.
    D3D11_AUTHENTICATED_PROTECTION_FLAGS Protections;
}

///Contains input data for a <b>D3D11_AUTHENTICATED_CONFIGURE_CRYPTO_SESSION</b> command.
struct D3D11_AUTHENTICATED_CONFIGURE_CRYPTO_SESSION_INPUT
{
    ///A D3D11_AUTHENTICATED_CONFIGURE_INPUT structure that contains the command GUID and other data.
    D3D11_AUTHENTICATED_CONFIGURE_INPUT Parameters;
    ///A handle to the decoder device. Get this from ID3D11VideoDecoder::GetDriverHandle.
    HANDLE DecoderHandle;
    ///A handle to the cryptographic session. Get this from ID3D11CryptoSession::GetCryptoSessionHandle.
    HANDLE CryptoSessionHandle;
    ///A handle to the Direct3D device. Get this from D3D11VideoContext::QueryAuthenticatedChannel using
    ///<b>D3D11_AUTHENTICATED_QUERY_DEVICE_HANDLE</b>.
    HANDLE DeviceHandle;
}

///Contains input data for a <b>D3D11_AUTHENTICATED_CONFIGURE_SHARED_RESOURCE</b> command.
struct D3D11_AUTHENTICATED_CONFIGURE_SHARED_RESOURCE_INPUT
{
    ///A D3D11_AUTHENTICATED_CONFIGURE_INPUT structure that contains the command GUID and other data.
    D3D11_AUTHENTICATED_CONFIGURE_INPUT Parameters;
    ///A D3D11_AUTHENTICATED_PROCESS_IDENTIFIER_TYPE value that specifies the type of process. To specify the Desktop
    ///Window Manager (DWM) process, set this member to <b>D3D11_PROCESSIDTYPE_DWM</b>. Otherwise, set this member to
    ///<b>D3D11_PROCESSIDTYPE_HANDLE</b> and set the <b>ProcessHandle</b> member to a valid handle.
    D3D11_AUTHENTICATED_PROCESS_IDENTIFIER_TYPE ProcessType;
    ///A process handle. If the <b>ProcessType</b> member equals <b>D3D11_PROCESSIDTYPE_HANDLE</b>, the
    ///<b>ProcessHandle</b> member specifies a handle to a process. Otherwise, the value is ignored.
    HANDLE ProcessHandle;
    ///If <b>TRUE</b>, the specified process has access to restricted shared resources.
    BOOL   AllowAccess;
}

///Contains input data for a <b>D3D11_AUTHENTICATED_CONFIGURE_ENCRYPTION_WHEN_ACCESSIBLE</b> command.
struct D3D11_AUTHENTICATED_CONFIGURE_ACCESSIBLE_ENCRYPTION_INPUT
{
    ///A D3D11_AUTHENTICATED_CONFIGURE_INPUT structure that contains the command GUID and other data.
    D3D11_AUTHENTICATED_CONFIGURE_INPUT Parameters;
    ///A GUID that specifies the type of encryption to apply.
    GUID EncryptionGuid;
}

///Identifies the texture resource for a video decoder output view.
struct D3D11_TEX2D_VDOV
{
    ///The zero-based index of the texture.
    uint ArraySlice;
}

///Describes a video decoder output view.
struct D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC
{
    ///The decoding profile. To get the list of profiles supported by the device, call the
    ///ID3D11VideoDevice::GetVideoDecoderProfile method.
    GUID                 DecodeProfile;
    ///The resource type of the view, specified as a member of the D3D11_VDOV_DIMENSION enumeration.
    D3D11_VDOV_DIMENSION ViewDimension;
union
    {
        D3D11_TEX2D_VDOV Texture2D;
    }
}

///Identifies the texture resource for a video processor input view.
struct D3D11_TEX2D_VPIV
{
    ///The zero-based index into the array of subtextures.
    uint MipSlice;
    ///The zero-based index of the texture.
    uint ArraySlice;
}

///Describes a video processor input view.
struct D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC
{
    ///The surface format. If zero, the driver uses the DXGI format that was used to create the resource. If you are
    ///using feature level 9, the value must be zero.
    uint                 FourCC;
    ///The resource type of the view, specified as a member of the D3D11_VPIV_DIMENSION enumeration.
    D3D11_VPIV_DIMENSION ViewDimension;
union
    {
        D3D11_TEX2D_VPIV Texture2D;
    }
}

///Identifies a texture resource for a video processor output view.
struct D3D11_TEX2D_VPOV
{
    ///The zero-based index into the array of subtextures.
    uint MipSlice;
}

///Identifies a texture resource for a video processor output view.
struct D3D11_TEX2D_ARRAY_VPOV
{
    ///The zero-based index into the array of subtextures.
    uint MipSlice;
    ///The index of the first texture to use.
    uint FirstArraySlice;
    ///The number of textures in the array.
    uint ArraySize;
}

///Describes a video processor output view.
struct D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC
{
    ///The resource type of the view, specified as a member of the D3D11_VPOV_DIMENSION enumeration.
    D3D11_VPOV_DIMENSION ViewDimension;
union
    {
        D3D11_TEX2D_VPOV Texture2D;
        D3D11_TEX2D_ARRAY_VPOV Texture2DArray;
    }
}

///Describes a sub sample mapping block.
struct D3D11_VIDEO_DECODER_SUB_SAMPLE_MAPPING_BLOCK
{
    ///The number of clear (non-encrypted) bytes at the start of the block.
    uint ClearSize;
    ///The number of encrypted bytes following the clear bytes.
    uint EncryptedSize;
}

///Describes a compressed buffer for decoding.
struct D3D11_VIDEO_DECODER_BUFFER_DESC1
{
    ///The type of buffer.
    D3D11_VIDEO_DECODER_BUFFER_TYPE BufferType;
    ///The offset of the relevant data from the beginning of the buffer, in bytes. This value must be zero.
    uint  DataOffset;
    ///Size of the relevant data.
    uint  DataSize;
    ///A pointer to a buffer that contains an initialization vector (IV) for encrypted data. If the decode buffer does
    ///not contain encrypted data, set this member to NULL.
    void* pIV;
    ///The size of the buffer specified in the <i>pIV</i> parameter. If <i>pIV</i> is NULL, set this member to zero.
    uint  IVSize;
    ///A pointer to an array of D3D11_VIDEO_DECODER_SUB_SAMPLE_MAPPING_BLOCK structures, which indicates exactly which
    ///bytes in the decode buffer are encrypted and which are in the clear. If the decode buffer does not contain
    ///encrypted data, set this member to NULL. Values in the sub sample mapping blocks are relative to the start of the
    ///decode buffer.
    D3D11_VIDEO_DECODER_SUB_SAMPLE_MAPPING_BLOCK* pSubSampleMappingBlock;
    ///The number of D3D11_VIDEO_DECODER_SUB_SAMPLE_MAPPING_BLOCK structures specified in the
    ///<i>pSubSampleMappingBlocks</i> parameter. If <i>pSubSampleMappingBlocks</i> is NULL, set this member to zero.
    uint  SubSampleMappingCount;
}

///Provides data to the ID3D11VideoContext::DecoderBeginFrame method.
struct D3D11_VIDEO_DECODER_BEGIN_FRAME_CRYPTO_SESSION
{
    ///A pointer to the ID3D11CryptoSession interface. To get this pointer, call
    ///ID3D11VideoDevice1::CreateCryptoSession.
    ID3D11CryptoSession pCryptoSession;
    ///The size of the memory buffer referenced by the <i>pBlob</i> member.
    uint                BlobSize;
    ///The definition of this buffer is dependent on the implementation of the secure execution environment. It could
    ///contain a sealed key blob or any other per-key data that the secure execution environment needs to pass to the
    ///decode API. The definition of this buffer is dependent on the implementation of the secure environment. It may
    ///contain data specific to the current frame.
    void*               pBlob;
    ///A pointer to a GUID identifying the hardware key.
    GUID*               pKeyInfoId;
    ///The size of the memory buffer referenced by the <i>pPrivateData</i> member.
    uint                PrivateDataSize;
    void*               pPrivateData;
}

///Provides information about the input streams passed into the ID3DVideoContext1::VideoProcessorGetBehaviorHints
///method.
struct D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT
{
    ///A value indicating whether this input stream should be used to compute behavior hints. Set to true if the stream
    ///should be used to compute behavior hints; otherwise, set to false.
    BOOL        Enable;
    ///The width of the input stream.
    uint        Width;
    ///The height of the input stream.
    uint        Height;
    ///The format of the input stream.
    DXGI_FORMAT Format;
}

///Represents key exchange input data for hardware content protection.
struct D3D11_KEY_EXCHANGE_HW_PROTECTION_INPUT_DATA
{
    ///The size of the private data reserved for IHV usage. This size is determined from the <i>pPrivateInputSize</i>
    ///parameter returned by the ID3D11VideoDevice1::GetCryptoSessionPrivateDataSize function.
    uint     PrivateDataSize;
    ///The size of the DRM command data.
    uint     HWProtectionDataSize;
    ///If <b>PrivateDataSize</b> is greater than 0, pbInput[0] â€“ <b>pbInput</b>[<b>PrivateDataSize</b> - 1] is
    ///reserved for IHV use. <b>pbInput</b>[<b>PrivateDataSize</b>] â€“ <b>pbInput</b>[<b>HWProtectionDataSize</b> +
    ///<b>PrivateDataSize</b> - 1] contains the input data for the DRM command. The format and size of the DRM command
    ///is defined by the DRM specification.
    ubyte[4] pbInput;
}

///Represents key exchange output data for hardware content protection.
struct D3D11_KEY_EXCHANGE_HW_PROTECTION_OUTPUT_DATA
{
    ///The size of the private data reserved for IHV usage. This size is determined from the <i>pPrivateOutputSize</i>
    ///parameter returned by the ID3D11VideoDevice1::GetCryptoSessionPrivateDataSize function.
    uint     PrivateDataSize;
    ///The maximum size of data that the driver can return in the output buffer. The last byte that it can write to is
    ///<b>pbOuput</b>[<b>PrivateDataSize</b> + <b>MaxHWProtectionDataSize</b> â€“ 1].
    uint     MaxHWProtectionDataSize;
    ///The size of the output data written by the driver.
    uint     HWProtectionDataSize;
    ///The number of 100 nanosecond units spent transporting the data.
    ulong    TransportTime;
    ///The number of 100 nanosecond units spent executing the content protection command.
    ulong    ExecutionTime;
    ///If <b>PrivateDataSize</b> is greater than 0, pbInput[0] â€“ <b>pbOutput</b>[<b>PrivateDataSize</b> - 1] is
    ///reserved for IHV use. <b>pbOutput</b>[<b>PrivateDataSize</b>] â€“ <b>pbOutput</b>[<b>HWProtectionDataSize</b> +
    ///<b>PrivateDataSize</b> - 1] contains the input data for the DRM command. The format and size of the DRM command
    ///is defined by the DRM specification.
    ubyte[4] pbOutput;
}

///Represents key exchange data for hardware content protection.
struct D3D11_KEY_EXCHANGE_HW_PROTECTION_DATA
{
    ///The function ID of the DRM command. The values and meanings of the function ID are defined by the DRM
    ///specification.
    uint    HWProtectionFunctionID;
    ///Pointer to a buffer containing a D3D11_KEY_EXCHANGE_HW_PROTECTION_INPUT_DATA structure that specifies memory
    ///reserved for IHV use and the input data for the DRM command.
    D3D11_KEY_EXCHANGE_HW_PROTECTION_INPUT_DATA* pInputData;
    ///Pointer to a buffer containing a D3D11_KEY_EXCHANGE_HW_PROTECTION_OUTPUT_DATA structure that specifies memory
    ///reserved for IHV use and the input data for the DRM command.
    D3D11_KEY_EXCHANGE_HW_PROTECTION_OUTPUT_DATA* pOutputData;
    ///The result of the hardware DRM command.
    HRESULT Status;
}

///Describes a video sample.
struct D3D11_VIDEO_SAMPLE_DESC
{
    ///The width of the video sample.
    uint        Width;
    ///The height of the video sample.
    uint        Height;
    ///The format of the video sample.
    DXGI_FORMAT Format;
    ///The colorspace of the sample.
    DXGI_COLOR_SPACE_TYPE ColorSpace;
}

// Functions

///Creates a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.
///Params:
///    pD3DDevice = A pointer to the IDirect3DDevice9Ex interface of a Direct3D 9 device.
///    pContentDesc = A pointer to a DXVAHD_CONTENT_DESC structure that describes the video content. The driver uses this information
///                   as a hint when it creates the device.
///    Usage = A member of the DXVAHD_DEVICE_USAGE enumeration, describing how the device will be used. The value indicates the
///            desired trade-off between speed and video quality. The driver uses this flag as a hint when it creates the
///            device.
///    pPlugin = A pointer to an initialization function for a software device. Set this pointer if you are using a software
///              plug-in device. Otherwise, set this parameter to <b>NULL</b>. If the value is <b>NULL</b>, the driver creates the
///              DXVA-HD device. The function pointer type is PDXVAHDSW_Plugin.
///    ppDevice = Receives a pointer to the IDXVAHD_Device interface. The caller must release the interface.
///Returns:
///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The Direct3D device does not support DXVA-HD. </td>
///    </tr> </table>
///    
@DllImport("dxva2")
HRESULT DXVAHD_CreateDevice(IDirect3DDevice9Ex pD3DDevice, const(DXVAHD_CONTENT_DESC)* pContentDesc, 
                            DXVAHD_DEVICE_USAGE Usage, PDXVAHDSW_Plugin pPlugin, IDXVAHD_Device* ppDevice);

///Creates an instance of the Direct3D Device Manager.
///Params:
///    pResetToken = Receives a token that identifies this instance of the Direct3D device manager. Use this token when calling
///                  IDirect3DDeviceManager9::ResetDevice.
///    ppDeviceManager = Receives a pointer to the IDirect3DDeviceManager9 interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("dxva2")
HRESULT DXVA2CreateDirect3DDeviceManager9(uint* pResetToken, IDirect3DDeviceManager9* ppDeviceManager);

///Creates a DirectX Video Acceleration (DXVA) services object. Call this function if your application uses DXVA
///directly, without using DirectShow or Media Foundation.
///Params:
///    pDD = A pointer to the IDirect3DDevice9 interface of a Direct3D device.
///    riid = The interface identifier (IID) of the requested interface. Any of the following interfaces might be supported by
///           the Direct3D device: <ul> <li> IDirectXVideoAccelerationService </li> <li> IDirectXVideoDecoderService </li> <li>
///           IDirectXVideoProcessorService </li> </ul>
///    ppService = Receives a pointer to the interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("dxva2")
HRESULT DXVA2CreateVideoService(IDirect3DDevice9 pDD, const(GUID)* riid, void** ppService);

///Creates an Output Protection Manager (OPM) object for each physical monitor that is associated with a particular
///<b>HMONITOR</b> handle.
///Params:
///    hMonitor = The monitor handle for which to create OPM objects. There are several functions that return <b>HMONITOR</b>
///               values. For more information, see the topic Multiple Display Monitors Functions in the Windows graphics device
///               interface (GDI) documentation.
///    vos = A member of the OPM_VIDEO_OUTPUT_SEMANTICS enumeration. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///          <td width="40%"><a id="OPM_VOS_OPM_SEMANTICS"></a><a id="opm_vos_opm_semantics"></a><dl>
///          <dt><b>OPM_VOS_OPM_SEMANTICS</b></dt> </dl> </td> <td width="60%"> The returned IOPMVideoOutput pointers will use
///          OPM semantics. </td> </tr> <tr> <td width="40%"><a id="OPM_VOS_COPP_SEMANTICS"></a><a
///          id="opm_vos_copp_semantics"></a><dl> <dt><b>OPM_VOS_COPP_SEMANTICS</b></dt> </dl> </td> <td width="60%"> The
///          returned IOPMVideoOutput pointers will use Certified Output Protection Protocol (COPP) semantics. </td> </tr>
///          </table>
///    pulNumVideoOutputs = Receives the number of IOPMVideoOutput pointers returned in the <i>pppOPMVideoOutputArray</i> parameter.
///    pppOPMVideoOutputArray = Receives a pointer to an array of IOPMVideoOutput pointers. Each <b>IOPMVideoOutput</b> pointer is associated
///                             with a single physical monitor. The caller must release each pointer in the array, and call CoTaskMemFree to free
///                             the array.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("dxva2")
HRESULT OPMGetVideoOutputsFromHMONITOR(HMONITOR hMonitor, OPM_VIDEO_OUTPUT_SEMANTICS vos, uint* pulNumVideoOutputs, 
                                       IOPMVideoOutput** pppOPMVideoOutputArray);

///Returns a video output object for the VidPN target on the specified adapter.
///Params:
///    pAdapterLuid = The LUID for the adapter where the target is located.
///    VidPnTarget = Target ID for the target on the specified adapter adapter.
///    vos = A member of the OPM_VIDEO_OUTPUT_SEMANTICS enumeration. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///          <td width="40%"><a id="OPM_VOS_OPM_SEMANTICS"></a><a id="opm_vos_opm_semantics"></a><dl>
///          <dt><b>OPM_VOS_OPM_SEMANTICS</b></dt> </dl> </td> <td width="60%"> The returned IOPMVideoOutput pointer will use
///          OPM semantics. </td> </tr> <tr> <td width="40%"><a id="OPM_VOS_COPP_SEMANTICS"></a><a
///          id="opm_vos_copp_semantics"></a><dl> <dt><b>OPM_VOS_COPP_SEMANTICS</b></dt> </dl> </td> <td width="60%"> The
///          returned IOPMVideoOutput pointer will use Certified Output Protection Protocol (COPP) semantics. </td> </tr>
///          </table>
///    ppOPMVideoOutput = Receives a pointer to an IOPMVideoOutput pointer. The caller must release this pointer.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("dxva2")
HRESULT OPMGetVideoOutputForTarget(LUID* pAdapterLuid, uint VidPnTarget, OPM_VIDEO_OUTPUT_SEMANTICS vos, 
                                   IOPMVideoOutput* ppOPMVideoOutput);

///Creates an Output Protection Manager (OPM) object for each physical monitor that is associated with a particular
///Direct3D device.
///Params:
///    pDirect3DDevice9 = Pointer to the <b>IDirect3DDevice9</b> interface of a Direct3D device.
///    vos = A member of the OPM_VIDEO_OUTPUT_SEMANTICS enumeration. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///          <td width="40%"><a id="OPM_VOS_OPM_SEMANTICS"></a><a id="opm_vos_opm_semantics"></a><dl>
///          <dt><b>OPM_VOS_OPM_SEMANTICS</b></dt> </dl> </td> <td width="60%"> The returned IOPMVideoOutput pointers will use
///          OPM semantics. </td> </tr> <tr> <td width="40%"><a id="OPM_VOS_COPP_SEMANTICS"></a><a
///          id="opm_vos_copp_semantics"></a><dl> <dt><b>OPM_VOS_COPP_SEMANTICS</b></dt> </dl> </td> <td width="60%"> The
///          returned IOPMVideoOutput pointers will use Certified Output Protection Protocol (COPP) semantics. </td> </tr>
///          </table>
///    pulNumVideoOutputs = Receives the number of IOPMVideoOutput pointers returned in the <i>pppOPMVideoOutputArray</i> parameter.
///    pppOPMVideoOutputArray = Receives a pointer to an array of IOPMVideoOutput pointers. Each <b>IOPMVideoOutput</b> pointer is associated
///                             with a single physical monitor. The caller must release each pointer in the array, and call CoTaskMemFree to free
///                             the array.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("dxva2")
HRESULT OPMGetVideoOutputsFromIDirect3DDevice9Object(IDirect3DDevice9 pDirect3DDevice9, 
                                                     OPM_VIDEO_OUTPUT_SEMANTICS vos, uint* pulNumVideoOutputs, 
                                                     IOPMVideoOutput** pppOPMVideoOutputArray);

///Writes the contents of an attribute store to a stream.
///Params:
///    pAttr = Pointer to the IMFAttributes interface of the attribute store.
///    dwOptions = Bitwise <b>OR</b> of zero or more flags from the MF_ATTRIBUTE_SERIALIZE_OPTIONS enumeration.
///    pStm = Pointer to the <b>IStream</b> interface of the stream where the attributes are saved.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFSerializeAttributesToStream(IMFAttributes pAttr, uint dwOptions, IStream pStm);

///Loads attributes from a stream into an attribute store.
///Params:
///    pAttr = Pointer to the IMFAttributes interface of the attribute store.
///    dwOptions = Bitwise <b>OR</b> of zero or more flags from the MF_ATTRIBUTE_SERIALIZE_OPTIONS enumeration.
///    pStm = Pointer to the <b>IStream</b> interface of the stream from which to read the attributes.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFDeserializeAttributesFromStream(IMFAttributes pAttr, uint dwOptions, IStream pStm);

///Creates a generic activation object for Media Foundation transforms (MFTs).
///Params:
///    ppActivate = Receives a pointer to the IMFActivate interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateTransformActivate(IMFActivate* ppActivate);

///Creates the Media Session in the application's process.
///Params:
///    pConfiguration = Pointer to the IMFAttributes interface. This parameter can be <b>NULL</b>. See Remarks.
///    ppMediaSession = Receives a pointer to the Media Session's IMFMediaSession interface. The caller must release the interface.
///                     Before releasing the last reference to the <b>IMFMediaSession</b> pointer, the application must call the
///                     IMFMediaSession::Shutdown method.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateMediaSession(IMFAttributes pConfiguration, IMFMediaSession* ppMediaSession);

///Creates an instance of the Media Session inside a Protected Media Path (PMP) process.
///Params:
///    dwCreationFlags = A member of the MFPMPSESSION_CREATION_FLAGS enumeration that specifies how to create the session object.
///    pConfiguration = A pointer to the IMFAttributes interface. This parameter can be <b>NULL</b>. See Remarks.
///    ppMediaSession = Receives a pointer to the PMP Media Session's IMFMediaSession interface. The caller must release the interface.
///                     Before releasing the last reference to the <b>IMFMediaSession</b> pointer, the application must call the
///                     IMFMediaSession::Shutdown method.
///    ppEnablerActivate = Receives a pointer to the IMFActivate interface or the value <b>NULL</b>. If non-<b>NULL</b>, the caller must
///                        release the interface. See Remarks.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreatePMPMediaSession(uint dwCreationFlags, IMFAttributes pConfiguration, 
                                IMFMediaSession* ppMediaSession, IMFActivate* ppEnablerActivate);

///Creates the source resolver, which is used to create a media source from a URL or byte stream.
///Params:
///    ppISourceResolver = Receives a pointer to the source resolver's IMFSourceResolver interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateSourceResolver(IMFSourceResolver* ppISourceResolver);

///<p class="CCE_Message">[This API is not supported and may be altered or unavailable in the future. Instead,
///applications should use the <b>PSCreateMemoryPropertyStore</b> function to create property stores.] Creates an empty
///property store object.
///Params:
///    ppStore = Receives a pointer to the <b>IPropertyStore</b> interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT CreatePropertyStore(IPropertyStore* ppStore);

///Retrieves the URL schemes that are registered for the source resolver.
///Params:
///    pPropVarSchemeArray = Pointer to a <b>PROPVARIANT</b> that receives the URL schemes. Before calling this method, call
///                          <b>PropVariantInit</b> to initialize the <b>PROPVARIANT</b>. If the method succeeds, the <b>PROPVARIANT</b>
///                          contains an array of wide-character strings. The <b>PROPVARIANT</b> data type is VT_VECTOR | VT_LPWSTR. The
///                          caller must release the <b>PROPVARIANT</b> by calling <b>PropVariantClear</b>.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFGetSupportedSchemes(PROPVARIANT* pPropVarSchemeArray);

///Retrieves the MIME types that are registered for the source resolver.
///Params:
///    pPropVarMimeTypeArray = Pointer to a <b>PROPVARIANT</b> that receives the MIME types. Before calling this method, call
///                            <b>PropVariantInit</b> to initialize the <b>PROPVARIANT</b>. If the method succeeds, the <b>PROPVARIANT</b>
///                            contains an array of wide-character strings. The <b>PROPVARIANT</b> data type is VT_VECTOR | VT_LPWSTR. The
///                            caller must release the <b>PROPVARIANT</b> by calling <b>PropVariantClear</b>.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFGetSupportedMimeTypes(PROPVARIANT* pPropVarMimeTypeArray);

///Creates a topology object.
///Params:
///    ppTopo = Receives a pointer to the IMFTopology interface of the topology object. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateTopology(IMFTopology* ppTopo);

///Creates a topology node.
///Params:
///    NodeType = The type of node to create, specified as a member of the MF_TOPOLOGY_TYPE enumeration.
///    ppNode = Receives a pointer to the node's IMFTopologyNode interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateTopologyNode(MF_TOPOLOGY_TYPE NodeType, IMFTopologyNode* ppNode);

///Gets the media type for a stream associated with a topology node.
///Params:
///    pNode = A pointer to the IMFTopologyNode interface.
///    dwStreamIndex = The identifier of the stream to query. This parameter is interpreted as follows: <ul> <li>Transform nodes: The
///                    value is the zero-based index of the input or output stream.</li> <li>All other node types: The value must be
///                    zero.</li> </ul>
///    fOutput = <b>If TRUE</b>, the function gets an output type<b>. If FALSE</b>, the function gets an input type. This
///              parameter is interpreted as follows: <ul> <li>Output nodes: The value must be <b>TRUE</b>.</li> <li>Source nodes:
///              The value must be <b>FALSE</b>.</li> <li>Tee nodes: The value is ignored.</li> <li>Transform nodes: If the value
///              is <b>TRUE</b>, the <i>dwStreamIndex</i> parameter is the index for an output stream. Otherwise,
///              <i>dwStreamIndex</i> is the index for an input stream.</li> </ul>
///    ppType = Receives a pointer to the IMFMediaType interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> The stream index is invalid. </td> </tr>
///    </table>
///    
@DllImport("MF")
HRESULT MFGetTopoNodeCurrentType(IMFTopologyNode pNode, uint dwStreamIndex, BOOL fOutput, IMFMediaType* ppType);

///Queries an object for a specified service interface. This function is a helper function that wraps the
///IMFGetService::GetService method. The function queries the object for the IMFGetService interface and, if successful,
///calls <b>GetService</b> on the object.
///Params:
///    punkObject = A pointer to the <b>IUnknown</b> interface of the object to query.
///    guidService = The service identifier (SID) of the service. For a list of service identifiers, see Service Interfaces.
///    riid = The interface identifier (IID) of the interface being requested.
///    ppvObject = Receives the interface pointer. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MF_E_UNSUPPORTED_SERVICE</b></dt> </dl> </td> <td width="60%"> The service requested cannot be found in
///    the object represented by <i>punkObject</i>. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFGetService(IUnknown punkObject, const(GUID)* guidService, const(GUID)* riid, void** ppvObject);

///Returns the system time.
///Returns:
///    Returns the system time, in 100-nanosecond units.
///    
@DllImport("MFPlat")
long MFGetSystemTime();

///Creates the presentation clock. The presentation clock is used to schedule the time at which samples are rendered and
///to synchronize multiple streams.
///Params:
///    ppPresentationClock = Receives a pointer to the clock's IMFPresentationClock interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreatePresentationClock(IMFPresentationClock* ppPresentationClock);

///Creates a presentation time source that is based on the system time.
///Params:
///    ppSystemTimeSource = Receives a pointer to the object's IMFPresentationTimeSource interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCreateSystemTimeSource(IMFPresentationTimeSource* ppSystemTimeSource);

///Creates a presentation descriptor.
///Params:
///    cStreamDescriptors = Number of elements in the <i>apStreamDescriptors</i> array.
///    apStreamDescriptors = Array of IMFStreamDescriptor interface pointers. Each pointer represents a stream descriptor for one stream in
///                          the presentation.
///    ppPresentationDescriptor = Receives a pointer to an IMFPresentationDescriptor interface of the presentation descriptor. The caller must
///                               release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreatePresentationDescriptor(uint cStreamDescriptors, IMFStreamDescriptor* apStreamDescriptors, 
                                       IMFPresentationDescriptor* ppPresentationDescriptor);

///Queries whether a media presentation requires the Protected Media Path (PMP).
///Params:
///    pPresentationDescriptor = Pointer to the IMFPresentationDescriptor interface of a presentation descriptor. The presentation descriptor is
///                              created by the media source, and describes the presentation.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> This presentation requires a protected environment.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_FALSE</b></b></dt> </dl> </td> <td width="60%"> This
///    presentation does not require a protected environment. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFRequireProtectedEnvironment(IMFPresentationDescriptor pPresentationDescriptor);

///Serializes a presentation descriptor to a byte array.
///Params:
///    pPD = Pointer to the IMFPresentationDescriptor interface of the presentation descriptor to serialize.
///    pcbData = Receives the size of the <i>ppbData</i> array, in bytes.
///    ppbData = Receives a pointer to an array of bytes containing the serialized presentation descriptor. The caller must free
///              the memory for the array by calling CoTaskMemFree.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFSerializePresentationDescriptor(IMFPresentationDescriptor pPD, uint* pcbData, ubyte** ppbData);

///Deserializes a presentation descriptor from a byte array.
///Params:
///    cbData = Size of the <i>pbData</i> array, in bytes.
///    pbData = Pointer to an array of bytes that contains the serialized presentation descriptor.
///    ppPD = Receives a pointer to the IMFPresentationDescriptor interface of the presentation descriptor. The caller must
///           release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFDeserializePresentationDescriptor(uint cbData, ubyte* pbData, IMFPresentationDescriptor* ppPD);

///Creates a stream descriptor.
///Params:
///    dwStreamIdentifier = Stream identifier.
///    cMediaTypes = Number of elements in the <i>apMediaTypes</i> array.
///    apMediaTypes = Pointer to an array of IMFMediaType interface pointers. These pointers are used to initialize the media type
///                   handler for the stream descriptor.
///    ppDescriptor = Receives a pointer to the IMFStreamDescriptor interface of the new stream descriptor. The caller must release the
///                   interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateStreamDescriptor(uint dwStreamIdentifier, uint cMediaTypes, IMFMediaType* apMediaTypes, 
                                 IMFStreamDescriptor* ppDescriptor);

///Creates a media-type handler that supports a single media type at a time.
///Params:
///    ppHandler = Receives a pointer to the IMFMediaTypeHandler interface of the media-type handler. The caller must release the
///                interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateSimpleTypeHandler(IMFMediaTypeHandler* ppHandler);

///Shuts down a Media Foundation object and releases all resources associated with the object. This function is a helper
///function that wraps the IMFShutdown::Shutdown method. The function queries the object for the IMFShutdown interface
///and, if successful, calls <b>Shutdown</b> on the object.
///Params:
///    pUnk = Pointer to the <b>IUnknown</b> interface of the object.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFShutdownObject(IUnknown pUnk);

///Creates the Streaming Audio Renderer.
///Params:
///    pAudioAttributes = A pointer to the IMFAttributes interface, which is used to configure the audio renderer. This parameter can be
///                       <b>NULL</b>. See Remarks.
///    ppSink = Receives a pointer to the audio renderer's IMFMediaSink interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateAudioRenderer(IMFAttributes pAudioAttributes, IMFMediaSink* ppSink);

///Creates an activation object for the Streaming Audio Renderer.
///Params:
///    ppActivate = Receives a pointer to the IMFActivate interface. Use this interface to create the audio renderer. The caller must
///                 release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateAudioRendererActivate(IMFActivate* ppActivate);

///Creates an activation object for the enhanced video renderer (EVR) media sink.
///Params:
///    hwndVideo = Handle to the window where the video will be displayed.
///    ppActivate = Receives a pointer to the IMFActivate interface. Use this interface to create the EVR. The caller must release
///                 the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateVideoRendererActivate(HWND hwndVideo, IMFActivate* ppActivate);

///Creates a media sink for authoring MP4 files.
///Params:
///    pIByteStream = A pointer to the IMFByteStream interface of a byte stream. The media sink writes the MP4 file to this byte
///                   stream. The byte stream must be writable and support seeking.
///    pVideoMediaType = A pointer to the IMFMediaType interface of a video media type. This type specifies the format of the video
///                      stream. This parameter can be <b>NULL</b>, but not if <i>pAudioMediaType</i> is <b>NULL</b>.
///    pAudioMediaType = A pointer to the IMFMediaType interface of an audio media type. This type specifies the format of the audio
///                      stream. This parameter can be <b>NULL</b>, but not if <i>pVideoMediaType</i> is <b>NULL</b>.
///    ppIMediaSink = Receives a pointer to the MP4 media sink's IMFMediaSink interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateMPEG4MediaSink(IMFByteStream pIByteStream, IMFMediaType pVideoMediaType, 
                               IMFMediaType pAudioMediaType, IMFMediaSink* ppIMediaSink);

///Creates a media sink for authoring 3GP files.
///Params:
///    pIByteStream = A pointer to the IMFByteStream interface of a byte stream. The media sink writes the 3GP file to this byte
///                   stream. The byte stream must be writable and support seeking.
///    pVideoMediaType = A pointer to the IMFMediaType interface of a video media type. This type specifies the format of the video
///                      stream. This parameter can be <b>NULL</b>, but not if <i>pAudioMediaType</i> is <b>NULL</b>.
///    pAudioMediaType = A pointer to the IMFMediaType interface of an audio media type. This type specifies the format of the audio
///                      stream. This parameter can be <b>NULL</b>, but not if <i>pVideoMediaType</i> is <b>NULL</b>.
///    ppIMediaSink = Receives a pointer to the 3GP media sink's IMFMediaSink interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreate3GPMediaSink(IMFByteStream pIByteStream, IMFMediaType pVideoMediaType, 
                             IMFMediaType pAudioMediaType, IMFMediaSink* ppIMediaSink);

///Creates the MP3 media sink.
///Params:
///    pTargetByteStream = A pointer to the IMFByteStream interface of a byte stream. The media sink writes the MP3 file to this byte
///                        stream. The byte stream must be writable.
///    ppMediaSink = Receives a pointer to the IMFMediaSink interface of the MP3 media sink.. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateMP3MediaSink(IMFByteStream pTargetByteStream, IMFMediaSink* ppMediaSink);

///Creates an instance of the AC-3 media sink.
///Params:
///    pTargetByteStream = A pointer to the IMFByteStream interface of a byte stream. The media sink writes the AC-3 file to this byte
///                        stream. The byte stream must be writable.
///    pAudioMediaType = A pointer to the IMFMediaType interface. This parameter specifies the media type for the AC-3 audio stream. The
///                      media type must contain the following attributes. <table> <tr> <th>Attribute</th> <th>Value</th> </tr> <tr> <td>
///                      MF_MT_MAJOR_TYPE </td> <td><b>MFMediaType_Audio</b></td> </tr> <tr> <td> MF_MT_SUBTYPE </td>
///                      <td><b>MFAudioFormat_Dolby_AC3</b> or <b>MFAudioFormat_Dolby_DDPlus</b></td> </tr> </table>
///    ppMediaSink = Receives a pointer to the IMFMediaSink interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateAC3MediaSink(IMFByteStream pTargetByteStream, IMFMediaType pAudioMediaType, 
                             IMFMediaSink* ppMediaSink);

///Creates an instance of the audio data transport stream (ADTS) media sink.
///Params:
///    pTargetByteStream = A pointer to the IMFByteStream interface of a byte stream. The media sink writes the ADTS stream to this byte
///                        stream. The byte stream must be writable.
///    pAudioMediaType = A pointer to the IMFMediaType interface. This parameter specifies the media type for the ADTS stream. The media
///                      type must contain the following attributes. <table> <tr> <th>Attribute</th> <th>Value</th> </tr> <tr> <td>
///                      MF_MT_MAJOR_TYPE </td> <td><b>MFMediaType_Audio</b></td> </tr> <tr> <td> MF_MT_SUBTYPE </td>
///                      <td><b>MFAudioFormat_AAC</b></td> </tr> <tr> <td> MF_MT_AAC_PAYLOAD_TYPE </td> <td>0 (raw AAC) or 1 (ADTS)</td>
///                      </tr> </table>
///    ppMediaSink = Receives a pointer to the IMFMediaSink interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateADTSMediaSink(IMFByteStream pTargetByteStream, IMFMediaType pAudioMediaType, 
                              IMFMediaSink* ppMediaSink);

///Creates a generic media sink that wraps a multiplexer Microsoft Media Foundation transform (MFT).
///Params:
///    guidOutputSubType = The subtype GUID of the output type for the MFT.
///    pOutputAttributes = A list of format attributes for the MFT output type. This parameter is optional and can be <b>NULL</b>.
///    pOutputByteStream = A pointer to the IMFByteStream interface of a byte stream. The output from the MFT is written to this byte
///                        stream. This parameter can be <b>NULL</b>.
///    ppMuxSink = Receives a pointer to the IMFMediaSink interface of the media sink. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateMuxSink(GUID guidOutputSubType, IMFAttributes pOutputAttributes, IMFByteStream pOutputByteStream, 
                        IMFMediaSink* ppMuxSink);

///Creates a media sink for authoring fragmented MP4 files.
///Params:
///    pIByteStream = A pointer to the IMFByteStream interface of a byte stream. The media sink writes the MP4 file to this byte
///                   stream. The byte stream must be writable and support seeking.
///    pVideoMediaType = A pointer to the IMFMediaType interface of a video media type. This type specifies the format of the video
///                      stream. This parameter can be <b>NULL</b>, but not if <i>pAudioMediaType</i> is <b>NULL</b>.
///    pAudioMediaType = A pointer to the IMFMediaType interface of an audio media type. This type specifies the format of the audio
///                      stream. This parameter can be <b>NULL</b>, but not if <i>pVideoMediaType</i> is <b>NULL</b>.
///    ppIMediaSink = Receives a pointer to the MP4 media sink's IMFMediaSink interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateFMPEG4MediaSink(IMFByteStream pIByteStream, IMFMediaType pVideoMediaType, 
                                IMFMediaType pAudioMediaType, IMFMediaSink* ppIMediaSink);

///Creates an Audio-Video Interleaved (AVI) Sink.
///Params:
///    pIByteStream = Pointer to the byte stream that will be used to write the AVI file.
///    pVideoMediaType = Pointer to the media type of the video input stream
///    pAudioMediaType = Pointer to the media type of the audio input stream
///    ppIMediaSink = Receives a pointer to the IMFMediaSink Interface. The caller must release this interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("mfsrcsnk")
HRESULT MFCreateAVIMediaSink(IMFByteStream pIByteStream, IMFMediaType pVideoMediaType, 
                             IMFMediaType pAudioMediaType, IMFMediaSink* ppIMediaSink);

///Creates an WAVE archive sink. The WAVE archive sink takes audio and writes it to an .wav file.
///Params:
///    pTargetByteStream = Pointer to the byte stream that will be used to write the .wav file.
///    pAudioMediaType = Pointer to the audio media type.
///    ppMediaSink = Receives a pointer to the IMFMediaSink interface. The caller must release this interface.
@DllImport("mfsrcsnk")
HRESULT MFCreateWAVEMediaSink(IMFByteStream pTargetByteStream, IMFMediaType pAudioMediaType, 
                              IMFMediaSink* ppMediaSink);

///Creates a new instance of the topology loader.
///Params:
///    ppObj = Receives a pointer to the IMFTopoLoader interface of the topology loader. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateTopoLoader(IMFTopoLoader* ppObj);

///Creates an activation object for the sample grabber media sink.
///Params:
///    pIMFMediaType = Pointer to the IMFMediaType interface, defining the media type for the sample grabber's input stream.
///    pIMFSampleGrabberSinkCallback = Pointer to the IMFSampleGrabberSinkCallback interface of a callback object. The caller must implement this
///                                    interface.
///    ppIActivate = Receives a pointer to the IMFActivate interface. Use this interface to complete the creation of the sample
///                  grabber. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateSampleGrabberSinkActivate(IMFMediaType pIMFMediaType, 
                                          IMFSampleGrabberSinkCallback pIMFSampleGrabberSinkCallback, 
                                          IMFActivate* ppIActivate);

///Creates the default implementation of the quality manager.
///Params:
///    ppQualityManager = Receives a pointer to the quality manager's IMFQualityManager interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateStandardQualityManager(IMFQualityManager* ppQualityManager);

///Creates the sequencer source.
///Params:
///    pReserved = Reserved. Must be <b>NULL</b>.
///    ppSequencerSource = Receives a pointer to the IMFSequencerSource interface of the sequencer source. The caller must release the
///                        interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateSequencerSource(IUnknown pReserved, IMFSequencerSource* ppSequencerSource);

///Creates a <b>PROPVARIANT</b> that can be used to seek within a sequencer source presentation.
///Params:
///    dwId = Sequencer element identifier. This value specifies the segment in which to begin playback. The element identifier
///           is returned in the IMFSequencerSource::AppendTopology method.
///    hnsOffset = Starting position within the segment, in 100-nanosecond units.
///    pvarSegmentOffset = Pointer to a <b>PROPVARIANT</b>. The method fills in the <b>PROPVARIANT</b> with the information needed for
///                        performing a seek operation. The caller must free the <b>PROPVARIANT</b> by calling <b>PropVariantClear</b>.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateSequencerSegmentOffset(uint dwId, long hnsOffset, PROPVARIANT* pvarSegmentOffset);

///Creates a media source that aggregates a collection of media sources.
///Params:
///    pSourceCollection = A pointer to the IMFCollection interface of the collection object that contains a list of media sources.
///    ppAggSource = Receives a pointer to the IMFMediaSource interface of the aggregated media source. The caller must release the
///                  interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pSourceCollection</i> collection does not
///    contain any elements. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateAggregateSource(IMFCollection pSourceCollection, IMFMediaSource* ppAggSource);

///Creates a credential cache object. An application can use this object to implement a custom credential manager.
///Params:
///    ppCache = Receives a pointer to the IMFNetCredentialCache interface of the new credential cache object. The caller must
///              release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateCredentialCache(IMFNetCredentialCache* ppCache);

///Creates a default proxy locator.
///Params:
///    pszProtocol = The name of the protocol. <div class="alert"><b>Note</b> In this release of Media Foundation, the default proxy
///                  locator does not support RTSP.</div> <div> </div>
///    pProxyConfig = Pointer to the <b>IPropertyStore</b> interface of a property store that contains the proxy configuration in the
///                   MFNETSOURCE_PROXYSETTINGS property.
///    ppProxyLocator = Receives a pointer to the IMFNetProxyLocator interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateProxyLocator(const(PWSTR) pszProtocol, IPropertyStore pProxyConfig, 
                             IMFNetProxyLocator* ppProxyLocator);

///Creates the scheme handler for the network source.
///Params:
///    riid = Interface identifier (IID) of the interface to retrieve.
///    ppvHandler = Receives a pointer to the requested interface. The caller must release the interface. The scheme handler exposes
///                 the IMFSchemeHandler interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateNetSchemePlugin(const(GUID)* riid, void** ppvHandler);

///Creates the protected media path (PMP) server object.
///Params:
///    dwCreationFlags = A member of the MFPMPSESSION_CREATION_FLAGS enumeration that specifies how to create the PMP session.
///    ppPMPServer = Receives a pointer to the IMFPMPServer interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreatePMPServer(uint dwCreationFlags, IMFPMPServer* ppPMPServer);

///Creates the remote desktop plug-in object. Use this object if the application is running in a Terminal Services
///client session.
///Params:
///    ppPlugin = Receives a pointer to the IMFRemoteDesktopPlugin interface of the plug-in object. The caller must release the
///               interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Remote desktop connections are not allowed by the
///    current session policy. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateRemoteDesktopPlugin(IMFRemoteDesktopPlugin* ppPlugin);

///<p class="CCE_Message">[This API is not supported and may be altered or unavailable in the future. Instead,
///applications should use the <b>PSCreateMemoryPropertyStore</b> function to create named property stores.] Creates an
///empty property store to hold name/value pairs.
///Params:
///    ppStore = Receives a pointer to the <b>INamedPropertyStore</b> interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT CreateNamedPropertyStore(INamedPropertyStore* ppStore);

///Creates an instance of the sample copier transform.
///Params:
///    ppCopierMFT = Receives a pointer to the IMFTransform interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateSampleCopierMFT(IMFTransform* ppCopierMFT);

///Creates an empty transcode profile object. The transcode profile stores configuration settings for the output file.
///These configuration settings are specified by the caller, and include audio and video stream properties, encoder
///settings, and container settings. To set these properties, the caller must call the appropriate IMFTranscodeProfile
///methods. The configured transcode profile is passed to the MFCreateTranscodeTopology function. The underlying
///topology builder uses these settings to build the transcode topology.
///Params:
///    ppTranscodeProfile = Receives a pointer to the IMFTranscodeProfile interface of the transcode profile object. Caller must release the
///                         interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateTranscodeProfile(IMFTranscodeProfile* ppTranscodeProfile);

///Creates a partial transcode topology. The underlying topology builder creates a partial topology by connecting the
///required pipeline objects: source, encoder, and sink. The encoder and the sink are configured according to the
///settings specified by the caller in the transcode profile. To create the transcode profile object, call the
///MFCreateTranscodeProfile function and set the required attributes by calling the appropriate the IMFTranscodeProfile
///methods. The configured transcode profile is passed to the <b>MFCreateTranscodeTopology</b> function, which creates
///the transcode topology with the appropriate settings. The caller can then set this topology on the Media Session and
///start the session to begin the encoding process. When the Media Session ends, the transcoded file is generated.
///Params:
///    pSrc = A pointer to a media source that encapsulates the source file to be transcoded. The media source object exposes
///           the IMFMediaSource interface and can be created by using the source resolver. For more information, see Using the
///           Source Resolver.
///    pwszOutputFilePath = A pointer to a null-terminated string that contains the name and path of the output file to be generated.
///    pProfile = A pointer to the transcode profile that contains the configuration settings for the audio stream, the video
///               stream, and the container to which the file is written. The transcode profile object exposes the
///               IMFTranscodeProfile interface and must be created by calling the MFCreateTranscodeProfile function. After the
///               object has been created the caller must provide the configuration settings by calling appropriate the
///               <b>IMFTranscodeProfile</b> methods.
///    ppTranscodeTopo = Receives a pointer to the IMFTopology interface of the transcode topology object. The caller must release the
///                      interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function call succeeded, and <i>ppTranscodeTopo</i>
///    receives a pointer to the transcode topology. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
///    </dl> </td> <td width="60%"> <i>pwszOutputFilePath</i> contains invalid characters. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED</b></dt> </dl> </td> <td width="60%"> No streams
///    are selected in the media source. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MF_E_TRANSCODE_NO_CONTAINERTYPE</b></dt> </dl> </td> <td width="60%"> The profile does not contain the
///    MF_TRANSCODE_CONTAINERTYPE attribute. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MF_E_TRANSCODE_NO_MATCHING_ENCODER</b></dt> </dl> </td> <td width="60%"> For one or more streams, cannot
///    find an encoder that accepts the media type given in the profile. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS</b></dt> </dl> </td> <td width="60%"> The profile does not
///    specify a media type for any of the selected streams on the media source. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateTranscodeTopology(IMFMediaSource pSrc, const(PWSTR) pwszOutputFilePath, 
                                  IMFTranscodeProfile pProfile, IMFTopology* ppTranscodeTopo);

///Creates a topology for transcoding to a byte stream.
///Params:
///    pSrc = A pointer to the IMFMediaSource interface of a media source. The media source provides that source content for
///           transcoding.
///    pOutputStream = A pointer to the IMFByteStream interface of a byte stream. The transcoded output will be written to this byte
///                    stream.
///    pProfile = A pointer to the IMFTranscodeProfile interface of a transcoding profile.
///    ppTranscodeTopo = Receives a pointer to the IMFTopology interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateTranscodeTopologyFromByteStream(IMFMediaSource pSrc, IMFByteStream pOutputStream, 
                                                IMFTranscodeProfile pProfile, IMFTopology* ppTranscodeTopo);

///Gets a list of output formats from an audio encoder.
///Params:
///    guidSubType = Specifies the subtype of the output media. The encoder uses this value as a filter when it is enumerating the
///                  available output types. For information about the audio subtypes, see Audio Subtype GUIDs.
///    dwMFTFlags = Bitwise <b>OR</b> of zero or more flags from the _MFT_ENUM_FLAG enumeration.
///    pCodecConfig = A pointer to the IMFAttributes interface of an attribute store. The attribute store specifies the encoder
///                   configuration settings. This parameter can be <b>NULL</b>. The attribute store can hold any of the following
///                   attributes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                   id="MFT_FIELDOFUSE_UNLOCK_Attribute"></a><a id="mft_fieldofuse_unlock_attribute"></a><a
///                   id="MFT_FIELDOFUSE_UNLOCK_ATTRIBUTE"></a><dl> <dt><b>MFT_FIELDOFUSE_UNLOCK_Attribute</b></dt> </dl> </td> <td
///                   width="60%"> Set this attribute to unlock an encoder that has field-of-use descriptions. </td> </tr> <tr> <td
///                   width="40%"><a id="MF_TRANSCODE_ENCODINGPROFILE"></a><a id="mf_transcode_encodingprofile"></a><dl>
///                   <dt><b>MF_TRANSCODE_ENCODINGPROFILE</b></dt> </dl> </td> <td width="60%"> Specifies a device conformance profile
///                   for a Windows Media encoder. </td> </tr> <tr> <td width="40%"><a id="MF_TRANSCODE_QUALITYVSSPEED"></a><a
///                   id="mf_transcode_qualityvsspeed"></a><dl> <dt><b>MF_TRANSCODE_QUALITYVSSPEED</b></dt> </dl> </td> <td
///                   width="60%"> Sets the tradeoff between encoding quality and encoding speed. </td> </tr> </table>
///    ppAvailableTypes = Receives a pointer to the IMFCollection interface of a collection object that contains a list of preferred audio
///                       media types. The collection contains IMFMediaType pointers. The caller must release the interface pointer.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function call succeeded. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>MF_E_TRANSCODE_NO_MATCHING_ENCODER</b></dt> </dl> </td> <td width="60%"> Failed to find an encoder
///    that matches the specified configuration settings. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFTranscodeGetAudioOutputAvailableTypes(const(GUID)* guidSubType, uint dwMFTFlags, 
                                                IMFAttributes pCodecConfig, IMFCollection* ppAvailableTypes);

///Creates the transcode sink activation object. The transcode sink activation object can be used to create any of the
///following file sinks: <ul> <li>3GP file sink</li> <li>MP3 file sink</li> <li>MP4 file sink</li> </ul>The transcode
///sink activation object exposes the IMFTranscodeSinkInfoProvider interface.
///Params:
///    ppActivate = Receives a pointer to the IMFActivate interface. This interface is used to create the file sink instance from the
///                 activation object. Before doing so, query the returned pointer for the IMFTranscodeSinkInfoProvider interface and
///                 use that interface to initialize the object.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateTranscodeSinkActivate(IMFActivate* ppActivate);

///Creates an IMFTrackedSample object that tracks the reference counts on a video media sample.
///Params:
///    ppMFSample = Receives a pointer to the IMFTrackedSample interface.
@DllImport("MFPlat")
HRESULT MFCreateTrackedSample(IMFTrackedSample* ppMFSample);

///Creates a Microsoft Media Foundation byte stream that wraps an <b>IStream</b> pointer.
///Params:
///    pStream = A pointer to the <b>IStream</b> interface.
///    ppByteStream = Receives a pointer to the IMFByteStream interface. The caller must release the interface.
///Returns:
///    Returns an <b>HRESULT</b> value.
///    
@DllImport("MFPlat")
HRESULT MFCreateMFByteStreamOnStream(IStream pStream, IMFByteStream* ppByteStream);

///Returns an IStream pointer that wraps a Microsoft Media Foundation byte stream.
///Params:
///    pByteStream = A pointer to the IMFByteStream interface of the Media Foundation byte stream.
///    ppStream = Receives a pointer to the IStream interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateStreamOnMFByteStream(IMFByteStream pByteStream, IStream* ppStream);

///Creates a Microsoft Media Foundation byte stream that wraps an IRandomAccessStream object.
///Params:
///    punkStream = A pointer to the IRandomAccessStream interface.
///    ppByteStream = Receives a pointer to the IMFByteStream interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateMFByteStreamOnStreamEx(IUnknown punkStream, IMFByteStream* ppByteStream);

///Creates an IRandomAccessStream object that wraps a Microsoft Media Foundation byte stream.
///Params:
///    pByteStream = A pointer to the IMFByteStream interface of the Media Foundation byte stream.
///    riid = The interface identifier (IID) of the interface being requested.
///    ppv = Receives a pointer to the requested interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateStreamOnMFByteStreamEx(IMFByteStream pByteStream, const(GUID)* riid, void** ppv);

///Create an IMFMediaType from properties.
///Params:
///    punkStream = A pointer to properties.
///    ppMediaType = Receives a pointer to the IMFMediaType. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateMediaTypeFromProperties(IUnknown punkStream, IMFMediaType* ppMediaType);

///Creates properties from a IMFMediaType.
///Params:
///    pMediaType = A pointer to the IMFMediaType interface.
///    riid = The interface identifier (IID) of the interface being requested.
///    ppv = Receives a pointer to the requested interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreatePropertiesFromMediaType(IMFMediaType pMediaType, const(GUID)* riid, void** ppv);

///Enumerates a list of audio or video capture devices.
///Params:
///    pAttributes = Pointer to an attribute store that contains search criteria. To create the attribute store, call
///                  MFCreateAttributes. Set one or more of the following attributes on the attribute store: <table> <tr>
///                  <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE"></a><a
///                  id="mf_devsource_attribute_source_type"></a><dl> <dt><b>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE</b></dt> </dl> </td>
///                  <td width="60%"> Specifies whether to enumerate audio or video devices. (Required.) </td> </tr> <tr> <td
///                  width="40%"><a id="MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_ROLE"></a><a
///                  id="mf_devsource_attribute_source_type_audcap_role"></a><dl>
///                  <dt><b>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_ROLE</b></dt> </dl> </td> <td width="60%"> For audio capture
///                  devices, specifies the device role. (Optional.) </td> </tr> <tr> <td width="40%"><a
///                  id="MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_CATEGORY"></a><a
///                  id="mf_devsource_attribute_source_type_vidcap_category"></a><dl>
///                  <dt><b>MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_CATEGORY</b></dt> </dl> </td> <td width="60%"> For video capture
///                  devices, specifies the device category. (Optional.) </td> </tr> </table>
///    pppSourceActivate = Receives an array of IMFActivate interface pointers. Each pointer represents an activation object for a media
///                        source. The function allocates the memory for the array. The caller must release the pointers in the array and
///                        call CoTaskMemFree to free the memory for the array.
///    pcSourceActivate = Receives the number of elements in the <i>pppSourceActivate</i> array. If no capture devices match the search
///                       criteria, this parameter receives the value 0.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFEnumDeviceSources(IMFAttributes pAttributes, IMFActivate** pppSourceActivate, uint* pcSourceActivate);

///Creates a media source for a hardware capture device.
///Params:
///    pAttributes = Pointer to the IMFAttributes interface of an attribute store, which is used to select the device. See Remarks.
///    ppSource = Receives a pointer to the media source's IMFMediaSource interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateDeviceSource(IMFAttributes pAttributes, IMFMediaSource* ppSource);

///Creates an activation object that represents a hardware capture device.
///Params:
///    pAttributes = Pointer to the IMFAttributes interface of an attribute store, which is used to select the device. See Remarks.
///    ppActivate = Receives a pointer to the IMFActivate interface. The caller must release the interface.
@DllImport("MF")
HRESULT MFCreateDeviceSourceActivate(IMFAttributes pAttributes, IMFActivate* ppActivate);

///Creates an IMFProtectedEnvironmentAccess object that allows content protection systems to perform a handshake with
///the protected environment.
///Params:
///    ppAccess = Receives a pointer to the IMFProtectedEnvironmentAccess interface.
@DllImport("MF")
HRESULT MFCreateProtectedEnvironmentAccess(IMFProtectedEnvironmentAccess* ppAccess);

///Loads a dynamic link library that is signed for the protected environment.
///Params:
///    pszName = The name of the dynamic link library to load. This dynamic link library must be signed for the protected
///              environment.
///    ppLib = Receives a pointer to the IMFSignedLibrary interface for the library.
@DllImport("MF")
HRESULT MFLoadSignedLibrary(const(PWSTR) pszName, IMFSignedLibrary* ppLib);

///Returns an IMFSystemId object for retrieving system id data.
///Params:
///    ppId = Receives a pointer to the IMFSystemId interface.
@DllImport("MF")
HRESULT MFGetSystemId(IMFSystemId* ppId);

///Gets the local system ID.
///Params:
///    verifier = Application-specific verifier value.
///    size = Length in bytes of verifier.
///    id = Returned ID string. This value must be freed by the caller by calling CoTaskMemFree.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table.
///    
@DllImport("MF")
HRESULT MFGetLocalId(const(ubyte)* verifier, uint size, PWSTR* id);

///Creates an IMFContentProtectionDevice interface for the specified media protection system.
///Params:
///    ProtectionSystemId = The idenfier of the media protection system for which you want to create the IMFContentProtectionDevice
///                         interface.
///    ContentProtectionDevice = Pointer to the created IMFContentProtectionDevice interface.
@DllImport("MFPlat")
HRESULT MFCreateContentProtectionDevice(const(GUID)* ProtectionSystemId, 
                                        IMFContentProtectionDevice* ContentProtectionDevice);

///Checks whether a hardware security processor is supported for the specified media protection system.
///Params:
///    ProtectionSystemId = The identifier of the protection system that you want to check.
///    isSupported = <b>TRUE</b> if the hardware security processor is supported for the specified protection system; otherwise
///                  <b>FALSE</b>.
@DllImport("MFPlat")
HRESULT MFIsContentProtectionDeviceSupported(const(GUID)* ProtectionSystemId, BOOL* isSupported);

///Creates an IMFContentDecryptorContext interface for the specified media protection system.
///Params:
///    guidMediaProtectionSystemId = The identifier of the media protection system for which you want to create an IMFContentDecryptorContext
///                                  interface.
///    pD3DManager = Pointer to the IMFDXGIDeviceManager interface that you want to use for sharing the Direct3D 11 device.
///    pContentProtectionDevice = The IMFContentProtectionDevice interface for the specified media protection system.
///    ppContentDecryptorContext = Pointer to the created IMFContentDecryptorContext interface.
@DllImport("MFPlat")
HRESULT MFCreateContentDecryptorContext(const(GUID)* guidMediaProtectionSystemId, IMFDXGIDeviceManager pD3DManager, 
                                        IMFContentProtectionDevice pContentProtectionDevice, 
                                        IMFContentDecryptorContext* ppContentDecryptorContext);

///Creates an instance of the IMFSensorGroup interface based on the provided symbolic link name.
///Params:
///    SensorGroupSymbolicLink = The symbolic link for the new IMFSensorGroup. This name can be obtained through device enumeration APIs such as
///                              SetupDiGetClassDevs or MFEnumDeviceSources or by getting the Id property of the DeviceInformation class.
///    ppSensorGroup = The symbolic link for the new IMFSensorGroup.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The supplied IMFSensorGroup is null. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The supplied <b>LPCWSTR</b> is null.
///    </td> </tr> </table>
///    
@DllImport("MFSENSORGROUP")
HRESULT MFCreateSensorGroup(const(PWSTR) SensorGroupSymbolicLink, IMFSensorGroup* ppSensorGroup);

///Creates an instance of the IMFSensorStream interface.
///Params:
///    StreamId = The identifier for the created stream. This is the same as setting the MF_DEVICESTREAM_STREAM_ID attribute. This
///               value is used if <i>pAttributes</i> is null.
///    pAttributes = The attribute store for the created stream.
///    pMediaTypeCollection = The collection of IMFMediaType objects specifying the media types supported by the stream.
///    ppStream = The created stream interface.
@DllImport("MFSENSORGROUP")
HRESULT MFCreateSensorStream(uint StreamId, IMFAttributes pAttributes, IMFCollection pMediaTypeCollection, 
                             IMFSensorStream* ppStream);

///Creates a sensor profile, based on the specified type, index, and optional constraints.
///Params:
///    ProfileType = The profile type to create.
///    ProfileIndex = The profile index.
///    Constraints = Any optional constraints to be put on the profile.
///    ppProfile = On success, returns a double pointer to the IMFSensorProfile containing the sensor profile.
@DllImport("MFSENSORGROUP")
HRESULT MFCreateSensorProfile(const(GUID)* ProfileType, uint ProfileIndex, const(PWSTR) Constraints, 
                              IMFSensorProfile* ppProfile);

///Creates a sensor profile collection.
///Params:
///    ppSensorProfile = On success, points to an IMFSensorProfileCollection containing the sensor profile collection.
@DllImport("MFSENSORGROUP")
HRESULT MFCreateSensorProfileCollection(IMFSensorProfileCollection* ppSensorProfile);

///Initializes a new instance of the IMFSensorActivityMonitor interface.
///Params:
///    pCallback = An implementation of the IMFSensorActivitiesReportCallback interface through which the system delivers
///                IMFSensorActivitiesReport objects.
///    ppActivityMonitor = A pointer to the new IMFSensorActivityMonitor.
@DllImport("MFSENSORGROUP")
HRESULT MFCreateSensorActivityMonitor(IMFSensorActivitiesReportCallback pCallback, 
                                      IMFSensorActivityMonitor* ppActivityMonitor);

@DllImport("MFCORE")
HRESULT MFCreateExtendedCameraIntrinsics(IMFExtendedCameraIntrinsics* ppExtendedCameraIntrinsics);

@DllImport("MFCORE")
HRESULT MFCreateExtendedCameraIntrinsicModel(const(MFCameraIntrinsic_DistortionModelType) distortionModelType, 
                                             IMFExtendedCameraIntrinsicModel* ppExtendedCameraIntrinsicModel);

///Creates a new instance of the **IMFRelativePanelWatcher** interface, which monitors the panel associated with the
///provided display monitor, so that the app receives notifications when the relative location of the panel changes.
///Params:
///    videoDeviceId = A string containing the symbolic link name of the video capture device.
///    displayMonitorDeviceId = A string containing the symbolic link name of the display monitor device.
///    ppRelativePanelWatcher = A pointer to an **IMFRelativePanelWatcher** interface representing the watcher.
///Returns:
///    The function returns an **HRESULT**. Possible values include, but are not limited to, those in the following
///    table. | Return code | Description | |--------------|------------------------| |S_OK | The function succeeded.|
///    
@DllImport("MFSENSORGROUP")
HRESULT MFCreateRelativePanelWatcher(const(PWSTR) videoDeviceId, const(PWSTR) displayMonitorDeviceId, 
                                     IMFRelativePanelWatcher* ppRelativePanelWatcher);

///Creates the ASF Header Object object.
///Params:
///    ppIContentInfo = Receives a pointer to the IMFASFContentInfo interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateASFContentInfo(IMFASFContentInfo* ppIContentInfo);

///Creates the ASF Indexer object.
///Params:
///    ppIIndexer = Receives a pointer to the IMFASFIndexer interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateASFIndexer(IMFASFIndexer* ppIIndexer);

///Creates a byte stream to access the index in an ASF stream.
///Params:
///    pIContentByteStream = Pointer to the IMFByteStream interface of a byte stream that contains the ASF stream.
///    cbIndexStartOffset = Byte offset of the index within the ASF stream. To get this value, call IMFASFIndexer::GetIndexPosition.
///    pIIndexByteStream = Receives a pointer to the IMFByteStream interface. Use this interface to read from the index or write to the
///                        index. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The call succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MF_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The offset specified in <i>cbIndexStartOffset</i> is
///    invalid. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateASFIndexerByteStream(IMFByteStream pIContentByteStream, ulong cbIndexStartOffset, 
                                     IMFByteStream* pIIndexByteStream);

///Creates the ASF Splitter.
///Params:
///    ppISplitter = Receives a pointer to the IMFASFSplitter interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateASFSplitter(IMFASFSplitter* ppISplitter);

///Creates the ASF profile object.
///Params:
///    ppIProfile = Receives a pointer to the IMFASFProfile interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateASFProfile(IMFASFProfile* ppIProfile);

///Creates an ASF profile object from a presentation descriptor.
///Params:
///    pIPD = Pointer to the IMFPresentationDescriptor interface of the presentation descriptor that contains the profile
///           information.
///    ppIProfile = Receives a pointer to the IMFASFProfile interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateASFProfileFromPresentationDescriptor(IMFPresentationDescriptor pIPD, IMFASFProfile* ppIProfile);

///Creates a presentation descriptor from an ASF profile object.
///Params:
///    pIProfile = Pointer to the IMFASFProfile interface of the ASF profile object.
///    ppIPD = Receives a pointer to the IMFPresentationDescriptor interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreatePresentationDescriptorFromASFProfile(IMFASFProfile pIProfile, IMFPresentationDescriptor* ppIPD);

///Creates the ASF Multiplexer.
///Params:
///    ppIMultiplexer = Receives a pointer to the IMFASFMultiplexer interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateASFMultiplexer(IMFASFMultiplexer* ppIMultiplexer);

///Creates the ASF stream selector.
///Params:
///    pIASFProfile = Pointer to the IMFASFProfile interface.
///    ppSelector = Receives a pointer to the IMFASFStreamSelector interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateASFStreamSelector(IMFASFProfile pIASFProfile, IMFASFStreamSelector* ppSelector);

///Creates the ASF media sink.
///Params:
///    pIByteStream = Pointer to a byte stream that will be used to write the ASF stream.
///    ppIMediaSink = Receives a pointer to the IMFMediaSink interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateASFMediaSink(IMFByteStream pIByteStream, IMFMediaSink* ppIMediaSink);

///Creates an activation object that can be used to create the ASF media sink.
///Params:
///    pwszFileName = Null-terminated wide-character string that contains the output file name.
///    pContentInfo = A pointer to the IMFASFContentInfo interface of an initialized ASF Header Object object. Use this interface to
///                   configure the ASF media sink.
///    ppIActivate = Receives a pointer to the IMFActivate interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateASFMediaSinkActivate(const(PWSTR) pwszFileName, IMFASFContentInfo pContentInfo, 
                                     IMFActivate* ppIActivate);

///Creates an activation object that can be used to create a Windows Media Video (WMV) encoder.
///Params:
///    pMediaType = A pointer to the IMFMediaType interface. This parameter specifies the encoded output format.
///    pEncodingConfigurationProperties = A pointer to the <b>IPropertyStore</b> interface of a property store that contains encoding parameters. Encoding
///                                       parameters for the WMV encoder are defined in the header file wmcodecdsp.h. If you have an ASF ContentInfo object
///                                       that contains an ASF profile object with all the streams for the output file, you can get the property store by
///                                       calling IMFASFContentInfo::GetEncodingConfigurationPropertyStore.
///    ppActivate = Receives a pointer to the IMFActivate interface. Use this interface to create the encoder. The caller must
///                 release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateWMVEncoderActivate(IMFMediaType pMediaType, IPropertyStore pEncodingConfigurationProperties, 
                                   IMFActivate* ppActivate);

///Creates an activation object that can be used to create a Windows Media Audio (WMA) encoder.
///Params:
///    pMediaType = A pointer to the IMFMediaType interface. This parameter specifies the encoded output format.
///    pEncodingConfigurationProperties = A pointer to the <b>IPropertyStore</b> interface of a property store that contains encoding parameters. Encoding
///                                       parameters for the WMV encoder are defined in the header file wmcodecdsp.h. If you have an ASF ContentInfo object
///                                       that contains an ASF profile object with all the streams for the output file, you can get the property store by
///                                       calling IMFASFContentInfo::GetEncodingConfigurationPropertyStore.
///    ppActivate = Receives a pointer to the IMFActivate interface. Use this interface to create the encoder. The caller must
///                 release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateWMAEncoderActivate(IMFMediaType pMediaType, IPropertyStore pEncodingConfigurationProperties, 
                                   IMFActivate* ppActivate);

///Creates an activation object for the ASF streaming sink. The ASF streaming sink enables an application to write
///streaming Advanced Systems Format (ASF) packets to an HTTP byte stream.
///Params:
///    pIByteStream = A pointer to a byte stream object in which the ASF media sink writes the streamed content.
///    ppIMediaSink = Receives a pointer to the IMFMediaSink interface of the ASF streaming-media sink object. To create the media
///                   sink, the application must call IMFActivate::ActivateObject on the received pointer. The caller must release the
///                   interface pointer.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateASFStreamingMediaSink(IMFByteStream pIByteStream, IMFMediaSink* ppIMediaSink);

///Creates an activation object for the ASF streaming sink. The ASF streaming sink enables an application to write
///streaming Advanced Systems Format (ASF) packets to an HTTP byte stream. The activation object can be used to create
///the ASF streaming sink in another process.
///Params:
///    pByteStreamActivate = A pointer to the IMFActivate interface of an activation object. The caller implements this interface. The
///                          IMFActivate::ActivateObject method of the activation object must create a byte-stream object. The byte stream
///                          exposes the IMFByteStream interface. The ASF streaming sink will write data to this byte stream.
///    pContentInfo = A pointer to an ASF ContentInfo Object that contains the properties that describe the ASF content. These settings
///                   can contain stream settings, encoding properties, and metadata. For more information about these properties, see
///                   Setting Properties in the ContentInfo Object.
///    ppIActivate = Receives a pointer to the IMFActivate interface of the activation object that is used to create the ASF
///                  streaming-media sink. To create the media sink, the application must call IMFActivate::ActivateObject by using
///                  the received pointer. The <b>ActivateObject</b> method also calls <b>IMFActivate::Activate</b> on the byte stream
///                  activate object specified by <i>pByteStreamActivate</i>, to create it so that the media sink can write streamed
///                  content in the byte stream. The caller must release the <b>IMFActivate</b> interface pointer of the media sink
///                  activation object received in <i>ppIActivate</i>.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MF")
HRESULT MFCreateASFStreamingMediaSinkActivate(IMFActivate pByteStreamActivate, IMFASFContentInfo pContentInfo, 
                                              IMFActivate* ppIActivate);

///Initializes Microsoft Media Foundation.
///Params:
///    Version = Version number. Use the value <b>MF_VERSION</b>, defined in mfapi.h.
///    dwFlags = This parameter is optional when using C++ but required in C. The value must be one of the following flags:
///              <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>MFSTARTUP_NOSOCKET</dt> </dl>
///              </td> <td width="60%"> Do not initialize the sockets library. </td> </tr> <tr> <td width="40%"> <dl>
///              <dt>MFSTARTUP_LITE</dt> </dl> </td> <td width="60%"> Equivalent to MFSTARTUP_NOSOCKET. </td> </tr> <tr> <td
///              width="40%"> <dl> <dt>MFSTARTUP_FULL</dt> </dl> </td> <td width="60%"> Initialize the entire Media Foundation
///              platform. This is the default value when <i>dwFlags</i> is not specified. </td> </tr> </table>
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MF_E_BAD_STARTUP_VERSION</b></dt> </dl> </td> <td width="60%"> The <i>Version</i> parameter requires a
///    newer version of Media Foundation than the version that is running. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MF_E_DISABLED_IN_SAFEMODE</b></dt> </dl> </td> <td width="60%"> The Media Foundation platform is disabled
///    because the system was started in "Safe Mode" (fail-safe boot). </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Media Foundation is not implemented on the system. This
///    error can occur if the media components are not present (See KB2703761 for more info). </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFStartup(uint Version, uint dwFlags);

///Shuts down the Microsoft Media Foundation platform. Call this function once for every call to MFStartup. Do not call
///this function from work queue threads.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFShutdown();

///Blocks the MFShutdown function.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFLockPlatform();

///Unlocks the Media Foundation platform after it was locked by a call to the MFLockPlatform function.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFUnlockPlatform();

///Puts an asynchronous operation on a work queue.
///Params:
///    dwQueue = The identifier for the work queue. This value can specify one of the standard Media Foundation work queues, or a
///              work queue created by the application. For list of standard Media Foundation work queues, see Work Queue
///              Identifiers. To create a new work queue, call MFAllocateWorkQueue or MFAllocateWorkQueueEx.
///    pCallback = A pointer to the IMFAsyncCallback interface. The caller must implement this interface.
///    pState = A pointer to the IUnknown interface of a state object, defined by the caller. This parameter can be <b>NULL</b>.
///             You can use this object to hold state information. The object is returned to the caller when the callback is
///             invoked.
///Returns:
///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%">
///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_INVALID_WORKQUEUE</b></b></dt> </dl> </td> <td
///    width="60%"> Invalid work queue. For more information, see IMFAsyncCallback::GetParameters. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The MFStartup function was not
///    called, or MFShutdown was called. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFPutWorkItem(uint dwQueue, IMFAsyncCallback pCallback, IUnknown pState);

///Puts an asynchronous operation on a work queue, with a specified priority.
///Params:
///    dwQueue = The identifier for the work queue. This value can specify one of the standard Media Foundation work queues, or a
///              work queue created by the application. For list of standard Media Foundation work queues, see Work Queue
///              Identifiers. To create a new work queue, call MFAllocateWorkQueue or MFAllocateWorkQueueEx.
///    Priority = The priority of the work item. Work items are performed in order of priority.
///    pCallback = A pointer to the IMFAsyncCallback interface. The caller must implement this interface.
///    pState = A pointer to the IUnknown interface of a state object, defined by the caller. This parameter can be <b>NULL</b>.
///             You can use this object to hold state information. The object is returned to the caller when the callback is
///             invoked.
///Returns:
///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%">
///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_INVALID_WORKQUEUE</b></b></dt> </dl> </td> <td
///    width="60%"> Invalid work queue identifier. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt>
///    </dl> </td> <td width="60%"> The MFStartup function was not called, or MFShutdown was called. </td> </tr>
///    </table>
///    
@DllImport("MFPlat")
HRESULT MFPutWorkItem2(uint dwQueue, int Priority, IMFAsyncCallback pCallback, IUnknown pState);

///Puts an asynchronous operation on a work queue.
///Params:
///    dwQueue = The identifier for the work queue. This value can specify one of the standard Media Foundation work queues, or a
///              work queue created by the application. For list of standard Media Foundation work queues, see Work Queue
///              Identifiers. To create a new work queue, call MFAllocateWorkQueue or MFAllocateWorkQueueEx.
///    pResult = A pointer to the IMFAsyncResult interface of an asynchronous result object. To create the result object, call
///              MFCreateAsyncResult.
///Returns:
///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%">
///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_INVALID_WORKQUEUE</b></b></dt> </dl> </td> <td
///    width="60%"> Invalid work queue identifier. For more information, see IMFAsyncCallback::GetParameters. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The MFStartup
///    function was not called, or MFShutdown was called. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFPutWorkItemEx(uint dwQueue, IMFAsyncResult pResult);

///Puts an asynchronous operation on a work queue, with a specified priority.
///Params:
///    dwQueue = The identifier for the work queue. This value can specify one of the standard Media Foundation work queues, or a
///              work queue created by the application. For list of standard Media Foundation work queues, see Work Queue
///              Identifiers. To create a new work queue, call MFAllocateWorkQueue or MFAllocateWorkQueueEx.
///    Priority = The priority of the work item. This value should be 1, 0, or -1. Items with a value of 1 are executed before
///               items with a value of 0. Items with a value of -1 are executed after items with a value of 0.
///    pResult = A pointer to the IMFAsyncResult interface of an asynchronous result object. To create the result object, call
///              MFCreateAsyncResult.
///Returns:
///    Returns an <b>HRESULT</b> value. Possible values include the following. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%">
///    Success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_INVALID_WORKQUEUE</b></b></dt> </dl> </td> <td
///    width="60%"> Invalid work queue identifier. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt>
///    </dl> </td> <td width="60%"> The MFStartup function was not called, or MFShutdown was called. </td> </tr>
///    </table>
///    
@DllImport("MFPlat")
HRESULT MFPutWorkItemEx2(uint dwQueue, int Priority, IMFAsyncResult pResult);

///Queues a work item that waits for an event to be signaled.
///Params:
///    hEvent = A handle to an event object. To create an event object, call CreateEvent or CreateEventEx.
///    Priority = The priority of the work item. Work items are performed in order of priority.
///    pResult = A pointer to the IMFAsyncResult interface of an asynchronous result object. To create the result object, call
///              MFCreateAsyncResult.
///    pKey = Receives a key that can be used to cancel the wait. To cancel the wait, call MFCancelWorkItem and pass this key
///           in the <i>Key</i> parameter. This parameter can be <b>NULL</b>.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFPutWaitingWorkItem(HANDLE hEvent, int Priority, IMFAsyncResult pResult, ulong* pKey);

///Creates a work queue that is guaranteed to serialize work items. The serial work queue wraps an existing
///multithreaded work queue. The serial work queue enforces a first-in, first-out (FIFO) execution order.
///Params:
///    dwWorkQueue = The identifier of an existing work queue. This must be either a multithreaded queue or another serial work queue.
///                  Any of the following can be used: <ul> <li>The default work queue (<b>MFASYNC_CALLBACK_QUEUE_STANDARD</b>)</li>
///                  <li>The platform multithreaded queue (<b>MFASYNC_CALLBACK_QUEUE_MULTITHREADED</b>)</li> <li>A multithreaded queue
///                  returned by the MFLockSharedWorkQueue function.</li> <li>A serial queue created by the
///                  <b>MFAllocateSerialWorkQueue</b> function.</li> </ul>
///    pdwWorkQueue = Receives an identifier for the new serial work queue. Use this identifier when queuing work items.
///Returns:
///    This function can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The application exceeded the maximum
///    number of work queues. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td
///    width="60%"> The application did not call MFStartup, or the application has already called MFShutdown. </td>
///    </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFAllocateSerialWorkQueue(uint dwWorkQueue, uint* pdwWorkQueue);

///Schedules an asynchronous operation to be completed after a specified interval.
///Params:
///    pResult = Pointer to the IMFAsyncResult interface of an asynchronous result object. To create the result object, call
///              MFCreateAsyncResult.
///    Timeout = Time-out interval, in milliseconds. Set this parameter to a negative value. The callback is invoked after
///              âˆ’<i>Timeout</i> milliseconds. For example, if <i>Timeout</i> is âˆ’5000, the callback is invoked after 5000
///              milliseconds.
///    pKey = Receives a key that can be used to cancel the timer. To cancel the timer, call MFCancelWorkItem and pass this key
///           in the <i>Key</i> parameter.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFScheduleWorkItemEx(IMFAsyncResult pResult, long Timeout, ulong* pKey);

///Schedules an asynchronous operation to be completed after a specified interval.
///Params:
///    pCallback = Pointer to the IMFAsyncCallback interface. The caller must implement this interface.
///    pState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
///             <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
///             callback is invoked.
///    Timeout = Time-out interval, in milliseconds. Set this parameter to a negative value. The callback is invoked after
///              âˆ’<i>Timeout</i> milliseconds. For example, if <i>Timeout</i> is âˆ’5000, the callback is invoked after 5000
///              milliseconds.
///    pKey = Receives a key that can be used to cancel the timer. To cancel the timer, call MFCancelWorkItem and pass this key
///           in the <i>Key</i> parameter.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFScheduleWorkItem(IMFAsyncCallback pCallback, IUnknown pState, long Timeout, ulong* pKey);

///Attempts to cancel an asynchronous operation that was scheduled with MFScheduleWorkItem or MFScheduleWorkItemEx.
///Params:
///    Key = The key that was received in the <i>pKey</i> parameter of the MFScheduleWorkItem, MFScheduleWorkItemEx, or
///          MFPutWaitingWorkItem functions.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCancelWorkItem(ulong Key);

///Retrieves the timer interval for the MFAddPeriodicCallback function.
///Params:
///    Periodicity = Receives the timer interval, in milliseconds.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFGetTimerPeriodicity(uint* Periodicity);

///Sets a callback function to be called at a fixed interval.
///Params:
///    Callback = Pointer to the callback function, of type MFPERIODICCALLBACK.
///    pContext = Pointer to a caller-provided object that implements <b>IUnknown</b>, or <b>NULL</b>. This parameter is passed to
///               the callback function.
///    pdwKey = Receives a key that can be used to cancel the callback. To cancel the callback, call MFRemovePeriodicCallback and
///             pass this key as the <i>dwKey</i> parameter.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFAddPeriodicCallback(MFPERIODICCALLBACK Callback, IUnknown pContext, uint* pdwKey);

///Cancels a callback function that was set by the MFAddPeriodicCallback function.
///Params:
///    dwKey = Key that identifies the callback. This value is retrieved by the MFAddPeriodicCallback function.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFRemovePeriodicCallback(uint dwKey);

///Creates a new work queue. This function extends the capabilities of the MFAllocateWorkQueue function by making it
///possible to create a work queue that has a message loop.
///Params:
///    WorkQueueType = A member of the MFASYNC_WORKQUEUE_TYPE enumeration, specifying the type of work queue to create. <table> <tr>
///                    <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MF_MULTITHREADED_WORKQUEUE"></a><a
///                    id="mf_multithreaded_workqueue"></a><dl> <dt><b>MF_MULTITHREADED_WORKQUEUE</b></dt> </dl> </td> <td width="60%">
///                    Create a multithreaded work queue. Generally, applications should not create private multithreaded queues. Use
///                    the platform multithreaded queues instead. For more information, see Work Queue and Threading Improvements. </td>
///                    </tr> <tr> <td width="40%"><a id="MF_STANDARD_WORKQUEUE"></a><a id="mf_standard_workqueue"></a><dl>
///                    <dt><b>MF_STANDARD_WORKQUEUE</b></dt> </dl> </td> <td width="60%"> Create a work queue without a message loop.
///                    Using this flag is equivalent to calling MFAllocateWorkQueue. </td> </tr> <tr> <td width="40%"><a
///                    id="MF_WINDOW_WORKQUEUE"></a><a id="mf_window_workqueue"></a><dl> <dt><b>MF_WINDOW_WORKQUEUE</b></dt> </dl> </td>
///                    <td width="60%"> Create a work queue with a message loop. The thread that dispatches the work items for this
///                    queue will also call PeekMessage and DispatchMessage. Use this option if your callback performs any actions that
///                    require a message loop. </td> </tr> </table>
///    pdwWorkQueue = Receives an identifier for the work queue that was created.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The application exceeded the maximum number of work queues.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid
///    argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The
///    application did not call MFStartup, or the application has already called MFShutdown. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFAllocateWorkQueueEx(MFASYNC_WORKQUEUE_TYPE WorkQueueType, uint* pdwWorkQueue);

///Creates a new work queue.
///Params:
///    pdwWorkQueue = Receives an identifier for the work queue.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The application exceeded the maximum number of work queues.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The application
///    did not call MFStartup, or the application has already called MFShutdown. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFAllocateWorkQueue(uint* pdwWorkQueue);

///Locks a work queue.
///Params:
///    dwWorkQueue = The identifier for the work queue. The identifier is returned by the MFAllocateWorkQueue function.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFLockWorkQueue(uint dwWorkQueue);

///Unlocks a work queue.
///Params:
///    dwWorkQueue = Identifier for the work queue to be unlocked. The identifier is returned by the MFAllocateWorkQueue function.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFUnlockWorkQueue(uint dwWorkQueue);

///Associates a work queue with a Multimedia Class Scheduler Service (MMCSS) task.
///Params:
///    dwWorkQueueId = The identifier of the work queue. For private work queues, the identifier is returned by the MFAllocateWorkQueue
///                    function. For platform work queues, see Work Queue Identifiers.
///    wszClass = The name of the MMCSS task.For more information, see Multimedia Class Scheduler Service.
///    dwTaskId = The unique task identifier. To obtain a new task identifier, set this value to zero.
///    pDoneCallback = A pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
///    pDoneState = A pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
///                 <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
///                 callback is invoked.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFBeginRegisterWorkQueueWithMMCSS(uint dwWorkQueueId, const(PWSTR) wszClass, uint dwTaskId, 
                                          IMFAsyncCallback pDoneCallback, IUnknown pDoneState);

///Associates a work queue with a Multimedia Class Scheduler Service (MMCSS) task.
///Params:
///    dwWorkQueueId = The identifier of the work queue. For private work queues, the identifier is returned by the MFAllocateWorkQueue
///                    function. For platform work queues, see Work Queue Identifiers.
///    wszClass = The name of the MMCSS task. For more information, see Multimedia Class Scheduler Service.
///    dwTaskId = The unique task identifier. To obtain a new task identifier, set this value to zero.
///    lPriority = The base relative priority for the work-queue threads. For more information, see AvSetMmThreadPriority.
///    pDoneCallback = A pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
///    pDoneState = A pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
///                 <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
///                 callback is invoked.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFBeginRegisterWorkQueueWithMMCSSEx(uint dwWorkQueueId, const(PWSTR) wszClass, uint dwTaskId, 
                                            int lPriority, IMFAsyncCallback pDoneCallback, IUnknown pDoneState);

///Completes an asynchronous request to associate a work queue with a Multimedia Class Scheduler Service (MMCSS) task.
///Params:
///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
///              IMFAsyncCallback::Invoke method.
///    pdwTaskId = The unique task identifier.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFEndRegisterWorkQueueWithMMCSS(IMFAsyncResult pResult, uint* pdwTaskId);

///Unregisters a work queue from a Multimedia Class Scheduler Service (MMCSS) task.
///Params:
///    dwWorkQueueId = The identifier of the work queue. For private work queues, the identifier is returned by the MFAllocateWorkQueue
///                    function. For platform work queues, see Work Queue Identifiers.
///    pDoneCallback = Pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
///    pDoneState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
///                 <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
///                 callback is invoked.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFBeginUnregisterWorkQueueWithMMCSS(uint dwWorkQueueId, IMFAsyncCallback pDoneCallback, 
                                            IUnknown pDoneState);

///Completes an asynchronous request to unregister a work queue from a Multimedia Class Scheduler Service (MMCSS) task.
///Params:
///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
///              IMFAsyncCallback::Invoke method.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFEndUnregisterWorkQueueWithMMCSS(IMFAsyncResult pResult);

///Retrieves the Multimedia Class Scheduler Service (MMCSS) class currently associated with this work queue.
///Params:
///    dwWorkQueueId = Identifier for the work queue. The identifier is retrieved by the MFAllocateWorkQueue function.
///    pwszClass = Pointer to a buffer that receives the name of the MMCSS class. This parameter can be <b>NULL</b>.
///    pcchClass = On input, specifies the size of the <i>pwszClass</i> buffer, in characters. On output, receives the required size
///                of the buffer, in characters. The size includes the terminating null character.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td width="60%"> The <i>pwszClass</i> buffer is too small to
///    receive the task name. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFGetWorkQueueMMCSSClass(uint dwWorkQueueId, PWSTR pwszClass, uint* pcchClass);

///Retrieves the Multimedia Class Scheduler Service (MMCSS) task identifier currently associated with this work queue.
///Params:
///    dwWorkQueueId = Identifier for the work queue. The identifier is retrieved by the MFAllocateWorkQueue function.
///    pdwTaskId = Receives the task identifier.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFGetWorkQueueMMCSSTaskId(uint dwWorkQueueId, uint* pdwTaskId);

///Registers the standard Microsoft Media Foundation platform work queues with the Multimedia Class Scheduler Service
///(MMCSS).
///Params:
///    wszClass = The name of the MMCSS task.
///    pdwTaskId = The MMCSS task identifier. On input, specify an existing MCCSS task group ID, or use the value zero to create a
///                new task group. On output, receives the actual task group ID.
///    lPriority = The base priority of the work-queue threads.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFRegisterPlatformWithMMCSS(const(PWSTR) wszClass, uint* pdwTaskId, int lPriority);

///Unregisters the Microsoft Media Foundation platform work queues from a Multimedia Class Scheduler Service (MMCSS)
///task.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFUnregisterPlatformFromMMCSS();

///Obtains and locks a shared work queue.
///Params:
///    wszClass = The name of the MMCSS task.
///    BasePriority = The base priority of the work-queue threads. If the regular-priority queue is being used (<i>wszClass</i>=""),
///                   then the value 0 must be passed in.
///    pdwTaskId = The MMCSS task identifier. On input, specify an existing MCCSS task group ID , or use the value zero to create a
///                new task group. If the regular priority queue is being used (<i>wszClass</i>=""), then <b>NULL</b> must be passed
///                in. On output, receives the actual task group ID.
///    pID = Receives an identifier for the new work queue. Use this identifier when queuing work items.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFLockSharedWorkQueue(const(PWSTR) wszClass, int BasePriority, uint* pdwTaskId, uint* pID);

///Gets the relative thread priority of a work queue.
///Params:
///    dwWorkQueueId = The identifier of the work queue. For private work queues, the identifier is returned by the MFAllocateWorkQueue
///                    function. For platform work queues, see Work Queue Identifiers.
///    lPriority = Receives the relative thread priority.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFGetWorkQueueMMCSSPriority(uint dwWorkQueueId, int* lPriority);

///Creates an asynchronous result object. Use this function if you are implementing an asynchronous method.
///Params:
///    punkObject = Pointer to the object stored in the asynchronous result. This pointer is returned by the
///                 IMFAsyncResult::GetObject method. This parameter can be <b>NULL</b>.
///    pCallback = Pointer to the IMFAsyncCallback interface. This interface is implemented by the caller of the asynchronous
///                method.
///    punkState = Pointer to the <b>IUnknown</b> interface of a state object. This value is provided by the caller of the
///                asynchronous method. This parameter can be <b>NULL</b>.
///    ppAsyncResult = Receives a pointer to the IMFAsyncResult interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCreateAsyncResult(IUnknown punkObject, IMFAsyncCallback pCallback, IUnknown punkState, 
                            IMFAsyncResult* ppAsyncResult);

///Invokes a callback method to complete an asynchronous operation.
///Params:
///    pAsyncResult = Pointer to the IMFAsyncResult interface. To create this object, call MFCreateAsyncResult.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b><b>MF_E_INVALID_WORKQUEUE</b></b></dt> </dl> </td> <td width="60%"> Invalid work queue.
///    For more information, see IMFAsyncCallback::GetParameters. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b><b>MF_E_SHUTDOWN</b></b></dt> </dl> </td> <td width="60%"> The MFShutdown function was called to shut down
///    the Media Foundation platform. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFInvokeCallback(IMFAsyncResult pAsyncResult);

///Creates a byte stream from a file.
///Params:
///    AccessMode = The requested access mode, specified as a member of the MF_FILE_ACCESSMODE enumeration.
///    OpenMode = The behavior of the function if the file already exists or does not exist, specified as a member of the
///               MF_FILE_OPENMODE enumeration.
///    fFlags = Bitwise <b>OR</b> of values from the MF_FILE_FLAGS enumeration.
///    pwszFileURL = Pointer to a null-terminated string that contains the file name.
///    ppIByteStream = Receives a pointer to the IMFByteStream interface of the byte stream. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateFile(MF_FILE_ACCESSMODE AccessMode, MF_FILE_OPENMODE OpenMode, MF_FILE_FLAGS fFlags, 
                     const(PWSTR) pwszFileURL, IMFByteStream* ppIByteStream);

///Creates a byte stream that is backed by a temporary local file.
///Params:
///    AccessMode = The requested access mode, specified as a member of the MF_FILE_ACCESSMODE enumeration.
///    OpenMode = The behavior of the function if the file already exists or does not exist, specified as a member of the
///               MF_FILE_OPENMODE enumeration.
///    fFlags = Bitwise <b>OR</b> of values from the MF_FILE_FLAGS enumeration.
///    ppIByteStream = Receives a pointer to the IMFByteStream interface of the byte stream. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateTempFile(MF_FILE_ACCESSMODE AccessMode, MF_FILE_OPENMODE OpenMode, MF_FILE_FLAGS fFlags, 
                         IMFByteStream* ppIByteStream);

///Begins an asynchronous request to create a byte stream from a file.
///Params:
///    AccessMode = The requested access mode, specified as a member of the MF_FILE_ACCESSMODE enumeration.
///    OpenMode = The behavior of the function if the file already exists or does not exist, specified as a member of the
///               MF_FILE_OPENMODE enumeration.
///    fFlags = Bitwise <b>OR</b> of values from the MF_FILE_FLAGS enumeration.
///    pwszFilePath = Pointer to a null-terminated string containing the file name.
///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface
///    pState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
///             <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
///             callback is invoked.
///    ppCancelCookie = Receives an <b>IUnknown</b> pointer or the value <b>NULL</b>. If the value is not <b>NULL</b>, you can cancel the
///                     asynchronous operation by passing this pointer to the MFCancelCreateFile function. The caller must release the
///                     interface. This parameter is optional and can be <b>NULL</b>.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFBeginCreateFile(MF_FILE_ACCESSMODE AccessMode, MF_FILE_OPENMODE OpenMode, MF_FILE_FLAGS fFlags, 
                          const(PWSTR) pwszFilePath, IMFAsyncCallback pCallback, IUnknown pState, 
                          IUnknown* ppCancelCookie);

///Completes an asynchronous request to create a byte stream from a file.
///Params:
///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
///              Invoke method.
///    ppFile = Receives a pointer to the IMFByteStream interface of the byte stream. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFEndCreateFile(IMFAsyncResult pResult, IMFByteStream* ppFile);

///Cancels an asynchronous request to create a byte stream from a file.
///Params:
///    pCancelCookie = A pointer to the <b>IUnknown</b> interface of the cancellation object. This pointer is received in the
///                    <i>ppCancelCookie</i> parameter of the MFBeginCreateFile function.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCancelCreateFile(IUnknown pCancelCookie);

///Allocates system memory and creates a media buffer to manage it.
///Params:
///    cbMaxLength = Size of the buffer, in bytes.
///    ppBuffer = Receives a pointer to the IMFMediaBuffer interface of the media buffer. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCreateMemoryBuffer(uint cbMaxLength, IMFMediaBuffer* ppBuffer);

///Creates a media buffer that wraps an existing media buffer. The new media buffer points to the same memory as the
///original media buffer, or to an offset from the start of the memory.
///Params:
///    pBuffer = A pointer to the IMFMediaBuffer interface of the original media buffer.
///    cbOffset = The start of the new buffer, as an offset in bytes from the start of the original buffer.
///    dwLength = The size of the new buffer. The value of <i>cbOffset</i> + <i>dwLength</i> must be less than or equal to the size
///               of valid data the original buffer. (The size of the valid data is returned by the
///               IMFMediaBuffer::GetCurrentLength method.)
///    ppBuffer = Receives a pointer to the IMFMediaBuffer interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The requested offset or the requested length is not
///    valid. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCreateMediaBufferWrapper(IMFMediaBuffer pBuffer, uint cbOffset, uint dwLength, IMFMediaBuffer* ppBuffer);

///Converts a Media Foundation media buffer into a buffer that is compatible with DirectX Media Objects (DMOs).
///Params:
///    pSample = Pointer to the IMFSample interface of the sample that contains the Media Foundation buffer. This parameter can be
///              <b>NULL</b>.
///    pMFMediaBuffer = Pointer to the IMFMediaBuffer interface of the Media Foundation buffer.
///    cbOffset = Offset in bytes from the start of the Media Foundation buffer. This offset defines where the DMO buffer starts.
///               If this parameter is zero, the DMO buffer starts at the beginning of the Media Foundation buffer.
///    ppMediaBuffer = Receives a pointer to the <b>IMediaBuffer</b> interface. This interface is documented in the DirectShow SDK
///                    documentation. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. The <i>pIMFMediaBuffer</i> parameter
///    must not be <b>NULL</b>. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCreateLegacyMediaBufferOnMFMediaBuffer(IMFSample pSample, IMFMediaBuffer pMFMediaBuffer, uint cbOffset, 
                                                 IMediaBuffer* ppMediaBuffer);

///Converts a Microsoft Direct3D 9 format identifier to a Microsoft DirectX Graphics Infrastructure (DXGI) format
///identifier.
///Params:
///    dx9 = The D3DFORMAT value or FOURCC code to convert.
///Returns:
///    Returns a DXGI_FORMAT value.
///    
@DllImport("MFPlat")
DXGI_FORMAT MFMapDX9FormatToDXGIFormat(uint dx9);

///Converts a Microsoft DirectX Graphics Infrastructure (DXGI) format identifier to a Microsoft Direct3D 9 format
///identifier.
///Params:
///    dx11 = The DXGI_FORMAT value to convert.
///Returns:
///    Returns a D3DFORMAT value or FOURCC code.
///    
@DllImport("MFPlat")
uint MFMapDXGIFormatToDX9Format(DXGI_FORMAT dx11);

///Locks the shared Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager.
///Params:
///    pResetToken = Receives a token that identifies this instance of the DXGI Device Manager. Use this token when calling
///                  IMFDXGIDeviceManager::ResetDevice. This parameter can be <b>NULL</b>.
///    ppManager = Receives a pointer to the IMFDXGIDeviceManager interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFLockDXGIDeviceManager(uint* pResetToken, IMFDXGIDeviceManager* ppManager);

///Unlocks the shared Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFUnlockDXGIDeviceManager();

///Creates a media buffer object that manages a Direct3D 9 surface.
///Params:
///    riid = Identifies the type of Direct3D 9 surface. Currently this value must be <b>IID_IDirect3DSurface9</b>.
///    punkSurface = A pointer to the IUnknown interface of the DirectX surface.
///    fBottomUpWhenLinear = If <b>TRUE</b>, the buffer's IMF2DBuffer::ContiguousCopyTo method copies the buffer into a bottom-up format. The
///                          bottom-up format is compatible with GDI for uncompressed RGB images. If this parameter is <b>FALSE</b>, the
///                          <b>ContiguousCopyTo</b> method copies the buffer into a top-down format, which is compatible with DirectX. For
///                          more information about top-down versus bottom-up images, see Image Stride.
///    ppBuffer = Receives a pointer to the IMFMediaBuffer interface. The caller must release the buffer.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCreateDXSurfaceBuffer(const(GUID)* riid, IUnknown punkSurface, BOOL fBottomUpWhenLinear, 
                                IMFMediaBuffer* ppBuffer);

///Creates a media buffer object that manages a Windows Imaging Component (WIC) bitmap.
///Params:
///    riid = Set this parameter to <code>__uuidof(IWICBitmap)</code>.
///    punkSurface = A pointer to the IUnknown interface of the bitmap surface. The bitmap surface must be a WIC bitmap that exposes
///                  the IWICBitmap interface.
///    ppBuffer = Receives a pointer to the IMFMediaBuffer interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateWICBitmapBuffer(const(GUID)* riid, IUnknown punkSurface, IMFMediaBuffer* ppBuffer);

///Creates a media buffer to manage a Microsoft DirectX Graphics Infrastructure (DXGI) surface.
///Params:
///    riid = Identifies the type of DXGI surface. This value must be <b>IID_ID3D11Texture2D</b>.
///    punkSurface = A pointer to the IUnknown interface of the DXGI surface.
///    uSubresourceIndex = The zero-based index of a subresource of the surface. The media buffer object is associated with this
///                        subresource.
///    fBottomUpWhenLinear = If <b>TRUE</b>, the buffer's IMF2DBuffer::ContiguousCopyTo method copies the buffer into a bottom-up format. The
///                          bottom-up format is compatible with GDI for uncompressed RGB images. If this parameter is <b>FALSE</b>, the
///                          <b>ContiguousCopyTo</b> method copies the buffer into a top-down format, which is compatible with Direct3D. For
///                          more information about top-down versus bottom-up images, see Image Stride.
///    ppBuffer = Receives a pointer to the IMFMediaBuffer interface. The caller must release the buffer.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateDXGISurfaceBuffer(const(GUID)* riid, IUnknown punkSurface, uint uSubresourceIndex, 
                                  BOOL fBottomUpWhenLinear, IMFMediaBuffer* ppBuffer);

///Creates an object that allocates video samples that are compatible with Microsoft DirectX Graphics Infrastructure
///(DXGI).
///Params:
///    riid = The identifier of the interface to retrieve. Specify one of the following values. <table> <tr> <th>Value</th>
///           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="IID_IUnknown"></a><a id="iid_iunknown"></a><a
///           id="IID_IUNKNOWN"></a><dl> <dt><b><b>IID_IUnknown</b></b></dt> </dl> </td> <td width="60%"> Retrieve an IUnknown
///           pointer. </td> </tr> <tr> <td width="40%"><a id="IID_IMFVideoSampleAllocator"></a><a
///           id="iid_imfvideosampleallocator"></a><a id="IID_IMFVIDEOSAMPLEALLOCATOR"></a><dl>
///           <dt><b><b>IID_IMFVideoSampleAllocator</b></b></dt> </dl> </td> <td width="60%"> Retrieve an
///           IMFVideoSampleAllocator pointer. </td> </tr> <tr> <td width="40%"><a id="IID_IMFVideoSampleAllocatorEx"></a><a
///           id="iid_imfvideosampleallocatorex"></a><a id="IID_IMFVIDEOSAMPLEALLOCATOREX"></a><dl>
///           <dt><b><b>IID_IMFVideoSampleAllocatorEx</b></b></dt> </dl> </td> <td width="60%"> Retrieve an
///           IMFVideoSampleAllocatorEx pointer. </td> </tr> <tr> <td width="40%"><a
///           id="IID_IMFVideoSampleAllocatorCallback"></a><a id="iid_imfvideosampleallocatorcallback"></a><a
///           id="IID_IMFVIDEOSAMPLEALLOCATORCALLBACK"></a><dl> <dt><b><b>IID_IMFVideoSampleAllocatorCallback</b></b></dt>
///           </dl> </td> <td width="60%"> Retrieve an IMFVideoSampleAllocatorCallback pointer. </td> </tr> </table>
///    ppSampleAllocator = Receives a pointer to the requested interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateVideoSampleAllocatorEx(const(GUID)* riid, void** ppSampleAllocator);

///Creates an instance of the Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager.
///Params:
///    resetToken = Receives a token that identifies this instance of the DXGI Device Manager. Use this token when calling
///                 IMFDXGIDeviceManager::ResetDevice.
///    ppDeviceManager = Receives a pointer to the IMFDXGIDeviceManager interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateDXGIDeviceManager(uint* resetToken, IMFDXGIDeviceManager* ppDeviceManager);

///Allocates system memory with a specified byte alignment and creates a media buffer to manage the memory.
///Params:
///    cbMaxLength = Size of the buffer, in bytes.
///    cbAligment = Specifies the memory alignment for the buffer. Use one of the following constants. <table> <tr> <th>Value</th>
///                 <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MF_1_BYTE_ALIGNMENT"></a><a id="mf_1_byte_alignment"></a><dl>
///                 <dt><b>MF_1_BYTE_ALIGNMENT</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> Align to 1 bytes. </td>
///                 </tr> <tr> <td width="40%"><a id="MF_2_BYTE_ALIGNMENT"></a><a id="mf_2_byte_alignment"></a><dl>
///                 <dt><b>MF_2_BYTE_ALIGNMENT</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Align to 2 bytes. </td>
///                 </tr> <tr> <td width="40%"><a id="MF_4_BYTE_ALIGNMENT"></a><a id="mf_4_byte_alignment"></a><dl>
///                 <dt><b>MF_4_BYTE_ALIGNMENT</b></dt> <dt>0x00000003</dt> </dl> </td> <td width="60%"> Align to 4 bytes. </td>
///                 </tr> <tr> <td width="40%"><a id="MF_8_BYTE_ALIGNMENT"></a><a id="mf_8_byte_alignment"></a><dl>
///                 <dt><b>MF_8_BYTE_ALIGNMENT</b></dt> <dt>0x00000007</dt> </dl> </td> <td width="60%"> Align to 8 bytes. </td>
///                 </tr> <tr> <td width="40%"><a id="MF_16_BYTE_ALIGNMENT"></a><a id="mf_16_byte_alignment"></a><dl>
///                 <dt><b>MF_16_BYTE_ALIGNMENT</b></dt> <dt>0x0000000F</dt> </dl> </td> <td width="60%"> Align to 16 bytes. </td>
///                 </tr> <tr> <td width="40%"><a id="MF_32_BYTE_ALIGNMENT"></a><a id="mf_32_byte_alignment"></a><dl>
///                 <dt><b>MF_32_BYTE_ALIGNMENT</b></dt> <dt>0x0000001F</dt> </dl> </td> <td width="60%"> Align to 32 bytes. </td>
///                 </tr> <tr> <td width="40%"><a id="MF_64_BYTE_ALIGNMENT"></a><a id="mf_64_byte_alignment"></a><dl>
///                 <dt><b>MF_64_BYTE_ALIGNMENT</b></dt> <dt>0x0000003F</dt> </dl> </td> <td width="60%"> Align to 64 bytes. </td>
///                 </tr> <tr> <td width="40%"><a id="MF_128_BYTE_ALIGNMENT"></a><a id="mf_128_byte_alignment"></a><dl>
///                 <dt><b>MF_128_BYTE_ALIGNMENT</b></dt> <dt>0x0000007F</dt> </dl> </td> <td width="60%"> Align to 128 bytes. </td>
///                 </tr> <tr> <td width="40%"><a id="MF_256_BYTE_ALIGNMENT"></a><a id="mf_256_byte_alignment"></a><dl>
///                 <dt><b>MF_256_BYTE_ALIGNMENT</b></dt> <dt>0x000000FF</dt> </dl> </td> <td width="60%"> Align to 256 bytes. </td>
///                 </tr> <tr> <td width="40%"><a id="MF_512_BYTE_ALIGNMENT"></a><a id="mf_512_byte_alignment"></a><dl>
///                 <dt><b>MF_512_BYTE_ALIGNMENT</b></dt> <dt>0x000001FF</dt> </dl> </td> <td width="60%"> Align to 512 bytes. </td>
///                 </tr> </table>
///    ppBuffer = Receives a pointer to the IMFMediaBuffer interface of the media buffer. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCreateAlignedMemoryBuffer(uint cbMaxLength, uint cbAligment, IMFMediaBuffer* ppBuffer);

///Creates a media event object.
///Params:
///    met = The event type. See IMFMediaEvent::GetType. For a list of event types, see Media Foundation Events.
///    guidExtendedType = The extended type. See IMFMediaEvent::GetExtendedType. If the event type does not have an extended type, use the
///                       value GUID_NULL.
///    hrStatus = The event status. See IMFMediaEvent::GetStatus
///    pvValue = The value associated with the event, if any. See IMFMediaEvent::GetValue. This parameter can be <b>NULL</b>.
///    ppEvent = Receives a pointer to the IMFMediaEvent interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCreateMediaEvent(uint met, const(GUID)* guidExtendedType, HRESULT hrStatus, const(PROPVARIANT)* pvValue, 
                           IMFMediaEvent* ppEvent);

///Creates an event queue.
///Params:
///    ppMediaEventQueue = Receives a pointer to the IMFMediaEventQueue interface of the event queue. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCreateEventQueue(IMFMediaEventQueue* ppMediaEventQueue);

///Creates an empty media sample.
///Params:
///    ppIMFSample = Receives a pointer to the IMFSample interface of the media sample. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCreateSample(IMFSample* ppIMFSample);

///Creates an empty attribute store.
///Params:
///    ppMFAttributes = Receives a pointer to the IMFAttributes interface. The caller must release the interface.
///    cInitialSize = The initial number of elements allocated for the attribute store. The attribute store grows as needed.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateAttributes(IMFAttributes* ppMFAttributes, uint cInitialSize);

///Initializes the contents of an attribute store from a byte array.
///Params:
///    pAttributes = Pointer to the IMFAttributes interface of the attribute store.
///    pBuf = Pointer to the array that contains the initialization data.
///    cbBufSize = Size of the <i>pBuf</i> array, in bytes.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The buffer is not valid. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFInitAttributesFromBlob(IMFAttributes pAttributes, const(ubyte)* pBuf, uint cbBufSize);

///Retrieves the size of the buffer needed for the MFGetAttributesAsBlob function.
///Params:
///    pAttributes = Pointer to the IMFAttributes interface of the attribute store.
///    pcbBufSize = Receives the required size of the array, in bytes.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFGetAttributesAsBlobSize(IMFAttributes pAttributes, uint* pcbBufSize);

///Converts the contents of an attribute store to a byte array.
///Params:
///    pAttributes = Pointer to the IMFAttributes interface of the attribute store.
///    pBuf = Pointer to an array that receives the attribute data.
///    cbBufSize = Size of the <i>pBuf</i> array, in bytes. To get the required size of the buffer, call MFGetAttributesAsBlobSize.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td width="60%"> The buffer given in <i>pBuf</i> is too small.
///    </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFGetAttributesAsBlob(IMFAttributes pAttributes, ubyte* pBuf, uint cbBufSize);

///Adds information about a Media Foundation transform (MFT) to the registry. Applications can enumerate the MFT by
///calling the MFTEnum or MFTEnumEx function.
///Params:
///    clsidMFT = The CLSID of the MFT. The MFT must also be registered as a COM object using the same CLSID.
///    guidCategory = GUID that specifies the category of the MFT. For a list of MFT categories, see MFT_CATEGORY.
///    pszName = Wide-character string that contains the friendly name of the MFT.
///    Flags = Bitwise <b>OR</b> of zero or more of the following flags from the _MFT_ENUM_FLAG enumeration: <table> <tr>
///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MFT_ENUM_FLAG_ASYNCMFT"></a><a
///            id="mft_enum_flag_asyncmft"></a><dl> <dt><b>MFT_ENUM_FLAG_ASYNCMFT</b></dt> </dl> </td> <td width="60%"> The MFT
///            performs asynchronous processing in software. See Asynchronous MFTs. This flag does not apply to hardware
///            transforms. Requires Windows 7. </td> </tr> <tr> <td width="40%"><a id="MFT_ENUM_FLAG_FIELDOFUSE"></a><a
///            id="mft_enum_flag_fieldofuse"></a><dl> <dt><b>MFT_ENUM_FLAG_FIELDOFUSE</b></dt> </dl> </td> <td width="60%"> The
///            application must unlock the MFT in order to use it. See IMFFieldOfUseMFTUnlock. Requires Windows 7. </td> </tr>
///            <tr> <td width="40%"><a id="MFT_ENUM_FLAG_HARDWARE"></a><a id="mft_enum_flag_hardware"></a><dl>
///            <dt><b>MFT_ENUM_FLAG_HARDWARE</b></dt> </dl> </td> <td width="60%"> The MFT performs hardware-based data
///            processing, using either the AVStream driver or a GPU-based proxy MFT. MFTs in this category always process data
///            asynchronously. See Hardware MFTs. <div class="alert"><b>Note</b> This flag applies to video codecs and video
///            processors that perform their work entirely in hardware. It does not apply to software decoders that use DirectX
///            Video Acceleration to assist decoding.</div> <div> </div> Requires Windows 7. </td> </tr> <tr> <td width="40%"><a
///            id="MFT_ENUM_FLAG_SYNCMFT"></a><a id="mft_enum_flag_syncmft"></a><dl> <dt><b>MFT_ENUM_FLAG_SYNCMFT</b></dt> </dl>
///            </td> <td width="60%"> The MFT performs synchronous processing in software. This flag does not apply to hardware
///            transforms. </td> </tr> <tr> <td width="40%"><a id="MFT_ENUM_FLAG_TRANSCODE_ONLY"></a><a
///            id="mft_enum_flag_transcode_only"></a><dl> <dt><b>MFT_ENUM_FLAG_TRANSCODE_ONLY</b></dt> </dl> </td> <td
///            width="60%"> The MFT is optimized for transcoding and should not be used for playback. Requires Windows 7. </td>
///            </tr> </table> Setting <i>Flags</i> to zero is equivalent to setting the <b>MFT_ENUM_FLAG_SYNCMFT</b> flag. The
///            default processing model for MFTs is synchronous processing. Prior to Windows 7, the <i>Flags</i> parameter was
///            reserved.
///    cInputTypes = Number of elements in the <i>pInputTypes</i> array.
///    pInputTypes = Pointer to an array of MFT_REGISTER_TYPE_INFO structures. Each member of the array specifies an input format that
///                  the MFT supports. This parameter can be <b>NULL</b>. This parameter can be <b>NULL</b>. However, if the parameter
///                  is <b>NULL</b>, the MFT will be enumerated only when an application specifies <b>NULL</b> for the desired input
///                  type.
///    cOutputTypes = Number of elements in the <i>pOutputTypes</i> array.
///    pOutputTypes = Pointer to an array of MFT_REGISTER_TYPE_INFO structures. Each member of the array defines an output format that
///                   the MFT supports. This parameter can be <b>NULL</b>. However, if the parameter is <b>NULL</b>, the MFT will be
///                   enumerated only when an application specifies <b>NULL</b> for the desired output type.
///    pAttributes = Pointer to the IMFAttributes interface of an attribute store that contains additional registry information. This
///                  parameter can be <b>NULL</b>. If the parameter is non-<b>NULL</b>, the attributes are written to the registery as
///                  a byte array. You can use the MFTGetInfo function to retrieve the attributes. The following attribute is defined
///                  for this parameter: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="MFT_CODEC_MERIT_Attribute"></a><a id="mft_codec_merit_attribute"></a><a
///                  id="MFT_CODEC_MERIT_ATTRIBUTE"></a><dl> <dt><b>MFT_CODEC_MERIT_Attribute</b></dt> </dl> </td> <td width="60%">
///                  Contains the merit value of a hardware codec. See Codec Merit. </td> </tr> </table>
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFTRegister(GUID clsidMFT, GUID guidCategory, PWSTR pszName, uint Flags, uint cInputTypes, 
                    MFT_REGISTER_TYPE_INFO* pInputTypes, uint cOutputTypes, MFT_REGISTER_TYPE_INFO* pOutputTypes, 
                    IMFAttributes pAttributes);

///Unregisters a Media Foundation transform (MFT).
///Params:
///    clsidMFT = The CLSID of the MFT.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFTUnregister(GUID clsidMFT);

///Registers a Media Foundation transform (MFT) in the caller's process.
///Params:
///    pClassFactory = A pointer to the <b>IClassFactory</b> interface of a class factory object. The class factory creates the MFT.
///    guidCategory = A GUID that specifies the category of the MFT. For a list of MFT categories, see MFT_CATEGORY.
///    pszName = A wide-character null-terminated string that contains the friendly name of the MFT.
///    Flags = A bitwise <b>OR</b> of zero or more flags from the _MFT_ENUM_FLAG enumeration.
///    cInputTypes = The number of elements in the <i>pInputTypes</i> array.
///    pInputTypes = A pointer to an array of MFT_REGISTER_TYPE_INFO structures. Each member of the array specifies an input format
///                  that the MFT supports. This parameter can be <b>NULL</b> if <i>cInputTypes</i> is zero.
///    cOutputTypes = The number of elements in the <i>pOutputTypes</i> array.
///    pOutputTypes = A pointer to an array of MFT_REGISTER_TYPE_INFO structures. Each member of the array defines an output format
///                   that the MFT supports. This parameter can be <b>NULL</b> if <i>cOutputTypes</i> is zero.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFTRegisterLocal(IClassFactory pClassFactory, const(GUID)* guidCategory, const(PWSTR) pszName, uint Flags, 
                         uint cInputTypes, const(MFT_REGISTER_TYPE_INFO)* pInputTypes, uint cOutputTypes, 
                         const(MFT_REGISTER_TYPE_INFO)* pOutputTypes);

///Unregisters one or more Media Foundation transforms (MFTs) from the caller's process.
///Params:
///    pClassFactory = A pointer to the <b>IClassFactory</b> interface of a class factory object. This parameter can be <b>NULL</b>.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>HRESULT_FROM_WIN32(<b>ERROR_NOT_FOUND</b>)</b></dt> </dl> </td> <td width="60%"> The MFT specified by
///    the <i>pClassFactory</i> parameter was not registered in this process. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFTUnregisterLocal(IClassFactory pClassFactory);

///Registers a Media Foundation transform (MFT) in the caller's process.
///Params:
///    clisdMFT = The class identifier (CLSID) of the MFT.
///    guidCategory = A GUID that specifies the category of the MFT. For a list of MFT categories, see MFT_CATEGORY.
///    pszName = A wide-character null-terminated string that contains the friendly name of the MFT.
///    Flags = A bitwise <b>OR</b> of zero or more flags from the _MFT_ENUM_FLAG enumeration.
///    cInputTypes = The number of elements in the <i>pInputTypes</i> array.
///    pInputTypes = A pointer to an array of MFT_REGISTER_TYPE_INFO structures. Each member of the array specifies an input format
///                  that the MFT supports. This parameter can be <b>NULL</b> if <i>cInputTypes</i> is zero.
///    cOutputTypes = The number of elements in the <i>pOutputTypes</i> array.
///    pOutputTypes = A pointer to an array of MFT_REGISTER_TYPE_INFO structures. Each member of the array defines an output format
///                   that the MFT supports. This parameter can be <b>NULL</b> if <i>cOutputTypes</i> is zero.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFTRegisterLocalByCLSID(const(GUID)* clisdMFT, const(GUID)* guidCategory, const(PWSTR) pszName, uint Flags, 
                                uint cInputTypes, const(MFT_REGISTER_TYPE_INFO)* pInputTypes, uint cOutputTypes, 
                                const(MFT_REGISTER_TYPE_INFO)* pOutputTypes);

///Unregisters a Media Foundation transform (MFT) from the caller's process.
///Params:
///    clsidMFT = The class identifier (CLSID) of the MFT.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>HRESULT_FROM_WIN32(<b>ERROR_NOT_FOUND</b>)</b></dt> </dl> </td> <td width="60%"> The MFT specified by
///    the <i>clsidMFT</i> parameter was not registered in this process. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFTUnregisterLocalByCLSID(GUID clsidMFT);

///Enumerates Media Foundation transforms (MFTs) in the registry. Starting in Windows 7, applications should use the
///MFTEnumEx function instead.
///Params:
///    guidCategory = GUID that specifies the category of MFTs to enumerate. For a list of MFT categories, see MFT_CATEGORY.
///    Flags = Reserved. Must be zero.
///    pInputType = Pointer to an MFT_REGISTER_TYPE_INFO structure that specifies an input media type to match. This parameter can be
///                 <b>NULL</b>. If <b>NULL</b>, all input types are matched.
///    pOutputType = Pointer to an MFT_REGISTER_TYPE_INFO structure that specifies an output media type to match. This parameter can
///                  be <b>NULL</b>. If <b>NULL</b>, all output types are matched.
///    pAttributes = Reserved. Set to <b>NULL</b>. <div class="alert"><b>Note</b> Windows Vista and Windows Server 2008: This
///                  parameter can specify a pointer to the IMFAttributes interface of an attribute store. The <b>MFTEnum</b> function
///                  matches the attributes in this object against the attributes stored in the registry. (Registry attributes are
///                  specified in the <i>pAttributes</i> parameter of the MFTRegister function.) Only MFTs with matching attributes
///                  are returned in the enumeration results.</div> <div> </div> <div class="alert"><b>Note</b> Windows 7 and later:
///                  This parameter is ignored.</div> <div> </div>
///    ppclsidMFT = Receives a pointer to an array of CLSIDs. To create an MFT from this list, call <b>CoCreateInstance</b> with one
///                 of the CLSIDs. To get information about a particular MFT from its CLSID, call MFTGetInfo. The caller must free
///                 the memory for the array by calling CoTaskMemFree.
///    pcMFTs = Receives the number of elements in the <i>ppclsidMFT</i> array. The value can be zero.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFTEnum(GUID guidCategory, uint Flags, MFT_REGISTER_TYPE_INFO* pInputType, 
                MFT_REGISTER_TYPE_INFO* pOutputType, IMFAttributes pAttributes, GUID** ppclsidMFT, uint* pcMFTs);

///Gets a list of Microsoft Media Foundation transforms (MFTs) that match specified search criteria. This function
///extends the MFTEnum function.
///Params:
///    guidCategory = A GUID that specifies the category of MFTs to enumerate. For a list of MFT categories, see MFT_CATEGORY.
///    Flags = The bitwise <b>OR</b> of zero or more flags from the _MFT_ENUM_FLAG enumeration.
///    pInputType = A pointer to an MFT_REGISTER_TYPE_INFO structure that specifies an input media type to match. This parameter can
///                 be <b>NULL</b>. If <b>NULL</b>, all input types are matched.
///    pOutputType = A pointer to an MFT_REGISTER_TYPE_INFO structure that specifies an output media type to match. This parameter can
///                  be <b>NULL</b>. If <b>NULL</b>, all output types are matched.
///    pppMFTActivate = Receives an array of IMFActivate interface pointers. Each pointer represents an activation object for an MFT that
///                     matches the search criteria. The function allocates the memory for the array. The caller must release the
///                     pointers and call the CoTaskMemFree function to free the memory for the array.
///    pnumMFTActivate = Receives the number of elements in the <i>pppMFTActivate</i> array. If no MFTs match the search criteria, this
///                      parameter receives the value zero.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFTEnumEx(GUID guidCategory, uint Flags, const(MFT_REGISTER_TYPE_INFO)* pInputType, 
                  const(MFT_REGISTER_TYPE_INFO)* pOutputType, IMFActivate** pppMFTActivate, uint* pnumMFTActivate);

///Gets a list of Microsoft Media Foundation transforms (MFTs) that match specified search criteria. This function
///extends the MFTEnumEx function to allow external applications and internal components to discover the hardware MFTs
///that correspond to a specific video adapter.
///Params:
///    guidCategory = A GUID that specifies the category of MFTs to enumerate. For a list of MFT categories, see MFT_CATEGORY.
///    Flags = The bitwise <b>OR</b> of zero or more flags from the _MFT_ENUM_FLAG enumeration.
///    pInputType = A pointer to an MFT_REGISTER_TYPE_INFO structure that specifies an input media type to match. This parameter can
///                 be <b>NULL</b>. If <b>NULL</b>, all input types are matched.
///    pOutputType = A pointer to an MFT_REGISTER_TYPE_INFO structure that specifies an output media type to match. This parameter can
///                  be <b>NULL</b>. If <b>NULL</b>, all output types are matched.
///    pAttributes = A pointer to an IMFAttributes interface that enables access to the standard attribute store. To specify a
///                  specific hardware adapter for which MFTs are queried, set the MFT_ENUM_ADAPTER_LUID attribute to the LUID of the
///                  adapter. If you do this, you must also specify the MFT_ENUM_FLAG_HARDWARE flag or E_INVALIDARG is returned.
///    pppMFTActivate = Receives an array of IMFActivate interface pointers. Each pointer represents an activation object for an MFT that
///                     matches the search criteria. The function allocates the memory for the array. The caller must release the
///                     pointers and call the CoTaskMemFree function to free the memory for the array.
///    pnumMFTActivate = Receives the number of elements in the <i>pppMFTActivate</i> array. If no MFTs match the search criteria, this
///                      parameter receives the value zero.
///Returns:
///    If the method succeeds, it returns S_OK. If it fails, possible return codes include, but are not limited to, the
///    values shown in the following table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> An IMFAttributes containing the
///    MFT_ENUM_ADAPTER_LUID attribute was provided in the <i>pAttributes</i> parameter and the MFT_ENUM_FLAG_HARDWARE
///    flag was not specified. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFTEnum2(GUID guidCategory, uint Flags, const(MFT_REGISTER_TYPE_INFO)* pInputType, 
                 const(MFT_REGISTER_TYPE_INFO)* pOutputType, IMFAttributes pAttributes, IMFActivate** pppMFTActivate, 
                 uint* pnumMFTActivate);

///Gets information from the registry about a Media Foundation transform (MFT).
///Params:
///    clsidMFT = The CLSID of the MFT.
///    pszName = Receives a pointer to a wide-character string containing the friendly name of the MFT. The caller must free the
///              string by calling CoTaskMemFree. This parameter can be <b>NULL</b>.
///    ppInputTypes = Receives a pointer to an array of MFT_REGISTER_TYPE_INFO structures. Each member of the array describes an input
///                   format that the MFT supports. The caller must free the array by calling CoTaskMemFree. This parameter can be
///                   <b>NULL</b>.
///    pcInputTypes = Receives the number of elements in the <i>ppInputTypes</i> array. If <i>ppInputTypes</i> is <b>NULL</b>, this
///                   parameter is ignored and can be <b>NULL</b>.
///    ppOutputTypes = Receives a pointer to an array of MFT_REGISTER_TYPE_INFO structures. Each member of the array describes an output
///                    format that the MFT supports. The caller must free the array by calling CoTaskMemFree. This parameter can be
///                    <b>NULL</b>.
///    pcOutputTypes = Receives the number of elements in the <i>ppOutputType</i> array. If <i>ppOutputTypes</i> is <b>NULL</b>, this
///                    parameter is ignored and can be <b>NULL</b>.
///    ppAttributes = Receives a pointer to the IMFAttributes interface of an attribute store. The caller must release the interface.
///                   The attribute store might contain attributes that are stored in the registry for the specified MFT. (For more
///                   information, see MFTRegister.) If no attributes are stored in the registry for this MFT, the attribute store is
///                   empty. This parameter can be <b>NULL</b>.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFTGetInfo(GUID clsidMFT, PWSTR* pszName, MFT_REGISTER_TYPE_INFO** ppInputTypes, uint* pcInputTypes, 
                   MFT_REGISTER_TYPE_INFO** ppOutputTypes, uint* pcOutputTypes, IMFAttributes* ppAttributes);

///Gets a pointer to the Microsoft Media Foundation plug-in manager.
///Params:
///    ppPluginControl = Receives a pointer to the IMFPluginControl interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFGetPluginControl(IMFPluginControl* ppPluginControl);

///Gets the merit value of a hardware codec.
///Params:
///    pMFT = A pointer to the <b>IUnknown</b> interface of the Media Foundation transform (MFT) that represents the codec.
///    cbVerifier = The size, in bytes, of the <i>verifier</i> array.
///    verifier = The address of a buffer that contains one of the following: <ul> <li>The class identifier (CLSID) of the
///               MFT.</li> <li>A null-terminated wide-character string that contains the symbol link for the underlying hardware
///               device. Include the size of the terminating null in the value of <i>cbVerifier</i>.</li> </ul>
///    merit = Receives the merit value.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFGetMFTMerit(IUnknown pMFT, uint cbVerifier, const(ubyte)* verifier, uint* merit);

///Registers a scheme handler in the caller's process.
///Params:
///    szScheme = A string that contains the scheme. The scheme includes the trailing ':' character; for example, "http:".
///    pActivate = A pointer to the IMFActivate interface of an activation object. The caller implements this interface. The
///                IMFActivate::ActivateObject method of the activation object must create a scheme handler object. The scheme
///                handler exposes the IMFSchemeHandler interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFRegisterLocalSchemeHandler(const(PWSTR) szScheme, IMFActivate pActivate);

///Registers a byte-stream handler in the caller's process.
///Params:
///    szFileExtension = A string that contains the file name extension for this handler.
///    szMimeType = A string that contains the MIME type for this handler.
///    pActivate = A pointer to the IMFActivate interface of an activation object. The caller implements this interface. The
///                IMFActivate::ActivateObject method of the activation object must create a byte-stream handler. The byte-stream
///                handler exposes the IMFByteStreamHandler interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFRegisterLocalByteStreamHandler(const(PWSTR) szFileExtension, const(PWSTR) szMimeType, 
                                         IMFActivate pActivate);

///Creates a wrapper for a byte stream.
///Params:
///    pStream = A pointer to the IMFByteStream interface of the original byte stream.
///    ppStreamWrapper = Receives a pointer to the IMFByteStream interface of the wrapper. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateMFByteStreamWrapper(IMFByteStream pStream, IMFByteStream* ppStreamWrapper);

///Creates an activation object for a Windows Runtime class.
///Params:
///    szActivatableClassId = The class identifier that is associated with the activatable runtime class.
///    pConfiguration = A pointer to an optional IPropertySet object, which is used to configure the Windows Runtime class. This
///                     parameter can be <b>NULL</b>.
///    riid = The interface identifier (IID) of the interface being requested. The activation object created by this function
///           supports the following interfaces: <ul> <li> IClassFactory </li> <li> IMFActivate </li> <li> IPersistStream </li>
///           </ul>
///    ppvObject = Receives a pointer to the requested interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateMediaExtensionActivate(const(PWSTR) szActivatableClassId, IUnknown pConfiguration, 
                                       const(GUID)* riid, void** ppvObject);

///Creates an IMFAttributes describing the content of multiplexed substreams.
///Params:
///    pAttributesToMux = The collection containing the IMFAttributes for each multiplexed substream.
///    ppMuxAttribs = The IMFAttributes containing the attributes for the multiplexed substreams.
@DllImport("MFPlat")
HRESULT MFCreateMuxStreamAttributes(IMFCollection pAttributesToMux, IMFAttributes* ppMuxAttribs);

///Creates an IMFMediaType describing the media types of multiplexed substreams.
///Params:
///    pMediaTypesToMux = The collection containing the IMFMediaType for each multiplexed substream.
///    ppMuxMediaType = The IMFMediaType containing the media types for the multiplexed substreams.
@DllImport("MFPlat")
HRESULT MFCreateMuxStreamMediaType(IMFCollection pMediaTypesToMux, IMFMediaType* ppMuxMediaType);

///Creates an IMFSample containing the samples of multiplexed substreams.
///Params:
///    pSamplesToMux = The collection containing the IMFSample for each multiplexed substream.
///    ppMuxSample = The IMFSample containing the samples for the multiplexed substreams.
@DllImport("MFPlat")
HRESULT MFCreateMuxStreamSample(IMFCollection pSamplesToMux, IMFSample* ppMuxSample);

///Validates the size of a buffer for a video format block.
///Params:
///    FormatType = GUID that specifies the type of format block. It must be one of the following values: <a id="FORMAT_DvInfo"></a>
///                 <a id="format_dvinfo"></a> <a id="FORMAT_DVINFO"></a>
///    pBlock = Pointer to a buffer that contains the format block.
///    cbSize = Size of the <i>pBlock</i> buffer, in bytes.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The buffer that contains the format block is large enough.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> The
///    buffer that contains the format block is too small, or the format block is not valid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>MF_E_UNSUPPORTED_FORMAT</b></dt> </dl> </td> <td width="60%"> This function does not
///    support the specified format type. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFValidateMediaTypeSize(GUID FormatType, ubyte* pBlock, uint cbSize);

///Creates an empty media type.
///Params:
///    ppMFType = Receives a pointer to the IMFMediaType interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateMediaType(IMFMediaType* ppMFType);

///<p class="CCE_Message">[This API is not supported and may be altered or unavailable in the future. Applications
///should avoid using the MFVIDEOFORMAT structure, and use media type attributes instead. For more information, see
///Video Media Types.] Creates an MFVIDEOFORMAT structure from a video media type.
///Params:
///    pMFType = Pointer to the IMFMediaType interface of a video media type.
///    ppMFVF = Receives a pointer to an MFVIDEOFORMAT structure. The caller must release the memory allocated for the structure
///             by calling CoTaskMemFree.
///    pcbSize = Receives the size of the MFVIDEOFORMAT structure.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateMFVideoFormatFromMFMediaType(IMFMediaType pMFType, MFVIDEOFORMAT** ppMFVF, uint* pcbSize);

///Converts a Media Foundation audio media type to a <b>WAVEFORMATEX</b> structure.
///Params:
///    pMFType = Pointer to the IMFMediaType interface of the media type.
///    ppWF = Receives a pointer to the <b>WAVEFORMATEX</b> structure. The caller must release the memory allocated for the
///           structure by calling CoTaskMemFree.
///    pcbSize = Receives the size of the <b>WAVEFORMATEX</b> structure.
///    Flags = Contains a flag from the MFWaveFormatExConvertFlags enumeration.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCreateWaveFormatExFromMFMediaType(IMFMediaType pMFType, WAVEFORMATEX** ppWF, uint* pcbSize, uint Flags);

///Initializes a media type from a DirectShow <b>VIDEOINFOHEADER</b> structure.
///Params:
///    pMFType = Pointer to the IMFMediaType interface of the media type to initialize. To create the uninitialized media type
///              object, call MFCreateMediaType.
///    pVIH = Pointer to a <b>VIDEOINFOHEADER</b> structure that describes the media type. The caller must fill in the
///           structure members before calling this function.
///    cbBufSize = Size of the <b>VIDEOINFOHEADER</b> structure, in bytes.
///    pSubtype = Pointer to a subtype GUID. This parameter can be <b>NULL</b>. If the subtype GUID is specified, the function uses
///               it to set the media subtype. Otherwise, the function attempts to deduce the subtype from the <b>biCompression</b>
///               field contained in the <b>VIDEOINFOHEADER</b> structure.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFInitMediaTypeFromVideoInfoHeader(IMFMediaType pMFType, const(VIDEOINFOHEADER)* pVIH, uint cbBufSize, 
                                           const(GUID)* pSubtype);

///Initializes a media type from a DirectShow <b>VIDEOINFOHEADER2</b> structure.
///Params:
///    pMFType = Pointer to the IMFMediaType interface of the media type to initialize. To create the uninitialized media type
///              object, call MFCreateMediaType.
///    pVIH2 = Pointer to a <b>VIDEOINFOHEADER2</b> structure that describes the media type. The caller must fill in the
///            structure members before calling this function.
///    cbBufSize = Size of the <b>VIDEOINFOHEADER2</b> structure, in bytes.
///    pSubtype = Pointer to a subtype GUID. This parameter can be <b>NULL</b>. If the subtype GUID is specified, the function uses
///               it to set the media subtype. Otherwise, the function attempts to deduce the subtype from the <b>biCompression</b>
///               field contained in the <b>VIDEOINFOHEADER2</b> structure.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFInitMediaTypeFromVideoInfoHeader2(IMFMediaType pMFType, const(VIDEOINFOHEADER2)* pVIH2, uint cbBufSize, 
                                            const(GUID)* pSubtype);

///Initializes a media type from a DirectShow <b>MPEG1VIDEOINFO</b> structure.
///Params:
///    pMFType = Pointer to the IMFMediaType interface of the media type to initialize. To create the uninitialized media type
///              object, call MFCreateMediaType.
///    pMP1VI = Pointer to a <b>MPEG1VIDEOINFO</b> structure that describes the media type. The caller must fill in the structure
///             members before calling this function.
///    cbBufSize = Size of the <b>MPEG1VIDEOINFO</b> structure, in bytes.
///    pSubtype = Pointer to a subtype GUID. This parameter can be <b>NULL</b>. If the subtype GUID is specified, the function uses
///               it to set the media subtype. Otherwise, the function attempts to deduce the subtype from the <b>biCompression</b>
///               field contained in the <b>MPEG1VIDEOINFO</b> structure.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFInitMediaTypeFromMPEG1VideoInfo(IMFMediaType pMFType, const(MPEG1VIDEOINFO)* pMP1VI, uint cbBufSize, 
                                          const(GUID)* pSubtype);

///Initializes a media type from a DirectShow <b>MPEG2VIDEOINFO</b> structure.
///Params:
///    pMFType = Pointer to the IMFMediaType interface of the media type to initialize. To create the uninitialized media type
///              object, call MFCreateMediaType.
///    pMP2VI = Pointer to a <b>MPEG2VIDEOINFO</b> structure that describes the media type. The caller must fill in the structure
///             members before calling this function.
///    cbBufSize = Size of the <b>MPEG2VIDEOINFO</b> structure, in bytes.
///    pSubtype = Pointer to a subtype GUID. This parameter can be <b>NULL</b>. If the subtype GUID is specified, the function uses
///               it to set the media subtype. Otherwise, the function attempts to deduce the subtype from the <b>biCompression</b>
///               field contained in the <b>MPEG2VIDEOINFO</b> structure.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFInitMediaTypeFromMPEG2VideoInfo(IMFMediaType pMFType, const(MPEG2VIDEOINFO)* pMP2VI, uint cbBufSize, 
                                          const(GUID)* pSubtype);

///Retrieves the image size for a video format. Given a BITMAPINFOHEADER structure, this function calculates the correct
///value of the <b>biSizeImage</b> member.
///Params:
///    pBMIH = Pointer to a <b>BITMAPINFOHEADER</b> structure that describes the format.
///    cbBufSize = Size of the <i>pBMIH</i> buffer, in bytes. The size includes any color masks or palette entries that follow the
///                <b>BITMAPINFOHEADER</b> structure.
///    pcbImageSize = Receives the image size, in bytes.
///    pbKnown = Receives the value <b>TRUE</b> if the function recognizes the video format. Otherwise, receives the value
///              <b>FALSE</b>. This parameter can be <b>NULL</b>.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <b>BITMAPINFOHEADER</b> structure is not valid, or
///    the value of <i>cbBufSize</i> is too small. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCalculateBitmapImageSize(const(BITMAPINFOHEADER)* pBMIH, uint cbBufSize, uint* pcbImageSize, 
                                   BOOL* pbKnown);

///Retrieves the image size, in bytes, for an uncompressed video format.
///Params:
///    guidSubtype = Media subtype for the video format. For a list of subtypes, see Media Type GUIDs.
///    unWidth = Width of the image, in pixels.
///    unHeight = Height of the image, in pixels.
///    pcbImageSize = Receives the size of each frame, in bytes. If the format is compressed or is not recognized, the value is zero.
///Returns:
///    The function returns an HRESULT. Possible values include, but are not limited to, those in the following table.
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
///    </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCalculateImageSize(const(GUID)* guidSubtype, uint unWidth, uint unHeight, uint* pcbImageSize);

///Converts a video frame rate into a frame duration.
///Params:
///    unNumerator = The numerator of the frame rate.
///    unDenominator = The denominator of the frame rate.
///    punAverageTimePerFrame = Receives the average duration of a video frame, in 100-nanosecond units.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFFrameRateToAverageTimePerFrame(uint unNumerator, uint unDenominator, ulong* punAverageTimePerFrame);

///Calculates the frame rate, in frames per second, from the average duration of a video frame.
///Params:
///    unAverageTimePerFrame = The average duration of a video frame, in 100-nanosecond units.
///    punNumerator = Receives the numerator of the frame rate.
///    punDenominator = Receives the denominator of the frame rate.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFAverageTimePerFrameToFrameRate(ulong unAverageTimePerFrame, uint* punNumerator, uint* punDenominator);

///<p class="CCE_Message">[This API is not supported and may be altered or unavailable in the future. Applications
///should avoid using the MFVIDEOFORMAT structure, and use media type attributes instead. For more information, see
///Video Media Types.] Initializes a media type from an MFVIDEOFORMAT structure.
///Params:
///    pMFType = Pointer to the IMFMediaType interface of the media type to initialize. To create the uninitialized media type
///              object, call MFCreateMediaType.
///    pMFVF = Pointer to an MFVIDEOFORMAT structure that describes the media type. The caller must fill in the structure
///            members before calling this function.
///    cbBufSize = Size of the MFVIDEOFORMAT structure, in bytes.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFInitMediaTypeFromMFVideoFormat(IMFMediaType pMFType, const(MFVIDEOFORMAT)* pMFVF, uint cbBufSize);

///Initializes a media type from a <b>WAVEFORMATEX</b> structure.
///Params:
///    pMFType = Pointer to the IMFMediaType interface of the media type to initialize. To create the uninitialized media type
///              object, call MFCreateMediaType.
///    pWaveFormat = Pointer to a <b>WAVEFORMATEX</b> structure that describes the media type. The caller must fill in the structure
///                  members before calling this function.
///    cbBufSize = Size of the <b>WAVEFORMATEX</b> structure, in bytes.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFInitMediaTypeFromWaveFormatEx(IMFMediaType pMFType, const(WAVEFORMATEX)* pWaveFormat, uint cbBufSize);

///Initializes a media type from a DirectShow <b>AM_MEDIA_TYPE</b> structure.
///Params:
///    pMFType = Pointer to the IMFMediaType interface of the media type to initialize. To create the uninitialized media type
///              object, call MFCreateMediaType.
///    pAMType = Pointer to an <b>AM_MEDIA_TYPE</b> structure that describes the media type. The caller must fill in the structure
///              members before calling this function.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFInitMediaTypeFromAMMediaType(IMFMediaType pMFType, const(AM_MEDIA_TYPE)* pAMType);

///Initializes a DirectShow <b>AM_MEDIA_TYPE</b> structure from a Media Foundation media type.
///Params:
///    pMFType = Pointer to the IMFMediaType interface of the media type to convert.
///    guidFormatBlockType = Format type GUID. This value corresponds to the <b>formattype</b> member of the <b>AM_MEDIA_TYPE</b> structure
///                          and specifies the type of format block to allocate. If the value is GUID_NULL, the function attempts to deduce
///                          the correct format block, based on the major type and subtype.
///    pAMType = Pointer to an <b>AM_MEDIA_TYPE</b> structure. The function allocates memory for the format block. The caller must
///              release the format block by calling CoTaskMemFree on the <b>pbFormat</b> member.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MF_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> The media type is not valid. </td> </tr>
///    </table>
///    
@DllImport("MFPlat")
HRESULT MFInitAMMediaTypeFromMFMediaType(IMFMediaType pMFType, GUID guidFormatBlockType, AM_MEDIA_TYPE* pAMType);

///Creates a DirectShow <b>AM_MEDIA_TYPE</b> structure from a Media Foundation media type.
///Params:
///    pMFType = Pointer to the IMFMediaType interface of the media type to convert.
///    guidFormatBlockType = Format type GUID. This value corresponds to the <b>formattype</b> member of the <b>AM_MEDIA_TYPE</b> structure
///                          and specifies the type of format block to allocate. If the value is GUID_NULL, the function attempts to deduce
///                          the correct format block, based on the major type and subtype.
///    ppAMType = Receives a pointer to an <b>AM_MEDIA_TYPE</b> structure. The caller must release the memory allocated for the
///               structure by calling CoTaskMemFree. The function also allocates memory for the format block, which the caller
///               must release by calling <b>CoTaskMemFree</b> on the <b>pbFormat</b> member.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCreateAMMediaTypeFromMFMediaType(IMFMediaType pMFType, GUID guidFormatBlockType, 
                                           AM_MEDIA_TYPE** ppAMType);

///Compares a full media type to a partial media type.
///Params:
///    pMFTypeFull = Pointer to the IMFMediaType interface of the full media type.
///    pMFTypePartial = Pointer to the IMFMediaType interface of the partial media type.
///Returns:
///    If the full media type is compatible with the partial media type, the function returns <b>TRUE</b>. Otherwise,
///    the function returns <b>FALSE</b>.
///    
@DllImport("MFPlat")
BOOL MFCompareFullToPartialMediaType(IMFMediaType pMFTypeFull, IMFMediaType pMFTypePartial);

///Creates a media type that wraps another media type.
///Params:
///    pOrig = A pointer to the IMFMediaType interface of the media type to wrap in a new media type.
///    MajorType = A GUID that specifies the major type for the new media type. For a list of possible values, see Major Media
///                Types.
///    SubType = A GUID that specifies the subtype for the new media type. For possible values, see: <ul> <li> Audio Subtypes
///              </li> <li> Video Subtypes </li> </ul> Applications can define custom subtype GUIDs.
///    ppWrap = Receives a pointer to the IMFMediaType interface of the new media type that wraps the original media type. The
///             caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFWrapMediaType(IMFMediaType pOrig, const(GUID)* MajorType, const(GUID)* SubType, IMFMediaType* ppWrap);

///Retrieves a media type that was wrapped in another media type by the MFWrapMediaType function.
///Params:
///    pWrap = Pointer to the IMFMediaType interface of the media type that was retrieved by MFWrapMediaType.
///    ppOrig = Receives a pointer to the IMFMediaType interface of the original media type. The caller must release the
///             interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFUnwrapMediaType(IMFMediaType pWrap, IMFMediaType* ppOrig);

///<p class="CCE_Message">[This API is not supported and may be altered or unavailable in the future. Applications
///should avoid using the MFVIDEOFORMAT structure, and use media type attributes instead. For more information, see
///Video Media Types.] Creates a video media type from an MFVIDEOFORMAT structure.
///Params:
///    pVideoFormat = Pointer to an MFVIDEOFORMAT structure that describes the video format.
///    ppIVideoMediaType = Receives a pointer to the IMFVideoMediaType interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateVideoMediaType(const(MFVIDEOFORMAT)* pVideoFormat, IMFVideoMediaType* ppIVideoMediaType);

///Creates a partial video media type with a specified subtype.
///Params:
///    pAMSubtype = Pointer to a GUID that specifies the subtype. See Video Subtype GUIDs.
///    ppIVideoMediaType = Receives a pointer to the IMFVideoMediaType interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateVideoMediaTypeFromSubtype(const(GUID)* pAMSubtype, IMFVideoMediaType* ppIVideoMediaType);

///Queries whether a FOURCC code or <b>D3DFORMAT</b> value is a YUV format.
///Params:
///    Format = FOURCC code or <b>D3DFORMAT</b> value.
///Returns:
///    The function returns one of the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>TRUE</b></dt> </dl> </td> <td width="60%"> The value specifies a YUV format.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>FALSE</b></dt> </dl> </td> <td width="60%"> The value does not
///    specify a recognized YUV format. </td> </tr> </table>
///    
@DllImport("EVR")
BOOL MFIsFormatYUV(uint Format);

///This function is not implemented.
///Params:
///    pbmihBitMapInfoHeader = Reserved.
///    dwPixelAspectRatioX = Reserved.
///    dwPixelAspectRatioY = Reserved.
///    InterlaceMode = Reserved.
///    VideoFlags = Reserved.
///    qwFramesPerSecondNumerator = Reserved.
///    qwFramesPerSecondDenominator = Reserved.
///    dwMaxBitRate = Reserved.
///    ppIVideoMediaType = Reserved.
///Returns:
///    Returns <b>E_FAIL</b>.
///    
@DllImport("MFPlat")
HRESULT MFCreateVideoMediaTypeFromBitMapInfoHeader(const(BITMAPINFOHEADER)* pbmihBitMapInfoHeader, 
                                                   uint dwPixelAspectRatioX, uint dwPixelAspectRatioY, 
                                                   MFVideoInterlaceMode InterlaceMode, ulong VideoFlags, 
                                                   ulong qwFramesPerSecondNumerator, 
                                                   ulong qwFramesPerSecondDenominator, uint dwMaxBitRate, 
                                                   IMFVideoMediaType* ppIVideoMediaType);

///Calculates the minimum surface stride for a video format.
///Params:
///    format = FOURCC code or <b>D3DFORMAT</b> value that specifies the video format. If you have a video subtype GUID, you can
///             use the first <b>DWORD</b> of the subtype.
///    dwWidth = Width of the image, in pixels.
///    pStride = Receives the minimum surface stride, in pixels.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFGetStrideForBitmapInfoHeader(uint format, uint dwWidth, int* pStride);

///Retrieves the image size, in bytes, for an uncompressed video format.
///Params:
///    format = FOURCC code or <b>D3DFORMAT</b> value that specifies the video format.
///    dwWidth = Width of the image, in pixels.
///    dwHeight = Height of the image, in pixels.
///    pdwPlaneSize = Receives the size of one frame, in bytes. If the format is compressed or is not recognized, this value is zero.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFGetPlaneSize(uint format, uint dwWidth, uint dwHeight, uint* pdwPlaneSize);

///Creates a video media type from a BITMAPINFOHEADER structure.
///Params:
///    pbmihBitMapInfoHeader = A pointer to the BITMAPINFOHEADER structure to convert.
///    cbBitMapInfoHeader = The size of the BITMAPINFOHEADER structure in bytes, including the size of any palette entries or color masks
///                         that follow the structure.
///    dwPixelAspectRatioX = The X dimension of the pixel aspect ratio.
///    dwPixelAspectRatioY = The Y dimension of the pixel aspect ratio.
///    InterlaceMode = A member of the MFVideoInterlaceMode enumeration, specifying how the video is interlaced.
///    VideoFlags = A bitwise <b>OR</b> of flags from the MFVideoFlags enumeration.
///    dwFramesPerSecondNumerator = The numerator of the frame rate in frames per second.
///    dwFramesPerSecondDenominator = The denominator of the frame rate in frames per second
///    dwMaxBitRate = The approximate data rate of the video stream, in bits per second. If the rate is unknown, set this parameter to
///                   zero.
///    ppIVideoMediaType = Receives a pointer to the IMFVideoMediaType interface. The caller must release the interface.
///Returns:
///    If the function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateVideoMediaTypeFromBitMapInfoHeaderEx(const(BITMAPINFOHEADER)* pbmihBitMapInfoHeader, 
                                                     uint cbBitMapInfoHeader, uint dwPixelAspectRatioX, 
                                                     uint dwPixelAspectRatioY, MFVideoInterlaceMode InterlaceMode, 
                                                     ulong VideoFlags, uint dwFramesPerSecondNumerator, 
                                                     uint dwFramesPerSecondDenominator, uint dwMaxBitRate, 
                                                     IMFVideoMediaType* ppIVideoMediaType);

///Creates a Media Foundation media type from another format representation.
///Params:
///    guidRepresentation = GUID that specifies which format representation to convert. The following value is defined. <table> <tr>
///                         <th>GUID</th> <th>Description</th> </tr> <tr> <td>AM_MEDIA_TYPE_REPRESENTATION</td> <td>Convert a DirectShow
///                         <b>AM_MEDIA_TYPE</b> structure.</td> </tr> </table>
///    pvRepresentation = Pointer to a buffer that contains the format representation to convert. The layout of the buffer depends on the
///                       value of <i>guidRepresentation</i>.
///    ppIMediaType = Receives a pointer to the IMFMediaType interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MF_E_UNSUPPORTED_REPRESENTATION</b></dt> </dl> </td> <td width="60%"> The GUID specified in
///    <i>guidRepresentation</i> is not supported. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCreateMediaTypeFromRepresentation(GUID guidRepresentation, void* pvRepresentation, 
                                            IMFMediaType* ppIMediaType);

///<p class="CCE_Message">[This API is not supported and may be altered or unavailable in the future.] Creates an audio
///media type from a <b>WAVEFORMATEX</b> structure.
///Params:
///    pAudioFormat = Pointer to a <b>WAVEFORMATEX</b> structure that describes the audio format.
///    ppIAudioMediaType = Receives a pointer to the IMFAudioMediaType interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateAudioMediaType(const(WAVEFORMATEX)* pAudioFormat, IMFAudioMediaType* ppIAudioMediaType);

///<p class="CCE_Message">[This API is not supported and may be altered or unavailable in the future. Applications
///should avoid using the MFVIDEOFORMAT structure, and use media type attributes instead. For more information, see
///Video Media Types.] Returns the FOURCC or <b>D3DFORMAT</b> value for an uncompressed video format.
///Params:
///    pVideoFormat = Pointer to an MFVIDEOFORMAT structure.
///Returns:
///    Returns a FOURCC or <b>D3DFORMAT</b> value that identifies the video format. If the video format is compressed or
///    not recognized, the return value is D3DFMT_UNKNOWN.
///    
@DllImport("MFPlat")
uint MFGetUncompressedVideoFormat(const(MFVIDEOFORMAT)* pVideoFormat);

///<p class="CCE_Message">[This API is not supported and may be altered or unavailable in the future. Applications
///should avoid using the MFVIDEOFORMAT structure, and use media type attributes instead. For more information, see
///Video Media Types.] Initializes an MFVIDEOFORMAT structure for a standard video format such as DVD, analog
///television, or ATSC digital television.
///Params:
///    pVideoFormat = A pointer to an MFVIDEOFORMAT structure. The function fills in the structure members based on the video format
///                   specified in the type parameter.
///    type = The video format, specified as a member of the MFStandardVideoFormat enumeration.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFInitVideoFormat(MFVIDEOFORMAT* pVideoFormat, MFStandardVideoFormat type);

///<p class="CCE_Message">[This API is not supported and may be altered or unavailable in the future. Applications
///should avoid using the MFVIDEOFORMAT structure, and use media type attributes instead. For more information, see
///Video Media Types.] Initializes an MFVIDEOFORMAT structure for an uncompressed RGB video format.
///Params:
///    pVideoFormat = A pointer to an MFVIDEOFORMAT structure. The functions fills in the structure members with the format
///                   information.
///    dwWidth = The width of the video, in pixels.
///    dwHeight = The height of the video, in pixels.
///    D3Dfmt = A <b>D3DFORMAT</b> value that specifies the RGB format.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFInitVideoFormat_RGB(MFVIDEOFORMAT* pVideoFormat, uint dwWidth, uint dwHeight, uint D3Dfmt);

///<p class="CCE_Message">[This API is not supported and may be altered or unavailable in the future. Applications
///should avoid using the MFVIDEOFORMAT structure, and use media type attributes instead. For more information, see
///Extended Color Information.] Converts the extended color information from an MFVIDEOFORMAT to the equivalent DirectX
///Video Acceleration (DXVA) color information.
///Params:
///    pdwToDXVA = Receives the DXVA extended color information. The bitfields in the <b>DWORD</b> are defined in the
///                DXVA2_ExtendedFormat structure.
///    pFromFormat = Pointer to an MFVIDEOFORMAT structure that describes the video format.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFConvertColorInfoToDXVA(uint* pdwToDXVA, const(MFVIDEOFORMAT)* pFromFormat);

///<p class="CCE_Message">[This API is not supported and may be altered or unavailable in the future. Applications
///should avoid using the MFVIDEOFORMAT structure, and use media type attributes instead. For more information, see
///Extended Color Information.] Sets the extended color information in a MFVIDEOFORMAT structure.
///Params:
///    pToFormat = Pointer to an MFVIDEOFORMAT structure. The function fills in the structure members that correspond to the DXVA
///                color information in the <i>dwFromDXVA</i> parameter. The function does not modify the other structure members.
///    dwFromDXVA = <b>DWORD</b> that contains extended color information. The bitfields in the <b>DWORD</b> are defined in the
///                 DXVA2_ExtendedFormat structure.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFConvertColorInfoFromDXVA(MFVIDEOFORMAT* pToFormat, uint dwFromDXVA);

///Copies an image or image plane from one buffer to another.
///Params:
///    pDest = Pointer to the start of the first row of pixels in the destination buffer.
///    lDestStride = Stride of the destination buffer, in bytes.
///    pSrc = Pointer to the start of the first row of pixels in the source image.
///    lSrcStride = Stride of the source image, in bytes.
///    dwWidthInBytes = Width of the image, in bytes.
///    dwLines = Number of rows of pixels to copy.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCopyImage(ubyte* pDest, int lDestStride, const(ubyte)* pSrc, int lSrcStride, uint dwWidthInBytes, 
                    uint dwLines);

///Converts an array of 16-bit floating-point numbers into an array of 32-bit floating-point numbers.
///Params:
///    pDest = Pointer to an array of <b>float</b> values. The array must contain at least <i>dwCount</i> elements.
///    pSrc = Pointer to an array of 16-bit floating-point values, typed as <b>WORD</b> values. The array must contain at least
///           <i>dwCount</i> elements.
///    dwCount = Number of elements in the <i>pSrc</i> array to convert.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFConvertFromFP16Array(float* pDest, const(ushort)* pSrc, uint dwCount);

///Converts an array of 32-bit floating-point numbers into an array of 16-bit floating-point numbers.
///Params:
///    pDest = Pointer to an array of 16-bit floating-point values, typed as <b>WORD</b> values. The array must contain at least
///            <i>dwCount</i> elements.
///    pSrc = Pointer to an array of <b>float</b> values. The array must contain at least <i>dwCount</i> elements.
///    dwCount = Number of elements in the <i>pSrc</i> array to convert.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFConvertToFP16Array(ushort* pDest, const(float)* pSrc, uint dwCount);

///Creates a system-memory buffer object to hold 2D image data.
///Params:
///    dwWidth = Width of the image, in pixels.
///    dwHeight = Height of the image, in pixels.
///    dwFourCC = A <b>FOURCC</b> code or D3DFORMAT value that specifies the video format. If you have a video subtype GUID, you
///               can use the first <b>DWORD</b> of the subtype.
///    fBottomUp = If <b>TRUE,</b> the buffer's IMF2DBuffer::ContiguousCopyTo method copies the buffer into a bottom-up format. The
///                bottom-up format is compatible with GDI for uncompressed RGB images. If this parameter is <b>FALSE</b>, the
///                <b>ContiguousCopyTo</b> method copies the buffer into a top-down format, which is compatible with DirectX. For
///                more information about top-down versus bottom-up images, see Image Stride.
///    ppBuffer = Receives a pointer to the IMFMediaBuffer interface.
///Returns:
///    This function can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>MF_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> Unrecognized video format.
///    </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCreate2DMediaBuffer(uint dwWidth, uint dwHeight, uint dwFourCC, BOOL fBottomUp, IMFMediaBuffer* ppBuffer);

///Allocates a system-memory buffer that is optimal for a specified media type.
///Params:
///    pMediaType = A pointer to the IMFMediaType interface of the media type.
///    llDuration = The sample duration. This value is required for audio formats.
///    dwMinLength = The minimum size of the buffer, in bytes. The actual buffer size might be larger. Specify zero to allocate the
///                  default buffer size for the media type.
///    dwMinAlignment = The minimum memory alignment for the buffer. Specify zero to use the default memory alignment.
///    ppBuffer = Receives a pointer to the IMFMediaBuffer interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFCreateMediaBufferFromMediaType(IMFMediaType pMediaType, long llDuration, uint dwMinLength, 
                                         uint dwMinAlignment, IMFMediaBuffer* ppBuffer);

///Creates an empty collection object.
///Params:
///    ppIMFCollection = Receives a pointer to the collection object's IMFCollection interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
///    
@DllImport("MFPlat")
HRESULT MFCreateCollection(IMFCollection* ppIMFCollection);

///Allocates a block of memory.
///Params:
///    nSize = Number of bytes to allocate.
///    dwFlags = Zero or more flags. For a list of valid flags, see <b>HeapAlloc</b> in the Windows SDK documentation.
///    pszFile = Reserved. Set to <b>NULL</b>.
///    line = Reserved. Set to zero.
///    eat = Reserved. Set to <b>eAllocationTypeIgnore</b>.
///Returns:
///    If the function succeeds, it returns a pointer to the allocated memory block. If the function fails, it returns
///    <b>NULL</b>.
///    
@DllImport("MFPlat")
void* MFHeapAlloc(size_t nSize, uint dwFlags, byte* pszFile, int line, EAllocationType eat);

///Frees a block of memory that was allocated by calling the MFHeapAlloc function.
///Params:
///    pv = Pointer to the memory to free.
@DllImport("MFPlat")
void MFHeapFree(void* pv);

///Calculates ((a * b) + d) / c, where each term is a 64-bit signed value.
///Params:
///    a = A multiplier.
///    b = Another multiplier.
///    c = The divisor.
///    d = The rounding factor.
///Returns:
///    Returns the result of the calculation. If numeric overflow occurs, the function returns _I64_MAX (positive
///    overflow) or LLONG_MIN (negative overflow). If Mfplat.dll cannot be loaded, the function returns _I64_MAX.
///    
@DllImport("MFPlat")
long MFllMulDiv(long a, long b, long c, long d);

///Gets the class identifier for a content protection system.
///Params:
///    guidProtectionSystemID = The GUID that identifies the content protection system.
///    pclsid = Receives the class identifier to the content protection system.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlat")
HRESULT MFGetContentProtectionSystemCLSID(const(GUID)* guidProtectionSystemID, GUID* pclsid);

///Concatenates a media sample onto another sample if their combined duration does not exceed the specified duration.
///Params:
///    pSample = A pointer to an [IMFSample](../mfobjects/nn-mfobjects-imfsample.md) to which the the sample provided in the
///              *pSampleToAdd* parameter is appended.
///    pSampleToAdd = A pointer to an [IMFSample](../mfobjects/nn-mfobjects-imfsample.md) to append to the sample provided in the
///                   *pSample* parameter.
///    dwMaxMergedDurationInMS = The maximum duration in milliseconds that the combined sample can fill for the operation to be successful.
///    pMerged = Output parameter that receives a BOOL indicating whether the sample was successfully appended.
///Returns:
///    Returns HRESULT.
///    
@DllImport("MFPlat")
HRESULT MFCombineSamples(IMFSample pSample, IMFSample pSampleToAdd, uint dwMaxMergedDurationInMS, BOOL* pMerged);

///Split up a combined media sample back into individual samples.
///Params:
///    pSample = A pointer to an [IMFSample](../mfobjects/nn-mfobjects-imfsample.md) representing a combined sample to be split.
///    pOutputSamples = Receives a pointer to an array of output samples from the split operation.
///    dwOutputSampleMaxCount = The maximum output array size. Call
///                             [IMFSample::GetBufferCount](../mfobjects/nf-mfobjects-imfsample-getbuffercount.md) on the sample provided in
///                             *pSample* to find out an upper bound.
///    pdwOutputSampleCount = Output parameter that receives the number of samples contained in the pOutputSamples array.
///Returns:
///    
///    
@DllImport("MFPlat")
HRESULT MFSplitSample(IMFSample pSample, IMFSample* pOutputSamples, uint dwOutputSampleMaxCount, 
                      uint* pdwOutputSampleCount);

///Creates the source reader from a URL.
///Params:
///    pwszURL = The URL of a media file to open.
///    pAttributes = Pointer to the IMFAttributes interface. You can use this parameter to configure the source reader. For more
///                  information, see Source Reader Attributes. This parameter can be <b>NULL</b>.
///    ppSourceReader = Receives a pointer to the IMFSourceReader interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFReadWrite")
HRESULT MFCreateSourceReaderFromURL(const(PWSTR) pwszURL, IMFAttributes pAttributes, 
                                    IMFSourceReader* ppSourceReader);

///Creates the source reader from a byte stream.
///Params:
///    pByteStream = A pointer to the IMFByteStream interface of a byte stream. This byte stream will provide the source data for the
///                  source reader.
///    pAttributes = Pointer to the IMFAttributes interface. You can use this parameter to configure the source reader. For more
///                  information, see Source Reader Attributes. This parameter can be <b>NULL</b>.
///    ppSourceReader = Receives a pointer to the IMFSourceReader interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFReadWrite")
HRESULT MFCreateSourceReaderFromByteStream(IMFByteStream pByteStream, IMFAttributes pAttributes, 
                                           IMFSourceReader* ppSourceReader);

///Creates the source reader from a media source.
///Params:
///    pMediaSource = A pointer to the IMFMediaSource interface of a media source.
///    pAttributes = Pointer to the IMFAttributes interface. You can use this parameter to configure the source reader. For more
///                  information, see Source Reader Attributes. This parameter can be <b>NULL</b>.
///    ppSourceReader = Receives a pointer to the IMFSourceReader interface. The caller must release the interface.
///Returns:
///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b><b>MF_E_DRM_UNSUPPORTED</b></b></dt> </dl> </td> <td width="60%"> The source contains protected
///    content. </td> </tr> </table>
///    
@DllImport("MFReadWrite")
HRESULT MFCreateSourceReaderFromMediaSource(IMFMediaSource pMediaSource, IMFAttributes pAttributes, 
                                            IMFSourceReader* ppSourceReader);

///Creates the sink writer from a URL or byte stream.
///Params:
///    pwszOutputURL = A null-terminated string that contains the URL of the output file. This parameter can be <b>NULL</b>.
///    pByteStream = Pointer to the IMFByteStream interface of a byte stream. This parameter can be <b>NULL</b>. If this parameter is
///                  a valid pointer, the sink writer writes to the provided byte stream. (The byte stream must be writable.)
///                  Otherwise, if <i>pByteStream</i> is <b>NULL</b>, the sink writer creates a new file named <i>pwszOutputURL</i>.
///    pAttributes = Pointer to the IMFAttributes interface. You can use this parameter to configure the sink writer. For more
///                  information, see Sink Writer Attributes. This parameter can be <b>NULL</b>.
///    ppSinkWriter = Receives a pointer to the IMFSinkWriter interface. The caller must release the interface.
///Returns:
///    This function can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>MF_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified URL was not found.
///    </td> </tr> </table>
///    
@DllImport("MFReadWrite")
HRESULT MFCreateSinkWriterFromURL(const(PWSTR) pwszOutputURL, IMFByteStream pByteStream, IMFAttributes pAttributes, 
                                  IMFSinkWriter* ppSinkWriter);

///Creates the sink writer from a media sink.
///Params:
///    pMediaSink = Pointer to the IMFMediaSink interface of a media sink.
///    pAttributes = Pointer to the IMFAttributes interface. You can use this parameter to configure the sink writer. For more
///                  information, see Sink Writer Attributes. This parameter can be <b>NULL</b>.
///    ppSinkWriter = Receives a pointer to the IMFSinkWriter interface. The caller must release the interface.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFReadWrite")
HRESULT MFCreateSinkWriterFromMediaSink(IMFMediaSink pMediaSink, IMFAttributes pAttributes, 
                                        IMFSinkWriter* ppSinkWriter);

///Creates the default video presenter for the enhanced video renderer (EVR).
///Params:
///    pOwner = Pointer to the owner of the object. If the object is aggregated, pass a pointer to the aggregating object's
///             <b>IUnknown</b> interface. Otherwise, set this parameter to <b>NULL</b>.
///    riidDevice = Interface identifier (IID) of the video device interface that will be used for processing the video. Currently
///                 the only supported value is IID_IDirect3DDevice9.
///    riid = IID of the requested interface on the video presenter. The video presenter exposes the IMFVideoPresenter
///           interface.
///    ppVideoPresenter = Receives a pointer to the requested interface on the video presenter. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
///    
@DllImport("EVR")
HRESULT MFCreateVideoPresenter(IUnknown pOwner, const(GUID)* riidDevice, const(GUID)* riid, 
                               void** ppVideoPresenter);

///Creates the default video mixer for the enhanced video renderer (EVR).
///Params:
///    pOwner = Pointer to the owner of this object. If the object is aggregated, pass a pointer to the aggregating object's
///             <b>IUnknown</b> interface. Otherwise, set this parameter to <b>NULL</b>.
///    riidDevice = Interface identifier (IID) of the video device interface that will be used for processing the video. Currently
///                 the only supported value is IID_IDirect3DDevice9.
///    riid = IID of the requested interface on the video mixer. The video mixer exposes the IMFTransform interface.
///    ppv = Receives a pointer to the requested interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
///    
@DllImport("EVR")
HRESULT MFCreateVideoMixer(IUnknown pOwner, const(GUID)* riidDevice, const(GUID)* riid, void** ppv);

///Creates the default video mixer and video presenter for the enhanced video renderer (EVR).
///Params:
///    pMixerOwner = Pointer to the owner of the video mixer. If the mixer is aggregated, pass a pointer to the aggregating object's
///                  <b>IUnknown</b> interface. Otherwise, set this parameter to <b>NULL</b>.
///    pPresenterOwner = Pointer to the owner of the video presenter. If the presenter is aggregated, pass a pointer to the aggregating
///                      object's <b>IUnknown</b> interface. Otherwise, set this parameter to <b>NULL</b>.
///    riidMixer = Interface identifier (IID) of the requested interface on the video mixer. The video mixer exposes the
///                IMFTransform interface.
///    ppvVideoMixer = Receives a pointer to the requested interface on the video mixer. The caller must release the interface.
///    riidPresenter = IID of the requested interface on the video presenter. The video presenter exposes the IMFVideoPresenter
///                    interface.
///    ppvVideoPresenter = Receives a pointer to the requested interface on the video presenter. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
///    
@DllImport("EVR")
HRESULT MFCreateVideoMixerAndPresenter(IUnknown pMixerOwner, IUnknown pPresenterOwner, const(GUID)* riidMixer, 
                                       void** ppvVideoMixer, const(GUID)* riidPresenter, void** ppvVideoPresenter);

///Creates an instance of the enhanced video renderer (EVR) media sink.
///Params:
///    riidRenderer = Interface identifier (IID) of the requested interface on the EVR.
///    ppVideoRenderer = Receives a pointer to the requested interface. The caller must release the interface.
///Returns:
///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
///    
@DllImport("MF")
HRESULT MFCreateVideoRenderer(const(GUID)* riidRenderer, void** ppVideoRenderer);

///Creates a media sample that manages a Direct3D surface.
///Params:
///    pUnkSurface = A pointer to the <b>IUnknown</b> interface of the Direct3D surface. This parameter can be <b>NULL</b>.
///    ppSample = Receives a pointer to the sample's IMFSample interface. The caller must release the interface.
///Returns:
///    If this callback function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>.
///    Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("EVR")
HRESULT MFCreateVideoSampleFromSurface(IUnknown pUnkSurface, IMFSample* ppSample);

///Creates an object that allocates video samples.
///Params:
///    riid = The identifier of the interface to retrieve. Specify one of the following values: <table> <tr> <th>Value</th>
///           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="IID_IUnknown"></a><a id="iid_iunknown"></a><a
///           id="IID_IUNKNOWN"></a><dl> <dt><b><b>IID_IUnknown</b></b></dt> </dl> </td> <td width="60%"> Retrieve an
///           <b>IUnknown</b> pointer. </td> </tr> <tr> <td width="40%"><a id="IID_IMFVideoSampleAllocator"></a><a
///           id="iid_imfvideosampleallocator"></a><a id="IID_IMFVIDEOSAMPLEALLOCATOR"></a><dl>
///           <dt><b><b>IID_IMFVideoSampleAllocator</b></b></dt> </dl> </td> <td width="60%"> Retrieve an
///           IMFVideoSampleAllocator pointer. </td> </tr> <tr> <td width="40%"><a
///           id="IID_IMFVideoSampleAllocatorCallback"></a><a id="iid_imfvideosampleallocatorcallback"></a><a
///           id="IID_IMFVIDEOSAMPLEALLOCATORCALLBACK"></a><dl> <dt><b><b>IID_IMFVideoSampleAllocatorCallback</b></b></dt>
///           </dl> </td> <td width="60%"> Retrieve an IMFVideoSampleAllocatorCallback pointer. </td> </tr> </table>
///    ppSampleAllocator = Receives a pointer to the requested interface. The caller must release the interface.
///Returns:
///    If the function succeeds, it returns S_OK. Otherwise, it returns an <b>HRESULT</b> error code.
///    
@DllImport("EVR")
HRESULT MFCreateVideoSampleAllocator(const(GUID)* riid, void** ppSampleAllocator);

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Creates a new instance of the MFPlay player object.
///Params:
///    pwszURL = Null-terminated string that contains the URL of a media file to open. This parameter can be <b>NULL</b>. If the
///              parameter is <b>NULL</b>, <i>fStartPlayback</i> must be <b>FALSE</b>. If this parameter is <b>NULL</b>, you can
///              open a URL later by calling IMFPMediaPlayer::CreateMediaItemFromURL.
///    fStartPlayback = If <b>TRUE</b>, playback starts automatically. If <b>FALSE</b>, playback does not start until the application
///                     calls IMFMediaPlayer::Play. If <i>pwszURL</i> is <b>NULL</b>, this parameter is ignored.
///    creationOptions = Bitwise <b>OR</b> of zero of more flags from the _MFP_CREATION_OPTIONS enumeration.
///    pCallback = Pointer to the IMFPMediaPlayerCallback interface of a callback object, implemented by the application. Use this
///                interface to get event notifications from the MFPlay player object. This parameter can be <b>NULL</b>. If the
///                parameter is <b>NULL</b>, the application will not receive event notifications from the player object.
///    hWnd = A handle to a window where the video will appear. For audio-only playback, this parameter can be <b>NULL</b>. The
///           window specified by <i>hWnd</i> is used for the first selected video stream in the source. If the source has
///           multiple video streams, you must call IMFPMediaItem::SetStreamSink to render any of the video streams after the
///           first. If <i>hWnd</i> is <b>NULL</b>, MFPlay will not display any video unless the application calls
///           IMFPMediaItem::SetStreamSink to specify a media sink for the video stream.
///    ppMediaPlayer = Receives a pointer to the IMFPMediaPlayer interface. The caller must release the interface. This parameter can be
///                    <b>NULL</b>. If this parameter is <b>NULL</b>, <i>fStartPlayback</i> must be <b>TRUE</b> and <i>pwszURL</i>
///                    cannot be <b>NULL</b>.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("MFPlay")
HRESULT MFPCreateMediaPlayer(const(PWSTR) pwszURL, BOOL fStartPlayback, MFP_CREATION_OPTIONS creationOptions, 
                             IMFPMediaPlayerCallback pCallback, HWND hWnd, IMFPMediaPlayer* ppMediaPlayer);

///This function creates an object that implements [IMFActivate](../mfobjects/nn-mfobjects-imfactivate.md). This
///objectâ€™s implementation of ActivateObject is based on the specified IMFPMPHostApp and class ID.
///Params:
///    pmpHost = An [IMFPMPHostApp](../mfidl/nn-mfidl-imfpmphostapp.md) with the necessary information to create the
///              **IMFActivate** for this app package.
///    objectStream = An [IStream](../objidl/nn-objidl-istream.md) representing the object stream that will be loaded via
///                   IMFActivate::Load.
///    classId = An **LPCWSTR** representing the target object's activatable class id.
///    activate = Receives a reference to the to an **IMFActivate**.
///Returns:
///    Returns S_OK on success.
///    
@DllImport("MF")
HRESULT MFCreateEncryptedMediaExtensionsStoreActivate(IMFPMPHostApp pmpHost, IStream objectStream, 
                                                      const(PWSTR) classId, IMFActivate* activate);


// Interfaces

@GUID("F371728A-6052-4D47-827C-D039335DFE0A")
struct CMpeg4DecMediaObject;

@GUID("CBA9E78B-49A3-49EA-93D4-6BCBA8C4DE07")
struct CMpeg43DecMediaObject;

@GUID("2A11BAE2-FE6E-4249-864B-9E9ED6E8DBC2")
struct CMpeg4sDecMediaObject;

@GUID("5686A0D9-FE39-409F-9DFF-3FDBC849F9F5")
struct CMpeg4sDecMFT;

@GUID("C56FC25C-0FC6-404A-9503-B10BF51A8AB9")
struct CZuneM4S2DecMediaObject;

@GUID("24F258D8-C651-4042-93E4-CA654ABB682C")
struct CMpeg4EncMediaObject;

@GUID("6EC5A7BE-D81E-4F9E-ADA3-CD1BF262B6D8")
struct CMpeg4sEncMediaObject;

@GUID("7BAFB3B1-D8F4-4279-9253-27DA423108DE")
struct CMSSCDecMediaObject;

@GUID("8CB9CC06-D139-4AE6-8BB4-41E612E141D5")
struct CMSSCEncMediaObject;

@GUID("F7FFE0A0-A4F5-44B5-949E-15ED2BC66F9D")
struct CMSSCEncMediaObject2;

@GUID("2EEB4ADF-4578-4D10-BCA7-BB955F56320A")
struct CWMADecMediaObject;

@GUID("70F598E9-F4AB-495A-99E2-A7C4D3D89ABF")
struct CWMAEncMediaObject;

@GUID("EDCAD9CB-3127-40DF-B527-0152CCB3F6F5")
struct CWMATransMediaObject;

@GUID("874131CB-4ECC-443B-8948-746B89595D20")
struct CWMSPDecMediaObject;

@GUID("67841B03-C689-4188-AD3F-4C9EBEEC710B")
struct CWMSPEncMediaObject;

@GUID("1F1F4E1A-2252-4063-84BB-EEE75F8856D5")
struct CWMSPEncMediaObject2;

@GUID("F9DBC64E-2DD0-45DD-9B52-66642EF94431")
struct CWMTDecMediaObject;

@GUID("60B67652-E46B-4E44-8609-F74BFFDC083C")
struct CWMTEncMediaObject;

@GUID("82D353DF-90BD-4382-8BC2-3F6192B76E34")
struct CWMVDecMediaObject;

@GUID("96B57CDD-8966-410C-BB1F-C97EEA765C04")
struct CWMVEncMediaObject2;

@GUID("7E320092-596A-41B2-BBEB-175D10504EB6")
struct CWMVXEncMediaObject;

@GUID("D23B90D0-144F-46BD-841D-59E4EB19DC59")
struct CWMV9EncMediaObject;

@GUID("C9BFBCCF-E60E-4588-A3DF-5A03B1FD9585")
struct CWVC1DecMediaObject;

@GUID("44653D0D-8CCA-41E7-BACA-884337B747AC")
struct CWVC1EncMediaObject;

@GUID("49034C05-F43C-400F-84C1-90A683195A3A")
struct CDeColorConvMediaObject;

@GUID("E54709C5-1E17-4C8D-94E7-478940433584")
struct CDVDecoderMediaObject;

@GUID("C82AE729-C327-4CCE-914D-8171FEFEBEFB")
struct CDVEncoderMediaObject;

@GUID("863D66CD-CDCE-4617-B47F-C8929CFC28A6")
struct CMpeg2DecMediaObject;

@GUID("9910C5CD-95C9-4E06-865A-EFA1C8016BF4")
struct CPK_DS_MPEG2Decoder;

@GUID("03D7C802-ECFA-47D9-B268-5FB3E310DEE4")
struct CAC3DecMediaObject;

@GUID("6C9C69D6-0FFC-4481-AFDB-CDF1C79C6F3E")
struct CPK_DS_AC3Decoder;

@GUID("BBEEA841-0A63-4F52-A7AB-A9B3A84ED38A")
struct CMP3DecMediaObject;

@GUID("F447B69E-1884-4A7E-8055-346F74D6EDB3")
struct CResamplerMediaObject;

@GUID("D3EC8B8B-7728-4FD8-9FE0-7B67D19F73A3")
struct CResizerMediaObject;

@GUID("B5A89C80-4901-407B-9ABC-90D9A644BB46")
struct CInterlaceMediaObject;

@GUID("62DC1A93-AE24-464C-A43E-452F824C4250")
struct CWMAudioLFXAPO;

@GUID("637C490D-EEE3-4C0A-973F-371958802DA2")
struct CWMAudioGFXAPO;

@GUID("5210F8E4-B0BB-47C3-A8D9-7B2282CC79ED")
struct CWMAudioSpdTxDMO;

@GUID("745057C7-F353-4F2D-A7EE-58434477730E")
struct CWMAudioAEC;

@GUID("36E820C4-165A-4521-863C-619E1160D4D4")
struct CClusterDetectorDmo;

@GUID("798059F0-89CA-4160-B325-AEB48EFE4F9A")
struct CColorControlDmo;

@GUID("98230571-0087-4204-B020-3282538E57D3")
struct CColorConvertDMO;

@GUID("FDFAA753-E48E-4E33-9C74-98A27FC6726A")
struct CColorLegalizerDmo;

@GUID("0A7CFE1B-6AB5-4334-9ED8-3F97CB37DAA1")
struct CFrameInterpDMO;

@GUID("01F36CE2-0907-4D8B-979D-F151BE91C883")
struct CFrameRateConvertDmo;

@GUID("1EA1EA14-48F4-4054-AD1A-E8AEE10AC805")
struct CResizerDMO;

@GUID("56AEFACD-110C-4397-9292-B0A0C61B6750")
struct CShotDetectorDmo;

@GUID("BDE6388B-DA25-485D-BA7F-FABC28B20318")
struct CSmpteTransformsDmo;

@GUID("559C6BAD-1EA8-4963-A087-8A6810F9218B")
struct CThumbnailGeneratorDmo;

@GUID("4DDA1941-77A0-4FB1-A518-E2185041D70C")
struct CTocGeneratorDmo;

@GUID("8DDE1772-EDAD-41C3-B4BE-1F30FB4EE0D6")
struct CMPEGAACDecMediaObject;

@GUID("3CB2BDE4-4E29-4C44-A73E-2D7C2C46D6EC")
struct CNokiaAACDecMediaObject;

@GUID("7F36F942-DCF3-4D82-9289-5B1820278F7C")
struct CVodafoneAACDecMediaObject;

@GUID("A74E98F2-52D6-4B4E-885B-E0A6CA4F187A")
struct CZuneAACCCDecMediaObject;

@GUID("EABF7A6F-CCBA-4D60-8620-B152CC977263")
struct CNokiaAACCCDecMediaObject;

@GUID("7E76BF7F-C993-4E26-8FAB-470A70C0D59C")
struct CVodafoneAACCCDecMediaObject;

@GUID("5F5AFF4A-2F7F-4279-88C2-CD88EB39D144")
struct CMPEG2EncoderDS;

@GUID("42150CD9-CA9A-4EA5-9939-30EE037F6E74")
struct CMPEG2EncoderVideoDS;

@GUID("ACD453BC-C58A-44D1-BBF5-BFB325BE2D78")
struct CMPEG2EncoderAudioDS;

@GUID("E1F1A0B8-BEEE-490D-BA7C-066C40B5E2B9")
struct CMPEG2AudDecoderDS;

@GUID("212690FB-83E5-4526-8FD7-74478B7939CD")
struct CMPEG2VidDecoderDS;

@GUID("8E269032-FE03-4753-9B17-18253C21722E")
struct CDTVAudDecoderDS;

@GUID("64777DC8-4E24-4BEB-9D19-60A35BE1DAAF")
struct CDTVVidDecoderDS;

@GUID("C6B400E2-20A7-4E58-A2FE-24619682CE6C")
struct CMSAC3Enc;

@GUID("62CE7E72-4C71-4D20-B15D-452831A87D9D")
struct CMSH264DecoderMFT;

@GUID("BC47FCFE-98A0-4F27-BB07-698AF24F2B38")
struct CMSH263EncoderMFT;

@GUID("6CA50344-051A-4DED-9779-A43305165E35")
struct CMSH264EncoderMFT;

@GUID("F2F84074-8BCA-40BD-9159-E880F673DD3B")
struct CMSH265EncoderMFT;

@GUID("AEB6C755-2546-4881-82CC-E15AE5EBFF3D")
struct CMSVPXEncoderMFT;

@GUID("05A47EBB-8BF0-4CBF-AD2F-3B71D75866F5")
struct CMSH264RemuxMFT;

@GUID("32D186A7-218F-4C75-8876-DD77273A8999")
struct CMSAACDecMFT;

@GUID("93AF0C51-2275-45D2-A35B-F2BA21CAED00")
struct AACMFTEncoder;

@GUID("177C0AFE-900B-48D4-9E4C-57ADD250B3D4")
struct CMSDDPlusDecMFT;

@GUID("E6335F02-80B7-4DC4-ADFA-DFE7210D20D5")
struct CMPEG2VideoEncoderMFT;

@GUID("46A4DD5C-73F8-4304-94DF-308F760974F4")
struct CMPEG2AudioEncoderMFT;

@GUID("2D709E52-123F-49B5-9CBC-9AF5CDE28FB9")
struct CMSMPEGDecoderMFT;

@GUID("70707B39-B2CA-4015-ABEA-F8447D22D88B")
struct CMSMPEGAudDecMFT;

@GUID("AC3315C9-F481-45D7-826C-0B406C1F64B8")
struct CMSDolbyDigitalEncMFT;

@GUID("11103421-354C-4CCA-A7A3-1AFF9A5B6701")
struct MP3ACMCodecWrapper;

@GUID("36CB6E0C-78C1-42B2-9943-846262F31786")
struct ALawCodecWrapper;

@GUID("92B66080-5E2D-449E-90C4-C41F268E5514")
struct MULawCodecWrapper;

@GUID("51571744-7FE4-4FF2-A498-2DC34FF74F1B")
struct CMSVideoDSPMFT;

@GUID("1A198EF2-60E5-4EA8-90D8-DA1F2832C288")
struct VorbisDecoderMFT;

@GUID("6B0B3E6B-A2C5-4514-8055-AFE8A95242D9")
struct CMSFLACDecMFT;

@GUID("128509E9-C44E-45DC-95E9-C255B8F466A6")
struct CMSFLACEncMFT;

@GUID("0E41CFB8-0506-40F4-A516-77CC23642D91")
struct MFFLACBytestreamHandler;

@GUID("7D39C56F-6075-47C9-9BAE-8CF9E531B5F5")
struct MFFLACSinkClassFactory;

@GUID("C0CD7D12-31FC-4BBC-B363-7322EE3E1879")
struct CMSALACDecMFT;

@GUID("9AB6A28C-748E-4B6A-BFFF-CC443B8E8FB4")
struct CMSALACEncMFT;

@GUID("63E17C10-2D43-4C42-8FE3-8D8B63E46A6A")
struct CMSOpusDecMFT;

@GUID("265011AE-5481-4F77-A295-ABB6FFE8D63E")
struct MSAMRNBDecoder;

@GUID("2FAE8AFE-04A3-423A-A814-85DB454712B0")
struct MSAMRNBEncoder;

@GUID("EFE6208A-0A2C-49FA-8A01-3768B559B6DA")
struct MFAMRNBByteStreamHandler;

@GUID("B0271158-70D2-4C5B-9F94-76F549D90FDF")
struct MFAMRNBSinkClassFactory;

@GUID("06F414BB-F43A-4FE2-A566-774B4C81F0DB")
struct KSPROPSETID_OPMVideoOutput;

///Queries the overlay hardware capabilities of a Direct3D device. To get a pointer to this interface, call
///<b>QueryInterface</b> on an <b>IDirect3D9Ex</b> interface pointer.
@GUID("187AEB13-AAF5-4C59-876D-E059088C0DF8")
interface IDirect3D9ExOverlayExtension : IUnknown
{
    ///Queries the overlay hardware capabilities of a Direct3D device.
    ///Params:
    ///    Adapter = An ordinal number that denotes the display adapter. <b>D3DADAPTER_DEFAULT</b> is always the primary display
    ///              adapter.
    ///    DevType = Specifies the Direct3D device type as a member of the <b>D3DDEVTYPE</b> enumerated type.
    ///    OverlayWidth = The width of the overlay to create, in pixels.
    ///    OverlayHeight = The height of the overlay to create, in pixels.
    ///    OverlayFormat = The surface format of the overlay.
    ///    pDisplayMode = A pointer to a <b>D3DDISPLAYMODEEX</b> structure that specifies the display mode that will be used. If this
    ///                   parameter is <b>NULL</b>, the current display mode is assumed.
    ///    DisplayRotation = Specifies the display rotation mode as a member of the <b>D3DDISPLAYROTATION</b> enumerated type.
    ///    pOverlayCaps = A pointer to a D3DOVERLAYCAPS structure. If the driver supports the overlay settings specified in the input
    ///                   parameters, the method fills this structure with the capabilities of the overlay hardware.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>D3DERR_INVALIDCALL</b></dt> </dl> </td> <td width="60%"> Invalid parameter, or
    ///    the device does not support hardware overlay. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>D3DERR_UNSUPPORTEDOVERLAY</b></dt> </dl> </td> <td width="60%"> The device does not support overlay
    ///    for the specified size or display mode. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>D3DERR_UNSUPPORTEDOVERLAYFORMAT</b></dt> </dl> </td> <td width="60%"> The device does not support
    ///    overlay for the specified surface format. </td> </tr> </table>
    ///    
    HRESULT CheckDeviceOverlayType(uint Adapter, D3DDEVTYPE DevType, uint OverlayWidth, uint OverlayHeight, 
                                   D3DFORMAT OverlayFormat, D3DDISPLAYMODEEX* pDisplayMode, 
                                   D3DDISPLAYROTATION DisplayRotation, D3DOVERLAYCAPS* pOverlayCaps);
}

///Enables an application to use content protection and encryption services implemented by a graphics driver. To get a
///pointer to this interface, call <b>QueryInterface</b> on a D3D9Ex device.
@GUID("26DC4561-A1EE-4AE7-96DA-118A36C0EC95")
interface IDirect3DDevice9Video : IUnknown
{
    ///Queries the display driver for its content protection capabilities.
    ///Params:
    ///    pCryptoType = A pointer to a GUID that specifies the type of encryption to use. The following GUIDs are defined.
    ///                  **D3DCRYPTOTYPE_AES128_CTR** 128-bit Advanced Encryption Standard CTR mode (AES-CTR) block cipher.
    ///                  **D3DCRYPTOTYPE_PROPRIETARY** Proprietary encryption algorithm.
    ///    pDecodeProfile = A pointer to a GUID that specifies the DirectX Video Acceleration 2 (DXVA-2) decoding profile. For a list of
    ///                     possible values, see IDirectXVideoDecoderService::GetDecoderDeviceGuids. If DXVA-2 decoding will not be used,
    ///                     set this parameter to <b>NULL</b>.
    ///    pCaps = A pointer to a D3DCONTENTPROTECTIONCAPS structure. The method fills in this structure with the driver's
    ///            content protection capabilities.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetContentProtectionCaps(const(GUID)* pCryptoType, const(GUID)* pDecodeProfile, 
                                     D3DCONTENTPROTECTIONCAPS* pCaps);
    ///Creates a channel to communicate with the Direct3D device or the graphics driver.
    ///Params:
    ///    ChannelType = Specifies the type of channel, as a member of the D3DAUTHENTICATEDCHANNELTYPE enumeration.
    ///    ppAuthenticatedChannel = Receives a pointer to the IDirect3DAuthenticatedChannel9 interface. The caller must release the interface.
    ///    pChannelHandle = Receives a pointer to a handle for the channel.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateAuthenticatedChannel(D3DAUTHENTICATEDCHANNELTYPE ChannelType, 
                                       IDirect3DAuthenticatedChannel9* ppAuthenticatedChannel, 
                                       HANDLE* pChannelHandle);
    ///Creates a cryptographic session to encrypt video content that is sent to the display driver.
    ///Params:
    ///    pCryptoType = Pointer to a GUID that specifies the type of encryption to use. The following GUIDs are defined.
    ///                  **pDecodeProfile** Type: **GUID** A pointer to a GUID that specifies the DirectX Video Acceleration 2
    ///                  (DXVA-2) decoding profile. For a list of possible values, see
    ///                  IDirectXVideoDecoderService::GetDecoderDeviceGuids. If DXVA-2 decoding will not be used, set this parameter
    ///                  to NULL. **pCaps** Type: **D3DCONTENTPROTECTIONCAPS** A pointer to a D3DCONTENTPROTECTIONCAPS structure. The
    ///                  method fills in this structure with the driver's content protection capabilities.
    ///    pDecodeProfile = Pointer to a GUID that specifies the DirectX Video Acceleration 2 (DXVA-2) decoding profile. For a list of
    ///                     possible values, see IDirectXVideoDecoderService::GetDecoderDeviceGuids. If DXVA-2 decoding will not be used,
    ///                     set this parameter to <b>NULL</b>.
    ///    ppCryptoSession = Receives a pointer to the IDirect3DCryptoSession9 interface. The caller must release the interface.
    ///    pCryptoHandle = Receives a handle for the session.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateCryptoSession(const(GUID)* pCryptoType, const(GUID)* pDecodeProfile, 
                                IDirect3DCryptoSession9* ppCryptoSession, HANDLE* pCryptoHandle);
}

///Provides a communication channel with the graphics driver or the Direct3D runtime. To get a pointer to this
///interface, call IDirect3DDevice9Video::CreateAuthenticatedChannel.
@GUID("FF24BEEE-DA21-4BEB-98B5-D2F899F98AF9")
interface IDirect3DAuthenticatedChannel9 : IUnknown
{
    ///Gets the size of the driver's certificate chain.
    ///Params:
    ///    pCertificateSize = Receives the size of the certificate chain, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCertificateSize(uint* pCertificateSize);
    ///Gets the driver's certificate chain.
    ///Params:
    ///    CertifacteSize = The size of the <i>ppCertificate</i> array, in bytes. To get the size of the certificate chain, call
    ///                     IDirect3DAuthenticatedChannel9::GetCertificateSize.
    ///    ppCertificate = A pointer to a byte array that receives the driver's X.509 certificate chain. The caller must allocate the
    ///                    array.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCertificate(uint CertifacteSize, ubyte* ppCertificate);
    ///Establishes a session key for the authenticated channel.
    ///Params:
    ///    DataSize = The size of the data in the <i>pData</i> array, in bytes.
    ///    pData = A pointer to a byte array that contains the encrypted session key. The buffer must contain 256 bytes of data,
    ///            encrypted using RSA Encryption Scheme - Optimal Asymmetric Encryption Padding (RSAES-OAEP).
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT NegotiateKeyExchange(uint DataSize, void* pData);
    ///Sends a query to the authenticated channel.
    ///Params:
    ///    InputSize = The size of the <i>pInput</i> array, in bytes.
    ///    pInput = A pointer to a byte array that contains input data for the query. This array always starts with a
    ///             D3DAUTHENTICATEDCHANNEL_QUERY_INPUT structure. The <b>QueryType</b> member of the structure specifies the
    ///             query and defines the meaning of the rest of the array.
    ///    OutputSize = The size of the <i>pOutput</i> array, in bytes.
    ///    pOutput = A pointer to a byte array that receives the result of the query. This array always starts with a
    ///              D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT structure. The meaning of the rest of the array depends on the query.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Query(uint InputSize, const(void)* pInput, uint OutputSize, void* pOutput);
    ///Sends a configuration command to the authenticated channel.
    ///Params:
    ///    InputSize = The size of the <i>pInput</i> array, in bytes.
    ///    pInput = A pointer to a byte array that contains input data for the command. This buffer always starts with a
    ///             D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT structure. The <b>ConfigureType</b> member of the structure specifies
    ///             the command and defines the meaning of the rest of the buffer.
    ///    pOutput = A pointer to a D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT structure that receives the response to the command.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Configure(uint InputSize, const(void)* pInput, D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT* pOutput);
}

///Represents a cryptographic session. To get a pointer to this interface, call
///IDirect3DDevice9Video::CreateCryptoSession.
@GUID("FA0AB799-7A9C-48CA-8C5B-237E71A54434")
interface IDirect3DCryptoSession9 : IUnknown
{
    ///Gets the size of the driver's certificate chain.
    ///Params:
    ///    pCertificateSize = Receives the size of the certificate chain, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCertificateSize(uint* pCertificateSize);
    ///Gets the driver's certificate chain.
    ///Params:
    ///    CertifacteSize = The size of the <i>ppCertificate</i> array, in bytes. To get the size of the certificate chain, call
    ///                     IDirect3DCryptoSession9::GetCertificateSize.
    ///    ppCertificate = A pointer to a byte array that receives the driver's certificate chain. The caller must allocate the array.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCertificate(uint CertifacteSize, ubyte* ppCertificate);
    ///Establishes the session key for the cryptographic session.
    ///Params:
    ///    DataSize = The size of the <i>pData</i> byte array, in bytes.
    ///    pData = A pointer to a byte array that contains the encrypted session key.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT NegotiateKeyExchange(uint DataSize, void* pData);
    ///Reads encrypted data from a protected surface.
    ///Params:
    ///    pSrcSurface = Pointer to the protected surface.
    ///    pDstSurface = Pointer to a surface that receives the encrypted data.
    ///    DstSurfaceSize = The size of the surface memory that <i>pDstSurface</i> points to, in bytes. The size must be aligned to the
    ///                     value of <b>BlockAlignmentSize</b> in the driver capabilities structure; see Remarks.
    ///    pIV = Pointer to a buffer that receives the initialization vector (IV). The caller allocates this buffer, but the
    ///          driver generates the IV. If the encryption type is <b>D3DCRYPTOTYPE_AES128_CTR</b> (128-bit AES-CTR),
    ///          <i>pIV</i> points to a D3DAES_CTR_IV structure. When the driver generates the first IV, it initializes the
    ///          structure to a random number. For each subsequent IV, the driver simply increments the <b>IV</b> member of
    ///          the structure, ensuring that the value always increases. This procedure enables the application to validate
    ///          that the same IV is never used more than once with the same key pair. For other encryption types, a different
    ///          structure might be used, or the encryption might not use an IV.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EncryptionBlt(IDirect3DSurface9 pSrcSurface, IDirect3DSurface9 pDstSurface, uint DstSurfaceSize, 
                          void* pIV);
    ///Writes encrypted data to a protected surface.
    ///Params:
    ///    pSrcSurface = A pointer to the surface that contains the source data.
    ///    pDstSurface = A pointer to the protected surface where the encrypted data is written.
    ///    SrcSurfaceSize = The size of the surface memory that <i>pSrcSurface</i> points to, in bytes. The size must be aligned to the
    ///                     value of <b>BlockAlignmentSize</b> in the driver capabilities structure; see Remarks.
    ///    pEncryptedBlockInfo = A pointer to a D3DENCRYPTED_BLOCK_INFO structure, or <b>NULL</b>. If the driver supports partially encrypted
    ///                          buffers, <i>pEncryptedBlockInfo</i> indicates which portions of the buffer are encrypted. If the entire
    ///                          surface is encrypted, set this parameter to <b>NULL</b>. To check whether the driver supports partially
    ///                          encrypted buffers, call IDirect3DDevice9Video::GetContentProtectionCaps and check for the
    ///                          <b>D3DCPCAPS_PARTIALDECRYPTION</b> capabilities flag. If the driver does not support partially encrypted
    ///                          buffers, set this parameter to <b>NULL</b>.
    ///    pContentKey = A pointer to a buffer that contains a content encryption key, or <b>NULL</b>. To query whether the driver
    ///                  supports the use of content keys, call IDirect3DDevice9Video::GetContentProtectionCaps and check for the
    ///                  <b>D3DCPCAPS_CONTENTKEY</b> capabilities flag. If the driver supports content keys, use the content key to
    ///                  encrypt the surface. Encrypt the content key using the session key, and place the resulting cipher text in
    ///                  <i>pContentKey</i>. If the driver does not support content keys, use the session key to encrypt the surface
    ///                  and set <i>pContentKey</i> to <b>NULL</b>.
    ///    pIV = A pointer to a buffer that contains the initialization vector (IV). If the encryption type is
    ///          <b>D3DCRYPTOTYPE_AES128_CTR</b>, the buffer is a D3DAES_CTR_IV structure. The caller allocates the structure
    ///          and generates the IV. When you generate the first IV, initialize the structure to a random number. For each
    ///          subsequent IV, simply increment the <b>IV</b> member of the structure, ensuring that the value always
    ///          increases. This procedure enables the driver to validate that the same IV is never used more than once with
    ///          the same key pair. For other encryption types, a different structure might be used, or the encryption might
    ///          not use an IV.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT DecryptionBlt(IDirect3DSurface9 pSrcSurface, IDirect3DSurface9 pDstSurface, uint SrcSurfaceSize, 
                          D3DENCRYPTED_BLOCK_INFO* pEncryptedBlockInfo, void* pContentKey, void* pIV);
    ///Gets the stride of a protected surface.
    ///Params:
    ///    pSrcSurface = Pointer to the protected surface.
    ///    pSurfacePitch = Receives the stride, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSurfacePitch(IDirect3DSurface9 pSrcSurface, uint* pSurfacePitch);
    ///Gets a random number that can be used to refresh the session key.
    ///Params:
    ///    pRandomNumber = A pointer to a byte array that receives a random number.
    ///    RandomNumberSize = The size of the <i>pRandomNumber</i> array, in bytes. The size should match the size of the session key.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StartSessionKeyRefresh(void* pRandomNumber, uint RandomNumberSize);
    ///Switches to a new session key.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT FinishSessionKeyRefresh();
    ///Gets the cryptographic key used to decrypt the data returned by the IDirect3DCryptoSession9::EncryptionBlt
    ///method.
    ///Params:
    ///    pReadbackKey = A pointer to a byte array that receives the key. The key is encrypted using the session key.
    ///    KeySize = The size of the <i>pReadbackKey</i> array, in bytes. The size should match the size of the session key.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEncryptionBltKey(void* pReadbackKey, uint KeySize);
}

///Represents a Direct3D 12 video decoder heap that contains resolution-dependent resources and state for performing the
///decode operation.
@GUID("0946B7C9-EBF6-4047-BB73-8683E27DBB1F")
interface ID3D12VideoDecoderHeap : ID3D12Pageable
{
    ///Gets the [D3D12_VIDEO_DECODER_HEAP_DESC](ns-d3d12video-d3d12_video_decoder_heap_desc.md) structure that was
    ///passed into [ID3D12VideoDevice::CreateVideoDecoderHeap](nf-d3d12video-id3d12videodevice-createvideodecoder.md)
    ///when the [ID3D12VideoDecoderHeap](nn-d3d12video-id3d12videodecoderheap.md) was created.
    ///Returns:
    ///    This method returns a **D3D12_VIDEO_DECODER_HEAP_DESC** structure.
    ///    
    D3D12_VIDEO_DECODER_HEAP_DESC GetDesc();
}

///Provides video decoding and processing capabilities of a Microsoft Direct3D 12 device including the ability to query
///video capabilities and instantiating video decoders and processors.
@GUID("1F052807-0B46-4ACC-8A89-364F793718A4")
interface ID3D12VideoDevice : IUnknown
{
    ///Gets information about the features that are supported by the current video driver.
    ///Params:
    ///    FeatureVideo = A member of the [D3D12\_FEATURE\_VIDEO](ne-d3d12video-d3d12_feature_video.md) enumeration that specifies the
    ///                   feature to query for support.
    ///    pFeatureSupportData = A structure that contains data that describes the configuration details of the feature for which support is
    ///                          requested and, upon the completion of the call, is populated with details about the level of support
    ///                          available. For information on the structure that is associated with each type of feature support request, see
    ///                          the field descriptions for [D3D12\_FEATURE\_VIDEO](ne-d3d12video-d3d12_feature_video.md).
    ///    FeatureSupportDataSize = The size of the structure passed to the *pFeatureSupportData* parameter.
    ///Returns:
    ///    Returns **S\_OK** if successful; otherwise, returns **E\_INVALIDARG** if an unsupported data type is passed
    ///    to the *pFeatureSupportData* parameter or a size mismatch is detected for the *FeatureSupportDataSize*
    ///    parameter.
    ///    
    HRESULT CheckFeatureSupport(D3D12_FEATURE_VIDEO FeatureVideo, void* pFeatureSupportData, 
                                uint FeatureSupportDataSize);
    ///Creates a video decoder instance that contains the resolution-independent driver resources and state.
    ///Params:
    ///    pDesc = A pointer to a [D3D12\_VIDEO\_DECODER\_DESC](ns-d3d12video-d3d12_video_decoder_desc.md) structure describing
    ///            the decode profile and bitstream encryption for the decoder.
    ///    riid = The globally unique identifier (GUID) for the decode video state interface.
    ///    ppVideoDecoder = A pointer to a memory block that receives a pointer to the
    ///                     [ID3D12VideoDecoder](nn-d3d12video-id3d12videodecoder.md) interface.
    ///Returns:
    ///    This method returns HRESULT.
    ///    
    HRESULT CreateVideoDecoder(const(D3D12_VIDEO_DECODER_DESC)* pDesc, const(GUID)* riid, void** ppVideoDecoder);
    ///Allocates a video decoder heap that contains the resolution-dependent driver resources and state.
    ///Params:
    ///    pVideoDecoderHeapDesc = A pointer to a [D3D12\_VIDEO\_DECODER\_HEAP\_DESC](ns-d3d12video-d3d12_video_decoder_heap_desc.md) describing
    ///                            the decoding configuration.
    ///    riid = The globally unique identifier (GUID) for the decode video state interface.
    ///    ppVideoDecoderHeap = A pointer to a memory block that receives a pointer to the
    ///                         [ID3D12VideoDecoderHeap](nn-d3d12video-id3d12videodecoderheap.md) interface.
    ///Returns:
    ///    This method returns an HRESULT.
    ///    
    HRESULT CreateVideoDecoderHeap(const(D3D12_VIDEO_DECODER_HEAP_DESC)* pVideoDecoderHeapDesc, const(GUID)* riid, 
                                   void** ppVideoDecoderHeap);
    ///Creates a video processor instance.
    ///Params:
    ///    NodeMask = The node mask specifying the physical adapter on which the video processor will be used. For single GPU
    ///               operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node, i.e. the
    ///               device's physical adapter, to which the command queue applies. Each bit in the mask corresponds to a single
    ///               node. Only 1 bit may be set.
    ///    pOutputStreamDesc = A pointer to a
    ///                        D3D12\_VIDEO\_PROCESS\_OUTPUT\_STREAM\_DESC(ns-d3d12video-d3d12_video_process_output_stream_desc) structure
    ///                        describing the output stream.
    ///    NumInputStreamDescs = The number of input streams provided in the *pInputStreamDescs* parameter.
    ///    pInputStreamDescs = A pointer to a list of
    ///                        D3D12\_VIDEO\_PROCESS\_INPUT\_STREAM\_DESC(ns-d3d12video-d3d12_video_process_input_stream_desc) structures
    ///                        the input streams. The number of structures provided should match the value specified in the
    ///                        *NumInputStreamDescs* parameter.
    ///    riid = The globally unique identifier (GUID) for the video processor interface.
    ///    ppVideoProcessor = A pointer to a memory block that receives a pointer to the
    ///                       [ID3D12VideoProcessor](nn-d3d12video-id3d12videoprocessor.md) interface
    ///Returns:
    ///    This method returns HRESULT.
    ///    
    HRESULT CreateVideoProcessor(uint NodeMask, const(D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC)* pOutputStreamDesc, 
                                 uint NumInputStreamDescs, 
                                 const(D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC)* pInputStreamDescs, const(GUID)* riid, 
                                 void** ppVideoProcessor);
}

///Represents a Direct3D 12 video decoder that contains resolution-independent resources and state for performing the
///decode operation.
@GUID("C59B6BDC-7720-4074-A136-17A156037470")
interface ID3D12VideoDecoder : ID3D12Pageable
{
    ///Gets the [D3D12_VIDEO_DECODER_DESC](ns-d3d12video-d3d12_video_decoder_desc.md) structure that was passed into
    ///[ID3D12VideoDevice::CreateVideoDecoder](nf-d3d12video-id3d12videodevice-createvideodecoder.md) when the
    ///[ID3D12VideoDecoder](nn-d3d12video-id3d12videodecoder.md) was created.
    ///Returns:
    ///    This method returns a **D3D12_VIDEO_DECODER_DESC** structure.
    ///    
    D3D12_VIDEO_DECODER_DESC GetDesc();
}

///Provides methods for getting information about the parameters to the call to
///[ID3D12VideoDevice::CreateVideoProcessor](nf-d3d12video-id3d12videodevice-createvideoprocessor.md) that created the
///video processor.
@GUID("304FDB32-BEDE-410A-8545-943AC6A46138")
interface ID3D12VideoProcessor : ID3D12Pageable
{
    ///The node mask specifying the physical adapter on which the video processor will be used.
    ///Returns:
    ///    This method returns a UINT.
    ///    
    uint    GetNodeMask();
    ///Gets the number of input stream descriptions provided when the video processor was created with a call to
    ///[ID3D12VideoDevice::CreateVideoProcessor](nf-d3d12video-id3d12videodevice-createvideoprocessor.md).
    ///Returns:
    ///    This method returns UINT. Use this value to determine the correct size of the array you pass in the
    ///    *pInputStreamDescs* parameter to
    ///    [ID3D12VideoProcessor::GetInputStreamDescs](nf-d3d12video-id3d12videoprocessor-getinputstreamdescs.md).
    ///    
    uint    GetNumInputStreamDescs();
    ///Gets the input stream descriptions provided when the video processor was created with a call to
    ///[ID3D12VideoDevice::CreateVideoProcessor](nf-d3d12video-id3d12videodevice-createvideoprocessor.md).
    ///Params:
    ///    NumInputStreamDescs = The size of the array pointed to by *pInputStreamDescs*. Get the number of input stream descriptions
    ///                          associated with the video processor by calling
    ///                          [ID3DVideoProcessor::GetNumInputStreamDescs](nf-d3d12video-id3d12videoprocessor-getnuminputstreamdescs.md).
    ///    pInputStreamDescs = An array of [D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC](ns-d3d12video-d3d12_video_process_input_stream_desc.md)
    ///                        structures that is populated with the input stream descriptions associated with the video processor.
    ///Returns:
    ///    This method returns HRESULT.
    ///    
    HRESULT GetInputStreamDescs(uint NumInputStreamDescs, D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC* pInputStreamDescs);
    ///Gets the output stream description provided when the video processor was created with a call to
    ///[ID3D12VideoDevice::CreateVideoProcessor](nf-d3d12video-id3d12videodevice-createvideoprocessor.md).
    ///Returns:
    ///    This method returns
    ///    [D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC](ns-d3d12video-d3d12_video_process_output_stream_desc.md).
    ///    
    D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC GetOutputStreamDesc();
}

///Encapsulates a list of graphics commands for video decoding. This interface is inherited by
///[ID3D12VideoDecodeCommandList1](nn-d3d12video-id3d12videodecodecommandlist1.md).
@GUID("3B60536E-AD29-4E64-A269-F853837E5E53")
interface ID3D12VideoDecodeCommandList : ID3D12CommandList
{
    ///Indicates that recording to the command list has finished.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful; otherwise, returns one of the following values: <ul>
    ///    <li><b>E_FAIL</b> if the command list has already been closed, or an invalid API was called during command
    ///    list recording. </li> <li><b>E_OUTOFMEMORY</b> if the operating system ran out of memory during recording.
    ///    </li> <li><b>E_INVALIDARG</b> if an invalid argument was passed to the command list API during recording.
    ///    </li> </ul> See Direct3D 12 Return Codes for other possible return values.
    ///    
    HRESULT Close();
    ///Resets a command list back to its initial state as if a new command list was just created.
    ///Params:
    ///    pAllocator = Type: <b>ID3D12CommandAllocator*</b> A pointer to the ID3D12CommandAllocator object that the device creates
    ///                 command lists from.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful; otherwise, returns one of the following values: <ul>
    ///    <li><b>E_FAIL</b> if the command list was not in the "closed" state when the <b>Reset</b> call was made, or
    ///    the per-device limit would have been exceeded. </li> <li><b>E_OUTOFMEMORY</b> if the operating system ran out
    ///    of memory. </li> <li><b>E_INVALIDARG</b> if the allocator is currently being used with another command list
    ///    in the "recording" state or if the specified allocator was created with the wrong type. </li> </ul> See
    ///    Direct3D 12 Return Codes for other possible return values.
    ///    
    HRESULT Reset(ID3D12CommandAllocator pAllocator);
    ///Resets the state of a direct command list back to the state it was in when the command list was created.
    void    ClearState();
    ///Notifies the driver that it needs to synchronize multiple accesses to resources.
    ///Params:
    ///    NumBarriers = Type: <b>UINT</b> The number of submitted barrier descriptions.
    ///    pBarriers = Type: <b>const D3D12_RESOURCE_BARRIER*</b> Pointer to an array of barrier descriptions.
    void    ResourceBarrier(uint NumBarriers, const(D3D12_RESOURCE_BARRIER)* pBarriers);
    ///Indicate that the current contents of a resource can be discarded. The current contents of the resource are no
    ///longer valid allowing optimizations for subsequent operations such as
    ///[ResourceBarrier](nf-d3d12video-id3d12videodecodecommandlist-discardresource.md).
    ///Params:
    ///    pResource = A pointer to the ID3D12Resource interface for the resource to discard.
    ///    pRegion = A pointer to a D3D12_DISCARD_REGION structure that describes details for the discard-resource operation.
    void    DiscardResource(ID3D12Resource pResource, const(D3D12_DISCARD_REGION)* pRegion);
    ///Starts a query running.
    ///Params:
    ///    pQueryHeap = A pointer to an [ID3D12QueryHeap](/windows/desktop/api/d3d12/nn-d3d12-id3d12queryheap) specifying the storage
    ///                 for this query.
    ///    Type = A member of the [D3D12_QUERY_TYPE](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type) enumeration
    ///           specifying the type of the query.
    ///    Index = The index of the query within the query heap.
    void    BeginQuery(ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint Index);
    ///Ends a query.
    ///Params:
    ///    pQueryHeap = A pointer to an [ID3D12QueryHeap](/windows/desktop/api/d3d12/nn-d3d12-id3d12queryheap) specifying the storage
    ///                 for this query.
    ///    Type = A member of the [D3D12_QUERY_TYPE](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type) enumeration
    ///           specifying the type of the query.
    ///    Index = The index of the query within the query heap.
    void    EndQuery(ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint Index);
    ///Extracts data from a query.
    ///Params:
    ///    pQueryHeap = A pointer to an [ID3D12QueryHeap](/windows/desktop/api/d3d12/nn-d3d12-id3d12queryheap) specifying the storage
    ///                 containing the queries to resolve.
    ///    Type = A member of the [D3D12_QUERY_TYPE](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type) enumeration
    ///           specifying the type of the query.
    ///    StartIndex = The index of the first query to resolve.
    ///    NumQueries = The number of queries to resolve.
    ///    pDestinationBuffer = A pointer to an [ID3D12Resource](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) representing the
    ///                         destination buffer. The resource must be in the state
    ///                         [D3D12_RESOURCE_STATE_COPY_DEST](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_states).
    ///    AlignedDestinationBufferOffset = The alignment offset into the destination buffer. This must be a multiple of 8 bytes.
    void    ResolveQueryData(ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint StartIndex, uint NumQueries, 
                             ID3D12Resource pDestinationBuffer, ulong AlignedDestinationBufferOffset);
    ///Specifies that subsequent commands should not be performed if the predicate value passes the specified operation.
    ///Params:
    ///    pBuffer = A pointer to an [ID3D12Resource](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) representing the buffer
    ///              from which to read the 64-bit predication value.
    ///    AlignedBufferOffset = The UINT64-aligned buffer offset.
    ///    Operation = A member of the [D3D12_PREDICATION_OP](/windows/desktop/api/d3d12/ne-d3d12-d3d12_predication_op) enumeration
    ///                specifying the predicate operation.
    void    SetPredication(ID3D12Resource pBuffer, ulong AlignedBufferOffset, D3D12_PREDICATION_OP Operation);
    ///For internal use only. Not intended to be called directly.
    ///Params:
    ///    Metadata = Internal.
    ///    pData = Internal.
    ///    Size = Internal.
    void    SetMarker(uint Metadata, const(void)* pData, uint Size);
    ///For internal use only. Not intended to be called directly.
    ///Params:
    ///    Metadata = Internal.
    ///    pData = Internal.
    ///    Size = Internal.
    void    BeginEvent(uint Metadata, const(void)* pData, uint Size);
    ///For internal use only. Not intended to be called directly.
    void    EndEvent();
    ///Records a decode frame operation to the command list. Inputs, outputs, and parameters for the decode are
    ///specified as arguments to this method.
    ///Params:
    ///    pDecoder = A pointer to an [ID3D12VideoDecoder](nn-d3d12video-id3d12videodecoder.md) interface representing a decoder
    ///               instance.
    ///    pOutputArguments = A [D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS](ns-d3d12video-d3d12_video_decode_output_stream_arguments.md)
    ///                       structure specifying the output surface and output arguments.
    ///    pInputArguments = A [D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS](ns-d3d12video-d3d12_video_decode_input_stream_arguments.md)
    ///                      structure specifying the input bitstream, reference frames, and other input parameters.
    void    DecodeFrame(ID3D12VideoDecoder pDecoder, 
                        const(D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS)* pOutputArguments, 
                        const(D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS)* pInputArguments);
    ///Writes a number of 32-bit immediate values to the specified buffer locations directly from the command stream.
    ///Params:
    ///    Count = The number of elements in the *pParams* and *pModes* arrays.
    ///    pParams = The address of an array of
    ///              [D3D12_WRITEBUFFERIMMEDIATE_PARAMETER](/windows/desktop/api/d3d12/ns-d3d12-d3d12_writebufferimmediate_parameter)
    ///              structures of size *Count*.
    ///    pModes = The address of an array of
    ///             [D3D12_WRITEBUFFERIMMEDIATE_MODE](/windows/desktop/api/d3d12/ne-d3d12-d3d12_writebufferimmediate_mode)
    ///             structures of size *Count*. The default value is <b>null</b>. Passing <b>null</b> causes the system to write
    ///             all immediate values using **D3D12_WRITEBUFFERIMMEDIATE_MODE_DEFAULT**.
    void    WriteBufferImmediate(uint Count, const(D3D12_WRITEBUFFERIMMEDIATE_PARAMETER)* pParams, 
                                 const(D3D12_WRITEBUFFERIMMEDIATE_MODE)* pModes);
}

///Encapsulates a list of graphics commands for video processing. This interface is inherited by
///[ID3D12VideoProcessCommandList1](nn-d3d12video-id3d12videoprocesscommandlist1.md).
@GUID("AEB2543A-167F-4682-ACC8-D159ED4A6209")
interface ID3D12VideoProcessCommandList : ID3D12CommandList
{
    ///Indicates that recording to the command list has finished.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful; otherwise, returns one of the following values: <ul>
    ///    <li><b>E_FAIL</b> if the command list has already been closed, or an invalid API was called during command
    ///    list recording. </li> <li><b>E_OUTOFMEMORY</b> if the operating system ran out of memory during recording.
    ///    </li> <li><b>E_INVALIDARG</b> if an invalid argument was passed to the command list API during recording.
    ///    </li> </ul> See Direct3D 12 Return Codes for other possible return values.
    ///    
    HRESULT Close();
    ///Resets a command list back to its initial state as if a new command list was just created.
    ///Params:
    ///    pAllocator = Type: <b>ID3D12CommandAllocator*</b> A pointer to the ID3D12CommandAllocator object that the device creates
    ///                 command lists from.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful; otherwise, returns one of the following values: <ul>
    ///    <li><b>E_FAIL</b> if the command list was not in the "closed" state when the <b>Reset</b> call was made, or
    ///    the per-device limit would have been exceeded. </li> <li><b>E_OUTOFMEMORY</b> if the operating system ran out
    ///    of memory. </li> <li><b>E_INVALIDARG</b> if the allocator is currently being used with another command list
    ///    in the "recording" state or if the specified allocator was created with the wrong type. </li> </ul> See
    ///    Direct3D 12 Return Codes for other possible return values.
    ///    
    HRESULT Reset(ID3D12CommandAllocator pAllocator);
    ///Resets the state of a direct command list back to the state it was in when the command list was created.
    void    ClearState();
    ///Notifies the driver that it needs to synchronize multiple accesses to resources.
    ///Params:
    ///    NumBarriers = Type: <b>UINT</b> The number of submitted barrier descriptions.
    ///    pBarriers = Type: <b>const D3D12_RESOURCE_BARRIER*</b> Pointer to an array of barrier descriptions.
    void    ResourceBarrier(uint NumBarriers, const(D3D12_RESOURCE_BARRIER)* pBarriers);
    ///Indicates that the current contents of a resource can be discarded. The current contents of the resource are no
    ///longer valid allowing optimizations for subsequent operations such as
    ///[ResourceBarrier](nf-d3d12video-id3d12videoprocesscommandlist-discardresource.md).
    ///Params:
    ///    pResource = A pointer to the ID3D12Resource interface for the resource to discard.
    ///    pRegion = A pointer to a D3D12_DISCARD_REGION structure that describes details for the discard-resource operation.
    void    DiscardResource(ID3D12Resource pResource, const(D3D12_DISCARD_REGION)* pRegion);
    ///Starts a query running.
    ///Params:
    ///    pQueryHeap = A pointer to an [ID3D12QueryHeap](/windows/desktop/api/d3d12/nn-d3d12-id3d12queryheap) specifying the storage
    ///                 for this query.
    ///    Type = A member of the [D3D12_QUERY_TYPE](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type) enumeration
    ///           specifying the type of the query.
    ///    Index = The index of the query within the query heap.
    void    BeginQuery(ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint Index);
    ///Ends a query.
    ///Params:
    ///    pQueryHeap = A pointer to an [ID3D12QueryHeap](/windows/desktop/api/d3d12/nn-d3d12-id3d12queryheap) specifying the storage
    ///                 for this query.
    ///    Type = A member of the [D3D12_QUERY_TYPE](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type) enumeration
    ///           specifying the type of the query.
    ///    Index = The index of the query within the query heap.
    void    EndQuery(ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint Index);
    ///Extracts data from a query.
    ///Params:
    ///    pQueryHeap = A pointer to an [ID3D12QueryHeap](/windows/desktop/api/d3d12/nn-d3d12-id3d12queryheap) specifying the storage
    ///                 containing the queries to resolve.
    ///    Type = A member of the [D3D12_QUERY_TYPE](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type) enumeration
    ///           specifying the type of the query.
    ///    StartIndex = The index of the first query to resolve.
    ///    NumQueries = The number of queries to resolve.
    ///    pDestinationBuffer = A pointer to an [ID3D12Resource](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) representing the
    ///                         destination buffer. The resource must be in the state
    ///                         [D3D12_RESOURCE_STATE_COPY_DEST](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_states).
    ///    AlignedDestinationBufferOffset = The alignment offset into the destination buffer. This must be a multiple of 8 bytes.
    void    ResolveQueryData(ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint StartIndex, uint NumQueries, 
                             ID3D12Resource pDestinationBuffer, ulong AlignedDestinationBufferOffset);
    ///Specifies that subsequent commands should not be performed if the predicate value passes the specified operation.
    ///Params:
    ///    pBuffer = A pointer to an [ID3D12Resource](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) representing the buffer
    ///              from which to read the 64-bit predication value.
    ///    AlignedBufferOffset = The UINT64-aligned buffer offset.
    ///    Operation = A member of the [D3D12_PREDICATION_OP](/windows/desktop/api/d3d12/ne-d3d12-d3d12_predication_op) enumeration
    ///                specifying the predicate operation.
    void    SetPredication(ID3D12Resource pBuffer, ulong AlignedBufferOffset, D3D12_PREDICATION_OP Operation);
    ///For internal use only. Not intended to be called directly.
    ///Params:
    ///    Metadata = Internal.
    ///    pData = Internal.
    ///    Size = Internal.
    void    SetMarker(uint Metadata, const(void)* pData, uint Size);
    ///For internal use only. Not intended to be called directly.
    ///Params:
    ///    Metadata = Internal.
    ///    pData = Internal.
    ///    Size = Internal.
    void    BeginEvent(uint Metadata, const(void)* pData, uint Size);
    ///For internal use only. Not intended to be called directly.
    void    EndEvent();
    ///Records a video processing operation to the command list, operating on one or more input samples and writing the
    ///result to an output surface. > [!NOTE] > This version of the method does not allow you to change the
    ///[D3D12_VIDEO_FIELD_TYPE](ne-d3d12video-d3d12_video_field_type.md) without recreating the interface. It is
    ///recommended that you use
    ///[ID3D12VideoProcessCommandList::ProcessFrames1](nf-d3d12video-id3d12videoprocesscommandlist1-processframes1.md)
    ///instead, which allows you to change the field type with each call.
    ///Params:
    ///    pVideoProcessor = A pointer to an [ID3D12VideoProcessor](nn-d3d12video-id3d12videoprocessor.md) interface representing a video
    ///                      processor instance.
    ///    pOutputArguments = A [D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS](ns-d3d12video-d3d12_video_process_output_stream_arguments.md)
    ///                       structure specifying the output surface and output arguments.
    ///    NumInputStreams = The count of input streams.
    ///    pInputArguments = A pointer to an array of
    ///                      [D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS](ns-d3d12video-d3d12_video_process_input_stream_arguments.md)
    ///                      structures specifying the input parameters.
    void    ProcessFrames(ID3D12VideoProcessor pVideoProcessor, 
                          const(D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS)* pOutputArguments, uint NumInputStreams, 
                          const(D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS)* pInputArguments);
    ///Writes a number of 32-bit immediate values to the specified buffer locations directly from the command stream.
    ///Params:
    ///    Count = The number of elements in the *pParams* and *pModes* arrays.
    ///    pParams = The address of an array of
    ///              [D3D12_WRITEBUFFERIMMEDIATE_PARAMETER](/windows/desktop/api/d3d12/ns-d3d12-d3d12_writebufferimmediate_parameter)
    ///              structures of size *Count*.
    ///    pModes = The address of an array of
    ///             [D3D12_WRITEBUFFERIMMEDIATE_MODE](/windows/desktop/api/d3d12/ne-d3d12-d3d12_writebufferimmediate_mode)
    ///             structures of size *Count*. The default value is <b>null</b>. Passing <b>null</b> causes the system to write
    ///             all immediate values using **D3D12_WRITEBUFFERIMMEDIATE_MODE_DEFAULT**.
    void    WriteBufferImmediate(uint Count, const(D3D12_WRITEBUFFERIMMEDIATE_PARAMETER)* pParams, 
                                 const(D3D12_WRITEBUFFERIMMEDIATE_MODE)* pModes);
}

///Encapsulates a list of graphics commands for video decoding. This interface inherits from
///[ID3D12VideoDecodeCommandList](nn-d3d12video-id3d12videodecodecommandlist.md) and adds support for video decode
///histograms.
@GUID("D52F011B-B56E-453C-A05A-A7F311C8F472")
interface ID3D12VideoDecodeCommandList1 : ID3D12VideoDecodeCommandList
{
    ///Records a decode frame operation to the command list. Inputs, outputs, and parameters for the decode are
    ///specified as arguments to this method. Takes a
    ///[D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1](ns-d3d12video-d3d12_video_decode_output_stream_arguments1.md)
    ///structure to support video decode histograms.
    ///Params:
    ///    pDecoder = A pointer to an [ID3D12VideoDecoder](nn-d3d12video-id3d12videodecoder.md) interface representing a decoder
    ///               instance.
    ///    pOutputArguments = A [D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1](ns-d3d12video-d3d12_video_decode_output_stream_arguments1.md)
    ///                       structure specifying the output surface and output arguments.
    ///    pInputArguments = A [D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS](ns-d3d12video-d3d12_video_decode_input_stream_arguments.md)
    ///                      structure specifying the input bitstream, reference frames, and other input parameters.
    void DecodeFrame1(ID3D12VideoDecoder pDecoder, 
                      const(D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1)* pOutputArguments, 
                      const(D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS)* pInputArguments);
}

///Encapsulates a list of graphics commands for video processing. Adds the
///[ID3D12VideoProcessCommandList1::ProcessFrames1](nf-d3d12video-id3d12videoprocesscommandlist1-processframes1.md)
///method which supports changing the [D3D12_VIDEO_FIELD_TYPE](ne-d3d12video-d3d12_video_field_type.md) for each call,
///unlike [ID3D12VideoProcessCommandList::ProcessFrames](nf-d3d12video-id3d12videoprocesscommandlist-processframes.md).
@GUID("542C5C4D-7596-434F-8C93-4EFA6766F267")
interface ID3D12VideoProcessCommandList1 : ID3D12VideoProcessCommandList
{
    ///Records a video processing operation to the command list, operating on one or more input samples and writing the
    ///result to an output surface. This version of the method supports changing the
    ///[D3D12_VIDEO_FIELD_TYPE](ne-d3d12video-d3d12_video_field_type.md) for each call, unlike
    ///[ID3D12VideoProcessCommandList::ProcessFrames](nf-d3d12video-id3d12videoprocesscommandlist-processframes.md).
    ///Params:
    ///    pVideoProcessor = A pointer to an [ID3D12VideoProcessor](nn-d3d12video-id3d12videoprocessor.md) interface representing a video
    ///                      processor instance.
    ///    pOutputArguments = A [D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS](ns-d3d12video-d3d12_video_process_output_stream_arguments.md)
    ///                       structure specifying the output surface and output arguments.
    ///    NumInputStreams = The count of input streams.
    ///    pInputArguments = A pointer to an array of
    ///                      [D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1](ns-d3d12video-d3d12_video_process_input_stream_arguments1.md)
    ///                      structures specifying the input parameters.
    void ProcessFrames1(ID3D12VideoProcessor pVideoProcessor, 
                        const(D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS)* pOutputArguments, uint NumInputStreams, 
                        const(D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1)* pInputArguments);
}

///This interface maintains context for video motion estimation operations.
@GUID("33FDAE0E-098B-428F-87BB-34B695DE08F8")
interface ID3D12VideoMotionEstimator : ID3D12Pageable
{
    ///Gets the [D3D12_VIDEO_MOTION_ESTIMATOR_DESC](ns-d3d12video-d3d12_video_motion_estimator_desc.md) structure that
    ///was passed into
    ///[ID3D12VideoDevice1::CreateVideoMotionEstimator](nf-d3d12video-id3d12videodevice1-createvideomotionestimator.md)
    ///when the [ID3D12VideoMotionEstimator](nn-d3d12video-id3d12videomotionestimator.md) was created.
    ///Returns:
    ///    This method returns a **D3D12_VIDEO_MOTION_ESTIMATOR_DESC** structure.
    ///    
    D3D12_VIDEO_MOTION_ESTIMATOR_DESC GetDesc();
    ///Gets the [ID3D12ProtectedResourceSession](../d3d12/nn-d3d12-id3d12protectedresourcesession.md) that was passed
    ///into
    ///[ID3D12VideoDevice1::CreateVideoMotionEstimator](nf-d3d12video-id3d12videodevice1-createvideomotionestimator.md)
    ///when the [ID3D12VideoMotionEstimator](nn-d3d12video-id3d12videomotionestimator.md) was created.
    ///Params:
    ///    riid = The globally unique identifier (GUID) for the **ID3D12ProtectedResourceSession** interface.
    ///    ppProtectedSession = Receives a void pointer representing the **ID3D12ProtectedResourceSession** interface.
    ///Returns:
    ///    This method returns HRESULT.
    ///    
    HRESULT GetProtectedResourceSession(const(GUID)* riid, void** ppProtectedSession);
}

///Represents the storage of the motion vector output of a motion estimation operation in an IHV-dependent layout. Call
///[ID3D12VideoEncodeCommandList::EstimateMotion](nf-d3d12video-id3d12videoencodecommandlist-estimatemotion.md) to
///calculate and store motion vectors. Use
///[ID3D12VideoEncodeCommandList::ResolveMotionVectorHeap](nf-d3d12video-id3d12videoencodecommandlist-resolvemotionvectorheap.md)
///to copy and translate these results into the API-defined layout in a Texture 2D.
@GUID("5BE17987-743A-4061-834B-23D22DAEA505")
interface ID3D12VideoMotionVectorHeap : ID3D12Pageable
{
    ///Gets the [D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC](ns-d3d12video-d3d12_video_motion_vector_heap_desc.md) structure
    ///that was passed into
    ///[ID3D12VideoDevice1::CreateVideoMotionEstimatorHeap](nf-d3d12video-id3d12videodevice1-createvideomotionvectorheap.md)
    ///when the [ID3D12VideoMotionEstimatorHeap](nn-d3d12video-id3d12videomotionvectorheap.md) was created.
    ///Returns:
    ///    This method returns a **D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC** structure.
    ///    
    D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC GetDesc();
    ///Gets the [ID3D12ProtectedResourceSession](../d3d12/nn-d3d12-id3d12protectedresourcesession.md) that was passed
    ///into
    ///[ID3D12VideoDevice1::CreateVideoMotionEstimatorHeap](nf-d3d12video-id3d12videodevice1-createvideomotionvectorheap.md)
    ///when the [ID3D12VideoMotionEstimatorHeap](nn-d3d12video-id3d12videomotionvectorheap.md) was created.
    ///Params:
    ///    riid = The globally unique identifier (GUID) for the **ID3D12ProtectedResourceSession** interface.
    ///    ppProtectedSession = Receives a void pointer representing the **ID3D12ProtectedResourceSession** interface.
    ///Returns:
    ///    This method returns HRESULT.
    ///    
    HRESULT GetProtectedResourceSession(const(GUID)* riid, void** ppProtectedSession);
}

///Provides video decoding and processing capabilities of a Microsoft Direct3D 12 device including the ability to query
///video capabilities and instantiating video decoders and processors. This interface adds support for motion
///estimation.
@GUID("981611AD-A144-4C83-9890-F30E26D658AB")
interface ID3D12VideoDevice1 : ID3D12VideoDevice
{
    ///Creates an [ID3D12VideoMotionEstimator](nn-d3d12video-id3d12videomotionestimator.md), which maintains context for
    ///video motion estimation operations.
    ///Params:
    ///    pDesc = A [D3D12_VIDEO_MOTION_ESTIMATOR_DESC](ns-d3d12video-d3d12_video_motion_estimator_desc.md) describing the
    ///            parameters used for motion estimation. This structure contains both input and output fields.
    ///    pProtectedResourceSession = A [ID3D12ProtectedResourceSession](../d3d12/nn-d3d12-id3d12protectedresourcesession.md) for managing access
    ///                                to protected resources.
    ///    riid = The globally unique identifier (GUID) for the **ID3D12VideoMotionEstimator** interface.
    ///    ppVideoMotionEstimator = A pointer to a memory block that receives a pointer to the **ID3D12VideoMotionEstimator** interface.
    ///Returns:
    ///    This method returns HRESULT.
    ///    
    HRESULT CreateVideoMotionEstimator(const(D3D12_VIDEO_MOTION_ESTIMATOR_DESC)* pDesc, 
                                       ID3D12ProtectedResourceSession pProtectedResourceSession, const(GUID)* riid, 
                                       void** ppVideoMotionEstimator);
    ///Allocates heap that contains motion vectors for video motion estimation.
    ///Params:
    ///    pDesc = A pointer to a [D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC](ns-d3d12video-d3d12_video_motion_vector_heap_desc.md)
    ///            describing the format of the heap. This structure contains both input and output fields.
    ///    pProtectedResourceSession = A [ID3D12ProtectedResourceSession](../d3d12/nn-d3d12-id3d12protectedresourcesession.md) for managing access
    ///                                to protected resources.
    ///    riid = The globally unique identifier (GUID) for the **ID3D12VideoMotionVectorHeap** interface.
    ///    ppVideoMotionVectorHeap = A pointer to a memory block that receives a pointer to the **ID3D12VideoMotionVectorHeap** interface.
    ///Returns:
    ///    This method returns HRESULT.
    ///    
    HRESULT CreateVideoMotionVectorHeap(const(D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC)* pDesc, 
                                        ID3D12ProtectedResourceSession pProtectedResourceSession, const(GUID)* riid, 
                                        void** ppVideoMotionVectorHeap);
}

///Encapsulates a list of graphics commands for video encoding, including motion estimation.
@GUID("8455293A-0CBD-4831-9B39-FBDBAB724723")
interface ID3D12VideoEncodeCommandList : ID3D12CommandList
{
    ///Indicates that recording to the command list has finished.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful; otherwise, returns one of the following values: <ul>
    ///    <li><b>E_FAIL</b> if the command list has already been closed, or an invalid API was called during command
    ///    list recording. </li> <li><b>E_OUTOFMEMORY</b> if the operating system ran out of memory during recording.
    ///    </li> <li><b>E_INVALIDARG</b> if an invalid argument was passed to the command list API during recording.
    ///    </li> </ul> See Direct3D 12 Return Codes for other possible return values.
    ///    
    HRESULT Close();
    ///Resets a command list back to its initial state as if a new command list was just created.
    ///Params:
    ///    pAllocator = Type: <b>ID3D12CommandAllocator*</b> A pointer to the ID3D12CommandAllocator object that the device creates
    ///                 command lists from.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns <b>S_OK</b> if successful; otherwise, returns one of the following values: <ul>
    ///    <li><b>E_FAIL</b> if the command list was not in the "closed" state when the <b>Reset</b> call was made, or
    ///    the per-device limit would have been exceeded. </li> <li><b>E_OUTOFMEMORY</b> if the operating system ran out
    ///    of memory. </li> <li><b>E_INVALIDARG</b> if the allocator is currently being used with another command list
    ///    in the "recording" state or if the specified allocator was created with the wrong type. </li> </ul> See
    ///    Direct3D 12 Return Codes for other possible return values.
    ///    
    HRESULT Reset(ID3D12CommandAllocator pAllocator);
    ///Resets the state of a direct command list back to the state it was in when the command list was created.
    void    ClearState();
    ///Notifies the driver that it needs to synchronize multiple accesses to resources.
    ///Params:
    ///    NumBarriers = Type: <b>UINT</b> The number of submitted barrier descriptions.
    ///    pBarriers = Type: <b>const D3D12_RESOURCE_BARRIER*</b> Pointer to an array of barrier descriptions.
    void    ResourceBarrier(uint NumBarriers, const(D3D12_RESOURCE_BARRIER)* pBarriers);
    ///Indicate that the current contents of a resource can be discarded. The current contents of the resource are no
    ///longer valid allowing optimizations for subsequent operations such as
    ///[ResourceBarrier](nf-d3d12video-id3d12videodecodecommandlist-discardresource.md).
    ///Params:
    ///    pResource = A pointer to the ID3D12Resource interface for the resource to discard.
    ///    pRegion = A pointer to a D3D12_DISCARD_REGION structure that describes details for the discard-resource operation.
    void    DiscardResource(ID3D12Resource pResource, const(D3D12_DISCARD_REGION)* pRegion);
    ///Starts a query running.
    ///Params:
    ///    pQueryHeap = A pointer to an [ID3D12QueryHeap](/windows/desktop/api/d3d12/nn-d3d12-id3d12queryheap) specifying the storage
    ///                 for this query.
    ///    Type = A member of the [D3D12_QUERY_TYPE](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type) enumeration
    ///           specifying the type of the query.
    ///    Index = The index of the query within the query heap.
    void    BeginQuery(ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint Index);
    ///Ends a query.
    ///Params:
    ///    pQueryHeap = A pointer to an [ID3D12QueryHeap](/windows/desktop/api/d3d12/nn-d3d12-id3d12queryheap) specifying the storage
    ///                 for this query.
    ///    Type = A member of the [D3D12_QUERY_TYPE](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type) enumeration
    ///           specifying the type of the query.
    ///    Index = The index of the query within the query heap.
    void    EndQuery(ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint Index);
    ///Extracts data from a query.
    ///Params:
    ///    pQueryHeap = A pointer to an [ID3D12QueryHeap](/windows/desktop/api/d3d12/nn-d3d12-id3d12queryheap) specifying the storage
    ///                 containing the queries to resolve.
    ///    Type = A member of the [D3D12_QUERY_TYPE](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type) enumeration
    ///           specifying the type of the query.
    ///    StartIndex = The index of the first query to resolve.
    ///    NumQueries = The number of queries to resolve.
    ///    pDestinationBuffer = A pointer to an [ID3D12Resource](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) representing the
    ///                         destination buffer. The resource must be in the state
    ///                         [D3D12_RESOURCE_STATE_COPY_DEST](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_states).
    ///    AlignedDestinationBufferOffset = The alignment offset into the destination buffer. This must be a multiple of 8 bytes.
    void    ResolveQueryData(ID3D12QueryHeap pQueryHeap, D3D12_QUERY_TYPE Type, uint StartIndex, uint NumQueries, 
                             ID3D12Resource pDestinationBuffer, ulong AlignedDestinationBufferOffset);
    ///Specifies that subsequent commands should not be performed if the predicate value passes the specified operation.
    ///Params:
    ///    pBuffer = A pointer to an [ID3D12Resource](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) representing the buffer
    ///              from which to read the 64-bit predication value.
    ///    AlignedBufferOffset = The UINT64-aligned buffer offset.
    ///    Operation = A member of the [D3D12_PREDICATION_OP](/windows/desktop/api/d3d12/ne-d3d12-d3d12_predication_op) enumeration
    ///                specifying the predicate operation.
    void    SetPredication(ID3D12Resource pBuffer, ulong AlignedBufferOffset, D3D12_PREDICATION_OP Operation);
    ///For internal use only. Not intended to be called directly.
    ///Params:
    ///    Metadata = Internal.
    ///    pData = Internal.
    ///    Size = Internal.
    void    SetMarker(uint Metadata, const(void)* pData, uint Size);
    ///For internal use only. Not intended to be called directly.
    ///Params:
    ///    Metadata = Internal.
    ///    pData = Internal.
    ///    Size = Internal.
    void    BeginEvent(uint Metadata, const(void)* pData, uint Size);
    ///For internal use only. Not intended to be called directly.
    void    EndEvent();
    ///Performs the motion estimation operation.
    ///Params:
    ///    pMotionEstimator = An [ID3D12VideoMotionEstimator](nn-d3d12video-id3d12videomotionestimator.md) representing the video motion
    ///                       estimator context object.
    ///    pOutputArguments = A [D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT](ns-d3d12video-d3d12_video_motion_estimator_output.md) structure
    ///                       representing the video motion estimation output arguments.
    ///    pInputArguments = A [D3D12_VIDEO_MOTION_ESTIMATOR_INPUT](ns-d3d12video-d3d12_video_motion_estimator_input.md) structure
    ///                      representing the video motion estimation input arguments.
    void    EstimateMotion(ID3D12VideoMotionEstimator pMotionEstimator, 
                           const(D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT)* pOutputArguments, 
                           const(D3D12_VIDEO_MOTION_ESTIMATOR_INPUT)* pInputArguments);
    ///Translates the motion vector output of the
    ///[EstimateMotion](nf-d3d12video-id3d12videoencodecommandlist-estimatemotion.md) method from hardware-dependent
    ///formats into a consistent format defined by the video motion estimation APIs.
    ///Params:
    ///    pOutputArguments = A
    ///                       [D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT](ns-d3d12video-d3d12_resolve_video_motion_vector_heap_output.md)
    ///                       structure containing the translated motion vectors.
    ///    pInputArguments = A
    ///                      [D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT](ns-d3d12video-d3d12_resolve_video_motion_vector_heap_input.md)
    ///                      structure containing the motion vectors to translate.
    void    ResolveMotionVectorHeap(const(D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT)* pOutputArguments, 
                                    const(D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT)* pInputArguments);
    ///Writes a number of 32-bit immediate values to the specified buffer locations directly from the command stream.
    ///Params:
    ///    Count = The number of elements in the *pParams* and *pModes* arrays.
    ///    pParams = The address of an array of
    ///              [D3D12_WRITEBUFFERIMMEDIATE_PARAMETER](/windows/desktop/api/d3d12/ns-d3d12-d3d12_writebufferimmediate_parameter)
    ///              structures of size *Count*.
    ///    pModes = The address of an array of
    ///             [D3D12_WRITEBUFFERIMMEDIATE_MODE](/windows/desktop/api/d3d12/ne-d3d12-d3d12_writebufferimmediate_mode)
    ///             structures of size *Count*. The default value is <b>null</b>. Passing <b>null</b> causes the system to write
    ///             all immediate values using **D3D12_WRITEBUFFERIMMEDIATE_MODE_DEFAULT**.
    void    WriteBufferImmediate(uint Count, const(D3D12_WRITEBUFFERIMMEDIATE_PARAMETER)* pParams, 
                                 const(D3D12_WRITEBUFFERIMMEDIATE_MODE)* pModes);
    ///Specifies whether or not protected resources can be accessed by subsequent commands in the command list. By
    ///default, no protected resources are enabled. After calling **SetProtectedResourceSession** with a valid session,
    ///protected resources of the same type can refer to that session. After calling **SetProtectedResourceSession**
    ///with **NULL**, no protected resources can be accessed.
    ///Params:
    ///    pProtectedResourceSession = An optional pointer to an
    ///                                [ID3D12ProtectedResourceSession](../d3d12/nn-d3d12-id3d12protectedresourcesession.md). You can obtain an
    ///                                **ID3D12ProtectedResourceSession** by calling
    ///                                [ID3D12Device4::CreateProtectedResourceSession](../d3d12/nf-d3d12-id3d12device4-createprotectedresourcesession.md).
    void    SetProtectedResourceSession(ID3D12ProtectedResourceSession pProtectedResourceSession);
}

///Represents a Direct3D 12 video decoder that contains resolution-independent resources and state for performing the
///decode operation. Inherits from [ID3D12VideoDecoder](nn-d3d12video-id3d12videodecoder.md) and adds support for
///protected resources.
@GUID("79A2E5FB-CCD2-469A-9FDE-195D10951F7E")
interface ID3D12VideoDecoder1 : ID3D12VideoDecoder
{
    ///Gets the [ID3D12ProtectedResourceSession](../d3d12/nn-d3d12-id3d12protectedresourcesession.md) that was passed
    ///into [ID3D12VideoDevice2::CreateVideoDecoder1](nf-d3d12video-id3d12videodevice2-createvideodecoder1.md) when the
    ///[ID3D12VideoDecoder1](nn-d3d12video-id3d12videodecoder1.md) was created.
    ///Params:
    ///    riid = The globally unique identifier (GUID) for the **ID3D12ProtectedResourceSession** interface.
    ///    ppProtectedSession = Receives a void pointer representing the **ID3D12ProtectedResourceSession** interface.
    ///Returns:
    ///    This method returns HRESULT.
    ///    
    HRESULT GetProtectedResourceSession(const(GUID)* riid, void** ppProtectedSession);
}

///ID3D12VideoDecoderHeap1 interits from [ID3D12VideoDecoderHeap](nn-d3d12video-id3d12videodecoderheap) and introduces
///support for protected resources.
@GUID("DA1D98C5-539F-41B2-BF6B-1198A03B6D26")
interface ID3D12VideoDecoderHeap1 : ID3D12VideoDecoderHeap
{
    ///Gets the [ID3D12ProtectedResourceSession](../d3d12/nn-d3d12-id3d12protectedresourcesession.md) that was passed
    ///into [ID3D12VideoDevice2::CreateVideoDecoderHeap1](nf-d3d12video-id3d12videodevice2-createvideodecoderheap1.md)
    ///when the [ID3D12VideoDecoderHeap1](nn-d3d12video-id3d12videodecoderheap1.md) was created.
    ///Params:
    ///    riid = The globally unique identifier (GUID) for the **ID3D12ProtectedResourceSession** interface.
    ///    ppProtectedSession = Receives a void pointer representing the **ID3D12ProtectedResourceSession** interface.
    ///Returns:
    ///    This method returns HRESULT.
    ///    
    HRESULT GetProtectedResourceSession(const(GUID)* riid, void** ppProtectedSession);
}

///Provides methods for getting information about the parameters to the call to
///[ID3D12VideoDevice2::CreateVideoProcessor1](nf-d3d12video-id3d12videodevice2-createvideoprocessor1) that created the
///video processor.
@GUID("F3CFE615-553F-425C-86D8-EE8C1B1FB01C")
interface ID3D12VideoProcessor1 : ID3D12VideoProcessor
{
    ///Gets the [ID3D12ProtectedResourceSession](../d3d12/nn-d3d12-id3d12protectedresourcesession.md) that was passed
    ///into [ID3D12VideoDevice2::CreateVideoProcessor1](nf-d3d12video-id3d12videodevice2-createvideoprocessor1.md) when
    ///the [ID3D12VideoProcessor1](nn-d3d12video-id3d12videoprocessor1.md) was created.
    ///Params:
    ///    riid = The globally unique identifier (GUID) for the **ID3D12ProtectedResourceSession** interface.
    ///    ppProtectedSession = Receives a void pointer representing the **ID3D12ProtectedResourceSession** interface.
    ///Returns:
    ///    This method returns HRESULT.
    ///    
    HRESULT GetProtectedResourceSession(const(GUID)* riid, void** ppProtectedSession);
}

///Represents a video extension command.
@GUID("554E41E8-AE8E-4A8C-B7D2-5B4F274A30E4")
interface ID3D12VideoExtensionCommand : ID3D12Pageable
{
    ///Gets the [D3D12_VIDEO_EXTENSION_COMMAND_DESC](ns-d3d12video-d3d12_video_extension_command_desc.md) provided when
    ///the interface was created.
    ///Returns:
    ///    The [D3D12_VIDEO_EXTENSION_COMMAND_DESC](ns-d3d12video-d3d12_video_extension_command_desc.md) provided when
    ///    the interface was created.
    ///    
    D3D12_VIDEO_EXTENSION_COMMAND_DESC GetDesc();
    ///Gets the [ID3D12ProtectedResourceSession](../d3d12/nn-d3d12-id3d12protectedresourcesession.md) that was passed
    ///into
    ///[ID3D12VideoDevice2::CreateVideoExtensionCommand](nf-d3d12video-id3d12videodevice2-createvideoextensioncommand.md)
    ///when the [ID3D12VideoExtensionCommand](nn-d3d12video-id3d12videoextensioncommand.md) was created.
    ///Params:
    ///    riid = The globally unique identifier (GUID) for the **ID3D12ProtectedResourceSession** interface.
    ///    ppProtectedSession = Receives a void pointer representing the **ID3D12ProtectedResourceSession** interface.
    ///Returns:
    ///    This method returns HRESULT.
    ///    
    HRESULT GetProtectedResourceSession(const(GUID)* riid, void** ppProtectedSession);
}

///Provides video decoding and processing capabilities of a Microsoft Direct3D 12 device including the ability to query
///video capabilities and instantiating video decoders and processors. This interface adds support for protected
///resources and video extension commands.
@GUID("F019AC49-F838-4A95-9B17-579437C8F513")
interface ID3D12VideoDevice2 : ID3D12VideoDevice1
{
    ///Creates a video decoder instance that contains the resolution-independent driver resources and state, with
    ///support for protected resources.
    ///Params:
    ///    pDesc = A pointer to a [D3D12\_VIDEO\_DECODER\_DESC](ns-d3d12video-d3d12_video_decoder_desc.md) structure describing
    ///            the decode profile and bitstream encryption for the decoder.
    ///    pProtectedResourceSession = A [ID3D12ProtectedResourceSession](../d3d12/nn-d3d12-id3d12protectedresourcesession.md) for managing access
    ///                                to protected resources.
    ///    riid = The globally unique identifier (GUID) for the decode video state interface.
    ///    ppVideoDecoder = A pointer to a memory block that receives a pointer to the
    ///                     [ID3D12VideoDecoder1](nn-d3d12video-id3d12videodecoder1.md) interface.
    ///Returns:
    ///    This method returns HRESULT.
    ///    
    HRESULT CreateVideoDecoder1(const(D3D12_VIDEO_DECODER_DESC)* pDesc, 
                                ID3D12ProtectedResourceSession pProtectedResourceSession, const(GUID)* riid, 
                                void** ppVideoDecoder);
    ///Allocates a video decoder heap that contains the resolution-dependent driver resources and state, with support
    ///for protected resources.
    ///Params:
    ///    pVideoDecoderHeapDesc = A pointer to a [D3D12\_VIDEO\_DECODER\_HEAP\_DESC](ns-d3d12video-d3d12_video_decoder_heap_desc.md) describing
    ///                            the decoding configuration.
    ///    pProtectedResourceSession = A [ID3D12ProtectedResourceSession](../d3d12/nn-d3d12-id3d12protectedresourcesession.md) for managing access
    ///                                to protected resources.
    ///    riid = The globally unique identifier (GUID) for the decode video state interface.
    ///    ppVideoDecoderHeap = A pointer to a memory block that receives a pointer to the
    ///                         [ID3D12VideoDecoderHeap1](nn-d3d12video-id3d12videodecoderheap1.md) interface.
    ///Returns:
    ///    This method returns an HRESULT.
    ///    
    HRESULT CreateVideoDecoderHeap1(const(D3D12_VIDEO_DECODER_HEAP_DESC)* pVideoDecoderHeapDesc, 
                                    ID3D12ProtectedResourceSession pProtectedResourceSession, const(GUID)* riid, 
                                    void** ppVideoDecoderHeap);
    ///Creates a video processor instance with support for protected resources.
    ///Params:
    ///    NodeMask = The node mask specifying the physical adapter on which the video processor will be used. For single GPU
    ///               operation, set this to zero. If there are multiple GPU nodes, set a bit to identify the node, i.e. the
    ///               device's physical adapter, to which the command queue applies. Each bit in the mask corresponds to a single
    ///               node. Only 1 bit may be set.
    ///    pOutputStreamDesc = A pointer to a D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC(ns-d3d12video-d3d12_video_process_output_stream_desc)
    ///                        structure describing the output stream.
    ///    NumInputStreamDescs = The number of input streams provided in the *pInputStreamDescs* parameter.
    ///    pInputStreamDescs = A pointer to a list of
    ///                        D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC(ns-d3d12video-d3d12_video_process_input_stream_desc) structures the
    ///                        input streams. The number of structures provided should match the value specified in the
    ///                        *NumInputStreamDescs* parameter.
    ///    pProtectedResourceSession = A [ID3D12ProtectedResourceSession](../d3d12/nn-d3d12-id3d12protectedresourcesession.md) for managing access
    ///                                to protected resources.
    ///    riid = The globally unique identifier (GUID) for the video processor interface.
    ///    ppVideoProcessor = A pointer to a memory block that receives a pointer to the
    ///                       [ID3D12VideoProcessor1](nn-d3d12video-id3d12videoprocessor1.md) interface
    ///Returns:
    ///    This method returns HRESULT.
    ///    
    HRESULT CreateVideoProcessor1(uint NodeMask, const(D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC)* pOutputStreamDesc, 
                                  uint NumInputStreamDescs, 
                                  const(D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC)* pInputStreamDescs, 
                                  ID3D12ProtectedResourceSession pProtectedResourceSession, const(GUID)* riid, 
                                  void** ppVideoProcessor);
    ///Creates a video extension command.
    ///Params:
    ///    pDesc = The [D3D12_VIDEO_EXTENSION_COMMAND_DESC](ns-d3d12video-d3d12_video_extension_command_desc.md) describing the
    ///            command to be created.
    ///    pCreationParameters = A pointer to the creation parameters structure, which is defined by the command. The parameters structure
    ///                          must match the parameters enumerated by a call to
    ///                          [ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) with the
    ///                          feature value of [D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETERS](ne-d3d12video-d3d12_feature_video.md) and
    ///                          a parameter stage value of
    ///                          [D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CREATION](ne-d3d12video-d3d12_video_extension_command_parameter_stage.md).
    ///    CreationParametersDataSizeInBytes = The size of the *pCreationParameters* parameter structure, in bytes.
    ///    pProtectedResourceSession = A [ID3D12ProtectedResourceSession](../d3d12/nn-d3d12-id3d12protectedresourcesession.md) for managing access
    ///                                to protected resources.
    ///    riid = The globally unique identifier (GUID) for the
    ///           [ID3D12VideoExtensionCommand](nn-d3d12video-id3d12videoextensioncommand.md) interface.
    ///    ppVideoExtensionCommand = A pointer to a memory block that receives a pointer to the
    ///                              [ID3D12VideoExtensionCommand](nn-d3d12video-id3d12videoextensioncommand.md) interface.
    ///Returns:
    ///    This method returns an HRESULT.
    ///    
    HRESULT CreateVideoExtensionCommand(const(D3D12_VIDEO_EXTENSION_COMMAND_DESC)* pDesc, 
                                        const(void)* pCreationParameters, size_t CreationParametersDataSizeInBytes, 
                                        ID3D12ProtectedResourceSession pProtectedResourceSession, const(GUID)* riid, 
                                        void** ppVideoExtensionCommand);
    ///Executes a video extension command.
    ///Params:
    ///    pExtensionCommand = Pointer to an [ID3D12VideoExtensionCommand](nn-d3d12video-id3d12videoextensioncommand.md) representing the
    ///                        video extension command to execute. The caller is responsible for maintaining object lifetime until command
    ///                        execution is complete.
    ///    pExecutionParameters = A pointer to the execution input parameters structure, which is defined by the command. The parameters
    ///                           structure must match the parameters enumerated by a call to
    ///                           [ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) with the
    ///                           feature value of [D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETERS](ne-d3d12video-d3d12_feature_video.md) and
    ///                           a parameter stage value of
    ///                           [D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_EXECUTION](ne-d3d12video-d3d12_video_extension_command_parameter_stage.md).
    ///    ExecutionParametersSizeInBytes = The size of the *pExecutionParameters* parameter structure, in bytes.
    ///    pOutputData = A pointer to the execution output parameters structure, which is defined by the command.
    ///    OutputDataSizeInBytes = Receives the size of the *pExecutionParameters* parameter structure, in bytes.
    ///Returns:
    ///    This method returns HRESULT.
    ///    
    HRESULT ExecuteExtensionCommand(ID3D12VideoExtensionCommand pExtensionCommand, 
                                    const(void)* pExecutionParameters, size_t ExecutionParametersSizeInBytes, 
                                    void* pOutputData, size_t OutputDataSizeInBytes);
}

///Encapsulates a list of graphics commands for video decoding. This interface inherits from
///[ID3D12VideoDecodeCommandList1](nn-d3d12video-id3d12videodecodecommandlist1.md) and adds support for video extension
///commands.
@GUID("6E120880-C114-4153-8036-D247051E1729")
interface ID3D12VideoDecodeCommandList2 : ID3D12VideoDecodeCommandList1
{
    ///Specifies whether or not protected resources can be accessed by subsequent commands in the video decode command
    ///list. By default, no protected resources are enabled. After calling **SetProtectedResourceSession** with a valid
    ///session, protected resources of the same type can refer to that session. After calling
    ///**SetProtectedResourceSession** with **NULL**, no protected resources can be accessed.
    ///Params:
    ///    pProtectedResourceSession = An optional pointer to an
    ///                                [ID3D12ProtectedResourceSession](../d3d12/nn-d3d12-id3d12protectedresourcesession.md). You can obtain an
    ///                                **ID3D12ProtectedResourceSession** by calling
    ///                                [ID3D12Device4::CreateProtectedResourceSession](../d3d12/nf-d3d12-id3d12device4-createprotectedresourcesession.md).
    void SetProtectedResourceSession(ID3D12ProtectedResourceSession pProtectedResourceSession);
    ///Records a command to initializes or re-initializes a video extension command into a video decode command list.
    ///Params:
    ///    pExtensionCommand = Pointer to an [ID3D12VideoExtensionCommand](nn-d3d12video-id3d12videoextensioncommand.md) representing the
    ///                        video extension command to initialize. The caller is responsible for maintaining object lifetime until
    ///                        command execution is complete.
    ///    pInitializationParameters = A pointer to the creation parameters structure, which is defined by the command. The parameters structure
    ///                                must match the parameters enumerated by a call to
    ///                                [ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) with the
    ///                                feature value of [D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETERS](ne-d3d12video-d3d12_feature_video.md) and
    ///                                a parameter stage value of
    ///                                [D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_INITIALIZATION](ne-d3d12video-d3d12_video_extension_command_parameter_stage.md).
    ///    InitializationParametersSizeInBytes = The size of the *pInitializationParameters* parameter structure, in bytes.
    void InitializeExtensionCommand(ID3D12VideoExtensionCommand pExtensionCommand, 
                                    const(void)* pInitializationParameters, 
                                    size_t InitializationParametersSizeInBytes);
    ///Records a command to execute a video extension command into a decode command list.
    ///Params:
    ///    pExtensionCommand = Pointer to an [ID3D12VideoExtensionCommand](nn-d3d12video-id3d12videoextensioncommand.md) representing the
    ///                        video extension command to execute. The caller is responsible for maintaining object lifetime until command
    ///                        execution is complete.
    ///    pExecutionParameters = A pointer to the execution parameters structure, which is defined by the command. The parameters structure
    ///                           must match the parameters enumerated by a call to
    ///                           [ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) with the
    ///                           feature value of [D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETERS](ne-d3d12video-d3d12_feature_video.md) and
    ///                           a parameter stage value of
    ///                           [D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_EXECUTION](ne-d3d12video-d3d12_video_extension_command_parameter_stage.md).
    ///    ExecutionParametersSizeInBytes = The size of the *pExecutionParameters* parameter structure, in bytes.
    void ExecuteExtensionCommand(ID3D12VideoExtensionCommand pExtensionCommand, const(void)* pExecutionParameters, 
                                 size_t ExecutionParametersSizeInBytes);
}

///Encapsulates a list of graphics commands for video processing. This interface inherits from
///[ID3D12VideoProcessComanndList1](nn-d3d12video-id3d12videoprocesscommandlist1.md) and adds support for video
///extension commands.
@GUID("DB525AE4-6AD6-473C-BAA7-59B2E37082E4")
interface ID3D12VideoProcessCommandList2 : ID3D12VideoProcessCommandList1
{
    ///Specifies whether or not protected resources can be accessed by subsequent commands in the video process command
    ///list. By default, no protected resources are enabled. After calling **SetProtectedResourceSession** with a valid
    ///session, protected resources of the same type can refer to that session. After calling
    ///**SetProtectedResourceSession** with **NULL**, no protected resources can be accessed.
    ///Params:
    ///    pProtectedResourceSession = An optional pointer to an
    ///                                [ID3D12ProtectedResourceSession](../d3d12/nn-d3d12-id3d12protectedresourcesession.md). You can obtain an
    ///                                **ID3D12ProtectedResourceSession** by calling
    ///                                [ID3D12Device4::CreateProtectedResourceSession](../d3d12/nf-d3d12-id3d12device4-createprotectedresourcesession.md).
    void SetProtectedResourceSession(ID3D12ProtectedResourceSession pProtectedResourceSession);
    ///Records a command to initializes or re-initializes a video extension command into a video processor command list.
    ///Params:
    ///    pExtensionCommand = Pointer to an [ID3D12VideoExtensionCommand](nn-d3d12video-id3d12videoextensioncommand.md) representing the
    ///                        video extension command to initialize. The caller is responsible for maintaining object lifetime until
    ///                        command execution is complete.
    ///    pInitializationParameters = A pointer to the creation parameters structure, which is defined by the command. The parameters structure
    ///                                must match the parameters enumerated by a call to
    ///                                [ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) with the
    ///                                feature value of [D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETERS](ne-d3d12video-d3d12_feature_video.md) and
    ///                                a parameter stage value of
    ///                                [D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_INITIALIZATION](ne-d3d12video-d3d12_video_extension_command_parameter_stage.md).
    ///    InitializationParametersSizeInBytes = The size of the *pInitializationParameters* parameter structure, in bytes.
    void InitializeExtensionCommand(ID3D12VideoExtensionCommand pExtensionCommand, 
                                    const(void)* pInitializationParameters, 
                                    size_t InitializationParametersSizeInBytes);
    ///Records a command to execute a video extension command into a video process command list.
    ///Params:
    ///    pExtensionCommand = Pointer to an [ID3D12VideoExtensionCommand](nn-d3d12video-id3d12videoextensioncommand.md) representing the
    ///                        video extension command to execute. The caller is responsible for maintaining object lifetime until command
    ///                        execution is complete.
    ///    pExecutionParameters = A pointer to the execution parameters structure, which is defined by the command. The parameters structure
    ///                           must match the parameters enumerated by a call to
    ///                           [ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) with the
    ///                           feature value of [D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETERS](ne-d3d12video-d3d12_feature_video.md) and
    ///                           a parameter stage value of
    ///                           [D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_EXECUTION](ne-d3d12video-d3d12_video_extension_command_parameter_stage.md).
    ///    ExecutionParametersSizeInBytes = The size of the *pExecutionParameters* parameter structure, in bytes.
    void ExecuteExtensionCommand(ID3D12VideoExtensionCommand pExtensionCommand, const(void)* pExecutionParameters, 
                                 size_t ExecutionParametersSizeInBytes);
}

@GUID("94971ECA-2BDB-4769-88CF-3675EA757EBC")
interface ID3D12VideoEncodeCommandList1 : ID3D12VideoEncodeCommandList
{
    ///Records a command to initializes or re-initializes a video extension command into a video encode command list.
    ///Params:
    ///    pExtensionCommand = Pointer to an [ID3D12VideoExtensionCommand](nn-d3d12video-id3d12videoextensioncommand.md) representing the
    ///                        video extension command to initialize. The caller is responsible for maintaining object lifetime until
    ///                        command execution is complete.
    ///    pInitializationParameters = A pointer to the creation parameters structure, which is defined by the command. The parameters structure
    ///                                must match the parameters enumerated by a call to
    ///                                [ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) with the
    ///                                feature value of [D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETERS](ne-d3d12video-d3d12_feature_video.md) and
    ///                                a parameter stage value of
    ///                                [D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_INITIALIZATION](ne-d3d12video-d3d12_video_extension_command_parameter_stage.md).
    ///    InitializationParametersSizeInBytes = The size of the *pInitializationParameters* parameter structure, in bytes.
    void InitializeExtensionCommand(ID3D12VideoExtensionCommand pExtensionCommand, 
                                    const(void)* pInitializationParameters, 
                                    size_t InitializationParametersSizeInBytes);
    ///Records a command to execute a video extension command into a encode command list.
    ///Params:
    ///    pExtensionCommand = Pointer to an [ID3D12VideoExtensionCommand](nn-d3d12video-id3d12videoextensioncommand.md) representing the
    ///                        video extension command to execute. The caller is responsible for maintaining object lifetime until command
    ///                        execution is complete.
    ///    pExecutionParameters = A pointer to the execution parameters structure, which is defined by the command. The parameters structure
    ///                           must match the parameters enumerated by a call to
    ///                           [ID3D12VideoDevice::CheckFeatureSupport](nf-d3d12video-id3d12videodevice-checkfeaturesupport.md) with the
    ///                           feature value of [D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETERS](ne-d3d12video-d3d12_feature_video.md) and
    ///                           a parameter stage value of
    ///                           [D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_EXECUTION](ne-d3d12video-d3d12_video_extension_command_parameter_stage.md).
    ///    ExecutionParametersSizeInBytes = The size of the *pExecutionParameters* parameter structure, in bytes.
    void ExecuteExtensionCommand(ID3D12VideoExtensionCommand pExtensionCommand, const(void)* pExecutionParameters, 
                                 size_t ExecutionParametersSizeInBytes);
}

@GUID("CEE3DEF2-3808-414D-BE66-FAFD472210BC")
interface IWMValidate : IUnknown
{
    HRESULT SetIdentifier(GUID guidValidationID);
}

@GUID("04A578B2-E778-422A-A805-B3EE54D90BD9")
interface IValidateBinding : IUnknown
{
    HRESULT GetIdentifier(GUID guidLicensorID, ubyte* pbEphemeron, uint cbEphemeron, ubyte** ppbBlobValidationID, 
                          uint* pcbBlobSize);
}

///Controls the speed of the video decoder. This interface is implemented by the video decoder objects. You can obtain a
///pointer to IWMVideoDecoderHurryup by calling the <b>QueryInterface</b> method of any other interface of the decoder,
///such as IMediaObject or IMFTransform
@GUID("352BB3BD-2D4D-4323-9E71-DCDCFBD53CA6")
interface IWMVideoDecoderHurryup : IUnknown
{
    ///Sets the speed mode of the video decoder.
    ///Params:
    ///    lHurryup = The speed mode of the video decoder. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%">
    ///               <dl> <dt>-1 (default)</dt> </dl> </td> <td width="60%"> The decoder will determine the decoding speed. </td>
    ///               </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> The decoder will decode in real
    ///               time. </td> </tr> <tr> <td width="40%"> <dl> <dt>1 to 4</dt> </dl> </td> <td width="60%"> The decoder will
    ///               decode faster than real time. The higher the value, the faster the decoding. </td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetHurryup(int lHurryup);
    ///Retrieves the current speed mode of the video decoder.
    ///Params:
    ///    plHurryup = Address of a variable that receives the decoder speed mode. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///                </tr> <tr> <td width="40%"> <dl> <dt>-1 (default)</dt> </dl> </td> <td width="60%"> The decoder will
    ///                determine the decoding speed. </td> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%">
    ///                The decoder will decode in real time. </td> </tr> <tr> <td width="40%"> <dl> <dt>1 to 4</dt> </dl> </td> <td
    ///                width="60%"> The decoder will decode faster than real time. </td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetHurryup(int* plHurryup);
}

///Forces the encoder to encode the current frame as a key frame.
@GUID("9F8496BE-5B9A-41B9-A9E8-F21CD80596C2")
interface IWMVideoForceKeyFrame : IUnknown
{
    ///Specifies that the current frame will be encoded as a key frame.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetKeyFrame();
}

///Retrieves names and descriptive strings for codecs and formats. This interface is implemented by all of the codec
///encoder objects. You can retrieve a pointer to the <b>IWMCodecStrings</b> interface for any encoder by calling the
///<b>QueryInterface</b> method of any other interface on the object, such as IMediaObject or IMFTransform, This
///interface is not implemented on any of the decoder DMOs.
@GUID("A7B2504B-E58A-47FB-958B-CAC7165A057D")
interface IWMCodecStrings : IUnknown
{
    ///Retrieves the name of a codec.
    ///Params:
    ///    pmt = Pointer to the output media type. If <b>NULL</b>, the codec will use the media type that is currently set.
    ///    cchLength = Size of szName buffer in wide characters.
    ///    szName = Address of the wide-character buffer that receives the name. If <b>NULL</b>, pcchLength receives the required
    ///             length.
    ///    pcchLength = Pointer to the required buffer length in wide characters, including the null terminating character.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetName(DMO_MEDIA_TYPE* pmt, uint cchLength, PWSTR szName, uint* pcchLength);
    ///Retrieves the description of an output format.
    ///Params:
    ///    pmt = Pointer to the output media type. If <b>NULL</b>, the codec will use the media type that is currently set.
    ///    cchLength = Size of szDescription buffer, in wide characters.
    ///    szDescription = Address of the wide-character buffer that receives the description. If <b>NULL</b>, pcchLength receives the
    ///                    required length.
    ///    pcchLength = Pointer to the required buffer length in wide characters, including the null terminating character.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetDescription(DMO_MEDIA_TYPE* pmt, uint cchLength, PWSTR szDescription, uint* pcchLength);
}

///Provides methods that retrieve format-specific codec properties. This interface is implemented by the video encoder
///objects. You can obtain a pointer to IWMCodecProps by calling the <b>QueryInterface</b> method of any other interface
///on the object, such as IMediaObject or IMFTransform. This interface enables you to receive information about a
///specific media type that is supported by a video encoder.
@GUID("2573E11A-F01A-4FDD-A98D-63B8E0BA9589")
interface IWMCodecProps : IUnknown
{
    ///Retrieves a format property for an output media type. Use this method to get information about enumerated audio
    ///formats.
    ///Params:
    ///    pmt = Pointer to the output media type.
    ///    pszName = Wide-character, null-terminated string containing the property name. The properties listed in the following
    ///              table are supported only through the IWMCodecProps interface. <table> <tr> <th>Property name constant</th>
    ///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="g_wszSpeechFormatCaps"></a><a
    ///              id="g_wszspeechformatcaps"></a><a id="G_WSZSPEECHFORMATCAPS"></a><dl> <dt><b>g_wszSpeechFormatCaps</b></dt>
    ///              </dl> </td> <td width="60%"> Retrieves the speech modes available for the format (used only by the Windows
    ///              Media Audio 9 Voice codec). Value contains flags identical to the values used to specify the mode for
    ///              MFPKEY_WMAVOICE_ENC_MusicSpeechClassMode. </td> </tr> </table> The properties in the following list are also
    ///              supported. They are used with <b>IPropertyBag</b> for video. <ul> <li> MFPKEY_VBRENABLED </li> <li>
    ///              MFPKEY_VBRQUALITY </li> </ul>
    ///    pType = Address of a variable that receives the data type of the property value.
    ///    pValue = Address of the byte buffer that receives the property value.
    ///    pdwSize = Pointer to the size of the value buffer, in bytes. If pValue is <b>NULL</b>, the method will set this value
    ///              to the size required.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFormatProp(DMO_MEDIA_TYPE* pmt, const(PWSTR) pszName, WMT_PROP_DATATYPE* pType, ubyte* pValue, 
                          uint* pdwSize);
    ///Retrieves a codec property specific to an output format.
    ///Params:
    ///    dwFormat = The output format to which the property applies. Set this value to the FOURCC value of the desired video
    ///               format.
    ///    pszName = Wide-character, null-terminated string containing the property name. The properties listed in the following
    ///              table are supported only through the IWMCodecProps interface. <table> <tr> <th>Property name constant</th>
    ///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="g_wszWMCPCodecName"></a><a id="g_wszwmcpcodecname"></a><a
    ///              id="G_WSZWMCPCODECNAME"></a><dl> <dt><b>g_wszWMCPCodecName</b></dt> </dl> </td> <td width="60%"> Retrieves
    ///              the name of the codec that is associated with the format (or FOURCC). This is an alternative to the
    ///              IWMCodecStrings interface. </td> </tr> <tr> <td width="40%"><a id="g_wszWMCPSupportedVBRModes"></a><a
    ///              id="g_wszwmcpsupportedvbrmodes"></a><a id="G_WSZWMCPSUPPORTEDVBRMODES"></a><dl>
    ///              <dt><b>g_wszWMCPSupportedVBRModes</b></dt> </dl> </td> <td width="60%"> Retrieves the encoding modes
    ///              supported by the codec. The value returned contains one or more of the following flags: <ul>
    ///              <li>WM_CODEC_ONEPASS_CBR </li> <li>WM_CODEC_ONEPASS_VBR</li> <li>WM_CODEC_TWOPASS_CBR</li>
    ///              <li>WM_CODEC_TWOPASS_VBR_UNCONSTRAINED </li> <li>WM_CODEC_TWOPASS_VBR_PEAKCONSTRAINED </li> </ul> </td> </tr>
    ///              </table>
    ///    pType = Address of a variable that receives the data type of the property value.
    ///    pValue = Address of the byte buffer that receives the property value.
    ///    pdwSize = Pointer to the size of the value buffer, in bytes. If pValue is <b>NULL</b>, the method will set this value
    ///              to the size required.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCodecProp(uint dwFormat, const(PWSTR) pszName, WMT_PROP_DATATYPE* pType, ubyte* pValue, 
                         uint* pdwSize);
}

///Configures the "leaky bucket" parameters on a video encoder. This interface is implemented by all of the encoder
///objects. You can get a pointer to the <b>IWMCodecLeakyBucket</b> interface for a Windows Media video encoder by
///calling the QueryInterface method of any other interface on the object, such as IMediaObject or IMFTransform. This
///interface is not implemented on any of the decoders.
@GUID("A81BA647-6227-43B7-B231-C7B15135DD7D")
interface IWMCodecLeakyBucket : IUnknown
{
    ///Sets the buffer size in bits.
    ///Params:
    ///    ulBufferSize = The buffer size, in bits.
    ///Returns:
    ///    This method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the
    ///    following table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetBufferSizeBits(uint ulBufferSize);
    ///Retrieves the current size of the buffer in bits.
    ///Params:
    ///    pulBufferSize = Pointer to a variable containing the buffer size, in bits.
    ///Returns:
    ///    This method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the
    ///    following table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetBufferSizeBits(uint* pulBufferSize);
    ///Not implemented in this release.
    ///Params:
    ///    ulBufferFullness = 
    ///Returns:
    ///    This method always returns E_NOTIMPL.
    ///    
    HRESULT SetBufferFullnessBits(uint ulBufferFullness);
    ///Not implemented in this release.
    ///Params:
    ///    pulBufferFullness = 
    ///Returns:
    ///    This method always returns E_NOTIMPL.
    ///    
    HRESULT GetBufferFullnessBits(uint* pulBufferFullness);
}

///Gets the time stamp of the next video frame to be decoded. This interface is implemented by the video decoders. You
///can obtain a pointer to <b>IWMCodecOutputTimestamp</b> by calling the QueryInterface method of any other interface of
///the decoder object, such as IMediaObject or IMFTransform.
@GUID("B72ADF95-7ADC-4A72-BC05-577D8EA6BF68")
interface IWMCodecOutputTimestamp : IUnknown
{
    ///Queries the decoder for the time stamp of the upcoming output sample. Use this method if you need to know the
    ///time of the sample before calling <b>IMediaObject::ProcessOutput</b> or IMFTransform::ProcessOutput to get the
    ///sample.
    ///Params:
    ///    prtTime = Address of a variable that receives the presentation time of the next sample.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetNextOutputTime(long* prtTime);
}

///<div class="alert"><b>Note</b> This interface is obsolete and should not be used.</div> <div> </div> Manages
///reconstructed video frames.
@GUID("45BDA2AC-88E2-4923-98BA-3949080711A3")
interface IWMVideoDecoderReconBuffer : IUnknown
{
    ///<div class="alert"><b>Note</b> This method is obsolete and should not be used.</div> <div> </div> Retrieves the
    ///size of the current reconstructed video frame.
    ///Params:
    ///    pdwSize = Address of a variable that receives the frame size in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetReconstructedVideoFrameSize(uint* pdwSize);
    ///<div class="alert"><b>Note</b> This method is obsolete and should not be used.</div> <div> </div> Retrieves the
    ///current reconstructed video frame.
    ///Params:
    ///    pBuf = Address of a media buffer that receives the reconstructed video frame.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetReconstructedVideoFrame(IMediaBuffer pBuf);
    ///<div class="alert"><b>Note</b> This method is obsolete and should not be used.</div> <div> </div> Restores the
    ///current reconstructed video frame.
    ///Params:
    ///    pBuf = Address of an IMediaBuffer interface containing the reconstructed frame to restore.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetReconstructedVideoFrame(IMediaBuffer pBuf);
}

///Gets the private codec data that must be appended to the output media type. This codec data is required for properly
///decoding Windows Media Video content. This interface is implemented by the video encoder object and the screen
///capture encoder object. You do not need codec private data to decode content of the subtype WMCMEDIASUBTYPE_WMV1
///(Windows Media Video version 7). For any other output type, you must obtain a pointer to the encoder's
///IWMCodecPrivateData interface by calling the QueryInterface method of any other interface on the object, such as
///IMediaObject or IMFTransform.
@GUID("73F0BE8E-57F7-4F01-AA66-9F57340CFE0E")
interface IWMCodecPrivateData : IUnknown
{
    ///Gives the codec the output media type without the codec data. This enables the codec to generate the private
    ///data.
    ///Params:
    ///    pmt = Address of the partial output media type.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetPartialOutputType(DMO_MEDIA_TYPE* pmt);
    ///Retrieves the codec data for the video content based on the output type passed using the
    ///IWMCodecPrivateData::SetPartialOutputType method.
    ///Params:
    ///    pbData = Address of the buffer that receives the private data. If you set this to <b>NULL</b>, the size required to
    ///             hold the private data will be returned in <i>pcbData</i>.
    ///    pcbData = Pointer to the size of the private data in bytes. If pbData is <b>NULL</b>, the method will set this to the
    ///              correct value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetPrivateData(ubyte* pbData, uint* pcbData);
}

///Configures codec support for sample extensions.
@GUID("9BCA9884-0604-4C2A-87DA-793FF4D586C3")
interface IWMSampleExtensionSupport : IUnknown
{
    ///Configures whether the codec supports sample extensions.
    ///Params:
    ///    fUseExtensions = Flag, true indicating to use extensions.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetUseSampleExtensions(BOOL fUseExtensions);
}

///Sets properties on the audio resampler DSP.
@GUID("E7E9984F-F09F-4DA4-903F-6E2E0EFE56B5")
interface IWMResamplerProps : IUnknown
{
    ///Specifies the quality of the output.
    ///Params:
    ///    lhalfFilterLen = Specifies the quality of the output. The valid range is 1 to 60, inclusive.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetHalfFilterLength(int lhalfFilterLen);
    ///Specifies the channel matrix.
    ///Params:
    ///    userChannelMtx = Pointer to an array of floating-point values that represents a channel conversion matrix.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetUserChannelMtx(float* userChannelMtx);
}

///Sets properties on the video resizer DSP.
@GUID("57665D4C-0414-4FAA-905B-10E546F81C33")
interface IWMResizerProps : IUnknown
{
    ///Specifies whether to use an algorithm that produces higher-quality video, or a faster algorithm.
    ///Params:
    ///    lquality = Boolean value. If <b>TRUE</b>, the video resizer uses an algorithm that produces higher-quality video. If
    ///               <b>FALSE</b>, the video resizer uses a faster algorithm.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetResizerQuality(int lquality);
    ///The <b>SetInterlaceMode</b> method specifies whether the input video stream is interlaced.
    ///Params:
    ///    lmode = Boolean value. If <b>TRUE</b>, the video is interlaced. If <b>FALSE</b>, the video is progressive.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetInterlaceMode(int lmode);
    ///Sets the source rectangle.
    ///Params:
    ///    lClipOriXSrc = Specifies the left edge of the source rectangle, in pixels.
    ///    lClipOriYSrc = Specifies the top edge of the source rectangle, in pixels.
    ///    lClipWidthSrc = Specifies the width of the source rectangle, in pixels.
    ///    lClipHeightSrc = Specifies the height of the source rectangle, in pixels.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetClipRegion(int lClipOriXSrc, int lClipOriYSrc, int lClipWidthSrc, int lClipHeightSrc);
    ///Sets the source and destination rectangles.
    ///Params:
    ///    lClipOriXSrc = Specifies the left edge of the source rectangle, in pixels.
    ///    lClipOriYSrc = Specifies the top edge of the source rectangle, in pixels.
    ///    lClipWidthSrc = Specifies the width of the source rectangle, in pixels.
    ///    lClipHeightSrc = Specifies the height of the source rectangle, in pixels.
    ///    lClipOriXDst = Specifies the left edge of the destination rectangle, in pixels.
    ///    lClipOriYDst = Specifies the top edge of the destination rectangle, in pixels.
    ///    lClipWidthDst = Specifies the width of the destination rectangle, in pixels.
    ///    lClipHeightDst = Specifies the height of the destination rectangle, in pixels.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetFullCropRegion(int lClipOriXSrc, int lClipOriYSrc, int lClipWidthSrc, int lClipHeightSrc, 
                              int lClipOriXDst, int lClipOriYDst, int lClipWidthDst, int lClipHeightDst);
    ///Retrieves the source and destination rectangles.
    ///Params:
    ///    lClipOriXSrc = Receives the left edge of the source rectangle, in pixels.
    ///    lClipOriYSrc = Receives the top edge of the source rectangle, in pixels.
    ///    lClipWidthSrc = Receives the width of the source rectangle, in pixels.
    ///    lClipHeightSrc = Receives the height of the source rectangle, in pixels.
    ///    lClipOriXDst = Receives the left edge of the destination rectangle, in pixels.
    ///    lClipOriYDst = Receives the top edge of the destination rectangle, in pixels.
    ///    lClipWidthDst = Receives the width of the destination rectangle, in pixels.
    ///    lClipHeightDst = Receives the height of the destination rectangle, in pixels.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetFullCropRegion(int* lClipOriXSrc, int* lClipOriYSrc, int* lClipWidthSrc, int* lClipHeightSrc, 
                              int* lClipOriXDst, int* lClipOriYDst, int* lClipWidthDst, int* lClipHeightDst);
}

@GUID("776C93B3-B72D-4508-B6D0-208785F553E7")
interface IWMColorLegalizerProps : IUnknown
{
    HRESULT SetColorLegalizerQuality(int lquality);
}

@GUID("7B12E5D1-BD22-48EA-BC06-98E893221C89")
interface IWMInterlaceProps : IUnknown
{
    HRESULT SetProcessType(int iProcessType);
    HRESULT SetInitInverseTeleCinePattern(int iInitPattern);
    HRESULT SetLastFrame();
}

@GUID("4C06BB9B-626C-4614-8329-CC6A21B93FA0")
interface IWMFrameInterpProps : IUnknown
{
    HRESULT SetFrameRateIn(int lFrameRate, int lScale);
    HRESULT SetFrameRateOut(int lFrameRate, int lScale);
    HRESULT SetFrameInterpEnabled(BOOL bFIEnabled);
    HRESULT SetComplexityLevel(int iComplexity);
}

///Sets properties on the color converter DSP.
@GUID("E6A49E22-C099-421D-AAD3-C061FB4AE85B")
interface IWMColorConvProps : IUnknown
{
    ///Specifies whether the input video stream is interlaced.
    ///Params:
    ///    lMode = Specifies one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///            width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> Progressive video </td> </tr> <tr> <td width="40%">
    ///            <dl> <dt>2</dt> </dl> </td> <td width="60%"> Interlaced video </td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetMode(int lMode);
    ///Sets the source and destination rectangles.
    ///Params:
    ///    lSrcCropLeft = Specifies the left edge of the source rectangle, in pixels.
    ///    lSrcCropTop = Specifies the top edge of the source rectangle, in pixels.
    ///    lDstCropLeft = Specifies the left edge of the destination rectangle, in pixels.
    ///    lDstCropTop = Specifies the top edge of the destination rectangle, in pixels.
    ///    lCropWidth = Specifies the width of the source and destination rectangles, in pixels.
    ///    lCropHeight = Specifies the height of the source and destination rectangles, in pixels.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetFullCroppingParam(int lSrcCropLeft, int lSrcCropTop, int lDstCropLeft, int lDstCropTop, 
                                 int lCropWidth, int lCropHeight);
}

///The <b>ITocEntry</b> interface represents an individual entry in a table of contents. It provides methods for setting
///and retrieving descriptive information for the entry.
@GUID("F22F5E06-585C-4DEF-8523-6555CFBC0CB3")
interface ITocEntry : IUnknown
{
    ///The <b>SetTitle</b> method sets the title of the entry.
    ///Params:
    ///    pwszTitle = Pointer to a NULL-terminated wide-character string that contains the title.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetTitle(const(PWSTR) pwszTitle);
    ///The <b>GetTitle</b> method retrieves the title, set by a previous call to SetTitle, of the entry.
    ///Params:
    ///    pwTitleSize = If <i>pwszTitle</i> is <b>NULL</b>, this is an output parameter that receives the size, in wide characters,
    ///                  of the buffer required to receive the title. If <i>pwszTitle</i> is not <b>NULL</b>, this is an input
    ///                  parameter that specifies the size, in wide characters, of the caller-allocated buffer pointed to by
    ///                  <i>pwszTitle</i>.
    ///    pwszTitle = <b>NULL</b>, or a pointer to a caller-allocated buffer that, on successful completion, receives the title.
    ///                The title is null-terminated.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td width="60%"> The method returns this error code if
    ///    <i>pwszTitle</i> is not <b>NULL</b> and the title, including its NULL terminator, is larger than the size
    ///    specified by <i>pwTitleSize</i>. In that case, <i>pwTitleSize</i> serves as an output parameter and receives
    ///    the size of the required buffer. </td> </tr> </table>
    ///    
    HRESULT GetTitle(ushort* pwTitleSize, PWSTR pwszTitle);
    ///The <b>SetDescriptor</b> method associates a descriptor with the entry.
    ///Params:
    ///    pDescriptor = Pointer to a TOC_ENTRY_DESCRIPTOR structure that contains the descriptor.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetDescriptor(TOC_ENTRY_DESCRIPTOR* pDescriptor);
    ///The <b>GetDescriptor</b> method retrieves the descriptor, previously set by a call to SetDescriptor, of the
    ///entry.
    ///Params:
    ///    pDescriptor = Pointer to a TOC_ENTRY_DESCRIPTOR structure that receives the descriptor.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetDescriptor(TOC_ENTRY_DESCRIPTOR* pDescriptor);
    ///The <b>SetSubEntries</b> identifies a set of entries as being subentries of this entry.
    ///Params:
    ///    dwNumSubEntries = The number of indices in the array pointed to by <i>pwSubEntryIndices</i>.
    ///    pwSubEntryIndices = Pointer to an array of <b>WORD</b>s. Each <b>WORD</b> in the array specifies the index of an entry that is to
    ///                        be considered a subentry of this entry.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetSubEntries(uint dwNumSubEntries, ushort* pwSubEntryIndices);
    ///The <b>GetSubEntries</b> method gets an array of subentry indices that were set by a previous call to
    ///SetSubEntries.
    ///Params:
    ///    pdwNumSubEntries = If <i>pwSubEntryIndices</i> is <b>NULL</b>, this is an output parameter that receives the number of
    ///                       subentries associated with this entry. If <i>pwSubEntryIndices</i> is not <b>NULL</b>, this is an input
    ///                       parameter that specifies the number of <b>DWORD</b>s in the caller-allocated array pointed to by
    ///                       <i>pwSubEntryIndices</i>.
    ///    pwSubEntryIndices = <b>NULL</b>, or a pointer to a caller-allocated array of <b>DWORD</b>s that receives the subentry indices.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td width="60%"> The method returns this error code if
    ///    <i>pwSubEntryIndices</i> is not <b>NULL</b> and the number of subentries is larger than the number specified
    ///    by <i>pdwNumSubEntries</i>. In that case, <i>pdwNumSubEntries</i> serves as an output parameter and receives
    ///    the number of available subentry indices. </td> </tr> </table>
    ///    
    HRESULT GetSubEntries(uint* pdwNumSubEntries, ushort* pwSubEntryIndices);
    ///The <b>SetDescriptionData</b> method associates a caller-supplied data block with the entry.
    ///Params:
    ///    dwDescriptionDataSize = The size, in bytes, of the data block.
    ///    pbtDescriptionData = Pointer to the first byte of the data block.
    ///    pguidType = Pointer to a <b>GUID</b> that identifies the type of data in the block. This parameter can be <b>NULL</b>.
    ///                See Remarks.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetDescriptionData(uint dwDescriptionDataSize, ubyte* pbtDescriptionData, GUID* pguidType);
    ///The <b>GetDescriptionData</b> method gets a description data block that was previously associated with the entry
    ///by a call to SetDescriptionData.
    ///Params:
    ///    pdwDescriptionDataSize = If <i>pbtDescriptionData</i> is <b>NULL</b>, this is an output parameter that receives the size, in bytes, of
    ///                             the description data block. If <i>pbtDescriptionData</i> is not <b>NULL</b>, this is an input parameter that
    ///                             specifies the size, in bytes, of the caller-allocated buffer pointed to by <i>pbtDescriptionData</i>.
    ///    pbtDescriptionData = NULL, or a pointer to a caller-allocated buffer that, on successful completion, receives the description data
    ///                         block.
    ///    pGuidType = Pointer to a variable that receives a globally unique identifier (GUID) that identifies the type of data in
    ///                the description data block. See Remarks.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td width="60%"> The method returns this error code if
    ///    <i>pbtDescriptionData</i> is not <b>NULL</b> and the context block is larger than the size specified by
    ///    <i>pdwDescriptionDataSize</i>. In that case, <i>pdwDescriptionDataSize</i> serves as an output parameter and
    ///    receives the size, in bytes, of the required buffer. </td> </tr> </table>
    ///    
    HRESULT GetDescriptionData(uint* pdwDescriptionDataSize, ubyte* pbtDescriptionData, GUID* pGuidType);
}

///The <b>ITocEntryList</b> interface represents a list of entries in a table of contents. It provides methods for
///adding entries to, and removing entries from the list.
@GUID("3A8CCCBD-0EFD-43A3-B838-F38A552BA237")
interface ITocEntryList : IUnknown
{
    ///The <b>GetEntryCount</b> method retrieves the number of entries in the list.
    ///Params:
    ///    pdwEntryCount = Pointer to a <b>DWORD</b> that receives the number of entries.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEntryCount(uint* pdwEntryCount);
    ///The <b>GetEntryByIndex</b> method retrieves an entry, specified by an index, from the list.
    ///Params:
    ///    dwEntryIndex = The index of the entry to retrieve.
    ///    ppEntry = Pointer to a variable that receives a pointer to an ITocEntry interface that represents the entry.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEntryByIndex(uint dwEntryIndex, ITocEntry* ppEntry);
    ///The <b>AddEntry</b> method adds an individual entry to the list and assigns an index to the entry.
    ///Params:
    ///    pEntry = Pointer to an ITocEntry interface that represents the entry to be added.
    ///    pdwEntryIndex = Pointer to a <b>DWORD</b> that receives the index of the added entry.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AddEntry(ITocEntry pEntry, uint* pdwEntryIndex);
    ///The <b>AddEntryByIndex</b> method adds an individual entry to the list and associates a caller-supplied index
    ///with the entry.
    ///Params:
    ///    dwEntryIndex = The index of the entry to be added.
    ///    pEntry = Pointer to an ITocEntry interface that represents the entry to be added.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AddEntryByIndex(uint dwEntryIndex, ITocEntry pEntry);
    ///The <b>RemoveEntryByIndex</b> method removes an entry, specified by an index, from the list.
    ///Params:
    ///    dwEntryIndex = The index of the entry to be removed.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RemoveEntryByIndex(uint dwEntryIndex);
}

///The <b>IToc</b> interface represents an individual table of contents. It provides methods for adding entries to, and
///removing entries from the table of contents.
@GUID("D6F05441-A919-423B-91A0-89D5B4A8AB77")
interface IToc : IUnknown
{
    ///The <b>SetDescriptor</b> method associates a descriptor with the table of contents.
    ///Params:
    ///    pDescriptor = Pointer to a TOC_DESCRIPTOR structure that contains the descriptor.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetDescriptor(TOC_DESCRIPTOR* pDescriptor);
    ///The <b>GetDescriptor</b> method retrieves the descriptor, previously set by SetDescriptor, of the table of
    ///contents.
    ///Params:
    ///    pDescriptor = Pointer to a TOC_DESCRIPTOR structure that receives the descriptor.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetDescriptor(TOC_DESCRIPTOR* pDescriptor);
    ///The <b>SetDescription</b> method associates a description with the table of contents.
    ///Params:
    ///    pwszDescription = Pointer to a NULL-terminated, wide-character string that contains the description.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetDescription(const(PWSTR) pwszDescription);
    ///The <b>GetDescription</b> method retrieves the description, set by a previous call to SetDescription, of the
    ///table of contents.
    ///Params:
    ///    pwDescriptionSize = If <i>pwszDescription</i> is <b>NULL</b>, this is an output parameter that receives the size, in wide
    ///                        characters, of the buffer required to receive the description. If <i>pwszDescription</i> is not <b>NULL</b>,
    ///                        this is an input parameter that specifies the size, in wide characters, of the caller-allocated buffer
    ///                        pointed to by <i>pwszDescription</i>.
    ///    pwszDescription = <b>NULL</b>, or a pointer to a caller-allocated buffer that, on successful completion, receives the
    ///                      description. The description is null-terminated.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td width="60%"> The method returns this error code if
    ///    <i>pwszDescription</i> is not <b>NULL</b> and the description, including its NULL terminator, is larger than
    ///    the size specified by <i>pwDescriptionSize</i>. In that case, <i>pwDescriptionSize</i> serves as an output
    ///    parameter and receives the size of the required buffer. </td> </tr> </table>
    ///    
    HRESULT GetDescription(ushort* pwDescriptionSize, PWSTR pwszDescription);
    ///The <b>SetContext</b> method associates a caller-supplied context block with the table of contents.
    ///Params:
    ///    dwContextSize = The size, in bytes, of the context block.
    ///    pbtContext = Pointer to the first byte of the context block.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetContext(uint dwContextSize, ubyte* pbtContext);
    ///The <b>GetContext</b> method retrieves a block of bytes that was previously associated with the table of contents
    ///by a call to SetContext.
    ///Params:
    ///    pdwContextSize = If <i>pbtContext</i> is <b>NULL</b>, this is an output parameter that receives the size, in bytes, of the
    ///                     context block. If <i>pbtContext</i> is not <b>NULL</b>, this is an input parameter that specifies the size,
    ///                     in bytes, of the caller-allocated buffer pointed to by <i>pbtContext</i>.
    ///    pbtContext = NULL, or a pointer to a caller-allocated buffer that, on successful completion, receives the context block.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td width="60%"> The method returns this error code if
    ///    <i>pbtContext</i> is not <b>NULL</b> and the context block is larger than the size specified by
    ///    <i>bdwContextSize</i>. In that case, <i>pdwContextSize</i> serves as an output parameter and receives the
    ///    size, in bytes, of the required buffer. </td> </tr> </table>
    ///    
    HRESULT GetContext(uint* pdwContextSize, ubyte* pbtContext);
    ///The <b>GetEntryListCount</b> method retrieves the number of entry lists in the table of contents.
    ///Params:
    ///    pwCount = Pointer to a <b>WORD</b> that receives the number of entry lists.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEntryListCount(ushort* pwCount);
    ///The <b>GetEntryListByIndex</b> method retrieves an entry list, specified by an index, from the table of contents.
    ///Params:
    ///    wEntryListIndex = The index of the entry list to retrieve.
    ///    ppEntryList = Pointer to a variable that receives a pointer to an ITocEntryList interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEntryListByIndex(ushort wEntryListIndex, ITocEntryList* ppEntryList);
    ///The <b>AddEntryList</b> method adds an entry list to the table of contents and assigns an index to the entry
    ///list.
    ///Params:
    ///    pEntryList = Pointer to an ITocEntryList interface that represents the entry list to be added.
    ///    pwEntryListIndex = Receives the index of the added entry list.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AddEntryList(ITocEntryList pEntryList, ushort* pwEntryListIndex);
    ///The <b>AddEntryListByIndex</b> method adds an entry list to the table of contents and associates a
    ///caller-supplied index with the entry list.
    ///Params:
    ///    wEntryListIndex = The index, specified by the caller, to be associated with the entry list.
    ///    pEntryList = Pointer to an ITocEntryList interface that represents the entry list to be added.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AddEntryListByIndex(ushort wEntryListIndex, ITocEntryList pEntryList);
    ///The <b>RemoveEntryListByIndex</b> method removes an entry list, specified by an index, from the table of
    ///contents.
    ///Params:
    ///    wEntryListIndex = The index of the entry list to be removed.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RemoveEntryListByIndex(ushort wEntryListIndex);
}

///The <b>ITocCollection</b> represents a collection of tables of contents. It provides methods for adding, retrieving,
///and removing, tables of contents from the collection.
@GUID("23FEE831-AE96-42DF-B170-25A04847A3CA")
interface ITocCollection : IUnknown
{
    ///The <b>GetEntryCount</b> method retrieves the number of tables of contents in the collection.
    ///Params:
    ///    pdwEntryCount = Pointer to a <b>DWORD</b> that receives the number of tables of contents.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEntryCount(uint* pdwEntryCount);
    ///The <b>GetEntryByIndex</b> method retrieves a table of contents, specified by an index, from the collection.
    ///Params:
    ///    dwEntryIndex = Specifies the index of the table of contents to retrieve.
    ///    ppToc = Pointer to a variable that receives a pointer to an IToc interface that represents the table of contents.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEntryByIndex(uint dwEntryIndex, IToc* ppToc);
    ///The <b>AddEntry</b> method adds an individual table of contents to the collection and assigns an index to the
    ///added table of contents.
    ///Params:
    ///    pToc = Pointer to an IToc interface that represents the table of contents to be added.
    ///    pdwEntryIndex = Pointer to a <b>DWORD</b> that receives the index of the added table of contents.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AddEntry(IToc pToc, uint* pdwEntryIndex);
    ///The <b>AddEntryByIndex</b> adds an individual table of contents to the collection and associates a
    ///caller-supplied index with the table of contents.
    ///Params:
    ///    dwEntryIndex = The index, specified by the caller, to be associated with the table of contents.
    ///    pToc = Pointer to an IToc interface that represents the table of contents to be added.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AddEntryByIndex(uint dwEntryIndex, IToc pToc);
    ///The <b>RemoveEntryByIndex</b> method removes a table of contents, specified by an index, from the collection.
    ///Params:
    ///    dwEntryIndex = Specifies the index of the table of contents to be removed.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RemoveEntryByIndex(uint dwEntryIndex);
}

///The <b>ITocParser</b> interface represents a TOC Parser object. It provides methods for storing tables of contents in
///a video file and retrieving tables of contents from a video file.
@GUID("ECFB9A55-9298-4F49-887F-0B36206599D2")
interface ITocParser : IUnknown
{
    ///The <b>Init</b> method initializes the TOC Parser object and associates it with a media file.
    ///Params:
    ///    pwszFileName = Pointer to a NULL-terminated wide-character string that specifies the path of the media file. See Remarks.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Init(const(PWSTR) pwszFileName);
    ///The <b>GetTocCount</b> method retrieves the number of tables of contents, of a specified position type, in the
    ///TOC Parser object.
    ///Params:
    ///    arg1 = A member of the TOC_POS_TYPE enumeration that specifies the position type of the tables of contents to be
    ///           counted.
    ///    pdwTocCount = Pointer to a <b>DWORD</b> that receives the number of tables of contents.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTocCount(TOC_POS_TYPE enumTocPosType, uint* pdwTocCount);
    ///The <b>GetTocByIndex</b> method retrieves a table of contents, specified by an index, from the TOC Parser object.
    ///Params:
    ///    arg1 = A member of the TOC_POS_TYPE enumeration that specifies the position type of the table of contents to be
    ///           retrieved.
    ///    dwTocIndex = The index of the table of contents to be retrieved.
    ///    ppToc = Pointer to a variable that receives a pointer to an IToc interface that represents the retrieved table of
    ///            contents.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTocByIndex(TOC_POS_TYPE enumTocPosType, uint dwTocIndex, IToc* ppToc);
    ///The <b>GetTocByType</b> retrieves all tables of contents of a specified type from the TOC Parser object.
    ///Params:
    ///    arg1 = A member of the TOC_POS_TYPE enumeration that specifies the position type of the table of contents to be
    ///           retrieved.
    ///    guidTocType = A globally unique identifier (<b>GUID</b>) that specifies the type of table of contents to retrieve. See
    ///                  Remarks.
    ///    ppTocs = Pointer to an ITocCollection interface that represents the colleciton of retrieved tables of contents.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTocByType(TOC_POS_TYPE enumTocPosType, GUID guidTocType, ITocCollection* ppTocs);
    ///The <b>AddToc</b> method adds a table of contents to the TOC Parser object and assigns an index to the added
    ///table of contents.
    ///Params:
    ///    arg1 = A member of the TOC_POS_TYPE enumeration that specifies the position type of the table of contents to be
    ///           added.
    ///    pToc = Pointer to an IToc interface that represents the table of contents to be added.
    ///    pdwTocIndex = Pointer to a <b>DWORD</b> that receives the index of the added table of contents.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AddToc(TOC_POS_TYPE enumTocPosType, IToc pToc, uint* pdwTocIndex);
    ///The <b>RemoveTocByIndex</b> method removes a table of contents, specified by an index, from the TOC Parser
    ///object.
    ///Params:
    ///    arg1 = A member of the TOC_POS_TYPE enumeration that specifies the position type of the table of contents to be
    ///           removed.
    ///    dwTocIndex = The index of the table of contents to be removed.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RemoveTocByIndex(TOC_POS_TYPE enumTocPosType, uint dwTocIndex);
    ///The <b>RemoveTocByType</b> method removes all tables of contents of a specified type from the TOC Parser object.
    ///Params:
    ///    arg1 = A member of the TOC_POS_TYPE enumeration that specifies the position type of the tables of contents to be
    ///           removed.
    ///    guidTocType = A globally unique identifier (<b>GUID</b>) that specifies the type of table of contents to removed. See
    ///                  Remarks.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RemoveTocByType(TOC_POS_TYPE enumTocPosType, GUID guidTocType);
    ///The <b>Commit</b> method stores the current state of the TOC Parser object in its associated media file.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Commit();
}

@GUID("11993196-1244-4840-AB44-480975C4FFE4")
interface IFileIo : IUnknown
{
    HRESULT Initialize(FILE_ACCESSMODE eAccessMode, FILE_OPENMODE eOpenMode, const(PWSTR) pwszFileName);
    HRESULT GetLength(ulong* pqwLength);
    HRESULT SetLength(ulong qwLength);
    HRESULT GetCurrentPosition(ulong* pqwPosition);
    HRESULT SetCurrentPosition(ulong qwPosition);
    HRESULT IsEndOfStream(BOOL* pbEndOfStream);
    HRESULT Read(ubyte* pbt, uint ul, uint* pulRead);
    HRESULT Write(ubyte* pbt, uint ul, uint* pulWritten);
    HRESULT Seek(SEEK_ORIGIN eSeekOrigin, ulong qwSeekOffset, uint dwSeekFlags, ulong* pqwCurrentPosition);
    HRESULT Close();
}

@GUID("BFCCD196-1244-4840-AB44-480975C4FFE4")
interface IFileClient : IUnknown
{
    HRESULT GetObjectDiskSize(ulong* pqwSize);
    HRESULT Write(IFileIo pFio);
    HRESULT Read(IFileIo pFio);
}

@GUID("3F07F7B7-C680-41D9-9423-915107EC9FF9")
interface IClusterDetector : IUnknown
{
    HRESULT Initialize(ushort wBaseEntryLevel, ushort wClusterEntryLevel);
    HRESULT Detect(uint dwMaxNumClusters, float fMinClusterDuration, float fMaxClusterDuration, IToc pSrcToc, 
                   IToc* ppDstToc);
}

///Represents a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device. To get a pointer to this
///interface, call the DXVAHD_CreateDevice function.
@GUID("95F12DFD-D77E-49BE-815F-57D579634D6D")
interface IDXVAHD_Device : IUnknown
{
    ///Creates one or more Microsoft Direct3D video surfaces.
    ///Params:
    ///    Width = The width of each surface, in pixels.
    ///    Height = The height of each surface, in pixels.
    ///    Format = The pixel format, specified as a <b>D3DFORMAT</b> value or FOURCC code. For more information, see Video
    ///             FOURCCs.
    ///    Pool = The memory pool in which the surface is created. This parameter must equal the <b>InputPool</b> member of the
    ///           DXVAHD_VPDEVCAPS structure. Call the IDXVAHD_Device::GetVideoProcessorDeviceCaps method to get this value.
    ///    Usage = Reserved. Set to 0.
    ///    Type = The type of surface to create, specified as a member of the DXVAHD_SURFACE_TYPE enumeration.
    ///    NumSurfaces = The number of surfaces to create.
    ///    ppSurfaces = A pointer to an array of <b>IDirect3DSurface9</b> pointers. The <i>NumSurfaces</i> parameter specifies the
    ///                 number of elements in the array. The method fills the array with pointers to the new video surfaces. The
    ///                 caller must release the pointers.
    ///    pSharedHandle = Reserved. Set to <b>NULL</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateVideoSurface(uint Width, uint Height, D3DFORMAT Format, D3DPOOL Pool, uint Usage, 
                               DXVAHD_SURFACE_TYPE Type, uint NumSurfaces, IDirect3DSurface9* ppSurfaces, 
                               HANDLE* pSharedHandle);
    ///Gets the capabilities of the Microsoft DirectX Video Acceleration High Definition (DXVA-HD) device.
    ///Params:
    ///    pCaps = A pointer to a DXVAHD_VPDEVCAPS structure that receives the device capabilities.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoProcessorDeviceCaps(DXVAHD_VPDEVCAPS* pCaps);
    ///Gets a list of the output formats supported by the Microsoft DirectX Video Acceleration High Definition (DXVA-HD)
    ///device.
    ///Params:
    ///    Count = The number of formats to retrieve. This parameter must equal the <b>OutputFormatCount</b> member of the
    ///            DXVAHD_VPDEVCAPS structure. Call the IDXVAHD_Device::GetVideoProcessorDeviceCaps method to get this value.
    ///    pFormats = A pointer to an array of <b>D3DFORMAT</b> values. The <i>Count</i> parameter specifies the number of elements
    ///               in the array. The method fills the array with a list of output formats.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoProcessorOutputFormats(uint Count, D3DFORMAT* pFormats);
    ///Gets a list of the input formats supported by the Microsoft DirectX Video Acceleration High Definition (DXVA-HD)
    ///device.
    ///Params:
    ///    Count = The number of formats to retrieve. This parameter must equal the <b>InputFormatCount</b> member of the
    ///            DXVAHD_VPDEVCAPS structure. Call the IDXVAHD_Device::GetVideoProcessorDeviceCaps method to get this value.
    ///    pFormats = A pointer to an array of <b>D3DFORMAT</b> values. The <i>Count</i> parameter specifies the number of elements
    ///               in the array. The method fills the array with a list of input formats.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoProcessorInputFormats(uint Count, D3DFORMAT* pFormats);
    ///Gets the capabilities of one or more Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video
    ///processors.
    ///Params:
    ///    Count = The number of elements in the <i>pCaps</i> array. This parameter must equal the <b>VideoProcessorCount</b>
    ///            member of the DXVAHD_VPDEVCAPS structure. Call the IDXVAHD_Device::GetVideoProcessorDeviceCaps method to get
    ///            this value.
    ///    pCaps = A pointer to an array of DXVAHD_VPCAPS structures. The method fills the structures with the capabilities of
    ///            the video processors supported by the driver.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoProcessorCaps(uint Count, DXVAHD_VPCAPS* pCaps);
    ///Gets a list of custom rates that a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video processor
    ///supports. Custom rates are used for frame-rate conversion and inverse telecine (IVTC).
    ///Params:
    ///    pVPGuid = A GUID that identifies the video processor to query. This GUID must equal the valud of the <b>VPGuid</b>
    ///              member from one of the DXVAHD_VPCAPS structures retrieved by the IDXVAHD_Device::GetVideoProcessorCaps
    ///              method.
    ///    Count = The number of rates to retrieve. This parameter must equal the <b>CustomRateCount</b> member of the
    ///            DXVAHD_VPCAPS structure for the video processor.
    ///    pRates = A pointer to an array of DXVAHD_CUSTOM_RATE_DATA structures. The <i>Count</i> parameter specifies the number
    ///             of elements in the array. The method fills the array with a list of custom rates.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoProcessorCustomRates(const(GUID)* pVPGuid, uint Count, DXVAHD_CUSTOM_RATE_DATA* pRates);
    ///Gets the range of values for an image filter that the Microsoft DirectX Video Acceleration High Definition
    ///(DXVA-HD) device supports.
    ///Params:
    ///    Filter = The type of image filter, specified as a member of the DXVAHD_FILTER enumeration.
    ///    pRange = A pointer to a DXVAHD_FILTER_RANGE_DATA structure. The method fills the structure with the range of values
    ///             for the specified filter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>Filter</i> parameter is invalid or the
    ///    device does not support the specified filter. </td> </tr> </table>
    ///    
    HRESULT GetVideoProcessorFilterRange(DXVAHD_FILTER Filter, DXVAHD_FILTER_RANGE_DATA* pRange);
    ///Creates a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video processor.
    ///Params:
    ///    pVPGuid = A GUID that identifies the video processor to create. This GUID must equal the value of the <b>VPGuid</b>
    ///              member from one of the DXVAHD_VPCAPS structures retrieved by the IDXVAHD_Device::GetVideoProcessorCaps
    ///              method.
    ///    ppVideoProcessor = Receives a pointer to the IDXVAHD_VideoProcessor interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateVideoProcessor(const(GUID)* pVPGuid, IDXVAHD_VideoProcessor* ppVideoProcessor);
}

///Represents a Microsoft DirectX Video Acceleration High Definition (DXVA-HD) video processor. To get a pointer to this
///interface, call the IDXVAHD_Device::CreateVideoProcessor method.
@GUID("95F4EDF4-6E03-4CD7-BE1B-3075D665AA52")
interface IDXVAHD_VideoProcessor : IUnknown
{
    ///Sets a state parameter for a blit operation by a Microsoft DirectX Video Acceleration High Definition (DXVA-HD)
    ///device.
    ///Params:
    ///    State = The state parameter to set, specified as a member of the DXVAHD_BLT_STATE enumeration.
    ///    DataSize = The size, in bytes, of the buffer pointed to by <i>pData</i>.
    ///    pData = A pointer to a buffer that contains the state data. The meaning of the data depends on the <i>State</i>
    ///            parameter. Each state has a corresponding data structure; for more information, see DXVAHD_BLT_STATE. The
    ///            caller allocates the buffer and fills in the parameter data before calling this method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetVideoProcessBltState(DXVAHD_BLT_STATE State, uint DataSize, const(void)* pData);
    ///Gets the value of a state parameter for blit operations performed by a Microsoft DirectX Video Acceleration High
    ///Definition (DXVA-HD) device.
    ///Params:
    ///    State = The state parameter to query, specified as a member of the DXVAHD_BLT_STATE enumeration.
    ///    DataSize = The size, in bytes, of the buffer pointed to by <i>pData</i>.
    ///    pData = A pointer to a buffer allocated by the caller. The method copies the state data into the buffer. The buffer
    ///            must be large enough to hold the data structure that corresponds to the state parameter. For more
    ///            information, see DXVAHD_BLT_STATE.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoProcessBltState(DXVAHD_BLT_STATE State, uint DataSize, void* pData);
    ///Sets a state parameter for an input stream on a Microsoft DirectX Video Acceleration High Definition (DXVA-HD)
    ///device.
    ///Params:
    ///    StreamNumber = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                   IDXVAHD_Device::GetVideoProcessorDeviceCaps and check the <b>MaxStreamStates</b> member of the
    ///                   DXVAHD_VPDEVCAPS structure.
    ///    State = The state parameter to set, specified as a member of the DXVAHD_STREAM_STATE enumeration.
    ///    DataSize = The size, in bytes, of the buffer pointed to by <i>pData</i>.
    ///    pData = A pointer to a buffer that contains the state data. The meaning of the data depends on the <i>State</i>
    ///            parameter. Each state has a corresponding data structure; for more information, see DXVAHD_STREAM_STATE. The
    ///            caller allocates the buffer and fills in the parameter data before calling this method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetVideoProcessStreamState(uint StreamNumber, DXVAHD_STREAM_STATE State, uint DataSize, 
                                       const(void)* pData);
    ///Gets the value of a state parameter for an input stream on a Microsoft DirectX Video Acceleration High Definition
    ///(DXVA-HD) device.
    ///Params:
    ///    StreamNumber = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                   IDXVAHD_Device::GetVideoProcessorDeviceCaps and check the <b>MaxStreamStates</b> member of the
    ///                   DXVAHD_VPDEVCAPS structure.
    ///    State = The state parameter to query, specified as a member of the DXVAHD_STREAM_STATE enumeration.
    ///    DataSize = The size, in bytes, of the buffer pointed to by <i>pData</i>.
    ///    pData = A pointer to a buffer allocated by the caller. The method copies the state data into the buffer. The buffer
    ///            must be large enough to hold the data structure that corresponds to the state parameter. For more
    ///            information, see DXVAHD_STREAM_STATE.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoProcessStreamState(uint StreamNumber, DXVAHD_STREAM_STATE State, uint DataSize, void* pData);
    ///Performs a video processing blit on one or more input samples and writes the result to a Microsoft Direct3D
    ///surface.
    ///Params:
    ///    pOutputSurface = A pointer to the <b>IDirect3DSurface9</b> interface of a Direct3D surface. The output of the video processing
    ///                     operation will be written to this surface. The following surface types can be used: <ul> <li>A video surface
    ///                     of type <b>DXVAHD_SURFACE_TYPE_VIDEO_OUTPUT</b>. See IDXVAHD_Device::CreateVideoSurface. </li> <li>A
    ///                     render-target surface or texture surface created with D3DUSAGE_RENDERTARGET usage.</li> <li>A swap
    ///                     chain.</li> <li>A swap chain with overlay support (<b>D3DSWAPEFFECT_OVERLAY</b>).</li> </ul>
    ///    OutputFrame = Frame number of the output video frame, indexed from zero.
    ///    StreamCount = Number of input streams to process.
    ///    pStreams = Pointer to an array of DXVAHD_STREAM_DATA structures that contain information about the input streams. The
    ///               caller allocates the array and fills in each structure. The number of elements in the array is given in the
    ///               <i>StreamCount</i> parameter.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT VideoProcessBltHD(IDirect3DSurface9 pOutputSurface, uint OutputFrame, uint StreamCount, 
                              const(DXVAHD_STREAM_DATA)* pStreams);
}

///Enables two threads to share the same Direct3D 9 device, and provides access to the DirectX Video Acceleration (DXVA)
///features of the device.
@GUID("A0CADE0F-06D5-4CF4-A1C7-F3CDD725AA75")
interface IDirect3DDeviceManager9 : IUnknown
{
    ///Sets the Direct3D device or notifies the device manager that the Direct3D device was reset.
    ///Params:
    ///    pDevice = Pointer to the <b>IDirect3DDevice9</b> interface of the Direct3D device.
    ///    resetToken = Token received in the <i>pResetToken</i> parameter of the DXVA2CreateDirect3DDeviceManager9 function.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid token </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>D3DERR_INVALIDCALL</b></dt> </dl> </td> <td width="60%"> Direct3D device error. </td> </tr>
    ///    </table>
    ///    
    HRESULT ResetDevice(IDirect3DDevice9 pDevice, uint resetToken);
    ///Gets a handle to the Direct3D device.
    ///Params:
    ///    phDevice = Receives the device handle.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>DXVA2_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The Direct3D device manager was not
    ///    initialized. The owner of the device must call IDirect3DDeviceManager9::ResetDevice. </td> </tr> </table>
    ///    
    HRESULT OpenDeviceHandle(HANDLE* phDevice);
    ///Closes a Direct3D device handle. Call this method to release a device handle retrieved by the
    ///IDirect3DDeviceManager9::OpenDeviceHandle method.
    ///Params:
    ///    hDevice = Handle to the Direct3D device.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_HANDLE</b></dt> </dl> </td> <td width="60%"> Invalid handle. </td> </tr> </table>
    ///    
    HRESULT CloseDeviceHandle(HANDLE hDevice);
    ///Tests whether a Direct3D device handle is valid.
    ///Params:
    ///    hDevice = Handle to a Direct3D device. To get a device handle, call IDirect3DDeviceManager9::OpenDeviceHandle.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The device handle is valid. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_HANDLE</b></dt> </dl> </td> <td width="60%"> The specified handle is not a
    ///    Direct3D device handle. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DXVA2_E_NEW_VIDEO_DEVICE</b></dt> </dl>
    ///    </td> <td width="60%"> The device handle is invalid. </td> </tr> </table>
    ///    
    HRESULT TestDevice(HANDLE hDevice);
    ///Gives the caller exclusive access to the Direct3D device.
    ///Params:
    ///    hDevice = A handle to the Direct3D device. To get the device handle, call IDirect3DDeviceManager9::OpenDeviceHandle.
    ///    ppDevice = Receives a pointer to the device's <b>IDirect3DDevice9</b> interface.
    ///    fBlock = Specifies whether to wait for the device lock. If the device is already locked and this parameter is
    ///             <b>TRUE</b>, the method blocks until the device is unlocked. Otherwise, if the device is locked and this
    ///             parmater is <b>FALSE</b>, the method returns immediately with the error code
    ///             <b>DXVA2_E_VIDEO_DEVICE_LOCKED</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>DXVA2_E_NEW_VIDEO_DEVICE</b></dt> </dl> </td> <td width="60%"> The device handle is invalid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DXVA2_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%">
    ///    The Direct3D device manager was not initialized. The owner of the device must call
    ///    IDirect3DDeviceManager9::ResetDevice. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DXVA2_E_VIDEO_DEVICE_LOCKED</b></dt> </dl> </td> <td width="60%"> The device is locked and
    ///    <i>fBlock</i> is <b>FALSE</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_HANDLE</b></dt> </dl> </td>
    ///    <td width="60%"> The specified handle is not a Direct3D device handle. </td> </tr> </table>
    ///    
    HRESULT LockDevice(HANDLE hDevice, IDirect3DDevice9* ppDevice, BOOL fBlock);
    ///Unlocks the Direct3D device. Call this method to release the device after calling
    ///IDirect3DDeviceManager9::LockDevice.
    ///Params:
    ///    hDevice = Handle to the Direct3D device. To get the device handle, call IDirect3DDeviceManager9::OpenDeviceHandle.
    ///    fSaveState = If <b>TRUE</b>, the method saves the Direct3D device state in a state block. Internally, the method uses the
    ///                 Direct3D <b>IDirect3DStateBlock9</b> interface to save the device state. The next time you call LockDevice
    ///                 with the same device handle, the state block is restored.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified device handle is not locked, or
    ///    is not a valid handle. </td> </tr> </table>
    ///    
    HRESULT UnlockDevice(HANDLE hDevice, BOOL fSaveState);
    ///Gets a DirectX Video Acceleration (DXVA) service interface.
    ///Params:
    ///    hDevice = A handle to a Direct3D device. To get a device handle, call IDirect3DDeviceManager9::OpenDeviceHandle.
    ///    riid = The interface identifier (IID) of the requested interface. The Direct3D device might support the following
    ///           DXVA service interfaces: <ul> <li> IDirectXVideoDecoderService </li> <li> IDirectXVideoProcessorService </li>
    ///           </ul>
    ///    ppService = Receives a pointer to the requested interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>DXVA2_E_NEW_VIDEO_DEVICE</b></dt> </dl> </td> <td width="60%"> The device handle is invalid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DXVA2_E_NOT_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The
    ///    Direct3D device does not support video acceleration. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DXVA2_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The Direct3D device manager was not
    ///    initialized. The owner of the device must call IDirect3DDeviceManager9::ResetDevice. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_HANDLE</b></dt> </dl> </td> <td width="60%"> The specified handle is not a
    ///    Direct3D device handle. </td> </tr> </table>
    ///    
    HRESULT GetVideoService(HANDLE hDevice, const(GUID)* riid, void** ppService);
}

///Provides DirectX Video Acceleration (DXVA) services from a Direct3D device. To get a pointer to this interface, call
///IDirect3DDeviceManager9::GetVideoService or DXVA2CreateVideoService.
@GUID("FC51A550-D5E7-11D9-AF55-00054E43FF02")
interface IDirectXVideoAccelerationService : IUnknown
{
    ///Creates a DirectX Video Acceleration (DXVA) video processor or DXVA decoder render target.
    ///Params:
    ///    Width = The width of the surface, in pixels.
    ///    Height = The height of the surface, in pixels.
    ///    BackBuffers = The number of back buffers. The method creates <i>BackBuffers</i> + 1 surfaces.
    ///    Format = The pixel format, specified as a <b>D3DFORMAT</b> value or FOURCC code. For more information, see the
    ///             Direct3D documentation.
    ///    Pool = The memory pool in which to create the surface, specified as a <b>D3DPOOL</b> value. For more information,
    ///           see the Direct3D documentation. Decoders should generally use the value D3DPOOL_DEFAULT.
    ///    Usage = Reserved. Set this value to zero.
    ///    DxvaType = The type of surface to create. Use one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///               </tr> <tr> <td width="40%"><a id="DXVA2_VideoDecoderRenderTarget"></a><a
    ///               id="dxva2_videodecoderrendertarget"></a><a id="DXVA2_VIDEODECODERRENDERTARGET"></a><dl>
    ///               <dt><b>DXVA2_VideoDecoderRenderTarget</b></dt> </dl> </td> <td width="60%"> Video decoder render target.
    ///               </td> </tr> <tr> <td width="40%"><a id="DXVA2_VideoProcessorRenderTarget"></a><a
    ///               id="dxva2_videoprocessorrendertarget"></a><a id="DXVA2_VIDEOPROCESSORRENDERTARGET"></a><dl>
    ///               <dt><b>DXVA2_VideoProcessorRenderTarget</b></dt> </dl> </td> <td width="60%"> Video processor render target.
    ///               Used for IDirectXVideoProcessor::VideoProcessBlt operations. </td> </tr> <tr> <td width="40%"><a
    ///               id="DXVA2_VideoSoftwareRenderTarget"></a><a id="dxva2_videosoftwarerendertarget"></a><a
    ///               id="DXVA2_VIDEOSOFTWARERENDERTARGET"></a><dl> <dt><b>DXVA2_VideoSoftwareRenderTarget</b></dt> </dl> </td> <td
    ///               width="60%"> Software render target. This surface type is for use with software DXVA devices. </td> </tr>
    ///               </table>
    ///    ppSurface = The address of an array of <b>IDirect3DSurface9</b> pointers allocated by the caller. The size of the array
    ///                must be 1 + <i>BackBuffers</i> (enough for the back buffers plus one front buffer). The method fills the
    ///                array with <b>IDirect3DSurface9</b> pointers. The caller must release all of the interface pointers. In
    ///                addition, the front buffer holds a reference count on each of the back buffers. Therefore, the back buffers
    ///                are never deleted until the front buffer is deleted.
    ///    pSharedHandle = A pointer to a handle that is used to share the surfaces between Direct3D devices. Set this parameter to
    ///                    <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>D3DERR_INVALIDCALL</b></dt> </dl> </td> <td width="60%"> Invalid parameter </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The DirectX Video Acceleration Manager
    ///    is not initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> <b>NULL</b> pointer argument. </td> </tr> </table>
    ///    
    HRESULT CreateSurface(uint Width, uint Height, uint BackBuffers, D3DFORMAT Format, D3DPOOL Pool, uint Usage, 
                          uint DxvaType, IDirect3DSurface9* ppSurface, HANDLE* pSharedHandle);
}

///Provides access to DirectX Video Acceleration (DXVA) decoder services. Use this interface to query which
///hardware-accelerated decoding operations are available and to create DXVA video decoder devices. To get a pointer to
///this interface, call IDirect3DDeviceManager9::GetVideoService or DXVA2CreateVideoService with the interface
///identifier IID_IDirectXVideoDecoderService.
@GUID("FC51A551-D5E7-11D9-AF55-00054E43FF02")
interface IDirectXVideoDecoderService : IDirectXVideoAccelerationService
{
    ///Retrieves an array of GUIDs that identifies the decoder devices supported by the graphics hardware.
    ///Params:
    ///    pCount = Receives the number of GUIDs.
    ///    pGuids = Receives an array of GUIDs. The size of the array is retrieved in the <i>Count</i> parameter. The method
    ///             allocates the memory for the array. The caller must free the memory by calling CoTaskMemFree.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>D3DERR_INVALIDCALL</b></dt> </dl> </td> <td width="60%"> Error from the Direct3D device. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> If the Microsoft Basic
    ///    Display Adapter is being used or the Direct3D 11 device type is the reference rasterizer. These devices do
    ///    not support video decoders. </td> </tr> </table>
    ///    
    HRESULT GetDecoderDeviceGuids(uint* pCount, GUID** pGuids);
    ///Retrieves the supported render targets for a specified decoder device.
    ///Params:
    ///    Guid = GUID that identifies the decoder device. To get the available device GUIDs, call
    ///           IDirectXVideoDecoderService::GetDecoderDeviceGuids.
    ///    pCount = Receives the number of formats.
    ///    pFormats = Receives an array of formats, specified as <b>D3DFORMAT</b> values. The size of the array is retrieved in the
    ///               <i>pCount</i> parameter. The method allocates the memory for the array. The caller must free the memory by
    ///               calling CoTaskMemFree.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetDecoderRenderTargets(const(GUID)* Guid, uint* pCount, D3DFORMAT** pFormats);
    ///Gets the configurations that are available for a decoder device.
    ///Params:
    ///    Guid = A GUID that identifies the decoder device. To get the available device GUIDs, call
    ///           IDirectXVideoDecoderService::GetDecoderDeviceGuids.
    ///    pVideoDesc = A pointer to a DXVA2_VideoDesc structure that describes the video content.
    ///    pReserved = Reserved. Set to <b>NULL</b>.
    ///    pCount = Receives the number of configurations.
    ///    ppConfigs = Receives an array of DXVA2_ConfigPictureDecode structures. The size of the array is retrieved in the
    ///                <i>pCount</i> parameter. The caller must free the memory for the array by calling CoTaskMemFree. This
    ///                parameter can be <b>NULL</b> if you simply want the number of configurations (returned in <i>pCount</i>) but
    ///                not the GUIDs.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDecoderConfigurations(const(GUID)* Guid, const(DXVA2_VideoDesc)* pVideoDesc, void* pReserved, 
                                     uint* pCount, DXVA2_ConfigPictureDecode** ppConfigs);
    ///Creates a video decoder device.
    ///Params:
    ///    Guid = GUID that specifies the decoder device to create. To get the available device GUIDs, call
    ///           IDirectXVideoDecoderService::GetDecoderDeviceGuids.
    ///    pVideoDesc = Pointer to a DXVA2_VideoDesc structure that describes the video content.
    ///    pConfig = Pointer to a DXVA2_ConfigPictureDecode structure that specifies the decoder configuration.
    ///    ppDecoderRenderTargets = Pointer to an array of <b>IDirect3DSurface9</b> pointers containing pointers to the decoder render targets.
    ///                             To create these surfaces, call IDirectXVideoAccelerationService::CreateSurface. Specify
    ///                             DXVA2_VideoDecoderRenderTarget for the <i>DxvaType</i> parameter.
    ///    NumRenderTargets = Size of the <i>ppDecoderRenderTargets</i> array. This value cannot be zero.
    ///    ppDecode = Receives a pointer to the decoder's IDirectXVideoDecoder interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CreateVideoDecoder(const(GUID)* Guid, const(DXVA2_VideoDesc)* pVideoDesc, 
                               const(DXVA2_ConfigPictureDecode)* pConfig, IDirect3DSurface9* ppDecoderRenderTargets, 
                               uint NumRenderTargets, IDirectXVideoDecoder* ppDecode);
}

///Provides access to DirectX Video Acceleration (DXVA) video processing services. Use this interface to query which
///hardware-accelerated video processing operations are available and to create DXVA video processor devices. To obtain
///a pointer to this interface, call IDirect3DDeviceManager9::GetVideoService or DXVA2CreateVideoService with the
///interface identifier <b>IID_IDirectXVideoProcessorService</b>.
@GUID("FC51A552-D5E7-11D9-AF55-00054E43FF02")
interface IDirectXVideoProcessorService : IDirectXVideoAccelerationService
{
    ///Registers a software video processing device.
    ///Params:
    ///    pCallbacks = Pointer to an initialization function.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterVideoProcessorSoftwareDevice(void* pCallbacks);
    ///Gets an array of GUIDs which identify the video processors supported by the graphics hardware.
    ///Params:
    ///    pVideoDesc = Pointer to a DXVA2_VideoDesc structure that describes the video content.
    ///    pCount = Receives the number of GUIDs.
    ///    pGuids = Receives an array of GUIDs. The size of the array is retrieved in the <i>pCount</i> parameter. The method
    ///             allocates the memory for the array. The caller must free the memory by calling CoTaskMemFree.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoProcessorDeviceGuids(const(DXVA2_VideoDesc)* pVideoDesc, uint* pCount, GUID** pGuids);
    ///Gets the render target formats that a video processor device supports. The list may include RGB and YUV formats.
    ///Params:
    ///    VideoProcDeviceGuid = A GUID that identifies the video processor device. To get the list of video processor GUIDs, call
    ///                          IDirectXVideoProcessorService::GetVideoProcessorDeviceGuids.
    ///    pVideoDesc = A pointer to a DXVA2_VideoDesc structure that describes the video content.
    ///    pCount = Receives the number of formats.
    ///    pFormats = Receives an array of formats, specified as <b>D3DFORMAT</b> values. The size of the array is retrieved in the
    ///               <i>pCount</i> parameter. The method allocates the memory for the array. The caller must free the memory by
    ///               calling CoTaskMemFree.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVideoProcessorRenderTargets(const(GUID)* VideoProcDeviceGuid, const(DXVA2_VideoDesc)* pVideoDesc, 
                                           uint* pCount, D3DFORMAT** pFormats);
    ///Gets a list of substream formats supported by a specified video processor device.
    ///Params:
    ///    VideoProcDeviceGuid = A GUID that identifies the video processor device. To get the list of video processor GUIDs, call
    ///                          IDirectXVideoProcessorService::GetVideoProcessorDeviceGuids.
    ///    pVideoDesc = A pointer to a DXVA2_VideoDesc structure that describes the video content.
    ///    RenderTargetFormat = The format of the render target surface, specified as a <b>D3DFORMAT</b> value. For more information, see the
    ///                         Direct3D documentation. You can also use a FOURCC code to specify a format that is not defined in the
    ///                         <b>D3DFORMAT</b> enumeration. See Video FOURCCs.
    ///    pCount = Receives the number of elements returned in the <i>ppFormats</i> array.
    ///    pFormats = Receives an array of <b>D3DFORMAT</b> values. The caller must free the array by calling CoTaskMemFree. The
    ///               array can contain both RGB and YUB pixel formats.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoProcessorSubStreamFormats(const(GUID)* VideoProcDeviceGuid, const(DXVA2_VideoDesc)* pVideoDesc, 
                                              D3DFORMAT RenderTargetFormat, uint* pCount, D3DFORMAT** pFormats);
    ///Gets the capabilities of a specified video processor device.
    ///Params:
    ///    VideoProcDeviceGuid = A GUID that identifies the video processor device. To get the list of video processor GUIDs, call
    ///                          IDirectXVideoProcessorService::GetVideoProcessorDeviceGuids.
    ///    pVideoDesc = A pointer to a DXVA2_VideoDesc structure that describes the video content.
    ///    RenderTargetFormat = The format of the render target surface, specified as a <b>D3DFORMAT</b> value. For more information, see the
    ///                         Direct3D documentation. You can also use a FOURCC code to specify a format that is not defined in the
    ///                         <b>D3DFORMAT</b> enumeration. See Video FOURCCs.
    ///    pCaps = A pointer to a DXVA2_VideoProcessorCaps structure that receives the video processor capabilities.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVideoProcessorCaps(const(GUID)* VideoProcDeviceGuid, const(DXVA2_VideoDesc)* pVideoDesc, 
                                  D3DFORMAT RenderTargetFormat, DXVA2_VideoProcessorCaps* pCaps);
    ///Gets the range of values for a video processor (ProcAmp) setting.
    ///Params:
    ///    VideoProcDeviceGuid = A GUID that identifies the video processor device. To get the list of video processor GUIDs, call
    ///                          IDirectXVideoProcessorService::GetVideoProcessorDeviceGuids.
    ///    pVideoDesc = A pointer to a DXVA2_VideoDesc structure that describes the video content.
    ///    RenderTargetFormat = The format of the render target surface, specified as a <b>D3DFORMAT</b> value. For more information, see the
    ///                         Direct3D documentation. You can also use a FOURCC code to specify a format that is not defined in the
    ///                         <b>D3DFORMAT</b> enumeration. See Video FOURCCs.
    ///    ProcAmpCap = The ProcAmp setting to query. See ProcAmp Settings.
    ///    pRange = A pointer to a DXVA2_ValueRange structure that receives the range of values for the setting specified in
    ///             <i>ProcAmpCaps</i>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetProcAmpRange(const(GUID)* VideoProcDeviceGuid, const(DXVA2_VideoDesc)* pVideoDesc, 
                            D3DFORMAT RenderTargetFormat, uint ProcAmpCap, DXVA2_ValueRange* pRange);
    ///Retrieves the range of values for an image filter supported by a video processor device.
    ///Params:
    ///    VideoProcDeviceGuid = A GUID that identifies the video processor device. To get the list of video processor GUIDs, call
    ///                          IDirectXVideoProcessorService::GetVideoProcessorDeviceGuids.
    ///    pVideoDesc = A pointer to a DXVA2_VideoDesc structure that describes the video content.
    ///    RenderTargetFormat = The format of the render target surface, specified as a <b>D3DFORMAT</b> value. For more information, see the
    ///                         Direct3D documentation. You can also use a FOURCC code to specify a format that is not defined in the
    ///                         <b>D3DFORMAT</b> enumeration. See Video FOURCCs.
    ///    FilterSetting = The filter setting to query. See DXVA Image Filter Settings.
    ///    pRange = A pointer to a DXVA2_ValueRange structure that receives range of values for the image filter setting
    ///             specified in <i>FilterSetting</i>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetFilterPropertyRange(const(GUID)* VideoProcDeviceGuid, const(DXVA2_VideoDesc)* pVideoDesc, 
                                   D3DFORMAT RenderTargetFormat, uint FilterSetting, DXVA2_ValueRange* pRange);
    ///Creates a video processor device.
    ///Params:
    ///    VideoProcDeviceGuid = A GUID that specifies the video processor to create. To get the list of video processor GUIDs, call
    ///                          IDirectXVideoProcessorService::GetVideoProcessorDeviceGuids.
    ///    pVideoDesc = A pointer to a DXVA2_VideoDesc structure that describes the video content.
    ///    RenderTargetFormat = The format of the render target surface, specified as a <b>D3DFORMAT</b> value. For more information, see the
    ///                         Direct3D documentation. You can also use a FOURCC code to specify a format that is not defined in the
    ///                         <b>D3DFORMAT</b> enumeration. See Video FOURCCs.
    ///    MaxNumSubStreams = The maximum number of substreams that will be used with this device.
    ///    ppVidProcess = Receives a pointer to the video processor's IDirectXVideoProcessor interface. The caller must release the
    ///                   interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CreateVideoProcessor(const(GUID)* VideoProcDeviceGuid, const(DXVA2_VideoDesc)* pVideoDesc, 
                                 D3DFORMAT RenderTargetFormat, uint MaxNumSubStreams, 
                                 IDirectXVideoProcessor* ppVidProcess);
}

///Represents a DirectX Video Acceleration (DXVA) video decoder device. To get a pointer to this interface, call
///IDirectXVideoDecoderService::CreateVideoDecoder.
@GUID("F2B0810A-FD00-43C9-918C-DF94E2D8EF7D")
interface IDirectXVideoDecoder : IUnknown
{
    ///Retrieves the DirectX Video Acceleration (DXVA) decoder service that created this decoder device.
    ///Params:
    ///    ppService = Receives a pointer to IDirectXVideoDecoderService interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVideoDecoderService(IDirectXVideoDecoderService* ppService);
    ///Retrieves the parameters that were used to create this device.
    ///Params:
    ///    pDeviceGuid = Receives the device GUID. This parameter can be <b>NULL</b>.
    ///    pVideoDesc = Pointer to a DXVA2_VideoDesc structure that receives a description of the video format. This parameter can be
    ///                 <b>NULL</b>.
    ///    pConfig = Pointer to a DXVA2_ConfigPictureDecode structure structure that receives the decoder configuration. This
    ///              parameter can be <b>NULL</b>.
    ///    pDecoderRenderTargets = Receives an array of <b>IDirect3DSurface9</b> interface pointers. These pointers represent the decoder render
    ///                            targets. The method allocates the memory for the array and calls <b>AddRef</b> on each of the pointers. The
    ///                            caller must release the pointers and call CoTaskMemFree to free the memory for the array. This parameter can
    ///                            be <b>NULL</b>.
    ///    pNumSurfaces = Receives the number of elements in the <i>pppDecoderRenderTargets</i> array. This parameter can be
    ///                   <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. At least one parameter must
    ///    be non-<b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT GetCreationParameters(GUID* pDeviceGuid, DXVA2_VideoDesc* pVideoDesc, 
                                  DXVA2_ConfigPictureDecode* pConfig, IDirect3DSurface9** pDecoderRenderTargets, 
                                  uint* pNumSurfaces);
    ///Retrieves a pointer to a DirectX Video Acceleration (DXVA) decoder buffer.
    ///Params:
    ///    BufferType = Type of buffer to retrieve. Use one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///                 </tr> <tr> <td width="40%"><a id="DXVA2_PictureParametersBufferType"></a><a
    ///                 id="dxva2_pictureparametersbuffertype"></a><a id="DXVA2_PICTUREPARAMETERSBUFFERTYPE"></a><dl>
    ///                 <dt><b>DXVA2_PictureParametersBufferType</b></dt> </dl> </td> <td width="60%"> Picture decoding parameter
    ///                 buffer. </td> </tr> <tr> <td width="40%"><a id="DXVA2_MacroBlockControlBufferType"></a><a
    ///                 id="dxva2_macroblockcontrolbuffertype"></a><a id="DXVA2_MACROBLOCKCONTROLBUFFERTYPE"></a><dl>
    ///                 <dt><b>DXVA2_MacroBlockControlBufferType</b></dt> </dl> </td> <td width="60%"> Macroblock control command
    ///                 buffer. </td> </tr> <tr> <td width="40%"><a id="DXVA2_ResidualDifferenceBufferType"></a><a
    ///                 id="dxva2_residualdifferencebuffertype"></a><a id="DXVA2_RESIDUALDIFFERENCEBUFFERTYPE"></a><dl>
    ///                 <dt><b>DXVA2_ResidualDifferenceBufferType</b></dt> </dl> </td> <td width="60%"> Residual difference block
    ///                 data buffer. </td> </tr> <tr> <td width="40%"><a id="DXVA2_DeblockingControlBufferType"></a><a
    ///                 id="dxva2_deblockingcontrolbuffertype"></a><a id="DXVA2_DEBLOCKINGCONTROLBUFFERTYPE"></a><dl>
    ///                 <dt><b>DXVA2_DeblockingControlBufferType</b></dt> </dl> </td> <td width="60%"> Deblocking filter control
    ///                 command buffer. </td> </tr> <tr> <td width="40%"><a id="DXVA2_InverseQuantizationMatrixBufferType"></a><a
    ///                 id="dxva2_inversequantizationmatrixbuffertype"></a><a id="DXVA2_INVERSEQUANTIZATIONMATRIXBUFFERTYPE"></a><dl>
    ///                 <dt><b>DXVA2_InverseQuantizationMatrixBufferType</b></dt> </dl> </td> <td width="60%"> Inverse quantization
    ///                 matrix buffer. </td> </tr> <tr> <td width="40%"><a id="DXVA2_SliceControlBufferType"></a><a
    ///                 id="dxva2_slicecontrolbuffertype"></a><a id="DXVA2_SLICECONTROLBUFFERTYPE"></a><dl>
    ///                 <dt><b>DXVA2_SliceControlBufferType</b></dt> </dl> </td> <td width="60%"> Slice-control buffer. </td> </tr>
    ///                 <tr> <td width="40%"><a id="DXVA2_BitStreamDateBufferType"></a><a id="dxva2_bitstreamdatebuffertype"></a><a
    ///                 id="DXVA2_BITSTREAMDATEBUFFERTYPE"></a><dl> <dt><b>DXVA2_BitStreamDateBufferType</b></dt> </dl> </td> <td
    ///                 width="60%"> Bitstream data buffer. </td> </tr> <tr> <td width="40%"><a id="DXVA2_MotionVectorBuffer"></a><a
    ///                 id="dxva2_motionvectorbuffer"></a><a id="DXVA2_MOTIONVECTORBUFFER"></a><dl>
    ///                 <dt><b>DXVA2_MotionVectorBuffer</b></dt> </dl> </td> <td width="60%"> Motion vector buffer. </td> </tr> <tr>
    ///                 <td width="40%"><a id="DXVA2_FilmGrainBuffer"></a><a id="dxva2_filmgrainbuffer"></a><a
    ///                 id="DXVA2_FILMGRAINBUFFER"></a><dl> <dt><b>DXVA2_FilmGrainBuffer</b></dt> </dl> </td> <td width="60%"> Film
    ///                 grain synthesis data buffer. </td> </tr> </table>
    ///    ppBuffer = Receives a pointer to the start of the memory buffer.
    ///    pBufferSize = Receives the size of the buffer, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetBuffer(uint BufferType, void** ppBuffer, uint* pBufferSize);
    ///Releases a buffer that was obtained by calling IDirectXVideoDecoder::GetBuffer.
    ///Params:
    ///    BufferType = The type of buffer to release. Specify the same value that was used in the <i>BufferType</i> parameter of the
    ///                 GetBuffer method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ReleaseBuffer(uint BufferType);
    ///Starts the decoding operation.
    ///Params:
    ///    pRenderTarget = Pointer to the IDirect3DSurface9 interface of the render target where the decoded frame will be written.
    ///    pvPVPData = Reserved; set to <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid surface type. See Remarks. </td> </tr>
    ///    </table>
    ///    
    HRESULT BeginFrame(IDirect3DSurface9 pRenderTarget, void* pvPVPData);
    ///Signals the end of the decoding operation.
    ///Params:
    ///    pHandleComplete = Reserved.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT EndFrame(HANDLE* pHandleComplete);
    ///Executes a decoding operation on the current frame.
    ///Params:
    ///    pExecuteParams = Pointer to a DXVA2_DecodeExecuteParams structure that contains the information needed for the decoding
    ///                     operation.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Execute(const(DXVA2_DecodeExecuteParams)* pExecuteParams);
}

///Represents a DirectX Video Acceleration (DXVA) video processor device. To get a pointer to this interface, call
///IDirectXVideoProcessorService::CreateVideoProcessor.
@GUID("8C3A39F0-916E-4690-804F-4C8001355D25")
interface IDirectXVideoProcessor : IUnknown
{
    ///Retrieves the DirectX Video Acceleration (DXVA) video processor service that created this video processor device.
    ///Params:
    ///    ppService = Receives a pointer to IDirectXVideoProcessorService interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVideoProcessorService(IDirectXVideoProcessorService* ppService);
    ///Retrieves the parameters that were used to create this device.
    ///Params:
    ///    pDeviceGuid = Receives the device GUID. This parameter can be <b>NULL</b>.
    ///    pVideoDesc = Pointer to a DXVA2_VideoDesc structure allocated by the caller. The method fills the structure with a
    ///                 description of the video format. This parameter can be <b>NULL</b>.
    ///    pRenderTargetFormat = Receives the render target format, specified as a <b>D3DFORMAT</b> value. For more information, see the
    ///                          Direct3D documentation. This parameter can be <b>NULL</b>.
    ///    pMaxNumSubStreams = Receives the maximum number of streams supported by the device. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. At least one parameter must
    ///    be non-<b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT GetCreationParameters(GUID* pDeviceGuid, DXVA2_VideoDesc* pVideoDesc, D3DFORMAT* pRenderTargetFormat, 
                                  uint* pMaxNumSubStreams);
    ///Retrieves the capabilities of the video processor device.
    ///Params:
    ///    pCaps = Pointer to a DXVA2_VideoProcessorCaps structure that receives the video processor capabilities.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVideoProcessorCaps(DXVA2_VideoProcessorCaps* pCaps);
    ///Retrieves the range of values for a video processor (ProcAmp) setting on this video processor device.
    ///Params:
    ///    ProcAmpCap = The ProcAmp setting to query. See ProcAmp Settings.
    ///    pRange = Pointer to a DXVA2_ValueRange structure that receives the range of values for the setting specified in
    ///             <i>ProcAmpCaps</i>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetProcAmpRange(uint ProcAmpCap, DXVA2_ValueRange* pRange);
    ///Retrieves the range of values for an image filter supported by this device.
    ///Params:
    ///    FilterSetting = Filter setting to query. For more information, see DXVA Image Filter Settings.
    ///    pRange = Pointer to a DXVA2_ValueRange structure that receives the range of values for the setting specified in
    ///             <i>FilterSetting</i>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetFilterPropertyRange(uint FilterSetting, DXVA2_ValueRange* pRange);
    ///Performs a video process operation on one or more input samples and writes the result to a Direct3D9 surface.
    ///Params:
    ///    pRenderTarget = A pointer to the IDirect3DSurface9 interface of a Direct3D surface. The output of the video processing
    ///                    operation will be written to this surface. The surface may be any of the following types: <ul> <li>A surface
    ///                    created by calling IDirectXVideoAccelerationService::CreateSurface with the
    ///                    <b>DXVA2_VideoProcessRenderTarget</b> flag. You can also use the <b>DXVA2_VideoSoftwareRenderTarget</b> flag,
    ///                    but only when the device GUID is <b>DXVA2_VideoProcSoftwareDevice</b> (software video processing device).
    ///                    </li> <li>A surface created from a Direct3D device with the <b>D3DUSAGE_RENDERTARGET</b> usage flag. </li>
    ///                    <li>A Direct3D swap chain. </li> </ul>
    ///    pBltParams = A pointer to a DXVA2_VideoProcessBltParams structure that describes the video processing operation to
    ///                 perform.
    ///    pSamples = A pointer to an array of DXVA2_VideoSample structures that contain the input samples. There must be at least
    ///               one element in the array. The maximum number of input samples is given by the constant
    ///               <b>MAX_DEINTERLACE_SURFACES</b>, defined in the header file dxva2api.h.
    ///    NumSamples = The number of elements in the <i>pSamples</i> array.
    ///    pHandleComplete = Reserved; set to <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>D3DERR_DRIVERINTERNALERROR</b></dt> </dl> </td> <td width="60%"> Internal driver error. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid arguments.
    ///    </td> </tr> </table>
    ///    
    HRESULT VideoProcessBlt(IDirect3DSurface9 pRenderTarget, const(DXVA2_VideoProcessBltParams)* pBltParams, 
                            const(DXVA2_VideoSample)* pSamples, uint NumSamples, HANDLE* pHandleComplete);
}

///Sets the type of video memory for uncompressed video surfaces. This interface is used by video decoders and
///transforms. The DirectShow enhanced video renderer (EVR) filter exposes this interface as a service on the filter's
///input pins. To obtain a pointer to this interface, call IMFGetService::GetService with the service identifier
///MR_VIDEO_ACCELERATION_SERVICE. A video decoder can use this interface to enumerate the EVR filter's preferred surface
///types and then select the surface type. The decoder should then create surfaces of that type to hold the results of
///the decoding operation. This interface does not define a way to clear the surface type. In the case of DirectShow,
///disconnecting two filters invalidates the surface type.
@GUID("B7F916DD-DB3B-49C1-84D7-E45EF99EC726")
interface IDirectXVideoMemoryConfiguration : IUnknown
{
    ///Retrieves a supported video surface type.
    ///Params:
    ///    dwTypeIndex = Zero-based index of the surface type to retrieve. Surface types are indexed in order of preference, starting
    ///                  with the most preferred type.
    ///    pdwType = Receives a member of the DXVA2_SurfaceType enumeration that specifies the surface type.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NO_MORE_TYPES</b></dt> </dl> </td> <td width="60%"> The index was out of range. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetAvailableSurfaceTypeByIndex(uint dwTypeIndex, DXVA2_SurfaceType* pdwType);
    ///Sets the video surface type that a decoder will use for DirectX Video Acceleration (DVXA) 2.0.
    ///Params:
    ///    dwType = Member of the DXVA2_SurfaceType enumeration specifying the surface type. Currently, the only supported value
    ///             is DXVA2_SurfaceType_DecoderRenderTarget.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>ERROR_UNSUPPORTED_TYPE</b></dt> </dl> </td> <td width="60%"> The renderer does not support the
    ///    specified surface type. </td> </tr> </table>
    ///    
    HRESULT SetSurfaceType(DXVA2_SurfaceType dwType);
}

///Represents a video output for an Output Protection Manager (OPM) session. To get a pointer to this interface, call
///one of the following functions: <ul> <li> OPMGetVideoOutputsFromIDirect3DDevice9Object </li> <li>
///OPMGetVideoOutputsFromHMONITOR </li> </ul>
@GUID("0A15159D-41C7-4456-93E1-284CD61D4E8D")
interface IOPMVideoOutput : IUnknown
{
    ///Begins the initialization sequence for an Output Protection Manager (OPM) session.
    ///Params:
    ///    prnRandomNumber = Pointer to an OPM_RANDOM_NUMBER structure. The structure receives a 128-bit random number generated by the
    ///                      display driver. This number is required for the IOPMVideoOutput::FinishInitialization method.
    ///    ppbCertificate = Receives a pointer to a buffer containing the display driver's certificate. The method allocates the memory
    ///                     for the buffer. The caller must release the memory by calling CoTaskMemFree.
    ///    pulCertificateLength = Receives the length of the buffer pointed to by <i>ppbCertificate</i>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StartInitialization(OPM_RANDOM_NUMBER* prnRandomNumber, ubyte** ppbCertificate, 
                                uint* pulCertificateLength);
    ///Completes the initialization sequence for an Output Protection Manager (OPM) session.
    ///Params:
    ///    pParameters = Pointer to an OPM_ENCRYPTED_INITIALIZATION_PARAMETERS structure. Initialize this structure as described in
    ///                  the Remarks session.
    ///Returns:
    ///    Returns an <b>HRESULT. </b>Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR</b></dt> </dl> </td> <td width="60%"> An unexpected error
    ///    occurred the display driver. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS</b></dt> </dl> </td> <td width="60%"> The encrypted
    ///    parameters in <i>pParameters</i> are incorrect. </td> </tr> </table>
    ///    
    HRESULT FinishInitialization(const(OPM_ENCRYPTED_INITIALIZATION_PARAMETERS)* pParameters);
    ///Sends an Output Protection Manager (OPM) status request to the display driver.
    ///Params:
    ///    pParameters = Pointer to an OPM_GET_INFO_PARAMETERS structure. Fill in this structure with data for the status request. For
    ///                  a list of status requests, see OPM Status Requests.
    ///    pRequestedInformation = Pointer to an OPM_REQUESTED_INFORMATION structure. On return, the method fills in this structure with the
    ///                            results of the status request.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS</b></dt> </dl> </td> <td width="60%"> The
    ///    OPM object was created with Certified Output Protection Protocol (COPP) semantics. </td> </tr> </table>
    ///    
    HRESULT GetInformation(const(OPM_GET_INFO_PARAMETERS)* pParameters, 
                           OPM_REQUESTED_INFORMATION* pRequestedInformation);
    ///Sends an Output Protection Manager (OPM) status request to the display driver. Use this method when OPM is
    ///emulating Certified Output Protection Manager (COPP).
    ///Params:
    ///    pParameters = Pointer to an OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS structure. Fill in this structure with data for the
    ///                  status request. For a list of status requests, see OPM Status Requests.
    ///    pRequestedInformation = Pointer to an OPM_REQUESTED_INFORMATION structure. On return, the method fills in this structure with the
    ///                            results of the status request.
    ///Returns:
    ///    Returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS</b></dt> </dl> </td> <td width="60%"> The
    ///    OPM object was created with OPM semantics, not COPP semantics. </td> </tr> </table>
    ///    
    HRESULT COPPCompatibleGetInformation(const(OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS)* pParameters, 
                                         OPM_REQUESTED_INFORMATION* pRequestedInformation);
    ///Configures a video output. This method sends an Output Protection Manager (OPM) or Certified Output Protection
    ///Protocol (COPP) command to the driver.
    ///Params:
    ///    pParameters = Pointer to an OPM_CONFIGURE_PARAMETERS structure that contains the command. For a list of OPM commands, see
    ///                  OPM Commands.
    ///    ulAdditionalParametersSize = The size of the <i>pbAdditionalParameters</i> buffer, in bytes.
    ///    pbAdditionalParameters = Pointer to a buffer that contains additional information for the command.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Configure(const(OPM_CONFIGURE_PARAMETERS)* pParameters, uint ulAdditionalParametersSize, 
                      const(ubyte)* pbAdditionalParameters);
}

///Provides a generic way to store key/value pairs on an object. The keys are <b>GUID</b>s, and the values can be any of
///the following data types: <b>UINT32</b>, <b>UINT64</b>, <b>double</b>, <b>GUID</b>, wide-character string, byte
///array, or <b>IUnknown</b> pointer. The standard implementation of this interface holds a thread lock while values are
///added, deleted, or retrieved. For a list of predefined attribute <b>GUID</b>s, see Media Foundation Attributes. Each
///attribute <b>GUID</b> has an expected data type. The various "set" methods in <b>IMFAttributes</b> do not validate
///the type against the attribute <b>GUID</b>. It is the application's responsibility to set the correct type for the
///attribute. To create an empty attribute store, call MFCreateAttributes.
@GUID("2CD2D921-C447-44A7-A13C-4ADABFC247E3")
interface IMFAttributes : IUnknown
{
    ///Retrieves the value associated with a key.
    ///Params:
    ///    guidKey = A GUID that identifies which value to retrieve.
    ///    pValue = A pointer to a <b>PROPVARIANT</b> that receives the value. The method fills the <b>PROPVARIANT</b> with a
    ///             copy of the stored value, if the value is found. Call <b>PropVariantClear</b> to free the memory allocated by
    ///             this method. This parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the method searches for the
    ///             key and returns S_OK if the key is found, but does not copy the value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The specified key was not found.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetItem(const(GUID)* guidKey, PROPVARIANT* pValue);
    ///Retrieves the data type of the value associated with a key.
    ///Params:
    ///    guidKey = GUID that identifies which value to query.
    ///    pType = Receives a member of the MF_ATTRIBUTE_TYPE enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The specified key is not stored in
    ///    this object. </td> </tr> </table>
    ///    
    HRESULT GetItemType(const(GUID)* guidKey, MF_ATTRIBUTE_TYPE* pType);
    ///Queries whether a stored attribute value equals to a specified <b>PROPVARIANT</b>.
    ///Params:
    ///    guidKey = GUID that identifies which value to query.
    ///    Value = <b>PROPVARIANT</b> that contains the value to compare.
    ///    pbResult = Receives a Boolean value indicating whether the attribute matches the value given in <i>Value</i>. See
    ///               Remarks. This parameter must not be <b>NULL</b>. If this parameter is <b>NULL</b>, an access violation
    ///               occurs.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CompareItem(const(GUID)* guidKey, const(PROPVARIANT)* Value, BOOL* pbResult);
    ///Compares the attributes on this object with the attributes on another object.
    ///Params:
    ///    pTheirs = Pointer to the IMFAttributes interface of the object to compare with this object.
    ///    MatchType = Member of the MF_ATTRIBUTES_MATCH_TYPE enumeration, specifying the type of comparison to make.
    ///    pbResult = Receives a Boolean value. The value is <b>TRUE</b> if the two sets of attributes match in the way specified
    ///               by the <i>MatchType</i> parameter. Otherwise, the value is <b>FALSE</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Compare(IMFAttributes pTheirs, MF_ATTRIBUTES_MATCH_TYPE MatchType, BOOL* pbResult);
    ///Retrieves a <b>UINT32</b> value associated with a key.
    ///Params:
    ///    guidKey = GUID that identifies which value to retrieve. The attribute type must be <b>MF_ATTRIBUTE_UINT32</b>.
    ///    punValue = Receives a <b>UINT32</b> value. If the key is found and the data type is <b>UINT32</b>, the method copies the
    ///               value into this parameter. Otherwise, the original value of this parameter is not changed.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The specified key was not found.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDTYPE</b></dt> </dl> </td> <td width="60%"> The
    ///    attribute value is not a <b>UINT32</b>. </td> </tr> </table>
    ///    
    HRESULT GetUINT32(const(GUID)* guidKey, uint* punValue);
    ///Retrieves a <b>UINT64</b> value associated with a key.
    ///Params:
    ///    guidKey = GUID that identifies which value to retrieve. The attribute type must be <b>MF_ATTRIBUTE_UINT64</b>.
    ///    punValue = Receives a <b>UINT64</b> value. If the key is found and the data type is <b>UINT64</b>, the method copies the
    ///               value into this parameter. Otherwise, the original value of this parameter is not changed.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The specified key was not found.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDTYPE</b></dt> </dl> </td> <td width="60%"> The
    ///    attribute value is not a <b>UINT64</b>. </td> </tr> </table>
    ///    
    HRESULT GetUINT64(const(GUID)* guidKey, ulong* punValue);
    ///Retrieves a <b>double</b> value associated with a key.
    ///Params:
    ///    guidKey = GUID that identifies which value to retrieve. The attribute type must be <b>MF_ATTRIBUTE_DOUBLE</b>.
    ///    pfValue = Receives a <b>double</b> value. If the key is found and the data type is <b>double</b>, the method copies the
    ///              value into this parameter. Otherwise, the original value of this parameter is not changed.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The specified key was not found.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDTYPE</b></dt> </dl> </td> <td width="60%"> The
    ///    attribute value is not a <b>double</b>. </td> </tr> </table>
    ///    
    HRESULT GetDouble(const(GUID)* guidKey, double* pfValue);
    ///Retrieves a GUID value associated with a key.
    ///Params:
    ///    guidKey = GUID that identifies which value to retrieve. The attribute type must be <b>MF_ATTRIBUTE_GUID</b>.
    ///    pguidValue = Receives a GUID value. If the key is found and the data type is GUID, the method copies the value into this
    ///                 parameter. Otherwise, the original value of this parameter is not changed.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The specified key was not found.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDTYPE</b></dt> </dl> </td> <td width="60%"> The
    ///    attribute value is not a GUID. </td> </tr> </table>
    ///    
    HRESULT GetGUID(const(GUID)* guidKey, GUID* pguidValue);
    ///Retrieves the length of a string value associated with a key.
    ///Params:
    ///    guidKey = GUID that identifies which value to retrieve. The attribute type must be <b>MF_ATTRIBUTE_STRING</b>.
    ///    pcchLength = If the key is found and the value is a string type, this parameter receives the number of characters in the
    ///                 string, not including the terminating <b>NULL</b> character. To get the string value, call
    ///                 IMFAttributes::GetString.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The specified key was not found.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDTYPE</b></dt> </dl> </td> <td width="60%"> The
    ///    attribute value is not a string. </td> </tr> </table>
    ///    
    HRESULT GetStringLength(const(GUID)* guidKey, uint* pcchLength);
    ///Retrieves a wide-character string associated with a key.
    ///Params:
    ///    guidKey = GUID that identifies which value to retrieve. The attribute type must be <b>MF_ATTRIBUTE_STRING</b>.
    ///    pwszValue = Pointer to a wide-character array allocated by the caller. The array must be large enough to hold the string,
    ///                including the terminating <b>NULL</b> character. If the key is found and the value is a string type, the
    ///                method copies the string into this buffer. To find the length of the string, call
    ///                IMFAttributes::GetStringLength.
    ///    cchBufSize = The size of the <i>pwszValue</i> array, in characters. This value includes the terminating NULL character.
    ///    pcchLength = Receives the number of characters in the string, excluding the terminating <b>NULL</b> character. This
    ///                 parameter can be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The length of the string is too large to fit
    ///    in a <b>UINT32</b> value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOT_SUFFICIENT_BUFFER</b></dt>
    ///    </dl> </td> <td width="60%"> The buffer is not large enough to hold the string. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The specified key was
    ///    not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDTYPE</b></dt> </dl> </td> <td
    ///    width="60%"> The attribute value is not a string. </td> </tr> </table>
    ///    
    HRESULT GetString(const(GUID)* guidKey, PWSTR pwszValue, uint cchBufSize, uint* pcchLength);
    ///Gets a wide-character string associated with a key. This method allocates the memory for the string.
    ///Params:
    ///    guidKey = A GUID that identifies which value to retrieve. The attribute type must be <b>MF_ATTRIBUTE_STRING</b>.
    ///    ppwszValue = If the key is found and the value is a string type, this parameter receives a copy of the string. The caller
    ///                 must free the memory for the string by calling CoTaskMemFree.
    ///    pcchLength = Receives the number of characters in the string, excluding the terminating <b>NULL</b> character. This
    ///                 parameter must not be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The specified key was not found.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDTYPE</b></dt> </dl> </td> <td width="60%"> The
    ///    attribute value is not a string. </td> </tr> </table>
    ///    
    HRESULT GetAllocatedString(const(GUID)* guidKey, PWSTR* ppwszValue, uint* pcchLength);
    ///Retrieves the length of a byte array associated with a key.
    ///Params:
    ///    guidKey = GUID that identifies which value to retrieve. The attribute type must be <b>MF_ATTRIBUTE_BLOB</b>.
    ///    pcbBlobSize = If the key is found and the value is a byte array, this parameter receives the size of the array, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The specified key was not found.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDTYPE</b></dt> </dl> </td> <td width="60%"> The
    ///    attribute value is not a byte array. </td> </tr> </table>
    ///    
    HRESULT GetBlobSize(const(GUID)* guidKey, uint* pcbBlobSize);
    ///Retrieves a byte array associated with a key. This method copies the array into a caller-allocated buffer.
    ///Params:
    ///    guidKey = GUID that identifies which value to retrieve. The attribute type must be <b>MF_ATTRIBUTE_BLOB</b>.
    ///    pBuf = Pointer to a buffer allocated by the caller. If the key is found and the value is a byte array, the method
    ///           copies the array into this buffer. To find the required size of the buffer, call IMFAttributes::GetBlobSize.
    ///    cbBufSize = The size of the <i>pBuf</i> buffer, in bytes.
    ///    pcbBlobSize = Receives the size of the byte array. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>E_NOT_SUFFICIENT_BUFFER</b></b></dt> </dl> </td> <td width="60%"> The buffer is
    ///    not large enough to the array. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>MF_E_ATTRIBUTENOTFOUND</b></b></dt> </dl> </td> <td width="60%"> The specified key was not found.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_INVALIDTYPE</b></b></dt> </dl> </td> <td width="60%">
    ///    The attribute value is not a byte array. </td> </tr> </table>
    ///    
    HRESULT GetBlob(const(GUID)* guidKey, ubyte* pBuf, uint cbBufSize, uint* pcbBlobSize);
    ///Retrieves a byte array associated with a key. This method allocates the memory for the array.
    ///Params:
    ///    guidKey = GUID that identifies which value to retrieve. The attribute type must be <b>MF_ATTRIBUTE_BLOB</b>.
    ///    ppBuf = If the key is found and the value is a byte array, this parameter receives a copy of the array. The caller
    ///            must free the memory for the array by calling CoTaskMemFree.
    ///    pcbSize = Receives the size of the array, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The specified key was not found.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDTYPE</b></dt> </dl> </td> <td width="60%"> The
    ///    attribute value is not a byte array. </td> </tr> </table>
    ///    
    HRESULT GetAllocatedBlob(const(GUID)* guidKey, ubyte** ppBuf, uint* pcbSize);
    ///Retrieves an interface pointer associated with a key.
    ///Params:
    ///    guidKey = GUID that identifies which value to retrieve. The attribute type must be <b>MF_ATTRIBUTE_IUNKNOWN</b>.
    ///    riid = Interface identifier (IID) of the interface to retrieve.
    ///    ppv = Receives a pointer to the requested interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The attribute value is an <b>IUnknown</b>
    ///    pointer but does not support requested interface. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The specified key was not found. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDTYPE</b></dt> </dl> </td> <td width="60%"> The attribute
    ///    value is not an <b>IUnknown</b> pointer. </td> </tr> </table>
    ///    
    HRESULT GetUnknown(const(GUID)* guidKey, const(GUID)* riid, void** ppv);
    ///Adds an attribute value with a specified key.
    ///Params:
    ///    guidKey = A GUID that identifies the value to set. If this key already exists, the method overwrites the old value.
    ///    Value = A <b>PROPVARIANT</b> that contains the attribute value. The method copies the value. The <b>PROPVARIANT</b>
    ///            type must be one of the types listed in the MF_ATTRIBUTE_TYPE enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDTYPE</b></dt> </dl> </td> <td width="60%"> Invalid attribute type. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetItem(const(GUID)* guidKey, const(PROPVARIANT)* Value);
    ///Removes a key/value pair from the object's attribute list.
    ///Params:
    ///    guidKey = GUID that identifies the value to delete.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT DeleteItem(const(GUID)* guidKey);
    ///Removes all key/value pairs from the object's attribute list.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT DeleteAllItems();
    ///Associates a <b>UINT32</b> value with a key.
    ///Params:
    ///    guidKey = GUID that identifies the value to set. If this key already exists, the method overwrites the old value.
    ///    unValue = New value for this key.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetUINT32(const(GUID)* guidKey, uint unValue);
    ///Associates a <b>UINT64</b> value with a key.
    ///Params:
    ///    guidKey = GUID that identifies the value to set. If this key already exists, the method overwrites the old value.
    ///    unValue = New value for this key.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetUINT64(const(GUID)* guidKey, ulong unValue);
    ///Associates a <b>double</b> value with a key.
    ///Params:
    ///    guidKey = GUID that identifies the value to set. If this key already exists, the method overwrites the old value.
    ///    fValue = New value for this key.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetDouble(const(GUID)* guidKey, double fValue);
    ///Associates a GUID value with a key.
    ///Params:
    ///    guidKey = GUID that identifies the value to set. If this key already exists, the method overwrites the old value.
    ///    guidValue = New value for this key.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory. </td> </tr> </table>
    ///    
    HRESULT SetGUID(const(GUID)* guidKey, const(GUID)* guidValue);
    ///Associates a wide-character string with a key.
    ///Params:
    ///    guidKey = GUID that identifies the value to set. If this key already exists, the method overwrites the old value.
    ///    wszValue = Null-terminated wide-character string to associate with this key. The method stores a copy of the string.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetString(const(GUID)* guidKey, const(PWSTR) wszValue);
    ///Associates a byte array with a key.
    ///Params:
    ///    guidKey = GUID that identifies the value to set. If this key already exists, the method overwrites the old value.
    ///    pBuf = Pointer to a byte array to associate with this key. The method stores a copy of the array.
    ///    cbBufSize = Size of the array, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetBlob(const(GUID)* guidKey, const(ubyte)* pBuf, uint cbBufSize);
    ///Associates an <b>IUnknown</b> pointer with a key.
    ///Params:
    ///    guidKey = GUID that identifies the value to set. If this key already exists, the method overwrites the old value.
    ///    pUnknown = <b>IUnknown</b> pointer to be associated with this key.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetUnknown(const(GUID)* guidKey, IUnknown pUnknown);
    ///Locks the attribute store so that no other thread can access it. If the attribute store is already locked by
    ///another thread, this method blocks until the other thread unlocks the object. After calling this method, call
    ///IMFAttributes::UnlockStore to unlock the object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT LockStore();
    ///Unlocks the attribute store after a call to the IMFAttributes::LockStore method. While the object is unlocked,
    ///multiple threads can access the object's attributes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT UnlockStore();
    ///Retrieves the number of attributes that are set on this object.
    ///Params:
    ///    pcItems = Receives the number of attributes. This parameter must not be <b>NULL</b>. If this parameter is <b>NULL</b>,
    ///              an access violation occurs.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCount(uint* pcItems);
    ///Retrieves an attribute at the specified index.
    ///Params:
    ///    unIndex = Index of the attribute to retrieve. To get the number of attributes, call IMFAttributes::GetCount.
    ///    pguidKey = Receives the GUID that identifies this attribute.
    ///    pValue = Pointer to a <b>PROPVARIANT</b> that receives the value. This parameter can be <b>NULL</b>. If it is not
    ///             <b>NULL</b>, the method fills the <b>PROPVARIANT</b> with a copy of the attribute value. Call
    ///             <b>PropVariantClear</b> to free the memory allocated by this method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid index. </td> </tr> </table>
    ///    
    HRESULT GetItemByIndex(uint unIndex, GUID* pguidKey, PROPVARIANT* pValue);
    ///Copies all of the attributes from this object into another attribute store.
    ///Params:
    ///    pDest = A pointer to the IMFAttributes interface of the attribute store that receives the copy.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CopyAllItems(IMFAttributes pDest);
}

///Represents a block of memory that contains media data. Use this interface to access the data in the buffer.
@GUID("045FA593-8799-42B8-BC8D-8968C6453507")
interface IMFMediaBuffer : IUnknown
{
    ///Gives the caller access to the memory in the buffer, for reading or writing
    ///Params:
    ///    ppbBuffer = Receives a pointer to the start of the buffer.
    ///    pcbMaxLength = Receives the maximum amount of data that can be written to the buffer. This parameter can be <b>NULL</b>. The
    ///                   same value is returned by the IMFMediaBuffer::GetMaxLength method.
    ///    pcbCurrentLength = Receives the length of the valid data in the buffer, in bytes. This parameter can be <b>NULL</b>. The same
    ///                       value is returned by the IMFMediaBuffer::GetCurrentLength method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>D3DERR_INVALIDCALL</b></dt> </dl> </td> <td width="60%"> For Direct3D surface buffers, an error
    ///    occurred when locking the surface. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt>
    ///    </dl> </td> <td width="60%"> The buffer cannot be locked at this time. </td> </tr> </table>
    ///    
    HRESULT Lock(ubyte** ppbBuffer, uint* pcbMaxLength, uint* pcbCurrentLength);
    ///Unlocks a buffer that was previously locked. Call this method once for every call to IMFMediaBuffer::Lock.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>D3DERR_INVALIDCALL</b></dt> </dl> </td> <td width="60%"> For Direct3D surface buffers, an error
    ///    occurred when unlocking the surface. </td> </tr> </table>
    ///    
    HRESULT Unlock();
    ///Retrieves the length of the valid data in the buffer.
    ///Params:
    ///    pcbCurrentLength = Receives the length of the valid data, in bytes. If the buffer does not contain any valid data, the value is
    ///                       zero.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCurrentLength(uint* pcbCurrentLength);
    ///Sets the length of the valid data in the buffer.
    ///Params:
    ///    cbCurrentLength = Length of the valid data, in bytes. This value cannot be greater than the allocated size of the buffer, which
    ///                      is returned by the IMFMediaBuffer::GetMaxLength method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified length is greater than the
    ///    maximum size of the buffer. </td> </tr> </table>
    ///    
    HRESULT SetCurrentLength(uint cbCurrentLength);
    ///Retrieves the allocated size of the buffer.
    ///Params:
    ///    pcbMaxLength = Receives the allocated size of the buffer, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetMaxLength(uint* pcbMaxLength);
}

///Represents a media sample, which is a container object for media data. For video, a sample typically contains one
///video frame. For audio data, a sample typically contains multiple audio samples, rather than a single sample of
///audio. A media sample contains zero or more buffers. Each buffer manages a block of memory, and is represented by the
///IMFMediaBuffer interface. A sample can have multiple buffers. The buffers are kept in an ordered list and accessed by
///index value. It is also valid to have an empty sample with no buffers.
@GUID("C40A00F2-B93A-4D80-AE8C-5A1C634F58E4")
interface IMFSample : IMFAttributes
{
    ///Retrieves flags associated with the sample. Currently no flags are defined. Instead, metadata for samples is
    ///defined using attributes. To get attibutes from a sample, use the IMFAttributes interface, which IMFSample
    ///inherits. For a list of sample attributes, see Sample Attributes.
    ///Params:
    ///    pdwSampleFlags = Receives the value zero.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetSampleFlags(uint* pdwSampleFlags);
    ///Sets flags associated with the sample. Currently no flags are defined. Instead, metadata for samples is defined
    ///using attributes. To set attibutes on a sample, use the IMFAttributes interface, which IMFSample inherits. For a
    ///list of sample attributes, see Sample Attributes.
    ///Params:
    ///    dwSampleFlags = Reserved; must be zero.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetSampleFlags(uint dwSampleFlags);
    ///Retrieves the presentation time of the sample.
    ///Params:
    ///    phnsSampleTime = Receives the presentation time, in 100-nanosecond units.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NO_SAMPLE_TIMESTAMP</b></dt> </dl> </td> <td width="60%"> The sample does not have a
    ///    presentation time. </td> </tr> </table>
    ///    
    HRESULT GetSampleTime(long* phnsSampleTime);
    ///Sets the presentation time of the sample.
    ///Params:
    ///    hnsSampleTime = The presentation time, in 100-nanosecond units.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetSampleTime(long hnsSampleTime);
    ///Retrieves the duration of the sample.
    ///Params:
    ///    phnsSampleDuration = Receives the duration, in 100-nanosecond units.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NO_SAMPLE_DURATION</b></dt> </dl> </td> <td width="60%"> The sample does not have a
    ///    specified duration. </td> </tr> </table>
    ///    
    HRESULT GetSampleDuration(long* phnsSampleDuration);
    ///Sets the duration of the sample.
    ///Params:
    ///    hnsSampleDuration = Duration of the sample, in 100-nanosecond units.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSampleDuration(long hnsSampleDuration);
    ///Retrieves the number of buffers in the sample.
    ///Params:
    ///    pdwBufferCount = Receives the number of buffers in the sample. A sample might contain zero buffers.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetBufferCount(uint* pdwBufferCount);
    ///Gets a buffer from the sample, by index. <div class="alert"><b>Note</b> In most cases, it is safer to use the
    ///IMFSample::ConvertToContiguousBuffer method. If the sample contains more than one buffer, the
    ///<b>ConvertToContiguousBuffer</b> method replaces them with a single buffer, copies the original data into that
    ///buffer, and returns the new buffer to the caller. The copy operation occurs at most once. On subsequent calls, no
    ///data is copied.</div> <div> </div>
    ///Params:
    ///    dwIndex = Index of the buffer. To find the number of buffers in the sample, call IMFSample::GetBufferCount. Buffers are
    ///              indexed from zero.
    ///    ppBuffer = Receives a pointer to the IMFMediaBuffer interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument, or the index is
    ///    out of range. </td> </tr> </table>
    ///    
    HRESULT GetBufferByIndex(uint dwIndex, IMFMediaBuffer* ppBuffer);
    ///Converts a sample with multiple buffers into a sample with a single buffer.
    ///Params:
    ///    ppBuffer = Receives a pointer to the IMFMediaBuffer interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The sample does not contain any buffers. </td>
    ///    </tr> </table>
    ///    
    HRESULT ConvertToContiguousBuffer(IMFMediaBuffer* ppBuffer);
    ///Adds a buffer to the end of the list of buffers in the sample.
    ///Params:
    ///    pBuffer = Pointer to the buffer's IMFMediaBuffer interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> </table>
    ///    
    HRESULT AddBuffer(IMFMediaBuffer pBuffer);
    ///Removes a buffer at a specified index from the sample.
    ///Params:
    ///    dwIndex = Index of the buffer. To find the number of buffers in the sample, call IMFSample::GetBufferCount. Buffers are
    ///              indexed from zero.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RemoveBufferByIndex(uint dwIndex);
    ///Removes all of the buffers from the sample.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RemoveAllBuffers();
    ///Retrieves the total length of the valid data in all of the buffers in the sample. The length is calculated as the
    ///sum of the values retrieved by the IMFMediaBuffer::GetCurrentLength method.
    ///Params:
    ///    pcbTotalLength = Receives the total length of the valid data, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTotalLength(uint* pcbTotalLength);
    ///Copies the sample data to a buffer. This method concatenates the valid data from all of the buffers of the
    ///sample, in order.
    ///Params:
    ///    pBuffer = Pointer to the IMFMediaBuffer interface of the destination buffer. The buffer must be large enough to hold
    ///              the valid data in the sample. To get the size of the data in the sample, call IMFSample::GetTotalLength.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td width="60%"> The buffer is not large
    ///    enough to contain the data. </td> </tr> </table>
    ///    
    HRESULT CopyToBuffer(IMFMediaBuffer pBuffer);
}

///Represents a buffer that contains a two-dimensional surface, such as a video frame.
@GUID("7DC9D5F9-9ED9-44EC-9BBF-0600BB589FBB")
interface IMF2DBuffer : IUnknown
{
    ///Gives the caller access to the memory in the buffer.
    ///Params:
    ///    ppbScanline0 = Receives a pointer to the first byte of the top row of pixels in the image. The top row is defined as the top
    ///                   row when the image is presented to the viewer, and might not be the first row in memory.
    ///    plPitch = Receives the surface stride, in bytes. The stride might be negative, indicating that the image is oriented
    ///              from the bottom up in memory.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>D3DERR_INVALIDCALL</b></dt> </dl> </td> <td width="60%"> Cannot lock the Direct3D surface. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The buffer
    ///    cannot be locked at this time. </td> </tr> </table>
    ///    
    HRESULT Lock2D(ubyte** ppbScanline0, int* plPitch);
    ///Unlocks a buffer that was previously locked. Call this method once for each call to IMF2DBuffer::Lock2D.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Unlock2D();
    ///Retrieves a pointer to the buffer memory and the surface stride.
    ///Params:
    ///    pbScanline0 = Receives a pointer to the first byte of the top row of pixels in the image.
    ///    plPitch = Receives the stride, in bytes. For more information, see Image Stride.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>ERROR_INVALID_FUNCTION</b></dt> </dl> </td> <td width="60%"> You must lock the buffer before
    ///    calling this method. </td> </tr> </table>
    ///    
    HRESULT GetScanline0AndPitch(ubyte** pbScanline0, int* plPitch);
    ///Queries whether the buffer is contiguous in its native format.
    ///Params:
    ///    pfIsContiguous = Receives a Boolean value. The value is <b>TRUE</b> if the buffer is contiguous, and <b>FALSE</b> otherwise.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT IsContiguousFormat(BOOL* pfIsContiguous);
    ///Retrieves the number of bytes needed to store the contents of the buffer in contiguous format.
    ///Params:
    ///    pcbLength = Receives the number of bytes needed to store the contents of the buffer in contiguous format.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetContiguousLength(uint* pcbLength);
    ///Copies this buffer into the caller's buffer, converting the data to contiguous format.
    ///Params:
    ///    pbDestBuffer = Pointer to the destination buffer where the data will be copied. The caller allocates the buffer.
    ///    cbDestBuffer = Size of the destination buffer, in bytes. To get the required size, call IMF2DBuffer::GetContiguousLength.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid size specified in <i>pbDestBuffer</i>.
    ///    </td> </tr> </table>
    ///    
    HRESULT ContiguousCopyTo(ubyte* pbDestBuffer, uint cbDestBuffer);
    ///Copies data to this buffer from a buffer that has a contiguous format.
    ///Params:
    ///    pbSrcBuffer = Pointer to the source buffer. The caller allocates the buffer.
    ///    cbSrcBuffer = Size of the source buffer, in bytes. To get the maximum size of the buffer, call
    ///                  IMF2DBuffer::GetContiguousLength.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ContiguousCopyFrom(const(ubyte)* pbSrcBuffer, uint cbSrcBuffer);
}

///Represents a buffer that contains a two-dimensional surface, such as a video frame.
@GUID("33AE5EA6-4316-436F-8DDD-D73D22F829EC")
interface IMF2DBuffer2 : IMF2DBuffer
{
    ///Gives the caller access to the memory in the buffer.
    ///Params:
    ///    lockFlags = A member of the MF2DBuffer_LockFlags enumeration that specifies whether to lock the buffer for reading,
    ///                writing, or both.
    ///    ppbScanline0 = Receives a pointer to the first byte of the top row of pixels in the image. The top row is defined as the top
    ///                   row when the image is presented to the viewer, and might not be the first row in memory.
    ///    plPitch = Receives the surface stride, in bytes. The stride might be negative, indicating that the image is oriented
    ///              from the bottom up in memory.
    ///    ppbBufferStart = Receives a pointer to the start of the accessible buffer in memory.
    ///    pcbBufferLength = Receives the length of the buffer, in bytes.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> Invalid request. The
    ///    buffer might already be locked with an incompatible locking flag. See Remarks. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b> E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is insufficient memory to
    ///    complete the operation. </td> </tr> </table>
    ///    
    HRESULT Lock2DSize(MF2DBuffer_LockFlags lockFlags, ubyte** ppbScanline0, int* plPitch, ubyte** ppbBufferStart, 
                       uint* pcbBufferLength);
    ///Copies the buffer to another 2D buffer object.
    ///Params:
    ///    pDestBuffer = A pointer to the IMF2DBuffer2 interface of the destination buffer.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Copy2DTo(IMF2DBuffer2 pDestBuffer);
}

///Represents a buffer that contains a Microsoft DirectX Graphics Infrastructure (DXGI)surface.
@GUID("E7174CFA-1C9E-48B1-8866-626226BFC258")
interface IMFDXGIBuffer : IUnknown
{
    ///Queries the Microsoft DirectX Graphics Infrastructure (DXGI)surface for an interface.
    ///Params:
    ///    riid = The interface identifer (IID) of the interface being requested.
    ///    ppvObject = Receives a pointer to the interface. The caller must release the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b> E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The object does not support the
    ///    specified interface. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid request. </td> </tr> </table>
    ///    
    HRESULT GetResource(const(GUID)* riid, void** ppvObject);
    ///Gets the index of the subresource that is associated with this media buffer.
    ///Params:
    ///    puSubresource = Receives the zero-based index of the subresource.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSubresourceIndex(uint* puSubresource);
    ///Gets an IUnknown pointer that was previously stored in the media buffer object.
    ///Params:
    ///    guid = The identifier of the IUnknown pointer.
    ///    riid = The interface identifer (IID) of the interface being requested.
    ///    ppvObject = Receives a pointer to the interface. The caller must release the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b> E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The object does not support the
    ///    specified interface. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_FOUND</b></dt> </dl> </td> <td
    ///    width="60%"> The specified key was not found. </td> </tr> </table>
    ///    
    HRESULT GetUnknown(const(GUID)* guid, const(GUID)* riid, void** ppvObject);
    ///Stores an arbitrary IUnknown pointer in the media buffer object.
    ///Params:
    ///    guid = The identifier for the IUnknown pointer. This identifier is used as a key to retrieve the value. It can be
    ///           any <b>GUID</b> value.
    ///    pUnkData = A pointer to the IUnknown interface. Set this parameter to <b>NULL</b> to clear a pointer that was previously
    ///               set.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>ERROR_OBJECT_ALREADY_EXISTS</b></dt> </dl> </td> <td width="60%"> An item already
    ///    exists with this key. </td> </tr> </table>
    ///    
    HRESULT SetUnknown(const(GUID)* guid, IUnknown pUnkData);
}

///Represents a description of a media format.
@GUID("44AE0FA8-EA31-4109-8D2E-4CAE4997C555")
interface IMFMediaType : IMFAttributes
{
    ///Gets the major type of the format.
    ///Params:
    ///    pguidMajorType = Receives the major type <b>GUID</b>. The major type describes the broad category of the format, such as audio
    ///                     or video. For a list of possible values, see Major Media Types.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The major type is not set. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetMajorType(GUID* pguidMajorType);
    ///Queries whether the media type is a temporally compressed format.Temporal compression uses information from
    ///previously decoded samples when decompressing the current sample.
    ///Params:
    ///    pfCompressed = Receives a Boolean value. The value is <b>TRUE</b> if the format uses temporal compression, or <b>FALSE</b>
    ///                   if the format does not use temporal compression.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IsCompressedFormat(BOOL* pfCompressed);
    ///Compares two media types and determines whether they are identical. If they are not identical, the method
    ///indicates how the two formats differ.
    ///Params:
    ///    pIMediaType = Pointer to the IMFMediaType interface of the media type to compare.
    ///    pdwFlags = Receives a bitwise <b>OR</b> of zero or more flags, indicating the degree of similarity between the two media
    ///               types. The following flags are defined. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///               width="40%"><a id="MF_MEDIATYPE_EQUAL_MAJOR_TYPES"></a><a id="mf_mediatype_equal_major_types"></a><dl>
    ///               <dt><b>MF_MEDIATYPE_EQUAL_MAJOR_TYPES</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The major
    ///               types are the same. The major type is specified by the MF_MT_MAJOR_TYPE attribute. </td> </tr> <tr> <td
    ///               width="40%"><a id="MF_MEDIATYPE_EQUAL_FORMAT_TYPES"></a><a id="mf_mediatype_equal_format_types"></a><dl>
    ///               <dt><b>MF_MEDIATYPE_EQUAL_FORMAT_TYPES</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The subtypes
    ///               are the same, or neither media type has a subtype. The subtype is specified by the MF_MT_SUBTYPE attribute.
    ///               </td> </tr> <tr> <td width="40%"><a id="MF_MEDIATYPE_EQUAL_FORMAT_DATA"></a><a
    ///               id="mf_mediatype_equal_format_data"></a><dl> <dt><b>MF_MEDIATYPE_EQUAL_FORMAT_DATA</b></dt>
    ///               <dt>0x00000004</dt> </dl> </td> <td width="60%"> The attributes in one of the media types are a subset of the
    ///               attributes in the other, and the values of these attributes match, excluding the value of the
    ///               MF_MT_USER_DATA, MF_MT_FRAME_RATE_RANGE_MIN, and MF_MT_FRAME_RATE_RANGE_MAX attributes. Specifically, the
    ///               method takes the media type with the smaller number of attributes and checks whether each attribute from that
    ///               type is present in the other media type and has the same value (not including MF_MT_USER_DATA,
    ///               MF_MT_FRAME_RATE_RANGE_MIN, and MF_MT_FRAME_RATE_RANGE_MAX). To perform other comparisons, use the
    ///               IMFAttributes::Compare method. For example, the <b>Compare</b> method can test for identical attributes, or
    ///               test the intersection of the two attribute sets. For more information, see MF_ATTRIBUTES_MATCH_TYPE. </td>
    ///               </tr> <tr> <td width="40%"><a id="MF_MEDIATYPE_EQUAL_FORMAT_USER_DATA"></a><a
    ///               id="mf_mediatype_equal_format_user_data"></a><dl> <dt><b>MF_MEDIATYPE_EQUAL_FORMAT_USER_DATA</b></dt>
    ///               <dt>0x00000008</dt> </dl> </td> <td width="60%"> The user data is identical, or neither media type contains
    ///               user data. User data is specified by the MF_MT_USER_DATA attribute. </td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The types are not equal. Examine the <i>pdwFlags</i>
    ///    parameter to determine how the types differ. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The types are equal. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or both media types are invalid. </td> </tr>
    ///    </table>
    ///    
    HRESULT IsEqual(IMFMediaType pIMediaType, uint* pdwFlags);
    ///Retrieves an alternative representation of the media type. Currently only the DirectShow <b>AM_MEDIA_TYPE</b>
    ///structure is supported.
    ///Params:
    ///    guidRepresentation = GUID that specifies the representation to retrieve. The following values are defined. <table> <tr>
    ///                         <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="AM_MEDIA_TYPE_REPRESENTATION"></a><a
    ///                         id="am_media_type_representation"></a><dl> <dt><b>AM_MEDIA_TYPE_REPRESENTATION</b></dt> </dl> </td> <td
    ///                         width="60%"> Convert the media type to a DirectShow <b>AM_MEDIA_TYPE</b> structure. The method selects the
    ///                         most appropriate format structure (<b>pbFormat</b>). </td> </tr> <tr> <td width="40%"><a
    ///                         id="FORMAT_MFVideoFormat"></a><a id="format_mfvideoformat"></a><a id="FORMAT_MFVIDEOFORMAT"></a><dl>
    ///                         <dt><b>FORMAT_MFVideoFormat</b></dt> </dl> </td> <td width="60%"> Convert the media type to a DirectShow
    ///                         <b>AM_MEDIA_TYPE</b> structure with an MFVIDEOFORMAT format structure. </td> </tr> <tr> <td width="40%"><a
    ///                         id="FORMAT_VideoInfo"></a><a id="format_videoinfo"></a><a id="FORMAT_VIDEOINFO"></a><dl>
    ///                         <dt><b>FORMAT_VideoInfo</b></dt> </dl> </td> <td width="60%"> Convert the media type to a DirectShow
    ///                         <b>AM_MEDIA_TYPE</b> structure with a <b>VIDEOINFOHEADER</b> format structure. </td> </tr> <tr> <td
    ///                         width="40%"><a id="FORMAT_VideoInfo2"></a><a id="format_videoinfo2"></a><a id="FORMAT_VIDEOINFO2"></a><dl>
    ///                         <dt><b>FORMAT_VideoInfo2</b></dt> </dl> </td> <td width="60%"> Convert the media type to a DirectShow
    ///                         <b>AM_MEDIA_TYPE</b> structure with a <b>VIDEOINFOHEADER2</b> format structure. </td> </tr> </table>
    ///    ppvRepresentation = Receives a pointer to a structure that contains the representation. The method allocates the memory for the
    ///                        structure. The caller must release the memory by calling IMFMediaType::FreeRepresentation.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The details of the media type do not
    ///    match the requested representation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> The media type is not valid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>MF_E_UNSUPPORTED_REPRESENTATION</b></dt> </dl> </td> <td width="60%"> The
    ///    media type does not support the requested representation. </td> </tr> </table>
    ///    
    HRESULT GetRepresentation(GUID guidRepresentation, void** ppvRepresentation);
    ///Frees memory that was allocated by the IMFMediaType::GetRepresentation method.
    ///Params:
    ///    guidRepresentation = GUID that was passed to the GetRepresentation method.
    ///    pvRepresentation = Pointer to the buffer that was returned by the GetRepresentation method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT FreeRepresentation(GUID guidRepresentation, void* pvRepresentation);
}

///<p class="CCE_Message">[<b>IMFAudioMediaType</b> is no longer available for use as of Windows 7. Instead, use the
///media type attributes to get the properties of the audio format.] Represents a description of an audio format.
@GUID("26A0ADC3-CE26-4672-9304-69552EDD3FAF")
interface IMFAudioMediaType : IMFMediaType
{
    ///<p class="CCE_Message">[<b>GetAudioFormat</b> is no longer available for use as of Windows 7. Instead, use the
    ///media type attributes to get the properties of the audio format.] Returns a pointer to a WAVEFORMATEX structure
    ///that describes the audio format.
    ///Returns:
    ///    This method returns a pointer to a WAVEFORMATEX structure.
    ///    
    WAVEFORMATEX* GetAudioFormat();
}

///Represents a description of a video format.
@GUID("B99F381F-A8F9-47A2-A5AF-CA3A225A3890")
interface IMFVideoMediaType : IMFMediaType
{
    ///<p class="CCE_Message">[<b>GetVideoFormat</b> is no longer available for use as of Windows 7. Instead, use the
    ///media type attributes to get the properties of the video format.] Returns a pointer to an MFVIDEOFORMAT structure
    ///that describes the video format.
    ///Returns:
    ///    This method returns a pointer to an MFVIDEOFORMAT structure.
    ///    
    MFVIDEOFORMAT* GetVideoFormat();
    ///<p class="CCE_Message">[This API is not supported and may be altered or unavailable in the future. Instead,
    ///applications should set the MF_MT_DEFAULT_STRIDE attribute on the media type to specify the surface stride and
    ///then call IMFMediaType::GetRepresentation.] Retrieves an alternative representation of the media type.
    ///Params:
    ///    guidRepresentation = GUID that specifies the representation to retrieve. For a list of values, see
    ///                         IMFMediaType::GetRepresentation.
    ///    ppvRepresentation = Receives a pointer to a structure that contains the representation. The method allocates the memory for the
    ///                        structure. The caller must release the memory by calling IMFMediaType::FreeRepresentation.
    ///    lStride = Stride of the video surface, in bytes. If the stride is unknown, set this value to 0. If the value is 0, the
    ///              method computes the stride from the image width and assumes that there is no padding.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetVideoRepresentation(GUID guidRepresentation, void** ppvRepresentation, int lStride);
}

///Provides information about the result of an asynchronous operation.
@GUID("AC6B7889-0740-4D51-8619-905994A55CC6")
interface IMFAsyncResult : IUnknown
{
    ///Returns the state object specified by the caller in the asynchronous <b>Begin</b> method.
    ///Params:
    ///    ppunkState = Receives a pointer to the state object's <b>IUnknown</b> interface. If the value is not <b>NULL</b>, the
    ///                 caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> There is no state object associated with this
    ///    asynchronous result. </td> </tr> </table>
    ///    
    HRESULT  GetState(IUnknown* ppunkState);
    ///Returns the status of the asynchronous operation.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation completed successfully. </td> </tr> </table>
    ///    
    HRESULT  GetStatus();
    ///Sets the status of the asynchronous operation.
    ///Params:
    ///    hrStatus = The status of the asynchronous operation.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT  SetStatus(HRESULT hrStatus);
    HRESULT  GetObjectA(IUnknown* ppObject);
    ///Returns the state object specified by the caller in the asynchronous <b>Begin</b> method, without incrementing
    ///the object's reference count.
    ///Returns:
    ///    Returns a pointer to the state object's <b>IUnknown</b> interface, or <b>NULL</b> if no object was set. This
    ///    pointer does not have an outstanding reference count. If you store this pointer, you must call <b>AddRef</b>
    ///    on the pointer.
    ///    
    IUnknown GetStateNoAddRef();
}

///Callback interface to notify the application when an asynchronous method completes.
@GUID("A27003CF-2354-4F2A-8D6A-AB7CFF15437E")
interface IMFAsyncCallback : IUnknown
{
    ///Provides configuration information to the dispatching thread for a callback.
    ///Params:
    ///    pdwFlags = Receives a flag indicating the behavior of the callback object's IMFAsyncCallback::Invoke method. The
    ///               following values are defined. The default value is zero. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///               <tr> <td width="40%"><a id="Zero"></a><a id="zero"></a><a id="ZERO"></a><dl> <dt><b>Zero</b></dt> </dl> </td>
    ///               <td width="60%"> The callback does not take a long time to complete, but has no specific restrictions on what
    ///               system calls it makes. The callback generally takes less than 30 milliseconds to complete. </td> </tr> <tr>
    ///               <td width="40%"><a id="MFASYNC_FAST_IO_PROCESSING_CALLBACK"></a><a
    ///               id="mfasync_fast_io_processing_callback"></a><dl> <dt><b><b>MFASYNC_FAST_IO_PROCESSING_CALLBACK</b></b></dt>
    ///               </dl> </td> <td width="60%"> The callback does very minimal processing. It takes less than 1 millisecond to
    ///               complete. The callback must be invoked from one of the following work queues: <ul>
    ///               <li><b>MFASYNC_CALLBACK_QUEUE_IO</b></li> <li><b>MFASYNC_CALLBACK_QUEUE_TIMER</b></li> </ul> </td> </tr> <tr>
    ///               <td width="40%"><a id="MFASYNC_SIGNAL_CALLBACK"></a><a id="mfasync_signal_callback"></a><dl>
    ///               <dt><b><b>MFASYNC_SIGNAL_CALLBACK</b></b></dt> </dl> </td> <td width="60%"> Implies
    ///               <b>MFASYNC_FAST_IO_PROCESSING_CALLBACK</b>, with the additional restriction that the callback does no
    ///               processing (less than 50 microseconds), and the only system call it makes is <b>SetEvent</b>. The callback
    ///               must be invoked from one of the following work queues: <ul> <li><b>MFASYNC_CALLBACK_QUEUE_IO</b></li>
    ///               <li><b>MFASYNC_CALLBACK_QUEUE_TIMER</b></li> </ul> </td> </tr> <tr> <td width="40%"><a
    ///               id="MFASYNC_BLOCKING_CALLBACK"></a><a id="mfasync_blocking_callback"></a><dl>
    ///               <dt><b><b>MFASYNC_BLOCKING_CALLBACK</b></b></dt> </dl> </td> <td width="60%"> Blocking callback. </td> </tr>
    ///               <tr> <td width="40%"><a id="MFASYNC_REPLY_CALLBACK"></a><a id="mfasync_reply_callback"></a><dl>
    ///               <dt><b><b>MFASYNC_REPLY_CALLBACK</b></b></dt> </dl> </td> <td width="60%"> Reply callback. </td> </tr>
    ///               </table>
    ///    pdwQueue = Receives the identifier of the work queue on which the callback is dispatched. This value can specify one of
    ///               the standard Media Foundation work queues, or a work queue created by the application. For list of standard
    ///               Media Foundation work queues, see Work Queue Identifiers. To create a new work queue, call
    ///               MFAllocateWorkQueue. The default value is <b>MFASYNC_CALLBACK_QUEUE_STANDARD</b>. If the work queue is not
    ///               compatible with the value returned in <i>pdwFlags</i>, the Media Foundation platform returns
    ///               <b>MF_E_INVALID_WORKQUEUE</b> when it tries to dispatch the callback. (See MFPutWorkItem.)
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>E_NOTIMPL</b></b></dt> </dl> </td> <td width="60%"> Not implemented. Assume the
    ///    default behavior. </td> </tr> </table>
    ///    
    HRESULT GetParameters(uint* pdwFlags, uint* pdwQueue);
    ///Called when an asynchronous operation is completed.
    ///Params:
    ///    pAsyncResult = Pointer to the IMFAsyncResult interface. Pass this pointer to the asynchronous <b>End...</b> method to
    ///                   complete the asynchronous call.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Invoke(IMFAsyncResult pAsyncResult);
}

///Provides logging information about the parent object the async callback is associated with.
@GUID("C7A4DCA1-F5F0-47B6-B92B-BF0106D25791")
interface IMFAsyncCallbackLogging : IMFAsyncCallback
{
    ///Gets the pointer to the parent object the async callback is associated with.
    ///Returns:
    ///    void pointer to the object.
    ///    
    void* GetObjectPointer();
    ///Gets the tag of the parent object the async callback is associated object.
    ///Returns:
    ///    The tag of the object.
    ///    
    uint  GetObjectTag();
}

///Represents an event generated by a Media Foundation object. Use this interface to get information about the event. To
///get a pointer to this interface, call IMFMediaEventGenerator::BeginGetEvent or IMFMediaEventGenerator::GetEvent on
///the event generator.
@GUID("DF598932-F10C-4E39-BBA2-C308F101DAA3")
interface IMFMediaEvent : IMFAttributes
{
    ///Retrieves the event type. The event type indicates what happened to trigger the event. It also defines the
    ///meaning of the event value.
    ///Params:
    ///    pmet = Receives the event type. For a list of event types, see Media Foundation Events.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetType(uint* pmet);
    ///Retrieves the extended type of the event.
    ///Params:
    ///    pguidExtendedType = Receives a <b>GUID</b> that identifies the extended type.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetExtendedType(GUID* pguidExtendedType);
    ///Retrieves an <b>HRESULT</b> that specifies the event status.
    ///Params:
    ///    phrStatus = Receives the event status. If the operation that generated the event was successful, the value is a success
    ///                code. A failure code means that an error condition triggered the event.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetStatus(HRESULT* phrStatus);
    ///Retrieves the value associated with the event, if any. The value is retrieved as a <b>PROPVARIANT</b> structure.
    ///The actual data type and the meaning of the value depend on the event.
    ///Params:
    ///    pvValue = Pointer to a <b>PROPVARIANT</b> structure. The method fills this structure with the data.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetValue(PROPVARIANT* pvValue);
}

///Retrieves events from any Media Foundation object that generates events.
@GUID("2CD0BD52-BCD5-4B89-B62C-EADC0C031E7D")
interface IMFMediaEventGenerator : IUnknown
{
    ///Retrieves the next event in the queue. This method is synchronous.
    ///Params:
    ///    dwFlags = Specifies one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///              width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td width="60%"> The method blocks until the
    ///              event generator queues an event. </td> </tr> <tr> <td width="40%"><a id="MF_EVENT_FLAG_NO_WAIT"></a><a
    ///              id="mf_event_flag_no_wait"></a><dl> <dt><b>MF_EVENT_FLAG_NO_WAIT</b></dt> </dl> </td> <td width="60%"> The
    ///              method returns immediately. </td> </tr> </table>
    ///    ppEvent = Receives a pointer to the IMFMediaEvent interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_MULTIPLE_SUBSCRIBERS</b></dt> </dl> </td> <td width="60%"> There is a pending
    ///    request. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NO_EVENTS_AVAILABLE</b></dt> </dl> </td> <td
    ///    width="60%"> There are no events in the queue. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The object was shut down. </td> </tr> </table>
    ///    
    HRESULT GetEvent(uint dwFlags, IMFMediaEvent* ppEvent);
    ///Begins an asynchronous request for the next event in the queue.
    ///Params:
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object. The client must implement this interface.
    ///    punkState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///                <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///                callback is invoked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>MF_E_MULTIPLE_BEGIN</b></dt> </dl> </td> <td width="60%"> There is a pending
    ///    request with the same callback pointer and a different state object. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_MULTIPLE_SUBSCRIBERS</b></dt> </dl> </td> <td width="60%"> There is a pending request with a
    ///    different callback pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td>
    ///    <td width="60%"> The object was shut down. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_S_MULTIPLE_BEGIN</b></dt> </dl> </td> <td width="60%"> There is a pending request with the same
    ///    callback pointer and state object. </td> </tr> </table>
    ///    
    HRESULT BeginGetEvent(IMFAsyncCallback pCallback, IUnknown punkState);
    ///Completes an asynchronous request for the next event in the queue.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              Invoke method.
    ///    ppEvent = Receives a pointer to the IMFMediaEvent interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The object was shut down. </td> </tr>
    ///    </table>
    ///    
    HRESULT EndGetEvent(IMFAsyncResult pResult, IMFMediaEvent* ppEvent);
    ///Puts a new event in the object's queue.
    ///Params:
    ///    met = Specifies the event type. The event type is returned by the event's IMFMediaEvent::GetType method. For a list
    ///          of event types, see Media Foundation Events.
    ///    guidExtendedType = The extended type. If the event does not have an extended type, use the value GUID_NULL. The extended type is
    ///                       returned by the event's IMFMediaEvent::GetExtendedType method.
    ///    hrStatus = A success or failure code indicating the status of the event. This value is returned by the event's
    ///               IMFMediaEvent::GetStatus method.
    ///    pvValue = Pointer to a <b>PROPVARIANT</b> that contains the event value. This parameter can be <b>NULL</b>. This value
    ///              is returned by the event's IMFMediaEvent::GetValue method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The object was shut down. </td> </tr>
    ///    </table>
    ///    
    HRESULT QueueEvent(uint met, const(GUID)* guidExtendedType, HRESULT hrStatus, const(PROPVARIANT)* pvValue);
}

///Used by the Microsoft Media Foundation proxy/stub DLL to marshal certain asynchronous method calls across process
///boundaries. Applications do not use or implement this interface.
@GUID("A27003D0-2354-4F2A-8D6A-AB7CFF15437E")
interface IMFRemoteAsyncCallback : IUnknown
{
    HRESULT Invoke(HRESULT hr, IUnknown pRemoteResult);
}

///Represents a byte stream from some data source, which might be a local file, a network file, or some other source.
///The <b>IMFByteStream</b> interface supports the typical stream operations, such as reading, writing, and seeking.
@GUID("AD4C1B00-4BF7-422F-9175-756693D9130D")
interface IMFByteStream : IUnknown
{
    ///Retrieves the characteristics of the byte stream.
    ///Params:
    ///    pdwCapabilities = Receives a bitwise <b>OR</b> of zero or more flags. The following flags are defined. <table> <tr>
    ///                      <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MFBYTESTREAM_IS_READABLE"></a><a
    ///                      id="mfbytestream_is_readable"></a><dl> <dt><b>MFBYTESTREAM_IS_READABLE</b></dt> <dt>0x00000001</dt> </dl>
    ///                      </td> <td width="60%"> The byte stream can be read. </td> </tr> <tr> <td width="40%"><a
    ///                      id="MFBYTESTREAM_IS_WRITABLE"></a><a id="mfbytestream_is_writable"></a><dl>
    ///                      <dt><b>MFBYTESTREAM_IS_WRITABLE</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The byte stream can
    ///                      be written to. </td> </tr> <tr> <td width="40%"><a id="MFBYTESTREAM_IS_SEEKABLE"></a><a
    ///                      id="mfbytestream_is_seekable"></a><dl> <dt><b>MFBYTESTREAM_IS_SEEKABLE</b></dt> <dt>0x00000004</dt> </dl>
    ///                      </td> <td width="60%"> The byte stream can be seeked. </td> </tr> <tr> <td width="40%"><a
    ///                      id="MFBYTESTREAM_IS_REMOTE"></a><a id="mfbytestream_is_remote"></a><dl>
    ///                      <dt><b>MFBYTESTREAM_IS_REMOTE</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> The byte stream is
    ///                      from a remote source, such as a network. </td> </tr> <tr> <td width="40%"><a
    ///                      id="MFBYTESTREAM_IS_DIRECTORY"></a><a id="mfbytestream_is_directory"></a><dl>
    ///                      <dt><b>MFBYTESTREAM_IS_DIRECTORY</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> The byte stream
    ///                      represents a file directory. </td> </tr> <tr> <td width="40%"><a id="MFBYTESTREAM_HAS_SLOW_SEEK"></a><a
    ///                      id="mfbytestream_has_slow_seek"></a><dl> <dt><b>MFBYTESTREAM_HAS_SLOW_SEEK</b></dt> <dt>0x00000100</dt> </dl>
    ///                      </td> <td width="60%"> Seeking within this stream might be slow. For example, the byte stream might download
    ///                      from a network. </td> </tr> <tr> <td width="40%"><a id="MFBYTESTREAM_IS_PARTIALLY_DOWNLOADED"></a><a
    ///                      id="mfbytestream_is_partially_downloaded"></a><dl> <dt><b>MFBYTESTREAM_IS_PARTIALLY_DOWNLOADED</b></dt>
    ///                      <dt>0x00000200</dt> </dl> </td> <td width="60%"> The byte stream is currently downloading data to a local
    ///                      cache. Read operations on the byte stream might take longer until the data is completely downloaded. This
    ///                      flag is cleared after all of the data has been downloaded. If the <b>MFBYTESTREAM_HAS_SLOW_SEEK</b> flag is
    ///                      also set, it means the byte stream must download the entire file sequentially. Otherwise, the byte stream can
    ///                      respond to seek requests by restarting the download from a new point in the stream. </td> </tr> <tr> <td
    ///                      width="40%"><a id="MFBYTESTREAM_SHARE_WRITE"></a><a id="mfbytestream_share_write"></a><dl>
    ///                      <dt><b>MFBYTESTREAM_SHARE_WRITE</b></dt> <dt>0x00000400</dt> </dl> </td> <td width="60%"> Another thread or
    ///                      process can open this byte stream for writing. If this flag is present, the length of the byte stream could
    ///                      change while it is being read. This flag can affect the behavior of byte-stream handlers. For more
    ///                      information, see MF_BYTESTREAMHANDLER_ACCEPTS_SHARE_WRITE. <div class="alert"><b>Note</b> Requires Windows 7
    ///                      or later.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a
    ///                      id="MFBYTESTREAM_DOES_NOT_USE_NETWORK"></a><a id="mfbytestream_does_not_use_network"></a><dl>
    ///                      <dt><b>MFBYTESTREAM_DOES_NOT_USE_NETWORK</b></dt> <dt>0x00000800</dt> </dl> </td> <td width="60%"> The byte
    ///                      stream is not currently using the network to receive the content. Networking hardware may enter a power
    ///                      saving state when this bit is set. <div class="alert"><b>Note</b> Requires Windows 8 or later.</div> <div>
    ///                      </div> </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCapabilities(uint* pdwCapabilities);
    ///Retrieves the length of the stream.
    ///Params:
    ///    pqwLength = Receives the length of the stream, in bytes. If the length is unknown, this value is -1.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLength(ulong* pqwLength);
    ///Sets the length of the stream.
    ///Params:
    ///    qwLength = Length of the stream in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetLength(ulong qwLength);
    ///Retrieves the current read or write position in the stream.
    ///Params:
    ///    pqwPosition = Receives the current position, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCurrentPosition(ulong* pqwPosition);
    ///Sets the current read or write position.
    ///Params:
    ///    qwPosition = New position in the stream, as a byte offset from the start of the stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT SetCurrentPosition(ulong qwPosition);
    ///Queries whether the current position has reached the end of the stream.
    ///Params:
    ///    pfEndOfStream = Receives the value <b>TRUE</b> if the end of the stream has been reached, or <b>FALSE</b> otherwise.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IsEndOfStream(BOOL* pfEndOfStream);
    ///Reads data from the stream.
    ///Params:
    ///    pb = Pointer to a buffer that receives the data. The caller must allocate the buffer.
    ///    cb = Size of the buffer in bytes.
    ///    pcbRead = Receives the number of bytes that are copied into the buffer. This parameter cannot be <b>NULL</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Read(ubyte* pb, uint cb, uint* pcbRead);
    ///Begins an asynchronous read operation from the stream.
    ///Params:
    ///    pb = Pointer to a buffer that receives the data. The caller must allocate the buffer.
    ///    cb = Size of the buffer in bytes.
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    punkState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///                <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///                callback is invoked.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BeginRead(ubyte* pb, uint cb, IMFAsyncCallback pCallback, IUnknown punkState);
    ///Completes an asynchronous read operation.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              IMFAsyncCallback::Invoke method.
    ///    pcbRead = Receives the number of bytes that were read.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EndRead(IMFAsyncResult pResult, uint* pcbRead);
    ///Writes data to the stream.
    ///Params:
    ///    pb = Pointer to a buffer that contains the data to write.
    ///    cb = Size of the buffer in bytes.
    ///    pcbWritten = Receives the number of bytes that are written.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Write(const(ubyte)* pb, uint cb, uint* pcbWritten);
    ///Begins an asynchronous write operation to the stream.
    ///Params:
    ///    pb = Pointer to a buffer containing the data to write.
    ///    cb = Size of the buffer in bytes.
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    punkState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///                <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///                callback is invoked.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BeginWrite(const(ubyte)* pb, uint cb, IMFAsyncCallback pCallback, IUnknown punkState);
    ///Completes an asynchronous write operation.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              IMFAsyncCallback::Invoke method.
    ///    pcbWritten = Receives the number of bytes that were written.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EndWrite(IMFAsyncResult pResult, uint* pcbWritten);
    ///Moves the current position in the stream by a specified offset.
    ///Params:
    ///    SeekOrigin = Specifies the origin of the seek as a member of the MFBYTESTREAM_SEEK_ORIGIN enumeration. The offset is
    ///                 calculated relative to this position.
    ///    llSeekOffset = Specifies the new position, as a byte offset from the seek origin.
    ///    dwSeekFlags = Specifies zero or more flags. The following flags are defined. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///                  </tr> <tr> <td width="40%"><a id="MFBYTESTREAM_SEEK_FLAG_CANCEL_PENDING_IO"></a><a
    ///                  id="mfbytestream_seek_flag_cancel_pending_io"></a><dl>
    ///                  <dt><b>MFBYTESTREAM_SEEK_FLAG_CANCEL_PENDING_IO</b></dt> </dl> </td> <td width="60%"> All pending I/O
    ///                  requests are canceled after the seek request completes successfully. </td> </tr> </table>
    ///    pqwCurrentPosition = Receives the new position after the seek.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Seek(MFBYTESTREAM_SEEK_ORIGIN SeekOrigin, long llSeekOffset, uint dwSeekFlags, 
                 ulong* pqwCurrentPosition);
    ///Clears any internal buffers used by the stream. If you are writing to the stream, the buffered data is written to
    ///the underlying file or device.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Flush();
    ///Closes the stream and releases any resources associated with the stream, such as sockets or file handles. This
    ///method also cancels any pending asynchronous I/O requests.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Close();
}

///Creates a proxy to a byte stream.
@GUID("A6B43F84-5C0A-42E8-A44D-B1857A76992F")
interface IMFByteStreamProxyClassFactory : IUnknown
{
    ///Creates a proxy to a byte stream. The proxy enables a media source to read from a byte stream in another process.
    ///Params:
    ///    pByteStream = A pointer to the IMFByteStream interface of the byte stream to proxy.
    ///    pAttributes = Reserved. Set to <b>NULL</b>.
    ///    riid = The interface identifer (IID) of the interface being requested.
    ///    ppvObject = Receives a pointer to the interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateByteStreamProxy(IMFByteStream pByteStream, IMFAttributes pAttributes, const(GUID)* riid, 
                                  void** ppvObject);
}

///Writes media samples to a byte stream.
@GUID("8FEED468-6F7E-440D-869A-49BDD283AD0D")
interface IMFSampleOutputStream : IUnknown
{
    ///Begins an asynchronous request to write a media sample to the stream.
    ///Params:
    ///    pSample = A pointer to the IMFSample interface of the sample.
    ///    pCallback = A pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    punkState = A pointer to the IUnknown interface of a state object, defined by the caller. This parameter can be
    ///                <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///                callback is invoked.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BeginWriteSample(IMFSample pSample, IMFAsyncCallback pCallback, IUnknown punkState);
    ///Completes an asynchronous request to write a media sample to the stream.
    ///Params:
    ///    pResult = A pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              IMFAsyncCallback::Invoke method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EndWriteSample(IMFAsyncResult pResult);
    HRESULT Close();
}

///Represents a generic collection of <b>IUnknown</b> pointers.
@GUID("5BC8A76B-869A-46A3-9B03-FA218A66AEBE")
interface IMFCollection : IUnknown
{
    ///Retrieves the number of objects in the collection.
    ///Params:
    ///    pcElements = Receives the number of objects in the collection.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetElementCount(uint* pcElements);
    ///Retrieves an object in the collection.
    ///Params:
    ///    dwElementIndex = Zero-based index of the object to retrieve. Objects are indexed in the order in which they were added to the
    ///                     collection.
    ///    ppUnkElement = Receives a pointer to the object's <b>IUnknown</b> interface. The caller must release the interface. The
    ///                   retrieved pointer value might be <b>NULL</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetElement(uint dwElementIndex, IUnknown* ppUnkElement);
    ///Adds an object to the collection.
    ///Params:
    ///    pUnkElement = Pointer to the object's <b>IUnknown</b> interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AddElement(IUnknown pUnkElement);
    ///Removes an object from the collection.
    ///Params:
    ///    dwElementIndex = Zero-based index of the object to remove. Objects are indexed in the order in which they were added to the
    ///                     collection.
    ///    ppUnkElement = Receives a pointer to the <b>IUnknown</b> interface of the object. The caller must release the interface.
    ///                   This parameter cannot be <b>NULL</b>, but the retrieved pointer value might be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RemoveElement(uint dwElementIndex, IUnknown* ppUnkElement);
    ///Adds an object at the specified index in the collection.
    ///Params:
    ///    dwIndex = The zero-based index where the object will be added to the collection.
    ///    pUnknown = The object to insert.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT InsertElementAt(uint dwIndex, IUnknown pUnknown);
    ///Removes all items from the collection.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RemoveAllElements();
}

///Provides an event queue for applications that need to implement the IMFMediaEventGenerator interface. This interface
///is exposed by a helper object that implements an event queue. If you are writing a component that implements the
///IMFMediaEventGenerator interface, you can use this object in your implementation. The event queue object is thread
///safe and provides methods to queue events and to pull them from the queue either synchronously or asynchronously. To
///create the event queue object, call MFCreateEventQueue.
@GUID("36F846FC-2256-48B6-B58E-E2B638316581")
interface IMFMediaEventQueue : IUnknown
{
    ///Retrieves the next event in the queue. This method is synchronous. Call this method inside your implementation of
    ///IMFMediaEventGenerator::GetEvent. Pass the parameters from that method directly to this method.
    ///Params:
    ///    dwFlags = Specifies whether the method blocks until an event is queued. For a list of valid flags, see
    ///              IMFMediaEventGenerator::GetEvent.
    ///    ppEvent = Receives a pointer to the IMFMediaEvent interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The Shutdown method was called. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetEvent(uint dwFlags, IMFMediaEvent* ppEvent);
    ///Begins an asynchronous request for the next event in the queue. Call this method inside your implementation of
    ///IMFMediaEventGenerator::BeginGetEvent. Pass the parameters from that method directly to this method.
    ///Params:
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object.
    ///    punkState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///                <b>NULL</b>. The object is returned to the caller when the callback is invoked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The Shutdown method was called. </td> </tr>
    ///    </table>
    ///    
    HRESULT BeginGetEvent(IMFAsyncCallback pCallback, IUnknown punkState);
    ///Completes an asynchronous request for the next event in the queue. Call this method inside your implementation of
    ///IMFMediaEventGenerator::EndGetEvent. Pass the parameters from that method directly to this method.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface.
    ///    ppEvent = Receives a pointer to the IMFMediaEvent interface of the event object. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The Shutdown method was called. </td> </tr>
    ///    </table>
    ///    
    HRESULT EndGetEvent(IMFAsyncResult pResult, IMFMediaEvent* ppEvent);
    ///Puts an event in the queue.
    ///Params:
    ///    pEvent = Pointer to the IMFMediaEvent interface of the event to be put in the queue.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The Shutdown method was called. </td> </tr>
    ///    </table>
    ///    
    HRESULT QueueEvent(IMFMediaEvent pEvent);
    ///Creates an event, sets a <b>PROPVARIANT</b> as the event data, and puts the event in the queue. Call this method
    ///inside your implementation of IMFMediaEventGenerator::QueueEvent. Pass the parameters from that method directly
    ///to this method. You can also call this method when your component needs to raise an event that does not contain
    ///attributes. If the event data is an <b>IUnknown</b> pointer, you can use IMFMediaEventQueue::QueueEventParamUnk.
    ///If the event contains attributes, use IMFMediaEventQueue::QueueEvent instead.
    ///Params:
    ///    met = Specifies the type of the event to be added to the queue. The event type is returned by the event's
    ///          IMFMediaEvent::GetType method. For a list of event types, see Media Foundation Events.
    ///    guidExtendedType = The extended type of the event. If the event does not have an extended type, use the value GUID_NULL. The
    ///                       extended type is returned by the event's IMFMediaEvent::GetExtendedType method.
    ///    hrStatus = A success or failure code indicating the status of the event. This value is returned by the event's
    ///               IMFMediaEvent::GetStatus method.
    ///    pvValue = Pointer to a <b>PROPVARIANT</b> that contains the event value. This parameter can be <b>NULL</b>. This value
    ///              is returned by the event's IMFMediaEvent::GetValue method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The Shutdown method was called. </td> </tr>
    ///    </table>
    ///    
    HRESULT QueueEventParamVar(uint met, const(GUID)* guidExtendedType, HRESULT hrStatus, 
                               const(PROPVARIANT)* pvValue);
    ///Creates an event, sets an <b>IUnknown</b> pointer as the event data, and puts the event in the queue.
    ///Params:
    ///    met = Specifies the event type of the event to be added to the queue. The event type is returned by the event's
    ///          IMFMediaEvent::GetType method. For a list of event types, see Media Foundation Events.
    ///    guidExtendedType = The extended type of the event. If the event does not have an extended type, use the value GUID_NULL. The
    ///                       extended type is returned by the event's IMFMediaEvent::GetExtendedType method.
    ///    hrStatus = A success or failure code indicating the status of the event. This value is returned by the event's
    ///               IMFMediaEvent::GetStatus method.
    ///    pUnk = Pointer to the <b>IUnknown</b> interface. The method sets this pointer as the event value. The pointer is
    ///           returned by the event's IMFMediaEvent::GetValue method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The Shutdown method was called. </td> </tr>
    ///    </table>
    ///    
    HRESULT QueueEventParamUnk(uint met, const(GUID)* guidExtendedType, HRESULT hrStatus, IUnknown pUnk);
    ///Shuts down the event queue.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Shutdown();
}

///Enables the application to defer the creation of an object. This interface is exposed by activation objects.
@GUID("7FEE9E9A-4A89-47A6-899C-B6A53A70FB67")
interface IMFActivate : IMFAttributes
{
    ///Creates the object associated with this activation object.
    ///Params:
    ///    riid = Interface identifier (IID) of the requested interface.
    ///    ppv = Receives a pointer to the requested interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ActivateObject(const(GUID)* riid, void** ppv);
    ///Shuts down the created object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ShutdownObject();
    ///Detaches the created object from the activation object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td> </tr> </table>
    ///    
    HRESULT DetachObject();
}

///Controls how media sources and transforms are enumerated in Microsoft Media Foundation. To get a pointer to this
///interface, call MFGetPluginControl.
@GUID("5C6C44BF-1DB6-435B-9249-E8CD10FDEC96")
interface IMFPluginControl : IUnknown
{
    ///Searches the preferred list for a class identifier (CLSID) that matches a specified key name.
    ///Params:
    ///    pluginType = Member of the MF_Plugin_Type enumeration, specifying the type of object.
    ///    selector = The key name to match. For more information about the format of key names, see the Remarks section of
    ///               IMFPluginControl.
    ///    clsid = Receives a CLSID from the preferred list.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>HRESULT_FROM_WIN32(ERROR_NOT_FOUND)</b></b></dt> </dl> </td> <td
    ///    width="60%"> No CLSID matching this key was found. </td> </tr> </table>
    ///    
    HRESULT GetPreferredClsid(uint pluginType, const(PWSTR) selector, GUID* clsid);
    ///Gets a class identifier (CLSID) from the preferred list, specified by index value.
    ///Params:
    ///    pluginType = Member of the MF_Plugin_Type enumeration, specifying the type of object to enumerate.
    ///    index = The zero-based index of the CLSID to retrieve.
    ///    selector = Receives the key name associated with the CLSID. The caller must free the memory for the returned string by
    ///               calling the CoTaskMemFree function. For more information about the format of key names, see the Remarks
    ///               section of IMFPluginControl.
    ///    clsid = Receives the CLSID at the specified index.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)</b></b></dt> </dl> </td>
    ///    <td width="60%"> The <i>index</i> parameter is out of range. </td> </tr> </table>
    ///    
    HRESULT GetPreferredClsidByIndex(uint pluginType, uint index, PWSTR* selector, GUID* clsid);
    ///Adds a class identifier (CLSID) to the preferred list or removes a CLSID from the list.
    ///Params:
    ///    pluginType = Member of the MF_Plugin_Type enumeration, specifying the type of object.
    ///    selector = The key name for the CLSID. For more information about the format of key names, see the Remarks section of
    ///               IMFPluginControl.
    ///    clsid = The CLSID to add to the list. If this parameter is <b>NULL</b>, the key/value entry specified by the
    ///            <i>selector</i> parameter is removed from the list.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPreferredClsid(uint pluginType, const(PWSTR) selector, const(GUID)* clsid);
    ///Queries whether a class identifier (CLSID) appears in the blocked list.
    ///Params:
    ///    pluginType = Member of the MF_Plugin_Type enumeration, specifying the type of object for the query.
    ///    clsid = The CLSID to search for.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The specified CLSID appears in the blocked list.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl> </td> <td width="60%">
    ///    Invalid argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>HRESULT_FROM_WIN32(ERROR_NOT_FOUND)</b></b></dt> </dl> </td> <td width="60%"> The specified CLSID
    ///    is not in the blocked list. </td> </tr> </table>
    ///    
    HRESULT IsDisabled(uint pluginType, const(GUID)* clsid);
    ///Gets a class identifier (CLSID) from the blocked list.
    ///Params:
    ///    pluginType = Member of the MF_Plugin_Type enumeration, specifying the type of object to enumerate.
    ///    index = The zero-based index of the CLSID to retrieve.
    ///    clsid = Receives the CLSID at the specified index.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)</b></b></dt> </dl> </td>
    ///    <td width="60%"> The <i>index</i> parameter is out of range. </td> </tr> </table>
    ///    
    HRESULT GetDisabledByIndex(uint pluginType, uint index, GUID* clsid);
    ///Adds a class identifier (CLSID) to the blocked list, or removes a CLSID from the list.
    ///Params:
    ///    pluginType = Member of the MF_Plugin_Type enumeration, specifying the type of object.
    ///    clsid = The CLSID to add or remove.
    ///    disabled = Specifies whether to add or remove the CSLID. If the value is <b>TRUE</b>, the method adds the CLSID to the
    ///               blocked list. Otherwise, the method removes it from the list.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetDisabled(uint pluginType, const(GUID)* clsid, BOOL disabled);
}

///Controls how media sources and transforms are enumerated in Microsoft Media Foundation. This interface extends the
///IMFPluginControl interface.
@GUID("C6982083-3DDC-45CB-AF5E-0F7A8CE4DE77")
interface IMFPluginControl2 : IMFPluginControl
{
    ///Sets the policy for which media sources and transforms are enumerated.
    ///Params:
    ///    policy = A value from the MF_PLUGIN_CONTROL_POLICY enumeration that specifies the policy.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPolicy(MF_PLUGIN_CONTROL_POLICY policy);
}

///Enables two threads to share the same Microsoft Direct3D 11 device.
@GUID("EB533D5D-2DB6-40F8-97A9-494692014F07")
interface IMFDXGIDeviceManager : IUnknown
{
    ///Closes a Microsoft Direct3D device handle.
    ///Params:
    ///    hDevice = A handle to the Direct3D device.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_HANDLE</b></dt> </dl> </td> <td width="60%"> The specified handle is not a
    ///    Direct3D device handle. </td> </tr> </table>
    ///    
    HRESULT CloseDeviceHandle(HANDLE hDevice);
    ///Queries the Microsoft Direct3D device for an interface.
    ///Params:
    ///    hDevice = A handle to the Direct3D device. To get the device handle, call IMFDXGIDeviceManager::OpenDeviceHandle.
    ///    riid = The interface identifier (IID) of the requested interface. The Direct3D device supports the following
    ///           interfaces: <ul> <li> ID3D11Device. To get a pointer to the Direct3D11 device, use <b>IID_ID3D11Device</b> as
    ///           the <i>riid</i>.</li> <li> ID3D11VideoDevice. To get a pointer to the Direct3D11 video device, use
    ///           <b>IID_ID3D11VideoDevice</b> as the <i>riid</i>.</li> </ul>
    ///    ppService = Receives a pointer to the requested interface. The caller must release the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_HANDLE</b></dt> </dl> </td> <td width="60%"> The specified handle is not a
    ///    Direct3D device handle. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_DXGI_DEVICE_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The DXGI Device Manager was not
    ///    initialized. The owner of the device must call IMFDXGIDeviceManager::ResetDevice. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_DXGI_NEW_VIDEO_DEVICE</b></dt> </dl> </td> <td width="60%"> The device handle
    ///    is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%">
    ///    If a ID3D11VideoDevice is specified and the D3D device created is using the reference rasterizer or WARP. Or
    ///    it is a hardware device and you are using the Microsoft Basic Display Adapter. </td> </tr> </table>
    ///    
    HRESULT GetVideoService(HANDLE hDevice, const(GUID)* riid, void** ppService);
    ///Gives the caller exclusive access to the Microsoft Direct3D device.
    ///Params:
    ///    hDevice = A handle to the Direct3D device. To get the device handle, call IMFDXGIDeviceManager::OpenDeviceHandle.
    ///    riid = The interface identifier (IID) of the requested interface. The Direct3D device will support the following
    ///           interfaces: <ul> <li> ID3D11Device </li> <li> ID3D11VideoContext </li> <li> ID3D11VideoDevice </li> </ul>
    ///    ppUnkDevice = Receives a pointer to the requested interface. The caller must release the interface.
    ///    fBlock = Specifies whether to wait for the device lock. If the device is already locked and this parameter is
    ///             <b>TRUE</b>, the method blocks until the device is unlocked. Otherwise, if the device is locked and this
    ///             parameter is <b>FALSE</b>, the method returns immediately with the error code
    ///             <b>DXVA2_E_VIDEO_DEVICE_LOCKED</b>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_HANDLE</b></dt> </dl> </td> <td width="60%"> The specified handle is not a
    ///    Direct3D device handle. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_DXGI_DEVICE_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The DXGI Device Manager was not
    ///    initialized. The owner of the device must call IMFDXGIDeviceManager::ResetDevice. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_DXGI_NEW_VIDEO_DEVICE</b></dt> </dl> </td> <td width="60%"> The device handle
    ///    is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_DXGI_VIDEO_DEVICE_LOCKED</b></dt> </dl> </td>
    ///    <td width="60%"> The device is locked and <i>fBlock</i> is <b>FALSE</b>. </td> </tr> </table>
    ///    
    HRESULT LockDevice(HANDLE hDevice, const(GUID)* riid, void** ppUnkDevice, BOOL fBlock);
    ///Gets a handle to the Microsoft Direct3D device.
    ///Params:
    ///    phDevice = Receives the device handle.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_DXGI_DEVICE_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The DXGI
    ///    Device Manager was not initialized. The owner of the device must call IMFDXGIDeviceManager::ResetDevice.
    ///    </td> </tr> </table>
    ///    
    HRESULT OpenDeviceHandle(HANDLE* phDevice);
    ///Sets the Microsoft Direct3D device or notifies the device manager that the Direct3D device was reset.
    ///Params:
    ///    pUnkDevice = A pointer to the IUnknown interface of the DXGI device.
    ///    resetToken = The token that was received in the <i>pResetToken</i> parameter of the MFCreateDXGIDeviceManager function.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ResetDevice(IUnknown pUnkDevice, uint resetToken);
    ///Tests whether a Microsoft Direct3D device handle is valid.
    ///Params:
    ///    hDevice = A handle to the Direct3D device. To get the device handle, call IMFDXGIDeviceManager::OpenDeviceHandle.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_HANDLE</b></dt> </dl> </td> <td width="60%"> The specified handle is not a
    ///    Direct3D device handle. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_DXGI_NEW_VIDEO_DEVICE</b></dt>
    ///    </dl> </td> <td width="60%"> The device handle is invalid. </td> </tr> </table>
    ///    
    HRESULT TestDevice(HANDLE hDevice);
    ///Unlocks the Microsoft Direct3D device.
    ///Params:
    ///    hDevice = A handle to the Direct3D device. To get the device handle, call IMFDXGIDeviceManager::OpenDeviceHandle.
    ///    fSaveState = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UnlockDevice(HANDLE hDevice, BOOL fSaveState);
}

///Provides access to the IMFAttributes of the substreams of a multiplexed media source.
@GUID("CE8BD576-E440-43B3-BE34-1E53F565F7E8")
interface IMFMuxStreamAttributesManager : IUnknown
{
    ///Gets the count of substreams managed by the multiplexed media source.
    ///Params:
    ///    pdwMuxStreamCount = The count of substreams managed by the multiplexed media source.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT GetStreamCount(uint* pdwMuxStreamCount);
    ///Gets the IMFAttributes for the substream with the specified index.
    ///Params:
    ///    dwMuxStreamIndex = The index of the substream for which attributes are retrieved.
    ///    ppStreamAttributes = The attributes for the specified substream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> The stream specified
    ///    substream index is invalid. Call GetStreamCount to get the number of substreams managed by the multiplexed
    ///    media source. </td> </tr> </table>
    ///    
    HRESULT GetAttributes(uint dwMuxStreamIndex, IMFAttributes* ppStreamAttributes);
}

///Enables the management of stream configurations for a multiplexed media source. A stream configuration defines a set
///of substreams that can be included the multiplexed output.
@GUID("505A2C72-42F7-4690-AEAB-8F513D0FFDB8")
interface IMFMuxStreamMediaTypeManager : IUnknown
{
    ///Gets the count of substreams managed by the multiplexed media source.
    ///Params:
    ///    pdwMuxStreamCount = The count of substreams managed by the multiplexed media source.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT GetStreamCount(uint* pdwMuxStreamCount);
    ///Gets the IMFMediaType of the substream with the specified index.
    ///Params:
    ///    dwMuxStreamIndex = The index of the substream for which the media type is retrieved.
    ///    ppMediaType = The media type of the substream with the specified index.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> The stream specified
    ///    substream index is invalid. Call GetStreamCount to get the number of substreams managed by the multiplexed
    ///    media source. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td
    ///    width="60%"> The media type of the specified substream is invalid. </td> </tr> </table>
    ///    
    HRESULT GetMediaType(uint dwMuxStreamIndex, IMFMediaType* ppMediaType);
    ///Gets the count of registered stream configurations, which define set of substreams that can be included the
    ///multiplexed output.
    ///Params:
    ///    pdwCount = The number of registered stream configurations.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT GetStreamConfigurationCount(uint* pdwCount);
    ///Registers a stream configuration, which defines a set of substreams that can be included the multiplexed output.
    ///Params:
    ///    ullStreamMask = A bitmask value where the bits that are on represent the indices of the substreams that are included in the
    ///                    stream configuration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The specified configuration is already registered.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The
    ///    supplied bitmask has bits set that are invalid for the media source. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is insufficient memory to complete the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT AddStreamConfiguration(ulong ullStreamMask);
    ///Unregisters a stream configuration, which defines a set of substreams that can be included the multiplexed
    ///output.
    ///Params:
    ///    ullStreamMask = A bitmask value where the bits that are on represent the indices of the substreams that are included in the
    ///                    stream configuration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The specified configuration is not currently
    ///    registered. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    There is insufficient memory to complete the operation. </td> </tr> </table>
    ///    
    HRESULT RemoveStreamConfiguration(ulong ullStreamMask);
    ///Gets the stream configuration with the specified index, which defines a set of substreams that can be included
    ///the multiplexed output.
    ///Params:
    ///    ulIndex = The index of the configuration to retrieve.
    ///    pullStreamMask = The index of the configuration to retrieve.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDINDEX</b></dt> </dl> </td> <td width="60%"> The specified configuration index is not
    ///    valid. </td> </tr> </table>
    ///    
    HRESULT GetStreamConfiguration(uint ulIndex, ulong* pullStreamMask);
}

///Provides the ability to retrieve IMFSample objects for individual substreams within the output of a multiplexed media
///source.
@GUID("74ABBC19-B1CC-4E41-BB8B-9D9B86A8F6CA")
interface IMFMuxStreamSampleManager : IUnknown
{
    ///Gets the count of substreams managed by the multiplexed media source.
    ///Params:
    ///    pdwMuxStreamCount = The count of substreams managed by the multiplexed media source.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT GetStreamCount(uint* pdwMuxStreamCount);
    ///Gets the IMFSample associated with the substream with the specified index.
    ///Params:
    ///    dwMuxStreamIndex = The index of the substream for which a sample is retrieved.
    ///    ppSample = The retrieved sample.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> The specified substream index is
    ///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMDATA</b></dt> </dl> </td> <td
    ///    width="60%"> The stream data for the sample is invalid. </td> </tr> </table>
    ///    
    HRESULT GetSample(uint dwMuxStreamIndex, IMFSample* ppSample);
    ///Gets the active stream configuration for the media source, which defines the set of substreams that are included
    ///the multiplexed output.
    ///Returns:
    ///    Gets a bitmask value where the bits that are on represent the indices of the substreams that are included in
    ///    the stream configuration.
    ///    
    ulong   GetStreamConfiguration();
}

@GUID("C1209904-E584-4752-A2D6-7F21693F8B21")
interface IMFSecureBuffer : IUnknown
{
    HRESULT GetIdentifier(GUID* pGuidIdentifier);
}

///Implemented by all Media Foundation Transforms (MFTs).
@GUID("BF94C121-5B05-4E6F-8000-BA598961414D")
interface IMFTransform : IUnknown
{
    ///Gets the minimum and maximum number of input and output streams for this Media Foundation transform (MFT).
    ///Params:
    ///    pdwInputMinimum = Receives the minimum number of input streams.
    ///    pdwInputMaximum = Receives the maximum number of input streams. If there is no maximum, receives the value
    ///                      <b>MFT_STREAMS_UNLIMITED</b>.
    ///    pdwOutputMinimum = Receives the minimum number of output streams.
    ///    pdwOutputMaximum = Receives the maximum number of output streams. If there is no maximum, receives the value
    ///                       <b>MFT_STREAMS_UNLIMITED</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamLimits(uint* pdwInputMinimum, uint* pdwInputMaximum, uint* pdwOutputMinimum, 
                            uint* pdwOutputMaximum);
    ///Gets the current number of input and output streams on this Media Foundation transform (MFT).
    ///Params:
    ///    pcInputStreams = Receives the number of input streams.
    ///    pcOutputStreams = Receives the number of output streams.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamCount(uint* pcInputStreams, uint* pcOutputStreams);
    ///Gets the stream identifiers for the input and output streams on this Media Foundation transform (MFT).
    ///Params:
    ///    dwInputIDArraySize = Number of elements in the <i>pdwInputIDs</i> array.
    ///    pdwInputIDs = Pointer to an array allocated by the caller. The method fills the array with the input stream identifiers.
    ///                  The array size must be at least equal to the number of input streams. To get the number of input streams,
    ///                  call IMFTransform::GetStreamCount. If the caller passes an array that is larger than the number of input
    ///                  streams, the MFT must not write values into the extra array entries.
    ///    dwOutputIDArraySize = Number of elements in the <i>pdwOutputIDs</i> array.
    ///    pdwOutputIDs = Pointer to an array allocated by the caller. The method fills the array with the output stream identifiers.
    ///                   The array size must be at least equal to the number of output streams. To get the number of output streams,
    ///                   call GetStreamCount. If the caller passes an array that is larger than the number of output streams, the MFT
    ///                   must not write values into the extra array entries.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. See Remarks. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td width="60%"> One or both of the
    ///    arrays is too small. </td> </tr> </table>
    ///    
    HRESULT GetStreamIDs(uint dwInputIDArraySize, uint* pdwInputIDs, uint dwOutputIDArraySize, uint* pdwOutputIDs);
    ///Gets the buffer requirements and other information for an input stream on this Media Foundation transform (MFT).
    ///Params:
    ///    dwInputStreamID = Input stream identifier. To get the list of stream identifiers, call IMFTransform::GetStreamIDs.
    ///    pStreamInfo = Pointer to an MFT_INPUT_STREAM_INFO structure. The method fills the structure with information about the
    ///                  input stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> Invalid stream identifier. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetInputStreamInfo(uint dwInputStreamID, MFT_INPUT_STREAM_INFO* pStreamInfo);
    ///Gets the buffer requirements and other information for an output stream on this Media Foundation transform (MFT).
    ///Params:
    ///    dwOutputStreamID = Output stream identifier. To get the list of stream identifiers, call IMFTransform::GetStreamIDs.
    ///    pStreamInfo = Pointer to an MFT_OUTPUT_STREAM_INFO structure. The method fills the structure with information about the
    ///                  output stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> Invalid stream number. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetOutputStreamInfo(uint dwOutputStreamID, MFT_OUTPUT_STREAM_INFO* pStreamInfo);
    ///Gets the global attribute store for this Media Foundation transform (MFT).
    ///Params:
    ///    pAttributes = Receives a pointer to the IMFAttributes interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The MFT does not support attributes. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetAttributes(IMFAttributes* pAttributes);
    ///Gets the attribute store for an input stream on this Media Foundation transform (MFT).
    ///Params:
    ///    dwInputStreamID = Input stream identifier. To get the list of stream identifiers, call IMFTransform::GetStreamIDs.
    ///    pAttributes = Receives a pointer to the IMFAttributes interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The MFT does not support input stream attributes.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%">
    ///    Invalid stream identifier. </td> </tr> </table>
    ///    
    HRESULT GetInputStreamAttributes(uint dwInputStreamID, IMFAttributes* pAttributes);
    ///Gets the attribute store for an output stream on this Media Foundation transform (MFT).
    ///Params:
    ///    dwOutputStreamID = Output stream identifier. To get the list of stream identifiers, call IMFTransform::GetStreamIDs.
    ///    pAttributes = Receives a pointer to the IMFAttributes interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The MFT does not support output stream
    ///    attributes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid stream identifier. </td> </tr> </table>
    ///    
    HRESULT GetOutputStreamAttributes(uint dwOutputStreamID, IMFAttributes* pAttributes);
    ///Removes an input stream from this Media Foundation transform (MFT).
    ///Params:
    ///    dwStreamID = Identifier of the input stream to remove.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The transform has a fixed number of input
    ///    streams. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td
    ///    width="60%"> The stream is not removable, or the transform currently has the minimum number of input streams
    ///    it can support. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid stream identifier. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_TRANSFORM_INPUT_REMAINING</b></dt> </dl> </td> <td width="60%"> The transform has unprocessed
    ///    input buffers for the specified stream. </td> </tr> </table>
    ///    
    HRESULT DeleteInputStream(uint dwStreamID);
    ///Adds one or more new input streams to this Media Foundation transform (MFT).
    ///Params:
    ///    cStreams = Number of streams to add.
    ///    adwStreamIDs = Array of stream identifiers. The new stream identifiers must not match any existing input streams.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The MFT has a fixed number of input
    ///    streams. </td> </tr> </table>
    ///    
    HRESULT AddInputStreams(uint cStreams, uint* adwStreamIDs);
    ///Gets an available media type for an input stream on this Media Foundation transform (MFT).
    ///Params:
    ///    dwInputStreamID = Input stream identifier. To get the list of stream identifiers, call IMFTransform::GetStreamIDs.
    ///    dwTypeIndex = Index of the media type to retrieve. Media types are indexed from zero and returned in approximate order of
    ///                  preference.
    ///    ppType = Receives a pointer to the IMFMediaType interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The MFT does not have a list of available input
    ///    types. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid stream identifier. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_NO_MORE_TYPES</b></dt> </dl> </td> <td width="60%"> The <i>dwTypeIndex</i> parameter is out of
    ///    range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td
    ///    width="60%"> You must set the output types before setting the input types. </td> </tr> </table>
    ///    
    HRESULT GetInputAvailableType(uint dwInputStreamID, uint dwTypeIndex, IMFMediaType* ppType);
    ///Gets an available media type for an output stream on this Media Foundation transform (MFT).
    ///Params:
    ///    dwOutputStreamID = Output stream identifier. To get the list of stream identifiers, call IMFTransform::GetStreamIDs.
    ///    dwTypeIndex = Index of the media type to retrieve. Media types are indexed from zero and returned in approximate order of
    ///                  preference.
    ///    ppType = Receives a pointer to the IMFMediaType interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The MFT does not have a list of available output
    ///    types. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid stream identifier. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_NO_MORE_TYPES</b></dt> </dl> </td> <td width="60%"> The <i>dwTypeIndex</i> parameter is out of
    ///    range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td
    ///    width="60%"> You must set the input types before setting the output types. </td> </tr> </table>
    ///    
    HRESULT GetOutputAvailableType(uint dwOutputStreamID, uint dwTypeIndex, IMFMediaType* ppType);
    ///Sets, tests, or clears the media type for an input stream on this Media Foundation transform (MFT).
    ///Params:
    ///    dwInputStreamID = Input stream identifier. To get the list of stream identifiers, call IMFTransform::GetStreamIDs.
    ///    pType = Pointer to the IMFMediaType interface, or <b>NULL</b>.
    ///    dwFlags = Zero or more flags from the _MFT_SET_TYPE_FLAGS enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> The MFT cannot use the proposed media
    ///    type. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid stream identifier. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALIDTYPE</b></dt> </dl> </td> <td width="60%"> The proposed type is not valid. This error code
    ///    indicates that the media type itself is not configured correctly; for example, it might contain mutually
    ///    contradictory attributes. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING</b></dt> </dl> </td> <td width="60%"> The MFT
    ///    cannot switch types while processing data. Try draining or flushing the MFT. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> You must set the
    ///    output types before setting the input types. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_UNSUPPORTED_D3D_TYPE</b></dt> </dl> </td> <td width="60%"> The MFT could not find a suitable
    ///    DirectX Video Acceleration (DXVA) configuration. </td> </tr> </table>
    ///    
    HRESULT SetInputType(uint dwInputStreamID, IMFMediaType pType, uint dwFlags);
    ///Sets, tests, or clears the media type for an output stream on this Media Foundation transform (MFT).
    ///Params:
    ///    dwOutputStreamID = Output stream identifier. To get the list of stream identifiers, call IMFTransform::GetStreamIDs.
    ///    pType = Pointer to the IMFMediaType interface, or <b>NULL</b>.
    ///    dwFlags = Zero or more flags from the _MFT_SET_TYPE_FLAGS enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> The transform cannot use the proposed
    ///    media type. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid stream identifier. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALIDTYPE</b></dt> </dl> </td> <td width="60%"> The proposed type is not valid. This error code
    ///    indicates that the media type itself is not configured correctly; for example, it might contain mutually
    ///    contradictory flags. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING</b></dt> </dl> </td> <td width="60%"> The MFT
    ///    cannot switch types while processing data. Try draining or flushing the MFT. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> You must set the
    ///    input types before setting the output types. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_UNSUPPORTED_D3D_TYPE</b></dt> </dl> </td> <td width="60%"> The MFT could not find a suitable
    ///    DirectX Video Acceleration (DXVA) configuration. </td> </tr> </table>
    ///    
    HRESULT SetOutputType(uint dwOutputStreamID, IMFMediaType pType, uint dwFlags);
    ///Gets the current media type for an input stream on this Media Foundation transform (MFT).
    ///Params:
    ///    dwInputStreamID = Input stream identifier. To get the list of stream identifiers, call IMFTransform::GetStreamIDs.
    ///    ppType = Receives a pointer to the IMFMediaType interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> Invalid stream identifier. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> The
    ///    input media type has not been set. </td> </tr> </table>
    ///    
    HRESULT GetInputCurrentType(uint dwInputStreamID, IMFMediaType* ppType);
    ///Gets the current media type for an output stream on this Media Foundation transform (MFT).
    ///Params:
    ///    dwOutputStreamID = Output stream identifier. To get the list of stream identifiers, call IMFTransform::GetStreamIDs.
    ///    ppType = Receives a pointer to the IMFMediaType interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> Invalid stream identifier. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> The
    ///    output media type has not been set. </td> </tr> </table>
    ///    
    HRESULT GetOutputCurrentType(uint dwOutputStreamID, IMFMediaType* ppType);
    ///Queries whether an input stream on this Media Foundation transform (MFT) can accept more data.
    ///Params:
    ///    dwInputStreamID = Input stream identifier. To get the list of stream identifiers, call IMFTransform::GetStreamIDs.
    ///    pdwFlags = Receives a member of the _MFT_INPUT_STATUS_FLAGS enumeration, or zero. If the value is
    ///               <b>MFT_INPUT_STATUS_ACCEPT_DATA</b>, the stream specified in <i>dwInputStreamID</i> can accept more input
    ///               data.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> Invalid stream identifier. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> The
    ///    media type is not set on one or more streams. </td> </tr> </table>
    ///    
    HRESULT GetInputStatus(uint dwInputStreamID, uint* pdwFlags);
    ///Queries whether the Media Foundation transform (MFT) is ready to produce output data.
    ///Params:
    ///    pdwFlags = Receives a member of the _MFT_OUTPUT_STATUS_FLAGS enumeration, or zero. If the value is
    ///               <b>MFT_OUTPUT_STATUS_SAMPLE_READY</b>, the MFT can produce an output sample.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> The media type is
    ///    not set on one or more streams. </td> </tr> </table>
    ///    
    HRESULT GetOutputStatus(uint* pdwFlags);
    ///Sets the range of time stamps the client needs for output.
    ///Params:
    ///    hnsLowerBound = Specifies the earliest time stamp. The Media Foundation transform (MFT) will accept input until it can
    ///                    produce an output sample that begins at this time; or until it can produce a sample that ends at this time or
    ///                    later. If there is no lower bound, use the value <b>MFT_OUTPUT_BOUND_LOWER_UNBOUNDED</b>.
    ///    hnsUpperBound = Specifies the latest time stamp. The MFT will not produce an output sample with time stamps later than this
    ///                    time. If there is no upper bound, use the value <b>MFT_OUTPUT_BOUND_UPPER_UNBOUNDED</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> The media type is
    ///    not set on one or more streams. </td> </tr> </table>
    ///    
    HRESULT SetOutputBounds(long hnsLowerBound, long hnsUpperBound);
    ///Sends an event to an input stream on this Media Foundation transform (MFT).
    ///Params:
    ///    dwInputStreamID = Input stream identifier. To get the list of stream identifiers, call IMFTransform::GetStreamIDs.
    ///    pEvent = Pointer to the IMFMediaEvent interface of an event object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> Invalid stream
    ///    number. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td
    ///    width="60%"> The media type is not set on one or more streams. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT</b></dt> </dl> </td> <td width="60%"> The pipeline should not
    ///    propagate the event. </td> </tr> </table>
    ///    
    HRESULT ProcessEvent(uint dwInputStreamID, IMFMediaEvent pEvent);
    ///Sends a message to the Media Foundation transform (MFT).
    ///Params:
    ///    eMessage = The message to send, specified as a member of the MFT_MESSAGE_TYPE enumeration.
    ///    ulParam = Message parameter. The meaning of this parameter depends on the message type.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> Invalid stream number. Applies to
    ///    the <b>MFT_MESSAGE_NOTIFY_END_OF_STREAM</b> message. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> The media type is not set on one or
    ///    more streams. </td> </tr> </table>
    ///    
    HRESULT ProcessMessage(MFT_MESSAGE_TYPE eMessage, size_t ulParam);
    ///Delivers data to an input stream on this Media Foundation transform (MFT).
    ///Params:
    ///    dwInputStreamID = Input stream identifier. To get the list of stream identifiers, call IMFTransform::GetStreamIDs.
    ///    pSample = Pointer to the IMFSample interface of the input sample. The sample must contain at least one media buffer
    ///              that contains valid input data.
    ///    dwFlags = Reserved. Must be zero.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> Invalid stream
    ///    identifier. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NO_SAMPLE_DURATION</b></dt> </dl> </td> <td
    ///    width="60%"> The input sample requires a valid sample duration. To set the duration, call
    ///    IMFSample::SetSampleDuration. Some MFTs require that input samples have valid durations. Some MFTs do not
    ///    require sample durations. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NO_SAMPLE_TIMESTAMP</b></dt>
    ///    </dl> </td> <td width="60%"> The input sample requires a time stamp. To set the time stamp, call
    ///    IMFSample::SetSampleTime. Some MFTs require that input samples have valid time stamps. Some MFTs do not
    ///    require time stamps. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOTACCEPTING</b></dt> </dl> </td> <td
    ///    width="60%"> The transform cannot process more input at this time. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> The media type is not set on one or
    ///    more streams. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_UNSUPPORTED_D3D_TYPE</b></dt> </dl> </td>
    ///    <td width="60%"> The media type is not supported for DirectX Video Acceleration (DXVA). A DXVA-enabled
    ///    decoder might return this error code. </td> </tr> </table> <div class="alert"><b>Note</b> If you are
    ///    converting a DirectX Media Object (DMO) to an MFT, be aware that <b>S_FALSE</b> is not a valid return code
    ///    for <b>IMFTransform::ProcessInput</b>, unlike the <b>IMediaObject::ProcessInput</b> method.</div> <div>
    ///    </div>
    ///    
    HRESULT ProcessInput(uint dwInputStreamID, IMFSample pSample, uint dwFlags);
    ///Generates output from the current input data.
    ///Params:
    ///    dwFlags = Bitwise <b>OR</b> of zero or more flags from the _MFT_PROCESS_OUTPUT_FLAGS enumeration.
    ///    cOutputBufferCount = Number of elements in the <i>pOutputSamples</i> array. The value must be at least 1.
    ///    pOutputSamples = Pointer to an array of MFT_OUTPUT_DATA_BUFFER structures, allocated by the caller. The MFT uses this array to
    ///                     return output data to the caller.
    ///    pdwStatus = Receives a bitwise <b>OR</b> of zero or more flags from the _MFT_PROCESS_OUTPUT_STATUS enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The ProcessOutput method was called on an
    ///    asynchronous MFT that was not expecting this method call. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> Invalid stream identifier in the
    ///    <b>dwStreamID</b> member of one or more MFT_OUTPUT_DATA_BUFFER structures. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_TRANSFORM_NEED_MORE_INPUT</b></dt> </dl> </td> <td width="60%"> The transform cannot produce
    ///    output data until it receives more input data. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_TRANSFORM_STREAM_CHANGE</b></dt> </dl> </td> <td width="60%"> The format has changed on an output
    ///    stream, or there is a new preferred format, or there is a new output stream. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> You must set the
    ///    media type on one or more streams of the MFT. </td> </tr> </table> <div class="alert"><b>Note</b> If you are
    ///    converting a DirectX Media Object (DMO) to an MFT, be aware that <b>S_FALSE</b> is not a valid return code
    ///    for <b>IMFTransform::ProcessOutput</b>, unlike the <b>IMediaObject::ProcessOutput</b> method.</div> <div>
    ///    </div>
    ///    
    HRESULT ProcessOutput(uint dwFlags, uint cOutputBufferCount, MFT_OUTPUT_DATA_BUFFER* pOutputSamples, 
                          uint* pdwStatus);
}

///Provides playback controls for protected and unprotected content. The Media Session and the protected media path
///(PMP) session objects expose this interface. This interface is the primary interface that applications use to control
///the Media Foundation pipeline. To obtain a pointer to this interface, call MFCreateMediaSession or
///MFCreatePMPMediaSession.
@GUID("90377834-21D0-4DEE-8214-BA2E3E6C1127")
interface IMFMediaSession : IMFMediaEventGenerator
{
    ///Sets a topology on the Media Session.
    ///Params:
    ///    dwSetTopologyFlags = Bitwise <b>OR</b> of zero or more flags from the MFSESSION_SETTOPOLOGY_FLAGS enumeration.
    ///    pTopology = Pointer to the topology object's IMFTopology interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The operation cannot be performed in
    ///    the Media Session's current state. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl>
    ///    </td> <td width="60%"> The Media Session has been shut down. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_TOPO_INVALID_TIME_ATTRIBUTES</b></dt> </dl> </td> <td width="60%"> The topology has invalid
    ///    values for one or more of the following attributes: <ul> <li> MF_TOPONODE_MEDIASTART </li> <li>
    ///    MF_TOPONODE_MEDIASTOP </li> <li> MF_TOPOLOGY_PROJECTSTART </li> <li> MF_TOPOLOGY_PROJECTSTOP </li> </ul>
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>NS_E_DRM_DEBUGGING_NOT_ALLOWED</b></dt> </dl> </td> <td
    ///    width="60%"> Protected content cannot be played while debugging. </td> </tr> </table>
    ///    
    HRESULT SetTopology(uint dwSetTopologyFlags, IMFTopology pTopology);
    ///Clears all of the presentations that are queued for playback in the Media Session.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The operation cannot be performed in
    ///    the Media Session's current state. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl>
    ///    </td> <td width="60%"> The Media Session has been shut down. </td> </tr> </table>
    ///    
    HRESULT ClearTopologies();
    ///Starts the Media Session.
    ///Params:
    ///    pguidTimeFormat = Pointer to a GUID that specifies the time format for the <i>pvarStartPosition</i> parameter. This parameter
    ///                      can be <b>NULL</b>. The value <b>NULL</b> is equivalent to passing in <b>GUID_NULL</b>. The following time
    ///                      format GUIDs are defined: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                      id="GUID_NULL"></a><a id="guid_null"></a><dl> <dt><b>GUID_NULL</b></dt> </dl> </td> <td width="60%">
    ///                      Presentation time. The <i>pvarStartPosition</i> parameter must have one of the following <b>PROPVARIANT</b>
    ///                      types. <ul> <li><b>VT_I8</b>: The <i>pvarStartPosition</i> parameter contains the starting position in
    ///                      100-nanosecond units, relative to the start of the presentation.</li> <li><b>VT_EMPTY</b>: Playback starts
    ///                      from the current position.</li> </ul> All media sources support this time format. </td> </tr> <tr> <td
    ///                      width="40%"><a id="MF_TIME_FORMAT_SEGMENT_OFFSET"></a><a id="mf_time_format_segment_offset"></a><dl>
    ///                      <dt><b>MF_TIME_FORMAT_SEGMENT_OFFSET</b></dt> </dl> </td> <td width="60%"> Segment offset. This time format
    ///                      is supported by the Sequencer Source. The starting time is an offset within a segment. Call the
    ///                      MFCreateSequencerSegmentOffset function to create the <b>PROPVARIANT</b> value for the
    ///                      <i>pvarStartPosition</i> parameter. </td> </tr> <tr> <td width="40%"><a
    ///                      id="MF_TIME_FORMAT_ENTRY_RELATIVE"></a><a id="mf_time_format_entry_relative"></a><dl>
    ///                      <dt><b>MF_TIME_FORMAT_ENTRY_RELATIVE</b></dt> </dl> </td> <td width="60%"> <div class="alert"><b>Note</b>
    ///                      Requires Windows 7 or later.</div> <div> </div> Skip to a playlist entry. The <i>pvarStartPosition</i>
    ///                      parameter specifies the index of the playlist entry, relative to the current entry. For example, the value 2
    ///                      skips forward two entries. To skip backward, pass a negative value. The <b>PROPVARIANT</b> type is
    ///                      <b>VT_I4</b>. If a media source supports this time format, the IMFMediaSource::GetCharacteristics method
    ///                      returns one or both of the following flags: <ul> <li><b>MFMEDIASOURCE_CAN_SKIPFORWARD</b></li>
    ///                      <li><b>MFMEDIASOURCE_CAN_SKIPBACKWARD</b></li> </ul> </td> </tr> </table>
    ///    pvarStartPosition = Pointer to a <b>PROPVARIANT</b> that specifies the starting position for playback. The meaning and data type
    ///                        of this parameter are indicated by the <i>pguidTimeFormat</i> parameter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The operation cannot be performed in
    ///    the Media Session's current state. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl>
    ///    </td> <td width="60%"> The Media Session has been shut down. </td> </tr> </table>
    ///    
    HRESULT Start(const(GUID)* pguidTimeFormat, const(PROPVARIANT)* pvarStartPosition);
    ///Pauses the Media Session.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The operation cannot be performed in
    ///    the Media Session's current state. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl>
    ///    </td> <td width="60%"> The Media Session has been shut down. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_SESSION_PAUSEWHILESTOPPED</b></dt> </dl> </td> <td width="60%"> The Media Session cannot pause
    ///    while stopped. </td> </tr> </table>
    ///    
    HRESULT Pause();
    ///Stops the Media Session.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The operation cannot be performed in
    ///    the Media Session's current state. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl>
    ///    </td> <td width="60%"> The Media Session has been shut down. </td> </tr> </table>
    ///    
    HRESULT Stop();
    ///Closes the Media Session and releases all of the resources it is using.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The Media Session has been shut down. </td>
    ///    </tr> </table>
    ///    
    HRESULT Close();
    ///Shuts down the Media Session and releases all the resources used by the Media Session.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Shutdown();
    ///Retrieves the Media Session's presentation clock.
    ///Params:
    ///    ppClock = Receives a pointer to the presentation clock's IMFClock interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The Media Session does not have a presentation
    ///    clock. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The
    ///    Media Session has been shut down. </td> </tr> </table>
    ///    
    HRESULT GetClock(IMFClock* ppClock);
    ///Retrieves the capabilities of the Media Session, based on the current presentation.
    ///Params:
    ///    pdwCaps = Receives a bitwise <b>OR</b> of zero or more of the following flags. <table> <tr> <th>Value</th>
    ///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MFSESSIONCAP_PAUSE"></a><a
    ///              id="mfsessioncap_pause"></a><dl> <dt><b>MFSESSIONCAP_PAUSE</b></dt> </dl> </td> <td width="60%"> The Media
    ///              Session can be paused. </td> </tr> <tr> <td width="40%"><a id="MFSESSIONCAP_RATE_FORWARD"></a><a
    ///              id="mfsessioncap_rate_forward"></a><dl> <dt><b>MFSESSIONCAP_RATE_FORWARD</b></dt> </dl> </td> <td
    ///              width="60%"> The Media Session supports forward playback at rates faster than 1.0. </td> </tr> <tr> <td
    ///              width="40%"><a id="MFSESSIONCAP_RATE_REVERSE"></a><a id="mfsessioncap_rate_reverse"></a><dl>
    ///              <dt><b>MFSESSIONCAP_RATE_REVERSE</b></dt> </dl> </td> <td width="60%"> The Media Session supports reverse
    ///              playback. </td> </tr> <tr> <td width="40%"><a id="MFSESSIONCAP_SEEK"></a><a id="mfsessioncap_seek"></a><dl>
    ///              <dt><b>MFSESSIONCAP_SEEK</b></dt> </dl> </td> <td width="60%"> The Media Session can be seeked. </td> </tr>
    ///              <tr> <td width="40%"><a id="MFSESSIONCAP_START"></a><a id="mfsessioncap_start"></a><dl>
    ///              <dt><b>MFSESSIONCAP_START</b></dt> </dl> </td> <td width="60%"> The Media Session can be started. </td> </tr>
    ///              </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> NULL pointer argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The Media Session has been shut
    ///    down. </td> </tr> </table>
    ///    
    HRESULT GetSessionCapabilities(uint* pdwCaps);
    ///Gets a topology from the Media Session. This method can get the current topology or a queued topology.
    ///Params:
    ///    dwGetFullTopologyFlags = Bitwise <b>OR</b> of zero or more flags from the MFSESSION_GETFULLTOPOLOGY_FLAGS enumeration.
    ///    TopoId = The identifier of the topology. This parameter is ignored if the <i>dwGetFullTopologyFlags</i> parameter
    ///             contains the <b>MFSESSION_GETFULLTOPOLOGY_CURRENT</b> flag. To get the identifier of a topology, call
    ///             IMFTopology::GetTopologyID.
    ///    ppFullTopology = Receives a pointer to the IMFTopology interface of the topology. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The Media Session has been shut down. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetFullTopology(uint dwGetFullTopologyFlags, ulong TopoId, IMFTopology* ppFullTopology);
}

///Creates a media source from a URL or a byte stream. The Source Resolver implements this interface. To create the
///source resolver, call MFCreateSourceResolver function.
@GUID("FBE5A32D-A497-4B61-BB85-97B1A848A6E3")
interface IMFSourceResolver : IUnknown
{
    ///Creates a media source or a byte stream from a URL. This method is synchronous.
    ///Params:
    ///    pwszURL = Null-terminated string that contains the URL to resolve.
    ///    dwFlags = Bitwise OR of one or more flags. See Source Resolver Flags. See remarks below.
    ///    pProps = Pointer to the <b>IPropertyStore</b> interface of a property store. The method passes the property store to
    ///             the scheme handler or byte-stream handler that creates the object. The handler can use the property store to
    ///             configure the object. This parameter can be <b>NULL</b>. For more information, see Configuring a Media
    ///             Source.
    ///    pObjectType = Receives a member of the MF_OBJECT_TYPE enumeration, specifying the type of object that was created.
    ///    ppObject = Receives a pointer to the object's <b>IUnknown</b> interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>dwFlags</i> parameter contains mutually exclusive flags. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_UNSUPPORTED_SCHEME</b></dt> </dl> </td> <td width="60%"> The URL scheme is not supported. </td>
    ///    </tr> </table>
    ///    
    HRESULT CreateObjectFromURL(const(PWSTR) pwszURL, uint dwFlags, IPropertyStore pProps, 
                                MF_OBJECT_TYPE* pObjectType, IUnknown* ppObject);
    ///Creates a media source from a byte stream. This method is synchronous.
    ///Params:
    ///    pByteStream = Pointer to the byte stream's IMFByteStream interface.
    ///    pwszURL = Null-terminated string that contains the URL of the byte stream. The URL is optional and can be <b>NULL</b>.
    ///              See Remarks for more information.
    ///    dwFlags = Bitwise <b>OR</b> of flags. See Source Resolver Flags.
    ///    pProps = Pointer to the <b>IPropertyStore</b> interface of a property store. The method passes the property store to
    ///             the byte-stream handler. The byte-stream handler can use the property store to configure the media source.
    ///             This parameter can be <b>NULL</b>. For more information, see Configuring a Media Source.
    ///    pObjectType = Receives a member of the MF_OBJECT_TYPE enumeration, specifying the type of object that was created.
    ///    ppObject = Receives a pointer to the media source's <b>IUnknown</b> interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>dwFlags</i> parameter contains mutually exclusive flags. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_UNSUPPORTED_BYTESTREAM_TYPE</b></dt> </dl> </td> <td width="60%"> This byte stream is not
    ///    supported. </td> </tr> </table>
    ///    
    HRESULT CreateObjectFromByteStream(IMFByteStream pByteStream, const(PWSTR) pwszURL, uint dwFlags, 
                                       IPropertyStore pProps, MF_OBJECT_TYPE* pObjectType, IUnknown* ppObject);
    ///Begins an asynchronous request to create a media source or a byte stream from a URL.
    ///Params:
    ///    pwszURL = Null-terminated string that contains the URL to resolve.
    ///    dwFlags = Bitwise OR of flags. See Source Resolver Flags.
    ///    pProps = Pointer to the <b>IPropertyStore</b> interface of a property store. The method passes the property store to
    ///             the scheme handler or byte-stream handler that creates the object. The handler can use the property store to
    ///             configure the object. This parameter can be <b>NULL</b>. For more information, see Configuring a Media
    ///             Source.
    ///    ppIUnknownCancelCookie = Receives an <b>IUnknown</b> pointer or the value <b>NULL</b>. If the value is not <b>NULL</b>, you can cancel
    ///                             the asynchronous operation by passing this pointer to the IMFSourceResolver::CancelObjectCreation method. The
    ///                             caller must release the interface. This parameter can be <b>NULL</b>.
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    punkState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///                <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///                callback is invoked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>dwFlags</i> parameter contains mutually exclusive flags. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_UNSUPPORTED_SCHEME</b></dt> </dl> </td> <td width="60%"> The URL scheme is not supported. </td>
    ///    </tr> </table>
    ///    
    HRESULT BeginCreateObjectFromURL(const(PWSTR) pwszURL, uint dwFlags, IPropertyStore pProps, 
                                     IUnknown* ppIUnknownCancelCookie, IMFAsyncCallback pCallback, 
                                     IUnknown punkState);
    ///Completes an asynchronous request to create an object from a URL.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              Invoke method.
    ///    pObjectType = Receives a member of the MF_OBJECT_TYPE enumeration, specifying the type of object that was created.
    ///    ppObject = Receives a pointer to the media source's <b>IUnknown</b> interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td width="60%"> The operation was canceled. </td> </tr> </table>
    ///    
    HRESULT EndCreateObjectFromURL(IMFAsyncResult pResult, MF_OBJECT_TYPE* pObjectType, IUnknown* ppObject);
    ///Begins an asynchronous request to create a media source from a byte stream.
    ///Params:
    ///    pByteStream = A pointer to the byte stream's IMFByteStream interface.
    ///    pwszURL = A null-terminated string that contains the original URL of the byte stream. This parameter can be
    ///              <b>NULL</b>.
    ///    dwFlags = A bitwise <b>OR</b> of one or more flags. See Source Resolver Flags.
    ///    pProps = A pointer to the <b>IPropertyStore</b> interface of a property store. The method passes the property store to
    ///             the byte-stream handler. The byte-stream handler can use the property store to configure the media source.
    ///             This parameter can be <b>NULL</b>. For more information, see Configuring a Media Source.
    ///    ppIUnknownCancelCookie = Receives an <b>IUnknown</b> pointer or the value <b>NULL</b>. If the value is not <b>NULL</b>, you can cancel
    ///                             the asynchronous operation by passing this pointer to the IMFSourceResolver::CancelObjectCreation method. The
    ///                             caller must release the interface. This parameter can be <b>NULL</b>.
    ///    pCallback = A pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    punkState = A oointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///                <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///                callback is invoked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>dwFlags</i> parameter contains mutually exclusive flags. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_UNSUPPORTED_BYTESTREAM_TYPE</b></dt> </dl> </td> <td width="60%"> The byte stream is not
    ///    supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_BYTESTREAM_NOT_SEEKABLE</b></dt> </dl> </td>
    ///    <td width="60%"> The byte stream does not support seeking. </td> </tr> </table>
    ///    
    HRESULT BeginCreateObjectFromByteStream(IMFByteStream pByteStream, const(PWSTR) pwszURL, uint dwFlags, 
                                            IPropertyStore pProps, IUnknown* ppIUnknownCancelCookie, 
                                            IMFAsyncCallback pCallback, IUnknown punkState);
    ///Completes an asynchronous request to create a media source from a byte stream.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              Invoke method.
    ///    pObjectType = Receives a member of the MF_OBJECT_TYPE enumeration, specifying the type of object that was created.
    ///    ppObject = Receives a pointer to the media source's <b>IUnknown</b> interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td width="60%"> The application canceled the operation. </td> </tr>
    ///    </table>
    ///    
    HRESULT EndCreateObjectFromByteStream(IMFAsyncResult pResult, MF_OBJECT_TYPE* pObjectType, IUnknown* ppObject);
    ///Cancels an asynchronous request to create an object.
    ///Params:
    ///    pIUnknownCancelCookie = Pointer to the <b>IUnknown</b> interface that was returned in the <i>ppIUnknownCancelCookie</i> parameter of
    ///                            the IMFSourceResolver::BeginCreateObjectFromByteStream or IMFSourceResolver::BeginCreateObjectFromURL method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CancelObjectCreation(IUnknown pIUnknownCancelCookie);
}

///Implemented by media source objects. Media sources are objects that generate media data. For example, the data might
///come from a video file, a network stream, or a hardware device, such as a camera. Each media source contains one or
///more streams, and each stream delivers data of one type, such as audio or video.
@GUID("279A808D-AEC7-40C8-9C6B-A6B492C78A66")
interface IMFMediaSource : IMFMediaEventGenerator
{
    ///Retrieves the characteristics of the media source.
    ///Params:
    ///    pdwCharacteristics = Receives a bitwise <b>OR</b> of zero or more flags from the MFMEDIASOURCE_CHARACTERISTICS enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media source's Shutdown method has been
    ///    called. </td> </tr> </table>
    ///    
    HRESULT GetCharacteristics(uint* pdwCharacteristics);
    ///Retrieves a copy of the media source's presentation descriptor. Applications use the presentation descriptor to
    ///select streams and to get information about the source content.
    ///Params:
    ///    ppPresentationDescriptor = Receives a pointer to the presentation descriptor's IMFPresentationDescriptor interface. The caller must
    ///                               release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media source's Shutdown method has been
    ///    called. </td> </tr> </table>
    ///    
    HRESULT CreatePresentationDescriptor(IMFPresentationDescriptor* ppPresentationDescriptor);
    ///Starts, seeks, or restarts the media source by specifying where to start playback.
    ///Params:
    ///    pPresentationDescriptor = Pointer to the IMFPresentationDescriptor interface of the media source's presentation descriptor. To get the
    ///                              presentation descriptor, call IMFMediaSource::CreatePresentationDescriptor. You can modify the presentation
    ///                              descriptor before calling <b>Start</b>, to select or deselect streams or change the media types.
    ///    pguidTimeFormat = Pointer to a GUID that specifies the time format. The time format defines the units for the
    ///                      <i>pvarStartPosition</i> parameter. If the value <i></i> is <b>GUID_NULL</b>, the time format is
    ///                      100-nanosecond units. Some media sources might support additional time format GUIDs. This parameter can be
    ///                      <b>NULL</b>. If the value is <b>NULL</b>, it is equalivent to <b>GUID_NULL</b>.
    ///    pvarStartPosition = Specifies where to start playback. The units of this parameter are indicated by the time format given in
    ///                        <i>pguidTimeFormat</i>. If the time format is <b>GUID_NULL</b>, the variant type must be <b>VT_I8</b> or
    ///                        <b>VT_EMPTY</b>. Use <b>VT_I8</b> to specify a new starting position, in 100-nanosecond units. Use
    ///                        <b>VT_EMPTY</b> to start from the current position. Other time formats might use other <b>PROPVARIANT</b>
    ///                        types.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ASF_OUTOFRANGE</b></dt> </dl> </td> <td width="60%"> The start position is past the end of
    ///    the presentation (ASF media source). </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_HW_MFT_FAILED_START_STREAMING</b></dt> </dl> </td> <td width="60%"> A hardware device was unable
    ///    to start streaming. This error code can be returned by a media source that represents a hardware device, such
    ///    as a camera. For example, if the camera is already being used by another application, the method might return
    ///    this error code. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td
    ///    width="60%"> The start request is not valid. For example, the start position is past the end of the
    ///    presentation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td
    ///    width="60%"> The media source's Shutdown method has been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_UNSUPPORTED_TIME_FORMAT</b></dt> </dl> </td> <td width="60%"> The media source does not support
    ///    the time format specified in <i>pguidTimeFormat</i>. </td> </tr> </table>
    ///    
    HRESULT Start(IMFPresentationDescriptor pPresentationDescriptor, const(GUID)* pguidTimeFormat, 
                  const(PROPVARIANT)* pvarStartPosition);
    ///Stops all active streams in the media source.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media source's Shutdown method has been
    ///    called. </td> </tr> </table>
    ///    
    HRESULT Stop();
    ///Pauses all active streams in the media source.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALID_STATE_TRANSITION</b></dt> </dl> </td> <td width="60%"> Invalid state transition. The
    ///    media source must be in the started state. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media source's Shutdown method has been
    ///    called. </td> </tr> </table>
    ///    
    HRESULT Pause();
    ///Shuts down the media source and releases the resources it is using.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Shutdown();
}

///Extends the IMFMediaSource interface to provide additional capabilities for a media source. To get a pointer to this
///interface, call QueryInterface on the media source.
@GUID("3C9B2EB9-86D5-4514-A394-F56664F9F0D8")
interface IMFMediaSourceEx : IMFMediaSource
{
    ///Gets an attribute store for the media source.
    ///Params:
    ///    ppAttributes = Receives a pointer to the IMFAttributes interface. The caller must release the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The media source does not support
    ///    source-level attributes. </td> </tr> </table>
    ///    
    HRESULT GetSourceAttributes(IMFAttributes* ppAttributes);
    ///Gets an attribute store for a stream on the media source.
    ///Params:
    ///    dwStreamIdentifier = The identifier of the stream. To get the identifier, call IMFStreamDescriptor::GetStreamIdentifier on the
    ///                         stream descriptor.
    ///    ppAttributes = Receives a pointer to the IMFAttributes interface. The caller must release the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The media source does not support
    ///    stream-level attributes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt>
    ///    </dl> </td> <td width="60%"> Invalid stream identifier. </td> </tr> </table>
    ///    
    HRESULT GetStreamAttributes(uint dwStreamIdentifier, IMFAttributes* ppAttributes);
    ///Sets a pointer to the Microsoft DirectX Graphics Infrastructure (DXGI) Device Manager on the media source.
    ///Params:
    ///    pManager = A pointer to the IUnknown interface of the DXGI Manager. The media source should query this pointer for the
    ///               IMFDXGIDeviceManager interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The media source does not support
    ///    source-level attributes. </td> </tr> </table>
    ///    
    HRESULT SetD3DManager(IUnknown pManager);
}

///Implemented by an app in order to get access to the IMFPresentationClock.
@GUID("6EF2A662-47C0-4666-B13D-CBB717F2FA2C")
interface IMFClockConsumer : IUnknown
{
    ///Called by the media pipeline to provide the app with an instance of IMFPresentationClock.
    ///Params:
    ///    pPresentationClock = An instance of IMFPresentationClock.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetPresentationClock(IMFPresentationClock pPresentationClock);
    ///Called by the media pipeline to get an instance of IMFPresentationClock.
    ///Params:
    ///    ppPresentationClock = Pointer to an object that implements the IMFPresentationClock interface. This value can be null.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The app does not implement this method. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetPresentationClock(IMFPresentationClock* ppPresentationClock);
}

///Represents one stream in a media source.
@GUID("D182108F-4EC6-443F-AA42-A71106EC825F")
interface IMFMediaStream : IMFMediaEventGenerator
{
    ///Retrieves a pointer to the media source that created this media stream.
    ///Params:
    ///    ppMediaSource = Receives a pointer to the IMFMediaSource interface of the media source. The caller must release the
    ///                    interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media source's Shutdown method has been
    ///    called. </td> </tr> </table>
    ///    
    HRESULT GetMediaSource(IMFMediaSource* ppMediaSource);
    ///Retrieves a stream descriptor for this media stream.
    ///Params:
    ///    ppStreamDescriptor = Receives a pointer to the IMFStreamDescriptor interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media source's Shutdown method has been
    ///    called. </td> </tr> </table>
    ///    
    HRESULT GetStreamDescriptor(IMFStreamDescriptor* ppStreamDescriptor);
    ///Requests a sample from the media source.
    ///Params:
    ///    pToken = Pointer to the <b>IUnknown</b> interface to an object that is used as a token for the request. The caller
    ///             must implement this object. This parameter can be <b>NULL</b>. See Remarks.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_END_OF_STREAM</b></dt> </dl> </td> <td width="60%"> The end of the stream was reached. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_MEDIA_SOURCE_WRONGSTATE</b></dt> </dl> </td> <td width="60%">
    ///    The media source is stopped. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td>
    ///    <td width="60%"> The source's Shutdown method has been called. </td> </tr> </table>
    ///    
    HRESULT RequestSample(IUnknown pToken);
}

///Implemented by media sink objects. This interface is the base interface for all Media Foundation media sinks. Stream
///sinks handle the actual processing of data on each stream.
@GUID("6EF2A660-47C0-4666-B13D-CBB717F2FA2C")
interface IMFMediaSink : IUnknown
{
    ///Gets the characteristics of the media sink.
    ///Params:
    ///    pdwCharacteristics = Receives a bitwise <b>OR</b> of zero or more flags. The following flags are defined: <table> <tr>
    ///                         <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEDIASINK_FIXED_STREAMS"></a><a
    ///                         id="mediasink_fixed_streams"></a><dl> <dt><b><b>MEDIASINK_FIXED_STREAMS</b></b></dt> <dt>0x00000001</dt>
    ///                         </dl> </td> <td width="60%"> The media sink has a fixed number of streams. It does not support the
    ///                         IMFMediaSink::AddStreamSink and IMFMediaSink::RemoveStreamSink methods. This flag is a hint to the
    ///                         application. </td> </tr> <tr> <td width="40%"><a id="MEDIASINK_CANNOT_MATCH_CLOCK"></a><a
    ///                         id="mediasink_cannot_match_clock"></a><dl> <dt><b><b>MEDIASINK_CANNOT_MATCH_CLOCK</b></b></dt>
    ///                         <dt>0x00000002</dt> </dl> </td> <td width="60%"> The media sink cannot match rates with an external clock.
    ///                         For best results, this media sink should be used as the time source for the presentation clock. If any other
    ///                         time source is used, the media sink cannot match rates with the clock, with poor results (for example,
    ///                         glitching). This flag should be used sparingly, because it limits how the pipeline can be configured. For
    ///                         more information about the presentation clock, see Presentation Clock. </td> </tr> <tr> <td width="40%"><a
    ///                         id="MEDIASINK_RATELESS"></a><a id="mediasink_rateless"></a><dl> <dt><b><b>MEDIASINK_RATELESS</b></b></dt>
    ///                         <dt>0x00000004</dt> </dl> </td> <td width="60%"> The media sink is rateless. It consumes samples as quickly
    ///                         as possible, and does not synchronize itself to a presentation clock. Most archiving sinks are rateless.
    ///                         </td> </tr> <tr> <td width="40%"><a id="MEDIASINK_CLOCK_REQUIRED"></a><a
    ///                         id="mediasink_clock_required"></a><dl> <dt><b><b>MEDIASINK_CLOCK_REQUIRED</b></b></dt> <dt>0x00000008</dt>
    ///                         </dl> </td> <td width="60%"> The media sink requires a presentation clock. The presentation clock is set by
    ///                         calling the media sink's IMFMediaSink::SetPresentationClock method. This flag is obsolete, because all media
    ///                         sinks must support the SetPresentationClock method, even if the media sink ignores the clock (as in a
    ///                         rateless media sink). </td> </tr> <tr> <td width="40%"><a id="MEDIASINK_CAN_PREROLL"></a><a
    ///                         id="mediasink_can_preroll"></a><dl> <dt><b><b>MEDIASINK_CAN_PREROLL</b></b></dt> <dt>0x00000010</dt> </dl>
    ///                         </td> <td width="60%"> The media sink can accept preroll samples before the presentation clock starts. The
    ///                         media sink exposes the IMFMediaSinkPreroll interface. </td> </tr> <tr> <td width="40%"><a
    ///                         id="MEDIASINK_REQUIRE_REFERENCE_MEDIATYPE"></a><a id="mediasink_require_reference_mediatype"></a><dl>
    ///                         <dt><b><b>MEDIASINK_REQUIRE_REFERENCE_MEDIATYPE</b></b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%">
    ///                         The first stream sink (index 0) is a reference stream. The reference stream must have a media type before the
    ///                         media types can be set on the other stream sinks. </td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt> </dl> </td> <td width="60%"> The media sink's Shutdown
    ///    method has been called. </td> </tr> </table>
    ///    
    HRESULT GetCharacteristics(uint* pdwCharacteristics);
    ///Adds a new stream sink to the media sink.
    ///Params:
    ///    dwStreamSinkIdentifier = Identifier for the new stream. The value is arbitrary but must be unique.
    ///    pMediaType = Pointer to the IMFMediaType interface, specifying the media type for the stream. This parameter can be
    ///                 <b>NULL</b>.
    ///    ppStreamSink = Receives a pointer to the new stream sink's IMFStreamSink interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> The specified stream identifier is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%">
    ///    The media sink's Shutdown method has been called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_STREAMSINK_EXISTS</b></dt> </dl> </td> <td width="60%"> There is already a stream sink with the
    ///    same stream identifier. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_STREAMSINKS_FIXED</b></dt> </dl>
    ///    </td> <td width="60%"> This media sink has a fixed set of stream sinks. New stream sinks cannot be added.
    ///    </td> </tr> </table>
    ///    
    HRESULT AddStreamSink(uint dwStreamSinkIdentifier, IMFMediaType pMediaType, IMFStreamSink* ppStreamSink);
    ///Removes a stream sink from the media sink.
    ///Params:
    ///    dwStreamSinkIdentifier = Identifier of the stream to remove. The stream identifier is defined when you call
    ///                             IMFMediaSink::AddStreamSink to add the stream sink.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> This particular stream sink cannot be removed.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%">
    ///    The stream number is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt>
    ///    </dl> </td> <td width="60%"> The media sink has not been initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media sink's Shutdown method has been called.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_STREAMSINKS_FIXED</b></dt> </dl> </td> <td width="60%">
    ///    This media sink has a fixed set of stream sinks. Stream sinks cannot be removed. </td> </tr> </table>
    ///    
    HRESULT RemoveStreamSink(uint dwStreamSinkIdentifier);
    ///Gets the number of stream sinks on this media sink.
    ///Params:
    ///    pcStreamSinkCount = Receives the number of stream sinks.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media sink's Shutdown method has been
    ///    called. </td> </tr> </table>
    ///    
    HRESULT GetStreamSinkCount(uint* pcStreamSinkCount);
    ///Gets a stream sink, specified by index.
    ///Params:
    ///    dwIndex = Zero-based index of the stream. To get the number of streams, call IMFMediaSink::GetStreamSinkCount.
    ///    ppStreamSink = Receives a pointer to the stream's IMFStreamSink interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDINDEX</b></dt> </dl> </td> <td width="60%"> Invalid index. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media sink's Shutdown method
    ///    has been called. </td> </tr> </table>
    ///    
    HRESULT GetStreamSinkByIndex(uint dwIndex, IMFStreamSink* ppStreamSink);
    ///Gets a stream sink, specified by stream identifier.
    ///Params:
    ///    dwStreamSinkIdentifier = Stream identifier of the stream sink.
    ///    ppStreamSink = Receives a pointer to the stream's IMFStreamSink interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> The stream identifier is not
    ///    valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The
    ///    media sink's Shutdown method has been called. </td> </tr> </table>
    ///    
    HRESULT GetStreamSinkById(uint dwStreamSinkIdentifier, IMFStreamSink* ppStreamSink);
    ///Sets the presentation clock on the media sink.
    ///Params:
    ///    pPresentationClock = Pointer to the IMFPresentationClock interface of the presentation clock, or <b>NULL</b>. If the value is
    ///                         <b>NULL</b>, the media sink stops listening to the presentaton clock that was previously set, if any.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_CLOCK_NO_TIME_SOURCE</b></dt> </dl> </td> <td width="60%"> The presentation clock does not
    ///    have a time source. Call SetTimeSource on the presentation clock. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media sink's Shutdown method has been called.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetPresentationClock(IMFPresentationClock pPresentationClock);
    ///Gets the presentation clock that was set on the media sink.
    ///Params:
    ///    ppPresentationClock = Receives a pointer to the presentation clock's IMFPresentationClock interface. The caller must release the
    ///                          interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NO_CLOCK</b></dt> </dl> </td> <td width="60%"> No clock has been set. To set the
    ///    presentation clock, call IMFMediaSink::SetPresentationClock. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media sink's Shutdown method has been called.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetPresentationClock(IMFPresentationClock* ppPresentationClock);
    ///Shuts down the media sink and releases the resources it is using.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media sink was shut down. </td> </tr>
    ///    </table>
    ///    
    HRESULT Shutdown();
}

///Represents a stream on a media sink object.
@GUID("0A97B3CF-8E7C-4A3D-8F8C-0C843DC247FB")
interface IMFStreamSink : IMFMediaEventGenerator
{
    ///Retrieves the media sink that owns this stream sink.
    ///Params:
    ///    ppMediaSink = Receives a pointer to the media sink's IMFMediaSink interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media sink's Shutdown method has been
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_STREAMSINK_REMOVED</b></dt> </dl> </td> <td
    ///    width="60%"> This stream was removed from the media sink and is no longer valid. </td> </tr> </table>
    ///    
    HRESULT GetMediaSink(IMFMediaSink* ppMediaSink);
    ///Retrieves the stream identifier for this stream sink.
    ///Params:
    ///    pdwIdentifier = Receives the stream identifier. If this stream sink was added by calling IMFMediaSink::AddStreamSink, the
    ///                    stream identifier is in the <i>dwStreamSinkIdentifier</i> parameter of that method. Otherwise, the media sink
    ///                    defines the identifier.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media sink's Shutdown method has been
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_STREAMSINK_REMOVED</b></dt> </dl> </td> <td
    ///    width="60%"> This stream was removed from the media sink and is no longer valid. </td> </tr> </table>
    ///    
    HRESULT GetIdentifier(uint* pdwIdentifier);
    ///Retrieves the media type handler for the stream sink. You can use the media type handler to find which formats
    ///the stream supports, and to set the media type on the stream.
    ///Params:
    ///    ppHandler = Receives a pointer to the IMFMediaTypeHandler interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media sink's Shutdown method has been
    ///    called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_STREAMSINK_REMOVED</b></dt> </dl> </td> <td
    ///    width="60%"> This stream was removed from the media sink and is no longer valid. </td> </tr> </table>
    ///    
    HRESULT GetMediaTypeHandler(IMFMediaTypeHandler* ppHandler);
    ///Delivers a sample to the stream. The media sink processes the sample.
    ///Params:
    ///    pSample = Pointer to the IMFSample interface of a sample that contains valid data for the stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALID_STATE_TRANSITION</b></dt> </dl> </td> <td width="60%"> The media sink is in the
    ///    wrong state to receive a sample. For example, preroll is complete but the presenation clock has not started
    ///    yet. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALID_TIMESTAMP</b></dt> </dl> </td> <td
    ///    width="60%"> The sample has an invalid time stamp. See Remarks. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The media sink is paused or stopped and
    ///    cannot process the sample. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NO_CLOCK</b></dt> </dl> </td>
    ///    <td width="60%"> The presentation clock was not set. Call IMFMediaSink::SetPresentationClock. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>MF_E_NO_SAMPLE_TIMESTAMP</b></dt> </dl> </td> <td width="60%"> The sample
    ///    does not have a time stamp. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl>
    ///    </td> <td width="60%"> The stream sink has not been initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media sink's Shutdown method has been called.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_STREAMSINK_REMOVED</b></dt> </dl> </td> <td width="60%">
    ///    This stream was removed from the media sink and is no longer valid. </td> </tr> </table>
    ///    
    HRESULT ProcessSample(IMFSample pSample);
    ///Places a marker in the stream.
    ///Params:
    ///    eMarkerType = Specifies the marker type, as a member of the MFSTREAMSINK_MARKER_TYPE enumeration.
    ///    pvarMarkerValue = Optional pointer to a <b>PROPVARIANT</b> that contains additional information related to the marker. The
    ///                      meaning of this value depends on the marker type. This parameter can be <b>NULL</b>.
    ///    pvarContextValue = Optional pointer to a <b>PROPVARIANT</b> that is attached to the MEStreamSinkMarker event. Call
    ///                       IMFMediaEvent::GetValue to get this value from the event. The caller can use this information for any
    ///                       purpose. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt> </dl> </td> <td width="60%"> The media sink's Shutdown
    ///    method has been called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_STREAMSINK_REMOVED</b></b></dt>
    ///    </dl> </td> <td width="60%"> This stream was removed from the media sink and is no longer valid. </td> </tr>
    ///    </table>
    ///    
    HRESULT PlaceMarker(MFSTREAMSINK_MARKER_TYPE eMarkerType, const(PROPVARIANT)* pvarMarkerValue, 
                        const(PROPVARIANT)* pvarContextValue);
    ///Causes the stream sink to drop any samples that it has received and has not rendered yet.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The stream sink has not been
    ///    initialized yet. You might need to set a media type. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media sink's Shutdown method has been called.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_STREAMSINK_REMOVED</b></dt> </dl> </td> <td width="60%">
    ///    This stream was removed from the media sink and is no longer valid. </td> </tr> </table>
    ///    
    HRESULT Flush();
}

///Allocates video samples for a video media sink. The stream sinks on the enhanced video renderer (EVR) expose this
///interface as a service. To obtain a pointer to the interface, call IMFGetService::GetService using the service
///identifier MR_VIDEO_ACCELERATION_SERVICE. Custom media sinks can also implement this interface. The Media Session
///uses this interface to allocate samples for the EVR, unless the upstream decoder supports DirectX Video Acceleration
///(DXVA).
@GUID("86CBC910-E533-4751-8E3B-F19B5B806A03")
interface IMFVideoSampleAllocator : IUnknown
{
    ///Specifies the Direct3D device manager for the video media sink to use.
    ///Params:
    ///    pManager = Pointer to the <b>IUnknown</b> interface of the Direct3D device manager. The media sink queries this pointer
    ///               for the IDirect3DDeviceManager9 interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetDirectXManager(IUnknown pManager);
    ///Releases all of the video samples that have been allocated.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT UninitializeSampleAllocator();
    ///Specifies the number of samples to allocate and the media type for the samples.
    ///Params:
    ///    cRequestedFrames = Number of samples to allocate.
    ///    pMediaType = Pointer to the IMFMediaType interface of a media type that describes the video format.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> Invalid media type. </td> </tr>
    ///    </table>
    ///    
    HRESULT InitializeSampleAllocator(uint cRequestedFrames, IMFMediaType pMediaType);
    ///Gets a video sample from the allocator.
    ///Params:
    ///    ppSample = Receives a pointer to the IMFSample interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The allocator was not initialized.
    ///    Call IMFVideoSampleAllocator::InitializeSampleAllocator or
    ///    InitializeSampleAllocatorEx::InitializeSampleAllocatorEx. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_SAMPLEALLOCATOR_EMPTY</b></dt> </dl> </td> <td width="60%"> No samples are available. </td> </tr>
    ///    </table>
    ///    
    HRESULT AllocateSample(IMFSample* ppSample);
}

///The callback for the IMFVideoSampleAllocatorCallback interface.
@GUID("A792CDBE-C374-4E89-8335-278E7B9956A4")
interface IMFVideoSampleAllocatorNotify : IUnknown
{
    ///Called when a video sample is returned to the allocator.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT NotifyRelease();
}

///The callback for the IMFVideoSampleAllocatorCallback interface.
@GUID("3978AA1A-6D5B-4B7F-A340-90899189AE34")
interface IMFVideoSampleAllocatorNotifyEx : IMFVideoSampleAllocatorNotify
{
    ///Called when allocator samples are released for pruning by the allocator, or when the allocator is removed.
    ///Params:
    ///    __MIDL__IMFVideoSampleAllocatorNotifyEx0000 = The sample to be pruned.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT NotifyPrune(IMFSample __MIDL__IMFVideoSampleAllocatorNotifyEx0000);
}

///Enables an application to track video samples allocated by the enhanced video renderer (EVR). The stream sinks on the
///EVR expose this interface as a service. To get a pointer to the interface, call the IMFGetService::GetService method,
///using the <b>MR_VIDEO_ACCELERATION_SERVICE</b> service identifier.
@GUID("992388B4-3372-4F67-8B6F-C84C071F4751")
interface IMFVideoSampleAllocatorCallback : IUnknown
{
    ///Sets the callback object that receives notification whenever a video sample is returned to the allocator.
    ///Params:
    ///    pNotify = A pointer to the IMFVideoSampleAllocatorNotify interface that receives notification, or <b>NULL</b> to remove
    ///              the callback.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCallback(IMFVideoSampleAllocatorNotify pNotify);
    ///Gets the number of video samples that are currently available for use.
    ///Params:
    ///    plSamples = Receives the number of available samples.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFreeSampleCount(int* plSamples);
}

///Allocates video samples that contain Microsoft Direct3D 11 texture surfaces.
@GUID("545B3A48-3283-4F62-866F-A62D8F598F9F")
interface IMFVideoSampleAllocatorEx : IMFVideoSampleAllocator
{
    ///Initializes the video sample allocator object.
    ///Params:
    ///    cInitialSamples = The initial number of samples to allocate.
    ///    cMaximumSamples = The maximum number of samples to allocate.
    ///    pAttributes = A pointer to the IMFAttributes interface. You can use this interface to configure the allocator. Currently,
    ///                  the following configuration attributes are defined: <ul> <li> MF_SA_BUFFERS_PER_SAMPLE </li> <li>
    ///                  MF_SA_D3D11_BINDFLAGS </li> <li> MF_SA_D3D11_USAGE </li> <li> MF_SA_D3D11_SHARED </li> <li>
    ///                  MF_SA_D3D11_SHARED_WITHOUT_MUTEX </li> </ul>
    ///    pMediaType = A pointer to the IMFMediaType interface of a media type that describes the video format.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT InitializeSampleAllocatorEx(uint cInitialSamples, uint cMaximumSamples, IMFAttributes pAttributes, 
                                        IMFMediaType pMediaType);
}

///Provides functionality for getting the IMFDXGIDeviceManager from the Microsoft Media Foundation video rendering sink.
@GUID("20BC074B-7A8D-4609-8C3B-64A0A3B5D7CE")
interface IMFDXGIDeviceManagerSource : IUnknown
{
    ///Gets the IMFDXGIDeviceManager from the Microsoft Media Foundation video rendering sink.
    ///Params:
    ///    ppManager = The IMFDXGIDeviceManager object.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetManager(IMFDXGIDeviceManager* ppManager);
}

///Configures the Video Processor MFT.
@GUID("A3F675D5-6119-4F7F-A100-1D8B280F0EFB")
interface IMFVideoProcessorControl : IUnknown
{
    ///Sets the border color.
    ///Params:
    ///    pBorderColor = A pointer to an MFARGB structure that specifies the border color as an ARGB (alpha, red, green, blue) value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetBorderColor(MFARGB* pBorderColor);
    ///Sets the source rectangle. The source rectangle is the portion of the input frame that is blitted to the
    ///destination surface.
    ///Params:
    ///    pSrcRect = A pointer to a RECT structure that specifies the source rectangle.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSourceRectangle(RECT* pSrcRect);
    ///Sets the destination rectangle. The destination rectangle is the portion of the output surface where the source
    ///rectangle is blitted.
    ///Params:
    ///    pDstRect = A pointer to a RECT structure that specifies the destination rectangle.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDestinationRectangle(RECT* pDstRect);
    ///Specifies whether to flip the video image.
    ///Params:
    ///    eMirror = An MF_VIDEO_PROCESSOR_MIRROR value that specifies whether to flip the video image, either horizontally or
    ///              vertically.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetMirror(MF_VIDEO_PROCESSOR_MIRROR eMirror);
    ///Specifies whether to rotate the video to the correct orientation.
    ///Params:
    ///    eRotation = A MF_VIDEO_PROCESSOR_ROTATION value that specifies whether to rotate the image.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetRotation(MF_VIDEO_PROCESSOR_ROTATION eRotation);
    ///Specifies the amount of downsampling to perform on the output.
    ///Params:
    ///    pConstrictionSize = The sampling size. To disable constriction, set this parameter to <b>NULL</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetConstrictionSize(SIZE* pConstrictionSize);
}

///Configures the Video Processor MFT.
@GUID("BDE633D3-E1DC-4A7F-A693-BBAE399C4A20")
interface IMFVideoProcessorControl2 : IMFVideoProcessorControl
{
    ///Overrides the rotation operation that is performed in the video processor.
    ///Params:
    ///    uiRotation = Type: <b>UINT</b> Rotation value in degrees. Typically, you can only use values from the
    ///                 MFVideoRotationFormat enumeration.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetRotationOverride(uint uiRotation);
    ///Enables effects that were implemented with IDirectXVideoProcessor::VideoProcessorBlt.
    ///Params:
    ///    fEnabled = Type: <b>BOOL</b> Specifies whether effects are to be enabled. <b>TRUE</b> specifies to enable effects.
    ///               <b>FALSE</b> specifies to disable effects.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnableHardwareEffects(BOOL fEnabled);
    ///Returns the list of supported effects in the currently configured video processor.
    ///Params:
    ///    puiSupport = Type: <b>UINT*</b> A combination of D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS-typed values that are combined by
    ///                 using a bitwise OR operation. The resulting value specifies the list of suppported effect capabilities.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSupportedHardwareEffects(uint* puiSupport);
}

@GUID("2424B3F2-EB23-40F1-91AA-74BDDEEA0883")
interface IMFVideoProcessorControl3 : IMFVideoProcessorControl2
{
    HRESULT GetNaturalOutputType(IMFMediaType* ppType);
    HRESULT EnableSphericalVideoProcessing(BOOL fEnable, MFVideoSphericalFormat eFormat, 
                                           MFVideoSphericalProjectionMode eProjectionMode);
    HRESULT SetSphericalVideoProperties(float X, float Y, float Z, float W, float fieldOfView);
    HRESULT SetOutputDevice(IUnknown pOutputDevice);
}

@GUID("604D33D7-CF23-41D5-8224-5BBBB1A87475")
interface IMFVideoRendererEffectControl : IUnknown
{
    HRESULT OnAppServiceConnectionEstablished(IUnknown pAppServiceConnection);
}

///Represents a topology. A <i>topology</i> describes a collection of media sources, sinks, and transforms that are
///connected in a certain order. These objects are represented within the topology by <i>topology nodes</i>, which
///expose the IMFTopologyNode interface. A topology describes the path of multimedia data through these nodes. To create
///a topology, call MFCreateTopology.
@GUID("83CF873A-F6DA-4BC8-823F-BACFD55DC433")
interface IMFTopology : IMFAttributes
{
    ///Gets the identifier of the topology.
    ///Params:
    ///    pID = Receives the identifier, as a TOPOID value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTopologyID(ulong* pID);
    ///Adds a node to the topology.
    ///Params:
    ///    pNode = Pointer to the node's IMFTopologyNode interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>pNode</i> is invalid, possibly because the
    ///    node already exists in the topology. </td> </tr> </table>
    ///    
    HRESULT AddNode(IMFTopologyNode pNode);
    ///Removes a node from the topology.
    ///Params:
    ///    pNode = Pointer to the node's IMFTopologyNode interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified node is not a member of this
    ///    topology. </td> </tr> </table>
    ///    
    HRESULT RemoveNode(IMFTopologyNode pNode);
    ///Gets the number of nodes in the topology.
    ///Params:
    ///    pwNodes = Receives the number of nodes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetNodeCount(ushort* pwNodes);
    ///Gets a node in the topology, specified by index.
    ///Params:
    ///    wIndex = The zero-based index of the node. To get the number of nodes in the topology, call IMFTopology::GetNodeCount.
    ///    ppNode = Receives a pointer to the node's IMFTopologyNode interface. The caller must release the pointer.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The index is less than zero. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>MF_E_INVALIDINDEX</b></dt> </dl> </td> <td width="60%"> No node can be found at
    ///    the index <i>wIndex</i>. </td> </tr> </table>
    ///    
    HRESULT GetNode(ushort wIndex, IMFTopologyNode* ppNode);
    ///Removes all nodes from the topology.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Clear();
    ///Converts this topology into a copy of another topology.
    ///Params:
    ///    pTopology = A pointer to the IMFTopology interface of the topology to clone.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CloneFrom(IMFTopology pTopology);
    ///Gets a node in the topology, specified by node identifier.
    ///Params:
    ///    qwTopoNodeID = The identifier of the node to retrieve. To get a node's identifier, call IMFTopologyNode::GetTopoNodeID.
    ///    ppNode = Receives a pointer to the node's IMFTopologyNode interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The topology does not contain a node with
    ///    this identifier. </td> </tr> </table>
    ///    
    HRESULT GetNodeByID(ulong qwTopoNodeID, IMFTopologyNode* ppNode);
    ///Gets the source nodes in the topology.
    ///Params:
    ///    ppCollection = Receives a pointer to the IMFCollection interface. The caller must release the pointer. The collection
    ///                   contains <b>IUnknown</b> pointers to all of the source nodes in the topology. Each pointer can be queried for
    ///                   the IMFTopologyNode interface. The collection might be empty.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSourceNodeCollection(IMFCollection* ppCollection);
    ///Gets the output nodes in the topology.
    ///Params:
    ///    ppCollection = Receives a pointer to the IMFCollection interface. The caller must release the pointer. The collection
    ///                   contains <b>IUnknown</b> pointers to all of the output nodes in the topology. Each pointer can be queried for
    ///                   the IMFTopologyNode interface. The collection might be empty.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetOutputNodeCollection(IMFCollection* ppCollection);
}

///Represents a node in a topology. The following node types are supported: <ul> <li>Output node. Represents a media
///sink. </li> <li>Source node. Represents a media stream. </li> <li>Transform node. Represents a Media Foundation
///Transform (MFT). </li> <li>Tee node. Delivers a media stream to two or more nodes. </li> </ul>To create a new node,
///call the MFCreateTopologyNode function.
@GUID("83CF873A-F6DA-4BC8-823F-BACFD55DC430")
interface IMFTopologyNode : IMFAttributes
{
    ///Sets the object associated with this node.
    ///Params:
    ///    pObject = A pointer to the object's <b>IUnknown</b> interface. Use the value <b>NULL</b> to clear an object that was
    ///              previous set.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetObject(IUnknown pObject);
    HRESULT GetObjectA(IUnknown* ppObject);
    ///Retrieves the node type.
    ///Params:
    ///    pType = Receives the node type, specified as a member of the MF_TOPOLOGY_TYPE enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetNodeType(MF_TOPOLOGY_TYPE* pType);
    ///Retrieves the identifier of the node.
    ///Params:
    ///    pID = Receives the identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTopoNodeID(ulong* pID);
    ///Sets the identifier for the node.
    ///Params:
    ///    ullTopoID = The identifier for the node.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The TOPOID has already been set for this
    ///    object. </td> </tr> </table>
    ///    
    HRESULT SetTopoNodeID(ulong ullTopoID);
    ///Retrieves the number of input streams that currently exist on this node.
    ///Params:
    ///    pcInputs = Receives the number of input streams.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetInputCount(uint* pcInputs);
    ///Retrieves the number of output streams that currently exist on this node.
    ///Params:
    ///    pcOutputs = Receives the number of output streams.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetOutputCount(uint* pcOutputs);
    ///Connects an output stream from this node to the input stream of another node.
    ///Params:
    ///    dwOutputIndex = Zero-based index of the output stream on this node.
    ///    pDownstreamNode = Pointer to the IMFTopologyNode interface of the node to connect to.
    ///    dwInputIndexOnDownstreamNode = Zero-based index of the input stream on the other node.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The method failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid parameter. </td> </tr> </table>
    ///    
    HRESULT ConnectOutput(uint dwOutputIndex, IMFTopologyNode pDownstreamNode, uint dwInputIndexOnDownstreamNode);
    ///Disconnects an output stream on this node.
    ///Params:
    ///    dwOutputIndex = Zero-based index of the output stream to disconnect.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>dwOutputIndex</i> parameter is out of
    ///    range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The
    ///    specified output stream is not connected to another node. </td> </tr> </table>
    ///    
    HRESULT DisconnectOutput(uint dwOutputIndex);
    ///Retrieves the node that is connected to a specified input stream on this node.
    ///Params:
    ///    dwInputIndex = Zero-based index of an input stream on this node.
    ///    ppUpstreamNode = Receives a pointer to the IMFTopologyNode interface of the node that is connected to the specified input
    ///                     stream. The caller must release the interface.
    ///    pdwOutputIndexOnUpstreamNode = Receives the index of the output stream that is connected to this node's input stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The index is out of range. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>MF_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified input stream
    ///    is not connected to another node. </td> </tr> </table>
    ///    
    HRESULT GetInput(uint dwInputIndex, IMFTopologyNode* ppUpstreamNode, uint* pdwOutputIndexOnUpstreamNode);
    ///Retrieves the node that is connected to a specified output stream on this node.
    ///Params:
    ///    dwOutputIndex = Zero-based index of an output stream on this node.
    ///    ppDownstreamNode = Receives a pointer to the IMFTopologyNode interface of the node that is connected to the specified output
    ///                       stream. The caller must release the interface.
    ///    pdwInputIndexOnDownstreamNode = Receives the index of the input stream that is connected to this node's output stream.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The index is out of range. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified input stream is
    ///    not connected to another node. </td> </tr> </table>
    ///    
    HRESULT GetOutput(uint dwOutputIndex, IMFTopologyNode* ppDownstreamNode, uint* pdwInputIndexOnDownstreamNode);
    ///Sets the preferred media type for an output stream on this node.
    ///Params:
    ///    dwOutputIndex = Zero-based index of the output stream.
    ///    pType = Pointer to the IMFMediaType interface of the media type.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This node is an output node. </td> </tr> </table>
    ///    
    HRESULT SetOutputPrefType(uint dwOutputIndex, IMFMediaType pType);
    ///Retrieves the preferred media type for an output stream on this node.
    ///Params:
    ///    dwOutputIndex = Zero-based index of the output stream.
    ///    ppType = Receives a pointer to the IMFMediaType interface of the media type. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> This node does not have a preferred output type.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid
    ///    stream index. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%">
    ///    This node is an output node. </td> </tr> </table>
    ///    
    HRESULT GetOutputPrefType(uint dwOutputIndex, IMFMediaType* ppType);
    ///Sets the preferred media type for an input stream on this node.
    ///Params:
    ///    dwInputIndex = Zero-based index of the input stream.
    ///    pType = Pointer to the IMFMediaType interface of the media type.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This node is a source node. </td> </tr> </table>
    ///    
    HRESULT SetInputPrefType(uint dwInputIndex, IMFMediaType pType);
    ///Retrieves the preferred media type for an input stream on this node.
    ///Params:
    ///    dwInputIndex = Zero-based index of the input stream.
    ///    ppType = Receives a pointer to the IMFMediaType interface of the media type. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> This node does not have a preferred input type.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid
    ///    stream index. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%">
    ///    This node is a source node. </td> </tr> </table>
    ///    
    HRESULT GetInputPrefType(uint dwInputIndex, IMFMediaType* ppType);
    ///Copies the data from another topology node into this node.
    ///Params:
    ///    pNode = A pointer to the IMFTopologyNode interface of the node to copy.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The node types do not match. </td>
    ///    </tr> </table>
    ///    
    HRESULT CloneFrom(IMFTopologyNode pNode);
}

///Queries an object for a specified service interface.
@GUID("FA993888-4383-415A-A930-DD472A8CF6F7")
interface IMFGetService : IUnknown
{
    ///Retrieves a service interface.
    ///Params:
    ///    guidService = The service identifier (SID) of the service. For a list of service identifiers, see Service Interfaces.
    ///    riid = The interface identifier (IID) of the interface being requested.
    ///    ppvObject = Receives the interface pointer. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_UNSUPPORTED_SERVICE</b></dt> </dl> </td> <td width="60%"> The object does not support the
    ///    service. </td> </tr> </table>
    ///    
    HRESULT GetService(const(GUID)* guidService, const(GUID)* riid, void** ppvObject);
}

///Provides timing information from a clock in Microsoft Media Foundation. Clocks and some media sinks expose this
///interface through <b>QueryInterface</b>.
@GUID("2EB1E945-18B8-4139-9B1A-D5D584818530")
interface IMFClock : IUnknown
{
    ///Retrieves the characteristics of the clock.
    ///Params:
    ///    pdwCharacteristics = Receives a bitwise OR of values from the MFCLOCK_CHARACTERISTICS_FLAGS enumeration indicating the
    ///                         characteristics of the clock.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetClockCharacteristics(uint* pdwCharacteristics);
    ///Retrieves the last clock time that was correlated with system time.
    ///Params:
    ///    dwReserved = Reserved, must be zero.
    ///    pllClockTime = Receives the last known clock time, in units of the clock's frequency.
    ///    phnsSystemTime = Receives the system time that corresponds to the clock time returned in <i>pllClockTime</i>, in
    ///                     100-nanosecond units.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_CLOCK_NO_TIME_SOURCE</b></dt> </dl> </td> <td width="60%"> The clock does not have a time
    ///    source. </td> </tr> </table>
    ///    
    HRESULT GetCorrelatedTime(uint dwReserved, long* pllClockTime, long* phnsSystemTime);
    ///Retrieves the clock's continuity key. (Not supported.)
    ///Params:
    ///    pdwContinuityKey = Receives the continuity key.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetContinuityKey(uint* pdwContinuityKey);
    ///Retrieves the current state of the clock.
    ///Params:
    ///    dwReserved = Reserved, must be zero.
    ///    peClockState = Receives the clock state, as a member of the MFCLOCK_STATE enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetState(uint dwReserved, MFCLOCK_STATE* peClockState);
    ///Retrieves the properties of the clock.
    ///Params:
    ///    pClockProperties = Pointer to an MFCLOCK_PROPERTIES structure that receives the properties.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetProperties(MFCLOCK_PROPERTIES* pClockProperties);
}

///Represents a presentation clock, which is used to schedule when samples are rendered and to synchronize multiple
///streams.
@GUID("868CE85C-8EA9-4F55-AB82-B009A910A805")
interface IMFPresentationClock : IMFClock
{
    ///Sets the time source for the presentation clock. The time source is the object that drives the clock by providing
    ///the current time.
    ///Params:
    ///    pTimeSource = Pointer to the IMFPresentationTimeSource interface of the time source.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_CLOCK_NOT_SIMPLE</b></dt> </dl> </td> <td width="60%"> The time source does not have a
    ///    frequency of 10 MHz. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td>
    ///    <td width="60%"> The time source has not been initialized. </td> </tr> </table>
    ///    
    HRESULT SetTimeSource(IMFPresentationTimeSource pTimeSource);
    ///Retrieves the clock's presentation time source.
    ///Params:
    ///    ppTimeSource = Receives a pointer to the time source's IMFPresentationTimeSource interface. The caller must release the
    ///                   interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_CLOCK_NO_TIME_SOURCE</b></dt> </dl> </td> <td width="60%"> No time source was set on this
    ///    clock. </td> </tr> </table>
    ///    
    HRESULT GetTimeSource(IMFPresentationTimeSource* ppTimeSource);
    ///Retrieves the latest clock time.
    ///Params:
    ///    phnsClockTime = Receives the latest clock time, in 100-nanosecond units. The time is relative to when the clock was last
    ///                    started.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_CLOCK_NO_TIME_SOURCE</b></dt> </dl> </td> <td width="60%"> The clock does not have a
    ///    presentation time source. Call IMFPresentationClock::SetTimeSource. </td> </tr> </table>
    ///    
    HRESULT GetTime(long* phnsClockTime);
    ///Registers an object to be notified whenever the clock starts, stops, or pauses, or changes rate.
    ///Params:
    ///    pStateSink = Pointer to the object's IMFClockStateSink interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AddClockStateSink(IMFClockStateSink pStateSink);
    ///Unregisters an object that is receiving state-change notifications from the clock.
    ///Params:
    ///    pStateSink = Pointer to the object's IMFClockStateSink interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RemoveClockStateSink(IMFClockStateSink pStateSink);
    ///Starts the presentation clock.
    ///Params:
    ///    llClockStartOffset = Initial starting time, in 100-nanosecond units. At the time the <b>Start</b> method is called, the clock's
    ///                         IMFPresentationClock::GetTime method returns this value, and the clock time increments from there. If the
    ///                         value is PRESENTATION_CURRENT_POSITION, the clock starts from its current position. Use this value if the
    ///                         clock is paused and you want to restart it from the same position.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_CLOCK_NO_TIME_SOURCE</b></dt> </dl> </td> <td width="60%"> No time source was set on this
    ///    clock. </td> </tr> </table>
    ///    
    HRESULT Start(long llClockStartOffset);
    ///Stops the presentation clock. While the clock is stopped, the clock time does not advance, and the clock's
    ///IMFPresentationClock::GetTime method returns zero.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_CLOCK_NO_TIME_SOURCE</b></dt> </dl> </td> <td width="60%"> No time source was set on this
    ///    clock. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_CLOCK_STATE_ALREADY_SET</b></dt> </dl> </td> <td
    ///    width="60%"> The clock is already stopped. </td> </tr> </table>
    ///    
    HRESULT Stop();
    ///Pauses the presentation clock. While the clock is paused, the clock time does not advance, and the clock's
    ///IMFPresentationClock::GetTime returns the time at which the clock was paused.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_CLOCK_NO_TIME_SOURCE</b></dt> </dl> </td> <td width="60%"> No time source was set on this
    ///    clock. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_CLOCK_STATE_ALREADY_SET</b></dt> </dl> </td> <td
    ///    width="60%"> The clock is already paused. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The clock is stopped. This request is not
    ///    valid when the clock is stopped. </td> </tr> </table>
    ///    
    HRESULT Pause();
}

///Provides the clock times for the presentation clock.
@GUID("7FF12CCE-F76F-41C2-863B-1666C8E5E139")
interface IMFPresentationTimeSource : IMFClock
{
    ///Retrieves the underlying clock that the presentation time source uses to generate its clock times.
    ///Params:
    ///    ppClock = Receives a pointer to the clock's IMFClock interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NO_CLOCK</b></dt> </dl> </td> <td width="60%"> This time source does not expose an
    ///    underlying clock. </td> </tr> </table>
    ///    
    HRESULT GetUnderlyingClock(IMFClock* ppClock);
}

///Receives state-change notifications from the presentation clock.
@GUID("F6696E82-74F7-4F3D-A178-8A5E09C3659F")
interface IMFClockStateSink : IUnknown
{
    ///Called when the presentation clock starts.
    ///Params:
    ///    hnsSystemTime = The system time when the clock started, in 100-nanosecond units.
    ///    llClockStartOffset = The new starting time for the clock, in 100-nanosecond units. This parameter can also equal
    ///                         <b>PRESENTATION_CURRENT_POSITION</b>, indicating the clock has started or restarted from its current
    ///                         position.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnClockStart(long hnsSystemTime, long llClockStartOffset);
    ///Called when the presentation clock stops.
    ///Params:
    ///    hnsSystemTime = The system time when the clock stopped, in 100-nanosecond units.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SINK_ALREADYSTOPPED</b></dt> </dl> </td> <td width="60%"> Deprecated. Do not use this error
    ///    code. </td> </tr> </table>
    ///    
    HRESULT OnClockStop(long hnsSystemTime);
    ///Called when the presentation clock pauses.
    ///Params:
    ///    hnsSystemTime = The system time when the clock was paused, in 100-nanosecond units.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnClockPause(long hnsSystemTime);
    ///Called when the presentation clock restarts from the same position while paused.
    ///Params:
    ///    hnsSystemTime = The system time when the clock restarted, in 100-nanosecond units.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnClockRestart(long hnsSystemTime);
    ///Called when the rate changes on the presentation clock.
    ///Params:
    ///    hnsSystemTime = The system time when the rate was set, in 100-nanosecond units.
    ///    flRate = The new rate, as a multiplier of the normal playback rate.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnClockSetRate(long hnsSystemTime, float flRate);
}

///Describes the details of a presentation. A <i>presentation</i> is a set of related media streams that share a common
///presentation time.
@GUID("03CB2711-24D7-4DB6-A17F-F3A7A479A536")
interface IMFPresentationDescriptor : IMFAttributes
{
    ///Retrieves the number of stream descriptors in the presentation. Each stream descriptor contains information about
    ///one stream in the media source. To retrieve a stream descriptor, call the
    ///IMFPresentationDescriptor::GetStreamDescriptorByIndex method.
    ///Params:
    ///    pdwDescriptorCount = Receives the number of stream descriptors.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamDescriptorCount(uint* pdwDescriptorCount);
    ///Retrieves a stream descriptor for a stream in the presentation. The stream descriptor contains information about
    ///the stream.
    ///Params:
    ///    dwIndex = Zero-based index of the stream. To find the number of streams in the presentation, call the
    ///              IMFPresentationDescriptor::GetStreamDescriptorCount method.
    ///    pfSelected = Receives a Boolean value. The value is <b>TRUE</b> if the stream is currently selected, or <b>FALSE</b> if
    ///                 the stream is currently deselected. If a stream is selected, the media source generates data for that stream
    ///                 when IMFMediaSource::Start is called. The media source will not generated data for deselected streams. To
    ///                 select a stream, call IMFPresentationDescriptor::SelectStream.To deselect a stream, call
    ///                 IMFPresentationDescriptor::DeselectStream.
    ///    ppDescriptor = Receives a pointer to the stream descriptor's IMFStreamDescriptor interface. The caller must release the
    ///                   interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamDescriptorByIndex(uint dwIndex, BOOL* pfSelected, IMFStreamDescriptor* ppDescriptor);
    ///Selects a stream in the presentation.
    ///Params:
    ///    dwDescriptorIndex = The stream number to select, indexed from zero. To find the number of streams in the presentation, call
    ///                        IMFPresentationDescriptor::GetStreamDescriptorCount.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>dwDescriptorIndex</i> is out of range.
    ///    </td> </tr> </table>
    ///    
    HRESULT SelectStream(uint dwDescriptorIndex);
    ///Deselects a stream in the presentation.
    ///Params:
    ///    dwDescriptorIndex = The stream number to deselect, indexed from zero. To find the number of streams in the presentation, call the
    ///                        IMFPresentationDescriptor::GetStreamDescriptorCount method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>dwDescriptorIndex</i> is out of range.
    ///    </td> </tr> </table>
    ///    
    HRESULT DeselectStream(uint dwDescriptorIndex);
    ///Creates a copy of this presentation descriptor.
    ///Params:
    ///    ppPresentationDescriptor = Receives a pointer to the IMFPresentationDescriptor interface of the new presentation descriptor. The caller
    ///                               must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Clone(IMFPresentationDescriptor* ppPresentationDescriptor);
}

///Gets information about one stream in a media source.
@GUID("56C03D9C-9DBB-45F5-AB4B-D80F47C05938")
interface IMFStreamDescriptor : IMFAttributes
{
    ///Retrieves an identifier for the stream.
    ///Params:
    ///    pdwStreamIdentifier = Receives the stream identifier.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamIdentifier(uint* pdwStreamIdentifier);
    ///Retrieves a media type handler for the stream. The media type handler can be used to enumerate supported media
    ///types for the stream, get the current media type, and set the media type.
    ///Params:
    ///    ppMediaTypeHandler = Receives a pointer to the IMFMediaTypeHandler interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMediaTypeHandler(IMFMediaTypeHandler* ppMediaTypeHandler);
}

///Gets and sets media types on an object, such as a media source or media sink.
@GUID("E93DCF6C-4B07-4E1E-8123-AA16ED6EADF5")
interface IMFMediaTypeHandler : IUnknown
{
    ///Queries whether the object supports a specified media type.
    ///Params:
    ///    pMediaType = Pointer to the IMFMediaType interface of the media type to check.
    ///    ppMediaType = Receives a pointer to the IMFMediaType interface of the closest matching media type, or receives the value
    ///                  <b>NULL</b>. If non-<b>NULL</b>, the caller must release the interface. This parameter can be <b>NULL</b>.
    ///                  See Remarks.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> The object does not support this
    ///    media type. </td> </tr> </table>
    ///    
    HRESULT IsMediaTypeSupported(IMFMediaType pMediaType, IMFMediaType* ppMediaType);
    ///Retrieves the number of media types in the object's list of supported media types.
    ///Params:
    ///    pdwTypeCount = Receives the number of media types in the list.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMediaTypeCount(uint* pdwTypeCount);
    ///Retrieves a media type from the object's list of supported media types.
    ///Params:
    ///    dwIndex = Zero-based index of the media type to retrieve. To get the number of media types in the list, call
    ///              IMFMediaTypeHandler::GetMediaTypeCount.
    ///    ppType = Receives a pointer to the IMFMediaType interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NO_MORE_TYPES</b></dt> </dl> </td> <td width="60%"> The <i>dwIndex</i> parameter is out of
    ///    range. </td> </tr> </table>
    ///    
    HRESULT GetMediaTypeByIndex(uint dwIndex, IMFMediaType* ppType);
    ///Sets the object's media type.
    ///Params:
    ///    pMediaType = Pointer to the IMFMediaType interface of the new media type.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> Invalid request. </td> </tr> </table>
    ///    
    HRESULT SetCurrentMediaType(IMFMediaType pMediaType);
    ///Retrieves the current media type of the object.
    ///Params:
    ///    ppMediaType = Receives a pointer to the IMFMediaType interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> No media type is set. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCurrentMediaType(IMFMediaType* ppMediaType);
    ///Gets the major media type of the object.
    ///Params:
    ///    pguidMajorType = Receives a GUID that identifies the major type. For a list of possible values, see Major Media Types.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMajorType(GUID* pguidMajorType);
}

///Provides a timer that invokes a callback at a specified time.
@GUID("E56E4CBD-8F70-49D8-A0F8-EDB3D6AB9BF2")
interface IMFTimer : IUnknown
{
    ///Sets a timer that invokes a callback at the specified time.
    ///Params:
    ///    dwFlags = Bitwise OR of zero or more flags from the MFTIMER_FLAGS enumeration.
    ///    llClockTime = The time at which the timer should fire, in units of the clock's frequency. The time is either absolute or
    ///                  relative to the current time, depending on the value of <i>dwFlags</i>.
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface. The
    ///                callback's Invoke method is called at the time specified in the <i>llClockTime</i> parameter.
    ///    punkState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///                <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///                callback is invoked.
    ///    ppunkKey = Receives a pointer to the <b>IUnknown</b> interface of a cancellation object. The caller must release the
    ///               interface. To cancel the timer, pass this pointer to the IMFTimer::CancelTimer method. This parameter can be
    ///               <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The clock was shut down. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_S_CLOCK_STOPPED</b></dt> </dl> </td> <td width="60%"> The method succeeded, but
    ///    the clock is stopped. </td> </tr> </table>
    ///    
    HRESULT SetTimer(uint dwFlags, long llClockTime, IMFAsyncCallback pCallback, IUnknown punkState, 
                     IUnknown* ppunkKey);
    ///Cancels a timer that was set using the IMFTimer::SetTimer method.
    ///Params:
    ///    punkKey = Pointer to the <b>IUnknown</b> interface that was returned in the <i>ppunkKey</i> parameter of the SetTimer
    ///              method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CancelTimer(IUnknown punkKey);
}

///Exposed by some Media Foundation objects that must be explicitly shut down.
@GUID("97EC2EA4-0E42-4937-97AC-9D6D328824E1")
interface IMFShutdown : IUnknown
{
    ///Shuts down a Media Foundation object and releases all resources associated with the object.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Shutdown();
    ///Queries the status of an earlier call to the IMFShutdown::Shutdown method.
    ///Params:
    ///    pStatus = Receives a member of the MFSHUTDOWN_STATUS enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The Shutdown method has
    ///    not been called on this object. </td> </tr> </table>
    ///    
    HRESULT GetShutdownStatus(MFSHUTDOWN_STATUS* pStatus);
}

///Converts a partial topology into a full topology. The topology loader exposes this interface.
@GUID("DE9A6157-F660-4643-B56A-DF9F7998C7CD")
interface IMFTopoLoader : IUnknown
{
    ///Creates a fully loaded topology from the input partial topology.
    ///Params:
    ///    pInputTopo = A pointer to the IMFTopology interface of the partial topology to be resolved.
    ///    ppOutputTopo = Receives a pointer to the IMFTopology interface of the completed topology. The caller must release the
    ///                   interface.
    ///    pCurrentTopo = A pointer to the IMFTopology interface of the previous full topology. The topology loader can re-use objects
    ///                   from this topology in the new topology. This parameter can be <b>NULL</b>. See Remarks.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> One or more output
    ///    nodes contain IMFActivate pointers. The caller must bind the output nodes to media sinks. See Binding Output
    ///    Nodes to Media Sinks. </td> </tr> </table>
    ///    
    HRESULT Load(IMFTopology pInputTopo, IMFTopology* ppOutputTopo, IMFTopology pCurrentTopo);
}

///Enables playback of protected content by providing the application with a pointer to a content enabler object.
///Applications that play protected content should implement this interface.
@GUID("ACF92459-6A61-42BD-B57C-B43E51203CB0")
interface IMFContentProtectionManager : IUnknown
{
    ///Begins an asynchronous request to perform a content enabling action. This method requests the application to
    ///perform a specific step needed to acquire rights to the content, using a content enabler object.
    ///Params:
    ///    pEnablerActivate = Pointer to the IMFActivate interface of a content enabler object. To create the content enabler, call
    ///                       IMFActivate::ActivateObject and request the IMFContentEnabler interface. The application should use the
    ///                       methods in <b>IMFContentEnabler</b> to complete the content enabling action.
    ///    pTopo = Pointer to the IMFTopology interface of the pending topology.
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object. When the operation is complete, the
    ///                application should call IMFAsyncCallback::Invoke on the callback.
    ///    punkState = Reserved. Currently this parameter is always <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT BeginEnableContent(IMFActivate pEnablerActivate, IMFTopology pTopo, IMFAsyncCallback pCallback, 
                               IUnknown punkState);
    ///Ends an asynchronous request to perform a content enabling action. This method is called by the protected media
    ///path (PMP) to complete an asynchronous call to IMFContentProtectionManager::BeginEnableContent.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. This pointer is the same value that the application passed to the
    ///              caller's IMFAsyncCallback::Invoke method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT EndEnableContent(IMFAsyncResult pResult);
}

///Implements one step that must be performed for the user to access media content. For example, the steps might be
///individualization followed by license acquisition. Each of these steps would be encapsulated by a content enabler
///object that exposes the <b>IMFContentEnabler</b> interface.
@GUID("D3C4EF59-49CE-4381-9071-D5BCD044C770")
interface IMFContentEnabler : IUnknown
{
    ///Retrieves the type of operation that this content enabler performs.
    ///Params:
    ///    pType = Receives a GUID that identifies the type of operation. An application can tailor its user interface (UI)
    ///            strings for known operation types. See Remarks.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEnableType(GUID* pType);
    ///Retrieves a URL for performing a manual content enabling action.
    ///Params:
    ///    ppwszURL = Receives a pointer to a buffer that contains the URL. The caller must release the memory for the buffer by
    ///               calling CoTaskMemFree.
    ///    pcchURL = Receives the number of characters returned in <i>ppwszURL</i>, including the terminating NULL character.
    ///    pTrustStatus = Receives a member of the MF_URL_TRUST_STATUS enumeration indicating whether the URL is trusted.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_NOT_AVAILABLE</b></dt> </dl> </td> <td width="60%"> No URL is available. </td> </tr> </table>
    ///    
    HRESULT GetEnableURL(PWSTR* ppwszURL, uint* pcchURL, MF_URL_TRUST_STATUS* pTrustStatus);
    ///Retrieves the data for a manual content enabling action.
    ///Params:
    ///    ppbData = Receives a pointer to a buffer that contains the data. The caller must free the buffer by calling
    ///              CoTaskMemFree.
    ///    pcbData = Receives the size of the <i>ppbData</i> buffer.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_NOT_AVAILABLE</b></dt> </dl> </td> <td width="60%"> No data is available. </td> </tr> </table>
    ///    
    HRESULT GetEnableData(ubyte** ppbData, uint* pcbData);
    ///Queries whether the content enabler can perform all of its actions automatically.
    ///Params:
    ///    pfAutomatic = Receives a Boolean value. If <b>TRUE</b>, the content enabler can perform the enabing action automatically.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT IsAutomaticSupported(BOOL* pfAutomatic);
    ///Performs a content enabling action without any user interaction.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AutomaticEnable();
    ///Requests notification when the enabling action is completed.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The method succeeded and no action was required.
    ///    </td> </tr> </table>
    ///    
    HRESULT MonitorEnable();
    ///Cancels a pending content enabling action.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Cancel();
}

///Manages metadata for an object. Metadata is information that describes a media file, stream, or other content.
///Metadata consists of individual properties, where each property contains a descriptive name and a value. A property
///may be associated with a particular language. To get this interface from a media source, use the IMFMetadataProvider
///interface.
@GUID("F88CFB8C-EF16-4991-B450-CB8C69E51704")
interface IMFMetadata : IUnknown
{
    ///Sets the language for setting and retrieving metadata.
    ///Params:
    ///    pwszRFC1766 = Pointer to a null-terminated string containing an RFC 1766-compliant language tag.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetLanguage(const(PWSTR) pwszRFC1766);
    ///Gets the current language setting.
    ///Params:
    ///    ppwszRFC1766 = Receives a pointer to a null-terminated string containing an RFC 1766-compliant language tag. The caller must
    ///                   release the string by calling CoTaskMemFree.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The metadata provider does not support multiple
    ///    languages. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td
    ///    width="60%"> No language was set. </td> </tr> </table>
    ///    
    HRESULT GetLanguage(PWSTR* ppwszRFC1766);
    ///Gets a list of the languages in which metadata is available.
    ///Params:
    ///    ppvLanguages = A pointer to a <b>PROPVARIANT</b> that receives the list of languages. The list is returned as an array of
    ///                   null-terminated wide-character strings. Each string in the array is an RFC 1766-compliant language tag. The
    ///                   returned <b>PROPVARIANT</b> type is VT_VECTOR | VT_LPWSTR. The list might be empty, if no language tags are
    ///                   present. The caller must free the <b>PROPVARIANT</b> by calling PropVariantClear.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAllLanguages(PROPVARIANT* ppvLanguages);
    ///Sets the value of a metadata property.
    ///Params:
    ///    pwszName = Pointer to a null-terminated string containing the name of the property.
    ///    ppvValue = Pointer to a <b>PROPVARIANT</b> that contains the value of the property. For multivalued properties, use a
    ///               <b>PROPVARIANT</b> with a VT_VECTOR type.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetProperty(const(PWSTR) pwszName, const(PROPVARIANT)* ppvValue);
    ///Gets the value of a metadata property.
    ///Params:
    ///    pwszName = A pointer to a null-terminated string that containings the name of the property. To get the list of property
    ///               names, call IMFMetadata::GetAllPropertyNames.
    ///    ppvValue = Pointer to a <b>PROPVARIANT</b> that receives the value of the property. The <b>PROPVARIANT</b> type depends
    ///               on the property. For multivalued properties, the <b>PROPVARIANT</b> is a <b>VT_VECTOR</b> type. The caller
    ///               must free the <b>PROPVARIANT</b> by calling PropVariantClear.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_PROPERTY_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The requested property was not
    ///    found. </td> </tr> </table>
    ///    
    HRESULT GetProperty(const(PWSTR) pwszName, PROPVARIANT* ppvValue);
    ///Deletes a metadata property.
    ///Params:
    ///    pwszName = Pointer to a null-terminated string containing the name of the property.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_PROPERTY_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The property was not found. </td>
    ///    </tr> </table>
    ///    
    HRESULT DeleteProperty(const(PWSTR) pwszName);
    ///Gets a list of all the metadata property names on this object.
    ///Params:
    ///    ppvNames = Pointer to a <b>PROPVARIANT</b> that receives an array of null-terminated wide-character strings. If no
    ///               properties are available, the <b>PROPVARIANT</b> type is VT_EMPTY. Otherwise, the <b>PROPVARIANT</b> type is
    ///               VT_VECTOR | VT_LPWSTR. The caller must free the <b>PROPVARIANT</b> by calling PropVariantClear.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAllPropertyNames(PROPVARIANT* ppvNames);
}

///Gets metadata from a media source or other object. If a media source supports this interface, it must expose the
///interface as a service. To get a pointer to this interface from a media source, call IMFGetService::GetService. The
///service identifier is <b>MF_METADATA_PROVIDER_SERVICE</b>. Other types of object can expose this interface through
///<b>QueryInterface</b>. Use this interface to get a pointer to the IMFMetadata interface.
@GUID("56181D2D-E221-4ADB-B1C8-3CEE6A53F76F")
interface IMFMetadataProvider : IUnknown
{
    ///Gets a collection of metadata, either for an entire presentation, or for one stream in the presentation.
    ///Params:
    ///    pPresentationDescriptor = Pointer to the IMFPresentationDescriptor interface of the media source's presentation descriptor.
    ///    dwStreamIdentifier = If this parameter is zero, the method retrieves metadata that applies to the entire presentation. Otherwise,
    ///                         this <i></i> parameter specifies a stream identifier, and the method retrieves metadata for that stream. To
    ///                         get the stream identifier for a stream, call IMFStreamDescriptor::GetStreamIdentifier.
    ///    dwFlags = Reserved. Must be zero.
    ///    ppMFMetadata = Receives a pointer to the IMFMetadata interface. Use this interface to access the metadata. The caller must
    ///                   release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_PROPERTY_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> No metadata is available for the
    ///    requested stream or presentation. </td> </tr> </table>
    ///    
    HRESULT GetMFMetadata(IMFPresentationDescriptor pPresentationDescriptor, uint dwStreamIdentifier, uint dwFlags, 
                          IMFMetadata* ppMFMetadata);
}

///Queries the range of playback rates that are supported, including reverse playback. To get a pointer to this
///interface, call IMFGetService::GetService with the service identifier MF_RATE_CONTROL_SERVICE.
@GUID("0A9CCDBC-D797-4563-9667-94EC5D79292D")
interface IMFRateSupport : IUnknown
{
    ///Retrieves the slowest playback rate supported by the object.
    ///Params:
    ///    eDirection = Specifies whether to query to the slowest forward playback rate or reverse playback rate. The value is a
    ///                 member of the MFRATE_DIRECTION enumeration.
    ///    fThin = If <b>TRUE</b>, the method retrieves the slowest thinned playback rate. Otherwise, the method retrieves the
    ///            slowest non-thinned playback rate. For information about thinning, see About Rate Control.
    ///    pflRate = Receives the slowest playback rate that the object supports.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_REVERSE_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> The object does not support
    ///    reverse playback. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_THINNING_UNSUPPORTED</b></dt> </dl>
    ///    </td> <td width="60%"> The object does not support thinning. </td> </tr> </table>
    ///    
    HRESULT GetSlowestRate(MFRATE_DIRECTION eDirection, BOOL fThin, float* pflRate);
    ///Gets the fastest playback rate supported by the object.
    ///Params:
    ///    eDirection = Specifies whether to query to the fastest forward playback rate or reverse playback rate. The value is a
    ///                 member of the MFRATE_DIRECTION enumeration.
    ///    fThin = If <b>TRUE</b>, the method retrieves the fastest thinned playback rate. Otherwise, the method retrieves the
    ///            fastest non-thinned playback rate. For information about thinning, see About Rate Control.
    ///    pflRate = Receives the fastest playback rate that the object supports.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_REVERSE_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> The object does not support
    ///    reverse playback. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_THINNING_UNSUPPORTED</b></dt> </dl>
    ///    </td> <td width="60%"> The object does not support thinning. </td> </tr> </table>
    ///    
    HRESULT GetFastestRate(MFRATE_DIRECTION eDirection, BOOL fThin, float* pflRate);
    ///Queries whether the object supports a specified playback rate.
    ///Params:
    ///    fThin = If <b>TRUE</b>, the method queries whether the object supports the playback rate with thinning. Otherwise,
    ///            the method queries whether the object supports the playback rate without thinning. For information about
    ///            thinning, see About Rate Control.
    ///    flRate = The playback rate to query.
    ///    pflNearestSupportedRate = If the object does not support the playback rate given in <i>flRate</i>, this parameter receives the closest
    ///                              supported playback rate. If the method returns S_OK, this parameter receives the value given in
    ///                              <i>flRate</i>. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The object supports the specified rate. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>MF_E_REVERSE_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> The object does
    ///    not support reverse playback. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_THINNING_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> The object does not support thinning.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_UNSUPPORTED_RATE</b></dt> </dl> </td> <td width="60%"> The
    ///    object does not support the specified rate. </td> </tr> </table>
    ///    
    HRESULT IsRateSupported(BOOL fThin, float flRate, float* pflNearestSupportedRate);
}

///Gets or sets the playback rate.
@GUID("88DDCD21-03C3-4275-91ED-55EE3929328F")
interface IMFRateControl : IUnknown
{
    ///Sets the playback rate.
    ///Params:
    ///    fThin = If <b>TRUE</b>, the media streams are thinned. Otherwise, the stream is not thinned. For media sources and
    ///            demultiplexers, the object must thin the streams when this parameter is <b>TRUE</b>. For downstream
    ///            transforms, such as decoders and multiplexers, this parameter is informative; it notifies the object that the
    ///            input streams are thinned. For information, see About Rate Control.
    ///    flRate = The requested playback rate. Postive values indicate forward playback, negative values indicate reverse
    ///             playback, and zero indicates scrubbing (the source delivers a single frame).
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_REVERSE_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> The object does not support
    ///    reverse playback. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_THINNING_UNSUPPORTED</b></dt> </dl>
    ///    </td> <td width="60%"> The object does not support thinning. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_UNSUPPORTED_RATE</b></dt> </dl> </td> <td width="60%"> The object does not support the requested
    ///    playback rate. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_UNSUPPORTED_RATE_TRANSITION</b></dt> </dl>
    ///    </td> <td width="60%"> The object cannot change to the new rate while in the running state. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetRate(BOOL fThin, float flRate);
    ///Gets the current playback rate.
    ///Params:
    ///    pfThin = Receives the value <b>TRUE</b> if the stream is currently being thinned. If the object does not support
    ///             thinning, this parameter always receives the value <b>FALSE</b>. This parameter can be <b>NULL</b>. For more
    ///             information, see About Rate Control.
    ///    pflRate = Receives the current playback rate.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRate(BOOL* pfThin, float* pflRate);
}

///Converts between Society of Motion Picture and Television Engineers (SMPTE) time codes and 100-nanosecond time units.
@GUID("AB9D8661-F7E8-4EF4-9861-89F334F94E74")
interface IMFTimecodeTranslate : IUnknown
{
    ///Starts an asynchronous call to convert Society of Motion Picture and Television Engineers (SMPTE) time code to
    ///100-nanosecond units.
    ///Params:
    ///    pPropVarTimecode = Time in SMPTE time code to convert. The <b>vt</b> member of the <b>PROPVARIANT</b> structure is set to
    ///                       <b>VT_I8</b>. The <b>hVal.QuadPart</b> member contains the time in binary coded decimal (BCD) form. See
    ///                       Remarks.
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    punkState = PPointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///                <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///                callback is invoked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>pPropVarTimecode</i> is not <b>VT_I8</b>. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The object's
    ///    <b>Shutdown</b> method was called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_BYTESTREAM_NOT_SEEKABLE</b></dt> </dl> </td> <td width="60%"> The byte stream is not seekable.
    ///    The time code cannot be read from the end of the byte stream. </td> </tr> </table>
    ///    
    HRESULT BeginConvertTimecodeToHNS(const(PROPVARIANT)* pPropVarTimecode, IMFAsyncCallback pCallback, 
                                      IUnknown punkState);
    ///Completes an asynchronous request to convert time in Society of Motion Picture and Television Engineers (SMPTE)
    ///time code to 100-nanosecond units.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              IMFAsyncCallback::Invoke method.
    ///    phnsTime = Receives the converted time.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EndConvertTimecodeToHNS(IMFAsyncResult pResult, long* phnsTime);
    ///Starts an asynchronous call to convert time in 100-nanosecond units to Society of Motion Picture and Television
    ///Engineers (SMPTE) time code.
    ///Params:
    ///    hnsTime = The time to convert, in 100-nanosecond units.
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    punkState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///                <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///                callback is invoked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The object's <b>Shutdown</b> method was called.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_BYTESTREAM_NOT_SEEKABLE</b></dt> </dl> </td> <td
    ///    width="60%"> The byte stream is not seekable. The time code cannot be read from the end of the byte stream.
    ///    </td> </tr> </table>
    ///    
    HRESULT BeginConvertHNSToTimecode(long hnsTime, IMFAsyncCallback pCallback, IUnknown punkState);
    ///Completes an asynchronous request to convert time in 100-nanosecond units to Society of Motion Picture and
    ///Television Engineers (SMPTE) time code.
    ///Params:
    ///    pResult = A pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              IMFAsyncCallback::Invoke method.
    ///    pPropVarTimecode = A pointer to a <b>PROPVARIANT</b> that receives the converted time. The <b>vt</b> member of the
    ///                       <b>PROPVARIANT</b> structure is set to VT_I8. The <b>hVal.QuadPart</b> member contains the converted time in
    ///                       binary coded decimal (BCD) form. See Remarks.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EndConvertHNSToTimecode(IMFAsyncResult pResult, PROPVARIANT* pPropVarTimecode);
}

///For a particular seek position, gets the two nearest key frames.
@GUID("26AFEA53-D9ED-42B5-AB80-E64F9EE34779")
interface IMFSeekInfo : IUnknown
{
    ///For a particular seek position, gets the two nearest key frames.
    ///Params:
    ///    pguidTimeFormat = A pointer to a GUID that specifies the time format. The time format defines the units for the other
    ///                      parameters of this method. If the value is <b>GUID_NULL</b>, the time format is 100-nanosecond units. Some
    ///                      media sources might support additional time format GUIDs.
    ///    pvarStartPosition = The seek position. The units for this parameter are specified by <i>pguidTimeFormat</i>.
    ///    pvarPreviousKeyFrame = Receives the position of the nearest key frame that appears earlier than <i>pvarStartPosition</i>. The units
    ///                           for this parameter are specified by <i>pguidTimeFormat</i>.
    ///    pvarNextKeyFrame = Receives the position of the nearest key frame that appears later than <i>pvarStartPosition</i>. The units
    ///                       for this parameter are specified by <i>pguidTimeFormat</i>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>MF_E_UNSUPPORTED_TIME_FORMAT</b></dt> </dl> </td> <td width="60%"> The time
    ///    format specified in <i>pguidTimeFormat</i> is not supported. </td> </tr> </table>
    ///    
    HRESULT GetNearestKeyFrames(const(GUID)* pguidTimeFormat, const(PROPVARIANT)* pvarStartPosition, 
                                PROPVARIANT* pvarPreviousKeyFrame, PROPVARIANT* pvarNextKeyFrame);
}

///Controls the master volume level of the audio session associated with the streaming audio renderer (SAR) and the
///audio capture source. The SAR and the audio capture source expose this interface as a service. To get a pointer to
///the interface, call IMFGetService::GetService. For the SAR, use the service identifier MR_POLICY_VOLUME_SERVICE. For
///the audio capture source, use the service identifier MR_CAPTURE_POLICY_VOLUME_SERVICE. You can call <b>GetService</b>
///directly on the SAR or the audio capture source, or call it on the Media Session.
@GUID("089EDF13-CF71-4338-8D13-9E569DBDC319")
interface IMFSimpleAudioVolume : IUnknown
{
    ///Sets the master volume level.
    ///Params:
    ///    fLevel = Volume level. Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0 indicates full
    ///             volume (no attenuation).
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The audio renderer is not initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_STREAMSINK_REMOVED</b></dt> </dl> </td> <td width="60%">
    ///    The audio renderer was removed from the pipeline. </td> </tr> </table>
    ///    
    HRESULT SetMasterVolume(float fLevel);
    ///Retrieves the master volume level.
    ///Params:
    ///    pfLevel = Receives the volume level. Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0
    ///              indicates full volume (no attenuation).
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The audio renderer is not initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_STREAMSINK_REMOVED</b></dt> </dl> </td> <td width="60%">
    ///    The audio renderer was removed from the pipeline. </td> </tr> </table>
    ///    
    HRESULT GetMasterVolume(float* pfLevel);
    ///Mutes or unmutes the audio.
    ///Params:
    ///    bMute = Specify <b>TRUE</b> to mute the audio, or <b>FALSE</b> to unmute the audio.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The audio renderer is not initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_STREAMSINK_REMOVED</b></dt> </dl> </td> <td width="60%">
    ///    The audio renderer was removed from the pipeline. </td> </tr> </table>
    ///    
    HRESULT SetMute(const(BOOL) bMute);
    ///Queries whether the audio is muted.
    ///Params:
    ///    pbMute = Receives a Boolean value. If <b>TRUE</b>, the audio is muted; otherwise, the audio is not muted.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The audio renderer is not initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_STREAMSINK_REMOVED</b></dt> </dl> </td> <td width="60%">
    ///    The audio renderer was removed from the pipeline. </td> </tr> </table>
    ///    
    HRESULT GetMute(BOOL* pbMute);
}

///Controls the volume levels of individual audio channels. The streaming audio renderer (SAR) exposes this interface as
///a service. To get a pointer to the interface, call IMFGetService::GetService with the service identifier
///<b>MR_STREAM_VOLUME_SERVICE</b>. You can call <b>GetService</b> directly on the SAR or call it on the Media Session.
@GUID("76B1BBDB-4EC8-4F36-B106-70A9316DF593")
interface IMFAudioStreamVolume : IUnknown
{
    ///Retrieves the number of channels in the audio stream.
    ///Params:
    ///    pdwCount = Receives the number of channels in the audio stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetChannelCount(uint* pdwCount);
    ///Sets the volume level for a specified channel in the audio stream.
    ///Params:
    ///    dwIndex = Zero-based index of the audio channel. To get the number of channels, call
    ///              IMFAudioStreamVolume::GetChannelCount.
    ///    fLevel = Volume level for the channel.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetChannelVolume(uint dwIndex, const(float) fLevel);
    ///Retrieves the volume level for a specified channel in the audio stream.
    ///Params:
    ///    dwIndex = Zero-based index of the audio channel. To get the number of channels, call
    ///              IMFAudioStreamVolume::GetChannelCount.
    ///    pfLevel = Receives the volume level for the channel.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetChannelVolume(uint dwIndex, float* pfLevel);
    ///Sets the individual volume levels for all of the channels in the audio stream.
    ///Params:
    ///    dwCount = Number of elements in the <i>pfVolumes</i> array. The value must equal the number of channels. To get the
    ///              number of channels, call IMFAudioStreamVolume::GetChannelCount.
    ///    pfVolumes = Address of an array of size <i>dwCount</i>, allocated by the caller. The array specifies the volume levels
    ///                for all of the channels. Before calling the method, set each element of the array to the desired volume level
    ///                for the channel.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetAllVolumes(uint dwCount, const(float)* pfVolumes);
    ///Retrieves the volume levels for all of the channels in the audio stream.
    ///Params:
    ///    dwCount = Number of elements in the <i>pfVolumes</i> array. The value must equal the number of channels. To get the
    ///              number of channels, call IMFAudioStreamVolume::GetChannelCount.
    ///    pfVolumes = Address of an array of size <i>dwCount</i>, allocated by the caller. The method fills the array with the
    ///                volume level for each channel in the stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetAllVolumes(uint dwCount, float* pfVolumes);
}

///Configures the audio session that is associated with the streaming audio renderer (SAR). Use this interface to change
///how the audio session appears in the Windows volume control. The SAR exposes this interface as a service. To get a
///pointer to the interface, call IMFGetService::GetService with the service identifier MR_AUDIO_POLICY_SERVICE. You can
///call <b>GetService</b> directly on the SAR or call it on the Media Session.
@GUID("A0638C2B-6465-4395-9AE7-A321A9FD2856")
interface IMFAudioPolicy : IUnknown
{
    ///Assigns the audio session to a group of sessions.
    ///Params:
    ///    rguidClass = A <b>GUID</b> that identifies the session group. Groups are application-defined. To create a new session
    ///                 group, assign a new GUID.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetGroupingParam(const(GUID)* rguidClass);
    ///Retrieves the group of sessions to which this audio session belongs.
    ///Params:
    ///    pguidClass = Receives a GUID that identifies the session group.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetGroupingParam(GUID* pguidClass);
    ///Sets the display name of the audio session. The Windows volume control displays this name.
    ///Params:
    ///    pszName = A null-terminated wide-character string that contains the display name.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetDisplayName(const(PWSTR) pszName);
    ///Retrieves the display name of the audio session. The Windows volume control displays this name.
    ///Params:
    ///    pszName = Receives a pointer to the display name string. The caller must free the memory allocated for the string by
    ///              calling CoTaskMemFree.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetDisplayName(PWSTR* pszName);
    ///Sets the icon resource for the audio session. The Windows volume control displays this icon.
    ///Params:
    ///    pszPath = A wide-character string that specifies the icon. See Remarks.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetIconPath(const(PWSTR) pszPath);
    ///Retrieves the icon resource for the audio session. The Windows volume control displays this icon.
    ///Params:
    ///    pszPath = Receives a pointer to a wide-character string that specifies a shell resource. The format of the string is
    ///              described in the topic IMFAudioPolicy::SetIconPath. The caller must free the memory allocated for the string
    ///              by calling CoTaskMemFree.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetIconPath(PWSTR* pszPath);
}

///Callback interface to get media data from the sample-grabber sink.
@GUID("8C7B80BF-EE42-4B59-B1DF-55668E1BDCA8")
interface IMFSampleGrabberSinkCallback : IMFClockStateSink
{
    ///Called when the presentation clock is set on the sample-grabber sink.
    ///Params:
    ///    pPresentationClock = Pointer to the presentation clock's IMFPresentationClock interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT OnSetPresentationClock(IMFPresentationClock pPresentationClock);
    ///Called when the sample-grabber sink receives a new media sample.
    ///Params:
    ///    guidMajorMediaType = The major type that specifies the format of the data. For a list of possible values, see Major Media Types.
    ///    dwSampleFlags = Reserved.
    ///    llSampleTime = The presentation time for this sample, in 100-nanosecond units. If the sample does not have a presentation
    ///                   time, the value of this parameter is <b>_I64_MAX</b>.
    ///    llSampleDuration = The duration of the sample, in 100-nanosecond units. If the sample does not have a duration, the value of
    ///                       this parameter is <b>_I64_MAX</b>.
    ///    pSampleBuffer = A pointer to a buffer that contains the sample data.
    ///    dwSampleSize = Size of the <i>pSampleBuffer</i> buffer, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnProcessSample(const(GUID)* guidMajorMediaType, uint dwSampleFlags, long llSampleTime, 
                            long llSampleDuration, const(ubyte)* pSampleBuffer, uint dwSampleSize);
    ///Called when the sample-grabber sink is shut down.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT OnShutdown();
}

///Extends the IMFSampleGrabberSinkCallback interface.
@GUID("CA86AA50-C46E-429E-AB27-16D6AC6844CB")
interface IMFSampleGrabberSinkCallback2 : IMFSampleGrabberSinkCallback
{
    ///Called when the sample-grabber sink receives a new media sample.
    ///Params:
    ///    guidMajorMediaType = The major type GUID that specifies the format of the data. For a list of possible values, see Major Media
    ///                         Types.
    ///    dwSampleFlags = Sample flags. The sample-grabber sink gets the value of this parameter by calling the
    ///                    IMFSample::GetSampleFlags method of the media sample.
    ///    llSampleTime = The presentation time for this sample, in 100-nanosecond units. If the sample does not have a presentation
    ///                   time, the value of this parameter is <b>_I64_MAX</b>
    ///    llSampleDuration = The duration of the sample, in 100-nanosecond units. If the sample does not have a duration, the value of
    ///                       this parameter is <b>_I64_MAX</b>.
    ///    pSampleBuffer = A pointer to a buffer that contains the sample data.
    ///    dwSampleSize = The size, in bytes, of the <i>pSampleBuffer</i> buffer.
    ///    pAttributes = A pointer to the IMFAttributes interface. Use this interface to get the attributes for this sample (if any).
    ///                  For a list of sample attributes, see Sample Attributes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnProcessSampleEx(const(GUID)* guidMajorMediaType, uint dwSampleFlags, long llSampleTime, 
                              long llSampleDuration, const(ubyte)* pSampleBuffer, uint dwSampleSize, 
                              IMFAttributes pAttributes);
}

///Controls the work queues created by the Media Session. The Media Session exposes this interface as a service. To
///obtain a pointer to this interface, call IMFGetService::GetService on the Media Session with the service identifier
///MF_WORKQUEUE_SERVICES.
@GUID("35FE1BB8-A3A9-40FE-BBEC-EB569C9CCCA3")
interface IMFWorkQueueServices : IUnknown
{
    ///Registers the topology work queues with the Multimedia Class Scheduler Service (MMCSS).
    ///Params:
    ///    pCallback = A pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    pState = A pointer to the <b>IUnknown</b> interface of a state object defined by the caller. This parameter can be
    ///             <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///             callback is invoked.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BeginRegisterTopologyWorkQueuesWithMMCSS(IMFAsyncCallback pCallback, IUnknown pState);
    ///Completes an asynchronous request to register the topology work queues with the Multimedia Class Scheduler
    ///Service (MMCSS).
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              IMFAsyncCallback::Invoke method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT EndRegisterTopologyWorkQueuesWithMMCSS(IMFAsyncResult pResult);
    ///Unregisters the topology work queues from the Multimedia Class Scheduler Service (MMCSS).
    ///Params:
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    pState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///             <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///             callback is invoked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT BeginUnregisterTopologyWorkQueuesWithMMCSS(IMFAsyncCallback pCallback, IUnknown pState);
    ///Completes an asynchronous request to unregister the topology work queues from the Multimedia Class Scheduler
    ///Service (MMCSS).
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              IMFAsyncCallback::Invoke method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT EndUnregisterTopologyWorkQueuesWithMMCSS(IMFAsyncResult pResult);
    ///Retrieves the Multimedia Class Scheduler Service (MMCSS) class for a specified branch of the current topology.
    ///Params:
    ///    dwTopologyWorkQueueId = Identifies the work queue assigned to this topology branch. The application defines this value by setting the
    ///                            MF_TOPONODE_WORKQUEUE_ID attribute on the source node for the branch.
    ///    pwszClass = Pointer to a buffer that receives the name of the MMCSS class. This parameter can be <b>NULL</b>.
    ///    pcchClass = On input, specifies the size of the <i>pwszClass</i> buffer, in characters. On output, receives the required
    ///                size of the buffer, in characters. The size includes the terminating null character.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> There is no work queue with the specified
    ///    identifier. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pwszClass</i> buffer is too small to receive the class name. </td> </tr> </table>
    ///    
    HRESULT GetTopologyWorkQueueMMCSSClass(uint dwTopologyWorkQueueId, PWSTR pwszClass, uint* pcchClass);
    ///Retrieves the Multimedia Class Scheduler Service (MMCSS) task identifier for a specified branch of the current
    ///topology.
    ///Params:
    ///    dwTopologyWorkQueueId = Identifies the work queue assigned to this topology branch. The application defines this value by setting the
    ///                            MF_TOPONODE_WORKQUEUE_ID attribute on the source node for the branch.
    ///    pdwTaskId = Receives the task identifier.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetTopologyWorkQueueMMCSSTaskId(uint dwTopologyWorkQueueId, uint* pdwTaskId);
    ///Associates a platform work queue with a Multimedia Class Scheduler Service (MMCSS) task.
    ///Params:
    ///    dwPlatformWorkQueue = The platform work queue to register with MMCSS. See Work Queue Identifiers. To register all of the standard
    ///                          work queues to the same MMCSS task, set this parameter to <b>MFASYNC_CALLBACK_QUEUE_ALL</b>.
    ///    wszClass = The name of the MMCSS task to be performed.
    ///    dwTaskId = The unique task identifier. To obtain a new task identifier, set this value to zero.
    ///    pCallback = A pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    pState = A pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///             <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///             callback is invoked.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BeginRegisterPlatformWorkQueueWithMMCSS(uint dwPlatformWorkQueue, const(PWSTR) wszClass, uint dwTaskId, 
                                                    IMFAsyncCallback pCallback, IUnknown pState);
    ///Completes an asynchronous request to associate a platform work queue with a Multimedia Class Scheduler Service
    ///(MMCSS) task.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              IMFAsyncCallback::Invoke method.
    ///    pdwTaskId = The unique task identifier.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT EndRegisterPlatformWorkQueueWithMMCSS(IMFAsyncResult pResult, uint* pdwTaskId);
    ///Unregisters a platform work queue from a Multimedia Class Scheduler Service (MMCSS) task.
    ///Params:
    ///    dwPlatformWorkQueue = Platform work queue to register with MMCSS. See
    ///                          IMFWorkQueueServices::BeginRegisterPlatformWorkQueueWithMMCSS.
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    pState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///             <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///             callback is invoked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT BeginUnregisterPlatformWorkQueueWithMMCSS(uint dwPlatformWorkQueue, IMFAsyncCallback pCallback, 
                                                      IUnknown pState);
    ///Completes an asynchronous request to unregister a platform work queue from a Multimedia Class Scheduler Service
    ///(MMCSS) task.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              IMFAsyncCallback::Invoke method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT EndUnregisterPlatformWorkQueueWithMMCSS(IMFAsyncResult pResult);
    ///Retrieves the Multimedia Class Scheduler Service (MMCSS) class for a specified platform work queue.
    ///Params:
    ///    dwPlatformWorkQueueId = Platform work queue to query. See IMFWorkQueueServices::BeginRegisterPlatformWorkQueueWithMMCSS.
    ///    pwszClass = Pointer to a buffer that receives the name of the MMCSS class. This parameter can be <b>NULL</b>.
    ///    pcchClass = On input, specifies the size of the pwszClass buffer, in characters. On output, receives the required size of
    ///                the buffer, in characters. The size includes the terminating null character.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td width="60%"> The <i>pwszClass</i> buffer is too
    ///    small to receive the class name. </td> </tr> </table>
    ///    
    HRESULT GetPlaftormWorkQueueMMCSSClass(uint dwPlatformWorkQueueId, PWSTR pwszClass, uint* pcchClass);
    ///Retrieves the Multimedia Class Scheduler Service (MMCSS) task identifier for a specified platform work queue.
    ///Params:
    ///    dwPlatformWorkQueueId = Platform work queue to query. See IMFWorkQueueServices::BeginRegisterPlatformWorkQueueWithMMCSS.
    ///    pdwTaskId = Receives the task identifier.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetPlatformWorkQueueMMCSSTaskId(uint dwPlatformWorkQueueId, uint* pdwTaskId);
}

///Extends the IMFWorkQueueServices interface.
@GUID("96BF961B-40FE-42F1-BA9D-320238B49700")
interface IMFWorkQueueServicesEx : IMFWorkQueueServices
{
    ///Retrieves the Multimedia Class Scheduler Service (MMCSS) string associated with the given topology work queue.
    ///Params:
    ///    dwTopologyWorkQueueId = The id of the topology work queue.
    ///    plPriority = Pointer to the buffer the work queue's MMCSS task id will be copied to.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTopologyWorkQueueMMCSSPriority(uint dwTopologyWorkQueueId, int* plPriority);
    ///Registers a platform work queue with Multimedia Class Scheduler Service (MMCSS) using the specified class and
    ///task id.
    ///Params:
    ///    dwPlatformWorkQueue = The id of one of the standard platform work queues.
    ///    wszClass = The MMCSS class which the work queue should be registered with.
    ///    dwTaskId = The task id which the work queue should be registered with. If <i>dwTaskId</i> is 0, a new MMCSS bucket will
    ///               be created.
    ///    lPriority = The priority.
    ///    pCallback = Standard callback used for async operations in Media Foundation.
    ///    pState = Standard state used for async operations in Media Foundation.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BeginRegisterPlatformWorkQueueWithMMCSSEx(uint dwPlatformWorkQueue, const(PWSTR) wszClass, 
                                                      uint dwTaskId, int lPriority, IMFAsyncCallback pCallback, 
                                                      IUnknown pState);
    ///Gets the priority of the Multimedia Class Scheduler Service (MMCSS) priority associated with the specified
    ///platform work queue.
    ///Params:
    ///    dwPlatformWorkQueueId = Topology work queue id for which the info will be returned.
    ///    plPriority = 
    ///Returns:
    ///    Pointer to a buffer allocated by the caller that the work queue's MMCSS task id will be copied to.
    ///    
    HRESULT GetPlatformWorkQueueMMCSSPriority(uint dwPlatformWorkQueueId, int* plPriority);
}

///Adjusts playback quality. This interface is exposed by the quality manager.
@GUID("8D009D86-5B9F-4115-B1FC-9F80D52AB8AB")
interface IMFQualityManager : IUnknown
{
    ///Called when the Media Session is about to start playing a new topology.
    ///Params:
    ///    pTopology = Pointer to the IMFTopology interface of the new topology. If this parameter is <b>NULL</b>, the quality
    ///                manager should release any references to the previous topology.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT NotifyTopology(IMFTopology pTopology);
    ///Called when the Media Session selects a presentation clock.
    ///Params:
    ///    pClock = Pointer to the IMFPresentationClock interface of the presentation clock. If this parameter is <b>NULL</b>,
    ///             the quality manager should release any references to the presentation clock.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT NotifyPresentationClock(IMFPresentationClock pClock);
    ///Called when the media processor is about to deliver an input sample to a pipeline component.
    ///Params:
    ///    pNode = Pointer to the IMFTopologyNode interface of the topology node that represents the pipeline component.
    ///    lInputIndex = Index of the input stream on the topology node.
    ///    pSample = Pointer to the IMFSample interface of the input sample.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT NotifyProcessInput(IMFTopologyNode pNode, int lInputIndex, IMFSample pSample);
    ///Called after the media processor gets an output sample from a pipeline component.
    ///Params:
    ///    pNode = Pointer to the IMFTopologyNode interface of the topology node that represents the pipeline component.
    ///    lOutputIndex = Index of the output stream on the topology node.
    ///    pSample = Pointer to the IMFSample interface of the output sample.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT NotifyProcessOutput(IMFTopologyNode pNode, int lOutputIndex, IMFSample pSample);
    ///Called when a pipeline component sends an MEQualityNotify event.
    ///Params:
    ///    pObject = Pointer to the <b>IUnknown</b> interface of the object that sent the event. The object is either a Media
    ///              Foundation transform (MFT) or a stream sink.
    ///    pEvent = Pointer to the IMFMediaEvent interface of the event.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT NotifyQualityEvent(IUnknown pObject, IMFMediaEvent pEvent);
    ///Called when the Media Session is shutting down.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Shutdown();
}

///Enables the quality manager to adjust the audio or video quality of a component in the pipeline. This interface is
///exposed by pipeline components that can adjust their quality. Typically it is exposed by decoders and stream sinks.
///For example, the enhanced video renderer (EVR) implements this interface. However, media sources can also implement
///this interface. To get a pointer to this interface from a media source, call IMFGetService::GetService with the
///service identifier MF_QUALITY_SERVICES. For all other pipeline objects (transforms and media sinks), call
///<b>QueryInterface</b>.
@GUID("EC15E2E9-E36B-4F7C-8758-77D452EF4CE7")
interface IMFQualityAdvise : IUnknown
{
    ///Sets the drop mode. In drop mode, a component drops samples, more or less aggressively depending on the level of
    ///the drop mode.
    ///Params:
    ///    eDropMode = Requested drop mode, specified as a member of the MF_QUALITY_DROP_MODE enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NO_MORE_DROP_MODES</b></dt> </dl> </td> <td width="60%"> The component does not support the
    ///    specified mode or any higher modes. </td> </tr> </table>
    ///    
    HRESULT SetDropMode(MF_QUALITY_DROP_MODE eDropMode);
    ///Sets the quality level. The quality level determines how the component consumes or produces samples.
    ///Params:
    ///    eQualityLevel = Requested quality level, specified as a member of the MF_QUALITY_LEVEL enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NO_MORE_QUALITY_LEVELS</b></dt> </dl> </td> <td width="60%"> The component does not support
    ///    the specified quality level or any levels below it. </td> </tr> </table>
    ///    
    HRESULT SetQualityLevel(MF_QUALITY_LEVEL eQualityLevel);
    ///Retrieves the current drop mode.
    ///Params:
    ///    peDropMode = Receives the drop mode, specified as a member of the MF_QUALITY_DROP_MODE enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetDropMode(MF_QUALITY_DROP_MODE* peDropMode);
    ///Retrieves the current quality level.
    ///Params:
    ///    peQualityLevel = Receives the quality level, specified as a member of the MF_QUALITY_LEVEL enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetQualityLevel(MF_QUALITY_LEVEL* peQualityLevel);
    ///Drops samples over a specified interval of time.
    ///Params:
    ///    hnsAmountToDrop = Amount of time to drop, in 100-nanosecond units. This value is always absolute. If the method is called
    ///                      multiple times, do not add the times from previous calls.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_DROPTIME_NOT_SUPPORTED</b></dt> </dl> </td> <td width="60%"> The object does not support
    ///    this method. </td> </tr> </table>
    ///    
    HRESULT DropTime(long hnsAmountToDrop);
}

///Enables a pipeline object to adjust its own audio or video quality, in response to quality messages.
@GUID("F3706F0D-8EA2-4886-8000-7155E9EC2EAE")
interface IMFQualityAdvise2 : IMFQualityAdvise
{
    ///Forwards an MEQualityNotify event from the media sink.
    ///Params:
    ///    pEvent = A pointer to the event's IMFMediaEvent interface.
    ///    pdwFlags = Receives a bitwise <b>OR</b> of zero or more flags from the MF_QUALITY_ADVISE_FLAGS enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT NotifyQualityEvent(IMFMediaEvent pEvent, uint* pdwFlags);
}

///Queries an object for the number of <i>quality modes</i> it supports. Quality modes are used to adjust the trade-off
///between quality and speed when rendering audio or video. The default presenter for the <i>enhanced video renderer</i>
///(EVR) implements this interface. The EVR uses the interface to respond to quality messages from the quality manager.
@GUID("DFCD8E4D-30B5-4567-ACAA-8EB5B7853DC9")
interface IMFQualityAdviseLimits : IUnknown
{
    ///Gets the maximum <i>drop mode</i>. A higher drop mode means that the object will, if needed, drop samples more
    ///aggressively to match the presentation clock.
    ///Params:
    ///    peDropMode = Receives the maximum drop mode, specified as a member of the MF_QUALITY_DROP_MODE enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMaximumDropMode(MF_QUALITY_DROP_MODE* peDropMode);
    ///Gets the minimum quality level that is supported by the component.
    ///Params:
    ///    peQualityLevel = Receives the minimum quality level, specified as a member of the MF_QUALITY_LEVEL enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMinimumQualityLevel(MF_QUALITY_LEVEL* peQualityLevel);
}

///Notifies a pipeline object to register itself with the Multimedia Class Scheduler Service (MMCSS). Any pipeline
///object that creates worker threads should implement this interface.
@GUID("2347D60B-3FB5-480C-8803-8DF3ADCD3EF0")
interface IMFRealTimeClient : IUnknown
{
    ///Notifies the object to register its worker threads with the Multimedia Class Scheduler Service (MMCSS).
    ///Params:
    ///    dwTaskIndex = The MMCSS task identifier.
    ///    wszClass = The name of the MMCSS task.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RegisterThreads(uint dwTaskIndex, const(PWSTR) wszClass);
    ///Notifies the object to unregister its worker threads from the Multimedia Class Scheduler Service (MMCSS).
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UnregisterThreads();
    ///Specifies the work queue for the topology branch that contains this object.
    ///Params:
    ///    dwWorkQueueId = The identifier of the work queue, or the value <b>MFASYNC_CALLBACK_QUEUE_UNDEFINED</b>. See Remarks.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetWorkQueue(uint dwWorkQueueId);
}

///Notifies a pipeline object to register itself with the Multimedia Class Scheduler Service (MMCSS). This interface is
///a replacement for the IMFRealTimeClient interface.
@GUID("03910848-AB16-4611-B100-17B88AE2F248")
interface IMFRealTimeClientEx : IUnknown
{
    ///Notifies the object to register its worker threads with the Multimedia Class Scheduler Service (MMCSS).
    ///Params:
    ///    pdwTaskIndex = The MMCSS task identifier. If the value is zero on input, the object should create a new MCCSS task group.
    ///                   See Remarks.
    ///    wszClassName = The name of the MMCSS task.
    ///    lBasePriority = The base priority of the thread.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RegisterThreadsEx(uint* pdwTaskIndex, const(PWSTR) wszClassName, int lBasePriority);
    ///Notifies the object to unregister its worker threads from the Multimedia Class Scheduler Service (MMCSS).
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UnregisterThreads();
    ///Specifies the work queue that this object should use for asynchronous work items.
    ///Params:
    ///    dwMultithreadedWorkQueueId = The work queue identifier.
    ///    lWorkItemBasePriority = The base priority for work items.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetWorkQueueEx(uint dwMultithreadedWorkQueueId, int lWorkItemBasePriority);
}

///Implemented by the Sequencer Source. The sequencer source enables an application to create a sequence of topologies.
///To create the sequencer source, call MFCreateSequencerSource. For step-by-step instructions about how to create a
///playlist, see How to Create a Playlist.
@GUID("197CD219-19CB-4DE1-A64C-ACF2EDCBE59E")
interface IMFSequencerSource : IUnknown
{
    ///Adds a topology to the end of the queue.
    ///Params:
    ///    pTopology = Pointer to the IMFTopology interface of the topology. This pointer cannot be <b>NULL</b>. If an application
    ///                passes <b>NULL</b>, the call fails with an E_INVALIDARG error code.
    ///    dwFlags = A combination of flags from the MFSequencerTopologyFlags enumeration.
    ///    pdwId = Receives the sequencer element identifier for this topology.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The source topology node is missing
    ///    one of the following attributes: <ul> <li> MF_TOPONODE_STREAM_DESCRIPTOR </li> <li>
    ///    MF_TOPONODE_PRESENTATION_DESCRIPTOR </li> <li> MF_TOPONODE_SOURCE </li> </ul> </td> </tr> </table>
    ///    
    HRESULT AppendTopology(IMFTopology pTopology, uint dwFlags, uint* pdwId);
    ///Deletes a topology from the queue.
    ///Params:
    ///    dwId = The sequencer element identifier of the topology to delete.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT DeleteTopology(uint dwId);
    ///Maps a presentation descriptor to its associated sequencer element identifier and the topology it represents.
    ///Params:
    ///    pPD = Pointer to the IMFPresentationDescriptor interface of the presentation descriptor.
    ///    pId = Receives the sequencer element identifier. This value is assigned by the sequencer source when the
    ///          application calls IMFSequencerSource::AppendTopology. This parameter is optional and can be <b>NULL</b>.
    ///    ppTopology = Receives a pointer to the IMFTopology interface of the original topology that the application added to the
    ///                 sequencer source. The caller must release the interface. This parameter can receive the value <b>NULL</b> if
    ///                 the sequencer source has switched to the next presentation. This parameter is optional and can be
    ///                 <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The presentation descriptor is not valid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_S_SEQUENCER_CONTEXT_CANCELED</b></dt> </dl> </td> <td
    ///    width="60%"> This segment was canceled. </td> </tr> </table>
    ///    
    HRESULT GetPresentationContext(IMFPresentationDescriptor pPD, uint* pId, IMFTopology* ppTopology);
    ///Updates a topology in the queue.
    ///Params:
    ///    dwId = Sequencer element identifier of the topology to update.
    ///    pTopology = Pointer to the IMFTopology interface of the updated topology object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The sequencer source has been shut down.
    ///    </td> </tr> </table>
    ///    
    HRESULT UpdateTopology(uint dwId, IMFTopology pTopology);
    ///Updates the flags for a topology in the queue.
    ///Params:
    ///    dwId = Sequencer element identifier of the topology to update.
    ///    dwFlags = Bitwise <b>OR</b> of flags from the MFSequencerTopologyFlags enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT UpdateTopologyFlags(uint dwId, uint dwFlags);
}

///Enables an application to get a topology from the sequencer source. This interface is exposed by the sequencer source
///object.
@GUID("0E1D6009-C9F3-442D-8C51-A42D2D49452F")
interface IMFMediaSourceTopologyProvider : IUnknown
{
    ///Returns a topology for a media source that builds an internal topology.
    ///Params:
    ///    pPresentationDescriptor = A pointer to the IMFPresentationDescriptor interface of the media source's presentation descriptor. To get
    ///                              this pointer, either call IMFMediaSource::CreatePresentationDescriptor on the media source, or get the
    ///                              pointer from the MENewPresentation event.
    ///    ppTopology = Receives a pointer to the topology's IMFTopology interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. For example, a <b>NULL</b> input
    ///    parameter, or the presentation descriptor is not valid. </td> </tr> </table>
    ///    
    HRESULT GetMediaSourceTopology(IMFPresentationDescriptor pPresentationDescriptor, IMFTopology* ppTopology);
}

///Provides notifications to the sequencer source. This interface is exposed by the sequencer source. Applications do
///not use this interface. To get a pointer to this interface, call IMFGetService::GetService with the service
///identifier MF_SOURCE_PRESENTATION_PROVIDER_SERVICE.
@GUID("0E1D600A-C9F3-442D-8C51-A42D2D49452F")
interface IMFMediaSourcePresentationProvider : IUnknown
{
    ///Notifies the source when playback has reached the end of a segment. For timelines, this corresponds to reaching a
    ///mark-out point.
    ///Params:
    ///    pPresentationDescriptor = Pointer to the IMFPresentationDescriptor interface of the presentation descriptor for the segment that has
    ///                              ended.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ForceEndOfPresentation(IMFPresentationDescriptor pPresentationDescriptor);
}

///Updates the attributes of one or more nodes in the Media Session's current topology. The Media Session exposes this
///interface as a service. To get a pointer to the interface, call IMFGetService::GetService. The service identifier is
///MF_TOPONODE_ATTRIBUTE_EDITOR_SERVICE.
@GUID("676AA6DD-238A-410D-BB99-65668D01605A")
interface IMFTopologyNodeAttributeEditor : IUnknown
{
    ///Updates the attributes of one or more nodes in the current topology.
    ///Params:
    ///    TopoId = Reserved.
    ///    cUpdates = The number of elements in the <i>pUpdates</i> array.
    ///    pUpdates = Pointer to an array of MFTOPONODE_ATTRIBUTE_UPDATE structures. Each element of the array updates one
    ///               attribute on a node.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT UpdateNodeAttributes(ulong TopoId, uint cUpdates, MFTOPONODE_ATTRIBUTE_UPDATE* pUpdates);
}

///Controls how a byte stream buffers data from a network. To get a pointer to this interface, call
///<b>QueryInterface</b> on the byte stream object.
@GUID("6D66D782-1D4F-4DB7-8C63-CB8C77F1EF5E")
interface IMFByteStreamBuffering : IUnknown
{
    ///Sets the buffering parameters.
    ///Params:
    ///    pParams = Pointer to an MFBYTESTREAM_BUFFERING_PARAMS structure that contains the buffering parameters. The byte stream
    ///              uses this information to calculate how much data to buffer from the network.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetBufferingParams(MFBYTESTREAM_BUFFERING_PARAMS* pParams);
    ///Enables or disables buffering.
    ///Params:
    ///    fEnable = Specifies whether the byte stream buffers data. If <b>TRUE</b>, buffering is enabled. If <b>FALSE</b>,
    ///              buffering is disabled.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT EnableBuffering(BOOL fEnable);
    ///Stops any buffering that is in progress.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The byte stream successfully stopped buffering. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No buffering was in progress.
    ///    </td> </tr> </table>
    ///    
    HRESULT StopBuffering();
}

///Controls how a network byte stream transfers data to a local cache. Optionally, this interface is exposed by byte
///streams that read data from a network, for example, through HTTP. To get a pointer to this interface, call
///<b>QueryInterface</b> on the byte stream object.
@GUID("F5042EA4-7A96-4A75-AA7B-2BE1EF7F88D5")
interface IMFByteStreamCacheControl : IUnknown
{
    ///Stops the background transfer of data to the local cache.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StopBackgroundTransfer();
}

///Seeks a byte stream by time position.
@GUID("64976BFA-FB61-4041-9069-8C9A5F659BEB")
interface IMFByteStreamTimeSeek : IUnknown
{
    ///Queries whether the byte stream supports time-based seeking.
    ///Params:
    ///    pfTimeSeekIsSupported = Receives the value <b>TRUE</b> if the byte stream supports time-based seeking, or <b>FALSE</b> otherwise.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IsTimeSeekSupported(BOOL* pfTimeSeekIsSupported);
    ///Seeks to a new position in the byte stream.
    ///Params:
    ///    qwTimePosition = The new position, in 100-nanosecond units.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT TimeSeek(ulong qwTimePosition);
    ///Gets the result of a time-based seek.
    ///Params:
    ///    pqwStartTime = Receives the new position after the seek, in 100-nanosecond units.
    ///    pqwStopTime = Receives the stop time, in 100-nanosecond units. If the stop time is unknown, the value is zero.
    ///    pqwDuration = Receives the total duration of the file, in 100-nanosecond units. If the duration is unknown, the value is
    ///                  â€“1.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The byte stream
    ///    does not support time-based seeking, or no data is available. </td> </tr> </table>
    ///    
    HRESULT GetTimeSeekResult(ulong* pqwStartTime, ulong* pqwStopTime, ulong* pqwDuration);
}

///Controls how a network byte stream transfers data to a local cache. This interface extends the
///IMFByteStreamCacheControl interface.
@GUID("71CE469C-F34B-49EA-A56B-2D2A10E51149")
interface IMFByteStreamCacheControl2 : IMFByteStreamCacheControl
{
    ///Gets the ranges of bytes that are currently stored in the cache.
    ///Params:
    ///    pcRanges = Receives the number of ranges returned in the <i>ppRanges</i> array.
    ///    ppRanges = Receives an array of MF_BYTE_STREAM_CACHE_RANGE structures. Each structure specifies a range of bytes stored
    ///               in the cache. The caller must free the array by calling CoTaskMemFree.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetByteRanges(uint* pcRanges, MF_BYTE_STREAM_CACHE_RANGE** ppRanges);
    ///Limits the cache size.
    ///Params:
    ///    qwBytes = The maximum number of bytes to store in the cache, or <b>ULONGLONG_MAX </b> for no limit. The default value
    ///              is no limit.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCacheLimit(ulong qwBytes);
    ///Queries whether background transfer is active.
    ///Params:
    ///    pfActive = Receives the value <b>TRUE</b> if background transfer is currently active, or <b>FALSE</b> otherwise.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IsBackgroundTransferActive(BOOL* pfActive);
}

///Sets and retrieves user-name and password information for authentication purposes.
@GUID("5B87EF6A-7ED8-434F-BA0E-184FAC1628D1")
interface IMFNetCredential : IUnknown
{
    ///Sets the user name.
    ///Params:
    ///    pbData = Pointer to a buffer that contains the user name. If <i>fDataIsEncrypted</i> is <b>FALSE</b>, the buffer is a
    ///             wide-character string. Otherwise, the buffer contains encrypted data.
    ///    cbData = Size of <i>pbData</i>, in bytes. If <i>fDataIsEncrypted</i> is <b>FALSE</b>, the size includes the
    ///             terminating null character.
    ///    fDataIsEncrypted = If <b>TRUE</b>, the user name is encrypted. Otherwise, the user name is not encrypted.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetUser(ubyte* pbData, uint cbData, BOOL fDataIsEncrypted);
    ///Sets the password.
    ///Params:
    ///    pbData = Pointer to a buffer that contains the password. If <i>fDataIsEncrypted</i> is <b>FALSE</b>, the buffer is a
    ///             wide-character string. Otherwise, the buffer contains encrypted data.
    ///    cbData = Size of <i>pbData</i>, in bytes. If <i>fDataIsEncrypted</i> is <b>FALSE</b>, the size includes the
    ///             terminating null character.
    ///    fDataIsEncrypted = If <b>TRUE</b>, the password is encrypted. Otherwise, the password is not encrypted.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetPassword(ubyte* pbData, uint cbData, BOOL fDataIsEncrypted);
    ///Retrieves the user name.
    ///Params:
    ///    pbData = Pointer to a buffer that receives the user name. To find the required buffer size, set this parameter to
    ///             <b>NULL</b>. If <i>fEncryptData</i> is <b>FALSE</b>, the buffer contains a wide-character string. Otherwise,
    ///             the buffer contains encrypted data.
    ///    pcbData = On input, specifies the size of the <i>pbData</i> buffer, in bytes. On output, receives the required buffer
    ///              size. If <i>fEncryptData</i> is <b>FALSE</b>, the size includes the terminating null character.
    ///    fEncryptData = If <b>TRUE</b>, the method returns an encrypted string. Otherwise, the method returns an unencrypted string.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetUser(ubyte* pbData, uint* pcbData, BOOL fEncryptData);
    ///Retrieves the password.
    ///Params:
    ///    pbData = Pointer to a buffer that receives the password. To find the required buffer size, set this parameter to
    ///             <b>NULL</b>. If <i>fEncryptData</i> is <b>FALSE</b>, the buffer contains a wide-character string. Otherwise,
    ///             the buffer contains encrypted data.
    ///    pcbData = On input, specifies the size of the <i>pbData</i> buffer, in bytes. On output, receives the required buffer
    ///              size. If <i>fEncryptData</i> is <b>FALSE</b>, the size includes the terminating null character.
    ///    fEncryptData = If <b>TRUE</b>, the method returns an encrypted string. Otherwise, the method returns an unencrypted string.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetPassword(ubyte* pbData, uint* pcbData, BOOL fEncryptData);
    ///Queries whether logged-on credentials should be used.
    ///Params:
    ///    pfLoggedOnUser = Receives a Boolean value. If logged-on credentials should be used, the value is <b>TRUE</b>. Otherwise, the
    ///                     value is <b>FALSE</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT LoggedOnUser(BOOL* pfLoggedOnUser);
}

///Implemented by applications to provide user credentials for a network source. To use this interface, implement it in
///your application. Then create a property store object and set the MFNETSOURCE_CREDENTIAL_MANAGER property. The value
///of the property is a pointer to your application's <b>IMFNetCredentialManager</b> interface. Then pass the property
///store to one of the source resolver's creation functions, such as IMFSourceResolver::CreateObjectFromURL, in the
///<i>pProps</i> parameter. Media Foundation does not provide a default implementation of this interface. Applications
///that support authentication must implement this interface.
@GUID("5B87EF6B-7ED8-434F-BA0E-184FAC1628D1")
interface IMFNetCredentialManager : IUnknown
{
    ///Begins an asynchronous request to retrieve the user's credentials.
    ///Params:
    ///    pParam = Pointer to an MFNetCredentialManagerGetParam structure.
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    pState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///             <b>NULL</b>. The object is returned to the caller when the callback is invoked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT BeginGetCredentials(MFNetCredentialManagerGetParam* pParam, IMFAsyncCallback pCallback, 
                                IUnknown pState);
    ///Completes an asynchronous request to retrieve the user's credentials.
    ///Params:
    ///    pResult = Pointer to an IMFAsyncResult interface that contains the asynchronous result.
    ///    ppCred = Receives a pointer to the IMFNetCredential interface, which is used to retrieve the credentials. The caller
    ///             must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT EndGetCredentials(IMFAsyncResult pResult, IMFNetCredential* ppCred);
    ///Specifies whether the user's credentials succeeded in the authentication challenge. The network source calls this
    ///method to informs the application whether the user's credentials were authenticated.
    ///Params:
    ///    pCred = Pointer to the IMFNetCredential interface.
    ///    fGood = Boolean value. The value is <b>TRUE</b> if the credentials succeeded in the authentication challenge.
    ///            Otherwise, the value is <b>FALSE</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetGood(IMFNetCredential pCred, BOOL fGood);
}

///Gets credentials from the credential cache. This interface is implemented by the credential cache object.
///Applications that implement the IMFNetCredentialManager interface can use this object to store the user's
///credentials. To create the credential cache object, call MFCreateCredentialCache.
@GUID("5B87EF6C-7ED8-434F-BA0E-184FAC1628D1")
interface IMFNetCredentialCache : IUnknown
{
    ///Retrieves the credential object for the specified URL.
    ///Params:
    ///    pszUrl = A null-terminated wide-character string containing the URL for which the credential is needed.
    ///    pszRealm = A null-terminated wide-character string containing the realm for the authentication.
    ///    dwAuthenticationFlags = Bitwise <b>OR</b> of zero or more flags from the MFNetAuthenticationFlags enumeration.
    ///    ppCred = Receives a pointer to the IMFNetCredential interface. The caller must release the interface.
    ///    pdwRequirementsFlags = Receives a bitwise <b>OR</b> of zero or more flags from the MFNetCredentialRequirements enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCredential(const(PWSTR) pszUrl, const(PWSTR) pszRealm, uint dwAuthenticationFlags, 
                          IMFNetCredential* ppCred, uint* pdwRequirementsFlags);
    ///Reports whether the credential object provided successfully passed the authentication challenge.
    ///Params:
    ///    pCred = Pointer to the IMFNetCredential interface.
    ///    fGood = <b>TRUE</b> if the credential object succeeded in the authentication challenge; otherwise, <b>FALSE</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetGood(IMFNetCredential pCred, BOOL fGood);
    ///Specifies how user credentials are stored.
    ///Params:
    ///    pCred = Pointer to the IMFNetCredential interface. Obtain this pointer by calling
    ///            IMFNetCredentialCache::GetCredential.
    ///    dwOptionsFlags = Bitwise <b>OR</b> of zero or more flags from the MFNetCredentialOptions enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetUserOptions(IMFNetCredential pCred, uint dwOptionsFlags);
}

///Implemented by a client and called by Microsoft Media Foundation to get the client Secure Sockets Layer (SSL)
///certificate requested by the server. In most HTTPS connections the server provides a certificate so that the client
///can ensure the identity of the server. However, in certain cases the server might wants to verify the identity of the
///client by requesting the client to send a certificate. For this scenario, a client application must provide a
///mechanism for Media Foundation to retrieve the client side certificate while opening an HTTPS URL with the source
///resolver or the scheme handler. The application must implement <b>IMFSSLCertificateManager</b>, set the
///<b>IUnknown</b> pointer of the implemented object in the MFNETSOURCE_SSLCERTIFICATE_MANAGER property, and pass the
///property store to the source resolver. While opening the URL, Media Foundation calls the
///<b>IMFSSLCertificateManager</b> methods to get the certificate information. If the application needs to connect to
///HTTPS URL that requires a client-side certificate, or the application wants customized control over the type of
///server certificates to accept, then they can implement this interface. This interface can also be used by the
///application to validate the server SSL certificate. If the <b>IUnknown</b> pointer is not provided by the application
///and the HTTPS URL does not require the client to provide a certificate, Media Foundation uses the default
///implementation to open the URL.
@GUID("61F7D887-1230-4A8B-AEBA-8AD434D1A64D")
interface IMFSSLCertificateManager : IUnknown
{
    ///Gets the client SSL certificate synchronously.
    ///Params:
    ///    pszURL = Pointer to a string that contains the URL for which a client-side SSL certificate is required. Media
    ///             Foundation can resolve the scheme and send the request to the server.
    ///    ppbData = Pointer to the buffer that stores the certificate. This caller must free the buffer by calling
    ///              <b>CoTaskMemFree</b>.
    ///    pcbData = Pointer to a <b>DWORD</b> variable that receives the number of bytes required to hold the certificate data in
    ///              the buffer pointed by <i>*ppbData</i>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetClientCertificate(const(PWSTR) pszURL, ubyte** ppbData, uint* pcbData);
    ///Starts an asynchronous call to get the client SSL certificate.
    ///Params:
    ///    pszURL = A null-terminated string that contains the URL for which a client-side SSL certificate is required. Media
    ///             Foundation can resolve the scheme and send the request to the server.
    ///    pCallback = A pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    pState = A pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///             <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///             callback is invoked.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BeginGetClientCertificate(const(PWSTR) pszURL, IMFAsyncCallback pCallback, IUnknown pState);
    ///Completes an asynchronous request to get the client SSL certificate.
    ///Params:
    ///    pResult = A pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              IMFAsyncCallback::Invoke method.
    ///    ppbData = Receives a pointer to the buffer that stores the certificate. The caller must free the buffer by calling
    ///              CoTaskMemFree.
    ///    pcbData = Receives the size of the <i>ppbData</i> buffer, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EndGetClientCertificate(IMFAsyncResult pResult, ubyte** ppbData, uint* pcbData);
    ///Indicates whether the server SSL certificate must be verified by the caller, Media Foundation, or the
    ///<b>IMFSSLCertificateManager</b> implementation class.
    ///Params:
    ///    pszURL = Pointer to a string that contains the URL that is sent to the server.
    ///    pfOverrideAutomaticCheck = Pointer to a <b>BOOL</b> value. Set to <b>TRUE</b> if IMFSSLCertificateManager::OnServerCertificate is used
    ///                               to verify the server certificate. Set to <b>FALSE</b> if Media Foundation verifies the server certificate by
    ///                               using the certificates in the Windows certificate store.
    ///    pfClientCertificateAvailable = Pointer to a <b>BOOL</b> value. Set to <b>TRUE</b> if the SSL certificate for the client is available for
    ///                                   immediate retrieval. Media Foundation calls IMFSSLCertificateManager::GetClientCertificate to obtain the
    ///                                   client certificate synchronously. If the value is set to <b>FALSE</b>, Media Foundation obtains the client
    ///                                   SSL certificate with an asynchronous call to IMFSSLCertificateManager::BeginGetClientCertificate.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCertificatePolicy(const(PWSTR) pszURL, BOOL* pfOverrideAutomaticCheck, 
                                 BOOL* pfClientCertificateAvailable);
    ///Called by Media Foundation when the server SSL certificate has been received; indicates whether the server
    ///certificate is accepted.
    ///Params:
    ///    pszURL = Pointer to a string that contains the URL used to send the request to the server, and for which a server-side
    ///             SSL certificate has been received.
    ///    pbData = Pointer to a buffer that contains the server SSL certificate.
    ///    cbData = Pointer to a <b>DWORD</b> variable that indicates the size of <i>pbData</i> in bytes.
    ///    pfIsGood = Pointer to a <b>BOOL</b> variable that indicates whether the certificate is accepted.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnServerCertificate(const(PWSTR) pszURL, ubyte* pbData, uint cbData, BOOL* pfIsGood);
}

///Notifies the application when a byte stream requests a URL, and enables the application to block URL redirection.
@GUID("091878A3-BF11-4A5C-BC9F-33995B06EF2D")
interface IMFNetResourceFilter : IUnknown
{
    ///Called when the byte stream redirects to a URL.
    ///Params:
    ///    pszUrl = The URL to which the connection has been redirected.
    ///    pvbCancel = To cancel the redirection, set this parameter to <b>VARIANT_TRUE</b>. To allow the redirection, set this
    ///                parameter to <b>VARIANT_FALSE</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnRedirect(const(PWSTR) pszUrl, short* pvbCancel);
    ///Called when the byte stream requests a URL.
    ///Params:
    ///    pszUrl = The URL that the byte stream is requesting.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnSendingRequest(const(PWSTR) pszUrl);
}

///Callback interface to receive notifications from a network source on the progress of an asynchronous open operation.
@GUID("059054B3-027C-494C-A27D-9113291CF87F")
interface IMFSourceOpenMonitor : IUnknown
{
    ///Called by the network source when the open operation begins or ends.
    ///Params:
    ///    pEvent = Pointer to the IMFMediaEvent interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT OnSourceEvent(IMFMediaEvent pEvent);
}

///Determines the proxy to use when connecting to a server. The network source uses this interface. Applications can
///create the proxy locator configured by the application by implementing the IMFNetProxyLocatorFactory interface and
///setting the MFNETSOURCE_PROXYLOCATORFACTORY property on the source resolver. Otherwise, the network source uses the
///default Media Foundation implementation. To create the default proxy locator, call MFCreateProxyLocator.
@GUID("E9CD0383-A268-4BB4-82DE-658D53574D41")
interface IMFNetProxyLocator : IUnknown
{
    ///Initializes the proxy locator object.
    ///Params:
    ///    pszHost = Null-terminated wide-character string containing the hostname of the destination server.
    ///    pszUrl = Null-terminated wide-character string containing the destination URL.
    ///    fReserved = Reserved. Set to <b>FALSE</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT FindFirstProxy(const(PWSTR) pszHost, const(PWSTR) pszUrl, BOOL fReserved);
    ///Determines the next proxy to use.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> There are no more proxy objects. </td> </tr>
    ///    </table>
    ///    
    HRESULT FindNextProxy();
    ///Keeps a record of the success or failure of using the current proxy.
    ///Params:
    ///    hrOp = <b>HRESULT</b> specifying the result of using the current proxy for connection.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RegisterProxyResult(HRESULT hrOp);
    ///Retrieves the current proxy information including hostname and port.
    ///Params:
    ///    pszStr = Pointer to a buffer that receives a null-terminated string containing the proxy hostname and port. This
    ///             parameter can be <b>NULL</b>.
    ///    pcchStr = On input, specifies the number of elements in the <i>pszStr</i> array. On output, receives the required size
    ///              of the buffer.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOT_SUFFICIENT_BUFFER</b></dt> </dl> </td> <td width="60%"> The buffer specified in
    ///    <i>pszStr</i> is too small. </td> </tr> </table>
    ///    
    HRESULT GetCurrentProxy(PWSTR pszStr, uint* pcchStr);
    ///Creates a new instance of the default proxy locator.
    ///Params:
    ///    ppProxyLocator = Receives a pointer to the new proxy locator object's IMFNetProxyLocator interface. The caller must release
    ///                     the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Clone(IMFNetProxyLocator* ppProxyLocator);
}

///Creates a proxy locator object, which determines the proxy to use. The network source uses this interface to create
///the proxy locator object. Applications can provide their own implementation of this interface by setting the
///MFNETSOURCE_PROXYLOCATORFACTORY property. on the source resolver. If the application does not set this property, the
///network source uses the default proxy locator provided by Media Foundation.
@GUID("E9CD0384-A268-4BB4-82DE-658D53574D41")
interface IMFNetProxyLocatorFactory : IUnknown
{
    ///Creates an IMFNetProxyLocator interface proxy locator object based on the protocol name.
    ///Params:
    ///    pszProtocol = Null-terminated wide-character string containing the protocol name (for example, RTSP or HTTP).
    ///    ppProxyLocator = Receives a pointer to the IMFNetProxyLocator interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CreateProxyLocator(const(PWSTR) pszProtocol, IMFNetProxyLocator* ppProxyLocator);
}

///Persists media data from a source byte stream to an application-provided byte stream. The byte stream used for HTTP
///download implements this interface. To get a pointer to this interface, call IMFGetService::GetService on the byte
///stream, with the service identifier MFNET_SAVEJOB_SERVICE.
@GUID("E9931663-80BF-4C6E-98AF-5DCF58747D1F")
interface IMFSaveJob : IUnknown
{
    ///Begins saving a Windows Media file to the application's byte stream.
    ///Params:
    ///    pStream = Pointer to the IMFByteStream interface of the application's byte stream. The data from the source byte stream
    ///              is written to this byte stream.
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface
    ///    pState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///             <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///             callback is invoked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT BeginSave(IMFByteStream pStream, IMFAsyncCallback pCallback, IUnknown pState);
    ///Completes the operation started by IMFSaveJob::BeginSave.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              IMFAsyncCallback::Invoke method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT EndSave(IMFAsyncResult pResult);
    ///Cancels the operation started by IMFSaveJob::BeginSave.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CancelSave();
    ///Retrieves the percentage of content saved to the provided byte stream.
    ///Params:
    ///    pdwPercentComplete = Receives the percentage of completion.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetProgress(uint* pdwPercentComplete);
}

///Configures a network scheme plug-in.
@GUID("7BE19E73-C9BF-468A-AC5A-A5E8653BEC87")
interface IMFNetSchemeHandlerConfig : IUnknown
{
    ///Retrieves the number of protocols supported by the network scheme plug-in.
    ///Params:
    ///    pcProtocols = Receives the number of protocols.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetNumberOfSupportedProtocols(uint* pcProtocols);
    ///Retrieves a supported protocol by index
    ///Params:
    ///    nProtocolIndex = Zero-based index of the protocol to retrieve. To get the number of supported protocols, call
    ///                     IMFNetSchemeHandlerConfig::GetNumberOfSupportedProtocols.
    ///    pnProtocolType = Receives a member of the MFNETSOURCE_PROTOCOL_TYPE enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The value passed in the <i>nProtocolIndex</i>
    ///    parameter was greater than the total number of supported protocols, returned by
    ///    GetNumberOfSupportedProtocols. </td> </tr> </table>
    ///    
    HRESULT GetSupportedProtocolType(uint nProtocolIndex, MFNETSOURCE_PROTOCOL_TYPE* pnProtocolType);
    ///Not implemented in this release.
    ///Returns:
    ///    This method returns S_OK.
    ///    
    HRESULT ResetProtocolRolloverSettings();
}

///Creates a media source or a byte stream from a URL.
@GUID("6D4C7B74-52A0-4BB7-B0DB-55F29F47A668")
interface IMFSchemeHandler : IUnknown
{
    ///Begins an asynchronous request to create an object from a URL. When the Source Resolver creates a media source
    ///from a URL, it passes the request to a scheme handler. The scheme handler might create a media source directly
    ///from the URL, or it might return a byte stream. If it returns a byte stream, the source resolver use a
    ///byte-stream handler to create the media source from the byte stream.
    ///Params:
    ///    pwszURL = A null-terminated string that contains the URL to resolve.
    ///    dwFlags = A bitwise <b>OR</b> of one or more flags. See Source Resolver Flags.
    ///    pProps = A pointer to the <b>IPropertyStore</b> interface of a property store. The scheme handler can use this
    ///             property store to configure the object. This parameter can be <b>NULL</b>. For more information, see
    ///             Configuring a Media Source.
    ///    ppIUnknownCancelCookie = Receives an <b>IUnknown</b> pointer or the value <b>NULL</b>. If the value is not <b>NULL</b>, you can cancel
    ///                             the asynchronous operation by passing this pointer to the IMFSchemeHandler::CancelObjectCreation method. The
    ///                             caller must release the interface. This parameter can be <b>NULL</b>, in which case the <b>IUnknown</b>
    ///                             pointer is not returned to the caller.
    ///    pCallback = A pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    punkState = A pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///                <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///                callback is invoked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Cannot open the URL with the requested
    ///    access (read or write). </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_UNSUPPORTED_BYTESTREAM_TYPE</b></dt> </dl> </td> <td width="60%"> Unsupported byte stream type.
    ///    </td> </tr> </table>
    ///    
    HRESULT BeginCreateObject(const(PWSTR) pwszURL, uint dwFlags, IPropertyStore pProps, 
                              IUnknown* ppIUnknownCancelCookie, IMFAsyncCallback pCallback, IUnknown punkState);
    ///Completes an asynchronous request to create an object from a URL.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              Invoke method.
    ///    pObjectType = Receives a member of the MF_OBJECT_TYPE enumeration, specifying the type of object that was created.
    ///    ppObject = Receives a pointer to the <b>IUnknown</b> interface of the object. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td width="60%"> The operation was canceled. </td> </tr> </table>
    ///    
    HRESULT EndCreateObject(IMFAsyncResult pResult, MF_OBJECT_TYPE* pObjectType, IUnknown* ppObject);
    ///Cancels the current request to create an object from a URL.
    ///Params:
    ///    pIUnknownCancelCookie = Pointer to the <b>IUnknown</b> interface that was returned in the <i>ppIUnknownCancelCookie</i> parameter of
    ///                            the IMFSchemeHandler::BeginCreateObject method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CancelObjectCreation(IUnknown pIUnknownCancelCookie);
}

///Creates a media source from a byte stream.
@GUID("BB420AA4-765B-4A1F-91FE-D6A8A143924C")
interface IMFByteStreamHandler : IUnknown
{
    ///Begins an asynchronous request to create a media source from a byte stream.
    ///Params:
    ///    pByteStream = Pointer to the byte stream's IMFByteStream interface.
    ///    pwszURL = String that contains the original URL of the byte stream. This parameter can be <b>NULL</b>.
    ///    dwFlags = Bitwise OR of zero or more flags. See Source Resolver Flags.
    ///    pProps = Pointer to the <b>IPropertyStore</b> interface of a property store. The byte-stream handler can use this
    ///             property store to configure the object. This parameter can be <b>NULL</b>. For more information, see
    ///             Configuring a Media Source.
    ///    ppIUnknownCancelCookie = Receives an <b>IUnknown</b> pointer or the value <b>NULL</b>. If the value is not <b>NULL</b>, you can cancel
    ///                             the asynchronous operation by passing this pointer to the IMFByteStreamHandler::CancelObjectCreation method.
    ///                             The caller must release the interface. This parameter can be <b>NULL</b>.
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    punkState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///                <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///                callback is invoked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_CANNOT_PARSE_BYTESTREAM</b></dt> </dl> </td> <td width="60%"> Unable to parse the byte
    ///    stream. </td> </tr> </table>
    ///    
    HRESULT BeginCreateObject(IMFByteStream pByteStream, const(PWSTR) pwszURL, uint dwFlags, IPropertyStore pProps, 
                              IUnknown* ppIUnknownCancelCookie, IMFAsyncCallback pCallback, IUnknown punkState);
    ///Completes an asynchronous request to create a media source.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              Invoke method.
    ///    pObjectType = Receives a member of the MF_OBJECT_TYPE enumeration, specifying the type of object that was created.
    ///    ppObject = Receives a pointer to the <b>IUnknown</b> interface of the media source. The caller must release the
    ///               interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td width="60%"> The operation was canceled. See
    ///    IMFByteStreamHandler::CancelObjectCreation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_CANNOT_PARSE_BYTESTREAM</b></dt> </dl> </td> <td width="60%"> Unable to parse the byte stream.
    ///    </td> </tr> </table>
    ///    
    HRESULT EndCreateObject(IMFAsyncResult pResult, MF_OBJECT_TYPE* pObjectType, IUnknown* ppObject);
    ///Cancels the current request to create a media source.
    ///Params:
    ///    pIUnknownCancelCookie = Pointer to the <b>IUnknown</b> interface that was returned in the <i>ppIUnknownCancelCookie</i> parameter of
    ///                            the IMFByteStreamHandler::BeginCreateObject method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CancelObjectCreation(IUnknown pIUnknownCancelCookie);
    ///Retrieves the maximum number of bytes needed to create the media source or determine that the byte stream handler
    ///cannot parse this stream.
    ///Params:
    ///    pqwBytes = Receives the maximum number of bytes that are required.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetMaxNumberOfBytesRequiredForResolution(ulong* pqwBytes);
}

///Implemented by components that provide input trust authorities (ITAs). This interface is used to get the ITA for each
///of the component's streams.
@GUID("542612C4-A1B8-4632-B521-DE11EA64A0B0")
interface IMFTrustedInput : IUnknown
{
    ///Retrieves the input trust authority (ITA) for a specified stream.
    ///Params:
    ///    dwStreamID = The stream identifier for which the ITA is being requested.
    ///    riid = The interface identifier (IID) of the interface being requested. Currently the only supported value is
    ///           IID_IMFInputTrustAuthority.
    ///    ppunkObject = Receives a pointer to the ITA's <b>IUnknown</b> interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The ITA does not expose the requested
    ///    interface. </td> </tr> </table>
    ///    
    HRESULT GetInputTrustAuthority(uint dwStreamID, const(GUID)* riid, IUnknown* ppunkObject);
}

///Enables other components in the protected media path (PMP) to use the input protection system provided by an input
///trust authorities (ITA). An ITA is a component that implements an input protection system for media content. ITAs
///expose the <b>IMFInputTrustAuthority</b> interface. An ITA translates policy from the content's native format into a
///common format that is used by other PMP components. It also provides a decrypter, if one is needed to decrypt the
///stream. The topology contains one ITA instance for every protected stream in the media source. The ITA is obtained
///from the media source by calling IMFTrustedInput::GetInputTrustAuthority.
@GUID("D19F8E98-B126-4446-890C-5DCB7AD71453")
interface IMFInputTrustAuthority : IUnknown
{
    ///Retrieves a decrypter transform.
    ///Params:
    ///    riid = Interface identifier (IID) of the interface being requested. Currently this value must be IID_IMFTransform,
    ///           which requests the IMFTransform interface.
    ///    ppv = Receives a pointer to the interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The decrypter does not support the requested
    ///    interface. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_PROTECTED</b></dt> </dl> </td> <td
    ///    width="60%"> This input trust authority (ITA) does not provide a decrypter. </td> </tr> </table>
    ///    
    HRESULT GetDecrypter(const(GUID)* riid, void** ppv);
    ///Requests permission to perform a specified action on the stream.
    ///Params:
    ///    Action = The requested action, specified as a member of the MFPOLICYMANAGER_ACTION enumeration.
    ///    ppContentEnablerActivate = Receives the value <b>NULL</b> or a pointer to the IMFActivate interface. The <b>IMFActivate</b> interface is
    ///                               used to create a content enabler object. The caller must release the interface. For more information, see
    ///                               Remarks.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The user has permission to perform this action. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>NS_E_DRM_NEEDS_INDIVIDUALIZATION</b></dt> </dl> </td> <td width="60%"> The user must
    ///    individualize the application. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>NS_E_LICENSE_REQUIRED</b></dt>
    ///    </dl> </td> <td width="60%"> The user must obtain a license. </td> </tr> </table>
    ///    
    HRESULT RequestAccess(MFPOLICYMANAGER_ACTION Action, IMFActivate* ppContentEnablerActivate);
    ///Retrieves the policy that defines which output protection systems are allowed for this stream, and the
    ///configuration data for each protection system.
    ///Params:
    ///    Action = The action that will be performed on this stream, specified as a member of the MFPOLICYMANAGER_ACTION
    ///             enumeration.
    ///    ppPolicy = Receives a pointer to the IMFOutputPolicy interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetPolicy(MFPOLICYMANAGER_ACTION Action, IMFOutputPolicy* ppPolicy);
    ///Notifies the input trust authority (ITA) that a requested action is about to be performed.
    ///Params:
    ///    pParam = Pointer to an MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS structure that contains parameters for the
    ///             <b>BindAccess</b> action.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT BindAccess(MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS* pParam);
    ///Notifies the input trust authority (ITA) when the number of output trust authorities (OTAs) that will perform a
    ///specified action has changed.
    ///Params:
    ///    pParam = Pointer to an MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS structure that contains parameters for the
    ///             <b>UpdateAccess</b> action.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT UpdateAccess(MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS* pParam);
    ///Resets the input trust authority (ITA) to its initial state.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Reset();
}

///Implemented by components that provide output trust authorities (OTAs). Any Media Foundation transform (MFT) or media
///sink that is designed to work within the protected media path (PMP) and also sends protected content outside the
///Media Foundation pipeline must implement this interface. The policy engine uses this interface to negotiate what type
///of content protection should be applied to the content. Applications do not use this interface directly.
@GUID("D19F8E95-B126-4446-890C-5DCB7AD71453")
interface IMFTrustedOutput : IUnknown
{
    ///Gets the number of output trust authorities (OTAs) provided by this trusted output. Each OTA reports a single
    ///action.
    ///Params:
    ///    pcOutputTrustAuthorities = Receives the number of OTAs.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetOutputTrustAuthorityCount(uint* pcOutputTrustAuthorities);
    ///Gets an output trust authority (OTA), specified by index.
    ///Params:
    ///    dwIndex = Zero-based index of the OTA to retrieve. To get the number of OTAs provided by this object, call
    ///              IMFTrustedOutput::GetOutputTrustAuthorityCount.
    ///    ppauthority = Receives a pointer to the IMFOutputTrustAuthority interface of the OTA. The caller must release the
    ///                  interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetOutputTrustAuthorityByIndex(uint dwIndex, IMFOutputTrustAuthority* ppauthority);
    ///Queries whether this output is a policy sink, meaning it handles the rights and restrictions required by the
    ///input trust authority (ITA).
    ///Params:
    ///    pfIsFinal = Receives a Boolean value. If <b>TRUE</b>, this object is a policy sink. If <b>FALSE</b>, the policy must be
    ///                enforced further downstream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT IsFinal(BOOL* pfIsFinal);
}

///Encapsulates the functionality of one or more output protection systems that a trusted output supports. This
///interface is exposed by output trust authority (OTA) objects. Each OTA represents a single action that the trusted
///output can perform, such as play, copy, or transcode. An OTA can represent more than one physical output if each
///output performs the same action.
@GUID("D19F8E94-B126-4446-890C-5DCB7AD71453")
interface IMFOutputTrustAuthority : IUnknown
{
    ///Retrieves the action that is performed by this output trust authority (OTA).
    ///Params:
    ///    pAction = Receives a member of the MFPOLICYMANAGER_ACTION enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetAction(MFPOLICYMANAGER_ACTION* pAction);
    ///Sets one or more policy objects on the output trust authority (OTA).
    ///Params:
    ///    ppPolicy = The address of an array of IMFOutputPolicy pointers.
    ///    nPolicy = The number of elements in the <i>ppPolicy</i> array.
    ///    ppbTicket = Receives either a pointer to a buffer allocated by the OTA, or the value <b>NULL</b>. If this parameter
    ///                receives a non-<b>NULL</b> value, the caller must release the buffer by calling CoTaskMemFree. <div
    ///                class="alert"><b>Note</b> Currently this parameter is reserved. An OTA should set the pointer to
    ///                <b>NULL</b>.</div> <div> </div>
    ///    pcbTicket = Receives the size of the <i>ppbTicket</i> buffer, in bytes. If <i>ppbTicket</i> receives the value
    ///                <b>NULL</b>, <i>pcbTicket</i> receives the value zero.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_S_WAIT_FOR_POLICY_SET</b></dt> </dl> </td> <td width="60%"> The policy was negotiated
    ///    successfully, but the OTA will enforce it asynchronously. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_POLICY_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> The OTA does not support the
    ///    requirements of this policy. </td> </tr> </table>
    ///    
    HRESULT SetPolicy(IMFOutputPolicy* ppPolicy, uint nPolicy, ubyte** ppbTicket, uint* pcbTicket);
}

///Encapsulates a usage policy from an input trust authority (ITA). Output trust authorities (OTAs) use this interface
///to query which protection systems they are required to enforce by the ITA.
@GUID("7F00F10A-DAED-41AF-AB26-5FDFA4DFBA3C")
interface IMFOutputPolicy : IMFAttributes
{
    ///Retrieves a list of the output protection systems that the output trust authority (OTA) must enforce, along with
    ///configuration data for each protection system.
    ///Params:
    ///    dwAttributes = Describes the output that is represented by the OTA calling this method. This value is a bitwise OR of zero
    ///                   or more of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                   id="MFOUTPUTATTRIBUTE_BUS"></a><a id="mfoutputattribute_bus"></a><dl> <dt><b>MFOUTPUTATTRIBUTE_BUS</b></dt>
    ///                   </dl> </td> <td width="60%"> Hardware bus. </td> </tr> <tr> <td width="40%"><a
    ///                   id="MFOUTPUTATTRIBUTE_COMPRESSED"></a><a id="mfoutputattribute_compressed"></a><dl>
    ///                   <dt><b>MFOUTPUTATTRIBUTE_COMPRESSED</b></dt> </dl> </td> <td width="60%"> The output sends compressed data.
    ///                   If this flag is absent, the output sends uncompressed data. </td> </tr> <tr> <td width="40%"><a
    ///                   id="MFOUTPUTATTRIBUTE_BUSIMPLEMENTATION"></a><a id="mfoutputattribute_busimplementation"></a><dl>
    ///                   <dt><b>MFOUTPUTATTRIBUTE_BUSIMPLEMENTATION</b></dt> </dl> </td> <td width="60%"> Reserved. Do not use. </td>
    ///                   </tr> <tr> <td width="40%"><a id="MFOUTPUTATTRIBUTE_DIGITAL"></a><a id="mfoutputattribute_digital"></a><dl>
    ///                   <dt><b>MFOUTPUTATTRIBUTE_DIGITAL</b></dt> </dl> </td> <td width="60%"> The output sends a digital signal. If
    ///                   this flag is absent, the output sends an analog signal. </td> </tr> <tr> <td width="40%"><a
    ///                   id="MFOUTPUTATTRIBUTE_NONSTANDARDIMPLEMENTATION"></a><a
    ///                   id="mfoutputattribute_nonstandardimplementation"></a><dl>
    ///                   <dt><b>MFOUTPUTATTRIBUTE_NONSTANDARDIMPLEMENTATION</b></dt> </dl> </td> <td width="60%"> Reserved. Do not
    ///                   use. </td> </tr> <tr> <td width="40%"><a id="MFOUTPUTATTRIBUTE_SOFTWARE"></a><a
    ///                   id="mfoutputattribute_software"></a><dl> <dt><b>MFOUTPUTATTRIBUTE_SOFTWARE</b></dt> </dl> </td> <td
    ///                   width="60%"> Reserved. Do not use. </td> </tr> <tr> <td width="40%"><a id="MFOUTPUTATTRIBUTE_VIDEO"></a><a
    ///                   id="mfoutputattribute_video"></a><dl> <dt><b>MFOUTPUTATTRIBUTE_VIDEO</b></dt> </dl> </td> <td width="60%">
    ///                   The output sends video data. If this flag is absent, the output sends audio data. </td> </tr> </table>
    ///    guidOutputSubType = Indicates a specific family of output connectors that is represented by the OTA calling this method. Possible
    ///                        values include the following. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                        id="MFCONNECTOR_AGP"></a><a id="mfconnector_agp"></a><dl> <dt><b>MFCONNECTOR_AGP</b></dt> </dl> </td> <td
    ///                        width="60%"> AGP bus. </td> </tr> <tr> <td width="40%"><a id="MFCONNECTOR_COMPONENT"></a><a
    ///                        id="mfconnector_component"></a><dl> <dt><b>MFCONNECTOR_COMPONENT</b></dt> </dl> </td> <td width="60%">
    ///                        Component video. </td> </tr> <tr> <td width="40%"><a id="MFCONNECTOR_COMPOSITE"></a><a
    ///                        id="mfconnector_composite"></a><dl> <dt><b>MFCONNECTOR_COMPOSITE</b></dt> </dl> </td> <td width="60%">
    ///                        Composite video. </td> </tr> <tr> <td width="40%"><a id="MFCONNECTOR_D_JPN"></a><a
    ///                        id="mfconnector_d_jpn"></a><dl> <dt><b>MFCONNECTOR_D_JPN</b></dt> </dl> </td> <td width="60%"> Japanese D
    ///                        connector. (Connector conforming to the EIAJ RC-5237 standard.) </td> </tr> <tr> <td width="40%"><a
    ///                        id="MFCONNECTOR_DISPLAYPORT_EMBEDDED"></a><a id="mfconnector_displayport_embedded"></a><dl>
    ///                        <dt><b>MFCONNECTOR_DISPLAYPORT_EMBEDDED</b></dt> </dl> </td> <td width="60%"> Embedded DisplayPort connector.
    ///                        </td> </tr> <tr> <td width="40%"><a id="MFCONNECTOR_DISPLAYPORT_EXTERNAL"></a><a
    ///                        id="mfconnector_displayport_external"></a><dl> <dt><b>MFCONNECTOR_DISPLAYPORT_EXTERNAL</b></dt> </dl> </td>
    ///                        <td width="60%"> External DisplayPort connector. </td> </tr> <tr> <td width="40%"><a
    ///                        id="MFCONNECTOR_DVI"></a><a id="mfconnector_dvi"></a><dl> <dt><b>MFCONNECTOR_DVI</b></dt> </dl> </td> <td
    ///                        width="60%"> Digital video interface (DVI) connector. </td> </tr> <tr> <td width="40%"><a
    ///                        id="MFCONNECTOR_HDMI"></a><a id="mfconnector_hdmi"></a><dl> <dt><b>MFCONNECTOR_HDMI</b></dt> </dl> </td> <td
    ///                        width="60%"> High-definition multimedia interface (HDMI) connector. </td> </tr> <tr> <td width="40%"><a
    ///                        id="MFCONNECTOR_LVDS"></a><a id="mfconnector_lvds"></a><dl> <dt><b>MFCONNECTOR_LVDS</b></dt> </dl> </td> <td
    ///                        width="60%"> Low voltage differential signaling (LVDS) connector. A connector using the LVDS interface to
    ///                        connect internally to a display device. The connection between the graphics adapter and the display device is
    ///                        permanent and not accessible to the user. Applications should not enable High-Bandwidth Digital Content
    ///                        Protection (HDCP) for this connector. </td> </tr> <tr> <td width="40%"><a id="MFCONNECTOR_PCI"></a><a
    ///                        id="mfconnector_pci"></a><dl> <dt><b>MFCONNECTOR_PCI</b></dt> </dl> </td> <td width="60%"> PCI bus. </td>
    ///                        </tr> <tr> <td width="40%"><a id="MFCONNECTOR_PCI_Express"></a><a id="mfconnector_pci_express"></a><a
    ///                        id="MFCONNECTOR_PCI_EXPRESS"></a><dl> <dt><b>MFCONNECTOR_PCI_Express</b></dt> </dl> </td> <td width="60%">
    ///                        PCI Express bus. </td> </tr> <tr> <td width="40%"><a id="MFCONNECTOR_PCIX"></a><a
    ///                        id="mfconnector_pcix"></a><dl> <dt><b>MFCONNECTOR_PCIX</b></dt> </dl> </td> <td width="60%"> PCI-X bus. </td>
    ///                        </tr> <tr> <td width="40%"><a id="MFCONNECTOR_SDI"></a><a id="mfconnector_sdi"></a><dl>
    ///                        <dt><b>MFCONNECTOR_SDI</b></dt> </dl> </td> <td width="60%"> Audio data sent over a connector via S/PDIF.
    ///                        </td> </tr> <tr> <td width="40%"><a id="MFCONNECTOR_SPDIF"></a><a id="mfconnector_spdif"></a><dl>
    ///                        <dt><b>MFCONNECTOR_SPDIF</b></dt> </dl> </td> <td width="60%"> Serial digital interface connector. </td>
    ///                        </tr> <tr> <td width="40%"><a id="MFCONNECTOR_SVIDEO"></a><a id="mfconnector_svideo"></a><dl>
    ///                        <dt><b>MFCONNECTOR_SVIDEO</b></dt> </dl> </td> <td width="60%"> S-Video connector. </td> </tr> <tr> <td
    ///                        width="40%"><a id="MFCONNECTOR_UDI_EMBEDDED"></a><a id="mfconnector_udi_embedded"></a><dl>
    ///                        <dt><b>MFCONNECTOR_UDI_EMBEDDED</b></dt> </dl> </td> <td width="60%"> Embedded Unified Display Interface
    ///                        (UDI). </td> </tr> <tr> <td width="40%"><a id="MFCONNECTOR_UDI_EXTERNAL"></a><a
    ///                        id="mfconnector_udi_external"></a><dl> <dt><b>MFCONNECTOR_UDI_EXTERNAL</b></dt> </dl> </td> <td width="60%">
    ///                        External UDI. </td> </tr> <tr> <td width="40%"><a id="MFCONNECTOR_UNKNOWN"></a><a
    ///                        id="mfconnector_unknown"></a><dl> <dt><b>MFCONNECTOR_UNKNOWN</b></dt> </dl> </td> <td width="60%"> Unknown
    ///                        connector type. See Remarks. </td> </tr> <tr> <td width="40%"><a id="MFCONNECTOR_VGA"></a><a
    ///                        id="mfconnector_vga"></a><dl> <dt><b>MFCONNECTOR_VGA</b></dt> </dl> </td> <td width="60%"> VGA connector.
    ///                        </td> </tr> <tr> <td width="40%"><a id="_MFCONNECTOR_MIRACAST"></a><a id="_mfconnector_miracast"></a><dl>
    ///                        <dt><b> MFCONNECTOR_MIRACAST</b></dt> </dl> </td> <td width="60%"> Miracast wireless connector. Supported in
    ///                        Windows 8.1 and later. </td> </tr> </table>
    ///    rgGuidProtectionSchemasSupported = Pointer to an array of GUID values that specify which output protection systems are supported by the OTA that
    ///                                       is calling this method.
    ///    cProtectionSchemasSupported = Number of elements in the <i>rgGuidProtectionSchemasSupported</i> array.
    ///    ppRequiredProtectionSchemas = Receives a pointer to the IMFCollection interface of a collection object. The caller must release the
    ///                                  interface. Each object in the collection is an IMFOutputSchema pointer. Each <b>IMFOutputSchema</b> pointer
    ///                                  defines an output protection system that the OTA must enforce.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GenerateRequiredSchemas(uint dwAttributes, GUID guidOutputSubType, 
                                    GUID* rgGuidProtectionSchemasSupported, uint cProtectionSchemasSupported, 
                                    IMFCollection* ppRequiredProtectionSchemas);
    ///Retrieives a GUID identifying the input trust authority (ITA) that created this output policy object.
    ///Params:
    ///    pguidOriginatorID = Receives a GUID that identifies the originating ITA.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetOriginatorID(GUID* pguidOriginatorID);
    ///Retrieves the minimum version of the global revocation list (GRL) that must be enforced by the protected
    ///environment for this policy.
    ///Params:
    ///    pdwMinimumGRLVersion = Receives the minimum GRL version.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetMinimumGRLVersion(uint* pdwMinimumGRLVersion);
}

///Encapsulates information about an output protection system and its corresponding configuration data.
@GUID("7BE0FC5B-ABD9-44FB-A5C8-F50136E71599")
interface IMFOutputSchema : IMFAttributes
{
    ///Retrieves the output protection system that is represented by this object. Output protection systems are
    ///identified by GUID value.
    ///Params:
    ///    pguidSchemaType = Receives the GUID that identifies the output protection system.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetSchemaType(GUID* pguidSchemaType);
    ///Returns configuration data for the output protection system. The configuration data is used to enable or disable
    ///the protection system, and to set the protection levels.
    ///Params:
    ///    pdwVal = Receives the configuration data. The meaning of this data depends on the output protection system.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetConfigurationData(uint* pdwVal);
    ///Retrieves a GUID identifying the input trust authority (ITA) that generated this output schema object.
    ///Params:
    ///    pguidOriginatorID = Receives a GUID that identifies the originating ITA.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetOriginatorID(GUID* pguidOriginatorID);
}

///Establishes a one-way secure channel between two objects.
@GUID("D0AE555D-3B12-4D97-B060-0990BC5AEB67")
interface IMFSecureChannel : IUnknown
{
    ///Retrieves the client's certificate.
    ///Params:
    ///    ppCert = Receives a pointer to a buffer allocated by the object. The buffer contains the client's certificate. The
    ///             caller must release the buffer by calling CoTaskMemFree.
    ///    pcbCert = Receives the size of the <i>ppCert</i> buffer, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetCertificate(ubyte** ppCert, uint* pcbCert);
    ///Passes the encrypted session key to the client.
    ///Params:
    ///    pbEncryptedSessionKey = Pointer to a buffer that contains the encrypted session key. This parameter can be <b>NULL</b>.
    ///    cbSessionKey = Size of the <i>pbEncryptedSessionKey</i> buffer, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetupSession(ubyte* pbEncryptedSessionKey, uint cbSessionKey);
}

///Provides encryption for media data inside the protected media path (PMP).
@GUID("8E36395F-C7B9-43C4-A54D-512B4AF63C95")
interface IMFSampleProtection : IUnknown
{
    ///Retrieves the version of sample protection that the component implements on input.
    ///Params:
    ///    pdwVersion = Receives a member of the SAMPLE_PROTECTION_VERSION enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetInputProtectionVersion(uint* pdwVersion);
    ///Retrieves the version of sample protection that the component implements on output.
    ///Params:
    ///    pdwVersion = Receives a member of the SAMPLE_PROTECTION_VERSION enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetOutputProtectionVersion(uint* pdwVersion);
    ///Retrieves the sample protection certificate.
    ///Params:
    ///    dwVersion = Specifies the version number of the sample protection scheme for which to receive a certificate. The version
    ///                number is specified as a SAMPLE_PROTECTION_VERSION enumeration value.
    ///    ppCert = Receives a pointer to a buffer containing the certificate. The caller must free the memory for the buffer by
    ///             calling CoTaskMemFree.
    ///    pcbCert = Receives the size of the <i>ppCert</i> buffer, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td> </tr> </table>
    ///    
    HRESULT GetProtectionCertificate(uint dwVersion, ubyte** ppCert, uint* pcbCert);
    ///Retrieves initialization information for sample protection from the upstream component.
    ///Params:
    ///    dwVersion = Specifies the version number of the sample protection scheme. The version number is specified as a
    ///                SAMPLE_PROTECTION_VERSION enumeration value.
    ///    dwOutputId = Identifier of the output stream. The identifier corresponds to the output stream identifier returned by the
    ///                 IMFTransform interface.
    ///    pbCert = Pointer to a certificate provided by the downstream component.
    ///    cbCert = Size of the certificate, in bytes.
    ///    ppbSeed = Receives a pointer to a buffer that contains the initialization information for downstream component. The
    ///              caller must free the memory for the buffer by calling CoTaskMemFree.
    ///    pcbSeed = Receives the size of the <i>ppbSeed</i> buffer, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td> </tr> </table>
    ///    
    HRESULT InitOutputProtection(uint dwVersion, uint dwOutputId, ubyte* pbCert, uint cbCert, ubyte** ppbSeed, 
                                 uint* pcbSeed);
    ///Initializes sample protection on the downstream component.
    ///Params:
    ///    dwVersion = Specifies the version number of the sample protection scheme. The version number is specified as a
    ///                SAMPLE_PROTECTION_VERSION enumeration value.
    ///    dwInputId = Identifier of the input stream. The identifier corresponds to the output stream identifier returned by the
    ///                IMFTransform interface.
    ///    pbSeed = Pointer to a buffer that contains the initialization data provided by the upstream component. To retrieve
    ///             this buffer, call IMFSampleProtection::InitOutputProtection.
    ///    cbSeed = Size of the <i>pbSeed</i> buffer, in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT InitInputProtection(uint dwVersion, uint dwInputId, ubyte* pbSeed, uint cbSeed);
}

///Enables a media sink to receive samples before the presentation clock is started. To get a pointer to this interface,
///call <b>QueryInterface</b> on the media sink.
@GUID("5DFD4B2A-7674-4110-A4E6-8A68FD5F3688")
interface IMFMediaSinkPreroll : IUnknown
{
    ///Notifies the media sink that the presentation clock is about to start.
    ///Params:
    ///    hnsUpcomingStartTime = The upcoming start time for the presentation clock, in 100-nanosecond units. This time is the same value that
    ///                           will be given to the IMFPresentationClock::Start method when the presentation clock is started.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT NotifyPreroll(long hnsUpcomingStartTime);
}

///Optionally supported by media sinks to perform required tasks before shutdown. This interface is typically exposed by
///archive sinksâ€”that is, media sinks that write to a file. It is used to perform tasks such as flushing data to disk
///or updating a file header. To get a pointer to this interface, call <b>QueryInterface</b> on the media sink.
@GUID("EAECB74A-9A50-42CE-9541-6A7F57AA4AD7")
interface IMFFinalizableMediaSink : IMFMediaSink
{
    ///Notifies the media sink to asynchronously take any steps it needs to finish its tasks.
    ///Params:
    ///    pCallback = Pointer to the IMFAsyncCallback interface of an asynchronous object. The caller must implement this
    ///                interface.
    ///    punkState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///                <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///                callback is invoked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT BeginFinalize(IMFAsyncCallback pCallback, IUnknown punkState);
    ///Completes an asynchronous finalize operation.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the
    ///              IMFAsyncCallback::Invoke method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT EndFinalize(IMFAsyncResult pResult);
}

///Passes configuration information to the media sinks that are used for streaming the content. Optionally, this
///interface is supported by media sinks. The built-in ASF streaming media sink and the MP3 media sink implement this
///interface.
@GUID("9DB7AA41-3CC5-40D4-8509-555804AD34CC")
interface IMFStreamingSinkConfig : IUnknown
{
    ///Called by the streaming media client before the Media Session starts streaming to specify the byte offset or the
    ///time offset.
    ///Params:
    ///    fSeekOffsetIsByteOffset = A Boolean value that specifies whether <i>qwSeekOffset</i> gives a byte offset of a time offset. <table> <tr>
    ///                              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TRUE"></a><a id="true"></a><dl>
    ///                              <dt><b>TRUE</b></dt> </dl> </td> <td width="60%"> The <i>qwSeekOffset</i> parameter specifies a byte offset.
    ///                              </td> </tr> <tr> <td width="40%"><a id="FALSE"></a><a id="false"></a><dl> <dt><b>FALSE</b></dt> </dl> </td>
    ///                              <td width="60%"> The <i>qwSeekOffset</i> parameter specifies the time position in 100-nanosecond units. </td>
    ///                              </tr> </table>
    ///    qwSeekOffset = A byte offset or a time offset, depending on the value passed in <i>fSeekOffsetIsByteOffset</i>. Time offsets
    ///                   are specified in 100-nanosecond units.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StartStreaming(BOOL fSeekOffsetIsByteOffset, ulong qwSeekOffset);
}

///Exposed by objects that act as a proxy for a remote object. To obtain a pointer to this interface, call
///IMFGetService::GetService with the service identifier MF_REMOTE_PROXY.
@GUID("994E23AD-1CC2-493C-B9FA-46F1CB040FA4")
interface IMFRemoteProxy : IUnknown
{
    ///Retrieves a pointer to the remote object for which this object is a proxy.
    ///Params:
    ///    riid = Interface identifier (IID) of the requested interface.
    ///    ppv = Receives a pointer to the requested interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRemoteObject(const(GUID)* riid, void** ppv);
    ///Retrieves a pointer to the object that is hosting this proxy.
    ///Params:
    ///    riid = Interface identifier (IID) of the requested interface.
    ///    ppv = Receives a pointer to the requested interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRemoteHost(const(GUID)* riid, void** ppv);
}

///Marshals an interface pointer to and from a stream. Stream objects that support <b>IStream</b> can expose this
///interface to provide custom marshaling for interface pointers.
@GUID("09EF5BE3-C8A7-469E-8B70-73BF25BB193F")
interface IMFObjectReferenceStream : IUnknown
{
    ///Stores the data needed to marshal an interface across a process boundary.
    ///Params:
    ///    riid = Interface identifier of the interface to marshal.
    ///    pUnk = Pointer to the <b>IUnknown</b> interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SaveReference(const(GUID)* riid, IUnknown pUnk);
    ///Marshals an interface from data stored in the stream.
    ///Params:
    ///    riid = Interface identifier of the interface to marshal.
    ///    ppv = Receives a pointer to the requested interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT LoadReference(const(GUID)* riid, void** ppv);
}

///Enables a media source in the application process to create objects in the protected media path (PMP) process.
@GUID("F70CA1A9-FDC7-4782-B994-ADFFB1C98606")
interface IMFPMPHost : IUnknown
{
    ///Blocks the protected media path (PMP) process from ending.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT LockProcess();
    ///Decrements the lock count on the protected media path (PMP) process. Call this method once for each call to
    ///IMFPMPHost::LockProcess.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UnlockProcess();
    ///Creates an object in the protect media path (PMP) process, from a CLSID.
    ///Params:
    ///    clsid = The CLSID of the object to create.
    ///    pStream = A pointer to the <b>IStream</b> interface. This parameter can be <b>NULL</b>. If this parameter is not
    ///              <b>NULL</b>, the PMP host queries the created object for the IPersistStream interface and calls
    ///              <b>IPersistStream::Load</b>, passing in the <i>pStream</i> pointer.
    ///    riid = The interface identifier (IID) of the interface to retrieve.
    ///    ppv = Receives a pointer to the requested interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateObjectByCLSID(const(GUID)* clsid, IStream pStream, const(GUID)* riid, void** ppv);
}

///Enables a media source to receive a pointer to the IMFPMPHost interface.
@GUID("6C4E655D-EAD8-4421-B6B9-54DCDBBDF820")
interface IMFPMPClient : IUnknown
{
    ///Provides a pointer to the IMFPMPHost interface.
    ///Params:
    ///    pPMPHost = A pointer to the IMFPMPHost interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPMPHost(IMFPMPHost pPMPHost);
}

///Enables two instances of the Media Session to share the same protected media path (PMP) process.
@GUID("994E23AF-1CC2-493C-B9FA-46F1CB040FA4")
interface IMFPMPServer : IUnknown
{
    ///Blocks the protected media path (PMP) process from ending.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT LockProcess();
    ///Decrements the lock count on the protected media path (PMP) process. Call this method once for each call to
    ///IMFPMPServer::LockProcess.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT UnlockProcess();
    ///Creates an object in the protected media path (PMP) process.
    ///Params:
    ///    clsid = CLSID of the object to create.
    ///    riid = Interface identifier of the interface to retrieve.
    ///    ppObject = Receives a pointer to the requested interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CreateObjectByCLSID(const(GUID)* clsid, const(GUID)* riid, void** ppObject);
}

///Modifies a topology for use in a Terminal Services environment.
@GUID("1CDE6309-CAE0-4940-907E-C1EC9C3D1D4A")
interface IMFRemoteDesktopPlugin : IUnknown
{
    ///Modifies a topology for use in a Terminal Services environment.
    ///Params:
    ///    pTopology = Pointer to the IMFTopology interface of the topology.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT UpdateTopology(IMFTopology pTopology);
}

///Sets and retrieves Synchronized Accessible Media Interchange (SAMI) styles on the SAMI Media Source.
@GUID("A7E025DD-5303-4A62-89D6-E747E1EFAC73")
interface IMFSAMIStyle : IUnknown
{
    ///Gets the number of styles defined in the SAMI file.
    ///Params:
    ///    pdwCount = Receives the number of SAMI styles in the file.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStyleCount(uint* pdwCount);
    ///Gets a list of the style names defined in the SAMI file.
    ///Params:
    ///    pPropVarStyleArray = Pointer to a <b>PROPVARIANT</b> that receives an array of null-terminated wide-character strings. The
    ///                         <b>PROPVARIANT</b> type is VT_VECTOR | VT_LPWSTR. The caller must clear the <b>PROPVARIANT</b> by calling
    ///                         <b>PropVariantClear</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStyles(PROPVARIANT* pPropVarStyleArray);
    ///Sets the current style on the SAMI media source.
    ///Params:
    ///    pwszStyle = Pointer to a null-terminated string containing the name of the style. To clear the current style, pass an
    ///                empty string (""). To get the list of style names, call IMFSAMIStyle::GetStyles.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSelectedStyle(const(PWSTR) pwszStyle);
    ///Gets the current style from the SAMI media source.
    ///Params:
    ///    ppwszStyle = Receives a pointer to a null-terminated string that contains the name of the style. If no style is currently
    ///                 set, the method returns an empty string. The caller must free the memory for the string by calling
    ///                 CoTaskMemFree.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSelectedStyle(PWSTR* ppwszStyle);
}

///Implemented by the transcode profile object. The transcode profile stores configuration settings that the topology
///builder uses to generate the transcode topology for the output file. These configuration settings are specified by
///the caller and include audio and video stream properties, encoder settings, and container settings that are specified
///by the caller. To create the transcode profile object, call MFCreateTranscodeProfile. The configured transcode
///profile is passed to MFCreateTranscodeTopology, which creates the transcode topology with the appropriate settings.
@GUID("4ADFDBA3-7AB0-4953-A62B-461E7FF3DA1E")
interface IMFTranscodeProfile : IUnknown
{
    ///Sets audio stream configuration settings in the transcode profile. To get a list of compatible audio media types
    ///supported by the Media Foundation transform (MFT) encoder , call MFTranscodeGetAudioOutputAvailableTypes. You can
    ///get the attributes that are set on the required media type and set them on the transcode profile. To set the
    ///audio attributes properly, create a new attribute store and copy the attribute store from the required media
    ///media type by calling IMFAttributes::CopyAllItems. This makes sure that the caller does not hold the references
    ///to the media type retrieved from the encoder. For example code, see MFCreateTranscodeProfile.
    ///Params:
    ///    pAttrs = Pointer to the IMFAttributes interface of an attribute store that contains the configuration settings for the
    ///             audio stream. The specified attribute values overwrite any existing values stored in the transcode profile.
    ///             The following audio attributes can be set: <ul> <li> Audio Media Types </li> <li>
    ///             MF_TRANSCODE_DONOT_INSERT_ENCODER </li> <li> MF_TRANSCODE_ENCODINGPROFILE </li> <li>
    ///             MF_TRANSCODE_QUALITYVSSPEED </li> </ul> To create the attribute store, call MFCreateAttributes. To set a
    ///             specific attribute value in the attribute store, the caller must call the appropriate IMFAttributes methods
    ///             depending on the data type of the attribute.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetAudioAttributes(IMFAttributes pAttrs);
    ///Gets the audio stream settings that are currently set in the transcode profile.
    ///Params:
    ///    ppAttrs = Receives a pointer to the IMFAttributes interface of the attribute store containing the current audio stream
    ///              settings. Caller must release the interface pointer.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAudioAttributes(IMFAttributes* ppAttrs);
    ///Sets video stream configuration settings in the transcode profile. For example code, see
    ///MFCreateTranscodeProfile.
    ///Params:
    ///    pAttrs = Pointer to the IMFAttributes interface of an attribute store that contains contains the configuration
    ///             settings for the video stream. The specified attribute values overwrites any existing values stored in the
    ///             transcode profile. The following video attributes can be set: <ul> <li> Video Media Types </li> <li>
    ///             MF_TRANSCODE_DONOT_INSERT_ENCODER </li> <li> MF_TRANSCODE_ENCODINGPROFILE </li> <li>
    ///             MF_TRANSCODE_QUALITYVSSPEED </li> </ul> To create the attribute store, call MFCreateAttributes. To set a
    ///             specific attribute value in the attribute store, the caller must call the appropriate IMFAttributes methods
    ///             depending on the data type of the attribute.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetVideoAttributes(IMFAttributes pAttrs);
    ///Gets the video stream settings that are currently set in the transcode profile.
    ///Params:
    ///    ppAttrs = Receives a pointer to the IMFAttributes interface of the attribute store containing the current video stream
    ///              settings. Caller must release the interface pointer.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoAttributes(IMFAttributes* ppAttrs);
    ///Sets container configuration settings in the transcode profile. For example code, see MFCreateTranscodeProfile.
    ///Params:
    ///    pAttrs = Pointer to the IMFAttributes interface of an attribute store that contains the configuration settings for the
    ///             container in which the transcoded file will be stored. The specified attribute values overwrite any existing
    ///             values stored in the transcode profile. The following list shows the container attributes that can be set:
    ///             <ul> <li> MF_TRANSCODE_ADJUST_PROFILE </li> <li> MF_TRANSCODE_CONTAINERTYPE </li> <li>
    ///             MF_TRANSCODE_SKIP_METADATA_TRANSFER </li> <li> MF_TRANSCODE_TOPOLOGYMODE </li> <li> MFT_FIELDOFUSE_UNLOCK
    ///             </li> </ul> To create the attribute store, call MFCreateAttributes. To set a specific attribute value in the
    ///             attribute store, the caller must call the appropriate IMFAttributes methods depending on the data type of the
    ///             attribute.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetContainerAttributes(IMFAttributes pAttrs);
    ///Gets the container settings that are currently set in the transcode profile.
    ///Params:
    ///    ppAttrs = Receives a pointer to the IMFAttributes interface of the attribute store containing the current container
    ///              type for the output file. Caller must release the interface pointer.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetContainerAttributes(IMFAttributes* ppAttrs);
}

///Implemented by the transcode sink activation object. The transcode sink activation object can be used to create any
///of the following file sinks: <ul> <li>3GP file sink</li> <li>MP3 file sink</li> <li>MP4 file sink</li> </ul>
@GUID("8CFFCD2E-5A03-4A3A-AFF7-EDCD107C620E")
interface IMFTranscodeSinkInfoProvider : IUnknown
{
    ///Sets the name of the encoded output file.
    ///Params:
    ///    pwszFileName = Pointer to a null-terminated string that contains the name of the output file.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOutputFile(const(PWSTR) pwszFileName);
    ///Sets an output byte stream for the transcode media sink.
    ///Params:
    ///    pByteStreamActivate = A pointer to the IMFActivate interface of a byte-stream activation object.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOutputByteStream(IMFActivate pByteStreamActivate);
    ///Sets the transcoding profile on the transcode sink activation object.
    ///Params:
    ///    pProfile = A pointer to the IMFTranscodeProfile interface. To get a pointer to this interface, call
    ///               MFCreateTranscodeProfile.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetProfile(IMFTranscodeProfile pProfile);
    ///Gets the media types for the audio and video streams specified in the transcode profile.
    ///Params:
    ///    pSinkInfo = A pointer to an MF_TRANSCODE_SINK_INFO structure. If the method succeeds, the method assigns IMFMediaType
    ///                pointers to the <b>pAudioMediaType</b> and <b>pVideoMediaType</b> members of this structure. The method might
    ///                set either member to <b>NULL</b>. If either member is non-NULL after the method returns, the caller must
    ///                release the <b>IMFMediaType</b> pointers.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSinkInfo(MF_TRANSCODE_SINK_INFO* pSinkInfo);
}

///Enables an application to use a Media Foundation transform (MFT) that has restrictions on its use.
@GUID("508E71D3-EC66-4FC3-8775-B4B9ED6BA847")
interface IMFFieldOfUseMFTUnlock : IUnknown
{
    ///Unlocks a Media Foundation transform (MFT) so that the application can use it.
    ///Params:
    ///    pUnkMFT = A pointer to the <b>IUnknown</b> interface of the MFT.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Unlock(IUnknown pUnkMFT);
}

///Registers Media Foundation transforms (MFTs) in the caller's process. The Media Session exposes this interface as a
///service. To obtain a pointer to this interface, call the IMFGetService::GetService method on the Media Session with
///the service identifier <b>MF_LOCAL_MFT_REGISTRATION_SERVICE</b>.
@GUID("149C4D73-B4BE-4F8D-8B87-079E926B6ADD")
interface IMFLocalMFTRegistration : IUnknown
{
    ///Registers one or more Media Foundation transforms (MFTs) in the caller's process.
    ///Params:
    ///    pMFTs = A pointer to an array of MFT_REGISTRATION_INFO structures.
    ///    cMFTs = The number of elements in the <i>pMFTs</i> array.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RegisterMFTs(MFT_REGISTRATION_INFO* pMFTs, uint cMFTs);
}

@GUID("19F68549-CA8A-4706-A4EF-481DBC95E12C")
interface IMFCapturePhotoConfirmation : IUnknown
{
    HRESULT SetPhotoConfirmationCallback(IMFAsyncCallback pNotificationCallback);
    HRESULT SetPixelFormat(GUID subtype);
    HRESULT GetPixelFormat(GUID* subtype);
}

///Allows a media source to create a Windows Runtime object in the Protected Media Path (PMP) process.
@GUID("84D2054A-3AA1-4728-A3B0-440A418CF49C")
interface IMFPMPHostApp : IUnknown
{
    ///Blocks the protected media path (PMP) process from ending.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT LockProcess();
    ///Decrements the lock count on the protected media path (PMP) process. Call this method once for each call to
    ///IMFPMPHostApp::LockProcess.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UnlockProcess();
    ///Creates a Windows Runtime object in the protected media path (PMP) process.
    ///Params:
    ///    id = Id of object to create.
    ///    pStream = Data to be passed to the object by way of a IPersistStream.
    ///    riid = The interface identifier (IID) of the interface to retrieve.
    ///    ppv = Receives a pointer to the created object.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ActivateClassById(const(PWSTR) id, IStream pStream, const(GUID)* riid, void** ppv);
}

///Provides a mechanism for a media source to implement content protection functionality in a Windows Store apps.
@GUID("C004F646-BE2C-48F3-93A2-A0983EBA1108")
interface IMFPMPClientApp : IUnknown
{
    ///Sets a pointer to the IMFPMPHostApp interface allowing a media source to create objects in the PMP process.
    ///Params:
    ///    pPMPHost = A pointer to the IMFPMPHostApp interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPMPHost(IMFPMPHostApp pPMPHost);
}

///Represents a request for a sample from a MediaStreamSource.
@GUID("380B9AF9-A85B-4E78-A2AF-EA5CE645C6B4")
interface IMFMediaStreamSourceSampleRequest : IUnknown
{
    ///Sets the sample for the media stream source.
    ///Params:
    ///    value = The sample for the media stream source.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSample(IMFSample value);
}

///Tracks the reference counts on a video media sample. Video samples created by the MFCreateVideoSampleFromSurface
///function expose this interface.
@GUID("245BF8E9-0755-40F7-88A5-AE0F18D55E17")
interface IMFTrackedSample : IUnknown
{
    ///Sets the owner for the sample.
    ///Params:
    ///    pSampleAllocator = Pointer to the IMFAsyncCallback interface of a callback object. The caller must implement this interface.
    ///    pUnkState = Pointer to the <b>IUnknown</b> interface of a state object, defined by the caller. This parameter can be
    ///                <b>NULL</b>. You can use this object to hold state information. The object is returned to the caller when the
    ///                callback is invoked.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOTACCEPTING</b></dt> </dl> </td> <td width="60%"> The owner was already set. This method
    ///    cannot be called twice on the sample. </td> </tr> </table>
    ///    
    HRESULT SetAllocator(IMFAsyncCallback pSampleAllocator, IUnknown pUnkState);
}

///Provides a method that allows content protection systems to perform a handshake with the protected environment. This
///is needed because the <b>CreateFile</b> and <b>DeviceIoControl</b> APIs are not available to Windows Store apps.
@GUID("EF5DC845-F0D9-4EC9-B00C-CB5183D38434")
interface IMFProtectedEnvironmentAccess : IUnknown
{
    ///Allows content protection systems to access the protected environment.
    ///Params:
    ///    inputLength = The length in bytes of the input data.
    ///    input = A pointer to the input data.
    ///    outputLength = The length in bytes of the output data.
    ///    output = A pointer to the output data.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Call(uint inputLength, const(ubyte)* input, uint outputLength, ubyte* output);
    ///Gets the Global Revocation List (GLR).
    ///Params:
    ///    outputLength = The length of the data returned in <b>output</b>.
    ///    output = Receives the contents of the global revocation list file.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ReadGRL(uint* outputLength, ubyte** output);
}

///Provides a method that allows content protection systems to get the procedure address of a function in the signed
///library. This method provides the same functionality as <b>GetProcAddress</b> which is not available to Windows Store
///apps.
@GUID("4A724BCA-FF6A-4C07-8E0D-7A358421CF06")
interface IMFSignedLibrary : IUnknown
{
    ///Gets the procedure address of the specified function in the signed library.
    ///Params:
    ///    name = The entry point name in the DLL that specifies the function.
    ///    address = Receives the address of the entry point.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetProcedureAddress(const(PSTR) name, void** address);
}

///Provides a method that retireves system id data.
@GUID("FFF4AF3A-1FC1-4EF9-A29B-D26C49E2F31A")
interface IMFSystemId : IUnknown
{
    ///Retrieves system id data.
    ///Params:
    ///    size = The size in bytes of the returned data.
    ///    data = Receives the returned data. The caller must free this buffer by calling CoTaskMemFree.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetData(uint* size, ubyte** data);
    ///Sets up the IMFSystemId.
    ///Params:
    ///    stage = Stage in the setup process. 0 or 1.
    ///    cbIn = Size of the input buffer.
    ///    pbIn = The input buffer.
    ///    pcbOut = Size of output buffer.
    ///    ppbOut = The output buffer.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Setup(uint stage, uint cbIn, const(ubyte)* pbIn, uint* pcbOut, ubyte** ppbOut);
}

///Allows a decryptor to communicate with the security processor that implements the hardware decryption for a
///protection system.
@GUID("E6257174-A060-4C9A-A088-3B1B471CAD28")
interface IMFContentProtectionDevice : IUnknown
{
    ///Calls into the implementation of the protection system in the security processor.
    ///Params:
    ///    FunctionId = The identifier of the function that you want to run. This identifier is defined by the implementation of the
    ///                 protection system.
    ///    InputBufferByteCount = The number of bytes of in the buffer that <i>InputBuffer</i> specifies, including private data.
    ///    InputBuffer = A pointer to the data that you want to provide as input.
    ///    OutputBufferByteCount = Pointer to a value that specifies the length in bytes of the data that the function wrote to the buffer that
    ///                            <i>OutputBuffer</i> specifies, including the private data.
    ///    OutputBuffer = Pointer to the buffer where you want the function to write its output.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT InvokeFunction(uint FunctionId, uint InputBufferByteCount, const(ubyte)* InputBuffer, 
                           uint* OutputBufferByteCount, ubyte* OutputBuffer);
    ///Gets the required number of bytes that need to be prepended to the input and output buffers when you call the
    ///security processor through the InvokeFunction method. When you specify this number of bytes, the Media Foundation
    ///transform (MFT) decryptor can allocate the total amount of bytes and can avoid making copies of the data when the
    ///decrytor moves the data to the security processor.
    ///Params:
    ///    PrivateInputByteCount = The required number of bytes that need to be prepended to the input buffer that you supply to content
    ///                            protection system.
    ///    PrivateOutputByteCount = The required number of bytes that need to be prepended to the output buffer that you supply to content
    ///                             protection system.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPrivateDataByteCount(uint* PrivateInputByteCount, uint* PrivateOutputByteCount);
}

///Allows a decryptor to manage hardware keys and decrypt hardware samples.
@GUID("7EC4B1BD-43FB-4763-85D2-64FCB5C5F4CB")
interface IMFContentDecryptorContext : IUnknown
{
    ///Allows the display driver to return IHV-specific information used when initializing a new hardware key.
    ///Params:
    ///    InputPrivateDataByteCount = The number of bytes in the buffer that <i>InputPrivateData</i> specifies.
    ///    InputPrivateData = The contents of this parameter are defined by the implementation of the protection system that runs in the
    ///                       security processor. The contents may contain data about license or stream properties.
    ///    OutputPrivateData = The return data is also defined by the implementation of the protection system implementation that runs in
    ///                        the security processor. The contents may contain data associated with the underlying hardware key.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT InitializeHardwareKey(uint InputPrivateDataByteCount, const(void)* InputPrivateData, 
                                  ulong* OutputPrivateData);
}

///<p class="CCE_Message">[Some information relates to pre-released product which may be substantially modified before
///it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information
///provided here.] Implemented by clients that want to enforce a cross origin policy for HTML5 media downloads.
@GUID("BC2B7D44-A72D-49D5-8376-1480DEE58B22")
interface IMFNetCrossOriginSupport : IUnknown
{
    ///<p class="CCE_Message">[Some information relates to pre-released product which may be substantially modified
    ///before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the
    ///information provided here.] Returns the client's current cross-origin policy to apply to the download session.
    ///Params:
    ///    pPolicy = A value indicating the client's current cross-origin policy to apply to the download session.
    ///Returns:
    ///    Returns S_OK upon successful completion.
    ///    
    HRESULT GetCrossOriginPolicy(MF_CROSS_ORIGIN_POLICY* pPolicy);
    ///<p class="CCE_Message">[Some information relates to pre-released product which may be substantially modified
    ///before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the
    ///information provided here.] Returns the W3C origin of the HTML5 media element.
    ///Params:
    ///    wszSourceOrigin = The W3C origin of the HTML5 media element.
    ///Returns:
    ///    Returns S_OK upon successful completion.
    ///    
    HRESULT GetSourceOrigin(PWSTR* wszSourceOrigin);
    ///<p class="CCE_Message">[Some information relates to pre-released product which may be substantially modified
    ///before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the
    ///information provided here.] Returns true when the specified URL has the same origin as the HTML5 media element.
    ///Params:
    ///    wszURL = TBD
    ///    pfIsSameOrigin = TBD
    ///Returns:
    ///    Returns S_OK upon successful completion.
    ///    
    HRESULT IsSameOrigin(const(PWSTR) wszURL, BOOL* pfIsSameOrigin);
}

///Applications implement this interface to override the default implementation of the HTTP and HTTPS protocols used by
///Microsoft Media Foundation. Applications provide the <b>IMFHttpDownloadRequest</b> interface to Media Foundation
///through the CreateRequest method on the IMFHttpDownloadSession interface.
@GUID("F779FDDF-26E7-4270-8A8B-B983D1859DE0")
interface IMFHttpDownloadRequest : IUnknown
{
    ///Invoked by Microsoft Media Foundation to add a single HTTP header to a HTTP request. Microsoft Media Foundation
    ///will invoke this method once for each header that shall be included in the HTTP request, before it invokes the
    ///BeginSendRequest method.
    ///Params:
    ///    szHeader = Contains a single HTTP request header, for example, â€œAccept: */*â€. The string does not include the
    ///               carriage return or line feed characters.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully added the header to the list of headers to be
    ///    sent with the request. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> There is insufficient memory to complete the operation. </td> </tr> </table>
    ///    
    HRESULT AddHeader(const(PWSTR) szHeader);
    ///Invoked by Microsoft Media Foundation to send a HTTP or HTTPS request
    ///Params:
    ///    pbPayload = Pointer to a buffer that contains the message payload to send in the request. This parameter is used for POST
    ///                requests. GET requests do not carry a message payload and therefore <i>pbPayload</i> is NULL.
    ///    cbPayload = The size of the <i>pbPayload</i> buffer, in bytes.
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object that is implemented by Microsoft Media
    ///                Foundation.
    ///    punkState = Pointer to the IUnknown interface of a state object, defined by Microsoft Media Foundation. This parameter
    ///                can be NULL.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully started the asynchronous operation. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory to complete the operation. </td> </tr> </table>
    ///    
    HRESULT BeginSendRequest(const(ubyte)* pbPayload, uint cbPayload, IMFAsyncCallback pCallback, 
                             IUnknown punkState);
    ///Invoked by Microsoft Media Foundation to complete the asynchronous operation started by BeginSendRequest.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Microsoft Media Foundation will pass in the same pointer that its
    ///              callback object received in the IMFAsyncCallback::Invoke method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The request was successfully sent to the server. </td>
    ///    </tr> </table>
    ///    
    HRESULT EndSendRequest(IMFAsyncResult pResult);
    ///Invoked by Microsoft Media Foundation to receive the response, provided by the server, in response to a
    ///previously sent HTTP or HTTPS request. Media Foundation invokes this method only after having successfully
    ///invoked the EndSendRequest method.
    ///Params:
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object that is implemented by Microsoft Media
    ///                Foundation.
    ///    punkState = Pointer to the IUnknown interface of a state object, defined by Microsoft Media Foundation. This parameter
    ///                can be NULL.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully started the asynchronous operation. </td>
    ///    </tr> </table>
    ///    
    HRESULT BeginReceiveResponse(IMFAsyncCallback pCallback, IUnknown punkState);
    ///Invoked by Microsoft Media Foundation to complete the asynchronous operation started by BeginReceiveResponse.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Microsoft Media Foundation will pass in the same pointer that its
    ///              callback object received in the IMFAsyncCallback::Invoke method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully received the HTTP response and associated
    ///    headers. </td> </tr> </table>
    ///    
    HRESULT EndReceiveResponse(IMFAsyncResult pResult);
    ///Invoked by Microsoft Media Foundation to receive the message body of the response to a previously sent HTTP or
    ///HTTPS request. Media Foundation invokes this method only after having successfully invoked the EndReceiveResponse
    ///method. Since the size of the message body may be large, or unknown, Media Foundation may invoke this method
    ///multiple times to retrieve the message body in piecemeal fashion.
    ///Params:
    ///    pb = Pointer to a buffer that receives the data.
    ///    cb = Specifies the size of the <i>pb</i> buffer, in bytes.
    ///    pCallback = Pointer to the IMFAsyncCallback interface of a callback object that is implemented by Microsoft Media
    ///                Foundation.
    ///    punkState = Pointer to the IUnknown interface of a state object, defined by Microsoft Media Foundation. This parameter
    ///                can be NULL.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully started the asynchronous operation. </td>
    ///    </tr> </table>
    ///    
    HRESULT BeginReadPayload(ubyte* pb, uint cb, IMFAsyncCallback pCallback, IUnknown punkState);
    ///Invoked by Microsoft Media Foundation to complete the asynchronous operation started by BeginReadPayload. When
    ///this method completes successfully, the payload data will have been written to the buffer that Media Foundation
    ///provided when invoking <b>BeginReadPayload</b>.
    ///Params:
    ///    pResult = Pointer to the IMFAsyncResult interface. Microsoft Media Foundation will pass in the same pointer that its
    ///              callback object received in the IMFAsyncCallback::Invoke method.
    ///    pqwOffset = The offset of the first byte written to the buffer, relative to the complete message body of the current HTTP
    ///                request. For example, when Media Foundation invokes BeginReadPayload for the first time on a given
    ///                IMFHttpDownloadRequest, and specifies a buffer size of 100, the <i>pqwOffset</i> parameter will be set to 0.
    ///                Then, when Media Foundation invokes <b>BeginReadPayload</b> for the second time on the same
    ///                <b>IMNFHttpDownloadRequest</b>, the <i>pqwOffset</i> parameter will be set to 100.
    ///    pcbRead = Specifies the number of bytes written to the buffer that Media Foundation provided when invoking
    ///              BeginReadPayload. Note that this value must always be equal to the size of the buffer specified in
    ///              <b>BeginReadPayload</b>, unless the request failed, or unless the end of the message body has been reached.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully wrote data to the buffer provided in
    ///    BeginReadPayload. </td> </tr> </table>
    ///    
    HRESULT EndReadPayload(IMFAsyncResult pResult, ulong* pqwOffset, uint* pcbRead);
    ///Invoked by Microsoft Media Foundation to retrieve the values of specified HTTP headers from the response to a
    ///previously sent HTTP or HTTPS request. Media Foundation invokes this method only after having successfully
    ///invoked the EndReceiveResponse method.
    ///Params:
    ///    szHeaderName = The name of the HTTP header for which the value is being queried.
    ///    dwIndex = The index number of the specified header, for the case where the response contains multiple headers with the
    ///              same name. A value of 0 indicates that the value of the first header with the specified name is requested, 1
    ///              indicates that the second header is requested, and so on.
    ///    ppszHeaderValue = Set to the value of the requested header, not including the carriage return or line feed characters. The
    ///                      memory for <i>ppszHeaderValue</i> must be allocated with CoTaskMemAlloc and will be freed by Media Foundation
    ///                      with CoTaskMemFree.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the value of the specified header
    ///    with the specified index. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td>
    ///    <td width="60%"> There is insufficient memory to complete the operation. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppszHeaderValue</i> parameter is an
    ///    invalid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_OUT_OF_RANGE</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>dwIndex</i> parameter value is out of range. </td> </tr> </table>
    ///    
    HRESULT QueryHeader(const(PWSTR) szHeaderName, uint dwIndex, PWSTR* ppszHeaderValue);
    ///Returns the URL that is used for sending the request.
    ///Params:
    ///    ppszURL = The URL that is used for sending the request to the server. Note that this URL may be different if the server
    ///              has issued a HTTP protocol â€œredirectâ€. The memory for <i>pszURL</i> must be allocated with
    ///              CoTaskMemAlloc, and will be freed by Media Foundation with CoTaskMemFree.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the URL. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is insufficient memory to
    ///    complete the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppszURL</i> parameter is an invalid pointer. </td> </tr> </table>
    ///    
    HRESULT GetURL(PWSTR* ppszURL);
    ///Invoked by Microsoft Media Foundation to detect the case when a HTTP or HTTPS request has been redirected to a
    ///different server of different "origin".
    ///Params:
    ///    pfNullSourceOrigin = Set to TRUE if the current request has a â€œnullâ€ source origin. The source origin would become â€œnullâ€
    ///                         if the HTTP request was redirected from one server to another, and the two servers have different origins.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully completed the operation. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pfNullSOurceOrigin</i>
    ///    parameter is an invalid pointer. </td> </tr> </table>
    ///    
    HRESULT HasNullSourceOrigin(BOOL* pfNullSourceOrigin);
    ///Invoked by Microsoft Media Foundation to retrieve the values of the TimeSeekRange.DLNA.ORG HTTP header, if any,
    ///that the server specified in its response.
    ///Params:
    ///    pqwStartTime = The starting time offset, specified in units of one-hundred nanoseconds.
    ///    pqwStopTime = The end time offset, specified in units of one-hundred nanoseconds
    ///    pqwDuration = The time duration of data contained in the response, specified in units of one-hundred nanoseconds. Set this
    ///                  parameter to 0 if the server did not specify a duration (i.e., specified â€œ*â€ as the duration.)
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The TimeSeekRange.DLNA.ORG HTTP header was present in the
    ///    response, and could be successfully parsed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt>
    ///    </dl> </td> <td width="60%"> The TimeSeekRange.DLNA.ORG HTTP header was not present in the response, or had a
    ///    syntax error. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    The <i>pfNullSOurceOrigin</i> parameter is an invalid pointer. </td> </tr> </table>
    ///    
    HRESULT GetTimeSeekResult(ulong* pqwStartTime, ulong* pqwStopTime, ulong* pqwDuration);
    ///Invoked by Microsoft Media Foundation to retrieve the HTTP status code that the server specified in its response.
    ///Media Foundation invokes this method after a successful call to EndReceiveResponse.
    ///Params:
    ///    pdwHttpStatus = The HTTP status code of the response. For example, the value is 200 for a typical successful response.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the HTTP status code. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The HTTP response has not yet
    ///    been received. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    The <i>pdwHttpStatus</i> parameter is an invalid pointer. </td> </tr> </table>
    ///    
    HRESULT GetHttpStatus(uint* pdwHttpStatus);
    ///Invoked by Microsoft Media Foundation to check if it should invoke BeginReadPayload to read data from the message
    ///body of the response. During the processing of a typical HTTP response, Media Foundation will invoke
    ///<b>BeginReadPayload</b> multiple times, but once <b>GetAtEndOfPayload</b> sets its output parameter to TRUE,
    ///Media Foundation will not invoke <b>BeginReadPayload</b> again.
    ///Params:
    ///    pfAtEndOfPayload = Set to FALSE if a call to BeginReadPayload can return one or more bytes of data to Media Foundation. Set to
    ///                       TRUE when there is no more data to return.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully completed the operation. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pfAtEndOfPayload</i>
    ///    parameter is an invalid pointer. </td> </tr> </table>
    ///    
    HRESULT GetAtEndOfPayload(BOOL* pfAtEndOfPayload);
    ///Invoked by Microsoft Media Foundation to retrieve the total length of the resource that is being downloaded, if
    ///known.
    ///Params:
    ///    pqwTotalLength = The total length, in bytes, of the resource being downloaded, if known. If not known, set to <b>MAX_ULONG</b>
    ///                     (0xFFFFFFFFFFFFFFFF).
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully completed the operation. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pqwTotalLength</i> parameter
    ///    is an invalid pointer. </td> </tr> </table>
    ///    
    HRESULT GetTotalLength(ulong* pqwTotalLength);
    ///Invoked by Microsoft Media Foundation to retrieve the offset of the last byte in the current response, counted
    ///from the start of the resource. This is useful when a request uses the HTTP â€œRangeâ€ header to download only a
    ///portion of a resource.
    ///Params:
    ///    pqwRangeEnd = The offset of the last byte in the current response, counted from the start of the resource, if known. For
    ///                  example, if the request specified the HTTP header, â€œRange: bytes=1000-â€œ and the size of the message body
    ///                  in the response is 200 bytes, then <i>pwqRangeEnd</i> becomes 1199. If the value is not known, for example,
    ///                  because the server did not specify the size of its response, <i>pwqRangeEnd</i> is set to MAX_ULONG
    ///                  (0xFFFFFFFFFFFFFFFF).
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully completed the operation. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>qwpRangeEnd</i> parameter is
    ///    an invalid pointer. </td> </tr> </table>
    ///    
    HRESULT GetRangeEndOffset(ulong* pqwRangeEnd);
    ///Invoked by Microsoft Media Foundation to allow IMFHttpDownloadRequest to free any internal resources. It will
    ///also cancel the current request if it is still in progress.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully closed the request object. </td> </tr>
    ///    </table>
    ///    
    HRESULT Close();
}

///Applications implement this interface to override the default implementation of the HTTP and HTTPS protocols used by
///Microsoft Media Foundation. Applications provide the <b>IMFHttpDownloadSession</b> interface to Media Foundation
///through the CreateHttpDownloadSession method on the IMFHttpDownloadSessionProvider interface. Microsoft Media
///Foundation uses this interface to perform a â€œstreamingâ€, or â€œprogressiveâ€, download of a resource identified
///by a HTTP or HTTPS URL. Multiple HTTP requests may be sent to download the resource. The
///<b>IMFHttpDownloadSession</b> interface is used to create these individual HTTP requests.
@GUID("71FA9A2C-53CE-4662-A132-1A7E8CBF62DB")
interface IMFHttpDownloadSession : IUnknown
{
    ///Called by Microsoft Media Foundation to specify parameters common to all requests created by this instance of
    ///IMFHttpDownloadSession.
    ///Params:
    ///    szServerName = The host name, fully qualified DNS name, or IP address of the HTTP server that the requests shall be sent to.
    ///    nPort = The TCP port number of the server.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully stored the supplied data. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is insufficient memory to
    ///    complete the operation. </td> </tr> </table>
    ///    
    HRESULT SetServer(const(PWSTR) szServerName, uint nPort);
    ///Invoked by Microsoft Media Foundation to create an object that implements the IMFHttpDownloadRequest interface,
    ///which is used to send a single HTTP, or HTTPS request. Since multiple requests may be needed to fully download a
    ///resource, Media Foundation may invoke <b>CreateRequest</b> multiple times on the same IMFHttpDownloadSession
    ///instance. Media Foundation will use each <b>IMFHttpDownloadRequest</b> instance for only a single request.
    ///Params:
    ///    szObjectName = Pointer to a string that contains the name of the target resource of the specified HTTP verb. This is
    ///                   generally a file name, an executable module, or a search specifier. The target resource always begins with a
    ///                   forward slash character and includes any query string that was included on the URL.
    ///    fBypassProxyCache = If set to TRUE, indicates that the request should be forwarded to the originating server rather than sending
    ///                        a cached version of a resource from a proxy server. When this flag is set to TRUE, a "Pragma: no-cache"
    ///                        header should be added to the request. When creating an HTTP/1.1 request, a "Cache-Control: no-cache" should
    ///                        also be added.
    ///    fSecure = If set to TRUE, causes the secure variant of the protocol to be used, if applicable. For example, if the
    ///              IMFHttpDownloadSession is for HTTP/HTTPS, setting <i>fSecure</i> to TRUE will cause the request to use HTTPS.
    ///              Otherwise, the unsecure variant of the protocol (in this example, HTTP) is used.
    ///    szVerb = Pointer to a string that contains the HTTP verb to use in the request. If this parameter is NULL, the
    ///             function uses GET as the HTTP verb. <div class="alert"><b>Note</b> This string should be all uppercase. Many
    ///             servers treat HTTP verbs as case-sensitive, and the Internet Engineering Task Force (IETF) Requests for
    ///             Comments (RFCs) spell these verbs using uppercase characters only.</div> <div> </div>
    ///    szReferrer = Pointer to a string that specifies the URL of the document from which the URL in the request
    ///                 <i>szObjectName</i> was obtained. If this parameter is set to NULL, no referring document is specified.
    ///    ppRequest = Upon successful return of the method, this parameter is set to an IMFHttpDownloadRequest interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully stored the supplied information. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is insufficient
    ///    memory to complete the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt>
    ///    </dl> </td> <td width="60%"> The method was invoked after Close or before SetServer was invoked. </td> </tr>
    ///    </table>
    ///    
    HRESULT CreateRequest(const(PWSTR) szObjectName, BOOL fBypassProxyCache, BOOL fSecure, const(PWSTR) szVerb, 
                          const(PWSTR) szReferrer, IMFHttpDownloadRequest* ppRequest);
    ///Invoked by Microsoft Media Foundation to specify that no more HTTP requests will be created, and allows
    ///IMFHttpDownloadSession to free any internal resources.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully closed the session. </td> </tr> </table>
    ///    
    HRESULT Close();
}

///Applications implement this interface in order to provide custom a custom HTTP or HTTPS download implementation. Use
///the IMFSourceResolver interface to register the provider. For more information, see Using the Source Resolver. Once
///registered, the Microsoft Media Foundation will invoke the CreateHttpDownloadSession method of the provider
///implementation to open HTTP or HTTPS URLs instead of using the default implementation.
@GUID("1B4CF4B9-3A16-4115-839D-03CC5C99DF01")
interface IMFHttpDownloadSessionProvider : IUnknown
{
    ///Called by the Microsoft Media Foundation to open HTTP or HTTPS URLs instead of using the default implementation.
    ///Params:
    ///    wszScheme = The name of the protocol to for which an IMFHttpDownloadSession is being requested. Microsoft Media
    ///                Foundation specifies the protocol scheme of the URL that the application provided the Media Foundation Source
    ///                Resolver. Valid values include â€œhttpâ€ for HTTP, and â€œhttpsâ€ for HTTPS. URL scheme names are generally
    ///                not case-sensitive.
    ///    ppDownloadSession = On successful execution, the parameter is set to a pointer to an IMFHttpDownloadSession interface. The
    ///                        returned interface is used by Microsoft Media Foundation to open a single HTTP or HTTPS URL.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully created the IMFHttpDownloadSession object.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The value
    ///    specified for the <i>wszScheme</i> parameter is incorrect. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppDownloadSession</i> parameter is an invalid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    There is insufficient memory to complete the operation. </td> </tr> </table>
    ///    
    HRESULT CreateHttpDownloadSession(const(PWSTR) wszScheme, IMFHttpDownloadSession* ppDownloadSession);
}

@GUID("FBB03414-D13B-4786-8319-5AC51FC0A136")
interface IMFMediaSource2 : IMFMediaSourceEx
{
    HRESULT SetMediaType(uint dwStreamID, IMFMediaType pMediaType);
}

@GUID("C5BC37D6-75C7-46A1-A132-81B5F723C20F")
interface IMFMediaStream2 : IMFMediaStream
{
    HRESULT SetStreamState(MF_STREAM_STATE value);
    HRESULT GetStreamState(MF_STREAM_STATE* value);
}

///Represents a sensor device that can belong to a sensor group, which is represented by the IMFSensorGroup interface.
///The term "device" in this context could refer to a physical device, a custom media source, or a frame provider.
@GUID("FB9F48F2-2A18-4E28-9730-786F30F04DC4")
interface IMFSensorDevice : IUnknown
{
    ///Gets the unique identifier for the device. This value is currently unused.
    ///Params:
    ///    pDeviceId = The unique identifier for the device.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDeviceId</i> parameter is null. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The sensor
    ///    group has not been initialized. </td> </tr> </table>
    ///    
    HRESULT GetDeviceId(ulong* pDeviceId);
    ///Gets a value that specifies the type of sensor device represented by the object.
    ///Params:
    ///    pType = A value that specifies the type of sensor device represented by the object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pType</i> parameter is null. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The sensor group
    ///    has not been initialized. </td> </tr> </table>
    ///    
    HRESULT GetDeviceType(MFSensorDeviceType* pType);
    ///Gets the flags set for the sensor device. This method is reserved for future use.
    ///Params:
    ///    pFlags = The flags set for the sensor device.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDeviceId</i> parameter is null. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The sensor
    ///    group has not been initialized. </td> </tr> </table>
    ///    
    HRESULT GetFlags(ulong* pFlags);
    ///Gets the symbolic link name of the sensor device.
    ///Params:
    ///    SymbolicLink = Buffer of <i>cchSymbolicLink</i> characters where the symbolic link name will be written. The buffer must be
    ///                   large enough to account for the null terminator.
    ///    cchSymbolicLink = Number of characters available in <i>SymbolicLink</i> buffer.
    ///    pcchWritten = Output parameter containing the number of characters written to <i>SymbolicLink</i>. This includes the null
    ///                  terminator. If <i>SymbolicLink</i> is null and <i>cchSymbolicLink</i> is 0, <i>pcchWritten</i> will contain
    ///                  the number of characters needed (including the null terminator) to store the symbolic link name.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt> </dl> </td> <td width="60%"> The buffer provided in the
    ///    <i>SymbolicLink</i> parameter is not large enough to contain the symbolic link name, including the null
    ///    terminator. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td
    ///    width="60%"> The sensor device has not been initialized. </td> </tr> </table>
    ///    
    HRESULT GetSymbolicLink(PWSTR SymbolicLink, int cchSymbolicLink, int* pcchWritten);
    ///Gets the IMFAttributes for the sensor group.
    ///Params:
    ///    ppAttributes = The IMFAttributes interface representing the internal attribute store of the sensor device.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppAttributes</i> parameter is null. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The sensor
    ///    device has not been initialized. </td> </tr> </table>
    ///    
    HRESULT GetDeviceAttributes(IMFAttributes* ppAttributes);
    ///Gets the count of stream attribute stores for the sensor device. This number represents the number of total
    ///streams available for the device because every valid stream must have an attribute store that contains at least
    ///the stream ID and stream category.
    ///Params:
    ///    eType = A member of the MFSensorStreamType enumeration specifying whether the attribute store count is being
    ///            requested for an input or output stream.
    ///    pdwCount = The number of stream attributes available for this sensor device.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pdwCount</i> parameter is null. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The sensor
    ///    group has not been initialized. </td> </tr> </table>
    ///    
    HRESULT GetStreamAttributesCount(MFSensorStreamType eType, uint* pdwCount);
    ///Gets the stream attribute store with the specified index.
    ///Params:
    ///    eType = A member of the MFSensorStreamType enumeration specifying whether the attribute store is being requested for
    ///            an input or output stream.
    ///    dwIndex = The 0-based index of the stream to be retrieved. The index must be between 0 and the value returned by
    ///              GetStreamAttributesCount - 1.
    ///    ppAttributes = The IMFAttributes interface representing a copy internal attribute store of the stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDeviceId</i> parameter is null. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The sensor
    ///    group has not been initialized. </td> </tr> </table>
    ///    
    HRESULT GetStreamAttributes(MFSensorStreamType eType, uint dwIndex, IMFAttributes* ppAttributes);
    ///Sets a value that specifies the sharing mode of the sensor device to either controller or shared.
    ///Params:
    ///    eMode = A member of the MFSensorDeviceMode enumeration specifying wether the device is in shared or controller mode.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The sensor group has not been
    ///    initialized. </td> </tr> </table>
    ///    
    HRESULT SetSensorDeviceMode(MFSensorDeviceMode eMode);
    ///Gets a value that specifies the current sharing mode of the sensor device, which is either controller or shared.
    ///Params:
    ///    peMode = If the call succeeds, receives a member of the MFSensorDeviceMode, specifying the current mode of the sendsor
    ///             device.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDeviceId</i> parameter is null. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The sensor
    ///    group has not been initialized. </td> </tr> </table>
    ///    
    HRESULT GetSensorDeviceMode(MFSensorDeviceMode* peMode);
}

///Represents a group of sensor devices from which an IMFMediaSource can be created. The term "device" in this context
///could refer to a physical device, a custom media source, or a frame provider. A sensor group may actually contain
///multiple sensor devices, or it could contain only a single device, but it still behaves as a sensor group.
@GUID("4110243A-9757-461F-89F1-F22345BCAB4E")
interface IMFSensorGroup : IUnknown
{
    ///Gets the symbolic link name of the sensor group.
    ///Params:
    ///    SymbolicLink = Buffer of <i>cchSymbolicLink</i> characters where the symbolic link name will be written. The buffer must be
    ///                   large enough to account for the null terminator.
    ///    cchSymbolicLink = Number of characters available in <i>SymbolicLink</i> buffer.
    ///    pcchWritten = Output parameter containing the number of characters written to <i>SymbolicLink</i>. This includes the null
    ///                  terminator. If <i>SymbolicLink</i> is null and <i>cchSymbolicLink</i> is 0, <i>pcchWritten</i> will contain
    ///                  the number of characters needed (including the null terminator) to store the symbolic link name.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt> </dl> </td> <td width="60%"> The buffer provided in the
    ///    <i>SymbolicLink</i> parameter is not large enough to contain the symbolic link name, including the null
    ///    terminator. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td
    ///    width="60%"> The sensor group has not been initialized. </td> </tr> </table>
    ///    
    HRESULT GetSymbolicLink(PWSTR SymbolicLink, int cchSymbolicLink, int* pcchWritten);
    ///Gets the flags set for the sensor group.
    ///Params:
    ///    pFlags = The flags set for the sensor group
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The sensor group has not been
    ///    initialized. </td> </tr> </table>
    ///    
    HRESULT GetFlags(ulong* pFlags);
    ///Gets the IMFAttributes for the sensor group. The returned object is a live reference to the internal attribute
    ///store.
    ///Params:
    ///    ppAttributes = The IMFAttributes interface representing the internal attribute store of the sensor group.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppAttributes</i> parameter is null. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The sensor
    ///    group has not been initialized. </td> </tr> </table>
    ///    
    HRESULT GetSensorGroupAttributes(IMFAttributes* ppAttributes);
    ///Gets the number of devices that are virtualized by the sensor group.
    ///Params:
    ///    pdwCount = The number of devices in the sensor group.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pdwCount</i> parameter is null. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The sensor
    ///    group has not been initialized. </td> </tr> </table>
    ///    
    HRESULT GetSensorDeviceCount(uint* pdwCount);
    ///Gets the IMFSensorDevice corresponding to a device in the sensor group.
    ///Params:
    ///    dwIndex = The 0-based index of the device to be retrieved. The index must be between 0 and the value returned by
    ///              GetSensorDeviceCount - 1.
    ///    ppDevice = If the call is successful, <i>ppDevice</i> will contain the retrieved sensor device.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppDevice</i> parameter is null. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALID_INDEX</b></dt> </dl> </td> <td width="60%"> the
    ///    <i>dwIndex</i> parameter is not in the valid range. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The sensor group has not been initialized.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetSensorDevice(uint dwIndex, IMFSensorDevice* ppDevice);
    ///Configures one of the devices in the sensor group as the default device.
    ///Params:
    ///    dwIndex = 0-based index of the device to be set as defaut. The index must be between 0 and the value returned by
    ///              GetSensorDeviceCount - 1.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALID_INDEX</b></dt> </dl> </td> <td width="60%"> the <i>dwIndex</i> parameter is not in
    ///    the valid range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td
    ///    width="60%"> The sensor group has not been initialized. </td> </tr> </table>
    ///    
    HRESULT SetDefaultSensorDeviceIndex(uint dwIndex);
    ///Retrieves the index of the default device in the sensor group.
    ///Params:
    ///    pdwIndex = If the call succeeds, <i>pdwIndex</i> receives the index of the default device.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pdwIndex</i> parameter is null. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The sensor
    ///    group has not been initialized. </td> </tr> </table>
    ///    
    HRESULT GetDefaultSensorDeviceIndex(uint* pdwIndex);
    ///Creates an IMFMediaSource that virtualizes the sensor group. The term "device" in this context could refer to a
    ///physical device or a software media source. The source can represent a sensor group that actually contains
    ///multiple sensor devices, or it could contain only a single device, but still behaves as a sensor group.
    ///Params:
    ///    ppSource = Receives a pointer to the created media source.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CreateMediaSource(IMFMediaSource* ppSource);
}

///Provides methods for cloning and querying the properties of a sensor stream.
@GUID("E9A42171-C56E-498A-8B39-EDA5A070B7FC")
interface IMFSensorStream : IMFAttributes
{
    ///Gets the count of media types supported by the sensor stream.
    ///Params:
    ///    pdwCount = If the call completes successfully, receives the count of media types supported by the stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pdwCount</i> parameter is null. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetMediaTypeCount(uint* pdwCount);
    ///Retrieves an IMFMediaType representing a supported media type for the sensor stream.
    ///Params:
    ///    dwIndex = The 0-based index of the IMFMediaType to retrieve. This value must be between 0 and the value returned by
    ///              GetMediaTypeCount - 1.
    ///    ppMediaType = The retrieved media type.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppMediaType</i> parameter is null. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDINDEX</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>dwIndex</i> is not in the allowed range. </td> </tr> </table>
    ///    
    HRESULT GetMediaType(uint dwIndex, IMFMediaType* ppMediaType);
    ///Clones the IMFSensorStream.
    ///Params:
    ///    ppStream = If the call is successful, <i>ppStream</i> receives the cloned IMFSensorStream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppStream</i> parameter is null. </td>
    ///    </tr> </table>
    ///    
    HRESULT CloneSensorStream(IMFSensorStream* ppStream);
}

///The interface implemented by sensor transforms to allow the media pipeline to query requirements of the sensor
///transform and to create a runtime instance of the sensor transform.
@GUID("EED9C2EE-66B4-4F18-A697-AC7D3960215C")
interface IMFSensorTransformFactory : IUnknown
{
    HRESULT GetFactoryAttributes(IMFAttributes* ppAttributes);
    ///Called by the media pipeline to initialize the sensor transform.
    ///Params:
    ///    dwMaxTransformCount = The maximum number of transforms allowed in a single transform. In the current release, this is always 1.
    ///    pSensorDevices = A collection of IMFSensorDevice objects representing the available sensors.
    ///    pAttributes = The attribute store to be populated by the sensor transform. The only required attribute for sensor
    ///                  transforms is MF_STF_VERSION_INFO.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT InitializeFactory(uint dwMaxTransformCount, IMFCollection pSensorDevices, IMFAttributes pAttributes);
    ///Called by the media pipeline to get the number of transforms provided by the sensor transform.
    ///Params:
    ///    pdwCount = The number of transforms provided by the sensor transform.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTransformCount(uint* pdwCount);
    ///Called by the media pipeline to get information about a transform provided by the sensor transform.
    ///Params:
    ///    TransformIndex = The index of the transform for which information is being requested. In the current release, this value will
    ///                     always be 0.
    ///    pguidTransformId = Gets the identifier for the transform.
    ///    ppAttributes = The attribute store to be populated.
    ///    ppStreamInformation = A collection of IMFSensorStream objects.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTransformInformation(uint TransformIndex, GUID* pguidTransformId, IMFAttributes* ppAttributes, 
                                    IMFCollection* ppStreamInformation);
    ///Called by the media pipeline to create the transform.
    ///Params:
    ///    guidSensorTransformID = The identifier of the transform to be created.
    ///    pAttributes = The identifier of the transform to be created.
    ///    ppDeviceMFT = The identifier of the transform to be created.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateTransform(const(GUID)* guidSensorTransformID, IMFAttributes pAttributes, 
                            IMFDeviceTransform* ppDeviceMFT);
}

///Describes a media foundation sensor profile.
@GUID("22F765D1-8DAB-4107-846D-56BAF72215E7")
interface IMFSensorProfile : IUnknown
{
    ///Retrieves the sensor profile ID.
    ///Params:
    ///    pId = Pointer to a SENSORPROFILEID containing the profile ID.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetProfileId(SENSORPROFILEID* pId);
    ///Adds a profile filter to the specified media stream.
    ///Params:
    ///    StreamId = The ID of the stream to add to.
    ///    wzFilterSetString = The filter to add.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddProfileFilter(uint StreamId, const(PWSTR) wzFilterSetString);
    ///Determines if a media stream supports the specified media type.
    ///Params:
    ///    StreamId = The ID of the stream to check.
    ///    pMediaType = Pointer to an IMFMediaType describing the media type to check.
    ///    pfSupported = Returns <b>true</b> if the media type is supported; otherwise, <b>false</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IsMediaTypeSupported(uint StreamId, IMFMediaType pMediaType, BOOL* pfSupported);
    ///Adds the specified blocked control .
    ///Params:
    ///    wzBlockedControl = The blocked control to add.
    ///Returns:
    ///    This method does not return a value.
    ///    
    HRESULT AddBlockedControl(const(PWSTR) wzBlockedControl);
}

///Contains a collection of media foundation sensor profile objects.
@GUID("C95EA55B-0187-48BE-9353-8D2507662351")
interface IMFSensorProfileCollection : IUnknown
{
    uint    GetProfileCount();
    ///Retrieves the specified profile.
    ///Params:
    ///    Index = Index of the profile to retrieve.
    ///    ppProfile = On success, returns a double pointer to an IMFSensorProfile object that describes the specified sensor
    ///                profile.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetProfile(uint Index, IMFSensorProfile* ppProfile);
    ///Adds the specified profile to the collection.
    ///Params:
    ///    pProfile = Pointer to an IMFSensorProfile object describing the profile to add.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddProfile(IMFSensorProfile pProfile);
    ///Finds a profile based on the specified profile ID.
    ///Params:
    ///    ProfileId = Pointer to the The ID of the profile to find.
    ///    ppProfile = On success, returns a double pointer to the profile.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT FindProfile(SENSORPROFILEID* ProfileId, IMFSensorProfile* ppProfile);
    ///Removes a profile based on the specified index.
    ///Params:
    ///    Index = The index of the profile to remove.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    void    RemoveProfileByIndex(uint Index);
    ///removes the specified profile based on the specified profile ID.
    ///Params:
    ///    ProfileId = Pointer to the SENSORPROFILEID of the profile to remove.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    void    RemoveProfile(SENSORPROFILEID* ProfileId);
}

///Represents the activity of a process associated with a sensor.
@GUID("39DC7F4A-B141-4719-813C-A7F46162A2B8")
interface IMFSensorProcessActivity : IUnknown
{
    ///Gets the ID of the process with which the activity is associated.
    ///Params:
    ///    pPID = Receives the process ID.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pPID</i> parameter is null. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetProcessId(uint* pPID);
    ///Gets a value indicating whether the sensor is currently streaming.
    ///Params:
    ///    pfStreaming = Receives a value indicating whether the sensor is currently streaming.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pfStreaming</i> parameter is null. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetStreamingState(BOOL* pfStreaming);
    ///Gets the streaming mode of the sensor process.
    ///Params:
    ///    pMode = Receives the process ID.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pMode</i> parameter is null. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetStreamingMode(MFSensorDeviceMode* pMode);
    ///Gets the time associated with the sensor activity report.
    ///Params:
    ///    pft = Receives the time associated with the sensor activity report.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pft</i> parameter is null. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetReportTime(FILETIME* pft);
}

///Represents an activity report for a sensor.
@GUID("3E8C4BE1-A8C2-4528-90DE-2851BDE5FEAD")
interface IMFSensorActivityReport : IUnknown
{
    ///Gets the friendly name for the sensor associated with the report.
    ///Params:
    ///    FriendlyName = The string into which the sensor friendly name is written.
    ///    cchFriendlyName = The character count of the <i>FriendlyName</i> string.
    ///    pcchWritten = Receives the number of characters that were written into the <i>FriendlyName</i> string.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pcchWritten</i> parameter is null. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetFriendlyName(PWSTR FriendlyName, uint cchFriendlyName, uint* pcchWritten);
    ///Gets the symbolic link for the sensor associated with the report.
    ///Params:
    ///    SymbolicLink = The string into which the sensor symbolic link is written.
    ///    cchSymbolicLink = The character count of the <i>SymbolicLink</i> string.
    ///    pcchWritten = Receives the number of characters that were written into the <i>SymbolicLink</i> string.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pcchWritten</i> parameter is null. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetSymbolicLink(PWSTR SymbolicLink, uint cchSymbolicLink, uint* pcchWritten);
    ///Gets the count of IMFSensorProcessActivity objects, representing the current activity of a process associated
    ///with the sensor, that are available to be retrieved.
    ///Params:
    ///    pcCount = A pointer in which the process count is stored.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pulCount</i> parameter is null. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetProcessCount(uint* pcCount);
    ///Gets an IMFSensorProcessActivity object representing the current process activity of a sensor.
    ///Params:
    ///    Index = The index of the IMFSensorProcessActivity to retrieve. This value must be less than the value returned by
    ///            GetProcessCount.
    ///    ppProcessActivity = A pointer to the IMFSensorProcessActivity associated with the specified index.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppProcessActivity</i> parameter is null.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetProcessActivity(uint Index, IMFSensorProcessActivity* ppProcessActivity);
}

///Provides access to IMFSensorActivityReport objects that describe the current activity of a sensor.
@GUID("683F7A5E-4A19-43CD-B1A9-DBF4AB3F7777")
interface IMFSensorActivitiesReport : IUnknown
{
    ///Gets the count of IMFSensorActivityReport objects that are available to be retrieved.
    ///Params:
    ///    pcCount = The count of IMFSensorActivityReport objects that are available to be retrieved.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pcCount</i> parameter is null. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCount(uint* pcCount);
    ///Retrieves an IMFSensorActivityReport based on the specified index.
    ///Params:
    ///    Index = The index of the IMFSensorActivityReport to retrieve. This value must be less than the value returned by
    ///            GetCount.
    ///    sensorActivityReport = A pointer to the IMFSensorActivityReport associated with the specified index.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>sensorActivityReport</i> parameter is
    ///    null. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDINDEX</b></dt> </dl> </td> <td width="60%">
    ///    The <i>Index</i> parameter is not less than value returned by GetCount. </td> </tr> </table>
    ///    
    HRESULT GetActivityReport(uint Index, IMFSensorActivityReport* sensorActivityReport);
    ///Retrieves an IMFSensorActivityReport based on the specified device name.
    ///Params:
    ///    SymbolicName = The symbolic name of the sensor for which the IMFSensorActivityReport is retrieved.
    ///    sensorActivityReport = A pointer to the IMFSensorActivityReport associated with the sensor with the specified symbolic name.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>symbolicName</i> parameter is null.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>sensorActivityReport</i> parameter is null. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The system is out of memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDINDEX</b></dt> </dl> </td> <td width="60%"> The <i>Index</i> parameter
    ///    is not less than value returned by GetCount. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> No sensor with the specified symbolic name was
    ///    found. </td> </tr> </table>
    ///    
    HRESULT GetActivityReportByDeviceName(const(PWSTR) SymbolicName, IMFSensorActivityReport* sensorActivityReport);
}

///Interface implemented by the client to receive callbacks when sensor activity reports are available.
@GUID("DE5072EE-DBE3-46DC-8A87-B6F631194751")
interface IMFSensorActivitiesReportCallback : IUnknown
{
    ///Raised by the media pipeline when a new IMFSensorActivitiesReport is available.
    ///Params:
    ///    sensorActivitiesReport = Receives a pointer to the new IMFSensorActivitiesReport.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnActivitiesReport(IMFSensorActivitiesReport sensorActivitiesReport);
}

///Provides methods for controlling a sensor activity monitor.
@GUID("D0CEF145-B3F4-4340-A2E5-7A5080CA05CB")
interface IMFSensorActivityMonitor : IUnknown
{
    ///Starts the sensor activity monitor.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The sensor activity monitor has already
    ///    been started. </td> </tr> </table>
    ///    
    HRESULT Start();
    ///Stops the sensor activity monitor.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Stop();
}

@GUID("5C595E64-4630-4231-855A-12842F733245")
interface IMFExtendedCameraIntrinsicModel : IUnknown
{
    HRESULT GetModel(MFExtendedCameraIntrinsic_IntrinsicModel* pIntrinsicModel);
    HRESULT SetModel(const(MFExtendedCameraIntrinsic_IntrinsicModel)* pIntrinsicModel);
    HRESULT GetDistortionModelType(MFCameraIntrinsic_DistortionModelType* pDistortionModelType);
}

@GUID("74C2653B-5F55-4EB1-9F0F-18B8F68B7D3D")
interface IMFExtendedCameraIntrinsicsDistortionModel6KT : IUnknown
{
    HRESULT GetDistortionModel(MFCameraIntrinsic_DistortionModel6KT* pDistortionModel);
    HRESULT SetDistortionModel(const(MFCameraIntrinsic_DistortionModel6KT)* pDistortionModel);
}

@GUID("812D5F95-B572-45DC-BAFC-AE24199DDDA8")
interface IMFExtendedCameraIntrinsicsDistortionModelArcTan : IUnknown
{
    HRESULT GetDistortionModel(MFCameraIntrinsic_DistortionModelArcTan* pDistortionModel);
    HRESULT SetDistortionModel(const(MFCameraIntrinsic_DistortionModelArcTan)* pDistortionModel);
}

@GUID("687F6DAC-6987-4750-A16A-734D1E7A10FE")
interface IMFExtendedCameraIntrinsics : IUnknown
{
    HRESULT InitializeFromBuffer(ubyte* pbBuffer, uint dwBufferSize);
    HRESULT GetBufferSize(uint* pdwBufferSize);
    HRESULT SerializeToBuffer(ubyte* pbBuffer, uint* pdwBufferSize);
    HRESULT GetIntrinsicModelCount(uint* pdwCount);
    HRESULT GetIntrinsicModelByIndex(uint dwIndex, IMFExtendedCameraIntrinsicModel* ppIntrinsicModel);
    HRESULT AddIntrinsicModel(IMFExtendedCameraIntrinsicModel pIntrinsicModel);
}

///This interface is used to configure a capture device's extended properties. Supported properties and capabilities are
///defined in the header file defined in ksmedia.h as constants with the naming convention **KSCAMERA_EXTENDEDPROP_**.
@GUID("38E33520-FCA1-4845-A27A-68B7C6AB3789")
interface IMFExtendedCameraControl : IUnknown
{
    ///Queries for property capabilities supported by the capture device.
    ///Returns:
    ///    A ULONGLONG mapping to property capabilities. Supported properties and capabilities are defined in the header
    ///    file defined in ksmedia.h as constants with the naming convention **KSCAMERA_EXTENDEDPROP_**. For more
    ///    information, see
    ///    [KSPROPERTYSETID_ExtendedCameraControl](/windows-hardware/drivers/stream/kspropertysetid-extendedcameracontrol).
    ///    
    ulong   GetCapabilities();
    ///Sets the flags for a property on the capture device.
    ///Params:
    ///    ulFlags = A ULONGLONG mapping to property flags. Supported properties and flags are defined in the header file defined
    ///              in ksmedia.h as constants with the naming convention **KSCAMERA_EXTENDEDPROP_**. For more information, see
    ///              [KSPROPERTYSETID_ExtendedCameraControl](/windows-hardware/drivers/stream/kspropertysetid-extendedcameracontrol).
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT SetFlags(ulong ulFlags);
    ///Queries for property flags on the capture device.
    ///Returns:
    ///    A ULONGLONG mapping to property flags. Supported properties and flags are defined in the header file defined
    ///    in ksmedia.h as constants with the naming convention **KSCAMERA_EXTENDEDPROP_**. For more information, see
    ///    [KSPROPERTYSETID_ExtendedCameraControl](/windows-hardware/drivers/stream/kspropertysetid-extendedcameracontrol).
    ///    
    ulong   GetFlags();
    ///Locks the internal payload buffer contained in the capture device control to enable querying or changing the
    ///payload.
    ///Params:
    ///    ppPayload = Receives a BYTE pointer to the buffer containing the raw payload. The caller should not free the buffer
    ///                directly, but instead should call
    ///                [IMFExtendedCameraControl::UnlockPayload](nf-mfidl-imfextendedcameracontrol-unlockpayload.md) to free the
    ///                resources.
    ///    pulPayload = Receives the size of the buffer returned in *ppPayload*.
    ///Returns:
    ///    On success, returns S_OK.
    ///    
    HRESULT LockPayload(ubyte** ppPayload, uint* pulPayload);
    ///Unlocks the raw payload contained in the capture device control.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT UnlockPayload();
    ///Commits the configured control settings to the camera driver.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT CommitSettings();
}

///Allows apps to retrieve an instance of [IMFExtendedCameraControl](nn-mfidl-imfextendedcameracontrol.md), which is
///used to configure a capture device's extended properties.
@GUID("B91EBFEE-CA03-4AF4-8A82-A31752F4A0FC")
interface IMFExtendedCameraController : IUnknown
{
    ///Gets an instance of [IMFExtendedCameraControl](nn-mfidl-imfextendedcameracontrol.md), which allows an app to get
    ///the current capture device's extended property controls.
    ///Params:
    ///    dwStreamIndex = A **DWORD** indicating stream index to use for this property. Specify
    ///                    [MF_CAPTURE_ENGINE_MEDIASOURCE](/windows/win32/medfound/mf-capture-engine-mediasource-config) to indicate
    ///                    that the extended property is a filter-level property.
    ///    ulPropertyId = The ID indicating the index for identifying the property within
    ///                   [KSPROPERTYSETID_ExtendedCameraControl](/windows-hardware/drivers/stream/kspropertysetid-extendedcameracontrol
    ///                   ).
    ///    ppControl = Receives a pointer to the **IMFExtendedCameraControl** instance that represents the requested control.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT GetExtendedCameraControl(uint dwStreamIndex, uint ulPropertyId, IMFExtendedCameraControl* ppControl);
}

///This interface is used to retrieve the current relative panel location for a display region.
@GUID("F25362EA-2C0E-447F-81E2-755914CDC0C3")
interface IMFRelativePanelReport : IUnknown
{
    ///Gets a value from the [ACPI_PLD_PANEL](/windows-hardware/drivers/ddi/acpitabl/ne-acpitabl-_acpi_pld_panel)
    ///enumeration indicating the location of the capture device, relative to the display provided to
    ///[MFCreateRelativePanelWatcher](nf-mfidl-mfcreaterelativepanelwatcher).
    ///Params:
    ///    panel = Receives a pointer to a **ULONG** value from the **ACPI_PLD_PANEL** enumeration.
    ///Returns:
    ///    The function returns an **HRESULT**. Possible values include, but are not limited to, those in the following
    ///    table. | Return code | Description | |--------------|------------------------| |S_OK | The function
    ///    succeeded.|
    ///    
    HRESULT GetRelativePanel(uint* panel);
}

///Monitors the panel associated with a display, so that the app receives notifications when the relative location of
///the panel changes.
@GUID("421AF7F6-573E-4AD0-8FDA-2E57CEDB18C6")
interface IMFRelativePanelWatcher : IMFShutdown
{
    ///Begins an asynchronous request to get an [IMFRelativePanelReport](nn-mfidl-imfrelativepanelreport) interface that
    ///represents the relative panel location.
    ///Params:
    ///    pCallback = Pointer to the [IMFAsyncCallback](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) interface of
    ///                a callback object. The caller must implement this interface.
    ///    pState = Pointer to the IUnknown interface of a state object, defined by the caller. This parameter can be NULL. You
    ///             can use this object to hold state information. The object is returned to the caller when the callback is
    ///             invoked.
    ///Returns:
    ///    The function returns an **HRESULT**. Possible values include, but are not limited to, those in the following
    ///    table. | Return code | Description | |--------------|------------------------| |S_OK | The function
    ///    succeeded.|
    ///    
    HRESULT BeginGetReport(IMFAsyncCallback pCallback, IUnknown pState);
    ///Ends an asynchronous request to get an [IMFRelativePanelReport](nn-mfidl-imfrelativepanelreport) interface that
    ///represents the relative panel location.
    ///Params:
    ///    pResult = Pointer to the [IMFAsyncResult](/windows/desktop/api/mfobjects/nn-mfobjects-imfasyncresult) interface. Pass
    ///              in the same pointer that your callback object received in the Invoke method.
    ///    ppRelativePanelReport = A pointer to he [IMFRelativePanelReport](nn-mfidl-imfrelativepanelreport) interface that represents the
    ///                            relative panel location.
    ///Returns:
    ///    The function returns an **HRESULT**. Possible values include, but are not limited to, those in the following
    ///    table. | Return code | Description | |--------------|------------------------| |S_OK | The function
    ///    succeeded.|
    ///    
    HRESULT EndGetReport(IMFAsyncResult pResult, IMFRelativePanelReport* ppRelativePanelReport);
    ///Gets an [IMFRelativePanelReport](nn-mfidl-imfrelativepanelreport) interface that represents the relative panel
    ///location.
    ///Params:
    ///    ppRelativePanelReport = A pointer to he [IMFRelativePanelReport](nn-mfidl-imfrelativepanelreport) interface that represents the
    ///                            relative panel location.
    ///Returns:
    ///    The function returns an **HRESULT**. Possible values include, but are not limited to, those in the following
    ///    table. | Return code | Description | |--------------|------------------------| |S_OK | The function
    ///    succeeded.|
    ///    
    HRESULT GetReport(IMFRelativePanelReport* ppRelativePanelReport);
}

///Allocates video samples for a video media sink with specialized functionality for video capture devices.
@GUID("725B77C7-CA9F-4FE5-9D72-9946BF9B3C70")
interface IMFVideoCaptureSampleAllocator : IMFVideoSampleAllocator
{
    ///Initializes the sample allocator with parameters relevant to video capture scenarios.
    ///Params:
    ///    cbSampleSize = A DWORD specifying the sample size in bytes. The actual sample size used by the allocator is the maximum of
    ///                   the size required by pMediaType and cbSampleSize.
    ///    cbCaptureMetadataSize = A DWORD specifying the capture metadata size in bytes. Applies only to callers that want to to include
    ///                            additional metadata with the captured frames. The metadata size should include the size of a
    ///                            [KSCAMERA_METADATA_ITEMHEADER](/windows-hardware/drivers/ddi/ksmedia/ns-ksmedia-tagkscamera_metadata_itemheader)
    ///                            in addition to the size of the metadata payload itself.
    ///    cbAlignment = A DWORD specifying the buffer alignment size in bytes. The default and minimum alignment size is 4KB. Custom
    ///                  alignment sizes less than 4KB will be treated as 4KB.
    ///    cMinimumSamples = A DWORD specifying the minimum number of pre-allocated samples. This method will fail if the allocator cannot
    ///                      pre-allocate the specified minimum number of samples.
    ///    pAttributes = Optional. An [IMFAttributes](../mfobjects/nn-mfobjects-imfattributes.md) store with additional configuration
    ///                  attributes for the sample allocator. The supported attributes are: -
    ///                  [MF_SA_BUFFERS_PER_SAMPLE](/windows/win32/medfound/mf-sa-buffers-per-sample) -
    ///                  [MF_SA_D3D11_BINDFLAGS](/windows/win32/medfound/mf-sa-d3d11-bindflags) -
    ///                  [MF_SA_D3D11_USAGE](/windows/win32/medfound/mf-sa-d3d11-usage) -
    ///                  [MF_SA_D3D11_SHARED](/windows/win32/medfound/mf-sa-d3d11-shared) -
    ///                  [MF_SA_D3D11_SHARED_WITHOUT_MUTEX](/windows/win32/medfound/mf-sa-d3d11-shared-without-mutex)
    ///    pMediaType = An [IMFMediaType](../mfobjects/nn-mfobjects-imfmediatype.md) specifying the media type for which samples will
    ///                 be allocator. The sample allocator uses this parameter to calculate the minimum required size for the media
    ///                 samples.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. | Return code | Description | |---------------|---------------| | S_OK | The method succeeded. |
    ///    |MF_E_INVALIDMEDIATYPE | Invalid media type. |
    ///    
    HRESULT InitializeCaptureSampleAllocator(uint cbSampleSize, uint cbCaptureMetadataSize, uint cbAlignment, 
                                             uint cMinimumSamples, IMFAttributes pAttributes, 
                                             IMFMediaType pMediaType);
}

///Implemented by video capture sources and transforms. Allows the system to provide components with a sample allocator
///to allocate samples using memory that is accessible from within a container.
@GUID("DA62B958-3A38-4A97-BD27-149C640C0771")
interface IMFSampleAllocatorControl : IUnknown
{
    ///Sets the default sample allocator to use for the specified output stream.
    ///Params:
    ///    dwOutputStreamID = The ID of the output stream that the *pAllocator* parameter applies to.
    ///    pAllocator = Receives a pointer to a sample allocator to use for the specified output stream. The allocator supports one
    ///                 of the MF allocator interfaces, such as
    ///                 [IMFVideoCaptureSampleAllocator](nn-mfidl-imfvideocapturesampleallocator.md) or
    ///                 [IMFVideoSampleAllocatorEx](nn-mfidl-imfvideosampleallocatorex.md).
    ///Returns:
    ///    The method returns an **HRESULT**.
    ///    
    HRESULT SetDefaultAllocator(uint dwOutputStreamID, IUnknown pAllocator);
    ///Retrieves the sample allocator usage for the specified output stream.
    ///Params:
    ///    dwOutputStreamID = The ID of the output stream whose sample allocator usage is requested.
    ///    pdwInputStreamID = If the allocator usage is [MFSampleAllocatorUsage_DoesNotAllocate](ne-mfidl-mfsampleallocatorusage.md), then
    ///                       this output parameter is set to the ID of the input stream that the output samples are coming from. For all
    ///                       other allocator usage values, this parameter is ignored.
    ///    peUsage = A member of the [MFSampleAllocatorUsage](ne-mfidl-mfsampleallocatorusage.md) enumeration specifying the
    ///              sample allocator usage of the specified output stream.
    ///Returns:
    ///    The method returns an **HRESULT**.
    ///    
    HRESULT GetAllocatorUsage(uint dwOutputStreamID, uint* pdwInputStreamID, MFSampleAllocatorUsage* peUsage);
}

///Provides methods to work with the header section of files conforming to the Advanced Systems Format (ASF)
///specification. The ASF ContentInfo Object exposes this interface. To create the get a pointer to the
///<b>IMFASFContentInfo</b> interface, call MFCreateASFContentInfo.
@GUID("B1DCA5CD-D5DA-4451-8E9E-DB5C59914EAD")
interface IMFASFContentInfo : IUnknown
{
    ///Retrieves the size of the header section of an Advanced Systems Format (ASF) file.
    ///Params:
    ///    pIStartOfContent = The IMFMediaBuffer interface of a buffer object containing the beginning of ASF content. The size of the
    ///                       valid data in the buffer must be at least MFASF_MIN_HEADER_BYTES in bytes.
    ///    cbHeaderSize = Receives the size, in bytes, of the header section of the content. The value includes the size of the ASF
    ///                   Header Object plus the size of the header section of the Data Object. Therefore, the resulting value is the
    ///                   offset to the start of the data packets in the ASF Data Object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ASF_INVALIDDATA</b></dt> </dl> </td> <td width="60%"> The buffer does not contain valid ASF
    ///    data. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td width="60%">
    ///    The buffer does not contain enough valid data. </td> </tr> </table>
    ///    
    HRESULT GetHeaderSize(IMFMediaBuffer pIStartOfContent, ulong* cbHeaderSize);
    ///Parses the information in an ASF header and uses that information to set values in the ContentInfo object. You
    ///can pass the entire header in a single buffer or send it in several pieces.
    ///Params:
    ///    pIHeaderBuffer = Pointer to the IMFMediaBuffer interface of a buffer object containing some or all of the header. The buffer
    ///                     must contain at least 30 bytes, which is the size of the Header Object, not including the objects contained
    ///                     in the Header Object (that is, everything up to and including the Reserved2 field in the Header Object).
    ///    cbOffsetWithinHeader = Offset, in bytes, of the first byte in the buffer relative to the beginning of the header.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The header is completely parsed and validated. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>MF_E_ASF_INVALIDDATA</b></dt> </dl> </td> <td width="60%"> The input buffer
    ///    does not contain valid ASF data. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_BUFFERTOOSMALL</b></dt>
    ///    </dl> </td> <td width="60%"> The input buffer is to small. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_S_ASF_PARSEINPROGRESS</b></dt> </dl> </td> <td width="60%"> The method succeeded, but the header
    ///    passed was incomplete. This is the successful return code for all calls but the last one when passing the
    ///    header in pieces. </td> </tr> </table>
    ///    
    HRESULT ParseHeader(IMFMediaBuffer pIHeaderBuffer, ulong cbOffsetWithinHeader);
    ///Encodes the data in the <b>MFASFContentInfo</b> object into a binary Advanced Systems Format (ASF) header.
    ///Params:
    ///    pIHeader = A pointer to the IMFMediaBuffer interface of the buffer object that will receive the encoded header. Set to
    ///               <b>NULL</b> to retrieve the size of the header.
    ///    pcbHeader = Size of the encoded ASF header in bytes. If <i>pIHeader</i> is <b>NULL</b>, this value is set to the buffer
    ///                size required to hold the encoded header.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The ASF Header Objects do not exist for
    ///    the media that the ContentInfo object holds reference to. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_ASF_INVALIDDATA</b></dt> </dl> </td> <td width="60%"> The ASF Header Object size exceeds 10 MB.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td width="60%"> The
    ///    buffer passed in <i>pIHeader</i> is not large enough to hold the ASF Header Object information. </td> </tr>
    ///    </table>
    ///    
    HRESULT GenerateHeader(IMFMediaBuffer pIHeader, uint* pcbHeader);
    ///Retrieves an Advanced Systems Format (ASF) profile that describes the ASF content.
    ///Params:
    ///    ppIProfile = Receives an IMFASFProfile interface pointer. The caller must release the interface. If the object does not
    ///                 have an ASF profile, this parameter receives the value <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetProfile(IMFASFProfile* ppIProfile);
    ///Uses profile data from a profile object to configure settings in the ContentInfo object.
    ///Params:
    ///    pIProfile = The IMFASFProfile interface of the profile object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetProfile(IMFASFProfile pIProfile);
    ///Creates a presentation descriptor for ASF content.
    ///Params:
    ///    ppIPresentationDescriptor = Receives a pointer to the IMFPresentationDescriptor interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GeneratePresentationDescriptor(IMFPresentationDescriptor* ppIPresentationDescriptor);
    ///Retrieves a property store that can be used to set encoding properties.
    ///Params:
    ///    wStreamNumber = Stream number to configure. Set to zero to configure file-level encoding properties.
    ///    ppIStore = Receives a pointer to the <b>IPropertyStore</b> interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetEncodingConfigurationPropertyStore(ushort wStreamNumber, IPropertyStore* ppIStore);
}

///Manages an Advanced Systems Format (ASF) profile. A profile is a collection of information that describes the
///configuration of streams that will be included in an ASF file. Information about the relationships between streams is
///also included in the profile. An <b>IMFASFProfile</b> interface exists for every ASF profile object. To create an ASF
///profile object, call MFCreateASFProfile or MFCreateASFProfileFromPresentationDescriptor.
@GUID("D267BF6A-028B-4E0D-903D-43F0EF82D0D4")
interface IMFASFProfile : IMFAttributes
{
    ///Retrieves the number of streams in the profile.
    ///Params:
    ///    pcStreams = Receives the number of streams in the profile.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetStreamCount(uint* pcStreams);
    ///Retrieves a stream from the profile by stream index, and/or retrieves the stream number for a stream index.
    ///Params:
    ///    dwStreamIndex = The index of the stream to retrieve. Stream indexes are sequential and zero-based. You can get the number of
    ///                    streams that are in the profile by calling the IMFASFProfile::GetStreamCount method.
    ///    pwStreamNumber = Receives the stream number of the requested stream. Stream numbers are one-based and are not necessarily
    ///                     sequential. This parameter can be set to <b>NULL</b> if the stream number is not required.
    ///    ppIStream = Receives a pointer to the IMFASFStreamConfig interface of the ASF stream configuration object. The caller
    ///                must release the interface. This parameter can be <b>NULL</b> if you want to retrieve the stream number
    ///                without accessing the stream configuration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetStream(uint dwStreamIndex, ushort* pwStreamNumber, IMFASFStreamConfig* ppIStream);
    ///Retrieves an Advanced Systems Format (ASF) stream configuration object for a stream in the profile. This method
    ///references the stream by stream number instead of stream index.
    ///Params:
    ///    wStreamNumber = The stream number for which to obtain the interface pointer.
    ///    ppIStream = Receives a pointer to the IMFASFStreamConfig interface of the ASF stream configuration object. The caller
    ///                must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetStreamByNumber(ushort wStreamNumber, IMFASFStreamConfig* ppIStream);
    ///Adds a stream to the profile or reconfigures an existing stream.
    ///Params:
    ///    pIStream = Pointer to the IMFASFStreamConfig interface of a configured ASF stream configuration object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetStream(IMFASFStreamConfig pIStream);
    ///Removes a stream from the Advanced Systems Format (ASF) profile object.
    ///Params:
    ///    wStreamNumber = Stream number of the stream to remove.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RemoveStream(ushort wStreamNumber);
    ///Creates an Advanced Systems Format (ASF) stream configuration object.
    ///Params:
    ///    pIMediaType = Pointer to the IMFMediaType interface of a configured media type.
    ///    ppIStream = Receives a pointer to the IMFASFStreamConfig interface of the new ASF stream configuration object. The caller
    ///                must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>ppIStream</i> is <b>NULL</b>. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> stream configuration
    ///    object could not be created due to insufficient memory. </td> </tr> </table>
    ///    
    HRESULT CreateStream(IMFMediaType pIMediaType, IMFASFStreamConfig* ppIStream);
    ///Retrieves the number of Advanced Systems Format (ASF) mutual exclusion objects that are associated with the
    ///profile.
    ///Params:
    ///    pcMutexs = Receives the number of mutual exclusion objects.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetMutualExclusionCount(uint* pcMutexs);
    ///Retrieves an Advanced Systems Format (ASF) mutual exclusion object from the profile.
    ///Params:
    ///    dwMutexIndex = Index of the mutual exclusion object in the profile.
    ///    ppIMutex = Receives a pointer to the IMFASFMutualExclusion interface of the ASF mutual exclusion object. The caller must
    ///               release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetMutualExclusion(uint dwMutexIndex, IMFASFMutualExclusion* ppIMutex);
    ///Adds a configured Advanced Systems Format (ASF) mutual exclusion object to the profile.
    ///Params:
    ///    pIMutex = Pointer to the IMFASFMutualExclusion interface of a configured ASF mutual exclusion object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AddMutualExclusion(IMFASFMutualExclusion pIMutex);
    ///Removes an Advanced Systems Format (ASF) mutual exclusion object from the profile.
    ///Params:
    ///    dwMutexIndex = The index of the mutual exclusion object to remove from the profile.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RemoveMutualExclusion(uint dwMutexIndex);
    ///Creates a new Advanced Systems Format (ASF) mutual exclusion object. Mutual exclusion objects can be added to a
    ///profile by calling the AddMutualExclusion method.
    ///Params:
    ///    ppIMutex = Receives a pointer to the IMFASFMutualExclusion interface of the new object. The caller must release the
    ///               interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CreateMutualExclusion(IMFASFMutualExclusion* ppIMutex);
    ///<div class="alert"><b>Note</b> This method is not supported.</div><div> </div>
    ///Params:
    ///    ppIStreamPrioritization = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamPrioritization(IMFASFStreamPrioritization* ppIStreamPrioritization);
    ///<div class="alert"><b>Note</b> This method is not supported.</div><div> </div>
    ///Params:
    ///    pIStreamPrioritization = Reserved.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddStreamPrioritization(IMFASFStreamPrioritization pIStreamPrioritization);
    ///<div class="alert"><b>Note</b> This method is not supported.</div><div> </div>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveStreamPrioritization();
    ///<div class="alert"><b>Note</b> This method is not implemented.</div><div> </div>
    ///Params:
    ///    ppIStreamPrioritization = Reserved.
    ///Returns:
    ///    Returns <b>E_NOTIMPL</b>.
    ///    
    HRESULT CreateStreamPrioritization(IMFASFStreamPrioritization* ppIStreamPrioritization);
    ///Creates a copy of the Advanced Systems Format profile object.
    ///Params:
    ///    ppIProfile = Receives a pointer to the IMFASFProfile interface of the new object. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Clone(IMFASFProfile* ppIProfile);
}

///Configures the settings of a stream in an ASF file. The ASF stream configuration object exposes this interface. To
///obtain a pointer to this interface, call the IMFASFProfile::CreateStream method.
@GUID("9E8AE8D2-DBBD-4200-9ACA-06E6DF484913")
interface IMFASFStreamConfig : IMFAttributes
{
    ///Gets the major media type of the stream.
    ///Params:
    ///    pguidStreamType = Receives the major media type for the stream. For a list of possible values, see Major Media Types.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamType(GUID* pguidStreamType);
    ///Retrieves the stream number of the stream.
    ///Returns:
    ///    The method returns the stream number.
    ///    
    ushort  GetStreamNumber();
    ///Assigns a stream number to the stream.
    ///Params:
    ///    wStreamNum = The number to assign to the stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetStreamNumber(ushort wStreamNum);
    ///Retrieves the media type of the stream.
    ///Params:
    ///    ppIMediaType = Receives a pointer to the IMFMediaType interface of the media type object associated with the stream. The
    ///                   caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetMediaType(IMFMediaType* ppIMediaType);
    ///Sets the media type for the Advanced Systems Format (ASF) stream configuration object.
    ///Params:
    ///    pIMediaType = Pointer to the IMFMediaType interface of a configured media type object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetMediaType(IMFMediaType pIMediaType);
    ///Retrieves the number of payload extensions that are configured for the stream.
    ///Params:
    ///    pcPayloadExtensions = Receives the number of payload extensions.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetPayloadExtensionCount(ushort* pcPayloadExtensions);
    ///Retrieves information about an existing payload extension.
    ///Params:
    ///    wPayloadExtensionNumber = The payload extension index. Valid indexes range from 0, to one less than the number of extensions obtained
    ///                              by calling IMFASFStreamConfig::GetPayloadExtensionCount.
    ///    pguidExtensionSystemID = Receives a GUID that identifies the payload extension. For a list of predefined payload extensions, see ASF
    ///                             Payload Extension GUIDs. Applications can also define custom payload extensions.
    ///    pcbExtensionDataSize = Receives the number of bytes added to each sample for the extension.
    ///    pbExtensionSystemInfo = Pointer to a buffer that receives information about this extension system. This information is the same for
    ///                            all samples and is stored in the content header (not in each sample). This parameter can be <b>NULL</b>. To
    ///                            find the required size of the buffer, set this parameter to <b>NULL</b>; the size is returned in
    ///                            <i>pcbExtensionSystemInfo</i>.
    ///    pcbExtensionSystemInfo = On input, specifies the size of the buffer pointed to by <i>pbExtensionSystemInfo</i>. On output, receives
    ///                             the required size of the <i>pbExtensionSystemInfo</i> buffer in bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td width="60%"> The buffer specified in
    ///    <i>pbExtensionSystemInfo</i> is too small. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALIDINDEX</b></dt> </dl> </td> <td width="60%"> The <i>wPayloadExtensionNumber</i> parameter
    ///    is out of range. </td> </tr> </table>
    ///    
    HRESULT GetPayloadExtension(ushort wPayloadExtensionNumber, GUID* pguidExtensionSystemID, 
                                ushort* pcbExtensionDataSize, ubyte* pbExtensionSystemInfo, 
                                uint* pcbExtensionSystemInfo);
    ///Configures a payload extension for the stream.
    ///Params:
    ///    guidExtensionSystemID = Pointer to a GUID that identifies the payload extension. For a list of predefined payload extensions, see ASF
    ///                            Payload Extension GUIDs. Applications can also define custom payload extensions.
    ///    cbExtensionDataSize = Number of bytes added to each sample for the extension.
    ///    pbExtensionSystemInfo = A pointer to a buffer that contains information about this extension system. This information is the same for
    ///                            all samples and is stored in the content header (not with each sample). This parameter can be <b>NULL</b> if
    ///                            <i>cbExtensionSystemInfo</i> is 0.
    ///    cbExtensionSystemInfo = Amount of data, in bytes, that describes this extension system. If this value is 0, then
    ///                            <i>pbExtensionSystemInfo</i> can be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AddPayloadExtension(GUID guidExtensionSystemID, ushort cbExtensionDataSize, 
                                ubyte* pbExtensionSystemInfo, uint cbExtensionSystemInfo);
    ///Removes all payload extensions that are configured for the stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RemoveAllPayloadExtensions();
    ///Creates a copy of the Advanced Systems Format (ASF) stream configuration object.
    ///Params:
    ///    ppIStreamConfig = Receives a pointer to the IMFASFStreamConfig interface of the new object. The caller must release the
    ///                      interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Clone(IMFASFStreamConfig* ppIStreamConfig);
}

///Configures an Advanced Systems Format (ASF) mutual exclusion object, which manages information about a group of
///streams in an ASF profile that are mutually exclusive. When streams or groups of streams are mutually exclusive, only
///one of them is read at a time, they are not read concurrently. A common example of mutual exclusion is a set of
///streams that each include the same content encoded at a different bit rate. The stream that is used is determined by
///the available bandwidth to the reader. An <b>IMFASFMutualExclusion</b> interface exists for every ASF mutual
///exclusion object. A pointer to this interface is obtained when you create the object using the
///IMFASFProfile::CreateMutualExclusion method.
@GUID("12558291-E399-11D5-BC2A-00B0D0F3F4AB")
interface IMFASFMutualExclusion : IUnknown
{
    ///Retrieves the type of mutual exclusion represented by the Advanced Systems Format (ASF) mutual exclusion object.
    ///Params:
    ///    pguidType = A variable that receives the type identifier. For a list of predefined mutual exclusion type constants, see
    ///                ASF Mutual Exclusion Type GUIDs.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetType(GUID* pguidType);
    ///Sets the type of mutual exclusion that is represented by the Advanced Systems Format (ASF) mutual exclusion
    ///object.
    ///Params:
    ///    guidType = The type of mutual exclusion that is represented by the ASF mutual exclusion object. For a list of predefined
    ///               mutual exclusion type constants, see ASF Mutual Exclusion Type GUIDs.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetType(const(GUID)* guidType);
    ///Retrieves the number of records in the Advanced Systems Format mutual exclusion object.
    ///Params:
    ///    pdwRecordCount = Receives the count of records.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetRecordCount(uint* pdwRecordCount);
    ///Retrieves the stream numbers contained in a record in the Advanced Systems Format mutual exclusion object.
    ///Params:
    ///    dwRecordNumber = The number of the record for which to retrieve the stream numbers.
    ///    pwStreamNumArray = An array that receives the stream numbers. Set to <b>NULL</b> to get the number of elements required, which
    ///                       is indicated by the value of <i>pcStreams</i> on return. If this parameter is not <b>NULL</b>, the method
    ///                       will copy as many stream numbers to the array as there are elements indicated by the value of
    ///                       <i>pcStreams</i>.
    ///    pcStreams = On input, the number of elements in the array referenced by <i>pwStreamNumArray</i>. On output, the method
    ///                sets this value to the count of stream numbers in the record. You can call <b>GetStreamsForRecord</b> with
    ///                <i>pwStreamNumArray</i> set to <b>NULL</b> to retrieve the number of elements required to hold all of the
    ///                stream numbers.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetStreamsForRecord(uint dwRecordNumber, ushort* pwStreamNumArray, uint* pcStreams);
    ///Adds a stream number to a record in the Advanced Systems Format mutual exclusion object.
    ///Params:
    ///    dwRecordNumber = The record number to which the stream is added. A record number is set by the
    ///                     IMFASFMutualExclusion::AddRecord method.
    ///    wStreamNumber = The stream number to add to the record.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The specified stream number is already
    ///    associated with the record. </td> </tr> </table>
    ///    
    HRESULT AddStreamForRecord(uint dwRecordNumber, ushort wStreamNumber);
    ///Removes a stream number from a record in the Advanced Systems Format mutual exclusion object.
    ///Params:
    ///    dwRecordNumber = The record number from which to remove the stream number.
    ///    wStreamNumber = The stream number to remove from the record.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The stream number is not listed for the
    ///    specified record. </td> </tr> </table>
    ///    
    HRESULT RemoveStreamFromRecord(uint dwRecordNumber, ushort wStreamNumber);
    ///Removes a record from the Advanced Systems Format (ASF) mutual exclusion object.
    ///Params:
    ///    dwRecordNumber = The index of the record to remove.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RemoveRecord(uint dwRecordNumber);
    ///Adds a record to the mutual exclusion object. A record specifies streams that are mutually exclusive with the
    ///streams in all other records.
    ///Params:
    ///    pdwRecordNumber = Receives the index assigned to the new record. Record indexes are zero-based and sequential.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT AddRecord(uint* pdwRecordNumber);
    ///Creates a copy of the Advanced Systems Format mutual exclusion object.
    ///Params:
    ///    ppIMutex = Receives a pointer to the IMFASFMutualExclusion interface of the new object. The caller must release the
    ///               interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Clone(IMFASFMutualExclusion* ppIMutex);
}

///<div class="alert"><b>Note</b> This interface is not implemented.</div><div> </div>Manages information about the
///relative priorities of a group of streams in an Advanced Systems Format (ASF) profile. This interface manages
///information about the relative priorities of a group of streams in an ASF profile. Priority is used in streaming to
///determine which streams should be dropped first when available bandwidth decreases. The ASF stream prioritization
///object exposes this interface. The stream prioritization object maintains a list of stream numbers in priority order.
///The methods of this interface manipulate and interrogate that list. To obtain a pointer to this interface, call the
///IMFASFProfile::CreateStreamPrioritization method.
@GUID("699BDC27-BBAF-49FF-8E38-9C39C9B5E088")
interface IMFASFStreamPrioritization : IUnknown
{
    ///<div class="alert"><b>Note</b> This interface is not implemented in this version of Media Foundation.</div> <div>
    ///</div> Retrieves the number of entries in the stream priority list.
    ///Params:
    ///    pdwStreamCount = Receives the number of streams in the stream priority list.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetStreamCount(uint* pdwStreamCount);
    ///<div class="alert"><b>Note</b> This interface is not implemented in this version of Media Foundation.</div> <div>
    ///</div> Retrieves the stream number of a stream in the stream priority list.
    ///Params:
    ///    dwStreamIndex = Zero-based index of the entry to retrieve from the stream priority list. To get the number of entries in the
    ///                    priority list, call IMFASFStreamPrioritization::GetStreamCount.
    ///    pwStreamNumber = Receives the stream number of the stream priority entry.
    ///    pwStreamFlags = Receives a Boolean value. If <b>TRUE</b>, the stream is mandatory.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <b>NULL</b> pointer argument or the
    ///    <i>dwStreamIndex</i> parameter is out of range. </td> </tr> </table>
    ///    
    HRESULT GetStream(uint dwStreamIndex, ushort* pwStreamNumber, ushort* pwStreamFlags);
    ///<div class="alert"><b>Note</b> This interface is not implemented in this version of Media Foundation.</div> <div>
    ///</div> Adds a stream to the stream priority list.
    ///Params:
    ///    wStreamNumber = Stream number of the stream to add.
    ///    wStreamFlags = If <b>TRUE</b>, the stream is mandatory.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> Invalid stream number. </td> </tr>
    ///    </table>
    ///    
    HRESULT AddStream(ushort wStreamNumber, ushort wStreamFlags);
    ///<div class="alert"><b>Note</b> This interface is not implemented in this version of Media Foundation.</div> <div>
    ///</div> Removes a stream from the stream priority list.
    ///Params:
    ///    dwStreamIndex = Index of the entry in the stream priority list to remove. Values range from zero, to one less than the stream
    ///                    count retrieved by calling IMFASFStreamPrioritization::GetStreamCount.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT RemoveStream(uint dwStreamIndex);
    ///<div class="alert"><b>Note</b> This interface is not implemented in this version of Media Foundation.</div> <div>
    ///</div> Creates a copy of the ASF stream prioritization object.
    ///Params:
    ///    ppIStreamPrioritization = Receives a pointer to the IMFASFStreamPrioritization interface of the new object. The caller must release the
    ///                              interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Clone(IMFASFStreamPrioritization* ppIStreamPrioritization);
}

///Provides methods to work with indexes in Systems Format (ASF) files. The ASF indexer object exposes this interface.
///To create the ASF indexer, call MFCreateASFIndexer.
@GUID("53590F48-DC3B-4297-813F-787761AD7B3E")
interface IMFASFIndexer : IUnknown
{
    ///Sets indexer options.
    ///Params:
    ///    dwFlags = Bitwise OR of zero or more flags from the [MFASF_INDEXER_FLAGS](./ne-wmcontainer-mfasf_indexer_flags.md)
    ///              enumeration specifying the indexer options to use.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The indexer object was initialized
    ///    before setting flags for it. For more information, see Remarks. </td> </tr> </table>
    ///    
    HRESULT SetFlags(uint dwFlags);
    ///Retrieves the flags that indicate the selected indexer options.
    ///Params:
    ///    pdwFlags = Receives a bitwise OR of zero or more flags from the
    ///               [MFASF_INDEXER_FLAGS](./ne-wmcontainer-mfasf_indexer_flags.md) enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>pdwFlags</i> is <b>NULL</b>. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetFlags(uint* pdwFlags);
    ///Initializes the indexer object. This method reads information in a ContentInfo object about the configuration of
    ///the content and the properties of the existing index, if present. Use this method before using the indexer for
    ///either writing or reading an index. You must make this call before using any of the other methods of the
    ///IMFASFIndexer interface.
    ///Params:
    ///    pIContentInfo = Pointer to the IMFASFContentInfo interface of the ContentInfo object describing the content with which to use
    ///                    the indexer.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ASF_INVALIDDATA</b></dt> </dl> </td> <td width="60%"> Invalid ASF data. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. </td> </tr>
    ///    </table>
    ///    
    HRESULT Initialize(IMFASFContentInfo pIContentInfo);
    ///Retrieves the offset of the index object from the start of the content.
    ///Params:
    ///    pIContentInfo = Pointer to the IMFASFContentInfo interface of the ContentInfo object that describes the content.
    ///    pcbIndexOffset = Receives the offset of the index relative to the beginning of the content described by the ContentInfo
    ///                     object. This is the position relative to the beginning of the ASF file.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>pIContentInfo</i> is <b>NULL</b> or
    ///    <i>pcbIndexOffset</i> is <b>NULL</b> </td> </tr> </table>
    ///    
    HRESULT GetIndexPosition(IMFASFContentInfo pIContentInfo, ulong* pcbIndexOffset);
    ///Adds byte streams to be indexed.
    ///Params:
    ///    ppIByteStreams = An array of IMFByteStream interface pointers. To get the byte stream, call MFCreateASFIndexerByteStream.
    ///    cByteStreams = The number of pointers in the <i>ppIByteStreams</i> array.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ALREADY_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The indexer object has already
    ///    been initialized and it has packets which have been indexed. </td> </tr> </table>
    ///    
    HRESULT SetIndexByteStreams(IMFByteStream* ppIByteStreams, uint cByteStreams);
    ///Retrieves the number of byte streams that are in use by the indexer object.
    ///Params:
    ///    pcByteStreams = Receives the number of byte streams that are in use by the indexer object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>pcByteStreams</i> is <b>NULL</b>. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetIndexByteStreamCount(uint* pcByteStreams);
    ///Retrieves the index settings for a specified stream and index type.
    ///Params:
    ///    pIndexIdentifier = Pointer to an ASF_INDEX_IDENTIFIER structure that contains the stream number and index type for which to get
    ///                       the status.
    ///    pfIsIndexed = A variable that retrieves a Boolean value specifying whether the index described by <i>pIndexIdentifier</i>
    ///                  has been created.
    ///    pbIndexDescriptor = A buffer that receives the index descriptor. The index descriptor consists of an ASF_INDEX_DESCRIPTOR
    ///                        structure, optionally followed by index-specific data.
    ///    pcbIndexDescriptor = On input, specifies the size, in bytes, of the buffer that <i>pbIndexDescriptor</i> points to. The value can
    ///                         be zero if <i>pbIndexDescriptor</i> is <b>NULL</b>. On output, receives the size of the index descriptor, in
    ///                         bytes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td width="60%"> The buffer size specified in
    ///    <i>pcbIndexDescriptor</i> is too small. </td> </tr> </table>
    ///    
    HRESULT GetIndexStatus(ASF_INDEX_IDENTIFIER* pIndexIdentifier, BOOL* pfIsIndexed, ubyte* pbIndexDescriptor, 
                           uint* pcbIndexDescriptor);
    ///Configures the index for a stream.
    ///Params:
    ///    pbIndexDescriptor = The index descriptor to set. The index descriptor is an ASF_INDEX_DESCRIPTOR structure, optionally followed
    ///                        by index-specific data.
    ///    cbIndexDescriptor = The size, in bytes, of the index descriptor.
    ///    fGenerateIndex = A Boolean value. Set to <b>TRUE</b> to have the indexer create an index of the type specified for the stream
    ///                     specified in the index descriptor.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> At attempt was made to change the index
    ///    status in a seek-only scenario. For more information, see Remarks. </td> </tr> </table>
    ///    
    HRESULT SetIndexStatus(ubyte* pbIndexDescriptor, uint cbIndexDescriptor, BOOL fGenerateIndex);
    ///Given a desired seek time, gets the offset from which the client should start reading data.
    ///Params:
    ///    pvarValue = The value of the index entry for which to get the position. The format of this value varies depending on the
    ///                type of index, which is specified in the index identifier. For time-based indexing, the variant type is
    ///                <b>VT_I8</b> and the value is the desired seek time, in 100-nanosecond units.
    ///    pIndexIdentifier = Pointer to an ASF_INDEX_IDENTIFIER structure that identifies the stream number and index type.
    ///    pcbOffsetWithinData = Receives the offset within the data segment of the ASF Data Object. The offset is in bytes, and is relative
    ///                          to the start of packet 0. The offset gives the starting location from which the client should begin reading
    ///                          from the stream. This location might not correspond exactly to the requested seek time. For reverse playback,
    ///                          if no key frame exists after the desired seek position, this parameter receives the value
    ///                          <b>MFASFINDEXER_READ_FOR_REVERSEPLAYBACK_OUTOFDATASEGMENT</b>. In that case, the seek position should be 1
    ///                          byte pass the end of the data segment.
    ///    phnsApproxTime = Receives the approximate time stamp of the data that is located at the offset returned in the
    ///                     <i>pcbOffsetWithinData</i> parameter. The accuracy of this value is equal to the indexing interval of the ASF
    ///                     index, typically about 1 second. <ul> <li>If the index type specified in <i>pIndexIdentifier</i> is
    ///                     <b>GUID_NULL</b> (time indexing), this parameter can be <b>NULL</b>. </li> <li>For all other index types,
    ///                     this parameter must be <b>NULL</b>. </li> </ul> If the approximate time stamp cannot be determined, this
    ///                     parameter receives the value <b>MFASFINDEXER_APPROX_SEEK_TIME_UNKNOWN</b>.
    ///    pdwPayloadNumberOfStreamWithinPacket = Receives the payload number of the payload that contains the information for the specified stream. Packets
    ///                                           can contain multiple payloads, each containing data for a different stream. This parameter can be
    ///                                           <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ASF_OUTOFRANGE</b></dt> </dl> </td> <td width="60%"> The requested seek time is out of
    ///    range. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NO_INDEX</b></dt> </dl> </td> <td width="60%"> No
    ///    index exists of the specified type for the specified stream. </td> </tr> </table>
    ///    
    HRESULT GetSeekPositionForValue(const(PROPVARIANT)* pvarValue, ASF_INDEX_IDENTIFIER* pIndexIdentifier, 
                                    ulong* pcbOffsetWithinData, long* phnsApproxTime, 
                                    uint* pdwPayloadNumberOfStreamWithinPacket);
    ///Accepts an ASF packet for the file and creates index entries for them.
    ///Params:
    ///    pIASFPacketSample = Pointer to the IMFSample interface of a media sample that contains the ASF packet.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The argument passed in is <b>NULL</b>. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The
    ///    indexer is not initialized. </td> </tr> </table>
    ///    
    HRESULT GenerateIndexEntries(IMFSample pIASFPacketSample);
    ///Adds information about a new index to the ContentInfo object associated with ASF content. You must call this
    ///method before copying the index to the content so that the index will be readable by the indexer later.
    ///Params:
    ///    pIContentInfo = Pointer to the IMFASFContentInfo interface of the ContentInfo object that describes the content.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The caller made an invalid request. For
    ///    more information, see Remarks. </td> </tr> </table>
    ///    
    HRESULT CommitIndex(IMFASFContentInfo pIContentInfo);
    ///Retrieves the size, in bytes, of the buffer required to store the completed index.
    ///Params:
    ///    pcbIndexWriteSpace = Receives the size of the index, in bytes
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INDEX_NOT_COMMITTED</b></dt> </dl> </td> <td width="60%"> The index has not been committed.
    ///    For more information; see Remarks. </td> </tr> </table>
    ///    
    HRESULT GetIndexWriteSpace(ulong* pcbIndexWriteSpace);
    ///Retrieves the completed index from the ASF indexer object.
    ///Params:
    ///    pIIndexBuffer = Pointer to the IMFMediaBuffer interface of a media buffer that receives the index data.
    ///    cbOffsetWithinIndex = The offset of the data to be retrieved, in bytes from the start of the index data. Set to 0 for the first
    ///                          call. If subsequent calls are needed (the buffer is not large enough to hold the entire index), set to the
    ///                          byte following the last one retrieved.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INDEX_NOT_COMMITTED</b></dt> </dl> </td> <td width="60%"> The index was not committed before
    ///    attempting to get the completed index. For more information, see Remarks. </td> </tr> </table>
    ///    
    HRESULT GetCompletedIndex(IMFMediaBuffer pIIndexBuffer, ulong cbOffsetWithinIndex);
}

///Provides methods to read data from an Advanced Systems Format (ASF) file. The ASF splitter object exposes this
///interface. To create the ASF splitter, MFCreateASFSplitter.
@GUID("12558295-E399-11D5-BC2A-00B0D0F3F4AB")
interface IMFASFSplitter : IUnknown
{
    ///Resets the Advanced Systems Format (ASF) splitter and configures it to parse data from an ASF data section.
    ///Params:
    ///    pIContentInfo = Pointer to the IMFASFContentInfo interface of a ContentInfo object that describes the data to be parsed.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pIContentInfo</i> parameter is
    ///    <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT Initialize(IMFASFContentInfo pIContentInfo);
    ///Sets option flags on the Advanced Systems Format (ASF) splitter.
    ///Params:
    ///    dwFlags = A bitwise combination of zero or more members of the MFASF_SPLITTERFLAGS enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The splitter is not initialized. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>dwFlags</i>
    ///    parameter does not contain a valid flag. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The MFASF_SPLITTER_REVERSE flag is set, but
    ///    the content cannot be parsed in reverse. </td> </tr> </table>
    ///    
    HRESULT SetFlags(uint dwFlags);
    ///Retrieves the option flags that are set on the ASF splitter.
    ///Params:
    ///    pdwFlags = Receives the option flags. This value is a bitwise <b>OR</b> of zero or more members of the
    ///               MFASF_SPLITTERFLAGS enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>pdwFlags</i> is <b>NULL</b>. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetFlags(uint* pdwFlags);
    ///Sets the streams to be parsed by the Advanced Systems Format (ASF) splitter.
    ///Params:
    ///    pwStreamNumbers = An array of variables containing the list of stream numbers to select.
    ///    wNumStreams = The number of valid elements in the stream number array.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>pwStreamNumbers</i> is <b>NULL</b> and
    ///    <i>wNumStreams</i> contains a value greater than zero. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> Invalid stream number was passed in the
    ///    array. </td> </tr> </table>
    ///    
    HRESULT SelectStreams(ushort* pwStreamNumbers, ushort wNumStreams);
    ///Gets a list of currently selected streams.
    ///Params:
    ///    pwStreamNumbers = The address of an array of <b>WORDs</b>. This array receives the stream numbers of the selected streams. This
    ///                      parameter can be <b>NULL</b>.
    ///    pwNumStreams = On input, points to a variable that contains the number of elements in the <i>pwStreamNumbers</i> array. Set
    ///                   the variable to zero if <i>pwStreamNumbers</i> is <b>NULL</b>. On output, receives the number of elements
    ///                   that were copied into <i>pwStreamNumbers</i>. Each element is the identifier of a selected stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_BUFFERTOOSMALL</b></dt> </dl> </td> <td width="60%"> The <i>pwStreamNumbers</i>
    ///    array is smaller than the number of selected streams. See Remarks. </td> </tr> </table>
    ///    
    HRESULT GetSelectedStreams(ushort* pwStreamNumbers, ushort* pwNumStreams);
    ///Sends packetized Advanced Systems Format (ASF) data to the ASF splitter for processing.
    ///Params:
    ///    pIBuffer = Pointer to the IMFMediaBuffer interface of a buffer object containing data to be parsed.
    ///    cbBufferOffset = The offset into the data buffer where the splitter should begin parsing. This value is typically set to 0.
    ///    cbLength = The length, in bytes, of the data to parse. This value is measured from the offset specified by
    ///               <i>cbBufferOffset</i>. Set to 0 to process to the end of the buffer.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pIBuffer</i> parameter is <b>NULL</b>.
    ///    The specified offset value in <i>cbBufferOffset</i> is greater than the length of the buffer. The total value
    ///    of <i>cbBufferOffset</i> and <i>cbLength</i> is greater than the length of the buffer. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The
    ///    IMFASFSplitter::Initialize method was not called or the call failed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_NOTACCEPTING</b></dt> </dl> </td> <td width="60%"> The splitter cannot process more input at this
    ///    time. </td> </tr> </table>
    ///    
    HRESULT ParseData(IMFMediaBuffer pIBuffer, uint cbBufferOffset, uint cbLength);
    ///Retrieves a sample from the Advanced Systems Format (ASF) splitter after the data has been parsed.
    ///Params:
    ///    pdwStatusFlags = Receives one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///                     width="40%"><a id="ASF_STATUSFLAGS_INCOMPLETE"></a><a id="asf_statusflags_incomplete"></a><dl>
    ///                     <dt><b>ASF_STATUSFLAGS_INCOMPLETE</b></dt> </dl> </td> <td width="60%"> More samples are ready to be
    ///                     retrieved. Call <b>GetNextSample</b> in a loop until the <i>pdwStatusFlags</i> parameter receives the value
    ///                     zero. </td> </tr> <tr> <td width="40%"><a id="Zero"></a><a id="zero"></a><a id="ZERO"></a><dl>
    ///                     <dt><b>Zero</b></dt> </dl> </td> <td width="60%"> No additional samples are ready. Call
    ///                     IMFASFSplitter::ParseData to give more input data to the splitter. </td> </tr> </table>
    ///    pwStreamNumber = If the method returns a sample in the <i>ppISample</i> parameter, this parameter receives the number of the
    ///                     stream to which the sample belongs.
    ///    ppISample = Receives a pointer to the IMFSample interface of the parsed sample. The caller must release the interface. If
    ///                no samples are ready, this parameter receives the value <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_ASF_INVALIDDATA</b></dt> </dl> </td> <td width="60%"> The ASF data in the buffer is invalid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_ASF_MISSINGDATA</b></dt> </dl> </td> <td width="60%">
    ///    There is a gap in the ASF data. </td> </tr> </table>
    ///    
    HRESULT GetNextSample(uint* pdwStatusFlags, ushort* pwStreamNumber, IMFSample* ppISample);
    ///Resets the Advanced Systems Format (ASF) splitter and releases all pending samples.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Flush();
    ///Retrieves the send time of the last sample received.
    ///Params:
    ///    pdwLastSendTime = Receives the send time of the last sample received.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>pdwLastSendTime</i> is <b>NULL</b>. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetLastSendTime(uint* pdwLastSendTime);
}

///Provides methods to create Advanced Systems Format (ASF) data packets. The methods of this interface process input
///samples into the packets that make up an ASF data section. The ASF multiplexer exposes this interface. To create the
///ASF multiplexer, call MFCreateASFMultiplexer.
@GUID("57BDD80A-9B38-4838-B737-C58F670D7D4F")
interface IMFASFMultiplexer : IUnknown
{
    ///Initializes the multiplexer with the data from an ASF ContentInfo object.
    ///Params:
    ///    pIContentInfo = Pointer to the IMFASFContentInfo interface of the <b>MFASFContentInfo</b> object that contains the header
    ///                    information of the new ASF file. The multiplexer will generate data packets for this file.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Initialize(IMFASFContentInfo pIContentInfo);
    ///Sets multiplexer options.
    ///Params:
    ///    dwFlags = Bitwise <b>OR</b> of zero or more members of the MFASF_MULTIPLEXERFLAGS enumeration. These flags specify
    ///              which multiplexer options to use. For more information, see "Multiplexer Initialization and Leaky Bucket
    ///              Settings" in Creating the Multiplexer Object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetFlags(uint dwFlags);
    ///Retrieves flags indicating the configured multiplexer options.
    ///Params:
    ///    pdwFlags = Receives a bitwise <b>OR</b> of zero or more values from the MFASF_MULTIPLEXERFLAGS enumeration. To set these
    ///               flags, call IMFASFMultiplexer::SetFlags.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetFlags(uint* pdwFlags);
    ///Delivers input samples to the multiplexer.
    ///Params:
    ///    wStreamNumber = The stream number of the stream to which the sample belongs.
    ///    pISample = Pointer to the IMFSample interface of the input sample. The input sample contains the media data to be
    ///               converted to ASF data packets. When possible, the time stamp of this sample should be accurate.
    ///    hnsTimestampAdjust = The adjustment to apply to the time stamp of the sample. This parameter is used if the caller wants to shift
    ///                         the sample time on <i>pISample</i>. This value should be positive if the time stamp should be pushed ahead
    ///                         and negative if the time stamp should be pushed back. This time stamp is added to sample time on
    ///                         <i>pISample</i>, and the resulting time is used by the multiplexer instead of the original sample time. If no
    ///                         adjustment is needed, set this value to 0.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOTACCEPTING</b></dt> </dl> </td> <td width="60%"> There are too many packets waiting to be
    ///    retrieved from the multiplexer. Call IMFASFMultiplexer::GetNextPacket to get the packets. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>MF_E_BANDWIDTH_OVERRUN</b></dt> </dl> </td> <td width="60%"> The sample that was
    ///    processed violates the bandwidth limitations specified for the stream in the ASF ContentInfo object. When
    ///    this error is generated, the sample is dropped. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> The value passed in
    ///    <i>wStreamNumber</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_LATE_SAMPLE</b></dt>
    ///    </dl> </td> <td width="60%"> The presentation time of the input media sample is earlier than the send time.
    ///    </td> </tr> </table>
    ///    
    HRESULT ProcessSample(ushort wStreamNumber, IMFSample pISample, long hnsTimestampAdjust);
    ///Retrieves the next output ASF packet from the multiplexer.
    ///Params:
    ///    pdwStatusFlags = Receives zero or more status flags. If more than one packet is waiting, the method sets the
    ///                     <b>ASF_STATUSFLAGS_INCOMPLETE</b> flag.
    ///    ppIPacket = Receives a pointer to the IMFSample interface of the first output sample of the data packet. The caller must
    ///                release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetNextPacket(uint* pdwStatusFlags, IMFSample* ppIPacket);
    ///Signals the multiplexer to process all queued output media samples. Call this method after passing the last
    ///sample to the multiplexer.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT Flush();
    ///Collects data from the multiplexer and updates the ASF ContentInfo object to include that information in the ASF
    ///Header Object.
    ///Params:
    ///    pIContentInfo = Pointer to the IMFASFContentInfo interface of the ContentInfo object. This must be the same object that was
    ///                    used to initialize the multiplexer. The ContentInfo object represents the ASF Header Object of the file for
    ///                    which the multiplexer generated data packets.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_FLUSH_NEEDED</b></dt> </dl> </td> <td width="60%"> There are pending output media samples
    ///    waiting in the multiplexer. Call IMFASFMultiplexer::Flush to force the media samples to be packetized. </td>
    ///    </tr> </table>
    ///    
    HRESULT End(IMFASFContentInfo pIContentInfo);
    ///Retrieves multiplexer statistics.
    ///Params:
    ///    wStreamNumber = The stream number for which to obtain statistics.
    ///    pMuxStats = Pointer to an ASF_MUX_STATISTICS structure that receives the statistics.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetStatistics(ushort wStreamNumber, ASF_MUX_STATISTICS* pMuxStats);
    ///Sets the maximum time by which samples from various streams can be out of synchronization. The multiplexer will
    ///not accept a sample with a time stamp that is out of synchronization with the latest samples from any other
    ///stream by an amount that exceeds the synchronization tolerance.
    ///Params:
    ///    msSyncTolerance = Synchronization tolerance in milliseconds.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetSyncTolerance(uint msSyncTolerance);
}

///Selects streams in an Advanced Systems Format (ASF) file, based on the mutual exclusion information in the ASF
///header. The ASF stream selector object exposes this interface. To create the ASF stream selector, call
///MFCreateASFStreamSelector.
@GUID("D01BAD4A-4FA0-4A60-9349-C27E62DA9D41")
interface IMFASFStreamSelector : IUnknown
{
    ///Retrieves the number of streams that are in the Advanced Systems Format (ASF) content.
    ///Params:
    ///    pcStreams = Receives the number of streams in the content.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetStreamCount(uint* pcStreams);
    ///Retrieves the number of outputs for the Advanced Systems Format (ASF) content.
    ///Params:
    ///    pcOutputs = Receives the number of outputs.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetOutputCount(uint* pcOutputs);
    ///Retrieves the number of streams associated with an output.
    ///Params:
    ///    dwOutputNum = The output number for which to retrieve the stream count.
    ///    pcStreams = Receives the number of streams associated with the output.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> Invalid output number. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetOutputStreamCount(uint dwOutputNum, uint* pcStreams);
    ///Retrieves the stream numbers for all of the streams that are associated with an output.
    ///Params:
    ///    dwOutputNum = The output number for which to retrieve stream numbers.
    ///    rgwStreamNumbers = Address of an array that receives the stream numbers associated with the output. The caller allocates the
    ///                       array. The array size must be at least as large as the value returned by the
    ///                       IMFASFStreamSelector::GetOutputStreamCount method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> Invalid output number. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetOutputStreamNumbers(uint dwOutputNum, ushort* rgwStreamNumbers);
    ///Retrieves the output number associated with a stream.
    ///Params:
    ///    wStreamNum = The stream number for which to retrieve an output number.
    ///    pdwOutput = Receives the output number.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> Invalid stream number. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetOutputFromStream(ushort wStreamNum, uint* pdwOutput);
    ///Retrieves the manual output override selection that is set for a stream.
    ///Params:
    ///    dwOutputNum = Stream number for which to retrieve the output override selection.
    ///    pSelection = Receives the output override selection. The value is a member of the ASF_SELECTION_STATUS enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetOutputOverride(uint dwOutputNum, ASF_SELECTION_STATUS* pSelection);
    ///Sets the selection status of an output, overriding other selection criteria.
    ///Params:
    ///    dwOutputNum = Output number for which to set selection.
    ///    Selection = Member of the ASF_SELECTION_STATUS enumeration specifying the level of selection for the output.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetOutputOverride(uint dwOutputNum, ASF_SELECTION_STATUS Selection);
    ///Retrieves the number of mutual exclusion objects associated with an output.
    ///Params:
    ///    dwOutputNum = Output number for which to retrieve the count of mutually exclusive relationships.
    ///    pcMutexes = Receives the number of mutual exclusions.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetOutputMutexCount(uint dwOutputNum, uint* pcMutexes);
    ///Retrieves a mutual exclusion object for an output.
    ///Params:
    ///    dwOutputNum = Output number for which to retrieve a mutual exclusion object.
    ///    dwMutexNum = Mutual exclusion number. This is an index of mutually exclusive relationships associated with the output. Set
    ///                 to a number between 0, and 1 less than the number of mutual exclusion objects retrieved by calling
    ///                 IMFASFStreamSelector::GetOutputMutexCount.
    ///    ppMutex = Receives a pointer to the mutual exclusion object's <b>IUnknown</b> interface. The caller must release the
    ///              interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetOutputMutex(uint dwOutputNum, uint dwMutexNum, IUnknown* ppMutex);
    ///Selects a mutual exclusion record to use for a mutual exclusion object associated with an output.
    ///Params:
    ///    dwOutputNum = The output number for which to set a stream.
    ///    dwMutexNum = Index of the mutual exclusion for which to select.
    ///    wSelectedRecord = Record of the specified mutual exclusion to select.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetOutputMutexSelection(uint dwOutputNum, uint dwMutexNum, ushort wSelectedRecord);
    ///Retrieves the number of bandwidth steps that exist for the content. This method is used for multiple bit rate
    ///(MBR) content.
    ///Params:
    ///    pcStepCount = Receives the number of bandwidth steps.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetBandwidthStepCount(uint* pcStepCount);
    ///Retrieves the stream numbers that apply to a bandwidth step. This method is used for multiple bit rate (MBR)
    ///content.
    ///Params:
    ///    dwStepNum = Bandwidth step number for which to retrieve information. Set this value to a number between 0, and 1 less
    ///                than the number of bandwidth steps returned by IMFASFStreamSelector::GetBandwidthStepCount.
    ///    pdwBitrate = Receives the bit rate associated with the bandwidth step.
    ///    rgwStreamNumbers = Address of an array that receives the stream numbers. The caller allocates the array. The array size must be
    ///                       at least as large as the value returned by the IMFASFStreamSelector::GetStreamCount method.
    ///    rgSelections = Address of an array that receives the selection status of each stream, as an ASF_SELECTION_STATUS value. The
    ///                   members of this array correspond to the members of the <i>rgwStreamNumbers</i> array by index. The caller
    ///                   allocates the array. The array size must be at least as large as the value returned by the
    ///                   IMFASFStreamSelector::GetStreamCount method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetBandwidthStep(uint dwStepNum, uint* pdwBitrate, ushort* rgwStreamNumbers, 
                             ASF_SELECTION_STATUS* rgSelections);
    ///Retrieves the index of a bandwidth step that is appropriate for a specified bit rate. This method is used for
    ///multiple bit rate (MBR) content.
    ///Params:
    ///    dwBitrate = The bit rate to find a bandwidth step for.
    ///    pdwStepNum = Receives the step number. Use this number to retrieve information about the step by calling
    ///                 IMFASFStreamSelector::GetBandwidthStep.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT BitrateToStepNumber(uint dwBitrate, uint* pdwStepNum);
    ///Sets options for the stream selector.
    ///Params:
    ///    dwStreamSelectorFlags = Bitwise [MFASF_STREAMSELECTOR_FLAGS](./ne-wmcontainer-mfasf_streamselector_flags.md) enumeration specifying
    ///                            the options to use.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetStreamSelectorFlags(uint dwStreamSelectorFlags);
}

///Configures Windows Media Digital Rights Management (DRM) for Network Devices on a network sink. The Advanced Systems
///Format (ASF) streaming media sink exposes this interface. To get a pointer to the <b>IMFDRMNetHelper</b> interface,
///perform the following tasks. <ol> <li>Get the activation object for the ASF streaming media sink by calling
///MFCreateASFStreamingMediaSinkActivate.</li> <li>Create the media sink by calling the activation object ActivateObject
///method.</li> <li>Get an <b>IMFDRMNetHelper</b> pointer by calling QueryInterface on the media sink.</li> </ol>For
///more information, see Remarks.
@GUID("3D1FF0EA-679A-4190-8D46-7FA69E8C7E15")
interface IMFDRMNetHelper : IUnknown
{
    ///Gets the license response for the specified request.
    ///Params:
    ///    pLicenseRequest = Pointer to a byte array that contains the license request.
    ///    cbLicenseRequest = Size, in bytes, of the license request.
    ///    ppLicenseResponse = Receives a pointer to a byte array that contains the license response. The caller must free the array by
    ///                        calling CoTaskMemFree.
    ///    pcbLicenseResponse = Receives the size, in bytes, of the license response.
    ///    pbstrKID = Receives the key identifier. The caller must release the string by calling <b>SysFreeString</b>.
    ///Returns:
    ///    The function returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the
    ///    following table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The media sink was shut down. </td> </tr>
    ///    </table>
    ///    
    HRESULT ProcessLicenseRequest(ubyte* pLicenseRequest, uint cbLicenseRequest, ubyte** ppLicenseResponse, 
                                  uint* pcbLicenseResponse, BSTR* pbstrKID);
    ///Not implemented in this release.
    ///Params:
    ///    ppLicenseResponse = Receives a pointer to a byte array that contains the license response. The caller must free the array by
    ///                        calling CoTaskMemFree.
    ///    pcbLicenseResponse = Receives the size, in bytes, of the license response.
    ///Returns:
    ///    The method returns <b>E_NOTIMPL</b>.
    ///    
    HRESULT GetChainedLicenseResponse(ubyte** ppLicenseResponse, uint* pcbLicenseResponse);
}

///Callback interface for receiving events from the capture engine.
@GUID("AEDA51C0-9025-4983-9012-DE597B88B089")
interface IMFCaptureEngineOnEventCallback : IUnknown
{
    ///Called by the capture engine to notify the application of a capture event.
    ///Params:
    ///    pEvent = A pointer to the IMFMediaEvent interface. Use this interface to get information about the event, as described
    ///             in Remarks.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnEvent(IMFMediaEvent pEvent);
}

///Callback interface to receive data from the capture engine.
@GUID("52150B82-AB39-4467-980F-E48BF0822ECD")
interface IMFCaptureEngineOnSampleCallback : IUnknown
{
    ///Called when the capture sink receives a sample.
    ///Params:
    ///    pSample = A pointer to the IMFSample interface. Use this interface to get the time stamp, duration, and stream data.
    ///              For more information, see Media Samples. This parameter can be <b>NULL</b>, so make sure to check for a
    ///              <b>NULL</b> value before you dereference the pointer.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnSample(IMFSample pSample);
}

///Controls a capture sink, which is an object that receives one or more streams from a capture device.
@GUID("72D6135B-35E9-412C-B926-FD5265F2A885")
interface IMFCaptureSink : IUnknown
{
    ///Gets the output format for a stream on this capture sink.
    ///Params:
    ///    dwSinkStreamIndex = The zero-based index of the stream to query. The index is returned in the <i>pdwSinkStreamIndex</i> parameter
    ///                        of the IMFCaptureSink::AddStream method.
    ///    ppMediaType = Receives a pointer to the IMFMediaType interface. The caller must release the pointer.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>dwSinkStreamIndex</i> parameter is invalid. </td> </tr> </table>
    ///    
    HRESULT GetOutputMediaType(uint dwSinkStreamIndex, IMFMediaType* ppMediaType);
    ///Queries the underlying Sink Writer object for an interface.
    ///Params:
    ///    dwSinkStreamIndex = The zero-based index of the stream to query. The index is returned in the <i>pdwSinkStreamIndex</i> parameter
    ///                        of the IMFCaptureSink::AddStream method.
    ///    rguidService = A service identifier GUID. Currently, the value must be <b>GUID_NULL</b>.
    ///    riid = A service identifier GUID. Currently, the value must be <b>IID_IMFSinkWriter</b>.
    ///    ppUnknown = Receives a pointer to the IUnknown interface. The caller must release the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> Invalid request.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%">
    ///    Invalid stream number. </td> </tr> </table>
    ///    
    HRESULT GetService(uint dwSinkStreamIndex, const(GUID)* rguidService, const(GUID)* riid, IUnknown* ppUnknown);
    ///Connects a stream from the capture source to this capture sink.
    ///Params:
    ///    dwSourceStreamIndex = The source stream to connect. The value can be any of the following. <table> <tr> <th>Value</th>
    ///                          <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The
    ///                          zero-based index of a stream. To get the number of streams, call IMFCaptureSource::GetDeviceStreamCount.
    ///                          </td> </tr> <tr> <td width="40%"><a id="MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_photo_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</b></b></dt> <dt>0xFFFFFFFB</dt> </dl> </td> <td
    ///                          width="60%"> The first image stream. </td> </tr> <tr> <td width="40%"><a
    ///                          id="MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_video_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</b></b></dt> <dt>0xFFFFFFFC</dt> </dl> </td> <td
    ///                          width="60%"> The first video stream. </td> </tr> <tr> <td width="40%"><a
    ///                          id="MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_audio_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</b></b></dt> <dt>0xFFFFFFFD</dt> </dl> </td> <td
    ///                          width="60%"> The first audio stream. </td> </tr> </table>
    ///    pMediaType = An IMFMediaType pointer that specifies the desired format of the output stream. The details of the format
    ///                 will depend on the capture sink. <ul> <li>Photo sink: A still image format compatible with Windows Imaging
    ///                 Component (WIC).</li> <li>Preview sink: An uncompressed audio or video format.</li> <li>Record sink: The
    ///                 audio or video format that will be written to the output file.</li> </ul>
    ///    pAttributes = A pointer to the IMFAttributes interface. For compressed streams, you can use this parameter to configure the
    ///                  encoder. This parameter can also be <b>NULL</b>. For the preview sink, set this parameter to <b>NULL</b>.
    ///    pdwSinkStreamIndex = Receives the index of the new stream on the capture sink. Note that this index will not necessarily match the
    ///                         value of <i>dwSourceStreamIndex</i>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> The format specified in
    ///    <i>pMediaType</i> is not valid for this capture sink. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> The <i>dwSourceStreamIndex</i>
    ///    parameter is invalid, or the specified source stream was already connected to this sink. </td> </tr> </table>
    ///    
    HRESULT AddStream(uint dwSourceStreamIndex, IMFMediaType pMediaType, IMFAttributes pAttributes, 
                      uint* pdwSinkStreamIndex);
    ///Prepares the capture sink by loading any required pipeline components, such as encoders, video processors, and
    ///media sinks.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> Invalid request. </td>
    ///    </tr> </table>
    ///    
    HRESULT Prepare();
    ///Removes all streams from the capture sink.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveAllStreams();
}

///Controls the recording sink. The recording sink creates compressed audio/video files or compressed audio/video
///streams.
@GUID("3323B55A-F92A-4FE2-8EDC-E9BFC0634D77")
interface IMFCaptureRecordSink : IMFCaptureSink
{
    ///Specifies a byte stream that will receive the data for the recording.
    ///Params:
    ///    pByteStream = A pointer to the IMFByteStream interface of a byte stream. The byte stream must be writable.
    ///    guidContainerType = A GUID that specifies the file container type. Possible values are documented in the
    ///                        MF_TRANSCODE_CONTAINERTYPE attribute.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOutputByteStream(IMFByteStream pByteStream, const(GUID)* guidContainerType);
    ///Specifies the name of the output file for the recording.
    ///Params:
    ///    fileName = A null-terminated string that contains the URL of the output file.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOutputFileName(const(PWSTR) fileName);
    ///Sets a callback to receive the recording data for one stream.
    ///Params:
    ///    dwStreamSinkIndex = The zero-based index of the stream. The index is returned in the <i>pdwSinkStreamIndex</i> parameter of the
    ///                        IMFCaptureSink::AddStream method.
    ///    pCallback = A pointer to the IMFCaptureEngineOnSampleCallback interface. The caller must implement this interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSampleCallback(uint dwStreamSinkIndex, IMFCaptureEngineOnSampleCallback pCallback);
    ///Sets a custom media sink for recording.
    ///Params:
    ///    pMediaSink = A pointer to the IMFMediaSink interface of the media sink.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCustomSink(IMFMediaSink pMediaSink);
    ///Gets the rotation that is currently being applied to the recorded video stream.
    ///Params:
    ///    dwStreamIndex = The zero-based index of the stream. You must specify a video stream.
    ///    pdwRotationValue = Receives the image rotation, in degrees.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRotation(uint dwStreamIndex, uint* pdwRotationValue);
    ///Rotates the recorded video stream.
    ///Params:
    ///    dwStreamIndex = The zero-based index of the stream to rotate. You must specify a video stream.
    ///    dwRotationValue = The amount to rotate the video, in degrees. Valid values are 0, 90, 180, and 270. The value zero restores the
    ///                      video to its original orientation.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetRotation(uint dwStreamIndex, uint dwRotationValue);
}

///Controls the preview sink. The preview sink enables the application to preview audio and video from the camera.
@GUID("77346CFD-5B49-4D73-ACE0-5B52A859F2E0")
interface IMFCapturePreviewSink : IMFCaptureSink
{
    ///Specifies a window for preview.
    ///Params:
    ///    handle = A handle to the window. The preview sink draws the video frames inside this window.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetRenderHandle(HANDLE handle);
    ///Specifies a Microsoft DirectComposition visual for preview.
    ///Params:
    ///    pSurface = A pointer to a DirectComposition visual that implements the IDCompositionVisual interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetRenderSurface(IUnknown pSurface);
    ///Updates the video frame. Call this method when the preview window receives a WM_PAINT or WM_SIZE message.
    ///Params:
    ///    pSrc = A pointer to an MFVideoNormalizedRect structure that specifies the source rectangle. The source rectangle
    ///           defines the area of the video frame that is displayed. If this parameter is <b>NULL</b>, the entire video
    ///           frame is displayed.
    ///    pDst = A pointer to a RECT structure that specifies the destination rectangle. The destination rectangle defines the
    ///           area of the window or DirectComposition visual where the video is drawn.
    ///    pBorderClr = The border color. Use the RGB macro to create this value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UpdateVideo(const(MFVideoNormalizedRect)* pSrc, const(RECT)* pDst, const(uint)* pBorderClr);
    ///Sets a callback to receive the preview data for one stream.
    ///Params:
    ///    dwStreamSinkIndex = The zero-based index of the stream. The index is returned in the <i>pdwSinkStreamIndex</i> parameter of the
    ///                        IMFCaptureSink::AddStream method.
    ///    pCallback = A pointer to the IMFCaptureEngineOnSampleCallback interface. The caller must implement this interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSampleCallback(uint dwStreamSinkIndex, IMFCaptureEngineOnSampleCallback pCallback);
    ///Gets the current mirroring state of the video preview stream.
    ///Params:
    ///    pfMirrorState = Receives the value <b>TRUE</b> if mirroring is enabled, or <b>FALSE</b> if mirroring is disabled.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMirrorState(BOOL* pfMirrorState);
    ///Enables or disables mirroring of the video preview stream.
    ///Params:
    ///    fMirrorState = If <b>TRUE</b>, mirroring is enabled. If <b>FALSE</b>, mirror is disabled.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetMirrorState(BOOL fMirrorState);
    ///Gets the rotation of the video preview stream.
    ///Params:
    ///    dwStreamIndex = The zero-based index of the stream. You must specify a video stream.
    ///    pdwRotationValue = Receives the image rotation, in degrees.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRotation(uint dwStreamIndex, uint* pdwRotationValue);
    ///Rotates the video preview stream.
    ///Params:
    ///    dwStreamIndex = The zero-based index of the stream to rotate. You must specify a video stream.
    ///    dwRotationValue = The amount to rotate the video, in degrees. Valid values are 0, 90, 180, and 270. The value zero restores the
    ///                      video to its original orientation.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetRotation(uint dwStreamIndex, uint dwRotationValue);
    ///Sets a custom media sink for preview.
    ///Params:
    ///    pMediaSink = A pointer to the IMFMediaSink interface of the media sink.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCustomSink(IMFMediaSink pMediaSink);
}

///Controls the photo sink. The photo sink captures still images from the video stream.
@GUID("D2D43CC8-48BB-4AA7-95DB-10C06977E777")
interface IMFCapturePhotoSink : IMFCaptureSink
{
    ///Specifies the name of the output file for the still image.
    ///Params:
    ///    fileName = A null-terminated string that contains the URL of the output file.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOutputFileName(const(PWSTR) fileName);
    ///Sets a callback to receive the still-image data.
    ///Params:
    ///    pCallback = A pointer to the IMFCaptureEngineOnSampleCallback interface. The caller must implement this interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSampleCallback(IMFCaptureEngineOnSampleCallback pCallback);
    ///Specifies a byte stream that will receive the still image data.
    ///Params:
    ///    pByteStream = A pointer to the IMFByteStream interface of a byte stream. The byte stream must be writable.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOutputByteStream(IMFByteStream pByteStream);
}

///Controls the capture source object. The capture source manages the audio and video capture devices.
@GUID("439A42A8-0D2C-4505-BE83-F79B2A05D5C4")
interface IMFCaptureSource : IUnknown
{
    ///Gets the current capture device's IMFMediaSource object pointer.
    ///Params:
    ///    mfCaptureEngineDeviceType = The capture engine device type.
    ///    ppMediaSource = Receives a pointer to the IMFMediaSource that represent the device.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCaptureDeviceSource(MF_CAPTURE_ENGINE_DEVICE_TYPE mfCaptureEngineDeviceType, 
                                   IMFMediaSource* ppMediaSource);
    ///Gets the current capture device's IMFActivate object pointer.
    ///Params:
    ///    mfCaptureEngineDeviceType = The capture engine device type.
    ///    ppActivate = Receives the pointer to a IMFActivate that represents a device.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCaptureDeviceActivate(MF_CAPTURE_ENGINE_DEVICE_TYPE mfCaptureEngineDeviceType, 
                                     IMFActivate* ppActivate);
    ///Gets a pointer to the underlying Source Reader object.
    ///Params:
    ///    rguidService = A service identifier GUID. Currently the value must be <b>IID_IMFSourceReader</b> or <b>GUID_NULL</b>.
    ///    riid = The interface identifier (IID) of the interface being requested. The value must be
    ///           <b>IID_IMFSourceReader</b>. If the value is not set to <b>IID_IMFSourceReader</b>, the call will fail and
    ///           return <b>E_INVALIDARG</b>.
    ///    ppUnknown = Receives a pointer to the IUnknown interface. The caller must release the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The capture
    ///    source was not initialized. Possibly there is no capture device on the system. </td> </tr> </table>
    ///    
    HRESULT GetService(const(GUID)* rguidService, const(GUID)* riid, IUnknown* ppUnknown);
    ///Adds an effect to a capture stream.
    ///Params:
    ///    dwSourceStreamIndex = The capture stream. The value can be any of the following. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///                          <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The zero-based index of a
    ///                          stream. To get the number of streams, call IMFCaptureSource::GetDeviceStreamCount. </td> </tr> <tr> <td
    ///                          width="40%"><a id="MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_photo_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</b></b></dt> <dt>0xFFFFFFFB</dt> </dl> </td> <td
    ///                          width="60%"> The first image stream. </td> </tr> <tr> <td width="40%"><a
    ///                          id="MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_video_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</b></b></dt> <dt>0xFFFFFFFC</dt> </dl> </td> <td
    ///                          width="60%"> The first video stream. </td> </tr> <tr> <td width="40%"><a
    ///                          id="MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_audio_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</b></b></dt> <dt>0xFFFFFFFD</dt> </dl> </td> <td
    ///                          width="60%"> The first audio stream. </td> </tr> </table>
    ///    pUnknown = A pointer to one of the following: <ul> <li>A Media Foundation transform (MFT) that exposes the IMFTransform
    ///               interface.</li> <li>An MFT activation object that exposes the IMFActivate interface.</li> </ul>
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> No compatible media type
    ///    could be found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td>
    ///    <td width="60%"> The <i>dwSourceStreamIndex</i> parameter is invalid. </td> </tr> </table>
    ///    
    HRESULT AddEffect(uint dwSourceStreamIndex, IUnknown pUnknown);
    ///Removes an effect from a capture stream.
    ///Params:
    ///    dwSourceStreamIndex = The capture stream. The value can be any of the following. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///                          <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The zero-based index of a
    ///                          stream. To get the number of streams, call IMFCaptureSource::GetDeviceStreamCount. </td> </tr> <tr> <td
    ///                          width="40%"><a id="MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_photo_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</b></b></dt> <dt>0xFFFFFFFB</dt> </dl> </td> <td
    ///                          width="60%"> The first image stream. </td> </tr> <tr> <td width="40%"><a
    ///                          id="MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_video_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</b></b></dt> <dt>0xFFFFFFFC</dt> </dl> </td> <td
    ///                          width="60%"> The first video stream. </td> </tr> <tr> <td width="40%"><a
    ///                          id="MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_audio_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</b></b></dt> <dt>0xFFFFFFFD</dt> </dl> </td> <td
    ///                          width="60%"> The first audio stream. </td> </tr> </table>
    ///    pUnknown = A pointer to the IUnknown interface of the effect object.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> Invalid request. Possibly
    ///    the specified effect could not be found. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> The <i>dwSourceStreamIndex</i>
    ///    parameter is invalid. </td> </tr> </table>
    ///    
    HRESULT RemoveEffect(uint dwSourceStreamIndex, IUnknown pUnknown);
    ///Removes all effects from a capture stream.
    ///Params:
    ///    dwSourceStreamIndex = The capture stream. The value can be any of the following. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///                          <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The zero-based index of a
    ///                          stream. To get the number of streams, call IMFCaptureSource::GetDeviceStreamCount. </td> </tr> <tr> <td
    ///                          width="40%"><a id="MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_photo_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</b></b></dt> <dt>0xFFFFFFFB</dt> </dl> </td> <td
    ///                          width="60%"> The first image stream. </td> </tr> <tr> <td width="40%"><a
    ///                          id="MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_video_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</b></b></dt> <dt>0xFFFFFFFC</dt> </dl> </td> <td
    ///                          width="60%"> The first video stream. </td> </tr> <tr> <td width="40%"><a
    ///                          id="MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_audio_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</b></b></dt> <dt>0xFFFFFFFD</dt> </dl> </td> <td
    ///                          width="60%"> The first audio stream. </td> </tr> </table>
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>dwSourceStreamIndex</i> parameter is invalid. </td> </tr> </table>
    ///    
    HRESULT RemoveAllEffects(uint dwSourceStreamIndex);
    ///Gets a format that is supported by one of the capture streams.
    ///Params:
    ///    dwSourceStreamIndex = The stream to query. The value can be any of the following. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///                          </tr> <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The zero-based index of
    ///                          a stream. To get the number of streams, call IMFCaptureSource::GetDeviceStreamCount. </td> </tr> <tr> <td
    ///                          width="40%"><a id="MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_photo_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</b></b></dt> <dt>0xFFFFFFFB</dt> </dl> </td> <td
    ///                          width="60%"> The first image stream. </td> </tr> <tr> <td width="40%"><a
    ///                          id="MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_video_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</b></b></dt> <dt>0xFFFFFFFC</dt> </dl> </td> <td
    ///                          width="60%"> The first video stream. </td> </tr> <tr> <td width="40%"><a
    ///                          id="MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_audio_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</b></b></dt> <dt>0xFFFFFFFD</dt> </dl> </td> <td
    ///                          width="60%"> The first audio stream. </td> </tr> </table>
    ///    dwMediaTypeIndex = The zero-based index of the media type to retrieve.
    ///    ppMediaType = Receives a pointer to the IMFMediaType interface. The caller must release the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>dwSourceStreamIndex</i> parameter is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_NO_MORE_TYPES</b></dt> </dl> </td> <td width="60%"> The <i>dwMediaTypeIndex</i> parameter is out
    ///    of range. </td> </tr> </table>
    ///    
    HRESULT GetAvailableDeviceMediaType(uint dwSourceStreamIndex, uint dwMediaTypeIndex, IMFMediaType* ppMediaType);
    ///Sets the output format for a capture stream.
    ///Params:
    ///    dwSourceStreamIndex = The capture stream to set. The value can be any of the following. <table> <tr> <th>Value</th>
    ///                          <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The
    ///                          zero-based index of a stream. To get the number of streams, call IMFCaptureSource::GetDeviceStreamCount.
    ///                          </td> </tr> <tr> <td width="40%"><a id="MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_photo_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</b></b></dt> <dt>0xFFFFFFFB</dt> </dl> </td> <td
    ///                          width="60%"> The first image stream. </td> </tr> <tr> <td width="40%"><a
    ///                          id="MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_video_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</b></b></dt> <dt>0xFFFFFFFC</dt> </dl> </td> <td
    ///                          width="60%"> The first video stream. </td> </tr> <tr> <td width="40%"><a
    ///                          id="MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_audio_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</b></b></dt> <dt>0xFFFFFFFD</dt> </dl> </td> <td
    ///                          width="60%"> The first audio stream. </td> </tr> </table>
    ///    pMediaType = A pointer to the IMFMediaType interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>dwSourceStreamIndex</i> parameter is invalid. </td> </tr> </table>
    ///    
    HRESULT SetCurrentDeviceMediaType(uint dwSourceStreamIndex, IMFMediaType pMediaType);
    ///Gets the current media type for a capture stream.
    ///Params:
    ///    dwSourceStreamIndex = Specifies which stream to query. The value can be any of the following. <table> <tr> <th>Value</th>
    ///                          <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The
    ///                          zero-based index of a stream. To get the number of streams, call IMFCaptureSource::GetDeviceStreamCount.
    ///                          </td> </tr> <tr> <td width="40%"><a id="MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_photo_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</b></b></dt> <dt>0xFFFFFFFB</dt> </dl> </td> <td
    ///                          width="60%"> The first image stream. </td> </tr> <tr> <td width="40%"><a
    ///                          id="MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_video_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</b></b></dt> <dt>0xFFFFFFFC</dt> </dl> </td> <td
    ///                          width="60%"> The first video stream. </td> </tr> <tr> <td width="40%"><a
    ///                          id="MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM"></a><a
    ///                          id="mf_capture_engine_first_source_audio_stream"></a><dl>
    ///                          <dt><b><b>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</b></b></dt> <dt>0xFFFFFFFD</dt> </dl> </td> <td
    ///                          width="60%"> The first audio stream. </td> </tr> </table>
    ///    ppMediaType = Receives a pointer to the IMFMediaType interface. The caller must release the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>dwSourceStreamIndex</i> parameter is invalid. </td> </tr> </table>
    ///    
    HRESULT GetCurrentDeviceMediaType(uint dwSourceStreamIndex, IMFMediaType* ppMediaType);
    ///Gets the number of device streams.
    ///Params:
    ///    pdwStreamCount = Receives the number of device streams.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDeviceStreamCount(uint* pdwStreamCount);
    ///Gets the stream category for the specified source stream index.
    ///Params:
    ///    dwSourceStreamIndex = The index of the source stream.
    ///    pStreamCategory = Receives the MF_CAPTURE_ENGINE_STREAM_CATEGORY of the specified source stream.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDeviceStreamCategory(uint dwSourceStreamIndex, MF_CAPTURE_ENGINE_STREAM_CATEGORY* pStreamCategory);
    ///Gets the current mirroring state of the video preview stream.
    ///Params:
    ///    dwStreamIndex = The zero-based index of the stream.
    ///    pfMirrorState = Receives the value <b>TRUE</b> if mirroring is enabled, or <b>FALSE</b> if mirroring is disabled.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMirrorState(uint dwStreamIndex, BOOL* pfMirrorState);
    ///Enables or disables mirroring of the video preview stream.
    ///Params:
    ///    dwStreamIndex = The zero-based index of the stream.
    ///    fMirrorState = If <b>TRUE</b>, mirroring is enabled; if <b>FALSE</b>, mirroring is disabled.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The device stream does not have
    ///    mirroring capability. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td>
    ///    <td width="60%"> The source is not initialized. </td> </tr> </table>
    ///    
    HRESULT SetMirrorState(uint dwStreamIndex, BOOL fMirrorState);
    ///Gets the actual device stream index translated from a friendly stream name.
    ///Params:
    ///    uifriendlyName = The friendly name. Can be one of the following: <ul> <li>MF_CAPTURE_ENGINE_FIRST_SOURCE_AUDIO_STREAM</li>
    ///                     <li>MF_CAPTURE_ENGINE_FIRST_SOURCE_VIDEO_STREAM</li> <li>MF_CAPTURE_ENGINE_FIRST_SOURCE_PHOTO_STREAM</li>
    ///                     <li>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_VIDEO_STREAM_FOR_RECORD</li>
    ///                     <li>MF_CAPTURE_ENGINE_PREFERRED_SOURCE_VIDEO_STREAM_FOR_PREVIEW</li>
    ///                     <li>MF_CAPTURE_ENGINE_FIRST_SOURCE_INDEPENDENT_PHOTO_STREAM</li> </ul>
    ///    pdwActualStreamIndex = Receives the value of the stream index that corresponds to the friendly name.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamIndexFromFriendlyName(uint uifriendlyName, uint* pdwActualStreamIndex);
}

///Controls one or more capture devices. The capture engine implements this interface. To get a pointer to this
///interface, call either MFCreateCaptureEngine or IMFCaptureEngineClassFactory::CreateInstance.
@GUID("A6BBA433-176B-48B2-B375-53AA03473207")
interface IMFCaptureEngine : IUnknown
{
    ///Initializes the capture engine.
    ///Params:
    ///    pEventCallback = A pointer to the IMFCaptureEngineOnEventCallback interface. The caller must implement this interface. The
    ///                     capture engine uses this interface to send asynchronous events to the caller.
    ///    pAttributes = A pointer to the IMFAttributes interface. This parameter can be <b>NULL</b>. You can use this parameter to
    ///                  configure the capture engine. Call MFCreateAttributes to create an attribute store, and then set any of the
    ///                  following attributes. <ul> <li> MF_CAPTURE_ENGINE_D3D_MANAGER </li> <li> MF_CAPTURE_ENGINE_DISABLE_DXVA </li>
    ///                  <li> MF_CAPTURE_ENGINE_DISABLE_HARDWARE_TRANSFORMS </li> <li>
    ///                  MF_CAPTURE_ENGINE_ENCODER_MFT_FIELDOFUSE_UNLOCK_Attribute </li> <li> MF_CAPTURE_ENGINE_EVENT_GENERATOR_GUID
    ///                  </li> <li> MF_CAPTURE_ENGINE_EVENT_STREAM_INDEX </li> <li> MF_CAPTURE_ENGINE_MEDIASOURCE_CONFIG </li> <li>
    ///                  MF_CAPTURE_ENGINE_RECORD_SINK_AUDIO_MAX_PROCESSED_SAMPLES </li> <li>
    ///                  MF_CAPTURE_ENGINE_RECORD_SINK_AUDIO_MAX_UNPROCESSED_SAMPLES </li> <li>
    ///                  MF_CAPTURE_ENGINE_RECORD_SINK_VIDEO_MAX_PROCESSED_SAMPLES </li> <li>
    ///                  MF_CAPTURE_ENGINE_RECORD_SINK_VIDEO_MAX_UNPROCESSED_SAMPLES </li> <li>
    ///                  MF_CAPTURE_ENGINE_USE_AUDIO_DEVICE_ONLY </li> <li> MF_CAPTURE_ENGINE_USE_VIDEO_DEVICE_ONLY </li> </ul>
    ///    pAudioSource = An IUnknown pointer that specifies an audio-capture device. This parameter can be <b>NULL</b>. If you set the
    ///                   MF_CAPTURE_ENGINE_USE_VIDEO_DEVICE_ONLY attribute to <b>TRUE</b> in <i>pAttributes</i>, the capture engine
    ///                   does not use an audio device, and the <i>pAudioSource</i> parameter is ignored. Otherwise, if
    ///                   <i>pAudioSource</i> is <b>NULL</b>, the capture engine selects the microphone that is built into the video
    ///                   camera specified by <i>pVideoSource</i>. If the video camera does not have a microphone, the capture engine
    ///                   enumerates the audio-capture devices on the system and selects the first one. To override the default audio
    ///                   device, set <i>pAudioSource</i> to an IMFMediaSource or IMFActivate pointer for the device. For more
    ///                   information, see Audio/Video Capture in Media Foundation.
    ///    pVideoSource = An IUnknown pointer that specifies a video-capture device. This parameter can be <b>NULL</b>. If you set the
    ///                   MF_CAPTURE_ENGINE_USE_AUDIO_DEVICE_ONLY attribute to <b>TRUE</b> in <i>pAttributes</i>, the capture engine
    ///                   does not use a video device, and the <i>pVideoSource</i> parameter is ignored. Otherwise, if
    ///                   <i>pVideoSource</i> is <b>NULL</b>, the capture engine enumerates the video-capture devices on the system and
    ///                   selects the first one. To override the default video device, set <i>pVideoSource</i> to an IMFMediaSource or
    ///                   IMFActivate pointer for the device. For more information, see Enumerating Video Capture Devices.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The Initialize method was
    ///    already called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NO_CAPTURE_DEVICES_AVAILABLE</b></dt>
    ///    </dl> </td> <td width="60%"> No capture devices are available. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_UNSUPPORTED_CAPTURE_DEVICE_PRESENT</b></dt> </dl> </td> <td width="60%"> An unsupported capture
    ///    device is present on the system. This error will only be returned if NULL is specified for the
    ///    <i>pVideoSource</i> parameter, indicating that the system should pick the capture device, and if no supported
    ///    capture device has already been attached. It is recommended that apps show users a specific unsupported
    ///    capture device message if this error is returned, rather than a general failure message. </td> </tr> </table>
    ///    
    HRESULT Initialize(IMFCaptureEngineOnEventCallback pEventCallback, IMFAttributes pAttributes, 
                       IUnknown pAudioSource, IUnknown pVideoSource);
    ///Starts preview.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The preview sink was not
    ///    initialized. </td> </tr> </table>
    ///    
    HRESULT StartPreview();
    ///Stops preview.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The capture engine is not
    ///    currently previewing. </td> </tr> </table>
    ///    
    HRESULT StopPreview();
    ///Starts recording audio and/or video to a file.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The recording sink was not
    ///    initialized. </td> </tr> </table>
    ///    
    HRESULT StartRecord();
    ///Stops recording.
    ///Params:
    ///    bFinalize = A Boolean value that specifies whether to finalize the output file. To create a valid output file, specify
    ///                <b>TRUE</b>. Specify <b>FALSE</b> only if you want to interrupt the recording and discard the output file. If
    ///                the value is <b>FALSE</b>, the operation completes more quickly, but the file will not be playable.
    ///    bFlushUnprocessedSamples = A Boolean value that specifies if the unprocessed samples waiting to be encoded should be flushed.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT StopRecord(BOOL bFinalize, BOOL bFlushUnprocessedSamples);
    ///Captures a still image from the video stream.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT TakePhoto();
    ///Gets a pointer to one of the capture sink objects. You can use the capture sinks to configure preview, recording,
    ///or still-image capture.
    ///Params:
    ///    mfCaptureEngineSinkType = An MF_CAPTURE_ENGINE_SINK_TYPE value that specifies the capture sink to retrieve.
    ///    ppSink = Receives a pointer to the IMFCaptureSink interface. The caller must release the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetSink(MF_CAPTURE_ENGINE_SINK_TYPE mfCaptureEngineSinkType, IMFCaptureSink* ppSink);
    ///Gets a pointer to the capture source object. Use the capture source to configure the capture devices.
    ///Params:
    ///    ppSource = Receives a pointer to the IMFCaptureSource interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSource(IMFCaptureSource* ppSource);
}

///Creates an instance of the capture engine.
@GUID("8F02D140-56FC-4302-A705-3A97C78BE779")
interface IMFCaptureEngineClassFactory : IUnknown
{
    ///Creates an instance of the capture engine.
    ///Params:
    ///    clsid = The CLSID of the object to create. Currently, this parameter must equal <b>CLSID_MFCaptureEngine</b>.
    ///    riid = The IID of the requested interface. The capture engine supports the IMFCaptureEngine interface.
    ///    ppvObject = Receives a pointer to the requested interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateInstance(const(GUID)* clsid, const(GUID)* riid, void** ppvObject);
}

///Extensions for the IMFCaptureEngineOnSampleCallback callback interface that is used to receive data from the capture
///engine.
@GUID("E37CEED7-340F-4514-9F4D-9C2AE026100B")
interface IMFCaptureEngineOnSampleCallback2 : IMFCaptureEngineOnSampleCallback
{
    ///Called by the capture sink when the format of the sample is changed.
    ///Params:
    ///    pEvent = The new media type.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnSynchronizedEvent(IMFMediaEvent pEvent);
}

///Extends the IMFCaptureSink interface to provide functionality for dynamically setting the output media type of the
///record sink or preview sink.
@GUID("F9E4219E-6197-4B5E-B888-BEE310AB2C59")
interface IMFCaptureSink2 : IMFCaptureSink
{
    ///Dynamically sets the output media type of the record sink or preview sink.
    ///Params:
    ///    dwStreamIndex = The stream index to change the output media type on.
    ///    pMediaType = The new output media type.
    ///    pEncodingAttributes = The new encoder attributes. This can be <b>null</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALID_MEDIATYPE</b></dt> </dl> </td> <td width="60%"> The sink does not support the media type.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetOutputMediaType(uint dwStreamIndex, IMFMediaType pMediaType, IMFAttributes pEncodingAttributes);
}

///Contains data that is needed to implement the IMFAsyncResult interface.
interface MFASYNCRESULT : IMFAsyncResult
{
}

///Provides the current error status for the Media Engine.
@GUID("FC0E10D2-AB2A-4501-A951-06BB1075184C")
interface IMFMediaError : IUnknown
{
    ///Gets the error code.
    ///Returns:
    ///    Returns a value from the MF_MEDIA_ENGINE_ERR enumeration.
    ///    
    ushort  GetErrorCode();
    ///Gets the extended error code.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value that gives additional information about the last error.
    ///    
    HRESULT GetExtendedErrorCode();
    ///Sets the error code.
    ///Params:
    ///    error = The error code, specified as an MF_MEDIA_ENGINE_ERR value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetErrorCode(MF_MEDIA_ENGINE_ERR error);
    ///Sets the extended error code.
    ///Params:
    ///    error = An <b>HRESULT</b> value that gives additional information about the last error.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetExtendedErrorCode(HRESULT error);
}

///Represents a list of time ranges, where each range is defined by a start and end time.
@GUID("DB71A2FC-078A-414E-9DF9-8C2531B0AA6C")
interface IMFMediaTimeRange : IUnknown
{
    ///Gets the number of time ranges contained in the object.
    ///Returns:
    ///    Returns the number of time ranges.
    ///    
    uint    GetLength();
    ///Gets the start time for a specified time range.
    ///Params:
    ///    index = The zero-based index of the time range to query. To get the number of time ranges, call
    ///            IMFMediaTimeRange::GetLength.
    ///    pStart = Receives the start time, in seconds.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStart(uint index, double* pStart);
    ///Gets the end time for a specified time range.
    ///Params:
    ///    index = The zero-based index of the time range to query. To get the number of time ranges, call
    ///            IMFMediaTimeRange::GetLength.
    ///    pEnd = Receives the end time, in seconds.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEnd(uint index, double* pEnd);
    ///Queries whether a specified time falls within any of the time ranges.
    ///Params:
    ///    time = The time, in seconds.
    ///Returns:
    ///    Returns <b>TRUE</b> if any time range contained in this object spans the value of the <i>time</i> parameter.
    ///    Otherwise, returns <b>FALSE</b>.
    ///    
    BOOL    ContainsTime(double time);
    ///Adds a new range to the list of time ranges.
    ///Params:
    ///    startTime = The start time, in seconds.
    ///    endTime = The end time, in seconds.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddRange(double startTime, double endTime);
    ///Clears the list of time ranges.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Clear();
}

///Callback interface for the IMFMediaEngine interface.
@GUID("FEE7C112-E776-42B5-9BBF-0048524E2BD5")
interface IMFMediaEngineNotify : IUnknown
{
    ///Notifies the application when a playback event occurs.
    ///Params:
    ///    event = A member of the MF_MEDIA_ENGINE_EVENT enumeration that specifies the event.
    ///    param1 = The first event parameter. The meaning of this parameter depends on the event code.
    ///    param2 = The second event parameter. The meaning of this parameter depends on the event code.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EventNotify(uint event, size_t param1, uint param2);
}

///Provides the Media Engine with a list of media resources.
@GUID("7A5E5354-B114-4C72-B991-3131D75032EA")
interface IMFMediaEngineSrcElements : IUnknown
{
    ///Gets the number of source elements in the list.
    ///Returns:
    ///    Returns the number of source elements.
    ///    
    uint    GetLength();
    ///Gets the URL of an element in the list.
    ///Params:
    ///    index = The zero-based index of the source element. To get the number of source elements, call
    ///            IMFMediaEngineSrcElements::GetLength.
    ///    pURL = Receives a <b>BSTR</b> that contains the URL of the source element. The caller must free the <b>BSTR</b> by
    ///           calling <b>SysFreeString</b>. If no URL is set, this parameter receives the value <b>NULL</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetURL(uint index, BSTR* pURL);
    ///Gets the MIME type of an element in the list.
    ///Params:
    ///    index = The zero-based index of the source element. To get the number of source elements, call
    ///            IMFMediaEngineSrcElements::GetLength.
    ///    pType = Receives a <b>BSTR</b> that contains the MIME type. The caller must free the <b>BSTR</b> by calling
    ///            <b>SysFreeString</b>. If no MIME type is set, this parameter receives the value <b>NULL</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetType(uint index, BSTR* pType);
    ///Gets the intended media type of an element in the list.
    ///Params:
    ///    index = The zero-based index of the source element. To get the number of source elements, call
    ///            IMFMediaEngineSrcElements::GetLength.
    ///    pMedia = Receives a <b>BSTR</b> that contains a media-query string. The caller must free the <b>BSTR</b> by calling
    ///             <b>SysFreeString</b>. If no media type is set, this parameter receives the value <b>NULL</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMedia(uint index, BSTR* pMedia);
    ///Adds a source element to the end of the list.
    ///Params:
    ///    pURL = The URL of the source element, or <b>NULL</b>.
    ///    pType = The MIME type of the source element, or <b>NULL</b>.
    ///    pMedia = A media-query string that specifies the intended media type, or <b>NULL</b>. If specified, the string should
    ///             conform to the W3C <i>Media Queries</i> specification.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddElement(BSTR pURL, BSTR pType, BSTR pMedia);
    ///Removes all of the source elements from the list.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveAllElements();
}

///Enables an application to play audio or video files.
@GUID("98A1B0BB-03EB-4935-AE7C-93C1FA0E1C93")
interface IMFMediaEngine : IUnknown
{
    ///Gets the most recent error status.
    ///Params:
    ///    ppError = Receives either a pointer to the IMFMediaError interface, or the value <b>NULL</b>. If the value is
    ///              <b>non-NULL</b>, the caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetError(IMFMediaError* ppError);
    ///Sets the current error code.
    ///Params:
    ///    error = The error code, as an MF_MEDIA_ENGINE_ERR value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetErrorCode(MF_MEDIA_ENGINE_ERR error);
    ///Sets a list of media sources.
    ///Params:
    ///    pSrcElements = A pointer to the IMFMediaEngineSrcElements interface. The caller must implement this interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSourceElements(IMFMediaEngineSrcElements pSrcElements);
    ///Sets the URL of a media resource.
    ///Params:
    ///    pUrl = The URL of the media resource.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSource(BSTR pUrl);
    ///Gets the URL of the current media resource, or an empty string if no media resource is present.
    ///Params:
    ///    ppUrl = Receives a <b>BSTR</b> that contains the URL of the current media resource. If there is no media resource,
    ///            <i>ppUrl</i> receives an empty string. The caller must free the <b>BSTR</b> by calling <b>SysFreeString</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCurrentSource(BSTR* ppUrl);
    ///Gets the current network state of the media engine.
    ///Returns:
    ///    Returns an MF_MEDIA_ENGINE_NETWORK enumeration value.
    ///    
    ushort  GetNetworkState();
    ///Gets the preload flag.
    ///Returns:
    ///    Returns an MF_MEDIA_ENGINE_PRELOAD enumeration value.
    ///    
    MF_MEDIA_ENGINE_PRELOAD GetPreload();
    ///Sets the preload flag.
    ///Params:
    ///    Preload = An MF_MEDIA_ENGINE_PRELOAD value equal to the preload flag.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPreload(MF_MEDIA_ENGINE_PRELOAD Preload);
    ///Queries how much resource data the media engine has buffered.
    ///Params:
    ///    ppBuffered = Receives a pointer to the IMFMediaTimeRange interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetBuffered(IMFMediaTimeRange* ppBuffered);
    ///Loads the current media source.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Load();
    ///Queries how likely it is that the Media Engine can play a specified type of media resource.
    ///Params:
    ///    type = A string that contains a MIME type with an optional codecs parameter, as defined in RFC 4281.
    ///    pAnswer = Receives an MF_MEDIA_ENGINE_CANPLAY enumeration value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CanPlayType(BSTR type, MF_MEDIA_ENGINE_CANPLAY* pAnswer);
    ///Gets the ready state, which indicates whether the current media resource can be rendered.
    ///Returns:
    ///    Returns an MF_MEDIA_ENGINE_READY enumeration value.
    ///    
    ushort  GetReadyState();
    ///Queries whether the Media Engine is currently seeking to a new playback position.
    ///Returns:
    ///    Returns <b>TRUE</b> if the Media Engine is seeking, or <b>FALSE</b> otherwise.
    ///    
    BOOL    IsSeeking();
    ///Gets the current playback position.
    ///Returns:
    ///    Returns the playback position, in seconds.
    ///    
    double  GetCurrentTime();
    ///Seeks to a new playback position.
    ///Params:
    ///    seekTime = The new playback position, in seconds.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCurrentTime(double seekTime);
    ///Gets the initial playback position.
    ///Returns:
    ///    Returns the initial playback position, in seconds.
    ///    
    double  GetStartTime();
    ///Gets the duration of the media resource.
    ///Returns:
    ///    Returns the duration, in seconds. If no media data is available, the method returns not-a-number (NaN). If
    ///    the duration is unbounded, the method returns an infinite value.
    ///    
    double  GetDuration();
    ///Queries whether playback is currently paused.
    ///Returns:
    ///    Returns <b>TRUE</b> if playback is paused, or <b>FALSE</b> otherwise.
    ///    
    BOOL    IsPaused();
    ///Gets the default playback rate.
    ///Returns:
    ///    Returns the default playback rate, as a multiple of normal (1Ã—) playback. A negative value indicates reverse
    ///    playback.
    ///    
    double  GetDefaultPlaybackRate();
    ///Sets the default playback rate.
    ///Params:
    ///    Rate = The default playback rate, as a multiple of normal (1Ã—) playback. A negative value indicates reverse
    ///           playback.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDefaultPlaybackRate(double Rate);
    ///Gets the current playback rate.
    ///Returns:
    ///    Returns the playback rate, as a multiple of normal (1Ã—) playback. A negative value indicates reverse
    ///    playback.
    ///    
    double  GetPlaybackRate();
    ///Sets the current playback rate.
    ///Params:
    ///    Rate = The playback rate, as a multiple of normal (1Ã—) playback. A negative value indicates reverse playback.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPlaybackRate(double Rate);
    ///Gets the time ranges that have been rendered.
    ///Params:
    ///    ppPlayed = Receives a pointer to the IMFMediaTimeRange interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPlayed(IMFMediaTimeRange* ppPlayed);
    ///Gets the time ranges to which the Media Engine can currently seek.
    ///Params:
    ///    ppSeekable = Receives a pointer to the IMFMediaTimeRange interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSeekable(IMFMediaTimeRange* ppSeekable);
    ///Queries whether playback has ended.
    ///Returns:
    ///    Returns <b>TRUE</b> if the direction of playback is forward and playback has reached the end of the media
    ///    resource. Returns <b>FALSE</b> otherwise.
    ///    
    BOOL    IsEnded();
    ///Queries whether the Media Engine automatically begins playback.
    ///Returns:
    ///    Returns <b>TRUE</b> if the Media Engine automatically begins playback, or <b>FALSE</b> otherwise.
    ///    
    BOOL    GetAutoPlay();
    ///Specifies whether the Media Engine automatically begins playback.
    ///Params:
    ///    AutoPlay = If <b>TRUE</b>, the Media Engine automatically begins playback after it loads a media source. Otherwise,
    ///               playback does not begin until the application calls IMFMediaEngine::Play.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetAutoPlay(BOOL AutoPlay);
    ///Queries whether the Media Engine will loop playback.
    ///Returns:
    ///    Returns <b>TRUE</b> if looping is enabled, or <b>FALSE</b> otherwise.
    ///    
    BOOL    GetLoop();
    ///Specifies whether the Media Engine loops playback.
    ///Params:
    ///    Loop = Specify <b>TRUE</b> to enable looping, or <b>FALSE</b> to disable looping.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetLoop(BOOL Loop);
    ///Starts playback.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Play();
    ///Pauses playback.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Pause();
    ///Queries whether the audio is muted.
    ///Returns:
    ///    Returns <b>TRUE</b> if the audio is muted, or <b>FALSE</b> otherwise.
    ///    
    BOOL    GetMuted();
    ///Mutes or unmutes the audio.
    ///Params:
    ///    Muted = Specify <b>TRUE</b> to mute the audio, or <b>FALSE</b> to unmute the audio.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetMuted(BOOL Muted);
    ///Gets the audio volume level.
    ///Returns:
    ///    Returns the volume level. Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0
    ///    indicates full volume (no attenuation).
    ///    
    double  GetVolume();
    ///Sets the audio volume level.
    ///Params:
    ///    Volume = The volume level. Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0 indicates
    ///             full volume (no attenuation).
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetVolume(double Volume);
    ///Queries whether the current media resource contains a video stream.
    ///Returns:
    ///    Returns <b>TRUE</b> if the current media resource contains a video stream. Returns <b>FALSE</b> if there is
    ///    no media resource or the media resource does not contain a video stream.
    ///    
    BOOL    HasVideo();
    ///Queries whether the current media resource contains an audio stream.
    ///Returns:
    ///    Returns <b>TRUE</b> if the current media resource contains an audio stream. Returns <b>FALSE</b> if there is
    ///    no media resource or the media resource does not contain an audio stream.
    ///    
    BOOL    HasAudio();
    ///Gets the size of the video frame, adjusted for aspect ratio.
    ///Params:
    ///    cx = Receives the width in pixels.
    ///    cy = Receives the height in pixels.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetNativeVideoSize(uint* cx, uint* cy);
    ///Gets the picture aspect ratio of the video stream.
    ///Params:
    ///    cx = Receives the x component of the aspect ratio.
    ///    cy = Receives the y component of the aspect ratio.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoAspectRatio(uint* cx, uint* cy);
    ///Shuts down the Media Engine and releases the resources it is using.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Shutdown();
    ///Copies the current video frame to a DXGI surface or WIC bitmap.
    ///Params:
    ///    pDstSurf = A pointer to the IUnknown interface of the destination surface.
    ///    pSrc = A pointer to an MFVideoNormalizedRect structure that specifies the source rectangle.
    ///    pDst = A pointer to a RECT structure that specifies the destination rectangle.
    ///    pBorderClr = A pointer to an MFARGB structure that specifies the border color.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT TransferVideoFrame(IUnknown pDstSurf, const(MFVideoNormalizedRect)* pSrc, const(RECT)* pDst, 
                               const(MFARGB)* pBorderClr);
    ///Queries the Media Engine to find out whether a new video frame is ready.
    ///Params:
    ///    pPts = If a new frame is ready, receives the presentation time of the frame.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The method succeeded, but the
    ///    Media Engine does not have a new frame. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> A new video frame is ready for display. </td> </tr> </table>
    ///    
    HRESULT OnVideoStreamTick(long* pPts);
}

///Extends the IMFMediaEngine interface.
@GUID("83015EAD-B1E6-40D0-A98A-37145FFE1AD1")
interface IMFMediaEngineEx : IMFMediaEngine
{
    ///Opens a media resource from a byte stream.
    ///Params:
    ///    pByteStream = A pointer to the IMFByteStream interface of the byte stream.
    ///    pURL = The URL of the byte stream.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSourceFromByteStream(IMFByteStream pByteStream, BSTR pURL);
    ///Gets a playback statistic from the Media Engine.
    ///Params:
    ///    StatisticID = A member of the MF_MEDIA_ENGINE_STATISTIC enumeration that identifies the statistic to get.
    ///    pStatistic = A pointer to a PROPVARIANT that receives the statistic. The data type and meaning of this value depends on
    ///                 the value of <i>StatisticID</i>. The caller must free the <b>PROPVARIANT</b> by calling PropVariantClear.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStatistics(MF_MEDIA_ENGINE_STATISTIC StatisticID, PROPVARIANT* pStatistic);
    ///Updates the source rectangle, destination rectangle, and border color for the video.
    ///Params:
    ///    pSrc = A pointer to an MFVideoNormalizedRect structure that specifies the source rectangle. The source rectangle
    ///           defines the area of the video frame that is displayed. If this parameter is <b>NULL</b>, the entire video
    ///           frame is displayed.
    ///    pDst = A pointer to a RECT structure that specifies the destination rectangle. The destination rectangle defines the
    ///           area of the window or DirectComposition visual where the video is drawn.
    ///    pBorderClr = A pointer to an MFARGB structure that specifies the border color.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UpdateVideoStream(const(MFVideoNormalizedRect)* pSrc, const(RECT)* pDst, const(MFARGB)* pBorderClr);
    ///Gets the audio balance.
    ///Returns:
    ///    Returns the balance. The value can be any number in the following range (inclusive). <table> <tr> <th>Return
    ///    value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt>-1</dt> </dl> </td> <td width="60%"> The
    ///    left channel is at full volume; the right channel is silent. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt>1</dt> </dl> </td> <td width="60%"> The right channel is at full volume; the left channel is silent.
    ///    </td> </tr> </table> If the value is zero, the left and right channels are at equal volumes. The default
    ///    value is zero.
    ///    
    double  GetBalance();
    ///Sets the audio balance.
    ///Params:
    ///    balance = The audio balance. The value can be any number in the following range (inclusive). <table> <tr>
    ///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>-1</dt> </dl> </td> <td width="60%"> The
    ///              left channel is at full volume; the right channel is silent. </td> </tr> <tr> <td width="40%"> <dl>
    ///              <dt>1</dt> </dl> </td> <td width="60%"> The right channel is at full volume; the left channel is silent.
    ///              </td> </tr> </table> If the value is zero, the left and right channels are at equal volumes. The default
    ///              value is zero.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetBalance(double balance);
    ///Queries whether the Media Engine can play at a specified playback rate.
    ///Params:
    ///    rate = The requested playback rate.
    ///Returns:
    ///    Returns <b>TRUE</b> if the playback rate is supported, or <b>FALSE</b> otherwise.
    ///    
    BOOL    IsPlaybackRateSupported(double rate);
    ///Steps forward or backward one frame.
    ///Params:
    ///    Forward = Specify <b>TRUE</b> to step forward or <b>FALSE</b> to step backward.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT FrameStep(BOOL Forward);
    ///Gets various flags that describe the media resource.
    ///Params:
    ///    pCharacteristics = Receives a bitwise <b>OR</b> of zero or more flags from the MFMEDIASOURCE_CHARACTERISTICS enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetResourceCharacteristics(uint* pCharacteristics);
    ///Gets a presentation attribute from the media resource.
    ///Params:
    ///    guidMFAttribute = The attribute to query. For a list of presentation attributes, see Presentation Descriptor Attributes.
    ///    pvValue = A pointer to a PROPVARIANT that receives the value. The method fills the <b>PROPVARIANT</b> with a copy of
    ///              the stored value. The caller must free the <b>PROPVARIANT</b> by calling PropVariantClear.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPresentationAttribute(const(GUID)* guidMFAttribute, PROPVARIANT* pvValue);
    ///Gets the number of streams in the media resource.
    ///Params:
    ///    pdwStreamCount = Receives the number of streams.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetNumberOfStreams(uint* pdwStreamCount);
    ///Gets a stream-level attribute from the media resource.
    ///Params:
    ///    dwStreamIndex = The zero-based index of the stream. To get the number of streams, call IMFMediaEngineEx::GetNumberOfStreams.
    ///    guidMFAttribute = The attribute to query. Possible values are listed in the following topics: <ul> <li> Stream Descriptor
    ///                      Attributes </li> <li> Media Type Attributes </li> </ul>
    ///    pvValue = A pointer to a PROPVARIANT that receives the value. The method fills the <b>PROPVARIANT</b> with a copy of
    ///              the stored value. Call PropVariantClear to free the memory allocated by the method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamAttribute(uint dwStreamIndex, const(GUID)* guidMFAttribute, PROPVARIANT* pvValue);
    ///Queries whether a stream is selected to play.
    ///Params:
    ///    dwStreamIndex = The zero-based index of the stream. To get the number of streams, call IMFMediaEngineEx::GetNumberOfStreams.
    ///    pEnabled = Receives a Boolean value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///               id="TRUE"></a><a id="true"></a><dl> <dt><b><b>TRUE</b></b></dt> </dl> </td> <td width="60%"> The stream is
    ///               selected. During playback, this stream will play. </td> </tr> <tr> <td width="40%"><a id="FALSE"></a><a
    ///               id="false"></a><dl> <dt><b><b>FALSE</b></b></dt> </dl> </td> <td width="60%"> The stream is not selected.
    ///               During playback, this stream will not play. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamSelection(uint dwStreamIndex, BOOL* pEnabled);
    ///Selects or deselects a stream for playback.
    ///Params:
    ///    dwStreamIndex = The zero-based index of the stream. To get the number of streams, call IMFMediaEngineEx::GetNumberOfStreams.
    ///    Enabled = Specifies whether to select or deselect the stream. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///              <td width="40%"><a id="TRUE"></a><a id="true"></a><dl> <dt><b><b>TRUE</b></b></dt> </dl> </td> <td
    ///              width="60%"> The stream is selected. During playback, this stream will play. </td> </tr> <tr> <td
    ///              width="40%"><a id="FALSE"></a><a id="false"></a><dl> <dt><b><b>FALSE</b></b></dt> </dl> </td> <td
    ///              width="60%"> The stream is not selected. During playback, this stream will not play. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetStreamSelection(uint dwStreamIndex, BOOL Enabled);
    ///Applies the stream selections from previous calls to SetStreamSelection.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ApplyStreamSelections();
    ///Queries whether the media resource contains protected content.
    ///Params:
    ///    pProtected = Receives the value <b>TRUE</b> if the media resource contains protected content, or <b>FALSE</b> otherwise.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IsProtected(BOOL* pProtected);
    ///Inserts a video effect.
    ///Params:
    ///    pEffect = One of the following: <ul> <li>A pointer to the IMFTransform interface of a Media Foundation transform (MFT)
    ///              that implements the video effect.</li> <li>A pointer to the IMFActivate interface of an activation object.
    ///              The activation object must create an MFT for the video effect.</li> </ul>
    ///    fOptional = Specifies whether the effect is optional. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///                width="40%"><a id="TRUE"></a><a id="true"></a><dl> <dt><b><b>TRUE</b></b></dt> </dl> </td> <td width="60%">
    ///                The effect is optional. If the Media Engine cannot add the effect, it ignores the effect and continues
    ///                playback. </td> </tr> <tr> <td width="40%"><a id="FALSE"></a><a id="false"></a><dl>
    ///                <dt><b><b>FALSE</b></b></dt> </dl> </td> <td width="60%"> The effect is required. If the Media Engine object
    ///                cannot add the effect, a playback error occurs. </td> </tr> </table>
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The maximum number of
    ///    video effects was reached. </td> </tr> </table>
    ///    
    HRESULT InsertVideoEffect(IUnknown pEffect, BOOL fOptional);
    ///Inserts an audio effect.
    ///Params:
    ///    pEffect = One of the following: <ul> <li>A pointer to the IMFTransform interface of a Media Foundation transform (MFT)
    ///              that implements the audio effect.</li> <li>A pointer to the IMFActivate interface of an activation object.
    ///              The activation object must create an MFT for the audio effect.</li> </ul>
    ///    fOptional = Specifies whether the effect is optional. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///                width="40%"><a id="TRUE"></a><a id="true"></a><dl> <dt><b><b>TRUE</b></b></dt> </dl> </td> <td width="60%">
    ///                The effect is optional. If the Media Engine cannot add the effect, it ignores the effect and continues
    ///                playback. </td> </tr> <tr> <td width="40%"><a id="FALSE"></a><a id="false"></a><dl>
    ///                <dt><b><b>FALSE</b></b></dt> </dl> </td> <td width="60%"> The effect is required. If the Media Engine object
    ///                cannot add the effect, a playback error occurs. </td> </tr> </table>
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The maximum number of
    ///    audio effects was reached. </td> </tr> </table>
    ///    
    HRESULT InsertAudioEffect(IUnknown pEffect, BOOL fOptional);
    ///Removes all audio and video effects.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveAllEffects();
    ///Specifies a presentation time when the Media Engine will send a marker event.
    ///Params:
    ///    timeToFire = The presentation time for the marker event, in seconds.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetTimelineMarkerTimer(double timeToFire);
    ///Gets the time of the next timeline marker, if any.
    ///Params:
    ///    pTimeToFire = Receives the marker time, in seconds. If no marker is set, this parameter receives the value <b>NaN</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTimelineMarkerTimer(double* pTimeToFire);
    ///Cancels the next pending timeline marker.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CancelTimelineMarkerTimer();
    ///Queries whether the media resource contains stereoscopic 3D video.
    ///Returns:
    ///    Returns <b>TRUE</b> if the media resource contains 3D video, or <b>FALSE</b> otherwise.
    ///    
    BOOL    IsStereo3D();
    ///For stereoscopic 3D video, gets the layout of the two views within a video frame.
    ///Params:
    ///    packMode = Receives a member of the MF_MEDIA_ENGINE_S3D_PACKING_MODE enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStereo3DFramePackingMode(MF_MEDIA_ENGINE_S3D_PACKING_MODE* packMode);
    ///For stereoscopic 3D video, sets the layout of the two views within a video frame.
    ///Params:
    ///    packMode = A member of the MF_MEDIA_ENGINE_S3D_PACKING_MODE enumeration that specifies the layout. The two views can be
    ///               arranged side-by-side, or top-to-bottom.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetStereo3DFramePackingMode(MF_MEDIA_ENGINE_S3D_PACKING_MODE packMode);
    ///For stereoscopic 3D video, queries how the Media Engine renders the 3D video content.
    ///Params:
    ///    outputType = Receives a member of the MF3DVideoOutputType enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStereo3DRenderMode(MF3DVideoOutputType* outputType);
    ///For stereoscopic 3D video, specifies how the Media Engine renders the 3D video content.
    ///Params:
    ///    outputType = A member of the MF3DVideoOutputType enumeration that specifies the 3D video rendering mode.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetStereo3DRenderMode(MF3DVideoOutputType outputType);
    ///Enables or disables windowless swap-chain mode.
    ///Params:
    ///    fEnable = If <b>TRUE</b>, windowless swap-chain mode is enabled.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnableWindowlessSwapchainMode(BOOL fEnable);
    ///Gets a handle to the windowless swap chain.
    ///Params:
    ///    phSwapchain = Receives a handle to the swap chain.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoSwapchainHandle(HANDLE* phSwapchain);
    ///Enables or disables mirroring of the video.
    ///Params:
    ///    fEnable = If <b>TRUE</b>, the video is mirrored horizontally. Otherwise, the video is displayed normally.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnableHorizontalMirrorMode(BOOL fEnable);
    ///Gets the audio stream category used for the next call to SetSource or Load.
    ///Params:
    ///    pCategory = Receives the audio stream category.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAudioStreamCategory(uint* pCategory);
    ///Sets the audio stream category for the next call to SetSource or Load.
    ///Params:
    ///    category = 
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetAudioStreamCategory(uint category);
    ///Gets the audio device endpoint role used for the next call to SetSource or Load.
    ///Params:
    ///    pRole = Receives the audio endpoint role.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAudioEndpointRole(uint* pRole);
    ///Sets the audio device endpoint used for the next call to SetSource or Load.
    ///Params:
    ///    role = Specifies the audio end point role.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetAudioEndpointRole(uint role);
    ///Gets the real time mode used for the next call to SetSource or Load.
    ///Params:
    ///    pfEnabled = Receives the real time mode.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRealTimeMode(BOOL* pfEnabled);
    ///Sets the real time mode used for the next call to SetSource or Load.
    ///Params:
    ///    fEnable = Specifies the real time mode.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetRealTimeMode(BOOL fEnable);
    ///Seeks to a new playback position using the specified MF_MEDIA_ENGINE_SEEK_MODE.
    ///Params:
    ///    seekTime = The new playback position, in seconds.
    ///    seekMode = Specifies if the seek is a normal seek or an approximate seek.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCurrentTimeEx(double seekTime, MF_MEDIA_ENGINE_SEEK_MODE seekMode);
    ///Enables or disables the time update timer.
    ///Params:
    ///    fEnableTimer = If <b>TRUE</b>, the update timer is enabled. Otherwise, the timer is disabled.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnableTimeUpdateTimer(BOOL fEnableTimer);
}

@GUID("7A3BAC98-0E76-49FB-8C20-8A86FD98EAF2")
interface IMFMediaEngineAudioEndpointId : IUnknown
{
    HRESULT SetAudioEndpointId(const(PWSTR) pszEndpointId);
    HRESULT GetAudioEndpointId(PWSTR* ppszEndpointId);
}

///Enables an application to load media resources in the Media Engine.
@GUID("2F69D622-20B5-41E9-AFDF-89CED1DDA04E")
interface IMFMediaEngineExtension : IUnknown
{
    ///Queries whether the object can load a specified type of media resource.
    ///Params:
    ///    AudioOnly = If <b>TRUE</b>, the Media Engine is set to audio-only mode. Otherwise, the Media Engine is set to audio-video
    ///                mode.
    ///    MimeType = A string that contains a MIME type with an optional codecs parameter, as defined in RFC 4281.
    ///    pAnswer = Receives a member of the MF_MEDIA_ENGINE_CANPLAY enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CanPlayType(BOOL AudioOnly, BSTR MimeType, MF_MEDIA_ENGINE_CANPLAY* pAnswer);
    ///Begins an asynchronous request to create either a byte stream or a media source.
    ///Params:
    ///    bstrURL = The URL of the media resource.
    ///    pByteStream = A pointer to the IMFByteStream interface. If the <i>type</i> parameter equals <b>MF_OBJECT_BYTESTREAM</b>,
    ///                  this parameter is <b>NULL</b>. If <i>type</i> equals <b>MF_OBJECT_MEDIASOURCE</b>, this parameter either
    ///                  contains a pointer to a byte stream or is <b>NULL</b>. See Remarks for more information.
    ///    type = A member of the MF_OBJECT_TYPE enumeration that specifies which type of object to create. <table> <tr>
    ///           <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MF_OBJECT_BYTESTREAM"></a><a
    ///           id="mf_object_bytestream"></a><dl> <dt><b>MF_OBJECT_BYTESTREAM</b></dt> </dl> </td> <td width="60%"> Create a
    ///           byte stream. The byte stream must support the IMFByteStream interface. </td> </tr> <tr> <td width="40%"><a
    ///           id="MF_OBJECT_MEDIASOURCE"></a><a id="mf_object_mediasource"></a><dl> <dt><b>MF_OBJECT_MEDIASOURCE</b></dt>
    ///           </dl> </td> <td width="60%"> Create a media source. The media source must support the IMFMediaSource
    ///           interface. </td> </tr> </table>
    ///    ppIUnknownCancelCookie = Receives a pointer to the IUnknown interface. This pointer can be used to cancel the asynchronous operation,
    ///                             by passing the pointer to the IMFMediaEngineExtension::CancelObjectCreation method. The caller must release
    ///                             the interface. This parameter can be NULL.
    ///    pCallback = A pointer to the IMFAsyncCallback interface. This interface is used to signal the completion of the
    ///                asynchronous operation.
    ///    punkState = A pointer to the IUnknown interface of an object impemented by the caller. You can use this object to hold
    ///                state information for the callback. The object is returned to the caller when the callback is invoked. This
    ///                parameter can be <b>NULL</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT BeginCreateObject(BSTR bstrURL, IMFByteStream pByteStream, MF_OBJECT_TYPE type, 
                              IUnknown* ppIUnknownCancelCookie, IMFAsyncCallback pCallback, IUnknown punkState);
    ///Cancels the current request to create an object.
    ///Params:
    ///    pIUnknownCancelCookie = The pointer that was returned in the the <i>ppIUnknownCancelCookie</i> parameter of the
    ///                            IMFMediaEngineExtension::BeginCreateObject method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CancelObjectCreation(IUnknown pIUnknownCancelCookie);
    ///Completes an asynchronous request to create a byte stream or media source.
    ///Params:
    ///    pResult = A pointer to the IMFAsyncResult interface.
    ///    ppObject = Receives a pointer to the IUnknown interface of the byte stream or media source. The caller must release the
    ///               interface
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EndCreateObject(IMFAsyncResult pResult, IUnknown* ppObject);
}

///Enables the Media Engine to play protected video content.
@GUID("9F8021E8-9C8C-487E-BB5C-79AA4779938C")
interface IMFMediaEngineProtectedContent : IUnknown
{
    ///Enables the Media Engine to access protected content while in frame-server mode.
    ///Params:
    ///    pUnkDeviceContext = A pointer to the Direct3D 11 device content. The Media Engine queries this pointer for the ID3D11VideoContext
    ///                        interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ShareResources(IUnknown pUnkDeviceContext);
    ///Gets the content protections that must be applied in frame-server mode.
    ///Params:
    ///    pFrameProtectionFlags = Receives a bitwise <b>OR</b> of zero or more flags from the MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS
    ///                            enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRequiredProtections(uint* pFrameProtectionFlags);
    ///Specifies the window that should receive output link protections.
    ///Params:
    ///    hwnd = A handle to the window.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOPMWindow(HWND hwnd);
    ///Copies a protected video frame to a DXGI surface.
    ///Params:
    ///    pDstSurf = A pointer to the IUnknown interface of the destination surface.
    ///    pSrc = A pointer to an MFVideoNormalizedRect structure that specifies the source rectangle.
    ///    pDst = A pointer to a RECT structure that specifies the destination rectangle.
    ///    pBorderClr = A pointer to an MFARGB structure that specifies the border color.
    ///    pFrameProtectionFlags = Receives a bitwise <b>OR</b> of zero or more flags from the MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS
    ///                            enumeration. These flags indicate which content protections the application must apply before presenting the
    ///                            surface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT TransferVideoFrame(IUnknown pDstSurf, const(MFVideoNormalizedRect)* pSrc, const(RECT)* pDst, 
                               const(MFARGB)* pBorderClr, uint* pFrameProtectionFlags);
    ///Sets the content protection manager (CPM).
    ///Params:
    ///    pCPM = A pointer to the IMFContentProtectionManager interface, implemented by the caller.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetContentProtectionManager(IMFContentProtectionManager pCPM);
    ///Sets the application's certificate.
    ///Params:
    ///    pbBlob = A pointer to a buffer that contains the certificate in X.509 format, followed by the application identifier
    ///             signed with a SHA-256 signature using the private key from the certificate.
    ///    cbBlob = The size of the <i>pbBlob</i> buffer, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetApplicationCertificate(const(ubyte)* pbBlob, uint cbBlob);
}

@GUID("EBBAF249-AFC2-4582-91C6-B60DF2E84954")
interface IAudioSourceProvider : IUnknown
{
    HRESULT ProvideInput(uint dwSampleCount, uint* pdwChannelCount, float* pInterleavedAudioData);
}

///Enables playback of web audio.
@GUID("BA2743A1-07E0-48EF-84B6-9A2ED023CA6C")
interface IMFMediaEngineWebSupport : IUnknown
{
    ///Gets a value indicating if the connecting to Web audio should delay the page's load event.
    ///Returns:
    ///    True if connection to Web audio should delay the page's load event; otherwise, false.
    ///    
    BOOL    ShouldDelayTheLoadEvent();
    ///Connects web audio to Media Engine using the specified sample rate.
    ///Params:
    ///    dwSampleRate = The sample rate of the web audio.
    ///    ppSourceProvider = The sample rate of the web audio.
    ///Returns:
    ///    Returns S_OK on successful completion.
    ///    
    HRESULT ConnectWebAudio(uint dwSampleRate, IAudioSourceProvider* ppSourceProvider);
    ///Disconnects web audio from the Media Engine
    ///Returns:
    ///    Returns S_OK on successful completion.
    ///    
    HRESULT DisconnectWebAudio();
}

///Provides functionality for raising events associated with IMFMediaSourceExtension.
@GUID("A7901327-05DD-4469-A7B7-0E01979E361D")
interface IMFMediaSourceExtensionNotify : IUnknown
{
    ///Used to indicate that the media source has opened.
    void OnSourceOpen();
    ///Used to indicate that the media source has ended.
    void OnSourceEnded();
    ///Used to indicate that the media source has closed.
    void OnSourceClose();
}

///Enables IMFSourceBufferList object to notify its clients of important state changes.
@GUID("24CD47F7-81D8-4785-ADB2-AF697A963CD2")
interface IMFBufferListNotify : IUnknown
{
    ///Indicates that a IMFSourceBuffer has been added.
    void OnAddSourceBuffer();
    ///Indicates that a IMFSourceBuffer has been removed.
    void OnRemoveSourceBuffer();
}

///Provides functionality for raising events associated with IMFSourceBuffer.
@GUID("87E47623-2CEB-45D6-9B88-D8520C4DCBBC")
interface IMFSourceBufferNotify : IUnknown
{
    ///Used to indicate that the source buffer has started updating.
    void OnUpdateStart();
    ///Used to indicate that the source buffer has been aborted.
    void OnAbort();
    ///Used to indicate that an error has occurred with the source buffer.
    ///Params:
    ///    hr = 
    void OnError(HRESULT hr);
    ///Used to indicate that the source buffer is updating.
    void OnUpdate();
    ///Used to indicate that the source buffer has finished updating.
    void OnUpdateEnd();
}

///Represents a buffer which contains media data for a IMFMediaSourceExtension.
@GUID("E2CD3A4B-AF25-4D3D-9110-DA0E6F8EE877")
interface IMFSourceBuffer : IUnknown
{
    ///Gets a value that indicates if Append, AppendByteStream, or Remove is in process.
    ///Returns:
    ///    <b>true</b> if Append, AppendByteStream, or Remove; otherwise, <b>false</b>.
    ///    
    BOOL    GetUpdating();
    ///Gets the buffered time range.
    ///Params:
    ///    ppBuffered = The buffered time range.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetBuffered(IMFMediaTimeRange* ppBuffered);
    ///Gets the timestamp offset for media segments appended to the IMFSourceBuffer.
    ///Returns:
    ///    The timestamp offset.
    ///    
    double  GetTimeStampOffset();
    ///Sets the timestamp offset for media segments appended to the IMFSourceBuffer.
    ///Params:
    ///    offset = 
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetTimeStampOffset(double offset);
    ///Gets the timestamp for the start of the append window.
    ///Returns:
    ///    The timestamp for the start of the append window.
    ///    
    double  GetAppendWindowStart();
    ///Sets the timestamp for the start of the append window.
    ///Params:
    ///    time = The timestamp for the start of the append window.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetAppendWindowStart(double time);
    ///Gets the timestamp for the end of the append window.
    ///Returns:
    ///    The timestamp for the end of the append window.
    ///    
    double  GetAppendWindowEnd();
    ///Sets the timestamp for the end of the append window.
    ///Params:
    ///    time = 
    ///Returns:
    ///    The timestamp for the end of the append window.
    ///    
    HRESULT SetAppendWindowEnd(double time);
    ///Appends the specified media segment to the IMFSourceBuffer.
    ///Params:
    ///    pData = The media data to append.
    ///    len = The length of the media data stored in <i>pData</i>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Append(const(ubyte)* pData, uint len);
    ///Appends the media segment from the specified byte stream to the IMFSourceBuffer.
    ///Params:
    ///    pStream = The media segment data.
    ///    pMaxLen = The maximum length of the media segment data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AppendByteStream(IMFByteStream pStream, ulong* pMaxLen);
    ///Aborts the processing of the current media segment.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Abort();
    ///Removes the media segments defined by the specified time range from the IMFSourceBuffer.
    ///Params:
    ///    start = The start of the time range.
    ///    end = The end of the time range.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Remove(double start, double end);
}

@GUID("19666FB4-BABE-4C55-BC03-0A074DA37E2A")
interface IMFSourceBufferAppendMode : IUnknown
{
    MF_MSE_APPEND_MODE GetAppendMode();
    HRESULT SetAppendMode(MF_MSE_APPEND_MODE mode);
}

///Represents a collection of IMFSourceBuffer objects.
@GUID("249981F8-8325-41F3-B80C-3B9E3AAD0CBE")
interface IMFSourceBufferList : IUnknown
{
    ///Gets the number of IMFSourceBuffer objects in the list.
    ///Returns:
    ///    The number of source buffers in the list.
    ///    
    uint GetLength();
    ///Gets the IMFSourceBuffer at the specified index in the list.
    ///Params:
    ///    index = The index of the source buffer to get.
    ///Returns:
    ///    The source buffer.
    ///    
    IMFSourceBuffer GetSourceBuffer(uint index);
}

///Provides functionality for the Media Source Extension (MSE).
@GUID("E467B94E-A713-4562-A802-816A42E9008A")
interface IMFMediaSourceExtension : IUnknown
{
    ///Gets the collection of source buffers associated with this media source.
    ///Returns:
    ///    The collection of source buffers.
    ///    
    IMFSourceBufferList GetSourceBuffers();
    ///Gets the source buffers that are actively supplying media data to the media source.
    ///Returns:
    ///    The list of active source buffers.
    ///    
    IMFSourceBufferList GetActiveSourceBuffers();
    ///Gets the ready state of the media source.
    ///Returns:
    ///    The ready state of the media source.
    ///    
    MF_MSE_READY GetReadyState();
    ///Gets the duration of the media source in 100-nanosecond units.
    ///Returns:
    ///    The duration of the media source in 100-nanosecond units.
    ///    
    double  GetDuration();
    ///Sets the duration of the media source in 100-nanosecond units.
    ///Params:
    ///    duration = The duration of the media source in 100-nanosecond units.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDuration(double duration);
    ///Adds a IMFSourceBuffer to the collection of buffers associated with the IMFMediaSourceExtension.
    ///Params:
    ///    type = 
    ///    pNotify = 
    ///    ppSourceBuffer = 
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddSourceBuffer(BSTR type, IMFSourceBufferNotify pNotify, IMFSourceBuffer* ppSourceBuffer);
    ///Removes the specified source buffer from the collection of source buffers managed by the IMFMediaSourceExtension
    ///object.
    ///Params:
    ///    pSourceBuffer = The buffer to remove.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveSourceBuffer(IMFSourceBuffer pSourceBuffer);
    ///Indicate that the end of the media stream has been reached.
    ///Params:
    ///    error = Used to pass error information.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetEndOfStream(MF_MSE_ERROR error);
    ///Gets a value that indicates if the specified MIME type is supported by the media source.
    ///Params:
    ///    type = The media type to check support for.
    ///Returns:
    ///    <b>true</b> if the media type is supported; otherwise, <b>false</b>.
    ///    
    BOOL    IsTypeSupported(BSTR type);
    ///Gets the IMFSourceBuffer at the specified index in the collection of buffers.
    ///Params:
    ///    dwStreamIndex = The location of the buffer in the colloection.
    ///Returns:
    ///    The source buffer.
    ///    
    IMFSourceBuffer GetSourceBuffer(uint dwStreamIndex);
}

@GUID("5D1ABFD6-450A-4D92-9EFC-D6B6CBC1F4DA")
interface IMFMediaSourceExtensionLiveSeekableRange : IUnknown
{
    HRESULT SetLiveSeekableRange(double start, double end);
    HRESULT ClearLiveSeekableRange();
}

///Implemented by the media engine to add encrypted media extensions methods.
@GUID("50DC93E4-BA4F-4275-AE66-83E836E57469")
interface IMFMediaEngineEME : IUnknown
{
    ///Gets the media keys object associated with the media engine or <b>null</b> if there is not a media keys object.
    ///Params:
    ///    keys = The media keys object associated with the media engine or <b>null</b> if there is not a media keys object.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Keys(IMFMediaKeys* keys);
    ///Sets the media keys object to use with the media engine.
    ///Params:
    ///    keys = The media keys.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetMediaKeys(IMFMediaKeys keys);
}

///Extends the IMFMediaEngineSrcElements interface to provide additional capabilities.
@GUID("654A6BB3-E1A3-424A-9908-53A43A0DFDA0")
interface IMFMediaEngineSrcElementsEx : IMFMediaEngineSrcElements
{
    ///Provides an enhanced version of IMFMediaEngineSrcElements::AddElement to add the key system intended to be used
    ///with content to an element.
    ///Params:
    ///    pURL = The URL of the source element, or <b>NULL</b>.
    ///    pType = The MIME type of the source element, or <b>NULL</b>.
    ///    pMedia = A media-query string that specifies the intended media type, or <b>NULL</b>. If specified, the string should
    ///             conform to the W3C <i>Media Queries</i> specification.
    ///    keySystem = The media key session.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddElementEx(BSTR pURL, BSTR pType, BSTR pMedia, BSTR keySystem);
    ///Gets the key system for the given source element index.
    ///Params:
    ///    index = The source element index.
    ///    pType = The MIME type of the source element.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetKeySystem(uint index, BSTR* pType);
}

///Represents a callback to the media engine to notify key request data.
@GUID("46A30204-A696-4B18-8804-246B8F031BB1")
interface IMFMediaEngineNeedKeyNotify : IUnknown
{
    ///Notifies the application that a key or keys are needed along with any initialization data.
    ///Params:
    ///    initData = The initialization data.
    ///    cb = The count in bytes of <i>initData</i>.
    void NeedKey(const(ubyte)* initData, uint cb);
}

///Represents a media keys used for decrypting media data using a Digital Rights Management (DRM) key system.
@GUID("5CB31C05-61FF-418F-AFDA-CAAF41421A38")
interface IMFMediaKeys : IUnknown
{
    ///Creates a media key session object using the specified initialization data and custom data. .
    ///Params:
    ///    mimeType = The MIME type of the media container used for the content.
    ///    initData = The initialization data for the key system.
    ///    cb = The count in bytes of <i>initData</i>.
    ///    customData = Custom data sent to the key system.
    ///    cbCustomData = The count in bytes of <i>cbCustomData</i>.
    ///    notify = notify
    ///    ppSession = The media key session.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateSession(BSTR mimeType, const(ubyte)* initData, uint cb, const(ubyte)* customData, 
                          uint cbCustomData, IMFMediaKeySessionNotify notify, IMFMediaKeySession* ppSession);
    ///Gets the key system string the IMFMediaKeys object was created with.
    ///Params:
    ///    keySystem = The string name of the key system.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_KeySystem(BSTR* keySystem);
    ///Shuts down the associated Content Decryption Module (CDM).
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Shutdown();
    ///Gets the suspend notify interface of the Content Decryption Module (CDM).
    ///Params:
    ///    notify = The suspend notify interface of the Content Decryption Module (CDM).
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSuspendNotify(IMFCdmSuspendNotify* notify);
}

///Represents a session with the Digital Rights Management (DRM) key system.
@GUID("24FA67D5-D1D0-4DC5-995C-C0EFDC191FB5")
interface IMFMediaKeySession : IUnknown
{
    ///Gets the error state associated with the media key session.
    ///Params:
    ///    code = The error code.
    ///    systemCode = Platform specific error information.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetError(ushort* code, uint* systemCode);
    ///Gets the name of the key system name the media keys object was created with.
    ///Params:
    ///    keySystem = The name of the key system.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_KeySystem(BSTR* keySystem);
    ///Gets a unique session id created for this session.
    ///Params:
    ///    sessionId = The media key session id.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_SessionId(BSTR* sessionId);
    ///Passes in a key value with any associated data required by the Content Decryption Module for the given key
    ///system.
    ///Params:
    ///    key = 
    ///    cb = The count in bytes of <i>key</i>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Update(const(ubyte)* key, uint cb);
    ///Closes the media key session and must be called before the key session is released.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Close();
}

///Provides a mechanism for notifying the app about information regarding the media key session.
@GUID("6A0083F9-8947-4C1D-9CE0-CDEE22B23135")
interface IMFMediaKeySessionNotify : IUnknown
{
    ///Passes information to the application so it can initiate a key acquisition.
    ///Params:
    ///    destinationURL = The URL to send the message to.
    ///    message = The message to send to the application.
    ///    cb = The length in bytes of <i>message</i>.
    void KeyMessage(BSTR destinationURL, const(ubyte)* message, uint cb);
    ///Notifies the application that the key has been added.
    void KeyAdded();
    ///Notifies the application that an error occurred while processing the key.
    ///Params:
    ///    code = 
    ///    systemCode = 
    void KeyError(ushort code, uint systemCode);
}

///Used to enable the client to notify the Content Decryption Module (CDM) when global resources should be brought into
///a consistent state prior to suspending.
@GUID("7A5645D2-43BD-47FD-87B7-DCD24CC7D692")
interface IMFCdmSuspendNotify : IUnknown
{
    ///Indicates that the suspend process is starting and resources should be brought into a consistent state.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Begin();
    ///The actual suspend is about to occur and no more calls will be made into the Content Decryption Module (CDM).
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT End();
}

@GUID("DE400F54-5BF1-40CF-8964-0BEA136B1E3D")
interface IMFHDCPStatus : IUnknown
{
    HRESULT Query(MF_HDCP_STATUS* pStatus, BOOL* pfStatus);
    HRESULT Set(MF_HDCP_STATUS status);
}

///Provides methods for getting information about the Output Protection Manager (OPM).
@GUID("765763E6-6C01-4B01-BB0F-B829F60ED28C")
interface IMFMediaEngineOPMInfo : IUnknown
{
    ///Gets status information about the Output Protection Manager (OPM).
    ///Params:
    ///    pStatus = A pointer to a MF_MEDIA_ENGINE_OPM_STATUS enum type that indicates the OPM status.
    ///    pConstricted = A pointer to a <b>BOOL</b> type that indicates the constriction status.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>INVALIDARG</b></dt> </dl> </td> <td width="60%"> If any of the parameters are <b>NULL</b>. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetOPMInfo(MF_MEDIA_ENGINE_OPM_STATUS* pStatus, BOOL* pConstricted);
}

///Creates an instance of the Media Engine.
@GUID("4D645ACE-26AA-4688-9BE1-DF3516990B93")
interface IMFMediaEngineClassFactory : IUnknown
{
    ///Creates a new instance of the Media Engine.
    ///Params:
    ///    dwFlags = A bitwise <b>OR</b> of zero or more flags from the MF_MEDIA_ENGINE_CREATEFLAGS enumeration.
    ///    pAttr = A pointer to the IMFAttributes interface of an attribute store. This parameter specifies configuration
    ///            attributes for the Media Engine. Call MFCreateAttributes to create the attribute store. Then, set one or more
    ///            attributes from the list of Media Engine Attributes. For details, see Remarks.
    ///    ppPlayer = Receives a pointer to the IMFMediaEngine interface. The caller must release the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> A required attribute
    ///    was missing from <i>pAttr</i>, or an invalid combination of attributes was used. </td> </tr> </table>
    ///    
    HRESULT CreateInstance(uint dwFlags, IMFAttributes pAttr, IMFMediaEngine* ppPlayer);
    ///Creates a time range object.
    ///Params:
    ///    ppTimeRange = Receives a pointer to the IMFMediaTimeRange interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateTimeRange(IMFMediaTimeRange* ppTimeRange);
    ///Creates a media error object.
    ///Params:
    ///    ppError = Receives a pointer to the IMFMediaError interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateError(IMFMediaError* ppError);
}

///Extension for the IMFMediaEngineClassFactory interface.
@GUID("C56156C6-EA5B-48A5-9DF8-FBE035D0929E")
interface IMFMediaEngineClassFactoryEx : IMFMediaEngineClassFactory
{
    ///Creates an instance of IMFMediaSourceExtension.
    ///Params:
    ///    dwFlags = This parameter is reserved and must be set to 0.
    ///    pAttr = This method supports the following Media Foundation attributes: <ul> <li> MF_MSE_CALLBACK </li> <li>
    ///            MF_MSE_BUFFERLIST_CALLBACK </li> <li> MF_MSE_ACTIVELIST_CALLBACK </li> </ul>
    ///    ppMSE = The IMFMediaSourceExtension which was created.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateMediaSourceExtension(uint dwFlags, IMFAttributes pAttr, IMFMediaSourceExtension* ppMSE);
    ///Creates a media keys object based on the specified key system.
    ///Params:
    ///    keySystem = The media keys system.
    ///    cdmStorePath = Points to a location to store Content Decryption Module (CDM) data which might be locked by multiple process
    ///                   and so might be incompatible with store app suspension.
    ///    ppKeys = The media keys.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateMediaKeys(BSTR keySystem, BSTR cdmStorePath, IMFMediaKeys* ppKeys);
    ///Gets a value that indicates if the specified key system supports the specified media type.
    ///Params:
    ///    type = The MIME type to check support for.
    ///    keySystem = The key system to check support for.
    ///    isSupported = <b>true</b> if type is supported by <i>keySystem</i>; otherwise, <b>false.</b>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IsTypeSupported(BSTR type, BSTR keySystem, BOOL* isSupported);
}

///Creates an instance of the IMFMediaKeys object.
@GUID("09083CEF-867F-4BF6-8776-DEE3A7B42FCA")
interface IMFMediaEngineClassFactory2 : IUnknown
{
    ///Creates a media keys object based on the specified key system.
    ///Params:
    ///    keySystem = The media key system.
    ///    defaultCdmStorePath = Points to the default file location for the store Content Decryption Module (CDM) data.
    ///    inprivateCdmStorePath = Points to a the inprivate location for the store Content Decryption Module (CDM) data. Specifying this path
    ///                            allows the CDM to comply with the applicationâ€™s privacy policy by putting personal information in the file
    ///                            location indicated by this path.
    ///    ppKeys = Receives the media keys.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateMediaKeys2(BSTR keySystem, BSTR defaultCdmStorePath, BSTR inprivateCdmStorePath, 
                             IMFMediaKeys* ppKeys);
}

@GUID("332EC562-3758-468D-A784-E38F23552128")
interface IMFExtendedDRMTypeSupport : IUnknown
{
    HRESULT IsTypeSupportedEx(BSTR type, BSTR keySystem, MF_MEDIA_ENGINE_CANPLAY* pAnswer);
}

///Enables the media source to be transferred between the media engine and the sharing engine for Play To.
@GUID("A724B056-1B2E-4642-A6F3-DB9420C52908")
interface IMFMediaEngineSupportsSourceTransfer : IUnknown
{
    ///Specifies wether or not the source should be transferred.
    ///Params:
    ///    pfShouldTransfer = <b>true</b> if the source should be transferred; otherwise, <b>false</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ShouldTransferSource(BOOL* pfShouldTransfer);
    ///Detaches the media source.
    ///Params:
    ///    ppByteStream = Receives the byte stream.
    ///    ppMediaSource = Receives the media source.
    ///    ppMSE = Receives the media source extension.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT DetachMediaSource(IMFByteStream* ppByteStream, IMFMediaSource* ppMediaSource, 
                              IMFMediaSourceExtension* ppMSE);
    ///Attaches the media source.
    ///Params:
    ///    pByteStream = Specifies the byte stream.
    ///    pMediaSource = Specifies the media source.
    ///    pMSE = Specifies the media source extension.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AttachMediaSource(IMFByteStream pByteStream, IMFMediaSource pMediaSource, IMFMediaSourceExtension pMSE);
}

@GUID("24230452-FE54-40CC-94F3-FCC394C340D6")
interface IMFMediaEngineTransferSource : IUnknown
{
    HRESULT TransferSourceToMediaEngine(IMFMediaEngine destination);
}

///A timed-text object represents a component of timed text.
@GUID("1F2A94C9-A3DF-430D-9D0F-ACD85DDC29AF")
interface IMFTimedText : IUnknown
{
    ///Registers a timed-text notify object.
    ///Params:
    ///    notify = Type: <b>IMFTimedTextNotify*</b> A pointer to the IMFTimedTextNotify interface for the timed-text notify
    ///             object to register.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RegisterNotifications(IMFTimedTextNotify notify);
    ///Selects or deselects a track of text in the timed-text component.
    ///Params:
    ///    trackId = Type: <b>DWORD</b> The identifier of the track to select.
    ///    selected = Type: <b>BOOL</b> Specifies whether to select or deselect a track of text. Specify <b>TRUE</b> to select the
    ///               track or <b>FALSE</b> to deselect the track.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SelectTrack(uint trackId, BOOL selected);
    ///Adds a timed-text data source.
    ///Params:
    ///    byteStream = Type: <b>IMFByteStream*</b> A pointer to the IMFByteStream interface for the data source to add.
    ///    label = Type: <b>LPCWSTR</b> Null-terminated wide-character string that contains the label of the data source.
    ///    language = Type: <b>LPCWSTR</b> Null-terminated wide-character string that contains the language of the data source.
    ///    kind = Type: <b>MF_TIMED_TEXT_TRACK_KIND</b> A MF_TIMED_TEXT_TRACK_KIND-typed value that specifies the kind of
    ///           timed-text track.
    ///    isDefault = Type: <b>BOOL</b> Specifies whether to add the default data source. Specify <b>TRUE</b> to add the default
    ///                data source or <b>FALSE</b> otherwise.
    ///    trackId = Type: <b>DWORD*</b> Receives a pointer to the unique identifier for the added track.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddDataSource(IMFByteStream byteStream, const(PWSTR) label, const(PWSTR) language, 
                          MF_TIMED_TEXT_TRACK_KIND kind, BOOL isDefault, uint* trackId);
    ///Adds a timed-text data source from the specified URL.
    ///Params:
    ///    url = Type: <b>LPCWSTR</b> The URL of the timed-text data source.
    ///    label = Type: <b>LPCWSTR</b> Null-terminated wide-character string that contains the label of the data source.
    ///    language = Type: <b>LPCWSTR</b> Null-terminated wide-character string that contains the language of the data source.
    ///    kind = Type: <b>MF_TIMED_TEXT_TRACK_KIND</b> A MF_TIMED_TEXT_TRACK_KIND-typed value that specifies the kind of
    ///           timed-text track.
    ///    isDefault = Type: <b>BOOL</b> Specifies whether to add the default data source. Specify <b>TRUE</b> to add the default
    ///                data source or <b>FALSE</b> otherwise.
    ///    trackId = Type: <b>DWORD*</b> Receives a pointer to the unique identifier for the added track.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddDataSourceFromUrl(const(PWSTR) url, const(PWSTR) label, const(PWSTR) language, 
                                 MF_TIMED_TEXT_TRACK_KIND kind, BOOL isDefault, uint* trackId);
    HRESULT AddTrack(const(PWSTR) label, const(PWSTR) language, MF_TIMED_TEXT_TRACK_KIND kind, 
                     IMFTimedTextTrack* track);
    ///Removes the timed-text track with the specified identifier.
    ///Params:
    ///    track = Type: <b>DWORD</b> The identifier of the track to remove.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveTrack(IMFTimedTextTrack track);
    ///Gets the offset to the cue time.
    ///Params:
    ///    offset = Type: <b>double*</b> A pointer to a variable that receives the offset to the cue time.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCueTimeOffset(double* offset);
    ///Sets the offset to the cue time.
    ///Params:
    ///    offset = Type: <b>double</b> The offset to the cue time.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetCueTimeOffset(double offset);
    ///Retrieves a list of all timed-text tracks registered with the IMFTimedText.
    ///Params:
    ///    tracks = Type: <b>IMFTimedTextTrackList**</b> Receives a pointer to track list.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTracks(IMFTimedTextTrackList* tracks);
    ///Gets the list of active timed-text tracks in the timed-text component.
    ///Params:
    ///    activeTracks = Type: <b>IMFTimedTextTrackList**</b> A pointer to a memory block that receives a pointer to the
    ///                   IMFTimedTextTrackList interface that can enumerate the list of active timed-text tracks.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetActiveTracks(IMFTimedTextTrackList* activeTracks);
    ///Gets the list of all the timed-text tracks in the timed-text component.
    ///Params:
    ///    textTracks = Type: <b>IMFTimedTextTrackList**</b> A pointer to a memory block that receives a pointer to the
    ///                 IMFTimedTextTrackList interface that can enumerate the list of all of the timed-text tracks.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTextTracks(IMFTimedTextTrackList* textTracks);
    ///Gets the list of the timed-metadata tracks in the timed-text component.
    ///Params:
    ///    metadataTracks = Type: <b>IMFTimedTextTrackList**</b> A pointer to a memory block that receives a pointer to the
    ///                     IMFTimedTextTrackList interface that can enumerate the list of the timed-metadata tracks.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMetadataTracks(IMFTimedTextTrackList* metadataTracks);
    ///Enables or disables inband mode.
    ///Params:
    ///    enabled = Type: <b>BOOL</b> Specifies whether inband mode is enabled. If <b>TRUE</b>, inband mode is enabled. If
    ///              <b>FALSE</b>, inband mode is disabled.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetInBandEnabled(BOOL enabled);
    ///Determines whether inband mode is enabled.
    ///Returns:
    ///    Type: <b>BOOL</b> Returns whether inband mode is enabled. If <b>TRUE</b>, inband mode is enabled. If
    ///    <b>FALSE</b>, inband mode is disabled.
    ///    
    BOOL    IsInBandEnabled();
}

///Interface that defines callbacks for Microsoft Media Foundation Timed Text notifications.
@GUID("DF6B87B6-CE12-45DB-ABA7-432FE054E57D")
interface IMFTimedTextNotify : IUnknown
{
    ///Called when a text track is added
    ///Params:
    ///    trackId = Type: <b>DWORD</b> The identifier of the track that was added.
    void TrackAdded(uint trackId);
    ///Called when a text track is removed.
    ///Params:
    ///    trackId = Type: <b>DWORD</b> The identifier of the track that was removed.
    void TrackRemoved(uint trackId);
    ///Called when a track is selected or deselected.
    ///Params:
    ///    trackId = Type: <b>DWORD</b> The identifier of the track that was selected or deselected.
    ///    selected = Type: <b>BOOL</b> <b>TRUE</b> if the track was selected. <b>FALSE</b> if the track was deselected.
    void TrackSelected(uint trackId, BOOL selected);
    void TrackReadyStateChanged(uint trackId);
    ///Called when an error occurs in a text track.
    ///Params:
    ///    errorCode = Type: <b>MF_TIMED_TEXT_ERROR_CODE</b> An MF_TIMED_TEXT_ERROR_CODE representing the last error.
    ///    extendedErrorCode = Type: <b>extendedErrorCode</b> The extended error code for the last error.
    ///    sourceTrackId = Type: <b>extendedErrorCode</b> The identifier of the track on which the error occurred.
    void Error(MF_TIMED_TEXT_ERROR_CODE errorCode, HRESULT extendedErrorCode, uint sourceTrackId);
    ///Called when a cue event occurs in a text track.
    ///Params:
    ///    cueEvent = Type: <b>MF_TIMED_TEXT_CUE_EVENT</b> A value specifying the type of event that has occured.
    ///    currentTime = Type: <b>double</b> The current time when the cue event occurred.
    ///    cue = Type: <b>IMFTimedTextCue*</b> The IMFTimedTextCue object representing the cue.
    void Cue(MF_TIMED_TEXT_CUE_EVENT cueEvent, double currentTime, IMFTimedTextCue cue);
    ///Resets the timed-text-notify object.
    void Reset();
}

///Represents a track of timed text.
@GUID("8822C32D-654E-4233-BF21-D7F2E67D30D4")
interface IMFTimedTextTrack : IUnknown
{
    ///Gets the identifier of the track of timed text.
    ///Returns:
    ///    Type: <b>DWORD</b> Returns the identifier of the track.
    ///    
    uint    GetId();
    ///Gets the label of the track.
    ///Params:
    ///    label = Type: <b>LPCWSTR*</b> A pointer to a variable that receives the null-terminated wide-character string that
    ///            contains the label of the track.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLabel(PWSTR* label);
    ///Sets the label of a timed-text track.
    ///Params:
    ///    label = Type: <b>LPCWSTR</b> A pointer to a null-terminated wide-character string that contains the label of the
    ///            track.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetLabel(const(PWSTR) label);
    ///Gets the language of the track.
    ///Params:
    ///    language = Type: <b>LPCWSTR*</b> A pointer to a variable that receives the null-terminated wide-character string that
    ///               contains the language of the track.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLanguage(PWSTR* language);
    ///Gets the kind of timed-text track.
    ///Returns:
    ///    Type: <b>MF_TIMED_TEXT_TRACK_KIND</b> Returns a MF_TIMED_TEXT_TRACK_KIND-typed value that specifies the kind
    ///    of timed-text track.
    ///    
    MF_TIMED_TEXT_TRACK_KIND GetTrackKind();
    ///Determines whether the timed-text track is inband.
    ///Returns:
    ///    Type: <b>BOOL</b> Returns whether the timed-text track is inband. If <b>TRUE</b>, the timed-text track is
    ///    inband; otherwise, <b>FALSE</b>.
    ///    
    BOOL    IsInBand();
    ///Gets the in-band metadata of the track.
    ///Params:
    ///    dispatchType = Type: <b>LPCWSTR*</b> A pointer to a variable that receives the null-terminated wide-character string that
    ///                   contains the in-band metadata of the track.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetInBandMetadataTrackDispatchType(PWSTR* dispatchType);
    ///Determines whether the timed-text track is active.
    ///Returns:
    ///    Type: <b>BOOL</b> Returns whether the timed-text track is active. If <b>TRUE</b>, the timed-text track is
    ///    active; otherwise, <b>FALSE</b>.
    ///    
    BOOL    IsActive();
    ///Gets a value indicating the error type of the latest error associated with the track.
    ///Returns:
    ///    Type: <b>MF_TIMED_TEXT_ERROR_CODE</b> A value indicating the error type of the latest error associated with
    ///    the track.
    ///    
    MF_TIMED_TEXT_ERROR_CODE GetErrorCode();
    ///Gets the extended error code for the latest error associated with the track.
    ///Returns:
    ///    Type: <b>HRESULT</b> The extended error code for the latest error associated with the track.
    ///    
    HRESULT GetExtendedErrorCode();
    ///Gets a GUID that identifies the track's underlying data format.
    ///Params:
    ///    format = Type: <b>GUID*</b> A GUID that identifies the track's underlying data format.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDataFormat(GUID* format);
    MF_TIMED_TEXT_TRACK_READY_STATE GetReadyState();
    HRESULT GetCueList(IMFTimedTextCueList* cues);
}

///Represents a list of timed-text tracks.
@GUID("23FF334C-442C-445F-BCCC-EDC438AA11E2")
interface IMFTimedTextTrackList : IUnknown
{
    ///Gets the length, in tracks, of the timed-text-track list.
    ///Returns:
    ///    Type: <b>DWORD</b> Returns the length, in tracks, of the timed-text-track list.
    ///    
    uint    GetLength();
    ///Gets a text track in the list from the index of the track.
    ///Params:
    ///    index = Type: <b>DWORD</b> The index of the track in the list to retrieve.
    ///    track = Type: <b>IMFTimedTextTrack**</b> A pointer to a memory block that receives a pointer to the IMFTimedTextTrack
    ///            interface for the timed-text track.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTrack(uint index, IMFTimedTextTrack* track);
    ///Gets a text track in the list from the identifier of the track.
    ///Params:
    ///    trackId = Type: <b>DWORD</b> The identifier of the track in the list to retrieve.
    ///    track = Type: <b>IMFTimedTextTrack**</b> A pointer to a memory block that receives a pointer to the IMFTimedTextTrack
    ///            interface for the timed-text track.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTrackById(uint trackId, IMFTimedTextTrack* track);
}

///Represents the timed-text-cue object.
@GUID("1E560447-9A2B-43E1-A94C-B0AAABFBFBC9")
interface IMFTimedTextCue : IUnknown
{
    ///Gets the identifier of a timed-text cue.
    ///Returns:
    ///    Type: <b>DWORD </b> The identifier of a timed-text cue.
    ///    
    uint    GetId();
    ///Gets the cue identifier that is provided in the text-track data format, if available.
    ///Params:
    ///    originalId = Type: <b>LPWSTR*</b> The cue identifier that is provided in the text-track data format.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetOriginalId(PWSTR* originalId);
    ///Gets the kind of timed-text cue.
    ///Returns:
    ///    Type: <b>MF_TIMED_TEXT_TRACK_KIND</b> Returns a MF_TIMED_TEXT_TRACK_KIND-typed value that specifies the kind
    ///    of timed-text cue.
    ///    
    MF_TIMED_TEXT_TRACK_KIND GetCueKind();
    ///Gets the start time of the cue in the track.
    ///Returns:
    ///    Type: <b>double</b> Returns the start time of the cue in the track.
    ///    
    double  GetStartTime();
    ///Gets the duration time of the cue in the track.
    ///Returns:
    ///    Type: <b>double</b> Returns the duration time of the cue in the track.
    ///    
    double  GetDuration();
    ///Gets the identifier of the timed-text cue.
    ///Returns:
    ///    Type: <b>DWORD</b> Returns the identifier of the timed-text cue.
    ///    
    uint    GetTrackId();
    ///Gets the data content of the timed-text cue.
    ///Params:
    ///    data = Type: <b>IMFTimedTextBinary**</b> A pointer to a memory block that receives a pointer to the
    ///           IMFTimedTextBinary interface for the data content of the timed-text cue. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetData(IMFTimedTextBinary* data);
    ///Gets info about the display region of the timed-text cue.
    ///Params:
    ///    region = Type: <b>IMFTimedTextRegion**</b> A pointer to a memory block that receives a pointer to the
    ///             IMFTimedTextRegion interface for the timed-text region. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRegion(IMFTimedTextRegion* region);
    ///Gets info about the style of the timed-text cue.
    ///Params:
    ///    style = Type: <b>IMFTimedTextStyle**</b> A pointer to a memory block that receives a pointer to the IMFTimedTextStyle
    ///            interface for the timed-text style. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStyle(IMFTimedTextStyle* style);
    ///Gets the number of lines of text in the timed-text cue.
    ///Returns:
    ///    Type: <b>DWORD</b> Returns the number of lines of text.
    ///    
    uint    GetLineCount();
    ///Gets a line of text in the cue from the index of the line.
    ///Params:
    ///    index = Type: <b>DWORD</b> The index of the line of text in the cue to retrieve.
    ///    line = Type: <b>IMFTimedTextFormattedText**</b> A pointer to a memory block that receives a pointer to the
    ///           IMFTimedTextFormattedText interface for the line of text in the cue.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLine(uint index, IMFTimedTextFormattedText* line);
}

///Represents a block of formatted timed-text.
@GUID("E13AF3C1-4D47-4354-B1F5-E83AE0ECAE60")
interface IMFTimedTextFormattedText : IUnknown
{
    ///Gets the text in the formatted timed-text object.
    ///Params:
    ///    text = Type: <b>LPCWSTR*</b> A pointer to a variable that receives the null-terminated wide-character string that
    ///           contains the text.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetText(PWSTR* text);
    ///Gets the number of subformats in the formatted timed-text object.
    ///Returns:
    ///    Type: <b>DWORD</b> Returns the number of subformats.
    ///    
    uint    GetSubformattingCount();
    ///Gets a subformat in the formatted timed-text object.
    ///Params:
    ///    index = Type: <b>DWORD</b> The index of the subformat in the formatted timed-text object.
    ///    firstChar = Type: <b>DWORD*</b> A pointer to a variable that receives the first character of the subformat.
    ///    charLength = Type: <b>DWORD*</b> A pointer to a variable that receives the length, in characters, of the subformat.
    ///    style = Type: <b>IMFTimedTextStyle**</b> A pointer to a memory block that receives a pointer to the IMFTimedTextStyle
    ///            interface for the subformat's timed-text style. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetSubformatting(uint index, uint* firstChar, uint* charLength, IMFTimedTextStyle* style);
}

///Represents the style for timed text.
@GUID("09B2455D-B834-4F01-A347-9052E21C450E")
interface IMFTimedTextStyle : IUnknown
{
    ///Gets the name of the timed-text style.
    ///Params:
    ///    name = Type: <b>LPCWSTR*</b> A pointer to a variable that receives the null-terminated wide-character string that
    ///           contains the name of the style.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetName(PWSTR* name);
    ///Determines whether the timed-text style is external.
    ///Returns:
    ///    Type: <b>BOOL</b> Returns whether the timed-text style is external. If <b>TRUE</b>, the timed-text style is
    ///    external; otherwise, <b>FALSE</b>.
    ///    
    BOOL    IsExternal();
    ///Gets the font family of the timed-text style.
    ///Params:
    ///    fontFamily = Type: <b>LPCWSTR*</b> A pointer to a variable that receives the null-terminated wide-character string that
    ///                 contains the font family of the style.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFontFamily(PWSTR* fontFamily);
    ///Gets the font size of the timed-text style.
    ///Params:
    ///    fontSize = Type: <b>double*</b> A pointer to a variable that receives the font size of the timed-text style.
    ///    unitType = Type: <b>MF_TIMED_TEXT_UNIT_TYPE*</b> A pointer to a variable that receives a MF_TIMED_TEXT_UNIT_TYPE-typed
    ///               value that specifies the units in which the timed-text style is measured.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFontSize(double* fontSize, MF_TIMED_TEXT_UNIT_TYPE* unitType);
    ///Gets the color of the timed-text style.
    ///Params:
    ///    color = Type: <b>MFARGB*</b> A pointer to a variable that receives a MFARGB structure that describes the color.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetColor(MFARGB* color);
    ///Gets the background color of the timed-text style.
    ///Params:
    ///    bgColor = Type: <b>MFARGB*</b> A pointer to a variable that receives a MFARGB structure that describes the background
    ///              color.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetBackgroundColor(MFARGB* bgColor);
    ///Determines whether the style of timed text always shows the background.
    ///Params:
    ///    showBackgroundAlways = Type: <b>BOOL*</b> A pointer to a variable that receives a value that specifies whether the style of timed
    ///                           text always shows the background. The variable specifies <b>TRUE</b> if the background is always shown;
    ///                           otherwise, <b>FALSE</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetShowBackgroundAlways(BOOL* showBackgroundAlways);
    ///Gets the font style of the timed-text style.
    ///Params:
    ///    fontStyle = Type: <b>MF_TIMED_TEXT_FONT_STYLE*</b> A pointer to a variable that receives a MF_TIMED_TEXT_FONT_STYLE-typed
    ///                value that specifies the font style.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetFontStyle(MF_TIMED_TEXT_FONT_STYLE* fontStyle);
    ///Determines whether the style of timed text is bold.
    ///Params:
    ///    bold = Type: <b>BOOL*</b> A pointer to a variable that receives a value that specifies whether the style of timed
    ///           text is bold. The variable specifies <b>TRUE</b> if the style is bold; otherwise, <b>FALSE</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetBold(BOOL* bold);
    ///Determines whether the right to left writing mode of the timed-text style is enabled.
    ///Params:
    ///    rightToLeft = Type: <b>BOOL*</b> A pointer to a variable that receives a value that specifies whether the right to left
    ///                  writing mode is enabled. The variable specifies <b>TRUE</b> if the right to left writing mode is enabled;
    ///                  otherwise, <b>FALSE</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRightToLeft(BOOL* rightToLeft);
    ///Gets the text alignment of the timed-text style.
    ///Params:
    ///    textAlign = Type: <b>MF_TIMED_TEXT_ALIGNMENT*</b> A pointer to a variable that receives a MF_TIMED_TEXT_ALIGNMENT-typed
    ///                value that specifies the text alignment.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTextAlignment(MF_TIMED_TEXT_ALIGNMENT* textAlign);
    ///Gets how text is decorated for the timed-text style.
    ///Params:
    ///    textDecoration = Type: <b>DWORD*</b> A pointer to a variable that receives a combination of MF_TIMED_TEXT_DECORATION-typed
    ///                     values that are combined by using a bitwise OR operation. The resulting value specifies how text is
    ///                     decorated.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTextDecoration(uint* textDecoration);
    ///Gets the text outline for the timed-text style.
    ///Params:
    ///    color = Type: <b>MFARGB*</b> A pointer to a variable that receives a MFARGB structure that describes the color.
    ///    thickness = Type: <b>double*</b> A pointer to a variable that receives the thickness.
    ///    blurRadius = Type: <b>double*</b> A pointer to a variable that receives the blur radius.
    ///    unitType = Type: <b>MF_TIMED_TEXT_UNIT_TYPE*</b> A pointer to a variable that receives a MF_TIMED_TEXT_UNIT_TYPE-typed
    ///               value that specifies the units in which the timed-text is measured.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTextOutline(MFARGB* color, double* thickness, double* blurRadius, MF_TIMED_TEXT_UNIT_TYPE* unitType);
}

///Represents the display region of a timed-text object.
@GUID("C8D22AFC-BC47-4BDF-9B04-787E49CE3F58")
interface IMFTimedTextRegion : IUnknown
{
    ///Gets the name of the region.
    ///Params:
    ///    name = Type: <b>LPCWSTR*</b> A pointer to a variable that receives the null-terminated wide-character string that
    ///           contains the name of the region.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetName(PWSTR* name);
    ///Gets the position of the region.
    ///Params:
    ///    pX = Type: <b>double*</b> A pointer to a variable that receives the X-coordinate of the position.
    ///    pY = Type: <b>double*</b> A pointer to a variable that receives the Y-coordinate of the position.
    ///    unitType = Type: <b>MF_TIMED_TEXT_UNIT_TYPE*</b> A pointer to a variable that receives a MF_TIMED_TEXT_UNIT_TYPE-typed
    ///               value that specifies the units in which the timed-text region is measured.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPosition(double* pX, double* pY, MF_TIMED_TEXT_UNIT_TYPE* unitType);
    ///Gets the extent of the region.
    ///Params:
    ///    pWidth = Type: <b>double*</b> A pointer to a variable that receives the width of the region.
    ///    pHeight = Type: <b>double*</b> A pointer to a variable that receives the height of the region.
    ///    unitType = Type: <b>MF_TIMED_TEXT_UNIT_TYPE*</b> A pointer to a variable that receives a MF_TIMED_TEXT_UNIT_TYPE-typed
    ///               value that specifies the units in which the timed-text region is measured.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetExtent(double* pWidth, double* pHeight, MF_TIMED_TEXT_UNIT_TYPE* unitType);
    ///Gets the background color of the region.
    ///Params:
    ///    bgColor = Type: <b>MFARGB*</b> A pointer to a variable that receives a MFARGB structure that describes the background
    ///              color.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetBackgroundColor(MFARGB* bgColor);
    ///Gets the writing mode of the region.
    ///Params:
    ///    writingMode = Type: <b>MF_TIMED_TEXT_WRITING_MODE*</b> A pointer to a variable that receives a
    ///                  MF_TIMED_TEXT_WRITING_MODE-typed value that specifies the writing mode of the region.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetWritingMode(MF_TIMED_TEXT_WRITING_MODE* writingMode);
    ///Gets the display alignment of the region.
    ///Params:
    ///    displayAlign = Type: <b>MF_TIMED_TEXT_DISPLAY_ALIGNMENT*</b> A pointer to a variable that receives a
    ///                   MF_TIMED_TEXT_DISPLAY_ALIGNMENT-typed value that specifies the display alignment of the region.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDisplayAlignment(MF_TIMED_TEXT_DISPLAY_ALIGNMENT* displayAlign);
    ///Gets the height of each line of text in the region.
    ///Params:
    ///    pLineHeight = Type: <b>double*</b> A pointer to a variable that receives the height of each line of text in the region.
    ///    unitType = Type: <b>MF_TIMED_TEXT_UNIT_TYPE*</b> A pointer to a variable that receives a MF_TIMED_TEXT_UNIT_TYPE-typed
    ///               value that specifies the units in which the timed-text region is measured.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLineHeight(double* pLineHeight, MF_TIMED_TEXT_UNIT_TYPE* unitType);
    ///Determines whether a clip of text overflowed the region.
    ///Params:
    ///    clipOverflow = Type: <b>BOOL*</b> A pointer to a variable that receives a value that specifies whether a clip of text
    ///                   overflowed the region. The variable specifies <b>TRUE</b> if the clip overflowed; otherwise, <b>FALSE</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetClipOverflow(BOOL* clipOverflow);
    ///Gets the padding that surrounds the region.
    ///Params:
    ///    before = Type: <b>double*</b> A pointer to a variable that receives the padding before the start of the region.
    ///    start = Type: <b>double*</b> A pointer to a variable that receives the start of the region.
    ///    after = Type: <b>double*</b> A pointer to a variable that receives the padding after the end of the region.
    ///    end = Type: <b>double*</b> A pointer to a variable that receives the end of the region.
    ///    unitType = Type: <b>MF_TIMED_TEXT_UNIT_TYPE*</b> A pointer to a variable that receives a MF_TIMED_TEXT_UNIT_TYPE-typed
    ///               value that specifies the units in which the timed-text region is measured.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPadding(double* before, double* start, double* after, double* end, 
                       MF_TIMED_TEXT_UNIT_TYPE* unitType);
    ///Determines whether the word wrap feature is enabled in the region.
    ///Params:
    ///    wrap = Type: <b>BOOL*</b> A pointer to a variable that receives a value that specifies whether the word wrap feature
    ///           is enabled in the region. The variable specifies <b>TRUE</b> if word wrap is enabled; otherwise,
    ///           <b>FALSE</b>.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetWrap(BOOL* wrap);
    ///Gets the Z-index (depth) of the region.
    ///Params:
    ///    zIndex = Type: <b>INT32*</b> A pointer to a variable that receives the Z-index (depth) of the region.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetZIndex(int* zIndex);
    ///Gets the scroll mode of the region.
    ///Params:
    ///    scrollMode = Type: <b>MF_TIMED_TEXT_SCROLL_MODE*</b> A pointer to a variable that receives a
    ///                 MF_TIMED_TEXT_SCROLL_MODE-typed value that specifies the scroll mode of the region.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetScrollMode(MF_TIMED_TEXT_SCROLL_MODE* scrollMode);
}

///Represents the data content of a timed-text object.
@GUID("4AE3A412-0545-43C4-BF6F-6B97A5C6C432")
interface IMFTimedTextBinary : IUnknown
{
    ///Gets the data content of the timed-text object.
    ///Params:
    ///    data = Type: <b>const BYTE**</b> A pointer to a memory block that receives a pointer to the data content of the
    ///           timed-text object.
    ///    length = Type: <b>DWORD*</b> A pointer to a variable that receives the length in bytes of the data content.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b
    ///    xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetData(const(ubyte)** data, uint* length);
}

@GUID("AD128745-211B-40A0-9981-FE65F166D0FD")
interface IMFTimedTextCueList : IUnknown
{
    uint    GetLength();
    HRESULT GetCueByIndex(uint index, IMFTimedTextCue* cue);
    HRESULT GetCueById(uint id, IMFTimedTextCue* cue);
    HRESULT GetCueByOriginalId(const(PWSTR) originalId, IMFTimedTextCue* cue);
    HRESULT AddTextCue(double start, double duration, const(PWSTR) text, IMFTimedTextCue* cue);
    HRESULT AddDataCue(double start, double duration, const(ubyte)* data, uint dataSize, IMFTimedTextCue* cue);
    HRESULT RemoveCue(IMFTimedTextCue cue);
}

@GUID("9E184D15-CDB7-4F86-B49E-566689F4A601")
interface IMFMediaEngineEMENotify : IUnknown
{
    void Encrypted(const(ubyte)* pbInitData, uint cb, BSTR bstrInitDataType);
    void WaitingForKey();
}

@GUID("C3A9E92A-DA88-46B0-A110-6CF953026CB9")
interface IMFMediaKeySessionNotify2 : IMFMediaKeySessionNotify
{
    void KeyMessage2(MF_MEDIAKEYSESSION_MESSAGETYPE eMessageType, BSTR destinationURL, const(ubyte)* pbMessage, 
                     uint cbMessage);
    void KeyStatusChange();
}

@GUID("AEC63FDA-7A97-4944-B35C-6C6DF8085CC3")
interface IMFMediaKeySystemAccess : IUnknown
{
    HRESULT CreateMediaKeys(IPropertyStore pCdmCustomConfig, IMFMediaKeys2* ppKeys);
    HRESULT get_SupportedConfiguration(IPropertyStore* ppSupportedConfiguration);
    HRESULT get_KeySystem(BSTR* pKeySystem);
}

@GUID("3787614F-65F7-4003-B673-EAD8293A0E60")
interface IMFMediaEngineClassFactory3 : IUnknown
{
    HRESULT CreateMediaKeySystemAccess(BSTR keySystem, IPropertyStore* ppSupportedConfigurationsArray, uint uSize, 
                                       IMFMediaKeySystemAccess* ppKeyAccess);
}

@GUID("45892507-AD66-4DE2-83A2-ACBB13CD8D43")
interface IMFMediaKeys2 : IMFMediaKeys
{
    HRESULT CreateSession2(MF_MEDIAKEYSESSION_TYPE eSessionType, 
                           IMFMediaKeySessionNotify2 pMFMediaKeySessionNotify2, IMFMediaKeySession2* ppSession);
    HRESULT SetServerCertificate(const(ubyte)* pbServerCertificate, uint cb);
    HRESULT GetDOMException(HRESULT systemCode, HRESULT* code);
}

@GUID("E9707E05-6D55-4636-B185-3DE21210BD75")
interface IMFMediaKeySession2 : IMFMediaKeySession
{
    HRESULT get_KeyStatuses(MFMediaKeyStatus** pKeyStatusesArray, uint* puSize);
    HRESULT Load(BSTR bstrSessionId, BOOL* pfLoaded);
    HRESULT GenerateRequest(BSTR initDataType, const(ubyte)* pbInitData, uint cb);
    HRESULT get_Expiration(double* dblExpiration);
    HRESULT Remove();
    HRESULT Shutdown();
}

@GUID("FBE256C1-43CF-4A9B-8CB8-CE8632A34186")
interface IMFMediaEngineClassFactory4 : IUnknown
{
    HRESULT CreateContentDecryptionModuleFactory(const(PWSTR) keySystem, const(GUID)* riid, void** ppvObject);
}

///Initializes the Digital Living Network Alliance (DLNA) media sink. The DLNA media sink exposes this interface. To get
///a pointer to this interface, call <b>CoCreateInstance</b>. The CLSID is <b>CLSID_MPEG2DLNASink</b>.
@GUID("0C012799-1B61-4C10-BDA9-04445BE5F561")
interface IMFDLNASinkInit : IUnknown
{
    ///Initializes the Digital Living Network Alliance (DLNA) media sink.
    ///Params:
    ///    pByteStream = Pointer to a byte stream. The DLNA media sink writes data to this byte stream. The byte stream must be
    ///                  writable.
    ///    fPal = If <b>TRUE</b>, the DLNA media sink accepts PAL video formats. Otherwise, it accepts NTSC video formats.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_ALREADY_INITIALIZED</b></b></dt> </dl> </td> <td width="60%">
    ///    The method was already called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt>
    ///    </dl> </td> <td width="60%"> The media sink's IMFMediaSink::Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT Initialize(IMFByteStream pByteStream, BOOL fPal);
}

///Creates an instance of either the sink writer or the source reader.
@GUID("E7FE2E12-661C-40DA-92F9-4F002AB67627")
interface IMFReadWriteClassFactory : IUnknown
{
    ///Creates an instance of the sink writer or source reader, given a URL.
    ///Params:
    ///    clsid = The CLSID of the object to create. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///            id="CLSID_MFSinkWriter"></a><a id="clsid_mfsinkwriter"></a><a id="CLSID_MFSINKWRITER"></a><dl>
    ///            <dt><b><b>CLSID_MFSinkWriter</b></b></dt> </dl> </td> <td width="60%"> Create the sink writer. The
    ///            <i>ppvObject</i> parameter receives an IMFSinkWriter interface pointer. </td> </tr> <tr> <td width="40%"><a
    ///            id="CLSID_MFSourceReader"></a><a id="clsid_mfsourcereader"></a><a id="CLSID_MFSOURCEREADER"></a><dl>
    ///            <dt><b><b>CLSID_MFSourceReader</b></b></dt> </dl> </td> <td width="60%"> Create the source reader. The
    ///            <i>ppvObject</i> parameter receives an IMFSourceReader interface pointer. </td> </tr> </table>
    ///    pwszURL = A null-terminated string that contains a URL. If <i>clsid</i> is CLSID_<b>MFSinkWriter</b>, the URL specifies
    ///              the name of the output file. The sink writer creates a new file with this name. If <i>clsid</i> is
    ///              <b>CLSID_MFSourceReader</b>, the URL specifies the input file for the source reader.
    ///    pAttributes = A pointer to the IMFAttributes interface. You can use this parameter to configure the sink writer or source
    ///                  reader. For more information, see the following topics: <ul> <li> Sink Writer Attributes </li> <li> Source
    ///                  Reader Attributes </li> </ul> This parameter can be <b>NULL</b>.
    ///    riid = The IID of the requested interface.
    ///    ppvObject = Receives a pointer to the requested interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateInstanceFromURL(const(GUID)* clsid, const(PWSTR) pwszURL, IMFAttributes pAttributes, 
                                  const(GUID)* riid, void** ppvObject);
    ///Creates an instance of the sink writer or source reader, given an <b>IUnknown</b> pointer.
    ///Params:
    ///    clsid = The CLSID of the object to create. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///            id="CLSID_MFSinkWriter"></a><a id="clsid_mfsinkwriter"></a><a id="CLSID_MFSINKWRITER"></a><dl>
    ///            <dt><b><b>CLSID_MFSinkWriter</b></b></dt> </dl> </td> <td width="60%"> Create the sink writer. The
    ///            <i>ppvObject</i> parameter receives an IMFSinkWriter interface pointer. </td> </tr> <tr> <td width="40%"><a
    ///            id="CLSID_MFSourceReader"></a><a id="clsid_mfsourcereader"></a><a id="CLSID_MFSOURCEREADER"></a><dl>
    ///            <dt><b><b>CLSID_MFSourceReader</b></b></dt> </dl> </td> <td width="60%"> Create the source reader. The
    ///            <i>ppvObject</i> parameter receives an IMFSourceReader interface pointer. </td> </tr> </table>
    ///    punkObject = A pointer to the <b>IUnknown</b> interface of an object that is used to initialize the source reader or sink
    ///                 writer. The method queries this pointer for one of the following interfaces. <table> <tr> <th>Value</th>
    ///                 <th>Meaning</th> </tr> <tr> <td width="40%"><a id="IMFByteStream"></a><a id="imfbytestream"></a><a
    ///                 id="IMFBYTESTREAM"></a><dl> <dt><b>IMFByteStream</b></dt> </dl> </td> <td width="60%"> Pointer to a byte
    ///                 stream. If <i>clsid</i> is <b>CLSID_MFSinkWriter</b>, the sink writer writes data to this byte stream. If
    ///                 <i>clsid</i> is <b>CLSID_MFSourceReader</b>, this byte stream provides the source data for the source reader.
    ///                 </td> </tr> <tr> <td width="40%"><a id="IMFMediaSink"></a><a id="imfmediasink"></a><a
    ///                 id="IMFMEDIASINK"></a><dl> <dt><b>IMFMediaSink</b></dt> </dl> </td> <td width="60%"> Pointer to a media sink.
    ///                 Applies only when <i>clsid</i> is <b>CLSID_MFSinkWriter</b>. </td> </tr> <tr> <td width="40%"><a
    ///                 id="IMFMediaSource"></a><a id="imfmediasource"></a><a id="IMFMEDIASOURCE"></a><dl>
    ///                 <dt><b>IMFMediaSource</b></dt> </dl> </td> <td width="60%"> Pointer to a media source. Applies only when
    ///                 <i>clsid</i> is <b>CLSID_MFSourceReader</b>. </td> </tr> </table>
    ///    pAttributes = A pointer to the IMFAttributes interface. You can use this parameter to configure the sink writer or source
    ///                  reader. For more information, see the following topics: <ul> <li> Sink Writer Attributes </li> <li> Source
    ///                  Reader Attributes </li> </ul> This parameter can be <b>NULL</b>.
    ///    riid = The IID of the requested interface.
    ///    ppvObject = Receives a pointer to the requested interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateInstanceFromObject(const(GUID)* clsid, IUnknown punkObject, IMFAttributes pAttributes, 
                                     const(GUID)* riid, void** ppvObject);
}

///Implemented by the Microsoft Media Foundation source reader object.
@GUID("70AE66F2-C809-4E4F-8915-BDCB406B7993")
interface IMFSourceReader : IUnknown
{
    ///Queries whether a stream is selected.
    ///Params:
    ///    dwStreamIndex = The stream to query. The value can be any of the following. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///                    </tr> <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The zero-based index of
    ///                    a stream. </td> </tr> <tr> <td width="40%"><a id="MF_SOURCE_READER_FIRST_VIDEO_STREAM"></a><a
    ///                    id="mf_source_reader_first_video_stream"></a><dl> <dt><b><b>MF_SOURCE_READER_FIRST_VIDEO_STREAM</b></b></dt>
    ///                    <dt>0xFFFFFFFC</dt> </dl> </td> <td width="60%"> The first video stream. </td> </tr> <tr> <td width="40%"><a
    ///                    id="MF_SOURCE_READER_FIRST_AUDIO_STREAM"></a><a id="mf_source_reader_first_audio_stream"></a><dl>
    ///                    <dt><b><b>MF_SOURCE_READER_FIRST_AUDIO_STREAM</b></b></dt> <dt>0xFFFFFFFD</dt> </dl> </td> <td width="60%">
    ///                    The first audio stream. </td> </tr> </table>
    ///    pfSelected = Receives <b>TRUE</b> if the stream is selected and will generate data. Receives <b>FALSE</b> if the stream is
    ///                 not selected and will not generate data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamSelection(uint dwStreamIndex, BOOL* pfSelected);
    ///Selects or deselects one or more streams.
    ///Params:
    ///    dwStreamIndex = The stream to set. The value can be any of the following. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///                    <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The zero-based index of a
    ///                    stream. </td> </tr> <tr> <td width="40%"><a id="MF_SOURCE_READER_FIRST_VIDEO_STREAM"></a><a
    ///                    id="mf_source_reader_first_video_stream"></a><dl> <dt><b><b>MF_SOURCE_READER_FIRST_VIDEO_STREAM</b></b></dt>
    ///                    <dt>0xFFFFFFFC</dt> </dl> </td> <td width="60%"> The first video stream. </td> </tr> <tr> <td width="40%"><a
    ///                    id="MF_SOURCE_READER_FIRST_AUDIO_STREAM"></a><a id="mf_source_reader_first_audio_stream"></a><dl>
    ///                    <dt><b><b>MF_SOURCE_READER_FIRST_AUDIO_STREAM</b></b></dt> <dt>0xFFFFFFFD</dt> </dl> </td> <td width="60%">
    ///                    The first audio stream. </td> </tr> <tr> <td width="40%"><a id="MF_SOURCE_READER_ALL_STREAMS"></a><a
    ///                    id="mf_source_reader_all_streams"></a><dl> <dt><b><b>MF_SOURCE_READER_ALL_STREAMS</b></b></dt>
    ///                    <dt>0xFFFFFFFE</dt> </dl> </td> <td width="60%"> All streams. </td> </tr> </table>
    ///    fSelected = Specify <b>TRUE</b> to select streams or <b>FALSE</b> to deselect streams. If a stream is deselected, it will
    ///                not generate data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetStreamSelection(uint dwStreamIndex, BOOL fSelected);
    ///Gets a format that is supported natively by the media source.
    ///Params:
    ///    dwStreamIndex = Specifies which stream to query. The value can be any of the following. <table> <tr> <th>Value</th>
    ///                    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The
    ///                    zero-based index of a stream. </td> </tr> <tr> <td width="40%"><a
    ///                    id="MF_SOURCE_READER_FIRST_VIDEO_STREAM"></a><a id="mf_source_reader_first_video_stream"></a><dl>
    ///                    <dt><b><b>MF_SOURCE_READER_FIRST_VIDEO_STREAM</b></b></dt> <dt>0xFFFFFFFC</dt> </dl> </td> <td width="60%">
    ///                    The first video stream. </td> </tr> <tr> <td width="40%"><a id="MF_SOURCE_READER_FIRST_AUDIO_STREAM"></a><a
    ///                    id="mf_source_reader_first_audio_stream"></a><dl> <dt><b><b>MF_SOURCE_READER_FIRST_AUDIO_STREAM</b></b></dt>
    ///                    <dt>0xFFFFFFFD</dt> </dl> </td> <td width="60%"> The first audio stream. </td> </tr> </table>
    ///    dwMediaTypeIndex = Specifies which media type to query. The value can be any of the following. <table> <tr> <th>Value</th>
    ///                       <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFE</dt> </dl> </td> <td width="60%"> The
    ///                       zero-based index of a media type </td> </tr> <tr> <td width="40%"><a
    ///                       id="MF_SOURCE_READER_CURRENT_TYPE_INDEX"></a><a id="mf_source_reader_current_type_index"></a><dl>
    ///                       <dt><b><b>MF_SOURCE_READER_CURRENT_TYPE_INDEX</b></b></dt> <dt>0xFFFFFFFF</dt> </dl> </td> <td width="60%">
    ///                       The current native media type. </td> </tr> </table>
    ///    ppMediaType = Receives a pointer to the IMFMediaType interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDSTREAMNUMBER</b></b></dt> </dl> </td> <td width="60%"> The
    ///    <i>dwStreamIndex</i> parameter is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>MF_E_NO_MORE_TYPES</b></b></dt> </dl> </td> <td width="60%"> The <i>dwMediaTypeIndex</i> parameter
    ///    is out of range. </td> </tr> </table>
    ///    
    HRESULT GetNativeMediaType(uint dwStreamIndex, uint dwMediaTypeIndex, IMFMediaType* ppMediaType);
    ///Gets the current media type for a stream.
    ///Params:
    ///    dwStreamIndex = The stream to query. The value can be any of the following. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///                    </tr> <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The zero-based index of
    ///                    a stream. </td> </tr> <tr> <td width="40%"><a id="MF_SOURCE_READER_FIRST_VIDEO_STREAM"></a><a
    ///                    id="mf_source_reader_first_video_stream"></a><dl> <dt><b><b>MF_SOURCE_READER_FIRST_VIDEO_STREAM</b></b></dt>
    ///                    <dt>0xFFFFFFFC</dt> </dl> </td> <td width="60%"> The first video stream. </td> </tr> <tr> <td width="40%"><a
    ///                    id="MF_SOURCE_READER_FIRST_AUDIO_STREAM"></a><a id="mf_source_reader_first_audio_stream"></a><dl>
    ///                    <dt><b><b>MF_SOURCE_READER_FIRST_AUDIO_STREAM</b></b></dt> <dt>0xFFFFFFFD</dt> </dl> </td> <td width="60%">
    ///                    The first audio stream. </td> </tr> </table>
    ///    ppMediaType = Receives a pointer to the IMFMediaType interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDSTREAMNUMBER</b></b></dt> </dl> </td> <td width="60%"> The
    ///    <i>dwStreamIndex</i> parameter is invalid. </td> </tr> </table>
    ///    
    HRESULT GetCurrentMediaType(uint dwStreamIndex, IMFMediaType* ppMediaType);
    ///Sets the media type for a stream. This media type defines that format that the Source Reader produces as output.
    ///It can differ from the native format provided by the media source. See Remarks for more information.
    ///Params:
    ///    dwStreamIndex = The stream to configure. The value can be any of the following. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///                    </tr> <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The zero-based index of
    ///                    a stream. </td> </tr> <tr> <td width="40%"><a id="MF_SOURCE_READER_FIRST_VIDEO_STREAM"></a><a
    ///                    id="mf_source_reader_first_video_stream"></a><dl> <dt><b><b>MF_SOURCE_READER_FIRST_VIDEO_STREAM</b></b></dt>
    ///                    <dt>0xFFFFFFFC</dt> </dl> </td> <td width="60%"> The first video stream. </td> </tr> <tr> <td width="40%"><a
    ///                    id="MF_SOURCE_READER_FIRST_AUDIO_STREAM"></a><a id="mf_source_reader_first_audio_stream"></a><dl>
    ///                    <dt><b><b>MF_SOURCE_READER_FIRST_AUDIO_STREAM</b></b></dt> <dt>0xFFFFFFFD</dt> </dl> </td> <td width="60%">
    ///                    The first audio stream. </td> </tr> </table>
    ///    pdwReserved = Reserved. Set to <b>NULL</b>.
    ///    pMediaType = A pointer to the IMFMediaType interface of the media type.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDMEDIATYPE</b></b></dt> </dl> </td> <td width="60%"> At least one
    ///    decoder was found for the native stream type, but the type specified by <i>pMediaType</i> was rejected. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> One
    ///    or more sample requests are still pending. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>MF_E_INVALIDSTREAMNUMBER</b></b></dt> </dl> </td> <td width="60%"> The <i>dwStreamIndex</i>
    ///    parameter is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_TOPO_CODEC_NOT_FOUND</b></b></dt>
    ///    </dl> </td> <td width="60%"> Could not find a decoder for the native stream type. </td> </tr> </table>
    ///    
    HRESULT SetCurrentMediaType(uint dwStreamIndex, uint* pdwReserved, IMFMediaType pMediaType);
    ///Seeks to a new position in the media source.
    ///Params:
    ///    guidTimeFormat = A GUID that specifies the <i>time format</i>. The time format defines the units for the <i>varPosition</i>
    ///                     parameter. The following value is defined for all media sources: <table> <tr> <th>Value</th> <th>Meaning</th>
    ///                     </tr> <tr> <td width="40%"><a id="GUID_NULL"></a><a id="guid_null"></a><dl> <dt><b>GUID_NULL</b></dt> </dl>
    ///                     </td> <td width="60%"> 100-nanosecond units. </td> </tr> </table> Some media sources might support additional
    ///                     values.
    ///    varPosition = The position from which playback will be started. The units are specified by the <i>guidTimeFormat</i>
    ///                  parameter. If the <i>guidTimeFormat</i> parameter is <b>GUID_NULL</b>, set the variant type to <b>VT_I8</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> One or more sample
    ///    requests are still pending. </td> </tr> </table>
    ///    
    HRESULT SetCurrentPosition(const(GUID)* guidTimeFormat, const(PROPVARIANT)* varPosition);
    ///Reads the next sample from the media source.
    ///Params:
    ///    dwStreamIndex = The stream to pull data from. The value can be any of the following. <table> <tr> <th>Value</th>
    ///                    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The
    ///                    zero-based index of a stream. </td> </tr> <tr> <td width="40%"><a
    ///                    id="MF_SOURCE_READER_FIRST_VIDEO_STREAM"></a><a id="mf_source_reader_first_video_stream"></a><dl>
    ///                    <dt><b><b>MF_SOURCE_READER_FIRST_VIDEO_STREAM</b></b></dt> <dt>0xFFFFFFFC</dt> </dl> </td> <td width="60%">
    ///                    The first video stream. </td> </tr> <tr> <td width="40%"><a id="MF_SOURCE_READER_FIRST_AUDIO_STREAM"></a><a
    ///                    id="mf_source_reader_first_audio_stream"></a><dl> <dt><b><b>MF_SOURCE_READER_FIRST_AUDIO_STREAM</b></b></dt>
    ///                    <dt>0xFFFFFFFD</dt> </dl> </td> <td width="60%"> The first audio stream. </td> </tr> <tr> <td width="40%"><a
    ///                    id="MF_SOURCE_READER_ANY_STREAM"></a><a id="mf_source_reader_any_stream"></a><dl>
    ///                    <dt><b><b>MF_SOURCE_READER_ANY_STREAM</b></b></dt> <dt>0xFFFFFFFE</dt> </dl> </td> <td width="60%"> Get the
    ///                    next available sample, regardless of which stream. </td> </tr> </table>
    ///    dwControlFlags = A bitwise <b>OR</b> of zero or more flags from the MF_SOURCE_READER_CONTROL_FLAG enumeration.
    ///    pdwActualStreamIndex = Receives the zero-based index of the stream.
    ///    pdwStreamFlags = Receives a bitwise <b>OR</b> of zero or more flags from the MF_SOURCE_READER_FLAG enumeration.
    ///    pllTimestamp = Receives the time stamp of the sample, or the time of the stream event indicated in <i>pdwStreamFlags</i>.
    ///                   The time is given in 100-nanosecond units.
    ///    ppSample = Receives a pointer to the IMFSample interface or the value <b>NULL</b> (see Remarks). If this parameter
    ///               receives a non-<b>NULL</b> pointer, the caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> Invalid request.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_INVALIDSTREAMNUMBER</b></b></dt> </dl> </td> <td
    ///    width="60%"> The <i>dwStreamIndex</i> parameter is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>MF_E_NOTACCEPTING</b></b></dt> </dl> </td> <td width="60%"> A flush operation is pending. See
    ///    IMFSourceReader::Flush. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl>
    ///    </td> <td width="60%"> Invalid argument. See Remarks. </td> </tr> </table>
    ///    
    HRESULT ReadSample(uint dwStreamIndex, uint dwControlFlags, uint* pdwActualStreamIndex, uint* pdwStreamFlags, 
                       long* pllTimestamp, IMFSample* ppSample);
    ///Flushes one or more streams.
    ///Params:
    ///    dwStreamIndex = The stream to flush. The value can be any of the following. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///                    </tr> <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The zero-based index of
    ///                    a stream. </td> </tr> <tr> <td width="40%"><a id="MF_SOURCE_READER_FIRST_VIDEO_STREAM"></a><a
    ///                    id="mf_source_reader_first_video_stream"></a><dl> <dt><b><b>MF_SOURCE_READER_FIRST_VIDEO_STREAM</b></b></dt>
    ///                    <dt>0xFFFFFFFC</dt> </dl> </td> <td width="60%"> The first video stream. </td> </tr> <tr> <td width="40%"><a
    ///                    id="MF_SOURCE_READER_FIRST_AUDIO_STREAM"></a><a id="mf_source_reader_first_audio_stream"></a><dl>
    ///                    <dt><b><b>MF_SOURCE_READER_FIRST_AUDIO_STREAM</b></b></dt> <dt>0xFFFFFFFD</dt> </dl> </td> <td width="60%">
    ///                    The first audio stream. </td> </tr> <tr> <td width="40%"><a id="MF_SOURCE_READER_ALL_STREAMS"></a><a
    ///                    id="mf_source_reader_all_streams"></a><dl> <dt><b><b>MF_SOURCE_READER_ALL_STREAMS</b></b></dt>
    ///                    <dt>0xFFFFFFFE</dt> </dl> </td> <td width="60%"> All streams. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Flush(uint dwStreamIndex);
    ///Queries the underlying media source or decoder for an interface.
    ///Params:
    ///    dwStreamIndex = The stream or object to query. If the value is <b>MF_SOURCE_READER_MEDIASOURCE</b>, the method queries the
    ///                    media source. Otherwise, it queries the decoder that is associated with the specified stream. The following
    ///                    values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
    ///                    <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The zero-based index of a stream. </td> </tr> <tr> <td
    ///                    width="40%"><a id="MF_SOURCE_READER_FIRST_VIDEO_STREAM"></a><a
    ///                    id="mf_source_reader_first_video_stream"></a><dl> <dt><b><b>MF_SOURCE_READER_FIRST_VIDEO_STREAM</b></b></dt>
    ///                    <dt>0xFFFFFFFC</dt> </dl> </td> <td width="60%"> The first video stream. </td> </tr> <tr> <td width="40%"><a
    ///                    id="MF_SOURCE_READER_FIRST_AUDIO_STREAM"></a><a id="mf_source_reader_first_audio_stream"></a><dl>
    ///                    <dt><b><b>MF_SOURCE_READER_FIRST_AUDIO_STREAM</b></b></dt> <dt>0xFFFFFFFD</dt> </dl> </td> <td width="60%">
    ///                    The first audio stream. </td> </tr> <tr> <td width="40%"><a id="MF_SOURCE_READER_MEDIASOURCE"></a><a
    ///                    id="mf_source_reader_mediasource"></a><dl> <dt><b><b>MF_SOURCE_READER_MEDIASOURCE</b></b></dt>
    ///                    <dt>0xFFFFFFFF</dt> </dl> </td> <td width="60%"> The media source. </td> </tr> </table>
    ///    guidService = A service identifier GUID. If the value is <b>GUID_NULL</b>, the method calls <b>QueryInterface</b> to get
    ///                  the requested interface. Otherwise, the method calls the IMFGetService::GetService method. For a list of
    ///                  service identifiers, see Service Interfaces.
    ///    riid = The interface identifier (IID) of the interface being requested.
    ///    ppvObject = Receives a pointer to the requested interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServiceForStream(uint dwStreamIndex, const(GUID)* guidService, const(GUID)* riid, void** ppvObject);
    ///Gets an attribute from the underlying media source.
    ///Params:
    ///    dwStreamIndex = The stream or object to query. The value can be any of the following. <table> <tr> <th>Value</th>
    ///                    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The
    ///                    zero-based index of a stream. </td> </tr> <tr> <td width="40%"><a
    ///                    id="MF_SOURCE_READER_FIRST_VIDEO_STREAM"></a><a id="mf_source_reader_first_video_stream"></a><dl>
    ///                    <dt><b><b>MF_SOURCE_READER_FIRST_VIDEO_STREAM</b></b></dt> <dt>0xFFFFFFFC</dt> </dl> </td> <td width="60%">
    ///                    The first video stream. </td> </tr> <tr> <td width="40%"><a id="MF_SOURCE_READER_FIRST_AUDIO_STREAM"></a><a
    ///                    id="mf_source_reader_first_audio_stream"></a><dl> <dt><b><b>MF_SOURCE_READER_FIRST_AUDIO_STREAM</b></b></dt>
    ///                    <dt>0xFFFFFFFD</dt> </dl> </td> <td width="60%"> The first audio stream. </td> </tr> <tr> <td width="40%"><a
    ///                    id="MF_SOURCE_READER_MEDIASOURCE"></a><a id="mf_source_reader_mediasource"></a><dl>
    ///                    <dt><b><b>MF_SOURCE_READER_MEDIASOURCE</b></b></dt> <dt>0xFFFFFFFF</dt> </dl> </td> <td width="60%"> The
    ///                    media source. </td> </tr> </table>
    ///    guidAttribute = A GUID that identifies the attribute to retrieve. If the <i>dwStreamIndex</i> parameter equals
    ///                    <b>MF_SOURCE_READER_MEDIASOURCE</b>, <i>guidAttribute</i> can specify one of the following: <ul> <li>A
    ///                    presentation descriptor attribute. For a list of values, see Presentation Descriptor Attributes.</li> <li>
    ///                    MF_SOURCE_READER_MEDIASOURCE_CHARACTERISTICS. Use this value to get characteristics flags from the media
    ///                    source.</li> </ul> Otherwise, if the <i>dwStreamIndex</i> parameter specifies a stream, <i>guidAttribute</i>
    ///                    specifies a stream descriptor attribute. For a list of values, see Stream Descriptor Attributes.
    ///    pvarAttribute = A pointer to a <b>PROPVARIANT</b> that receives the value of the attribute. Call the <b>PropVariantClear</b>
    ///                    function to free the <b>PROPVARIANT</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPresentationAttribute(uint dwStreamIndex, const(GUID)* guidAttribute, PROPVARIANT* pvarAttribute);
}

///Extends the IMFSourceReader interface. The Source Reader implements this interface in Windows 8. To get a pointer to
///this interface, call QueryInterface on the Source Reader.
@GUID("7B981CF0-560E-4116-9875-B099895F23D7")
interface IMFSourceReaderEx : IMFSourceReader
{
    ///Sets the native media type for a stream on the media source.
    ///Params:
    ///    dwStreamIndex = 
    ///    pMediaType = A pointer to the IMFMediaType interface of the media type.
    ///    pdwStreamFlags = Receives a bitwise <b>OR</b> of zero or more of the following flags. <table> <tr> <th>Value</th>
    ///                     <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MF_SOURCE_READERF_ALLEFFECTSREMOVED"></a><a
    ///                     id="mf_source_readerf_alleffectsremoved"></a><dl> <dt><b>MF_SOURCE_READERF_ALLEFFECTSREMOVED</b></dt> </dl>
    ///                     </td> <td width="60%"> All effects were removed from the stream. </td> </tr> <tr> <td width="40%"><a
    ///                     id="MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED"></a><a id="mf_source_readerf_currentmediatypechanged"></a><dl>
    ///                     <dt><b>MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED</b></dt> </dl> </td> <td width="60%"> The current output
    ///                     type changed. </td> </tr> </table>
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> Invalid request. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_INVALIDSTREAMNUMBER</b></b></dt> </dl> </td> <td width="60%">
    ///    The <i>dwStreamIndex</i> parameter is invalid. </td> </tr> </table>
    ///    
    HRESULT SetNativeMediaType(uint dwStreamIndex, IMFMediaType pMediaType, uint* pdwStreamFlags);
    ///Adds a transform, such as an audio or video effect, to a stream.
    ///Params:
    ///    dwStreamIndex = The stream to configure. The value can be any of the following. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///                    </tr> <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The zero-based index of
    ///                    a stream. </td> </tr> <tr> <td width="40%"><a id="MF_SOURCE_READER_FIRST_VIDEO_STREAM"></a><a
    ///                    id="mf_source_reader_first_video_stream"></a><dl> <dt><b><b>MF_SOURCE_READER_FIRST_VIDEO_STREAM</b></b></dt>
    ///                    <dt>0xFFFFFFFC</dt> </dl> </td> <td width="60%"> The first video stream. </td> </tr> <tr> <td width="40%"><a
    ///                    id="MF_SOURCE_READER_FIRST_AUDIO_STREAM"></a><a id="mf_source_reader_first_audio_stream"></a><dl>
    ///                    <dt><b><b>MF_SOURCE_READER_FIRST_AUDIO_STREAM</b></b></dt> <dt>0xFFFFFFFD</dt> </dl> </td> <td width="60%">
    ///                    The first audio stream. </td> </tr> </table>
    ///    pTransformOrActivate = A pointer to one of the following: <ul> <li>A Media Foundation transform (MFT) that exposes the IMFTransform
    ///                           interface.</li> <li>An MFT activation object that exposes the IMFActivate interface.</li> </ul>
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> The transform does not
    ///    support the current stream format, and no conversion was possible. See Remarks for more information. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> Invalid
    ///    request. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_INVALIDSTREAMNUMBER</b></b></dt> </dl> </td>
    ///    <td width="60%"> The <i>dwStreamIndex</i> parameter is invalid. </td> </tr> </table>
    ///    
    HRESULT AddTransformForStream(uint dwStreamIndex, IUnknown pTransformOrActivate);
    ///Removes all of the Media Foundation transforms (MFTs) for a specified stream, with the exception of the decoder.
    ///Params:
    ///    dwStreamIndex = The stream for which to remove the MFTs. The value can be any of the following. <table> <tr> <th>Value</th>
    ///                    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The
    ///                    zero-based index of a stream. </td> </tr> <tr> <td width="40%"><a
    ///                    id="MF_SOURCE_READER_FIRST_VIDEO_STREAM"></a><a id="mf_source_reader_first_video_stream"></a><dl>
    ///                    <dt><b><b>MF_SOURCE_READER_FIRST_VIDEO_STREAM</b></b></dt> <dt>0xFFFFFFFC</dt> </dl> </td> <td width="60%">
    ///                    The first video stream. </td> </tr> <tr> <td width="40%"><a id="MF_SOURCE_READER_FIRST_AUDIO_STREAM"></a><a
    ///                    id="mf_source_reader_first_audio_stream"></a><dl> <dt><b><b>MF_SOURCE_READER_FIRST_AUDIO_STREAM</b></b></dt>
    ///                    <dt>0xFFFFFFFD</dt> </dl> </td> <td width="60%"> The first audio stream. </td> </tr> </table>
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> Invalid request. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_INVALIDSTREAMNUMBER</b></b></dt> </dl> </td> <td width="60%">
    ///    The <i>dwStreamIndex</i> parameter is invalid. </td> </tr> </table>
    ///    
    HRESULT RemoveAllTransformsForStream(uint dwStreamIndex);
    ///Gets a pointer to a Media Foundation transform (MFT) for a specified stream.
    ///Params:
    ///    dwStreamIndex = The stream to query for the MFT. The value can be any of the following. <table> <tr> <th>Value</th>
    ///                    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0â€“0xFFFFFFFB</dt> </dl> </td> <td width="60%"> The
    ///                    zero-based index of a stream. </td> </tr> <tr> <td width="40%"><a
    ///                    id="MF_SOURCE_READER_FIRST_VIDEO_STREAM"></a><a id="mf_source_reader_first_video_stream"></a><dl>
    ///                    <dt><b><b>MF_SOURCE_READER_FIRST_VIDEO_STREAM</b></b></dt> <dt>0xFFFFFFFC</dt> </dl> </td> <td width="60%">
    ///                    The first video stream. </td> </tr> <tr> <td width="40%"><a id="MF_SOURCE_READER_FIRST_AUDIO_STREAM"></a><a
    ///                    id="mf_source_reader_first_audio_stream"></a><dl> <dt><b><b>MF_SOURCE_READER_FIRST_AUDIO_STREAM</b></b></dt>
    ///                    <dt>0xFFFFFFFD</dt> </dl> </td> <td width="60%"> The first audio stream. </td> </tr> </table>
    ///    dwTransformIndex = The zero-based index of the MFT to retreive.
    ///    pGuidCategory = Receives a GUID that specifies the category of the MFT. For a list of possible values, see MFT_CATEGORY.
    ///    ppTransform = Receives a pointer to the IMFTransform interface of the MFT. The caller must release the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDINDEX</b></dt> </dl> </td> <td width="60%"> The <i>dwTransformIndex</i>
    ///    parameter is out of range. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>MF_E_INVALIDSTREAMNUMBER</b></b></dt> </dl> </td> <td width="60%"> The <i>dwStreamIndex</i>
    ///    parameter is invalid. </td> </tr> </table>
    ///    
    HRESULT GetTransformForStream(uint dwStreamIndex, uint dwTransformIndex, GUID* pGuidCategory, 
                                  IMFTransform* ppTransform);
}

///Callback interface for the Microsoft Media Foundation source reader.
@GUID("DEEC8D99-FA1D-4D82-84C2-2C8969944867")
interface IMFSourceReaderCallback : IUnknown
{
    ///Called when the IMFSourceReader::ReadSample method completes.
    ///Params:
    ///    hrStatus = The status code. If an error occurred while processing the next sample, this parameter contains the error
    ///               code.
    ///    dwStreamIndex = The zero-based index of the stream that delivered the sample.
    ///    dwStreamFlags = A bitwise <b>OR</b> of zero or more flags from the MF_SOURCE_READER_FLAG enumeration.
    ///    llTimestamp = The time stamp of the sample, or the time of the stream event indicated in <i>dwStreamFlags</i>. The time is
    ///                  given in 100-nanosecond units.
    ///    pSample = A pointer to the IMFSample interface of a media sample. This parameter might be <b>NULL</b>.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Currently, the source reader ignores the return value.
    ///    
    HRESULT OnReadSample(HRESULT hrStatus, uint dwStreamIndex, uint dwStreamFlags, long llTimestamp, 
                         IMFSample pSample);
    ///Called when the IMFSourceReader::Flush method completes.
    ///Params:
    ///    dwStreamIndex = The index of the stream that was flushed, or <b>MF_SOURCE_READER_ALL_STREAMS</b> if all streams were flushed.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Currently, the source reader ignores the return value.
    ///    
    HRESULT OnFlush(uint dwStreamIndex);
    ///Called when the source reader receives certain events from the media source.
    ///Params:
    ///    dwStreamIndex = For stream events, the value is the zero-based index of the stream that sent the event. For source events,
    ///                    the value is <b>MF_SOURCE_READER_MEDIASOURCE</b>.
    ///    pEvent = A pointer to the IMFMediaEvent interface of the event.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Currently, the source reader ignores the return value.
    ///    
    HRESULT OnEvent(uint dwStreamIndex, IMFMediaEvent pEvent);
}

///Extends the IMFSourceReaderCallback interface.
@GUID("CF839FE6-8C2A-4DD2-B6EA-C22D6961AF05")
interface IMFSourceReaderCallback2 : IMFSourceReaderCallback
{
    ///Called when the transform chain in the IMFSourceReader is built or modified.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Currently, the source reader ignores the return value.
    ///    
    HRESULT OnTransformChange();
    ///Called when an asynchronous error occurs with the IMFSourceReader.
    ///Params:
    ///    dwStreamIndex = The index of the stream of the transform that raised the asynchronous error.
    ///    hrStatus = The error that occurred.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Currently, the source reader ignores the return value.
    ///    
    HRESULT OnStreamError(uint dwStreamIndex, HRESULT hrStatus);
}

///Implemented by the Microsoft Media Foundation sink writer object.
@GUID("3137F1CD-FE5E-4805-A5D8-FB477448CB3D")
interface IMFSinkWriter : IUnknown
{
    ///Adds a stream to the sink writer.
    ///Params:
    ///    pTargetMediaType = A pointer to the IMFMediaType interface of a media type. This media type specifies the format of the samples
    ///                       that will be written to the file. It does not need to match the input format. To set the input format, call
    ///                       IMFSinkWriter::SetInputMediaType.
    ///    pdwStreamIndex = Receives the zero-based index of the new stream.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AddStream(IMFMediaType pTargetMediaType, uint* pdwStreamIndex);
    ///Sets the input format for a stream on the sink writer.
    ///Params:
    ///    dwStreamIndex = The zero-based index of the stream. The index is received by the <i>pdwStreamIndex</i> parameter of the
    ///                    IMFSinkWriter::AddStream method.
    ///    pInputMediaType = A pointer to the IMFMediaType interface of a media type. The media type specifies the input format.
    ///    pEncodingParameters = A pointer to the IMFAttributes interface of an attribute store. Use the attribute store to configure the
    ///                          encoder. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDMEDIATYPE</b></b></dt> </dl> </td> <td width="60%"> The underlying
    ///    media sink does not support the format, no conversion is possible, or a dynamic format change is not
    ///    possible. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_INVALIDSTREAMNUMBER</b></b></dt> </dl> </td>
    ///    <td width="60%"> The <i>dwStreamIndex</i> parameter is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>MF_E_TOPO_CODEC_NOT_FOUND</b></b></dt> </dl> </td> <td width="60%"> Could not find an encoder for
    ///    the encoded format. </td> </tr> </table>
    ///    
    HRESULT SetInputMediaType(uint dwStreamIndex, IMFMediaType pInputMediaType, IMFAttributes pEncodingParameters);
    ///Initializes the sink writer for writing.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> The request is
    ///    invalid. </td> </tr> </table>
    ///    
    HRESULT BeginWriting();
    ///Delivers a sample to the sink writer.
    ///Params:
    ///    dwStreamIndex = The zero-based index of the stream for this sample.
    ///    pSample = A pointer to the IMFSample interface of the sample.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> The request is
    ///    invalid. </td> </tr> </table>
    ///    
    HRESULT WriteSample(uint dwStreamIndex, IMFSample pSample);
    ///Indicates a gap in an input stream.
    ///Params:
    ///    dwStreamIndex = The zero-based index of the stream.
    ///    llTimestamp = The position in the stream where the gap in the data occurs. The value is given in 100-nanosecond units,
    ///                  relative to the start of the stream.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SendStreamTick(uint dwStreamIndex, long llTimestamp);
    ///Places a marker in the specified stream.
    ///Params:
    ///    dwStreamIndex = The zero-based index of the stream.
    ///    pvContext = Pointer to an application-defined value. The value of this parameter is returned to the caller in the
    ///                <i>pvContext</i> parameter of the caller's IMFSinkWriterCallback::OnMarker callback method. The application
    ///                is responsible for any memory allocation associated with this data. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> The request is
    ///    invalid. </td> </tr> </table>
    ///    
    HRESULT PlaceMarker(uint dwStreamIndex, void* pvContext);
    ///Notifies the media sink that a stream has reached the end of a segment.
    ///Params:
    ///    dwStreamIndex = The zero-based index of a stream, or <b>MF_SINK_WRITER_ALL_STREAMS</b> to signal that all streams have
    ///                    reached the end of a segment.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> The request is
    ///    invalid. </td> </tr> </table>
    ///    
    HRESULT NotifyEndOfSegment(uint dwStreamIndex);
    ///Flushes one or more streams.
    ///Params:
    ///    dwStreamIndex = The zero-based index of the stream to flush, or <b>MF_SINK_WRITER_ALL_STREAMS</b> to flush all of the
    ///                    streams.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> The request is
    ///    invalid. </td> </tr> </table>
    ///    
    HRESULT Flush(uint dwStreamIndex);
    ///Completes all writing operations on the sink writer.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Finalize();
    ///Queries the underlying media sink or encoder for an interface.
    ///Params:
    ///    dwStreamIndex = The zero-based index of a stream to query, or <b>MF_SINK_WRITER_MEDIASINK</b> to query the media sink itself.
    ///    guidService = A service identifier GUID, or <b>GUID_NULL</b>. If the value is <b>GUID_NULL</b>, the method calls
    ///                  <b>QueryInterface</b> to get the requested interface. Otherwise, the method calls IMFGetService::GetService.
    ///                  For a list of service identifiers, see Service Interfaces.
    ///    riid = The interface identifier (IID) of the interface being requested.
    ///    ppvObject = Receives a pointer to the requested interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetServiceForStream(uint dwStreamIndex, const(GUID)* guidService, const(GUID)* riid, void** ppvObject);
    ///Gets statistics about the performance of the sink writer.
    ///Params:
    ///    dwStreamIndex = The zero-based index of a stream to query, or <b>MF_SINK_WRITER_ALL_STREAMS </b> to query the media sink
    ///                    itself.
    ///    pStats = A pointer to an MF_SINK_WRITER_STATISTICS structure. Before calling the method, set the <b>cb</b> member to
    ///             the size of the structure in bytes. The method fills the structure with statistics from the sink writer.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> Invalid stream
    ///    number. </td> </tr> </table>
    ///    
    HRESULT GetStatistics(uint dwStreamIndex, MF_SINK_WRITER_STATISTICS* pStats);
}

///Extends the IMFSinkWriter interface. The Sink Writer implements this interface in Windows 8. To get a pointer to this
///interface, call QueryInterface on the Sink Writer.
@GUID("588D72AB-5BC1-496A-8714-B70617141B25")
interface IMFSinkWriterEx : IMFSinkWriter
{
    ///Gets a pointer to a Media Foundation transform (MFT) for a specified stream.
    ///Params:
    ///    dwStreamIndex = The zero-based index of a stream.
    ///    dwTransformIndex = The zero-based index of the MFT to retreive.
    ///    pGuidCategory = Receives a pointer to a GUID that specifies the category of the MFT. For a list of possible values, see
    ///                    MFT_CATEGORY.
    ///    ppTransform = Receives a pointer to the IMFTransform interface of the MFT. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetTransformForStream(uint dwStreamIndex, uint dwTransformIndex, GUID* pGuidCategory, 
                                  IMFTransform* ppTransform);
}

///Provides additional functionality on the sink writer for dynamically changing the media type and encoder
///configuration.
@GUID("17C3779E-3CDE-4EDE-8C60-3899F5F53AD6")
interface IMFSinkWriterEncoderConfig : IUnknown
{
    ///Dynamically changes the target media type that Sink Writer is encoding to.
    ///Params:
    ///    dwStreamIndex = Specifies the stream index.
    ///    pTargetMediaType = The new media format to encode to.
    ///    pEncodingParameters = The new set of encoding parameters to configure the encoder with. If not specified, previously provided
    ///                          parameters will be used.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetTargetMediaType(uint dwStreamIndex, IMFMediaType pTargetMediaType, 
                               IMFAttributes pEncodingParameters);
    ///Dynamically updates the encoder configuration with a collection of new encoder settings.
    ///Params:
    ///    dwStreamIndex = Specifies the stream index.
    ///    pEncodingParameters = A set of encoding parameters to configure the encoder with.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT PlaceEncodingParameters(uint dwStreamIndex, IMFAttributes pEncodingParameters);
}

///Callback interface for the Microsoft Media Foundation sink writer.
@GUID("666F76DE-33D2-41B9-A458-29ED0A972C58")
interface IMFSinkWriterCallback : IUnknown
{
    ///Called when the IMFSinkWriter::Finalize method completes.
    ///Params:
    ///    hrStatus = The status code for the Finalize operation. If the value is an error code, the output file might be invalid.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Currently, the sink writer ignores the return value.
    ///    
    HRESULT OnFinalize(HRESULT hrStatus);
    ///Called when the IMFSinkWriter::PlaceMarker method completes.
    ///Params:
    ///    dwStreamIndex = The zero-based index of the stream. This parameter equals the value of the <i>dwStreamIndex</i> parameter in
    ///                    the PlaceMarker method.
    ///    pvContext = The application-defined value that was given in the <i>pvContext</i> parameter in the PlaceMarker method.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Currently, the sink writer ignores the return value.
    ///    
    HRESULT OnMarker(uint dwStreamIndex, void* pvContext);
}

///Extends the IMFSinkWriterCallback interface.
@GUID("2456BD58-C067-4513-84FE-8D0C88FFDC61")
interface IMFSinkWriterCallback2 : IMFSinkWriterCallback
{
    ///Called when the transform chain in the IMFSourceReader is built or modified.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Currently, the sink writer ignores the return value.
    ///    
    HRESULT OnTransformChange();
    ///Called when an asynchronous error occurs with the IMFSinkWriter.
    ///Params:
    ///    dwStreamIndex = The index of the stream of the transform that raised the asynchronous error.
    ///    hrStatus = The error that occurred.
    ///Returns:
    ///    Returns an <b>HRESULT</b> value. Currently, the sink writer ignores the return value.
    ///    
    HRESULT OnStreamError(uint dwStreamIndex, HRESULT hrStatus);
}

///Maps a position on an input video stream to the corresponding position on an output video stream. To obtain a pointer
///to this interface, call IMFGetService::GetService on the renderer with the service GUID MR_VIDEO_RENDER_SERVICE.
@GUID("1F6A9F17-E70B-4E24-8AE4-0B2C3BA7A4AE")
interface IMFVideoPositionMapper : IUnknown
{
    ///Maps output image coordinates to input image coordinates. This method provides the reverse transformation for
    ///components that map coordinates on the input image to different coordinates on the output image.
    ///Params:
    ///    xOut = X-coordinate of the output image, normalized to the range [0...1].
    ///    yOut = Y-coordinate of the output image, normalized to the range [0...1].
    ///    dwOutputStreamIndex = Output stream index for the coordinate mapping.
    ///    dwInputStreamIndex = Input stream index for the coordinate mapping.
    ///    pxIn = Receives the mapped x-coordinate of the input image, normalized to the range [0...1].
    ///    pyIn = Receives the mapped y-coordinate of the input image, normalized to the range [0...1].
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video renderer has been shut down. </td>
    ///    </tr> </table>
    ///    
    HRESULT MapOutputCoordinateToInputStream(float xOut, float yOut, uint dwOutputStreamIndex, 
                                             uint dwInputStreamIndex, float* pxIn, float* pyIn);
}

///Returns the device identifier supported by a video renderer component. This interface is implemented by mixers and
///presenters for the enhanced video renderer (EVR). If you replace either of these components, the mixer and presenter
///must report the same device identifier.
@GUID("A38D9567-5A9C-4F3C-B293-8EB415B279BA")
interface IMFVideoDeviceID : IUnknown
{
    ///Returns the identifier of the video device supported by an EVR mixer or presenter.
    ///Params:
    ///    pDeviceID = Receives the device identifier. Generally, the value is IID_IDirect3DDevice9.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video renderer has been shut down. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetDeviceID(GUID* pDeviceID);
}

///Controls how the Enhanced Video Renderer (EVR) displays video. The EVR presenter implements this interface. To get a
///pointer to the interface, call IMFGetService::GetService. The service identifier is GUID MR_VIDEO_RENDER_SERVICE.
///Call <b>GetService</b> on any of the following objects: <ul> <li>The Media Session, if the topology contains an
///instance of the EVR. </li> <li>The EVR media sink. </li> <li>The DirectShow EVR filter. </li> <li>The EVR presenter.
///</li> </ul>If you implement a custom presenter for the EVR, the presenter can optionally expose this interface as a
///service.
@GUID("A490B1E4-AB84-4D31-A1B2-181E03B1077A")
interface IMFVideoDisplayControl : IUnknown
{
    ///Gets the size and aspect ratio of the video, prior to any stretching by the video renderer.
    ///Params:
    ///    pszVideo = Receives the size of the native video rectangle. This parameter can be <b>NULL</b>.
    ///    pszARVideo = Receives the aspect ratio of the video. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> At least one of the parameters must be
    ///    non-<b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td
    ///    width="60%"> The video renderer has been shut down. </td> </tr> </table>
    ///    
    HRESULT GetNativeVideoSize(SIZE* pszVideo, SIZE* pszARVideo);
    ///Gets the range of sizes that the enhanced video renderer (EVR) can display without significantly degrading
    ///performance or image quality.
    ///Params:
    ///    pszMin = Receives the minimum ideal size. This parameter can be <b>NULL</b>.
    ///    pszMax = Receives the maximum ideal size. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> At least one parameter must be non-<b>NULL</b>.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video
    ///    renderer has been shut down. </td> </tr> </table>
    ///    
    HRESULT GetIdealVideoSize(SIZE* pszMin, SIZE* pszMax);
    ///Sets the source and destination rectangles for the video.
    ///Params:
    ///    pnrcSource = Pointer to an MFVideoNormalizedRect structure that specifies the source rectangle. This parameter can be
    ///                 <b>NULL</b>. If this parameter is <b>NULL</b>, the source rectangle does not change.
    ///    prcDest = Specifies the destination rectangle. This parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the
    ///              destination rectangle does not change.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> At least one parameter must be non-<b>NULL</b>.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video
    ///    renderer has been shut down. </td> </tr> </table>
    ///    
    HRESULT SetVideoPosition(const(MFVideoNormalizedRect)* pnrcSource, const(RECT)* prcDest);
    ///Gets the source and destination rectangles for the video.
    ///Params:
    ///    pnrcSource = Pointer to an MFVideoNormalizedRect structure that receives the source rectangle.
    ///    prcDest = Receives the current destination rectangle.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> One or more required parameters are <b>NULL</b>.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video
    ///    renderer has been shut down. </td> </tr> </table>
    ///    
    HRESULT GetVideoPosition(MFVideoNormalizedRect* pnrcSource, RECT* prcDest);
    ///Specifies how the enhanced video renderer (EVR) handles the aspect ratio of the source video.
    ///Params:
    ///    dwAspectRatioMode = Bitwise <b>OR</b> of one or more flags from the MFVideoAspectRatioMode enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid flags. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video renderer has been shut
    ///    down. </td> </tr> </table>
    ///    
    HRESULT SetAspectRatioMode(uint dwAspectRatioMode);
    ///Queries how the enhanced video renderer (EVR) handles the aspect ratio of the source video.
    ///Params:
    ///    pdwAspectRatioMode = Receives a bitwise <b>OR</b> of one or more flags from the MFVideoAspectRatioMode enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video renderer has been shut down. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetAspectRatioMode(uint* pdwAspectRatioMode);
    ///Sets the clipping window for the video.
    ///Params:
    ///    hwndVideo = Handle to the window where the enhanced video renderer (EVR) will draw the video.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>hwndVideo</i> does not specify a valid
    ///    window. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> DWM
    ///    thumbnails were not enabled/disabled. </td> </tr> </table>
    ///    
    HRESULT SetVideoWindow(HWND hwndVideo);
    ///Gets the clipping window for the video.
    ///Params:
    ///    phwndVideo = Receives a handle to the window where the enhanced video renderer (EVR) will draw the video.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video renderer has been shut down. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetVideoWindow(HWND* phwndVideo);
    ///Repaints the current video frame. Call this method whenever the application receives a WM_PAINT message.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The EVR cannot repaint the frame at
    ///    this time. This error can occur while the EVR is switching between full-screen and windowed mode. The caller
    ///    can safely ignore this error. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl>
    ///    </td> <td width="60%"> The video renderer has been shut down. </td> </tr> </table>
    ///    
    HRESULT RepaintVideo();
    ///Gets a copy of the current image being displayed by the video renderer.
    ///Params:
    ///    pBih = Pointer to a <b>BITMAPINFOHEADER</b> structure that receives a description of the bitmap. Set the
    ///           <b>biSize</b> member of the structure to <code>sizeof(BITMAPINFOHEADER)</code> before calling the method.
    ///    pDib = Receives a pointer to a buffer that contains a packed Windows device-independent bitmap (DIB). The caller
    ///           must free the memory for the bitmap by calling CoTaskMemFree.
    ///    pcbDib = Receives the size of the buffer returned in <i>pDib</i>, in bytes.
    ///    pTimeStamp = Receives the time stamp of the captured image.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_LICENSE_INCORRECT_RIGHTS</b></dt> </dl> </td> <td width="60%"> The content is protected and
    ///    the license does not permit capturing the image. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video renderer has been shut down. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetCurrentImage(BITMAPINFOHEADER* pBih, ubyte** pDib, uint* pcbDib, long* pTimeStamp);
    ///Sets the border color for the video.
    ///Params:
    ///    Clr = Specifies the border color as a <b>COLORREF</b> value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video renderer has been shut down. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetBorderColor(uint Clr);
    ///Gets the border color for the video.
    ///Params:
    ///    pClr = Receives the border color, as a <b>COLORREF</b> value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video renderer has been shut down. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetBorderColor(uint* pClr);
    ///Sets various preferences related to video rendering.
    ///Params:
    ///    dwRenderFlags = Bitwise <b>OR</b> of zero or more flags from the MFVideoRenderPrefs enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid flags. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video renderer has been shut
    ///    down. </td> </tr> </table>
    ///    
    HRESULT SetRenderingPrefs(uint dwRenderFlags);
    ///Gets various video rendering settings.
    ///Params:
    ///    pdwRenderFlags = Receives a bitwise <b>OR</b> of zero or more flags from the MFVideoRenderPrefs enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video renderer has been shut down. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetRenderingPrefs(uint* pdwRenderFlags);
    ///<p class="CCE_Message">[This API is not supported and may be altered or unavailable in the future. ] Sets or
    ///unsets full-screen rendering mode. To implement full-screen playback, an application should simply resize the
    ///video window to cover the entire area of the monitor. Also set the window to be a topmost window, so that the
    ///application receives all mouse-click messages. For more information about topmost windows, see the documentation
    ///for the SetWindowPos function.
    ///Params:
    ///    fFullscreen = If <b>TRUE</b>, the enhanced video renderer (EVR) uses full-screen mode. If <b>FALSE</b>, the EVR draws the
    ///                  video in the application-provided clipping window.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video renderer has been shut down. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetFullscreen(BOOL fFullscreen);
    ///Queries whether the enhanced video renderer (EVR) is currently in full-screen mode.
    ///Params:
    ///    pfFullscreen = Receives a Boolean value. If <b>TRUE</b>, the EVR is in full-screen mode. If <b>FALSE</b>, the EVR will
    ///                   display the video inside the application-provided clipping window.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The EVR is currently switching between
    ///    full-screen and windowed mode. </td> </tr> </table>
    ///    
    HRESULT GetFullscreen(BOOL* pfFullscreen);
}

///Represents a video presenter. A <i>video presenter</i> is an object that receives video frames, typically from a
///video mixer, and presents them in some way, typically by rendering them to the display. The enhanced video renderer
///(EVR) provides a default video presenter, and applications can implement custom presenters. The video presenter
///receives video frames as soon as they are available from upstream. The video presenter is responsible for presenting
///frames at the correct time and for synchronizing with the presentation clock.
@GUID("29AFF080-182A-4A5D-AF3B-448F3A6346CB")
interface IMFVideoPresenter : IMFClockStateSink
{
    ///Sends a message to the video presenter. Messages are used to signal the presenter that it must perform some
    ///action, or that some event has occurred.
    ///Params:
    ///    eMessage = Specifies the message as a member of the MFVP_MESSAGE_TYPE enumeration.
    ///    ulParam = Message parameter. The meaning of this parameter depends on the message type.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video renderer has been shut down. </td> </tr>
    ///    </table>
    ///    
    HRESULT ProcessMessage(MFVP_MESSAGE_TYPE eMessage, size_t ulParam);
    ///Retrieves the presenter's media type.
    ///Params:
    ///    ppMediaType = Receives a pointer to the IMFVideoMediaType interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> The media type is not set. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video renderer has
    ///    been shut down </td> </tr> </table>
    ///    
    HRESULT GetCurrentMediaType(IMFVideoMediaType* ppMediaType);
}

///Enables the presenter for the enhanced video renderer (EVR) to request a specific frame from the video mixer. The
///sample objects created by the MFCreateVideoSampleFromSurface function implement this interface. To retrieve a pointer
///to this interface, call <b>QueryInterface</b> on the sample.
@GUID("56C294D0-753E-4260-8D61-A3D8820B1D54")
interface IMFDesiredSample : IUnknown
{
    ///Called by the mixer to get the time and duration of the sample requested by the presenter.
    ///Params:
    ///    phnsSampleTime = Receives the desired sample time that should be mixed.
    ///    phnsSampleDuration = Receives the sample duration that should be mixed.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_AVAILABLE</b></dt> </dl> </td> <td width="60%"> No time stamp was set for this sample.
    ///    See IMFDesiredSample::Clear. </td> </tr> </table>
    ///    
    HRESULT GetDesiredSampleTimeAndDuration(long* phnsSampleTime, long* phnsSampleDuration);
    ///Called by the presenter to set the time and duration of the sample that it requests from the mixer.
    ///Params:
    ///    hnsSampleTime = The time of the requested sample.
    ///    hnsSampleDuration = The duration of the requested sample.
    void    SetDesiredSampleTimeAndDuration(long hnsSampleTime, long hnsSampleDuration);
    ///Clears the time stamps previously set by a call to IMFDesiredSample::SetDesiredSampleTimeAndDuration.
    void    Clear();
}

///Controls how the Enhanced Video Renderer (EVR) mixes video substreams. Applications can use this interface to control
///video mixing during playback. The EVR mixer implements this interface. To get a pointer to the interface, call
///IMFGetService::GetService. The service identifier GUID is MR_VIDEO_MIXER_SERVICE. Call <b>GetService</b> on any of
///the following objects: <ul> <li>The Media Session, if the topology contains an instance of the EVR. </li> <li>The EVR
///media sink. </li> <li>The DirectShow EVR filter. </li> <li>The EVR mixer. </li> </ul>If you implement a custom mixer
///for the EVR, the mixer can optionally expose this interface as a service.
@GUID("A5C6C53F-C202-4AA5-9695-175BA8C508A5")
interface IMFVideoMixerControl : IUnknown
{
    ///Sets the z-order of a video stream.
    ///Params:
    ///    dwStreamID = Identifier of the stream. For the EVR media sink, the stream identifier is defined when the
    ///                 IMFMediaSink::AddStreamSink method is called. For the DirectShow EVR filter, the stream identifier
    ///                 corresponds to the pin index. The reference stream is always stream 0.
    ///    dwZ = Z-order value. The z-order of the reference stream must be zero. The maximum z-order value is the number of
    ///          streams minus one.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The value of <i>dwZ</i> is larger than the
    ///    maximum z-order value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid z-order for this stream. For the reference stream, <i>dwZ</i> must be zero. For all
    ///    other streams, <i>dwZ</i> must be greater than zero. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> Invalid stream identifier. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetStreamZOrder(uint dwStreamID, uint dwZ);
    ///Retrieves the z-order of a video stream.
    ///Params:
    ///    dwStreamID = Identifier of the stream. For the EVR media sink, the stream identifier is defined when the
    ///                 IMFMediaSink::AddStreamSink method is called. For the DirectShow EVR filter, the stream identifier
    ///                 corresponds to the pin index. The reference stream is always stream 0.
    ///    pdwZ = Receives the z-order value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> Invalid stream identifier. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetStreamZOrder(uint dwStreamID, uint* pdwZ);
    ///Sets the position of a video stream within the composition rectangle.
    ///Params:
    ///    dwStreamID = Identifier of the stream. For the EVR media sink, the stream identifier is defined when the
    ///                 IMFMediaSink::AddStreamSink method is called. For the DirectShow EVR filter, the stream identifier
    ///                 corresponds to the pin index. The reference stream is always stream 0.
    ///    pnrcOutput = Pointer to an MFVideoNormalizedRect structure that defines the bounding rectangle for the video stream.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The coordinates of the bounding rectangle
    ///    given in <i>pnrcOutput</i> are not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> Invalid stream identifier. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetStreamOutputRect(uint dwStreamID, const(MFVideoNormalizedRect)* pnrcOutput);
    ///Retrieves the position of a video stream within the composition rectangle.
    ///Params:
    ///    dwStreamID = The identifier of the stream. For the EVR media sink, the stream identifier is defined when the
    ///                 IMFMediaSink::AddStreamSink method is called. For the DirectShow EVR filter, the stream identifier
    ///                 corresponds to the pin index. The reference stream is always stream 0.
    ///    pnrcOutput = Pointer to an MFVideoNormalizedRect structure that receives the bounding rectangle, in normalized
    ///                 coordinates.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDSTREAMNUMBER</b></dt> </dl> </td> <td width="60%"> Invalid stream identifier. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetStreamOutputRect(uint dwStreamID, MFVideoNormalizedRect* pnrcOutput);
}

///Controls preferences for video deinterlacing. The default video mixer for the Enhanced Video Renderer (EVR)
///implements this interface. To get a pointer to the interface, call IMFGetService::GetService on any of the following
///objects, using the <b>MR_VIDEO_MIXER_SERVICE</b> service identifier: <ul> <li>The Media Session, if the topology
///contains an instance of the EVR.</li> <li>The EVR media sink.</li> <li>The DirectShow EVR filter.</li> <li>The EVR
///mixer.</li> </ul>
@GUID("8459616D-966E-4930-B658-54FA7E5A16D3")
interface IMFVideoMixerControl2 : IMFVideoMixerControl
{
    ///Sets the preferences for video deinterlacing.
    ///Params:
    ///    dwMixFlags = Bitwise <b>OR</b> of zero or more flags from the MFVideoMixPrefs enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetMixingPrefs(uint dwMixFlags);
    ///Gets the current preferences for video deinterlacing.
    ///Params:
    ///    pdwMixFlags = Receives a bitwise <b>OR</b> of zero or more flags from the MFVideoMixPrefs enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMixingPrefs(uint* pdwMixFlags);
}

///Sets a new mixer or presenter for the Enhanced Video Renderer (EVR). Both the EVR media sink and the DirectShow EVR
///filter implement this interface. To get a pointer to the interface, call <b>QueryInterface</b> on the media sink or
///the filter. Do not use IMFGetService to get a pointer to this interface.
@GUID("DFDFD197-A9CA-43D8-B341-6AF3503792CD")
interface IMFVideoRenderer : IUnknown
{
    ///Sets a new mixer or presenter for the enhanced video renderer (EVR).
    ///Params:
    ///    pVideoMixer = Pointer to the IMFTransform interface of the mixer to use. This parameter can be <b>NULL</b>. If this
    ///                  parameter is <b>NULL</b>, the EVR uses its default mixer.
    ///    pVideoPresenter = Pointer to the IMFVideoPresenter interface of the presenter to use. This parameter can be <b>NULL</b>. If
    ///                      this parameter is <b>NULL</b>, the EVR uses its default presenter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Either the mixer or the presenter is invalid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The
    ///    mixer and presenter cannot be replaced in the current state. (EVR media sink.) </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The video renderer has been shut
    ///    down. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td> <td width="60%">
    ///    One or more input pins are connected. (DirectShow EVR filter.) </td> </tr> </table>
    ///    
    HRESULT InitializeRenderer(IMFTransform pVideoMixer, IMFVideoPresenter pVideoPresenter);
}

///Sets the number of input pins on the DirectShow Enhanced Video Renderer (EVR) filter. To get a pointer to this
///interface, call <b>QueryInterface</b> on the DirectShow EVR filter.
@GUID("83E91E85-82C1-4EA7-801D-85DC50B75086")
interface IEVRFilterConfig : IUnknown
{
    ///Sets the number of input pins on the EVR filter.
    ///Params:
    ///    dwMaxStreams = Specifies the total number of input pins on the EVR filter. This value includes the input pin for the
    ///                   reference stream, which is created by default. For example, to mix one substream plus the reference stream,
    ///                   set this parameter to 2.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid number of streams. The minimum is one,
    ///    and the maximum is 16. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_WRONG_STATE</b></dt> </dl> </td>
    ///    <td width="60%"> This method has already been called, or at least one pin is already connected. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetNumberOfStreams(uint dwMaxStreams);
    ///Retrieves the number of input pins on the EVR filter. The EVR filter always has at least one input pin, which
    ///corresponds to the reference stream.
    ///Params:
    ///    pdwMaxStreams = Receives the number of streams.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetNumberOfStreams(uint* pdwMaxStreams);
}

///Configures the DirectShow Enhanced Video Renderer (EVR) filter. To get a pointer to this interface, call
///<b>QueryInterface</b> on the EVR filter.
@GUID("AEA36028-796D-454F-BEEE-B48071E24304")
interface IEVRFilterConfigEx : IEVRFilterConfig
{
    ///Sets the configuration parameters for the Microsoft DirectShow Enhanced Video Renderer Filter (EVR).
    ///Params:
    ///    dwConfigFlags = Bitwise <b>OR</b> of zero or more flags from the EVRFilterConfigPrefs enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> </table>
    ///    
    HRESULT SetConfigPrefs(uint dwConfigFlags);
    ///Gets the configuration parameters for the Microsoft DirectShow Enhanced Video Renderer Filter filter.
    ///Params:
    ///    pdwConfigFlags = Receives a bitwise <b>OR</b> of flags from the EVRFilterConfigPrefs enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetConfigPrefs(uint* pdwConfigFlags);
}

///Enables a custom video mixer or video presenter to get interface pointers from the Enhanced Video Renderer (EVR). The
///mixer can also use this interface to get interface pointers from the presenter, and the presenter can use it to get
///interface pointers from the mixer. To use this interface, implement the IMFTopologyServiceLookupClient interface on
///your custom mixer or presenter. The EVR calls IMFTopologyServiceLookupClient::InitServicePointers with a pointer to
///the EVR's <b>IMFTopologyServiceLookup</b> interface.
@GUID("FA993889-4383-415A-A930-DD472A8CF6F7")
interface IMFTopologyServiceLookup : IUnknown
{
    ///Retrieves an interface from the enhanced video renderer (EVR), or from the video mixer or video presenter.
    ///Params:
    ///    Type = Specifies the scope of the search. Currently this parameter is ignored. Use the value
    ///           MF_SERVICE_LOOKUP_GLOBAL.
    ///    dwIndex = Reserved, must be zero.
    ///    guidService = Service GUID of the requested interface.
    ///    riid = Interface identifier of the requested interface.
    ///    ppvObjects = Array of interface pointers. If the method succeeds, each member of the array contains either a valid
    ///                 interface pointer or <b>NULL</b>. The caller must release the interface pointers when the EVR calls
    ///                 IMFTopologyServiceLookupClient::ReleaseServicePointers (or earlier). If the method fails, every member of the
    ///                 array is <b>NULL</b>.
    ///    pnObjects = Pointer to a value that specifies the size of the <i>ppvObjects</i> array. The value must be at least 1. In
    ///                the current implementation, there is no reason to specify an array size larger than one element. The value is
    ///                not changed on output.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The requested interface is not available.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOTACCEPTING</b></dt> </dl> </td> <td width="60%"> The
    ///    method was not called from inside the IMFTopologyServiceLookupClient::InitServicePointers method. See
    ///    Remarks. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_UNSUPPORTED_SERVICE</b></dt> </dl> </td> <td
    ///    width="60%"> The object does not support the specified service GUID. </td> </tr> </table>
    ///    
    HRESULT LookupService(MF_SERVICE_LOOKUP_TYPE Type, uint dwIndex, const(GUID)* guidService, const(GUID)* riid, 
                          void** ppvObjects, uint* pnObjects);
}

///Initializes a video mixer or presenter. This interface is implemented by mixers and presenters, and enables them to
///query the enhanced video renderer (EVR) for interface pointers.
@GUID("FA99388A-4383-415A-A930-DD472A8CF6F7")
interface IMFTopologyServiceLookupClient : IUnknown
{
    ///Signals the mixer or presenter to query the enhanced video renderer (EVR) for interface pointers.
    ///Params:
    ///    pLookup = Pointer to the IMFTopologyServiceLookup interface. To query the EVR for an interface, call
    ///              IMFTopologyServiceLookup::LookupService.
    ///Returns:
    ///    The method returns an HRESULT. Possible values include, but are not limited to, those in the following table.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT InitServicePointers(IMFTopologyServiceLookup pLookup);
    ///Signals the object to release the interface pointers obtained from the enhanced video renderer (EVR).
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT ReleaseServicePointers();
}

///Enables a plug-in component for the enhanced video renderer (EVR) to work with protected media. To work in the
///protected media path (PMP), a custom EVR mixer or presenter must implement this interface. The EVR obtains a pointer
///to this interface by calling <b>QueryInterface</b> on the plug-in component. This interface is required only if the
///plug-in is a trusted component, designed to work in the PMP. It is not required for playing clear content in an
///unprotected process.
@GUID("83A4CE40-7710-494B-A893-A472049AF630")
interface IEVRTrustedVideoPlugin : IUnknown
{
    ///Queries whether the plug-in has any transient vulnerabilities at this time.
    ///Params:
    ///    pYes = Receives a Boolean value. If <b>TRUE</b>, the plug-in has no transient vulnerabilities at the moment and can
    ///           receive protected content. If <b>FALSE</b>, the plug-in has a transient vulnerability. If the method fails,
    ///           the EVR treats the value as <b>FALSE</b> (untrusted).
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT IsInTrustedVideoMode(BOOL* pYes);
    ///Queries whether the plug-in can limit the effective video resolution.
    ///Params:
    ///    pYes = Receives a Boolean value. If <b>TRUE</b>, the plug-in can limit the effective video resolution. Otherwise,
    ///           the plug-in cannot limit the video resolution. If the method fails, the EVR treats the value as <b>FALSE</b>
    ///           (not supported).
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT CanConstrict(BOOL* pYes);
    ///Limits the effective video resolution.
    ///Params:
    ///    dwKPix = Maximum number of source pixels that may appear in the final video image, in thousands of pixels. If the
    ///             value is zero, the video is disabled. If the value is MAXDWORD (0xFFFFFFFF), video constriction is removed
    ///             and the video may be rendered at full resolution.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetConstriction(uint dwKPix);
    ///Enables or disables the ability of the plug-in to export the video image.
    ///Params:
    ///    bDisable = Boolean value. Specify <b>TRUE</b> to disable image exporting, or <b>FALSE</b> to enable it.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT DisableImageExport(BOOL bDisable);
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Contains methods to play media files. The MFPlay player
///object exposes this interface. To get a pointer to this interface, call MFPCreateMediaPlayer.
@GUID("A714590A-58AF-430A-85BF-44F5EC838D85")
interface IMFPMediaPlayer : IUnknown
{
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Starts playback.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt> </dl> </td> <td width="60%"> The object's Shutdown
    ///    method was called. </td> </tr> </table>
    ///    
    HRESULT Play();
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Pauses playback. While playback is
    ///paused, the most recent video frame is displayed, and audio is silent.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt> </dl> </td> <td width="60%"> The object's Shutdown
    ///    method was called. </td> </tr> </table>
    ///    
    HRESULT Pause();
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Stops playback.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The object's Shutdown method was called.
    ///    </td> </tr> </table>
    ///    
    HRESULT Stop();
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Steps forward one video frame.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> Cannot frame step. Reasons for this
    ///    error code include: <ul> <li>There is no media item queued for playback.</li> <li>The current media item does
    ///    not contain video.</li> </ul> </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl>
    ///    </td> <td width="60%"> The object's Shutdown method was called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_UNSUPPORTED_RATE</b></dt> </dl> </td> <td width="60%"> The media source does not support frame
    ///    stepping, or the current playback rate is negative. </td> </tr> </table>
    ///    
    HRESULT FrameStep();
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Sets the playback position.
    ///Params:
    ///    guidPositionType = Unit of time for the playback position. The following value is defined. <table> <tr> <th>Value</th>
    ///                       <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MFP_POSITIONTYPE_100NS"></a><a
    ///                       id="mfp_positiontype_100ns"></a><dl> <dt><b>MFP_POSITIONTYPE_100NS</b></dt> </dl> </td> <td width="60%">
    ///                       100-nanosecond units. The value of <i>pvPositionValue</i> must be a <b>LARGE_INTEGER</b>. <ul> <li>Variant
    ///                       type (<b>vt</b>): <b>VT_I8</b></li> <li>Variant member: <b>hVal</b></li> </ul> </td> </tr> </table>
    ///    pvPositionValue = New playback position. The meaning and data type of this parameter are indicated by the
    ///                      <i>guidPositionType</i> parameter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>HRESULT_FROM_WIN32( ERROR_SEEK )</b></b></dt> </dl> </td> <td
    ///    width="60%"> The value of <i>pvPositionValue</i> is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> No media item has been queued. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt> </dl> </td> <td width="60%"> The
    ///    object's Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT SetPosition(const(GUID)* guidPositionType, const(PROPVARIANT)* pvPositionValue);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the current playback position.
    ///Params:
    ///    guidPositionType = Specifies the unit of time for the playback position. The following value is defined. <table> <tr>
    ///                       <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MFP_POSITIONTYPE_100NS"></a><a
    ///                       id="mfp_positiontype_100ns"></a><dl> <dt><b><b>MFP_POSITIONTYPE_100NS</b></b></dt> </dl> </td> <td
    ///                       width="60%"> 100-nanosecond units. The value returned in <i>pvPositionValue</i> is a <b>LARGE_INTEGER</b>.
    ///                       <ul> <li>Variant type (<b>vt</b>): <b>VT_I8</b></li> <li>Variant member: <b>hVal</b></li> </ul> </td> </tr>
    ///                       </table>
    ///    pvPositionValue = Pointer to a <b>PROPVARIANT</b> that receives the playback position.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> No
    ///    media item has been queued. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt> </dl>
    ///    </td> <td width="60%"> The object's Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT GetPosition(const(GUID)* guidPositionType, PROPVARIANT* pvPositionValue);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the playback duration of the
    ///current media item.
    ///Params:
    ///    guidPositionType = Specifies the unit of time for the duration. The following value is defined. <table> <tr> <th>Value</th>
    ///                       <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MFP_POSITIONTYPE_100NS"></a><a
    ///                       id="mfp_positiontype_100ns"></a><dl> <dt><b><b>MFP_POSITIONTYPE_100NS</b></b></dt> </dl> </td> <td
    ///                       width="60%"> 100-nanosecond units. The value returned in <i>pvDurationValue</i> is a <b>ULARGE_INTEGER</b>.
    ///                       <ul> <li>Variant type (<b>vt</b>): <b>VT_UI8</b></li> <li>Variant member: <b>uhVal</b></li> </ul> </td> </tr>
    ///                       </table>
    ///    pvDurationValue = Pointer to a <b>PROPVARIANT</b> that receives the duration.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>MF_E_ATTRIBUTENOTFOUND</b></dt> </dl> </td> <td width="60%"> The media
    ///    source does not have a duration. This error can occur with a live source, such as a video camera. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> There is no
    ///    current media item. </td> </tr> </table>
    ///    
    HRESULT GetDuration(const(GUID)* guidPositionType, PROPVARIANT* pvDurationValue);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Sets the playback rate.
    ///Params:
    ///    flRate = Playback rate. The playback rate is expressed as a ratio of the current rate to the normal rate. For example,
    ///             <b>1.0</b> indicates normal playback speed, <b>0.5</b> indicates half speed, and <b>2.0</b> indicates twice
    ///             speed. Positive values indicate forward playback, and negative values indicate reverse playback.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_OUT_OF_RANGE</b></b></dt> </dl> </td> <td width="60%"> The <i>flRate</i>
    ///    parameter is zero. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt> </dl> </td>
    ///    <td width="60%"> The object's Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT SetRate(float flRate);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the current playback rate.
    ///Params:
    ///    pflRate = Receives the playback rate. The playback rate is expressed as a ratio of the current rate to the normal rate.
    ///              For example, 1.0 indicates normal playback, 0.5 indicates half speed, and 2.0 indicates twice speed. Positive
    ///              values indicate forward playback, and negative values indicate reverse playback.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetRate(float* pflRate);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the range of supported playback
    ///rates.
    ///Params:
    ///    fForwardDirection = Specify <b>TRUE</b> to get the playback rates for forward playback. Specify <b>FALSE</b> to get the rates for
    ///                        reverse playback.
    ///    pflSlowestRate = Receives the slowest supported rate.
    ///    pflFastestRate = Receives the fastest supported rate.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_UNSUPPORTED_RATE</b></b></dt> </dl> </td> <td width="60%">
    ///    The current media item does not support playback in the requested direction (either forward or reverse).
    ///    </td> </tr> </table>
    ///    
    HRESULT GetSupportedRates(BOOL fForwardDirection, float* pflSlowestRate, float* pflFastestRate);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the current playback state of the
    ///MFPlay player object.
    ///Params:
    ///    peState = Receives the playback state, as a member of the MFP_MEDIAPLAYER_STATE enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetState(MFP_MEDIAPLAYER_STATE* peState);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Creates a media item from a URL.
    ///Params:
    ///    pwszURL = Null-terminated string that contains the URL of a media file.
    ///    fSync = If <b>TRUE</b>, the method blocks until it completes. If <b>FALSE</b>, the method does not block and
    ///            completes asynchronously.
    ///    dwUserData = Application-defined value to store in the media item. To retrieve this value from the media item, call
    ///                 IMFPMediaItem::GetUserData.
    ///    ppMediaItem = Receives a pointer to the IMFPMediaItem interface. The caller must release the interface. If <i>fSync</i> is
    ///                  <b>TRUE</b>, this parameter must be a valid pointer. If <i>bSync</i> is <b>FALSE</b>, this parameter must be
    ///                  <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%">
    ///    Invalid request. This error can occur when <i>fSync</i> is <b>FALSE</b> and the application did not provide a
    ///    callback interface. See Remarks. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt>
    ///    </dl> </td> <td width="60%"> The object's Shutdown method was called. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>MF_E_UNSUPPORTED_SCHEME</b></b></dt> </dl> </td> <td width="60%"> Unsupported protocol. </td> </tr>
    ///    </table>
    ///    
    HRESULT CreateMediaItemFromURL(const(PWSTR) pwszURL, BOOL fSync, size_t dwUserData, IMFPMediaItem* ppMediaItem);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Creates a media item from an object.
    ///Params:
    ///    pIUnknownObj = A pointer to the object's <b>IUnknown</b> interface. See Remarks.
    ///    fSync = If <b>TRUE</b>, the method blocks until it completes. If <b>FALSE</b>, the method does not block and
    ///            completes asynchronously.
    ///    dwUserData = Application-defined value to store in the media item. To retrieve this value from the media item, call
    ///                 IMFPMediaItem::GetUserData.
    ///    ppMediaItem = Receives a pointer to the IMFPMediaItem interface. The caller must release the interface. If <i>fSync</i> is
    ///                  <b>TRUE</b>, this parameter must be a valid pointer. If <i>bSync</i> is <b>FALSE</b>, this parameter must be
    ///                  <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%">
    ///    Invalid request. This error can occur when <i>fSync</i> is <b>FALSE</b> and the application did not provide a
    ///    callback interface. See Remarks. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt>
    ///    </dl> </td> <td width="60%"> The object's Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT CreateMediaItemFromObject(IUnknown pIUnknownObj, BOOL fSync, size_t dwUserData, 
                                      IMFPMediaItem* ppMediaItem);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Queues a media item for playback.
    ///Params:
    ///    pIMFPMediaItem = Pointer to the IMFPMediaItem interface of the media item.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_DRM_UNSUPPORTED</b></b></dt> </dl> </td> <td width="60%"> The
    ///    media item contains protected content. MFPlay currently does not support protected content. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>MF_E_NO_AUDIO_PLAYBACK_DEVICE</b></b></dt> </dl> </td> <td width="60%"> No
    ///    audio playback device was found. This error can occur if the media source contains audio, but no audio
    ///    playback devices are available on the system. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>MF_E_SHUTDOWN</b></b></dt> </dl> </td> <td width="60%"> The object's Shutdown method was called.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetMediaItem(IMFPMediaItem pIMFPMediaItem);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Clears the current media item. <div
    ///class="alert"><b>Note</b> This method is currently not implemented.</div><div> </div>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ClearMediaItem();
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets a pointer to the current media
    ///item.
    ///Params:
    ///    ppIMFPMediaItem = Receives a pointer to the media item's IMFPMediaItem interface. The caller must release the interface.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>E_FAIL</b></b></dt> </dl> </td> <td width="60%"> There is no current media item.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_NOT_FOUND</b></b></dt> </dl> </td> <td width="60%">
    ///    There is no current media item. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt>
    ///    </dl> </td> <td width="60%"> The object's Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT GetMediaItem(IMFPMediaItem* ppIMFPMediaItem);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the current audio volume.
    ///Params:
    ///    pflVolume = Receives the audio volume. Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0
    ///                indicates full volume (no attenuation).
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVolume(float* pflVolume);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Sets the audio volume.
    ///Params:
    ///    flVolume = The volume level. Volume is expressed as an attenuation level, where 0.0 indicates silence and 1.0 indicates
    ///               full volume (no attenuation).
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_OUT_OF_RANGE</b></dt> </dl> </td> <td width="60%"> The <i>flVolume</i> parameter is invalid.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetVolume(float flVolume);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the current audio balance.
    ///Params:
    ///    pflBalance = Receives the balance. The value can be any number in the following range (inclusive). <table> <tr>
    ///                 <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>-1.0</dt> </dl> </td> <td width="60%">
    ///                 The left channel is at full volume; the right channel is silent. </td> </tr> <tr> <td width="40%"> <dl>
    ///                 <dt>+1.0</dt> </dl> </td> <td width="60%"> The right channel is at full volume; the left channel is silent.
    ///                 </td> </tr> </table> If the value is zero, the left and right channels are at equal volumes. The default
    ///                 value is zero.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetBalance(float* pflBalance);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Sets the audio balance.
    ///Params:
    ///    flBalance = The audio balance. The value can be any number in the following range (inclusive). <table> <tr>
    ///                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>-1.0</b></dt> </dl> </td> <td
    ///                width="60%"> The left channel is at full volume; the right channel is silent. </td> </tr> <tr> <td
    ///                width="40%"> <dl> <dt><b>+1.0</b></dt> </dl> </td> <td width="60%"> The right channel is at full volume; the
    ///                left channel is silent. </td> </tr> </table> If the value is zero, the left and right channels are at equal
    ///                volumes. The default value is zero.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_OUT_OF_RANGE</b></b></dt> </dl> </td> <td width="60%"> The <i>flBalance</i>
    ///    parameter is invalid. </td> </tr> </table>
    ///    
    HRESULT SetBalance(float flBalance);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Queries whether the audio is muted.
    ///Params:
    ///    pfMute = Receives the value <b>TRUE</b> if the audio is muted, or <b>FALSE</b> otherwise.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMute(BOOL* pfMute);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Mutes or unmutes the audio.
    ///Params:
    ///    fMute = Specify <b>TRUE</b> to mute the audio, or <b>FALSE</b> to unmute the audio.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetMute(BOOL fMute);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the size and aspect ratio of the
    ///video. These values are computed before any scaling is done to fit the video into the destination window.
    ///Params:
    ///    pszVideo = Receives the size of the video, in pixels. This parameter can be <b>NULL</b>.
    ///    pszARVideo = Receives the picture aspect ratio of the video. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> The current media
    ///    item does not contain video. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt>
    ///    </dl> </td> <td width="60%"> The object's Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT GetNativeVideoSize(SIZE* pszVideo, SIZE* pszARVideo);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the range of video sizes that can
    ///be displayed without significantly degrading performance or image quality.
    ///Params:
    ///    pszMin = Receives the minimum size that is preferable. This parameter can be <b>NULL</b>.
    ///    pszMax = Receives the maximum size that is preferable. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> The current media
    ///    item does not contain video. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt>
    ///    </dl> </td> <td width="60%"> The object's Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT GetIdealVideoSize(SIZE* pszMin, SIZE* pszMax);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Sets the video source rectangle.
    ///MFPlay clips the video to this rectangle and stretches the rectangle to fill the video window.
    ///Params:
    ///    pnrcSource = Pointer to an MFVideoNormalizedRect structure that specifies the source rectangle. This rectangle defines
    ///                 which portion of the video is displayed. It is specified in normalized coordinates, which are defined as
    ///                 follows: <ul> <li>The upper-left corner of the video image is (0, 0).</li> <li>The lower-right corner of the
    ///                 video image is (1, 1).</li> </ul> To display the entire image, set the source rectangle to {0, 0, 1, 1}. This
    ///                 is the default value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The current media item does not contain
    ///    video. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The
    ///    object's Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT SetVideoSourceRect(const(MFVideoNormalizedRect)* pnrcSource);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the video source rectangle.
    ///Params:
    ///    pnrcSource = Pointer to an MFVideoNormalizedRect structure that specifies the source rectangle. This rectangle defines
    ///                 which portion of the video is displayed. It is specified in normalized coordinates, which are defined as
    ///                 follows: <ul> <li>The upper-left corner of the video image is (0, 0).</li> <li>The lower-right corner of the
    ///                 video image is (1, 1).</li> </ul> If the source rectangle is {0, 0, 1, 1}, the entire image is displayed.
    ///                 This is the default value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> The current media
    ///    item does not contain video. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt>
    ///    </dl> </td> <td width="60%"> The object's Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT GetVideoSourceRect(MFVideoNormalizedRect* pnrcSource);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Specifies whether the aspect ratio of
    ///the video is preserved during playback.
    ///Params:
    ///    dwAspectRatioMode = Bitwise <b>OR</b> of one or more flags from the MFVideoAspectRatioMode enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> The current media
    ///    item does not contain video. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt>
    ///    </dl> </td> <td width="60%"> The object's Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT SetAspectRatioMode(uint dwAspectRatioMode);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the current aspect-ratio
    ///correction mode. This mode controls whether the aspect ratio of the video is preserved during playback.
    ///Params:
    ///    pdwAspectRatioMode = Receives a bitwise <b>OR</b> of one or more flags from the MFVideoAspectRatioMode enumeration.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The current media item does not contain
    ///    video. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The
    ///    object's Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT GetAspectRatioMode(uint* pdwAspectRatioMode);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the window where the video is
    ///displayed.
    ///Params:
    ///    phwndVideo = Receives a handle to the application window where the video is displayed.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoWindow(HWND* phwndVideo);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Updates the video frame.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> The current media
    ///    item does not contain video. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>MF_E_SHUTDOWN</b></b></dt>
    ///    </dl> </td> <td width="60%"> The object's Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT UpdateVideo();
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Sets the color for the video border.
    ///The border color is used to letterbox the video.
    ///Params:
    ///    Clr = Specifies the border color as a <b>COLORREF</b> value. Use the <b>RGB</b> macro to create this value. The
    ///          default value is black.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDREQUEST</b></b></dt> </dl> </td> <td width="60%"> The current media
    ///    item does not contain video. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>M<b>F_E_SHUTDOWN</b></b></dt>
    ///    </dl> </td> <td width="60%"> The object's Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT SetBorderColor(uint Clr);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the current color of the video
    ///border. The border color is used to letterbox the video.
    ///Params:
    ///    pClr = Receives the border color as a <b>COLORREF</b> value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The current media item does not contain
    ///    video. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The
    ///    object's Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT GetBorderColor(uint* pClr);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Applies an audio or video effect to
    ///playback.
    ///Params:
    ///    pEffect = Pointer to the <b>IUnknown</b> interface for one of the following: <ul> <li>A Media Foundation transform
    ///              (MFT) that implements the effect. MFTs expose the IMFTransform interface.</li> <li>An activation object that
    ///              creates an MFT. Activation objects expose the IMFActivate interface.</li> </ul>
    ///    fOptional = Specifies whether the effect is optional. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///                width="40%"><a id="TRUE"></a><a id="true"></a><dl> <dt><b><b>TRUE</b></b></dt> </dl> </td> <td width="60%">
    ///                The effect is optional. If the MFPlay player object cannot add the effect, it ignores the effect and
    ///                continues playback. </td> </tr> <tr> <td width="40%"><a id="FALSE"></a><a id="false"></a><dl>
    ///                <dt><b><b>FALSE</b></b></dt> </dl> </td> <td width="60%"> If the MFPlay player object cannot add the effect,
    ///                a playback error occurs. </td> </tr> </table>
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>MF_E_INVALIDINDEX</b></b></dt> </dl> </td> <td width="60%"> This effect was
    ///    already added. </td> </tr> </table>
    ///    
    HRESULT InsertEffect(IUnknown pEffect, BOOL fOptional);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Removes an effect that was added with
    ///the IMFPMediaPlayer::InsertEffect method.
    ///Params:
    ///    pEffect = Pointer to the <b>IUnknown</b> interface of the effect object. Use the same pointer that you passed to the
    ///              InsertEffect method.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The effect was not found. </td> </tr>
    ///    </table>
    ///    
    HRESULT RemoveEffect(IUnknown pEffect);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Removes all effects that were added
    ///with the IMFPMediaPlayer::InsertEffect method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RemoveAllEffects();
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Shuts down the MFPlay player object
    ///and releases any resources the object is using.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Shutdown();
}

///<div class="alert"><b>Note</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Represents a media item. A <i>media item</i> is an
///abstraction for a source of media data, such as a video file. Use this interface to get information about the source,
///or to change certain playback settings, such as the start and stop times. To get a pointer to this interface, call
///one of the following methods: <ul> <li> IMFPMediaPlayer::CreateMediaItemFromObject </li> <li>
///IMFPMediaPlayer::CreateMediaItemFromURL </li> </ul>
@GUID("90EB3E6B-ECBF-45CC-B1DA-C6FE3EA70D57")
interface IMFPMediaItem : IUnknown
{
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets a pointer to the MFPlay player
    ///object that created the media item.
    ///Params:
    ///    ppMediaPlayer = Receives a pointer to the player object's IMFPMediaPlayer interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMediaPlayer(IMFPMediaPlayer* ppMediaPlayer);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the URL that was used to create
    ///the media item.
    ///Params:
    ///    ppwszURL = Receives a pointer to a null-terminated string that contains the URL. The caller must free the string by
    ///               calling CoTaskMemFree.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOTFOUND</b></dt> </dl> </td> <td width="60%"> No URL is associated with this media item.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_SHUTDOWN</b></dt> </dl> </td> <td width="60%"> The
    ///    IMFPMediaPlayer::Shutdown method was called. </td> </tr> </table>
    ///    
    HRESULT GetURL(PWSTR* ppwszURL);
    HRESULT GetObjectA(IUnknown* ppIUnknown);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the application-defined value
    ///stored in the media item.
    ///Params:
    ///    pdwUserData = Receives the application-defined value for the media item.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetUserData(size_t* pdwUserData);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Stores an application-defined value in
    ///the media item.
    ///Params:
    ///    dwUserData = The application-defined value.
    ///Returns:
    ///    This method can return one of these values.
    ///    
    HRESULT SetUserData(size_t dwUserData);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the start and stop times for the
    ///media item.
    ///Params:
    ///    pguidStartPositionType = Receives the unit of time for the start position. See Remarks. This parameter can be <b>NULL</b>.
    ///    pvStartValue = Receives the start position. The meaning and data type of this parameter are indicated by the
    ///                   <i>pguidStartPositionType</i> parameter. The <i>pvStartValue</i> parameter must be <b>NULL</b> if
    ///                   <i>pguidStartPositionType</i> is <b>NULL</b>, and cannot be <b>NULL</b> otherwise.
    ///    pguidStopPositionType = Receives the unit of time for the stop position. See Remarks. This parameter can be <b>NULL</b>.
    ///    pvStopValue = Stop position. The meaning and data type of this parameter are indicated by the <i>pguidStopPositionType</i>
    ///                  parameter. The <i>pvStopValue</i> parameter must be <b>NULL</b> if <i>pguidStopPositionType</i> is
    ///                  <b>NULL</b>, and cannot be <b>NULL</b> otherwise.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStartStopPosition(GUID* pguidStartPositionType, PROPVARIANT* pvStartValue, 
                                 GUID* pguidStopPositionType, PROPVARIANT* pvStopValue);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Sets the start and stop time for the
    ///media item.
    ///Params:
    ///    pguidStartPositionType = Unit of time for the start position. See Remarks. This parameter can be <b>NULL</b>.
    ///    pvStartValue = Start position. The meaning and data type of this parameter are indicated by the
    ///                   <i>pguidStartPositionType</i> parameter. The <i>pvStartValue</i> parameter must be <b>NULL</b> if
    ///                   <i>pguidStartPositionType</i> is <b>NULL</b>, and cannot be <b>NULL</b> otherwise.
    ///    pguidStopPositionType = Unit of time for the stop position. See Remarks. This parameter can be <b>NULL</b>.
    ///    pvStopValue = Stop position. The meaning and data type of this parameter are indicated by the <i>pguidStopPositionType</i>
    ///                  parameter. The <i>pvStopValue</i> parameter must be <b>NULL</b> if <i>pguidStopPositionType</i> is
    ///                  <b>NULL</b>, and cannot be <b>NULL</b> otherwise.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MF_E_OUT_OF_RANGE</b></dt> </dl> </td> <td width="60%"> Invalid start or stop time.
    ///    Any of the following can cause this error: <ul> <li>Time less than zero.</li> <li>Time greater than the total
    ///    duration of the media item.</li> <li>Stop time less than start time.</li> </ul> </td> </tr> </table>
    ///    
    HRESULT SetStartStopPosition(const(GUID)* pguidStartPositionType, const(PROPVARIANT)* pvStartValue, 
                                 const(GUID)* pguidStopPositionType, const(PROPVARIANT)* pvStopValue);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Queries whether the media item
    ///contains a video stream.
    ///Params:
    ///    pfHasVideo = Receives the value <b>TRUE</b> if the media item contains at least one video stream, or <b>FALSE</b>
    ///                 otherwise.
    ///    pfSelected = Receives the value <b>TRUE</b> if at least one video stream is selected, or <b>FALSE</b> otherwise.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT HasVideo(BOOL* pfHasVideo, BOOL* pfSelected);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Queries whether the media item
    ///contains an audio stream.
    ///Params:
    ///    pfHasAudio = Receives the value <b>TRUE</b> if the media item contains at least one audio stream, or <b>FALSE</b>
    ///                 otherwise.
    ///    pfSelected = Receives the value <b>TRUE</b> if at least one audio stream is selected, or <b>FALSE</b> otherwise.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT HasAudio(BOOL* pfHasAudio, BOOL* pfSelected);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Queries whether the media item
    ///contains protected content. <div class="alert"><b>Note</b> Currently IMFPMediaPlayer does not support playing
    ///protected content.</div><div> </div>
    ///Params:
    ///    pfProtected = Receives one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///                  width="40%"><a id="TRUE"></a><a id="true"></a><dl> <dt><b>TRUE</b></dt> </dl> </td> <td width="60%"> The
    ///                  media item contains protected content. Attempting to play this media item will cause a playback error. </td>
    ///                  </tr> <tr> <td width="40%"><a id="FALSE"></a><a id="false"></a><dl> <dt><b>FALSE</b></dt> </dl> </td> <td
    ///                  width="60%"> The media item does not contain protected content. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IsProtected(BOOL* pfProtected);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the duration of the media item.
    ///Params:
    ///    guidPositionType = Specifies the unit of time for the duration value. The following value is defined. <table> <tr>
    ///                       <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MFP_POSITIONTYPE_100NS"></a><a
    ///                       id="mfp_positiontype_100ns"></a><dl> <dt><b>MFP_POSITIONTYPE_100NS</b></dt> </dl> </td> <td width="60%">
    ///                       100-nanosecond units. The value returned in <i>pvDurationValue</i> is a <b>LARGE_INTEGER</b>. <ul>
    ///                       <li>Variant type (<b>vt</b>): VT_I8</li> <li>Variant member: <b>hVal</b></li> </ul> </td> </tr> </table>
    ///    pvDurationValue = Pointer to a <b>PROPVARIANT</b> that receives the duration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDuration(const(GUID)* guidPositionType, PROPVARIANT* pvDurationValue);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets the number of streams (audio,
    ///video, and other) in the media item.
    ///Params:
    ///    pdwStreamCount = Receives the number of streams.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetNumberOfStreams(uint* pdwStreamCount);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Queries whether a stream is selected
    ///to play.
    ///Params:
    ///    dwStreamIndex = Zero-based index of the stream. To get the number of streams, call IMFPMediaItem::GetNumberOfStreams.
    ///    pfEnabled = Receives a Boolean value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                id="TRUE"></a><a id="true"></a><dl> <dt><b>TRUE</b></dt> </dl> </td> <td width="60%"> The stream is selected.
    ///                During playback, this stream will play. </td> </tr> <tr> <td width="40%"><a id="FALSE"></a><a
    ///                id="false"></a><dl> <dt><b>FALSE</b></dt> </dl> </td> <td width="60%"> The stream is not selected. During
    ///                playback, this stream will not play. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamSelection(uint dwStreamIndex, BOOL* pfEnabled);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Selects or deselects a stream.
    ///Params:
    ///    dwStreamIndex = Zero-based index of the stream. To get the number of streams, call IMFPMediaItem::GetNumberOfStreams.
    ///    fEnabled = Specify whether to select or deselect the stream. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///               width="40%"><a id="TRUE"></a><a id="true"></a><dl> <dt><b>TRUE</b></dt> </dl> </td> <td width="60%"> The
    ///               stream is selected. During playback, this stream will play. </td> </tr> <tr> <td width="40%"><a
    ///               id="FALSE"></a><a id="false"></a><dl> <dt><b>FALSE</b></dt> </dl> </td> <td width="60%"> The stream is not
    ///               selected. During playback, this stream will not play. </td> </tr> </table>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetStreamSelection(uint dwStreamIndex, BOOL fEnabled);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Queries the media item for a stream
    ///attribute.
    ///Params:
    ///    dwStreamIndex = Zero-based index of the stream. To get the number of streams, call IMFPMediaItem::GetNumberOfStreams.
    ///    guidMFAttribute = GUID that identifies the attribute value to query. Possible values are listed in the following topics: <ul>
    ///                      <li> Stream Descriptor Attributes </li> <li> Media Type Attributes </li> </ul>
    ///    pvValue = Pointer to a <b>PROPVARIANT</b> that receives the value. The method fills the <b>PROPVARIANT</b> with a copy
    ///              of the stored value. Call <b>PropVariantClear</b> to free the memory allocated by this method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamAttribute(uint dwStreamIndex, const(GUID)* guidMFAttribute, PROPVARIANT* pvValue);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Queries the media item for a
    ///presentation attribute.
    ///Params:
    ///    guidMFAttribute = GUID that identifies the attribute value to query. For a list of presentation attributes, see Presentation
    ///                      Descriptor Attributes.
    ///    pvValue = Pointer to a <b>PROPVARIANT</b> that receives the value. The method fills the <b>PROPVARIANT</b> with a copy
    ///              of the stored value. Call <b>PropVariantClear</b> to free the memory allocated by the method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPresentationAttribute(const(GUID)* guidMFAttribute, PROPVARIANT* pvValue);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets various flags that describe the
    ///media item.
    ///Params:
    ///    pCharacteristics = Receives a bitwise <b>OR</b> of flags from the _MFP_MEDIAITEM_CHARACTERISTICS enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCharacteristics(uint* pCharacteristics);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Sets a media sink for the media item.
    ///A <i>media sink</i> is an object that consumes the data from one or more streams.
    ///Params:
    ///    dwStreamIndex = Zero-based index of a stream on the media source. The media sink will receive the data from this stream.
    ///    pMediaSink = <b>IUnknown</b> pointer that specifies the media sink. Pass in one of the following: <ul> <li>A pointer to a
    ///                 stream sink. Every media sink contains one or more <i>stream sinks</i>. Each stream sink receives the data
    ///                 from one stream. The stream sink must expose the IMFStreamSink interface.</li> <li>A pointer to an activation
    ///                 object that creates the media sink. The activation object must expose the IMFActivate interface. The media
    ///                 item uses the first stream sink on the media sink (that is, the stream sink at index 0).</li>
    ///                 <li><b>NULL</b>. If you set <i>pMediaSink</i> to <b>NULL</b>, the default media sink for the stream type is
    ///                 used.</li> </ul>
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetStreamSink(uint dwStreamIndex, IUnknown pMediaSink);
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Gets a property store that contains
    ///metadata for the source, such as author or title.
    ///Params:
    ///    ppMetadataStore = Receives a pointer to the <b>IPropertyStore</b> interface of a read-only property store. The caller must
    ///                      release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMetadata(IPropertyStore* ppMetadataStore);
}

///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows. Applications
///should use the Media Session for playback.</div> <div> </div> Callback interface for the IMFPMediaPlayer interface.
///To set the callback, pass an <b>IMFPMediaPlayerCallback</b> pointer to the MFPCreateMediaPlayer function in the
///<i>pCallback</i> parameter. The application implements the <b>IMFPMediaPlayerCallback</b> interface.
@GUID("766C8FFB-5FDB-4FEA-A28D-B912996F51BD")
interface IMFPMediaPlayerCallback : IUnknown
{
    ///<div class="alert"><b>Important</b> Deprecated. This API may be removed from future releases of Windows.
    ///Applications should use the Media Session for playback.</div> <div> </div> Called by the MFPlay player object to
    ///notify the application of a playback event.
    ///Params:
    ///    pEventHeader = Pointer to an MFP_EVENT_HEADER structure that contains information about the event.
    void OnMediaPlayerEvent(MFP_EVENT_HEADER* pEventHeader);
}

///Creates an instance of the media sharing engine.
@GUID("2BA61F92-8305-413B-9733-FAF15F259384")
interface IMFSharingEngineClassFactory : IUnknown
{
    ///Creates an instance of the media sharing engine.
    ///Params:
    ///    dwFlags = A bitwise <b>OR</b> of zero or more flags from the MF_MEDIA_ENGINE_CREATEFLAGS enumeration.
    ///    pAttr = A pointer to the IMFAttributes interface. This parameter specifies configuration attributes; see Media Engine
    ///            Attributes.
    ///    ppEngine = Receives a pointer to the IUnknown interface of the media sharing engine. The caller must release the
    ///               interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateInstance(uint dwFlags, IMFAttributes pAttr, IUnknown* ppEngine);
}

///Enables media sharing.
@GUID("8D3CE1BF-2367-40E0-9EEE-40D377CC1B46")
interface IMFMediaSharingEngine : IMFMediaEngine
{
    ///Gets information about the media sharing device.
    ///Params:
    ///    pDevice = A pointer to a DEVICE_INFO structure. The method fills in this structure with the device information.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDevice(DEVICE_INFO* pDevice);
}

///Creates an instance of the IMFMediaSharingEngine.
@GUID("524D2BC4-B2B1-4FE5-8FAC-FA4E4512B4E0")
interface IMFMediaSharingEngineClassFactory : IUnknown
{
    ///Creates an instance of the IMFMediaSharingEngine.
    ///Params:
    ///    dwFlags = A bitwise <b>OR</b> of zero or more flags from the MF_MEDIA_ENGINE_CREATEFLAGS enumeration.
    ///    pAttr = A pointer to the IMFAttributes interface of an attribute store.
    ///    ppEngine = Receives a pointer to the IMFMediaSharingEngine interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateInstance(uint dwFlags, IMFAttributes pAttr, IMFMediaSharingEngine* ppEngine);
}

///Enables image sharing.
@GUID("CFA0AE8E-7E1C-44D2-AE68-FC4C148A6354")
interface IMFImageSharingEngine : IUnknown
{
    ///Sets the source stream.
    ///Params:
    ///    pStream = The source stream.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetSource(IUnknown pStream);
    ///Gets information about the image sharing device.
    ///Params:
    ///    pDevice = A pointer to a DEVICE_INFO structure. The method fills in this structure with the device information.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDevice(DEVICE_INFO* pDevice);
    ///Shuts down the image sharing engine.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Shutdown();
}

///Creates an instance of the IMFImageSharingEngine.
@GUID("1FC55727-A7FB-4FC8-83AE-8AF024990AF1")
interface IMFImageSharingEngineClassFactory : IUnknown
{
    ///Creates an instance of the IMFImageSharingEngine from the provided unique device name.
    ///Params:
    ///    pUniqueDeviceName = The unique device name of the device with which the sharing engine is created.
    ///    ppEngine = Receives a pointer to the IMFImageSharingEngine interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateInstanceFromUDN(BSTR pUniqueDeviceName, IMFImageSharingEngine* ppEngine);
}

///Enables the <b>PlayToConnection</b> object to connect to a media element.
@GUID("607574EB-F4B6-45C1-B08C-CB715122901D")
interface IPlayToControl : IUnknown
{
    ///Connects the media element to the media sharing engine.
    ///Params:
    ///    pFactory = A pointer to the IMFSharingEngineClassFactory interface. The media element uses this interface to create the
    ///               Sharing Engine.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Connect(IMFSharingEngineClassFactory pFactory);
    ///Disconnects the media element from the media sharing engine.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Disconnect();
}

///Provides functionality for the IPlayToSource to determine the capabilities of the content.
@GUID("AA9DD80F-C50A-4220-91C1-332287F82A34")
interface IPlayToControlWithCapabilities : IPlayToControl
{
    ///Gets the capabilities information for the content.
    ///Params:
    ///    pCapabilities = The capabilities information for the content.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCapabilities(PLAYTO_SOURCE_CREATEFLAGS* pCapabilities);
}

///Creates an instance of the PlayToSource object.
@GUID("842B32A3-9B9B-4D1C-B3F3-49193248A554")
interface IPlayToSourceClassFactory : IUnknown
{
    ///Creates an instance of the <b>PlayToController</b> object.
    ///Params:
    ///    dwFlags = A bitwise <b>OR</b> of flags from the PLAYTO_SOURCE_CREATEFLAGS enumeration.
    ///    pControl = A pointer to the IPlayToControl interface.
    ///    ppSource = Receives a pointer to the IInspectable interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateInstance(uint dwFlags, IPlayToControl pControl, IInspectable* ppSource);
}

///This interface is not supported.
@GUID("D0CFE38B-93E7-4772-8957-0400C49A4485")
interface IEVRVideoStreamControl : IUnknown
{
    ///<div class="alert"><b>Note</b> This method is not supported.</div><div> </div>
    ///Params:
    ///    fActive = 
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetStreamActiveState(BOOL fActive);
    ///<div class="alert"><b>Note</b> This method is not supported.</div><div> </div>
    ///Params:
    ///    lpfActive = 
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetStreamActiveState(BOOL* lpfActive);
}

///Controls video processing in the Enhanced Video Renderer (EVR). The operations controlled through this interface
///include color adjustment (ProcAmp), noise filters, and detail filters. The EVR mixer implements this interface. To
///get a pointer to the interface, call IMFGetService::GetService. The service identifier is GUID
///MR_VIDEO_MIXER_SERVICE. Call <b>GetService</b> on any of the following objects: <ul> <li>The media sesson (if the
///topology contains an instance of the EVR). </li> <li>The EVR media sink. </li> <li>The DirectShow EVR filter. </li>
///<li>The EVR mixer. </li> </ul>If you implement a custom mixer for the EVR, the mixer can optionally expose this
///interface as a service.
@GUID("6AB0000C-FECE-4D1F-A2AC-A9573530656E")
interface IMFVideoProcessor : IUnknown
{
    ///Retrieves the video processor modes that the video driver supports.
    ///Params:
    ///    lpdwNumProcessingModes = Receives the number of video processor modes.
    ///    ppVideoProcessingModes = Receives a pointer to an array of GUIDs. The number of elements in the array is returned in the
    ///                             <i>lpdwNumProcessingModes</i> parameter. The caller must release the memory for the array by calling
    ///                             CoTaskMemFree. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> The media type for the
    ///    reference stream is not set. </td> </tr> </table>
    ///    
    HRESULT GetAvailableVideoProcessorModes(uint* lpdwNumProcessingModes, GUID** ppVideoProcessingModes);
    ///Retrieves the capabilities of a video processor mode.
    ///Params:
    ///    lpVideoProcessorMode = Pointer to a GUID that identifies the video processor mode. To get a list of available modes, call
    ///                           IMFVideoProcessor::GetAvailableVideoProcessorModes.
    ///    lpVideoProcessorCaps = Pointer to a DXVA2_VideoProcessorCaps structure that receives the capabilities.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> The media type for the
    ///    reference stream is not set. </td> </tr> </table>
    ///    
    HRESULT GetVideoProcessorCaps(GUID* lpVideoProcessorMode, DXVA2_VideoProcessorCaps* lpVideoProcessorCaps);
    ///Retrieves the application's preferred video processor mode. To set the preferred mode, call
    ///IMFVideoProcessor::SetVideoProcessorMode.
    ///Params:
    ///    lpMode = Receives a GUID that identifies the preferred video processor mode.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> The media type for the
    ///    reference stream is not set. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> The application has not specified a preferred video processor mode. </td> </tr> </table>
    ///    
    HRESULT GetVideoProcessorMode(GUID* lpMode);
    ///Sets the preferred video processor mode. The EVR will attempt to use this mode when playback starts.
    ///Params:
    ///    lpMode = Pointer to a GUID that identifies the video processor mode. To get a list of available modes, call
    ///             IMFVideoProcessor::GetAvailableVideoProcessorModes.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>D3DERR_INVALIDCALL</b></dt> </dl> </td> <td width="60%"> The requested mode is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> The mixer
    ///    has already allocated Direct3D resources and cannot change modes. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> The media type for the reference
    ///    stream is not set. </td> </tr> </table>
    ///    
    HRESULT SetVideoProcessorMode(GUID* lpMode);
    ///Retrieves the range of values for a color adjustment (ProcAmp) setting.
    ///Params:
    ///    dwProperty = The ProcAmp setting to query. For a list of possible values, see ProcAmp Settings.
    ///    pPropRange = Pointer to a DXVA2_ValueRange structure that receives range of values for the specified ProcAmp setting.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid value for <i>dwProperty</i>. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> No video
    ///    processor mode has been set. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> The media type for the reference
    ///    stream is not set. </td> </tr> </table>
    ///    
    HRESULT GetProcAmpRange(uint dwProperty, DXVA2_ValueRange* pPropRange);
    ///Retrieves the current settings for one or more color adjustment (ProcAmp) settings.
    ///Params:
    ///    dwFlags = Bitwise <b>OR</b> of one or more flags, specifying which operations to query. For a list of flags, see
    ///              ProcAmp Settings.
    ///    Values = Pointer to a DXVA2_ProcAmpValues structure. The method fills the structure with the current value of each
    ///             operation specified in <i>dwFlags</i>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> The media type for the
    ///    reference stream is not set. </td> </tr> </table>
    ///    
    HRESULT GetProcAmpValues(uint dwFlags, DXVA2_ProcAmpValues* Values);
    ///Sets one or more color adjustment (ProcAmp) settings.
    ///Params:
    ///    dwFlags = Bitwise <b>OR</b> of one or more flags, specifying which ProcAmp values to set. For a list of flags, see
    ///              ProcAmp Settings.
    ///    pValues = Pointer to a DXVA2_ProcAmpValues structure. For each flag that you set in <i>dwFlags</i>, set the
    ///              corresponding structure member to the desired value. To get the valid range of values for each operation,
    ///              call IMFVideoProcessor::GetProcAmpRange. The method ignores any structure members for which the corresponding
    ///              flag is not set in <i>dwFlags</i>.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>dwFlags</i> parameter is invalid, or
    ///    one or more values in <i>pValues</i> is not within the correct range. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> The media type for the reference
    ///    stream is not set. </td> </tr> </table>
    ///    
    HRESULT SetProcAmpValues(uint dwFlags, DXVA2_ProcAmpValues* pValues);
    ///Retrieves the range of values for a specified image filter setting.
    ///Params:
    ///    dwProperty = The image filtering parameter to query. For a list of possible values, see DXVA Image Filter Settings.
    ///    pPropRange = Pointer to a DXVA2_ValueRange structure that receives range of values for the specified image filtering
    ///                 parameter.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>DDERR_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> The driver does not support this filter
    ///    setting. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    Invalid value for <i>dwProperty</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_INVALIDREQUEST</b></dt> </dl> </td> <td width="60%"> No video processor mode has been set. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_NOT_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The
    ///    specified operation is not available. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td width="60%"> The media type for the reference
    ///    stream is not set. </td> </tr> </table>
    ///    
    HRESULT GetFilteringRange(uint dwProperty, DXVA2_ValueRange* pPropRange);
    ///Retrieves the current setting for an image filter.
    ///Params:
    ///    dwProperty = The filter setting to query. For a list of possible values, see DXVA Image Filter Settings.
    ///    pValue = Pointer to a DXVA2_Fixed32 structure that receives the current value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The value of <i>dwProperty</i> is invalid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td
    ///    width="60%"> The media type for the reference stream is not set. </td> </tr> </table>
    ///    
    HRESULT GetFilteringValue(uint dwProperty, DXVA2_Fixed32* pValue);
    ///Sets a parameter for an image filter.
    ///Params:
    ///    dwProperty = The image filtering parameter to set. For a list of possible values, see DXVA Image Filter Settings.
    ///    pValue = Pointer to a DXVA2_Fixed32 structure that specifies the new value. To get the valid range of values for each
    ///             parameter, call IMFVideoProcessor::GetFilteringRange.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The value of <i>dwProperty</i> is invalid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MF_E_TRANSFORM_TYPE_NOT_SET</b></dt> </dl> </td> <td
    ///    width="60%"> The media type for the reference stream is not set. </td> </tr> </table>
    ///    
    HRESULT SetFilteringValue(uint dwProperty, DXVA2_Fixed32* pValue);
    ///Retrieves the background color for the composition rectangle. The background color is used for letterboxing the
    ///video image.
    ///Params:
    ///    lpClrBkg = Pointer to a <b>COLORREF</b> value that receives the background color.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT GetBackgroundColor(uint* lpClrBkg);
    ///Sets the background color for the composition rectangle. The background color is used for letterboxing the video
    ///image.
    ///Params:
    ///    ClrBkg = Background color, specified as a <b>COLORREF</b> value. Use the <b>RGB</b> macro to create this value.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetBackgroundColor(uint ClrBkg);
}

///Alpha-blends a static bitmap image with the video displayed by the Enhanced Video Renderer (EVR). The EVR mixer
///implements this interface. To get a pointer to the interface, call IMFGetService::GetService. The service identifier
///GUID is MR_VIDEO_MIXER_SERVICE. Call <b>GetService</b> on any of the following objects: <ul> <li>The Media Session,
///if the topology contains an instance of the EVR. </li> <li>The EVR media sink. </li> <li>The DirectShow EVR filter.
///</li> <li>The EVR mixer. </li> </ul>If you implement a custom mixer for the EVR, the mixer can optionally expose this
///interface as a service.
@GUID("814C7B20-0FDB-4EEC-AF8F-F957C8F69EDC")
interface IMFVideoMixerBitmap : IUnknown
{
    ///Sets a bitmap image for the enhanced video renderer (EVR) to alpha-blend with the video.
    ///Params:
    ///    pBmpParms = Pointer to an MFVideoAlphaBitmap structure that contains information about the bitmap, the source and
    ///                destination rectangles, the color key, and other information.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The blending parameters defined in the
    ///    <i>pBmpParms</i> structure are not valid. </td> </tr> </table>
    ///    
    HRESULT SetAlphaBitmap(const(MFVideoAlphaBitmap)* pBmpParms);
    ///Removes the current bitmap and releases any resources associated with it.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> No bitmap is currently set. </td>
    ///    </tr> </table>
    ///    
    HRESULT ClearAlphaBitmap();
    ///Updates the current alpha-blending settings, including the source and destination rectangles, the color key, and
    ///other information. You can update some or all of the blending parameters.
    ///Params:
    ///    pBmpParms = Pointer to an MFVideoAlphaBitmapParams structure that contains the blending parameters.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The blending parameters defined in the
    ///    <i>pBmpParms</i> structure are not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> No bitmap is currently set. You must call
    ///    IMFVideoMixerBitmap::SetAlphaBitmap to set a bitmap. </td> </tr> </table>
    ///    
    HRESULT UpdateAlphaBitmapParameters(const(MFVideoAlphaBitmapParams)* pBmpParms);
    ///Retrieves the current settings that the enhanced video renderer (EVR) uses to alpha-blend the bitmap with the
    ///video.
    ///Params:
    ///    pBmpParms = Pointer to an MFVideoAlphaBitmapParams structure that receives the current blending parameters.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MF_E_NOT_INITIALIZED</b></dt> </dl> </td> <td width="60%"> No bitmap is currently set. You must
    ///    call IMFVideoMixerBitmap::SetAlphaBitmap to set a bitmap. </td> </tr> </table>
    ///    
    HRESULT GetAlphaBitmapParameters(MFVideoAlphaBitmapParams* pBmpParms);
}

///Provides initialization settings for advanced media capture.
@GUID("3DE21209-8BA6-4F2A-A577-2819B56FF14D")
interface IAdvancedMediaCaptureInitializationSettings : IUnknown
{
    ///Sets the DirectX Device Manager.
    ///Params:
    ///    value = 
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDirectxDeviceManager(IMFDXGIDeviceManager value);
}

///Provides settings for advanced media capture.
@GUID("24E0485F-A33E-4AA1-B564-6019B1D14F65")
interface IAdvancedMediaCaptureSettings : IUnknown
{
    ///Gets the DirectX device manager.
    ///Params:
    ///    value = 
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDirectxDeviceManager(IMFDXGIDeviceManager* value);
}

///Enables advanced media capture.
@GUID("D0751585-D216-4344-B5BF-463B68F977BB")
interface IAdvancedMediaCapture : IUnknown
{
    ///Gets the advanced media capture settings.
    ///Params:
    ///    value = 
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAdvancedMediaCaptureSettings(IAdvancedMediaCaptureSettings* value);
}

///Represents a section of audio data with associated positional and rendering metadata. Spatial audio objects are
///stored in IMFSpatialAudioSample instances, and allow passing of spatial audio information between Media Foundation
///components.
@GUID("D396EC8C-605E-4249-978D-72AD1C312872")
interface IMFSpatialAudioObjectBuffer : IMFMediaBuffer
{
    ///Sets the ID of the spatial audio object represented by the buffer.
    ///Params:
    ///    u32ID = A 32-bit unsigned unique ID of the audio object.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table>
    ///    
    HRESULT SetID(uint u32ID);
    ///Returns the unique, unsigned 32-bit ID of the spatial audio object represented by the buffer. If SetID method was
    ///not previously called, this method returns the invalid object ID, -1 (0xffffffff). The invalid ID indicates that
    ///the object buffer is unused and contains invalid data.
    ///Params:
    ///    pu32ID = Pointer to a 32-bit variable where the object ID will be stored.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The supplied pointer is invalid. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetID(uint* pu32ID);
    ///Sets the type of the spatial audio object represented by the buffer.
    ///Params:
    ///    type = A value from the AudioObjectType enumeration specifying the type of audio object.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetType(AudioObjectType type);
    ///Gets the type of the spatial audio object represented by the buffer. If SetType has not been called previously,
    ///this method returns the default value of <b>AudioObjectType_None</b>.
    ///Params:
    ///    pType = A pointer to an AudioObjectType variable where the audio object type will be stored.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The supplied pointer is invalid. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetType(AudioObjectType* pType);
    ///Retrieves a pointer to a buffer that may contain spatial audio metadata.
    ///Params:
    ///    ppMetadataItems = A pointer to an ISpatialAudioMetadataItems object in which the collection of metadata items will be stored.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The supplied pointer is invalid. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetMetadataItems(ISpatialAudioMetadataItems* ppMetadataItems);
}

///Represents a multimedia sample with spatial sound information. Every <b>IMFSpatialAudioSample</b> contains one or
///more IMFSpatialAudioObjectBuffer objects.
@GUID("ABF28A9B-3393-4290-BA79-5FFC46D986B2")
interface IMFSpatialAudioSample : IMFSample
{
    ///Gets the count of spatial audio objects, represented by IMFSpatialAudioObjectBuffer objects, in the sample.
    ///Params:
    ///    pdwObjectCount = A pointer to a 32 bit variable where the total number of audio objects in the sample will be stored.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The supplied pointer is invalid. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetObjectCount(uint* pdwObjectCount);
    ///Adds a new spatial audio object, represented by an IMFSpatialAudioObjectBuffer object, to the sample.
    ///Params:
    ///    pAudioObjBuffer = A pointer to the new IMFSpatialAudioObject.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The supplied pointer is invalid. </td> </tr>
    ///    </table>
    ///    
    HRESULT AddSpatialAudioObject(IMFSpatialAudioObjectBuffer pAudioObjBuffer);
    ///Returns the spatial audio object, represented by an IMFSpatialAudioObjectBuffer object, corresponding to the
    ///specified index.
    ///Params:
    ///    dwIndex = A 32 bit variable with the 0-based index of the requested audio object.
    ///    ppAudioObjBuffer = A pointer to an IMFSpatialAudioObjectBuffer object in which the spatial audio object corresponding with the
    ///                       specified index will be stored.
    ///Returns:
    ///    The method returns an <b>HRESULT</b>. Possible values include, but are not limited to, those in the following
    ///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The supplied pointer is invalid. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetSpatialAudioObjectByIndex(uint dwIndex, IMFSpatialAudioObjectBuffer* ppAudioObjBuffer);
}

///Provides access to the Content Decryption Module (CDM) for encrypted media extensions support.
@GUID("4E233EFD-1DD2-49E8-B577-D63EEE4C0D33")
interface IMFContentDecryptionModuleSession : IUnknown
{
    ///Gets a unique string identifier generated by the Content Decryption Module (CDM) that can be used by the
    ///application to identify session objects.
    ///Params:
    ///    sessionId = Receives a pointer to an LPWSTR representing the session ID.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT GetSessionId(PWSTR* sessionId);
    ///Gets the expiration time for all keys in the session as determined by the Content Decryption Module (CDM).
    ///Params:
    ///    expiration = Receives a pointer to an LPWSTR representing the session ID or NaN if no such time exists or if the license
    ///                 explicitly never expires.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT GetExpiration(double* expiration);
    ///Gets a reference to an array of structures that represent the key IDs known to the Content Decryption Module
    ///(CDM) session and the current status of the associated key.
    ///Params:
    ///    keyStatuses = Receives a pointer to an array of [MFMediaKeyStatus](../mfidl/ns-mfidl-mfmediakeystatus.md) structures
    ///                  containing the IDs and statuses of the keys known to the CDM session.
    ///    numKeyStatuses = Receives the number of structures present in the *keyStatuses* array.
    ///Returns:
    ///    Returns S_OK. If an error occurs, the returned mey status list is empty.
    ///    
    HRESULT GetKeyStatuses(MFMediaKeyStatus** keyStatuses, uint* numKeyStatuses);
    ///Loads the data for the specified session into the **IMFContentDecryptionModuleSession** object.
    ///Params:
    ///    sessionId = The unique identifier of the session to load.
    ///    loaded = Receives a pointer to a *BOOL* indicating if the session data was loaded successfully.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT Load(const(PWSTR) sessionId, BOOL* loaded);
    ///Generates a license request based on the provided data.
    ///Params:
    ///    initDataType = A **LPCWSTR** specifying the type of the data provided in the *initData* parameter. The string format is
    ///                   specified by the Encrypted Media Extension specification's [Initialization Data
    ///                   Type](https://www.w3.org/TR/2017/REC-encrypted-media-20170918/
    ///    initData = A **BYTE** array containing initialization data. The data format is specified by the Encrypted Media
    ///               Extension specification's [Initialization Data](https://www.w3.org/TR/2017/REC-encrypted-media-20170918/
    ///    initDataSize = The size of the **BYTE** array provided in the *initData* parameter.
    ///Returns:
    ///    Rerturns S_OK on success.
    ///    
    HRESULT GenerateRequest(const(PWSTR) initDataType, const(ubyte)* initData, uint initDataSize);
    ///Provides messages, including licenses, to the Content Decryption Module (CDM) session. Persisted data should not
    ///be released or cleared.
    ///Params:
    ///    response = A **BYTE** array containing messages.
    ///    responseSize = The size of the **BYTE** array provided in the *response* parameter.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT Update(const(ubyte)* response, uint responseSize);
    ///Indicates that the application no longer needs the session and the Content Decryption Module (CDM) should release
    ///any resources associated with the session and close it.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT Close();
    ///Removes all licenses and keys associated with the session.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT Remove();
}

///Provides a callback mechanism for receiving key status change updates from an
///[IMFContentDecryptionModuleSession](nn-mfcontentdecryptionmodule-imfcontentdecryptionmodulesession.md).
@GUID("3F96EE40-AD81-4096-8470-59A4B770F89A")
interface IMFContentDecryptionModuleSessionCallbacks : IUnknown
{
    ///Called when the Content Decryption Module (CDM) has generated a message for the session.
    ///Params:
    ///    messageType = A value from the [MF_MEDIAKEYSESSION_MESSAGETYPE](../mfidl/ne-mfidl-mf_mediakeysession_messagetype.md)
    ///                  enumeration specifying the type of the message.
    ///    message = A pointer to a **BYTE** array containing the message contents. Messages are Key System-specific.
    ///    messageSize = The size of the array in the *message* parameter.
    ///    destinationURL = A optional parameter containing the destination URL.
    ///Returns:
    ///    Returns an HRESULT.
    ///    
    HRESULT KeyMessage(MF_MEDIAKEYSESSION_MESSAGETYPE messageType, const(ubyte)* message, uint messageSize, 
                       const(PWSTR) destinationURL);
    ///Called when there has been a change in the keys in the Content Decryption Module (CDM) session or their status.
    ///Returns:
    ///    Returns S_OK.
    ///    
    HRESULT KeyStatusChanged();
}

///Represents a Content Decryption Module (CDM) for a DRM key system.
@GUID("87BE986C-10BE-4943-BF48-4B54CE1983A2")
interface IMFContentDecryptionModule : IUnknown
{
    ///Allows the caller to specify the [IMFContentEnabler](../mfidl/nn-mfidl-imfcontentenabler.md) interface that shall
    ///be used by the Content Decryption Module (CDM).
    ///Params:
    ///    contentEnabler = The [IMFContentEnabler](../mfidl/nn-mfidl-imfcontentenabler.md) interface to be used by the CDM.
    ///    result = An [IMFAsyncResult](../mfobjects/nn-mfobjects-imfasyncresult.md) that provides information about the result
    ///             of the operation.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT SetContentEnabler(IMFContentEnabler contentEnabler, IMFAsyncResult result);
    ///Retrieves an object for
    ///[IMFContentDecryptionModuleSession](nn-mfcontentdecryptionmodule-imfcontentdecryptionmodulesession.md) suspend
    ///events.
    ///Params:
    ///    notify = Receives an [IMFCdmSuspendNotify](../mfmediaengine/nn-mfmediaengine-imfcdmsuspendnotify.md) object that
    ///             notifies the Content Decryption Module (CDM) when global resources should be brought into a consistent state
    ///             prior to suspending.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT GetSuspendNotify(IMFCdmSuspendNotify* notify);
    ///Allows the caller to specify the [IMFPMPHostApp](../mfidl/nn-mfidl-imfpmphostapp.md) interface, which represents
    ///a protected process. The **IMFPMPHostApp** interface is used by the Content Decryption Module (CDM) to create the
    ///IMFTrustedInput object.
    ///Params:
    ///    pmpHostApp = The **IMFPMPHostApp** representing a protected process.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT SetPMPHostApp(IMFPMPHostApp pmpHostApp);
    ///Creates a [IMFContentDecryptionModuleSession](nn-mfcontentdecryptionmodule-imfcontentdecryptionmodulesession)
    ///object representing a Content Decryption Module (CDM) session.
    ///Params:
    ///    sessionType = A member of the [MF_MEDIAKEYSESSION_TYPE](../mfidl/ne-mfidl-mf_mediakeysession_type.md) that specifies the
    ///                  type of CDM session to create.
    ///    callbacks = An
    ///                [IMFContentDecryptionModuleSessionCallbacks](nn-mfcontentdecryptionmodule-imfcontentdecryptionmodulesessioncallbacks)
    ///                object for receiving key status change updates.
    ///    session = Receives the created **IMFContentDecryptionModuleSession** object.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT CreateSession(MF_MEDIAKEYSESSION_TYPE sessionType, 
                          IMFContentDecryptionModuleSessionCallbacks callbacks, 
                          IMFContentDecryptionModuleSession* session);
    ///Provides a server certificate to be used to encrypt messages to the license server.
    ///Params:
    ///    certificate = A **BYTE** array containing the certificate.
    ///    certificateSize = The size of the array in *certificate*.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT SetServerCertificate(const(ubyte)* certificate, uint certificateSize);
    ///Creates an [IMFTrustedInput](../mfidl/nn-mfidl-imftrustedinput.md) object that implements the decryption of
    ///content.
    ///Params:
    ///    contentInitData = A **BYTE** array containing initialization data. *contentInitData* will only be used if initData from
    ///                      [IMFContentDecryptionModuleSession::GenerateRequest](nf-mfcontentdecryptionmodule-imfcontentdecryptionmodulesession-generaterequest)
    ///                      is not provided or incomplete. Initialization Data should be structured in PSSH Box Format. For more details,
    ///                      see the Encrypted Media Extension specification's [Common SystemID and PSSH Box
    ///                      Format](https://www.w3.org/TR/eme-initdata-cenc/
    ///    contentInitDataSize = The size of the array in *contentInitData*.
    ///    trustedInput = Receives the created **IMFTrustedInput** object.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT CreateTrustedInput(const(ubyte)* contentInitData, uint contentInitDataSize, 
                               IMFTrustedInput* trustedInput);
    ///Gets a list of **SystemIDs** that the **IMFContentDecryptionModule** supports.
    ///Params:
    ///    systemIds = A **GUID** array in which the SystemIDs are returned.
    ///    count = The count of SystemIDs returned in the *systemIds* parameter.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT GetProtectionSystemIds(GUID** systemIds, uint* count);
}

///Provides access to a media key system.
@GUID("A853D1F4-E2A0-4303-9EDC-F1A68EE43136")
interface IMFContentDecryptionModuleAccess : IUnknown
{
    ///Creates a [IMFContentDecryptionModule](nn-mfcontentdecryptionmodule-imfcontentdecryptionmodule) that represents a
    ///Content Decryption Module (CDM) for a DRM key system.
    ///Params:
    ///    contentDecryptionModuleProperties = An [IPropertyStore](../propsys/nn-propsys-ipropertystore.md) object containing the properties for the CDM.
    ///    contentDecryptionModule = Receives the created **IMFContentDecryptionModule** object.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT CreateContentDecryptionModule(IPropertyStore contentDecryptionModuleProperties, 
                                          IMFContentDecryptionModule* contentDecryptionModule);
    ///Returns the supported combination of configuration options.
    ///Params:
    ///    configuration = Recevices a referebce to an [IPropertyStore](../propsys/nn-propsys-ipropertystore.md) object containing the
    ///                    configuration options for the CDM.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT GetConfiguration(IPropertyStore* configuration);
    ///Gets a string identifying the Key System being used by the Content Decryption Module (CDM).
    ///Params:
    ///    keySystem = Receives a pointer to an **LPWSTR** identifying the Key System.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT GetKeySystem(PWSTR* keySystem);
}

///A factory interface for creating
///[IMFContentDecryptionModuleAccess](nn-mfcontentdecryptionmodule-imfcontentdecryptionmoduleaccess) objects.
@GUID("7D5ABF16-4CBB-4E08-B977-9BA59049943E")
interface IMFContentDecryptionModuleFactory : IUnknown
{
    ///Queries whether the specified Key System and, optionally, content type are supported.
    ///Params:
    ///    keySystem = An **LPCWSTR** specifying the Key System for which support is being queried.
    ///    contentType = Optional. An **LPCWSTR** specifying the content type for which support is being queried.
    ///Returns:
    ///    True if the specified Key System and content type are supported; otherwise, false.
    ///    
    BOOL    IsTypeSupported(const(PWSTR) keySystem, const(PWSTR) contentType);
    ///Creates an instance of the
    ///[IMFContentDecryptionModuleAccess](nn-mfcontentdecryptionmodule-imfcontentdecryptionmoduleaccess.md) interface.
    ///Params:
    ///    keySystem = An **LPWSTR** identifying the Key System for which the interface is created.
    ///    configurations = An [IPropertyStore](../propsys/nn-propsys-ipropertystore.md) object containing the configuration options for
    ///                     the CDM.
    ///    numConfigurations = A **DWORD** specifying the number of properties in the *configurations* parameter.
    ///    contentDecryptionModuleAccess = Receives the created **IMFContentDecryptionModuleAccess** object.
    ///Returns:
    ///    Returns S_OK on success.
    ///    
    HRESULT CreateContentDecryptionModuleAccess(const(PWSTR) keySystem, IPropertyStore* configurations, 
                                                uint numConfigurations, 
                                                IMFContentDecryptionModuleAccess* contentDecryptionModuleAccess);
}

///The <b>ICodecAPI</b> interface sets and retrieves settings on an encoder or decoder filter. > [!Note] > APIs declared
///in strmif.h are not supported for Universal Windows Platform (UWP) apps. To use ICodecAPI in a UWP app, use the
///version declared in [icodecapi.h](/windows/win32/api/icodecapi/).
@GUID("901DB4C7-31CE-41A2-85DC-8FA0BF41B8DA")
interface ICodecAPI : IUnknown
{
    ///The <b>IsSupported</b> method queries whether a codec supports a given property.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the property to query. For a list of standard codec properties, see Codec
    ///          API Properties.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The codec does not support the
    ///    property. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The codec
    ///    supports the property. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> The codec does not support the property. </td> </tr> </table>
    ///    
    HRESULT IsSupported(const(GUID)* Api);
    ///The <b>IsModifiable</b> method queries whether a codec property can be changed, given the codec's current
    ///configuration.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the property. For a list of standard codec properties, see Codec API
    ///          Properties.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The value of this property cannot
    ///    be changed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    value of this property can be changed. </td> </tr> </table>
    ///    
    HRESULT IsModifiable(const(GUID)* Api);
    ///The <b>GetParameterRange</b> method gets the range of values for a codec property. This method applies only to
    ///properties whose values form a linear range.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the property to query. For a list of standard codec properties, see Codec
    ///          API Properties.
    ///    ValueMin = Pointer to a <b>VARIANT</b> that receives the minimum value of the property. The caller must free the
    ///               <b>VARIANT</b> by calling <b>VariantClear</b>.
    ///    ValueMax = Pointer to a <b>VARIANT</b> that receives the maximum value of the property. The caller must free the
    ///               <b>VARIANT</b> by calling <b>VariantClear</b>.
    ///    SteppingDelta = Pointer to a <b>VARIANT</b> that receives the stepping delta, which defines the valid increments from
    ///                    <i>ValueMin</i> to <i>ValueMax</i>. The caller must free the <b>VARIANT</b> by calling <b>VariantClear</b>.
    ///                    If the <b>VARIANT</b> type is VT_EMPTY, any increment is valid.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_CODECAPI_ENUMERATED</b></dt> </dl> </td> <td width="60%"> The
    ///    property supports a list of possible values, not a linear range. </td> </tr> </table>
    ///    
    HRESULT GetParameterRange(const(GUID)* Api, VARIANT* ValueMin, VARIANT* ValueMax, VARIANT* SteppingDelta);
    ///The <b>GetParameterValues</b> method gets the list of possible values for a codec property. This method applies
    ///only to properties that support a list of possible values, as opposed to a linear range.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the property to query. For a list of standard codec properties, see Codec
    ///          API Properties.
    ///    Values = Receives a pointer to an array of <b>VARIANT</b> types. The array contains the list of values that the
    ///             encoder supports for this property. The caller must free each <b>VARIANT</b> by calling <b>VariantClear</b>.
    ///             The caller must also free the array by calling <b>CoTaskMemFree</b>.
    ///    ValuesCount = Receives the number of elements in the <i>Values</i> array.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VFW_E_CODECAPI_LINEAR_RANGE</b></dt> </dl> </td> <td width="60%"> The
    ///    property supports a range of values, not a list. </td> </tr> </table>
    ///    
    HRESULT GetParameterValues(const(GUID)* Api, VARIANT** Values, uint* ValuesCount);
    ///The <b>GetDefaultValue</b> method gets the default value of a codec property.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the property. For a list of standard codec properties, see Codec API
    ///          Properties.
    ///    Value = Pointer to a <b>VARIANT</b> that receives the default value. The caller must free the <b>VARIANT</b> by
    ///            calling <b>VariantClear</b>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_CODECAPI_NO_DEFAULT</b></dt> </dl> </td> <td width="60%"> The
    ///    specified property does not have a default value. </td> </tr> </table>
    ///    
    HRESULT GetDefaultValue(const(GUID)* Api, VARIANT* Value);
    ///The <b>GetValue</b> method gets the current value of a codec property.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the property. For a list of standard codec properties, see Codec API
    ///          Properties.
    ///    Value = Pointer to a <b>VARIANT</b> that receives the value of the property. The caller must free the <b>VARIANT</b>
    ///            by calling <b>VariantClear</b>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VFW_E_CODECAPI_NO_CURRENT_VALUE</b></dt> </dl> </td> <td width="60%"> The
    ///    property does not currently have a value. </td> </tr> </table>
    ///    
    HRESULT GetValue(const(GUID)* Api, VARIANT* Value);
    ///The <b>SetValue</b> method sets the value of a codec property.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the property to set. For a list of standard codec properties, see Codec API
    ///          Properties.
    ///    Value = Pointer to a <b>VARIANT</b> that contains the new value for the property.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The property is read-only.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid
    ///    property GUID or value. </td> </tr> </table>
    ///    
    HRESULT SetValue(const(GUID)* Api, VARIANT* Value);
    ///The <b>RegisterForEvent</b> method registers the application to receive events from the codec.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the event. There are three categories of events: <table> <tr> <th>Value</th>
    ///          <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CODECAPI_CHANGELISTS"></a><a
    ///          id="codecapi_changelists"></a><dl> <dt><b>CODECAPI_CHANGELISTS</b></dt> </dl> </td> <td width="60%"> The
    ///          codec notifies the application when the properties of the codec change. The event data is a list of GUIDs for
    ///          the properties that changed. </td> </tr> <tr> <td width="40%"><a
    ///          id="One_of_the_property_GUIDs_defined_in_codecapi.h.__See_Codec_API_Properties._"></a><a
    ///          id="one_of_the_property_guids_defined_in_codecapi.h.__see_codec_api_properties._"></a><a
    ///          id="ONE_OF_THE_PROPERTY_GUIDS_DEFINED_IN_CODECAPI.H.__SEE_CODEC_API_PROPERTIES._"></a><dl> <dt><b>One of the
    ///          property GUIDs defined in codecapi.h. (See Codec API Properties.)</b></dt> </dl> </td> <td width="60%"> The
    ///          codec notifies the application when the specified property changes. Typically, a codec will support this type
    ///          of notification for a limited set of properties, if any. </td> </tr> <tr> <td width="40%"><a
    ///          id="A_proprietary_event_GUID_defined_by_the_codec."></a><a
    ///          id="a_proprietary_event_guid_defined_by_the_codec."></a><a
    ///          id="A_PROPRIETARY_EVENT_GUID_DEFINED_BY_THE_CODEC."></a><dl> <dt><b>A proprietary event GUID defined by the
    ///          codec.</b></dt> </dl> </td> <td width="60%"> Implementation dependent. </td> </tr> </table>
    ///    userData = Pointer to caller-defined data. The application receives this pointer in the <i>lParam1</i> event parameter.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. The codec
    ///    does not support event notification, or does not support the event GUID specified in the <i>Api</i>
    ///    parameter. </td> </tr> </table>
    ///    
    HRESULT RegisterForEvent(const(GUID)* Api, ptrdiff_t userData);
    ///The <b>UnregisterForEvent</b> method unregisters the application for a specified encoder event.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the event.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. If it fails, it returns an <b>HRESULT</b> error code.
    ///    
    HRESULT UnregisterForEvent(const(GUID)* Api);
    ///The <b>SetAllDefaults</b> method resets all codec properties to their default values.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetAllDefaults();
    ///The <b>SetValueWithNotify</b> method sets a property on a codec and returns a list of other properties that
    ///changed as a result.
    ///Params:
    ///    Api = Pointer to a GUID that specifies the property to set. For a list of standard codec properties, see Codec API
    ///          Properties.
    ///    Value = Pointer to a <b>VARIANT</b> that contains the new value for the property.
    ///    ChangedParam = Receives a pointer to an array of GUIDs. The array contains the GUIDs of any properties that changed as a
    ///                   result of this method call. The caller must free the array by calling <b>CoTaskMemFree</b>.
    ///    ChangedParamCount = Receives the number of elements in the <i>ChangedParam</i> array.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetValueWithNotify(const(GUID)* Api, VARIANT* Value, GUID** ChangedParam, uint* ChangedParamCount);
    ///The <b>SetAllDefaultsWithNotify</b> method resets all codec properties to their default values, and returns a
    ///list of the properties that changed.
    ///Params:
    ///    ChangedParam = Receives a pointer to an array of GUIDs. The array contains the GUIDs of any properties that changed as a
    ///                   result of this method call. The caller must free the array by calling <b>CoTaskMemFree</b>.
    ///    ChangedParamCount = Receives the number of elements in the <i>ChangedParam</i> array.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetAllDefaultsWithNotify(GUID** ChangedParam, uint* ChangedParamCount);
    ///The <b>GetAllSettings</b> method gets the codec's current properties and writes them to a stream.
    ///Params:
    ///    __MIDL__ICodecAPI0000 = Pointer to the <b>IStream</b> interface of the stream.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetAllSettings(IStream __MIDL__ICodecAPI0000);
    ///The <b>SetAllSettings</b> method reads codec properties from a stream and sets them on the codec.
    ///Params:
    ///    __MIDL__ICodecAPI0001 = Pointer to the <b>IStream</b> interface of the stream.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetAllSettings(IStream __MIDL__ICodecAPI0001);
    ///The <b>SetAllSettingsWithNotify</b> method reads codec properties from a stream, sets them on the codec, and
    ///returns a list of the properties that changed.
    ///Params:
    ///    __MIDL__ICodecAPI0002 = Pointer to the <b>IStream</b> interface of the stream.
    ///    ChangedParam = Receives a pointer to an array of GUIDs. The array contains the GUIDs of any properties that changed as a
    ///                   result of this method call. The caller must free the array by calling <b>CoTaskMemFree</b>.
    ///    ChangedParamCount = Receives the number of elements in the <i>ChangedParam</i> array.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Not implemented. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetAllSettingsWithNotify(IStream __MIDL__ICodecAPI0002, GUID** ChangedParam, uint* ChangedParamCount);
}

///Represents a hardware-accelerated video decoder for Microsoft Direct3D 11.
@GUID("3C9C5B51-995D-48D1-9B8D-FA5CAEDED65C")
interface ID3D11VideoDecoder : ID3D11DeviceChild
{
    ///Gets the parameters that were used to create the decoder.
    ///Params:
    ///    pVideoDesc = A pointer to a D3D11_VIDEO_DECODER_DESC structure that receives a description of the video stream.
    ///    pConfig = A pointer to a D3D11_VIDEO_DECODER_CONFIG structure that receives the decoder configuration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCreationParameters(D3D11_VIDEO_DECODER_DESC* pVideoDesc, D3D11_VIDEO_DECODER_CONFIG* pConfig);
    ///Gets a handle to the driver.
    ///Params:
    ///    pDriverHandle = Receives a handle to the driver.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDriverHandle(HANDLE* pDriverHandle);
}

///Enumerates the video processor capabilities of a Microsoft Direct3D 11 device.
@GUID("31627037-53AB-4200-9061-05FAA9AB45F9")
interface ID3D11VideoProcessorEnumerator : ID3D11DeviceChild
{
    ///Gets the content description that was used to create this enumerator.
    ///Params:
    ///    pContentDesc = A pointer to a D3D11_VIDEO_PROCESSOR_CONTENT_DESC structure that receives the content description.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoProcessorContentDesc(D3D11_VIDEO_PROCESSOR_CONTENT_DESC* pContentDesc);
    ///Queries whether the video processor supports a specified video format.
    ///Params:
    ///    Format = The video format to query, specified as a DXGI_FORMAT value.
    ///    pFlags = Receives a bitwise <b>OR</b> of zero or more flags from the D3D11_VIDEO_PROCESSOR_FORMAT_SUPPORT enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CheckVideoProcessorFormat(DXGI_FORMAT Format, uint* pFlags);
    ///Gets the capabilities of the video processor.
    ///Params:
    ///    pCaps = A pointer to a D3D11_VIDEO_PROCESSOR_CAPS structure that receives the capabilities.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoProcessorCaps(D3D11_VIDEO_PROCESSOR_CAPS* pCaps);
    ///Returns a group of video processor capabilities that are associated with frame-rate conversion, including
    ///deinterlacing and inverse telecine.
    ///Params:
    ///    TypeIndex = The zero-based index of the group to retrieve. To get the maximum index, call
    ///                ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>RateConversionCapsCount</b> member of
    ///                the D3D11_VIDEO_PROCESSOR_CAPS structure.
    ///    pCaps = A pointer to a D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS structure that receives the frame-rate conversion
    ///            capabilities.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoProcessorRateConversionCaps(uint TypeIndex, D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS* pCaps);
    ///Gets a list of custom frame rates that a video processor supports.
    ///Params:
    ///    TypeIndex = The zero-based index of the frame-rate capability group. To get the maxmum index, call
    ///                ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>RateConversionCapsCount</b> member of
    ///                the D3D11_VIDEO_PROCESSOR_CAPS structure.
    ///    CustomRateIndex = The zero-based index of the custom rate to retrieve. To get the maximum index, call
    ///                      ID3D11VideoProcessorEnumerator::GetVideoProcessorRateConversionCaps and check the <b>CustomRateCount</b>
    ///                      member of the D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS structure. This index value is always relative to
    ///                      the capability group specified in the <i>TypeIndex</i> parameter.
    ///    pRate = A pointer to a D3D11_VIDEO_PROCESSOR_CUSTOM_RATE structure that receives the custom rate.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoProcessorCustomRate(uint TypeIndex, uint CustomRateIndex, 
                                        D3D11_VIDEO_PROCESSOR_CUSTOM_RATE* pRate);
    ///Gets the range of values for an image filter.
    ///Params:
    ///    Filter = The type of image filter, specified as a D3D11_VIDEO_PROCESSOR_FILTER value.
    ///    pRange = A pointer to a D3D11_VIDEO_PROCESSOR_FILTER_RANGE structure. The method fills the structure with the range of
    ///             values for the specified filter.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoProcessorFilterRange(D3D11_VIDEO_PROCESSOR_FILTER Filter, 
                                         D3D11_VIDEO_PROCESSOR_FILTER_RANGE* pRange);
}

///Represents a video processor for Microsoft Direct3D 11.
@GUID("1D7B0652-185F-41C6-85CE-0C5BE3D4AE6C")
interface ID3D11VideoProcessor : ID3D11DeviceChild
{
    ///Gets the content description that was used to create the video processor.
    ///Params:
    ///    pDesc = A pointer to a D3D11_VIDEO_PROCESSOR_CONTENT_DESC structure that receives the content description.
    void GetContentDesc(D3D11_VIDEO_PROCESSOR_CONTENT_DESC* pDesc);
    ///Gets the rate conversion capabilities of the video processor.
    ///Params:
    ///    pCaps = A pointer to a D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS structure that receives the rate conversion
    ///            capabilities.
    void GetRateConversionCaps(D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS* pCaps);
}

///Provides a communication channel with the graphics driver or the Microsoft Direct3D runtime.
@GUID("3015A308-DCBD-47AA-A747-192486D14D4A")
interface ID3D11AuthenticatedChannel : ID3D11DeviceChild
{
    ///Gets the size of the driver's certificate chain.
    ///Params:
    ///    pCertificateSize = Receives the size of the certificate chain, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCertificateSize(uint* pCertificateSize);
    ///Gets the driver's certificate chain.
    ///Params:
    ///    CertificateSize = The size of the <i>pCertificate</i> array, in bytes. To get the size of the certificate chain, call
    ///                      ID3D11CryptoSession::GetCertificateSize.
    ///    pCertificate = A pointer to a byte array that receives the driver's certificate chain. The caller must allocate the array.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCertificate(uint CertificateSize, ubyte* pCertificate);
    ///Gets a handle to the authenticated channel.
    ///Params:
    ///    pChannelHandle = Receives a handle to the channel.
    void    GetChannelHandle(HANDLE* pChannelHandle);
}

///Represents a cryptographic session.
@GUID("9B32F9AD-BDCC-40A6-A39D-D5C865845720")
interface ID3D11CryptoSession : ID3D11DeviceChild
{
    ///Gets the type of encryption that is supported by this session.
    ///Params:
    ///    pCryptoType = Receives a GUID that specifies the encryption type. The following GUIDs are defined. <table> <tr>
    ///                  <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="D3D11_CRYPTO_TYPE_AES128_CTR"></a><a
    ///                  id="d3d11_crypto_type_aes128_ctr"></a><dl> <dt><b>D3D11_CRYPTO_TYPE_AES128_CTR</b></dt> </dl> </td> <td
    ///                  width="60%"> 128-bit Advanced Encryption Standard CTR mode (AES-CTR) block cipher. </td> </tr> </table>
    void    GetCryptoType(GUID* pCryptoType);
    ///Gets the decoding profile of the session.
    ///Params:
    ///    pDecoderProfile = Receives the decoding profile. For a list of possible values, see ID3D11VideoDevice::GetVideoDecoderProfile.
    void    GetDecoderProfile(GUID* pDecoderProfile);
    ///Gets the size of the driver's certificate chain.
    ///Params:
    ///    pCertificateSize = Receives the size of the certificate chain, in bytes.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCertificateSize(uint* pCertificateSize);
    ///Gets the driver's certificate chain.
    ///Params:
    ///    CertificateSize = The size of the <i>pCertificate</i> array, in bytes. To get the size of the certificate chain, call
    ///                      ID3D11CryptoSession::GetCertificateSize.
    ///    pCertificate = A pointer to a byte array that receives the driver's certificate chain. The caller must allocate the array.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetCertificate(uint CertificateSize, ubyte* pCertificate);
    ///Gets a handle to the cryptographic session.
    ///Params:
    ///    pCryptoSessionHandle = Receives a handle to the session.
    void    GetCryptoSessionHandle(HANDLE* pCryptoSessionHandle);
}

///Identifies the output surfaces that can be accessed during video decoding.
@GUID("C2931AEA-2A85-4F20-860F-FBA1FD256E18")
interface ID3D11VideoDecoderOutputView : ID3D11View
{
    ///Gets the properties of the video decoder output view.
    ///Params:
    ///    pDesc = A pointer to a D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC structure. The method fills the structure with the view
    ///            properties.
    void GetDesc(D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC* pDesc);
}

///Identifies the input surfaces that can be accessed during video processing.
@GUID("11EC5A5F-51DC-4945-AB34-6E8C21300EA5")
interface ID3D11VideoProcessorInputView : ID3D11View
{
    ///Gets the properties of the video processor input view.
    ///Params:
    ///    pDesc = A pointer to a D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC structure. The method fills the structure with the view
    ///            properties.
    void GetDesc(D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC* pDesc);
}

///Identifies the output surfaces that can be accessed during video processing.
@GUID("A048285E-25A9-4527-BD93-D68B68C44254")
interface ID3D11VideoProcessorOutputView : ID3D11View
{
    ///Gets the properties of the video processor output view.
    ///Params:
    ///    pDesc = A pointer to a D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC structure. The method fills the structure with the view
    ///            properties.
    void GetDesc(D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC* pDesc);
}

///Provides the video functionality of a Microsoft Direct3D 11 device.
@GUID("61F21C45-3C0E-4A74-9CEA-67100D9AD5E4")
interface ID3D11VideoContext : ID3D11DeviceChild
{
    ///Gets a pointer to a decoder buffer.
    ///Params:
    ///    pDecoder = A pointer to the ID3D11VideoDecoder interface. To get this pointer, call
    ///               ID3D11VideoDevice::CreateVideoDecoder.
    ///    Type = The type of buffer to retrieve, specified as a member of the D3D11_VIDEO_DECODER_BUFFER_TYPE enumeration.
    ///    pBufferSize = Receives the size of the buffer, in bytes.
    ///    ppBuffer = Receives a pointer to the start of the memory buffer.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetDecoderBuffer(ID3D11VideoDecoder pDecoder, D3D11_VIDEO_DECODER_BUFFER_TYPE Type, uint* pBufferSize, 
                             void** ppBuffer);
    ///Releases a buffer that was obtained by calling the ID3D11VideoContext::GetDecoderBuffer method.
    ///Params:
    ///    pDecoder = A pointer to the ID3D11VideoDecoder interface. To get this pointer, call
    ///               ID3D11VideoDevice::CreateVideoDecoder.
    ///    Type = The type of buffer to release. Specify the same value that was used in the <i>Type</i> parameter of the
    ///           GetDecoderBuffer method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ReleaseDecoderBuffer(ID3D11VideoDecoder pDecoder, D3D11_VIDEO_DECODER_BUFFER_TYPE Type);
    ///Starts a decoding operation to decode a video frame.
    ///Params:
    ///    pDecoder = A pointer to the ID3D11VideoDecoder interface. To get this pointer, call
    ///               ID3D11VideoDevice::CreateVideoDecoder.
    ///    pView = A pointer to the ID3D11VideoDecoderOutputView interface. This interface describes the resource that will
    ///            receive the decoded frame. To get this pointer, call ID3D11VideoDevice::CreateVideoDecoderOutputView.
    ///    ContentKeySize = The size of the content key that is specified in <i>pContentKey</i>. If <i>pContentKey</i> is NULL, set
    ///                     <i>ContentKeySize</i> to zero.
    ///    pContentKey = An optional pointer to a content key that was used to encrypt the frame data. If no content key was used, set
    ///                  this parameter to <b>NULL</b>. If the caller provides a content key, the caller must use the session key to
    ///                  encrypt the content key.
    ///Returns:
    ///    If this method succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
    ///    <b>D3DERR_WASSTILLDRAWING</b> or <b>E_PENDING</b> is returned if the harware is busy, in which case the
    ///    decoder should try to make the call again.
    ///    
    HRESULT DecoderBeginFrame(ID3D11VideoDecoder pDecoder, ID3D11VideoDecoderOutputView pView, uint ContentKeySize, 
                              const(void)* pContentKey);
    ///Signals the end of a decoding operation.
    ///Params:
    ///    pDecoder = A pointer to the ID3D11VideoDecoder interface. To get this pointer, call
    ///               ID3D11VideoDevice::CreateVideoDecoder.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT DecoderEndFrame(ID3D11VideoDecoder pDecoder);
    ///Submits one or more buffers for decoding.
    ///Params:
    ///    pDecoder = A pointer to the ID3D11VideoDecoder interface. To get this pointer, call the
    ///               ID3D11VideoDevice::CreateVideoDecoder method.
    ///    NumBuffers = The number of buffers submitted for decoding.
    ///    pBufferDesc = A pointer to an array of D3D11_VIDEO_DECODER_BUFFER_DESC structures. The <i>NumBuffers</i> parameter
    ///                  specifies the number of elements in the array. Each element in the array describes a compressed buffer for
    ///                  decoding.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SubmitDecoderBuffers(ID3D11VideoDecoder pDecoder, uint NumBuffers, 
                                 const(D3D11_VIDEO_DECODER_BUFFER_DESC)* pBufferDesc);
    ///Performs an extended function for decoding. This method enables extensions to the basic decoder functionality.
    ///Params:
    ///    pDecoder = A pointer to the ID3D11VideoDecoder interface. To get this pointer, call
    ///               ID3D11VideoDevice::CreateVideoDecoder.
    ///    pExtensionData = A pointer to a D3D11_VIDEO_DECODER_EXTENSION structure that contains data for the function.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    int     DecoderExtension(ID3D11VideoDecoder pDecoder, const(D3D11_VIDEO_DECODER_EXTENSION)* pExtensionData);
    ///Sets the target rectangle for the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    Enable = Specifies whether to apply the target rectangle.
    ///    pRect = A pointer to a RECT structure that specifies the target rectangle. If <i>Enable</i> is <b>FALSE</b>, this
    ///            parameter is ignored.
    void    VideoProcessorSetOutputTargetRect(ID3D11VideoProcessor pVideoProcessor, BOOL Enable, 
                                              const(RECT)* pRect);
    ///Sets the background color for the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    YCbCr = If <b>TRUE</b>, the color is specified as a YCbCr value. Otherwise, the color is specified as an RGB value.
    ///    pColor = A pointer to a D3D11_VIDEO_COLOR structure that specifies the background color.
    void    VideoProcessorSetOutputBackgroundColor(ID3D11VideoProcessor pVideoProcessor, BOOL YCbCr, 
                                                   const(D3D11_VIDEO_COLOR)* pColor);
    ///Sets the output color space for the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    pColorSpace = A pointer to a D3D11_VIDEO_PROCESSOR_COLOR_SPACE structure that specifies the color space.
    void    VideoProcessorSetOutputColorSpace(ID3D11VideoProcessor pVideoProcessor, 
                                              const(D3D11_VIDEO_PROCESSOR_COLOR_SPACE)* pColorSpace);
    ///Sets the alpha fill mode for data that the video processor writes to the render target.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    AlphaFillMode = The alpha fill mode, specified as a D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE value.
    ///    StreamIndex = The zero-based index of an input stream. This parameter is used if <i>AlphaFillMode</i> is
    ///                  <b>D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_SOURCE_STREAM</b>. Otherwise, the parameter is ignored.
    void    VideoProcessorSetOutputAlphaFillMode(ID3D11VideoProcessor pVideoProcessor, 
                                                 D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE AlphaFillMode, 
                                                 uint StreamIndex);
    ///Sets the amount of downsampling to perform on the output.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    Enable = If <b>TRUE</b>, downsampling is enabled. Otherwise, downsampling is disabled and the <b>Size</b> member is
    ///             ignored.
    ///    Size = The sampling size.
    void    VideoProcessorSetOutputConstriction(ID3D11VideoProcessor pVideoProcessor, BOOL Enable, SIZE Size);
    ///Specifies whether the video processor produces stereo video frames.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    Enable = If <b>TRUE</b>, stereo output is enabled. Otherwise, the video processor produces mono video frames.
    void    VideoProcessorSetOutputStereoMode(ID3D11VideoProcessor pVideoProcessor, BOOL Enable);
    ///Sets a driver-specific video processing state.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    pExtensionGuid = A pointer to a GUID that identifies the operation. The meaning of this GUID is defined by the graphics
    ///                     driver.
    ///    DataSize = The size of the <i>pData</i> buffer, in bytes.
    ///    pData = A pointer to a buffer that contains private state data. The method passes this buffer directly to the driver
    ///            without validation. It is the responsibility of the driver to validate the data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    int     VideoProcessorSetOutputExtension(ID3D11VideoProcessor pVideoProcessor, const(GUID)* pExtensionGuid, 
                                             uint DataSize, void* pData);
    ///Gets the current target rectangle for the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    Enabled = Receives the value <b>TRUE</b> if the target rectangle was explicitly set using the
    ///              ID3D11VideoContext::VideoProcessorSetOutputTargetRect method. Receives the value FALSE if the target
    ///              rectangle was disabled or was never set.
    ///    pRect = If <i>Enabled</i> receives the value <b>TRUE</b>, this parameter receives the target rectangle. Otherwise,
    ///            this parameter is ignored.
    void    VideoProcessorGetOutputTargetRect(ID3D11VideoProcessor pVideoProcessor, BOOL* Enabled, RECT* pRect);
    ///Gets the current background color for the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    pYCbCr = Receives the value <b>TRUE</b> if the background color is a YCbCr color, or <b>FALSE</b> if the background
    ///             color is an RGB color.
    ///    pColor = A pointer to a D3D11_VIDEO_COLOR structure. The method fills in the structure with the background color.
    void    VideoProcessorGetOutputBackgroundColor(ID3D11VideoProcessor pVideoProcessor, BOOL* pYCbCr, 
                                                   D3D11_VIDEO_COLOR* pColor);
    ///Gets the current output color space for the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    pColorSpace = A pointer to a D3D11_VIDEO_PROCESSOR_COLOR_SPACE structure. The method fills in the structure with the output
    ///                  color space.
    void    VideoProcessorGetOutputColorSpace(ID3D11VideoProcessor pVideoProcessor, 
                                              D3D11_VIDEO_PROCESSOR_COLOR_SPACE* pColorSpace);
    ///Gets the current alpha fill mode for the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    pAlphaFillMode = Receives the alpha fill mode, as a D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE value.
    ///    pStreamIndex = If the alpha fill mode is <b>D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_SOURCE_STREAM</b>, this parameter receives
    ///                   the zero-based index of an input stream. The input stream provides the alpha values for the alpha fill.
    void    VideoProcessorGetOutputAlphaFillMode(ID3D11VideoProcessor pVideoProcessor, 
                                                 D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE* pAlphaFillMode, 
                                                 uint* pStreamIndex);
    ///Gets the current level of downsampling that is performed by the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    pEnabled = Receives the value <b>TRUE</b> if downsampling was explicitly enabled using the
    ///               ID3D11VideoContext::VideoProcessorSetOutputConstriction method. Receives the value <b>FALSE</b> if the
    ///               downsampling was disabled or was never set.
    ///    pSize = If <i>Enabled</i> receives the value <b>TRUE</b>, this parameter receives the downsampling size. Otherwise,
    ///            this parameter is ignored.
    void    VideoProcessorGetOutputConstriction(ID3D11VideoProcessor pVideoProcessor, BOOL* pEnabled, SIZE* pSize);
    ///Queries whether the video processor produces stereo video frames.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    pEnabled = Receives the value <b>TRUE</b> if stereo output is enabled, or <b>FALSE</b> otherwise.
    void    VideoProcessorGetOutputStereoMode(ID3D11VideoProcessor pVideoProcessor, BOOL* pEnabled);
    ///Gets private state data from the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    pExtensionGuid = A pointer to a GUID that identifies the state. The meaning of this GUID is defined by the graphics driver.
    ///    DataSize = The size of the <i>pData</i> buffer, in bytes.
    ///    pData = A pointer to a buffer that receives the private state data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    int     VideoProcessorGetOutputExtension(ID3D11VideoProcessor pVideoProcessor, const(GUID)* pExtensionGuid, 
                                             uint DataSize, void* pData);
    ///Specifies whether an input stream on the video processor contains interlaced or progressive frames.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    FrameFormat = A D3D11_VIDEO_FRAME_FORMAT value that specifies the interlacing.
    void    VideoProcessorSetStreamFrameFormat(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                               D3D11_VIDEO_FRAME_FORMAT FrameFormat);
    ///Sets the color space for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    pColorSpace = A pointer to a D3D11_VIDEO_PROCESSOR_COLOR_SPACE structure that specifies the color space.
    void    VideoProcessorSetStreamColorSpace(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                              const(D3D11_VIDEO_PROCESSOR_COLOR_SPACE)* pColorSpace);
    ///Sets the rate at which the video processor produces output frames for an input stream.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    OutputRate = The output rate, specified as a D3D11_VIDEO_PROCESSOR_OUTPUT_RATE value.
    ///    RepeatFrame = Specifies how the driver performs frame-rate conversion, if required. <table> <tr> <th>Value</th>
    ///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TRUE"></a><a id="true"></a><dl> <dt><b>TRUE</b></dt> </dl>
    ///                  </td> <td width="60%"> Repeat frames. </td> </tr> <tr> <td width="40%"><a id="FALSE"></a><a
    ///                  id="false"></a><dl> <dt><b>FALSE</b></dt> </dl> </td> <td width="60%"> Interpolate frames. </td> </tr>
    ///                  </table>
    ///    pCustomRate = A pointer to a DXGI_RATIONAL structure. If <i>OutputRate</i> is
    ///                  <b>D3D11_VIDEO_PROCESSOR_OUTPUT_RATE_CUSTOM</b>, this parameter specifies the exact output rate. Otherwise,
    ///                  this parameter is ignored and can be <b>NULL</b>.
    void    VideoProcessorSetStreamOutputRate(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                              D3D11_VIDEO_PROCESSOR_OUTPUT_RATE OutputRate, BOOL RepeatFrame, 
                                              const(DXGI_RATIONAL)* pCustomRate);
    ///Sets the source rectangle for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    Enable = Specifies whether to apply the source rectangle.
    ///    pRect = A pointer to a RECT structure that specifies the source rectangle. If <i>Enable</i> is <b>FALSE</b>, this
    ///            parameter is ignored.
    void    VideoProcessorSetStreamSourceRect(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, BOOL Enable, 
                                              const(RECT)* pRect);
    ///Sets the destination rectangle for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    Enable = Specifies whether to apply the destination rectangle.
    ///    pRect = A pointer to a RECT structure that specifies the destination rectangle. If <i>Enable</i> is <b>FALSE</b>,
    ///            this parameter is ignored.
    void    VideoProcessorSetStreamDestRect(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, BOOL Enable, 
                                            const(RECT)* pRect);
    ///Sets the planar alpha for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    Enable = Specifies whether alpha blending is enabled.
    ///    Alpha = The planar alpha value. The value can range from 0.0 (transparent) to 1.0 (opaque). If <i>Enable</i> is
    ///            <b>FALSE</b>, this parameter is ignored.
    void    VideoProcessorSetStreamAlpha(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, BOOL Enable, 
                                         float Alpha);
    ///Sets the color-palette entries for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    Count = The number of elements in the <i>pEntries</i> array.
    ///    pEntries = A pointer to an array of palette entries. For RGB streams, the palette entries use the
    ///               <b>DXGI_FORMAT_B8G8R8A8</b> representation. For YCbCr streams, the palette entries use the
    ///               <b>DXGI_FORMAT_AYUV</b> representation. The caller allocates the array.
    void    VideoProcessorSetStreamPalette(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, uint Count, 
                                           const(uint)* pEntries);
    ///Sets the pixel aspect ratio for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    Enable = Specifies whether the <i>pSourceAspectRatio</i> and <i>pDestinationAspectRatio</i> parameters contain valid
    ///             values. Otherwise, the pixel aspect ratios are unspecified.
    ///    pSourceAspectRatio = A pointer to a DXGI_RATIONAL structure that contains the pixel aspect ratio of the source rectangle. If
    ///                         <i>Enable</i> is <b>FALSE</b>, this parameter can be <b>NULL</b>.
    ///    pDestinationAspectRatio = A pointer to a DXGI_RATIONAL structure that contains the pixel aspect ratio of the destination rectangle. If
    ///                              <i>Enable</i> is <b>FALSE</b>, this parameter can be <b>NULL</b>.
    void    VideoProcessorSetStreamPixelAspectRatio(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                                    BOOL Enable, const(DXGI_RATIONAL)* pSourceAspectRatio, 
                                                    const(DXGI_RATIONAL)* pDestinationAspectRatio);
    ///Sets the luma key for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    Enable = Specifies whether luma keying is enabled.
    ///    Lower = The lower bound for the luma key. The valid range is [0â€¦1]. If <i>Enable</i> is <b>FALSE</b>, this
    ///            parameter is ignored.
    ///    Upper = The upper bound for the luma key. The valid range is [0â€¦1]. If <i>Enable</i> is <b>FALSE</b>, this
    ///            parameter is ignored.
    void    VideoProcessorSetStreamLumaKey(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, BOOL Enable, 
                                           float Lower, float Upper);
    ///Enables or disables stereo 3D video for an input stream on the video processor. In addition, this method
    ///specifies the layout of the video frames in memory.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    Enable = Specifies whether stereo 3D is enabled for this stream. If the value is <b>FALSE</b>, the remaining
    ///             parameters of this method are ignored.
    ///    Format = Specifies the layout of the two stereo views in memory, as a D3D11_VIDEO_PROCESSOR_STEREO_FORMAT value.
    ///    LeftViewFrame0 = If <b>TRUE</b>, frame 0 contains the left view. Otherwise, frame 0 contains the right view. This parameter is
    ///                     ignored for the following stereo formats: <ul> <li><b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO </b></li>
    ///                     <li><b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO_OFFSET</b></li> </ul>
    ///    BaseViewFrame0 = If <b>TRUE</b>, frame 0 contains the base view. Otherwise, frame 1 contains the base view. This parameter is
    ///                     ignored for the following stereo formats: <ul> <li><b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO </b></li>
    ///                     <li><b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO_OFFSET</b></li> <li>When
    ///                     <b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_SEPARATE</b> is used and the application wants to convert the stereo
    ///                     data to mono, it can either:<ul> <li>Specify the base view as a mono input.</li> <li>Specify both resources
    ///                     and allow the driver to do the conversion from the base view. In this case,
    ///                     D3D11_VIDEO_PROCESSOR_STREAM.hInputSurface is considered frame 0 and
    ///                     <b>D3D11_VIDEO_PROCESSOR_STREAM.hInputSurfaceRight</b> is considered frame 1.</li> </ul> </li> </ul>
    ///    FlipMode = A flag from the D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE enumeration, specifying whether one of the views is
    ///               flipped.
    ///    MonoOffset = For <b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO_OFFSET</b> format, this parameter specifies how to generate
    ///                 the left and right views: <ul> <li>If <i>MonoOffset</i> is positive, the right view is shifted to the right
    ///                 by that many pixels, and the left view is shifted to the left by the same amount. </li> <li>If
    ///                 <i>MonoOffset</i> is negative, the right view is shifted to the left by that many pixels, and the left view
    ///                 is shifted to right by the same amount.</li> </ul> If <i>Format</i> is not
    ///                 <b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO_OFFSET</b>, this parameter must be zero.
    void    VideoProcessorSetStreamStereoFormat(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                                BOOL Enable, D3D11_VIDEO_PROCESSOR_STEREO_FORMAT Format, 
                                                BOOL LeftViewFrame0, BOOL BaseViewFrame0, 
                                                D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE FlipMode, int MonoOffset);
    ///Enables or disables automatic processing features on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    Enable = If <b>TRUE</b>, automatic processing features are enabled. If <b>FALSE</b>, the driver disables any extra
    ///             video processing that it might be performing.
    void    VideoProcessorSetStreamAutoProcessingMode(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                                      BOOL Enable);
    ///Enables or disables an image filter for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    Filter = The filter, specified as a D3D11_VIDEO_PROCESSOR_FILTER value. To query which filters the driver supports,
    ///             call ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps.
    ///    Enable = Specifies whether to enable the filter.
    ///    Level = The filter level. If <i>Enable</i> is <b>FALSE</b>, this parameter is ignored. To find the valid range of
    ///            levels for a specified filter, call ID3D11VideoProcessorEnumerator::GetVideoProcessorFilterRange.
    void    VideoProcessorSetStreamFilter(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                          D3D11_VIDEO_PROCESSOR_FILTER Filter, BOOL Enable, int Level);
    ///Sets a driver-specific state on a video processing stream.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    pExtensionGuid = A pointer to a GUID that identifies the operation. The meaning of this GUID is defined by the graphics
    ///                     driver.
    ///    DataSize = The size of the <i>pData</i> buffer, in bytes.
    ///    pData = A pointer to a buffer that contains private state data. The method passes this buffer directly to the driver
    ///            without validation. It is the responsibility of the driver to validate the data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    int     VideoProcessorSetStreamExtension(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                             const(GUID)* pExtensionGuid, uint DataSize, void* pData);
    ///Gets the format of an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    pFrameFormat = Receives a D3D11_VIDEO_FRAME_FORMAT value that specifies whether the stream contains interlaced or
    ///                   progressive frames.
    void    VideoProcessorGetStreamFrameFormat(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                               D3D11_VIDEO_FRAME_FORMAT* pFrameFormat);
    ///Gets the color space for an input stream of the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    pColorSpace = Receives a D3D11_VIDEO_PROCESSOR_COLOR_SPACE value that specifies the color space.
    void    VideoProcessorGetStreamColorSpace(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                              D3D11_VIDEO_PROCESSOR_COLOR_SPACE* pColorSpace);
    ///Gets the rate at which the video processor produces output frames for an input stream.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    pOutputRate = Receives a D3D11_VIDEO_PROCESSOR_OUTPUT_RATE value that specifies the output rate.
    ///    pRepeatFrame = Receives a Boolean value that specifies how the driver performs frame-rate conversion, if required. <table>
    ///                   <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TRUE"></a><a id="true"></a><dl>
    ///                   <dt><b>TRUE</b></dt> </dl> </td> <td width="60%"> Repeat frames. </td> </tr> <tr> <td width="40%"><a
    ///                   id="FALSE"></a><a id="false"></a><dl> <dt><b>FALSE</b></dt> </dl> </td> <td width="60%"> Interpolate frames.
    ///                   </td> </tr> </table>
    ///    pCustomRate = A pointer to a DXGI_RATIONAL structure. If the output rate is
    ///                  <b>D3D11_VIDEO_PROCESSOR_OUTPUT_RATE_CUSTOM</b>, the method fills in this structure with the exact output
    ///                  rate. Otherwise, this parameter is ignored.
    void    VideoProcessorGetStreamOutputRate(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                              D3D11_VIDEO_PROCESSOR_OUTPUT_RATE* pOutputRate, BOOL* pRepeatFrame, 
                                              DXGI_RATIONAL* pCustomRate);
    ///Gets the source rectangle for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    pEnabled = Receives the value <b>TRUE</b> if the source rectangle is enabled, or <b>FALSE</b> otherwise.
    ///    pRect = A pointer to a RECT structure that receives the source rectangle.
    void    VideoProcessorGetStreamSourceRect(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                              BOOL* pEnabled, RECT* pRect);
    ///Gets the destination rectangle for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    pEnabled = Receives the value <b>TRUE</b> if the destination rectangle is enabled, or <b>FALSE</b> otherwise.
    ///    pRect = A pointer to a RECT structure that receives the destination rectangle.
    void    VideoProcessorGetStreamDestRect(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, BOOL* pEnabled, 
                                            RECT* pRect);
    ///Gets the planar alpha for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    pEnabled = Receives the value <b>TRUE</b> if planar alpha is enabled, or <b>FALSE</b> otherwise.
    ///    pAlpha = Receives the planar alpha value. The value can range from 0.0 (transparent) to 1.0 (opaque).
    void    VideoProcessorGetStreamAlpha(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, BOOL* pEnabled, 
                                         float* pAlpha);
    ///Gets the color-palette entries for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    Count = The number of entries in the <i>pEntries</i> array.
    ///    pEntries = A pointer to a <b>UINT</b> array allocated by the caller. The method fills the array with the palette
    ///               entries. For RGB streams, the palette entries use the <b>DXGI_FORMAT_B8G8R8A8</b> representation. For YCbCr
    ///               streams, the palette entries use the <b>DXGI_FORMAT_AYUV</b> representation.
    void    VideoProcessorGetStreamPalette(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, uint Count, 
                                           uint* pEntries);
    ///Gets the pixel aspect ratio for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    pEnabled = Receives the value <b>TRUE</b> if the pixel aspect ratio is specified. Otherwise, receives the value
    ///               <b>FALSE</b>.
    ///    pSourceAspectRatio = A pointer to a DXGI_RATIONAL structure. If *<i>pEnabled</i> is <b>TRUE</b>, this parameter receives the pixel
    ///                         aspect ratio of the source rectangle.
    ///    pDestinationAspectRatio = A pointer to a DXGI_RATIONAL structure. If *<i>pEnabled</i> is <b>TRUE</b>, this parameter receives the pixel
    ///                              aspect ratio of the destination rectangle.
    void    VideoProcessorGetStreamPixelAspectRatio(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                                    BOOL* pEnabled, DXGI_RATIONAL* pSourceAspectRatio, 
                                                    DXGI_RATIONAL* pDestinationAspectRatio);
    ///Gets the luma key for an input stream of the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    pEnabled = Receives the value <b>TRUE</b> if luma keying is enabled, or <b>FALSE</b> otherwise.
    ///    pLower = Receives the lower bound for the luma key. The valid range is [0â€¦1].
    ///    pUpper = Receives the upper bound for the luma key. The valid range is [0â€¦1].
    void    VideoProcessorGetStreamLumaKey(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, BOOL* pEnabled, 
                                           float* pLower, float* pUpper);
    ///Gets the stereo 3D format for an input stream on the video processor
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    pEnable = Receives the value <b>TRUE</b> if stereo 3D is enabled for this stream, or <b>FALSE</b> otherwise. If the
    ///              value is <b>FALSE</b>, ignore the remaining parameters.
    ///    pFormat = Receives a D3D11_VIDEO_PROCESSOR_STEREO_FORMAT value that specifies the layout of the two stereo views in
    ///              memory.
    ///    pLeftViewFrame0 = Receives a Boolean value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                      id="TRUE"></a><a id="true"></a><dl> <dt><b>TRUE</b></dt> </dl> </td> <td width="60%"> Frame 0 contains the
    ///                      left view. </td> </tr> <tr> <td width="40%"><a id="FALSE"></a><a id="false"></a><dl> <dt><b>FALSE</b></dt>
    ///                      </dl> </td> <td width="60%"> Frame 0 contains the right view. </td> </tr> </table>
    ///    pBaseViewFrame0 = Receives a Boolean value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                      id="TRUE"></a><a id="true"></a><dl> <dt><b>TRUE</b></dt> </dl> </td> <td width="60%"> Frame 0 contains the
    ///                      base view. </td> </tr> <tr> <td width="40%"><a id="FALSE"></a><a id="false"></a><dl> <dt><b>FALSE</b></dt>
    ///                      </dl> </td> <td width="60%"> Frame 1 contains the base view. </td> </tr> </table>
    ///    pFlipMode = Receives a D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE value. This value specifies whether one of the views is
    ///                flipped.
    ///    MonoOffset = Receives the pixel offset used for <b>D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO_OFFSET</b> format. This
    ///                 parameter is ignored for other stereo formats.
    void    VideoProcessorGetStreamStereoFormat(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                                BOOL* pEnable, D3D11_VIDEO_PROCESSOR_STEREO_FORMAT* pFormat, 
                                                BOOL* pLeftViewFrame0, BOOL* pBaseViewFrame0, 
                                                D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE* pFlipMode, int* MonoOffset);
    ///Queries whether automatic processing features of the video processor are enabled.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    pEnabled = Receives the value <b>TRUE</b> if automatic processing features are enabled, or <b>FALSE</b> otherwise.
    void    VideoProcessorGetStreamAutoProcessingMode(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                                      BOOL* pEnabled);
    ///Gets the image filter settings for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    Filter = The filter to query, specified as a D3D11_VIDEO_PROCESSOR_FILTER value.
    ///    pEnabled = Receives the value <b>TRUE</b> if the image filter is enabled, or <b>FALSE</b> otherwise.
    ///    pLevel = Receives the filter level.
    void    VideoProcessorGetStreamFilter(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                          D3D11_VIDEO_PROCESSOR_FILTER Filter, BOOL* pEnabled, int* pLevel);
    ///Gets a driver-specific state for a video processing stream.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    pExtensionGuid = A pointer to a GUID that identifies the state. The meaning of this GUID is defined by the graphics driver.
    ///    DataSize = The size of the <i>pData</i> buffer, in bytes.
    ///    pData = A pointer to a buffer that receives the private state data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    int     VideoProcessorGetStreamExtension(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                             const(GUID)* pExtensionGuid, uint DataSize, void* pData);
    ///Performs a video processing operation on one or more input samples, and writes the result to a Direct3D surface.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call the
    ///                      ID3D11VideoDevice::CreateVideoProcessor method.
    ///    pView = A pointer to the ID3D11VideoProcessorOutputView interface for the output surface. The output of the video
    ///            processing operation will be written to this surface.
    ///    OutputFrame = The frame number of the output video frame, indexed from zero.
    ///    StreamCount = The number of input streams to process.
    ///    pStreams = A pointer to an array of D3D11_VIDEO_PROCESSOR_STREAM structures that contain information about the input
    ///               streams. The caller allocates the array and fills in each structure. The number of elements in the array is
    ///               given in the *StreamCount* parameter.
    ///Returns:
    ///    If this method succeeds, it returns **S_OK**. Otherwise, it returns an **HRESULT** error code.
    ///    
    HRESULT VideoProcessorBlt(ID3D11VideoProcessor pVideoProcessor, ID3D11VideoProcessorOutputView pView, 
                              uint OutputFrame, uint StreamCount, const(D3D11_VIDEO_PROCESSOR_STREAM)* pStreams);
    ///Establishes the session key for a cryptographic session.
    ///Params:
    ///    pCryptoSession = A pointer to the ID3D11CryptoSession interface of the cryptographic session.
    ///    DataSize = The size of the <i>pData</i> byte array, in bytes.
    ///    pData = A pointer to a byte array that contains the encrypted session key.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT NegotiateCryptoSessionKeyExchange(ID3D11CryptoSession pCryptoSession, uint DataSize, void* pData);
    ///Reads encrypted data from a protected surface.
    ///Params:
    ///    pCryptoSession = A pointer to the ID3D11CryptoSession interface of the cryptographic session.
    ///    pSrcSurface = A pointer to the ID3D11Texture2D interface of the protected surface.
    ///    pDstSurface = A pointer to the ID3D11Texture2D interface of the surface that receives the encrypted data.
    ///    IVSize = The size of the <i>pIV</i> buffer, in bytes.
    ///    pIV = A pointer to a buffer that receives the initialization vector (IV). The caller allocates this buffer, but the
    ///          driver generates the IV. For 128-bit AES-CTR encryption, <i>pIV</i> points to a D3D11_AES_CTR_IV structure.
    ///          When the driver generates the first IV, it initializes the structure to a random number. For each subsequent
    ///          IV, the driver simply increments the <b>IV</b> member of the structure, ensuring that the value always
    ///          increases. The application can validate that the same IV is never used more than once with the same key pair.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    void    EncryptionBlt(ID3D11CryptoSession pCryptoSession, ID3D11Texture2D pSrcSurface, 
                          ID3D11Texture2D pDstSurface, uint IVSize, void* pIV);
    ///Writes encrypted data to a protected surface.
    ///Params:
    ///    pCryptoSession = A pointer to the ID3D11CryptoSession interface.
    ///    pSrcSurface = A pointer to the surface that contains the source data.
    ///    pDstSurface = A pointer to the protected surface where the encrypted data is written.
    ///    pEncryptedBlockInfo = A pointer to a D3D11_ENCRYPTED_BLOCK_INFO structure, or <b>NULL</b>. If the driver supports partially
    ///                          encrypted buffers, <i>pEncryptedBlockInfo</i> indicates which portions of the buffer are encrypted. If the
    ///                          entire surface is encrypted, set this parameter to <b>NULL</b>. To check whether the driver supports
    ///                          partially encrypted buffers, call ID3D11VideoDevice::GetContentProtectionCaps and check for the
    ///                          <b>D3D11_CONTENT_PROTECTION_CAPS_PARTIAL_DECRYPTION </b> capabilities flag. If the driver does not support
    ///                          partially encrypted buffers, set this parameter to <b>NULL</b>.
    ///    ContentKeySize = The size of the encrypted content key, in bytes.
    ///    pContentKey = A pointer to a buffer that contains a content encryption key, or <b>NULL</b>. To query whether the driver
    ///                  supports the use of content keys, call ID3D11VideoDevice::GetContentProtectionCaps and check for the
    ///                  <b>D3D11_CONTENT_PROTECTION_CAPS_CONTENT_KEY</b> capabilities flag. If the driver supports content keys, use
    ///                  the content key to encrypt the surface. Encrypt the content key using the session key, and place the
    ///                  resulting cipher text in <i>pContentKey</i>. If the driver does not support content keys, use the session key
    ///                  to encrypt the surface and set <i>pContentKey</i> to <b>NULL</b>.
    ///    IVSize = The size of the <i>pIV</i> buffer, in bytes.
    ///    pIV = A pointer to a buffer that contains the initialization vector (IV). For 128-bit AES-CTR encryption,
    ///          <i>pIV</i> points to a D3D11_AES_CTR_IV structure. The caller allocates the structure and generates the IV.
    ///          When you generate the first IV, initialize the structure to a random number. For each subsequent IV, simply
    ///          increment the <b>IV</b> member of the structure, ensuring that the value always increases. This procedure
    ///          enables the driver to validate that the same IV is never used more than once with the same key pair. For
    ///          other encryption types, a different structure might be used, or the encryption might not use an IV.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    void    DecryptionBlt(ID3D11CryptoSession pCryptoSession, ID3D11Texture2D pSrcSurface, 
                          ID3D11Texture2D pDstSurface, D3D11_ENCRYPTED_BLOCK_INFO* pEncryptedBlockInfo, 
                          uint ContentKeySize, const(void)* pContentKey, uint IVSize, void* pIV);
    ///Gets a random number that can be used to refresh the session key.
    ///Params:
    ///    pCryptoSession = A pointer to the ID3D11CryptoSession interface.
    ///    RandomNumberSize = The size of the <i>pRandomNumber</i> array, in bytes. The size should match the size of the session key.
    ///    pRandomNumber = A pointer to a byte array that receives a random number.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    void    StartSessionKeyRefresh(ID3D11CryptoSession pCryptoSession, uint RandomNumberSize, void* pRandomNumber);
    ///Switches to a new session key.
    ///Params:
    ///    pCryptoSession = A pointer to the ID3D11CryptoSession interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    void    FinishSessionKeyRefresh(ID3D11CryptoSession pCryptoSession);
    ///Gets the cryptographic key to decrypt the data returned by the ID3D11VideoContext::EncryptionBlt method.
    ///Params:
    ///    pCryptoSession = A pointer to the ID3D11CryptoSession interface.
    ///    KeySize = The size of the <i>pReadbackKey</i> array, in bytes. The size should match the size of the session key.
    ///    pReadbackKey = A pointer to a byte array that receives the key. The key is encrypted using the session key.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetEncryptionBltKey(ID3D11CryptoSession pCryptoSession, uint KeySize, void* pReadbackKey);
    ///Establishes a session key for an authenticated channel.
    ///Params:
    ///    pChannel = A pointer to the ID3D11AuthenticatedChannel interface. This method will fail if the channel type is
    ///               D3D11_AUTHENTICATED_CHANNEL_D3D11, because the Direct3D11 channel does not support authentication.
    ///    DataSize = The size of the data in the <i>pData</i> array, in bytes.
    ///    pData = A pointer to a byte array that contains the encrypted session key. The buffer must contain 256 bytes of data,
    ///            encrypted using RSA Encryption Scheme - Optimal Asymmetric Encryption Padding (RSAES-OAEP).
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT NegotiateAuthenticatedChannelKeyExchange(ID3D11AuthenticatedChannel pChannel, uint DataSize, 
                                                     void* pData);
    ///Sends a query to an authenticated channel.
    ///Params:
    ///    pChannel = A pointer to the ID3D11AuthenticatedChannel interface.
    ///    InputSize = The size of the <i>pInput</i> array, in bytes.
    ///    pInput = A pointer to a byte array that contains input data for the query. This array always starts with a
    ///             D3D11_AUTHENTICATED_QUERY_INPUT structure. The <b>QueryType</b> member of the structure specifies the query
    ///             and defines the meaning of the rest of the array.
    ///    OutputSize = The size of the <i>pOutput</i> array, in bytes.
    ///    pOutput = A pointer to a byte array that receives the result of the query. This array always starts with a
    ///              D3D11_AUTHENTICATED_QUERY_OUTPUT structure. The meaning of the rest of the array depends on the query.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT QueryAuthenticatedChannel(ID3D11AuthenticatedChannel pChannel, uint InputSize, const(void)* pInput, 
                                      uint OutputSize, void* pOutput);
    ///Sends a configuration command to an authenticated channel.
    ///Params:
    ///    pChannel = A pointer to the ID3D11AuthenticatedChannel interface.
    ///    InputSize = The size of the <i>pInput</i> array, in bytes.
    ///    pInput = A pointer to a byte array that contains input data for the command. This buffer always starts with a
    ///             D3D11_AUTHENTICATED_CONFIGURE_INPUT structure. The <b>ConfigureType</b> member of the structure specifies the
    ///             command and defines the meaning of the rest of the buffer.
    ///    pOutput = A pointer to a D3D11_AUTHENTICATED_CONFIGURE_OUTPUT structure that receives the response to the command.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ConfigureAuthenticatedChannel(ID3D11AuthenticatedChannel pChannel, uint InputSize, const(void)* pInput, 
                                          D3D11_AUTHENTICATED_CONFIGURE_OUTPUT* pOutput);
    ///Sets the stream rotation for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    Enable = Specifies if the stream is to be rotated in a clockwise orientation.
    ///    Rotation = Specifies the rotation of the stream.
    void    VideoProcessorSetStreamRotation(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, BOOL Enable, 
                                            D3D11_VIDEO_PROCESSOR_ROTATION Rotation);
    ///Gets the stream rotation for an input stream on the video processor.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface. To get this pointer, call
    ///                      ID3D11VideoDevice::CreateVideoProcessor.
    ///    StreamIndex = The zero-based index of the input stream. To get the maximum number of streams, call
    ///                  ID3D11VideoProcessorEnumerator::GetVideoProcessorCaps and check the <b>MaxStreamStates</b> structure member.
    ///    pEnable = Specifies if the stream is rotated.
    ///    pRotation = Specifies the rotation of the stream in a clockwise orientation.
    void    VideoProcessorGetStreamRotation(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, BOOL* pEnable, 
                                            D3D11_VIDEO_PROCESSOR_ROTATION* pRotation);
}

///Provides the video decoding and video processing capabilities of a Microsoft Direct3D 11 device.
@GUID("10EC4D5B-975A-4689-B9E4-D0AAC30FE333")
interface ID3D11VideoDevice : IUnknown
{
    ///Creates a video decoder device for Microsoft Direct3D 11.
    ///Params:
    ///    pVideoDesc = A pointer to a D3D11_VIDEO_DECODER_DESC structure that describes the video stream and the decoder profile.
    ///    pConfig = A pointer to a D3D11_VIDEO_DECODER_CONFIG structure that specifies the decoder configuration.
    ///    ppDecoder = Receives a pointer to the ID3D11VideoDecoder interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateVideoDecoder(const(D3D11_VIDEO_DECODER_DESC)* pVideoDesc, 
                               const(D3D11_VIDEO_DECODER_CONFIG)* pConfig, ID3D11VideoDecoder* ppDecoder);
    ///Creates a video processor device for Microsoft Direct3D 11.
    ///Params:
    ///    pEnum = A pointer to the ID3D11VideoProcessorEnumerator interface. To get this pointer, call
    ///            ID3D11VideoDevice::CreateVideoProcessorEnumerator.
    ///    RateConversionIndex = Specifies the frame-rate conversion capabilities for the video processor. The value is a zero-based index
    ///                          that corresponds to the <i>TypeIndex</i> parameter of the
    ///                          ID3D11VideoProcessorEnumerator::GetVideoProcessorRateConversionCaps method.
    ///    ppVideoProcessor = Receives a pointer to the ID3D11VideoProcessor interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateVideoProcessor(ID3D11VideoProcessorEnumerator pEnum, uint RateConversionIndex, 
                                 ID3D11VideoProcessor* ppVideoProcessor);
    ///Creates a channel to communicate with the Microsoft Direct3D device or the graphics driver. The channel can be
    ///used to send commands and queries for content protection.
    ///Params:
    ///    ChannelType = Specifies the type of channel, as a member of the D3D11_AUTHENTICATED_CHANNEL_TYPE enumeration.
    ///    ppAuthenticatedChannel = Receives a pointer to the ID3D11AuthenticatedChannel interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateAuthenticatedChannel(D3D11_AUTHENTICATED_CHANNEL_TYPE ChannelType, 
                                       ID3D11AuthenticatedChannel* ppAuthenticatedChannel);
    ///Creates a cryptographic session to encrypt video content that is sent to the graphics driver.
    ///Params:
    ///    pCryptoType = A pointer to a GUID that specifies the type of encryption to use. The following GUIDs are defined. <table>
    ///                  <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="D3D11_CRYPTO_TYPE_AES128_CTR"></a><a
    ///                  id="d3d11_crypto_type_aes128_ctr"></a><dl> <dt><b>D3D11_CRYPTO_TYPE_AES128_CTR</b></dt> </dl> </td> <td
    ///                  width="60%"> 128-bit Advanced Encryption Standard CTR mode (AES-CTR) block cipher. </td> </tr> </table>
    ///    pDecoderProfile = A pointer to a GUID that specifies the decoding profile. For a list of possible values, see
    ///                      ID3D11VideoDevice::GetVideoDecoderProfile. If decoding will not be used, set this parameter to <b>NULL</b>.
    ///    pKeyExchangeType = A pointer to a GUID that specifies the type of key exchange. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///                       </tr> <tr> <td width="40%"><a id="D3D11_KEY_EXCHANGE_RSAES_OAEP"></a><a
    ///                       id="d3d11_key_exchange_rsaes_oaep"></a><dl> <dt><b>D3D11_KEY_EXCHANGE_RSAES_OAEP</b></dt> </dl> </td> <td
    ///                       width="60%"> The caller will create the session key, encrypt it with RSA Encryption Scheme - Optimal
    ///                       Asymmetric Encryption Padding (RSAES-OAEP) by using the driver's public key, and pass the session key to the
    ///                       driver. </td> </tr> </table>
    ///    ppCryptoSession = Receives a pointer to the ID3D11CryptoSession interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateCryptoSession(const(GUID)* pCryptoType, const(GUID)* pDecoderProfile, 
                                const(GUID)* pKeyExchangeType, ID3D11CryptoSession* ppCryptoSession);
    ///Creates a resource view for a video decoder, describing the output sample for the decoding operation.
    ///Params:
    ///    pResource = A pointer to the ID3D11Resource interface of the decoder surface. The resource must be created with the
    ///                <b>D3D11_BIND_DECODER</b> flag. See D3D11_BIND_FLAG.
    ///    pDesc = A pointer to a D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC structure that describes the view.
    ///    ppVDOVView = Receives a pointer to the ID3D11VideoDecoderOutputView interface. The caller must release the interface. If
    ///                 this parameter is <b>NULL</b>, the method checks whether the view is supported, but does not create the view.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateVideoDecoderOutputView(ID3D11Resource pResource, 
                                         const(D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC)* pDesc, 
                                         ID3D11VideoDecoderOutputView* ppVDOVView);
    ///Creates a resource view for a video processor, describing the input sample for the video processing operation.
    ///Params:
    ///    pResource = A pointer to the ID3D11Resource interface of the input surface.
    ///    pEnum = A pointer to the ID3D11VideoProcessorEnumerator interface that specifies the video processor. To get this
    ///            pointer, call ID3D11VideoDevice::CreateVideoProcessorEnumerator.
    ///    pDesc = A pointer to a D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC structure that describes the view.
    ///    ppVPIView = Receives a pointer to the ID3D11VideoProcessorInputView interface. The caller must release the resource. If
    ///                this parameter is <b>NULL</b>, the method checks whether the view is supported, but does not create the view.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateVideoProcessorInputView(ID3D11Resource pResource, ID3D11VideoProcessorEnumerator pEnum, 
                                          const(D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC)* pDesc, 
                                          ID3D11VideoProcessorInputView* ppVPIView);
    ///Creates a resource view for a video processor, describing the output sample for the video processing operation.
    ///Params:
    ///    pResource = A pointer to the ID3D11Resource interface of the output surface. The resource must be created with the
    ///                <b>D3D11_BIND_RENDER_TARGET</b> flag. See D3D11_BIND_FLAG.
    ///    pEnum = A pointer to the ID3D11VideoProcessorEnumerator interface that specifies the video processor. To get this
    ///            pointer, call ID3D11VideoDevice::CreateVideoProcessorEnumerator.
    ///    pDesc = A pointer to a D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC structure that describes the view.
    ///    ppVPOView = Receives a pointer to the ID3D11VideoProcessorOutputView interface. The caller must release the resource. If
    ///                this parameter is <b>NULL</b>, the method checks whether the view is supported, but does not create the view.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateVideoProcessorOutputView(ID3D11Resource pResource, ID3D11VideoProcessorEnumerator pEnum, 
                                           const(D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC)* pDesc, 
                                           ID3D11VideoProcessorOutputView* ppVPOView);
    ///Enumerates the video processor capabilities of the driver.
    ///Params:
    ///    pDesc = A pointer to a D3D11_VIDEO_PROCESSOR_CONTENT_DESC structure that describes the video content.
    ///    ppEnum = Receives a pointer to the ID3D11VideoProcessorEnumerator interface. The caller must release the interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateVideoProcessorEnumerator(const(D3D11_VIDEO_PROCESSOR_CONTENT_DESC)* pDesc, 
                                           ID3D11VideoProcessorEnumerator* ppEnum);
    ///Gets the number of profiles that are supported by the driver.
    ///Returns:
    ///    Returns the number of profiles.
    ///    
    uint    GetVideoDecoderProfileCount();
    ///Gets a profile that is supported by the driver.
    ///Params:
    ///    Index = The zero-based index of the profile. To get the number of profiles that the driver supports, call
    ///            ID3D11VideoDevice::GetVideoDecoderProfileCount.
    ///    pDecoderProfile = Receives a GUID that identifies the profile.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoDecoderProfile(uint Index, GUID* pDecoderProfile);
    ///Given aprofile, checks whether the driver supports a specified output format.
    ///Params:
    ///    pDecoderProfile = A pointer to a GUID that identifies the profile. To get the list of supported profiles, call
    ///                      ID3D11VideoDevice::GetVideoDecoderProfile.
    ///    Format = A DXGI_FORMAT value that specifies the output format. Typical values include <b>DXGI_FORMAT_NV12</b> and
    ///             <b>DXGI_FORMAT_420_OPAQUE</b>.
    ///    pSupported = Receives the value <b>TRUE</b> if the format is supported, or <b>FALSE</b> otherwise.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CheckVideoDecoderFormat(const(GUID)* pDecoderProfile, DXGI_FORMAT Format, BOOL* pSupported);
    ///Gets the number of decoder configurations that the driver supports for a specified video description.
    ///Params:
    ///    pDesc = A pointer to a D3D11_VIDEO_DECODER_DESC structure that describes the video stream.
    ///    pCount = Receives the number of decoder configurations.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoDecoderConfigCount(const(D3D11_VIDEO_DECODER_DESC)* pDesc, uint* pCount);
    ///Gets a decoder configuration that is supported by the driver.
    ///Params:
    ///    pDesc = A pointer to a D3D11_VIDEO_DECODER_DESC structure that describes the video stream.
    ///    Index = The zero-based index of the decoder configuration. To get the number of configurations that the driver
    ///            supports, call ID3D11VideoDevice::GetVideoDecoderConfigCount.
    ///    pConfig = A pointer to a D3D11_VIDEO_DECODER_CONFIG structure. The method fills in the structure with the decoder
    ///              configuration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetVideoDecoderConfig(const(D3D11_VIDEO_DECODER_DESC)* pDesc, uint Index, 
                                  D3D11_VIDEO_DECODER_CONFIG* pConfig);
    ///Queries the driver for its content protection capabilities.
    ///Params:
    ///    pCryptoType = A pointer to a GUID that specifies the type of encryption to be used. The following GUIDs are defined.
    ///                  <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                  id="D3D11_CRYPTO_TYPE_AES128_CTR"></a><a id="d3d11_crypto_type_aes128_ctr"></a><dl>
    ///                  <dt><b>D3D11_CRYPTO_TYPE_AES128_CTR</b></dt> </dl> </td> <td width="60%"> 128-bit Advanced Encryption
    ///                  Standard CTR mode (AES-CTR) block cipher. </td> </tr> </table> If no encryption will be used, set this
    ///                  parameter to <b>NULL</b>.
    ///    pDecoderProfile = A pointer to a GUID that specifies the decoding profile. To get profiles that the driver supports, call
    ///                      ID3D11VideoDevice::GetVideoDecoderProfile. If decoding will not be used, set this parameter to <b>NULL</b>.
    ///                      The driver might disallow some combinations of encryption type and profile.
    ///    pCaps = A pointer to a D3D11_VIDEO_CONTENT_PROTECTION_CAPS structure. The method fills in this structure with the
    ///            driver's content protection capabilities.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetContentProtectionCaps(const(GUID)* pCryptoType, const(GUID)* pDecoderProfile, 
                                     D3D11_VIDEO_CONTENT_PROTECTION_CAPS* pCaps);
    ///Gets a cryptographic key-exchange mechanism that is supported by the driver.
    ///Params:
    ///    pCryptoType = A pointer to a GUID that specifies the type of encryption to be used. The following GUIDs are defined.
    ///                  <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                  id="D3D11_CRYPTO_TYPE_AES128_CTR"></a><a id="d3d11_crypto_type_aes128_ctr"></a><dl>
    ///                  <dt><b>D3D11_CRYPTO_TYPE_AES128_CTR</b></dt> </dl> </td> <td width="60%"> 128-bit Advanced Encryption
    ///                  Standard CTR mode (AES-CTR) block cipher. </td> </tr> </table>
    ///    pDecoderProfile = A pointer to a GUID that specifies the decoding profile. To get profiles that the driver supports, call
    ///                      ID3D11VideoDevice::GetVideoDecoderProfile. If decoding will not be used, set this parameter to <b>NULL</b>.
    ///    Index = The zero-based index of the key-exchange type. The driver reports the number of types in the
    ///            <b>KeyExchangeTypeCount</b> member of the D3D11_VIDEO_CONTENT_PROTECTION_CAPS structure.
    ///    pKeyExchangeType = Receives a GUID that identifies the type of key exchange.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CheckCryptoKeyExchange(const(GUID)* pCryptoType, const(GUID)* pDecoderProfile, uint Index, 
                                   GUID* pKeyExchangeType);
    ///Sets private data on the video device and associates that data with a GUID.
    ///Params:
    ///    guid = The GUID associated with the data.
    ///    DataSize = The size of the data, in bytes.
    ///    pData = A pointer to the data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPrivateData(const(GUID)* guid, uint DataSize, const(void)* pData);
    ///Sets a private IUnknown pointer on the video device and associates that pointer with a GUID.
    ///Params:
    ///    guid = The GUID associated with the pointer.
    ///    pData = A pointer to the IUnknown interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetPrivateDataInterface(const(GUID)* guid, const(IUnknown) pData);
}

///Provides the video functionality of a Microsoft Direct3D 11 device.
@GUID("A7F026DA-A5F8-4487-A564-15E34357651E")
interface ID3D11VideoContext1 : ID3D11VideoContext
{
    ///Submits one or more buffers for decoding.
    ///Params:
    ///    pDecoder = Type: <b>ID3D11VideoDecoder*</b> A pointer to the ID3D11VideoDecoder interface. To get this pointer, call the
    ///               ID3D11VideoDevice::CreateVideoDecoder method.
    ///    NumBuffers = Type: <b>UINT</b> The number of buffers submitted for decoding.
    ///    pBufferDesc = Type: <b>const D3D11_VIDEO_DECODER_BUFFER_DESC1*</b> A pointer to an array of
    ///                  D3D11_VIDEO_DECODER_BUFFER_DESC1 structures. The <i>NumBuffers</i> parameter specifies the number of elements
    ///                  in the array. Each element in the array describes a compressed buffer for decoding.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
    ///    
    HRESULT SubmitDecoderBuffers1(ID3D11VideoDecoder pDecoder, uint NumBuffers, 
                                  const(D3D11_VIDEO_DECODER_BUFFER_DESC1)* pBufferDesc);
    ///Allows the driver to return IHV specific information used when initializing the new hardware key.
    ///Params:
    ///    pCryptoSession = Type: <b>ID3D11CryptoSession*</b> A pointer to the ID3D11CryptoSession interface. To get this pointer, call
    ///                     ID3D11VideoDevice1::CreateCryptoSession.
    ///    PrivateInputSize = Type: <b>UINT</b> The size of the memory referenced by the <i>pPrivateInputData</i> parameter.
    ///    pPrivatInputData = Type: <b>const void*</b> The private input data. The contents of this parameter is defined by the
    ///                       implementation of the secure execution environment. It may contain data about the license or about the stream
    ///                       properties.
    ///    pPrivateOutputData = Type: <b>UINT64*</b> A pointer to the private output data. The return data is defined by the implementation
    ///                         of the secure execution environment. It may contain graphics-specific data to be associated with the
    ///                         underlying hardware key.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns one of the following error codes. <table> <tr> <td>S_OK</td> <td>The
    ///    operation completed successfully.</td> </tr> <tr> <td>E_OUTOFMEMORY</td> <td>There is insufficient memory to
    ///    complete the operation.</td> </tr> </table>
    ///    
    HRESULT GetDataForNewHardwareKey(ID3D11CryptoSession pCryptoSession, uint PrivateInputSize, 
                                     const(void)* pPrivatInputData, ulong* pPrivateOutputData);
    ///Checks the status of a crypto session.
    ///Params:
    ///    pCryptoSession = Type: <b>ID3D11CryptoSession*</b> Specifies a ID3D11CryptoSession for which status is checked.
    ///    pStatus = Type: <b>D3D11_CRYPTO_SESSION_STATUS*</b> A D3D11_CRYPTO_SESSION_STATUS that is populated with the crypto
    ///              session status upon completion.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns one of the following error codes. <table> <tr> <td>S_OK</td> <td>The
    ///    operation completed successfully.</td> </tr> <tr> <td>E_INVALIDARG</td> <td>An invalid parameter was passed
    ///    or this function was called using an invalid calling pattern.</td> </tr> <tr> <td>E_OUTOFMEMORY</td>
    ///    <td>There is insufficient memory to complete the operation.</td> </tr> </table>
    ///    
    HRESULT CheckCryptoSessionStatus(ID3D11CryptoSession pCryptoSession, D3D11_CRYPTO_SESSION_STATUS* pStatus);
    ///Indicates that decoder downsampling will be used and that the driver should allocate the appropriate reference
    ///frames.
    ///Params:
    ///    pDecoder = Type: <b>ID3D11VideoDecoder*</b> A pointer to the ID3D11VideoDecoder interface.
    ///    InputColorSpace = Type: <b>DXGI_COLOR_SPACE_TYPE</b> The color space information of the reference frame data.
    ///    pOutputDesc = Type: <b>const D3D11_VIDEO_SAMPLE_DESC*</b> The resolution, format, and colorspace of the output/display
    ///                  frames. This is the destination resolution and format of the downsample operation.
    ///    ReferenceFrameCount = Type: <b>UINT</b> The number of reference frames to be used in the operation.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns one of the following error codes. <table> <tr> <td>S_OK</td> <td>The
    ///    operation completed successfully.</td> </tr> <tr> <td>E_INVALIDARG</td> <td>An invalid parameter was passed
    ///    or this function was called using an invalid calling pattern.</td> </tr> <tr> <td>E_OUTOFMEMORY</td>
    ///    <td>There is insufficient memory to complete the operation.</td> </tr> </table>
    ///    
    HRESULT DecoderEnableDownsampling(ID3D11VideoDecoder pDecoder, DXGI_COLOR_SPACE_TYPE InputColorSpace, 
                                      const(D3D11_VIDEO_SAMPLE_DESC)* pOutputDesc, uint ReferenceFrameCount);
    ///Updates the decoder downsampling parameters.
    ///Params:
    ///    pDecoder = Type: <b>ID3D11VideoDecoder*</b> A pointer to the ID3D11VideoDecoder interface.
    ///    pOutputDesc = Type: <b>const D3D11_VIDEO_SAMPLE_DESC*</b> The resolution, format, and colorspace of the output/display
    ///                  frames. This is the destination resolution and format of the downsample operation.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns one of the following error codes. <table> <tr> <td>S_OK</td> <td>The
    ///    operation completed successfully.</td> </tr> <tr> <td>E_INVALIDARG</td> <td>An invalid parameter was passed
    ///    or this function was called using an invalid calling pattern.</td> </tr> <tr> <td>E_OUTOFMEMORY</td>
    ///    <td>There is insufficient memory to complete the operation.</td> </tr> </table>
    ///    
    HRESULT DecoderUpdateDownsampling(ID3D11VideoDecoder pDecoder, const(D3D11_VIDEO_SAMPLE_DESC)* pOutputDesc);
    ///Sets the color space information for the video processor output surface.
    ///Params:
    ///    pVideoProcessor = Type: <b>ID3D11VideoProcessor*</b> A pointer to the ID3D11VideoProcessor interface.
    ///    ColorSpace = Type: <b>DXGI_COLOR_SPACE_TYPE</b> A DXGI_COLOR_SPACE_TYPE value that specifies the colorspace for the video
    ///                 processor output surface.
    void    VideoProcessorSetOutputColorSpace1(ID3D11VideoProcessor pVideoProcessor, 
                                               DXGI_COLOR_SPACE_TYPE ColorSpace);
    ///Sets a value indicating whether the output surface from a call to ID3D11VideoContext::VideoProcessorBlt will be
    ///read by Direct3D shaders.
    ///Params:
    ///    pVideoProcessor = Type: <b>ID3D11VideoProcessor*</b> A pointer to the ID3D11VideoProcessor interface.
    ///    ShaderUsage = Type: <b>BOOL</b> True if the surface rendered using ID3D11VideoContext::VideoProcessorBlt will be read by
    ///                  Direct3D shaders; otherwise, false. This may be set to false when multi-plane overlay hardware is supported.
    void    VideoProcessorSetOutputShaderUsage(ID3D11VideoProcessor pVideoProcessor, BOOL ShaderUsage);
    ///Gets the color space information for the video processor output surface.
    ///Params:
    ///    pVideoProcessor = Type: <b>ID3D11VideoProcessor*</b> A pointer to the ID3D11VideoProcessor interface.
    ///    pColorSpace = Type: <b>DXGI_COLOR_SPACE_TYPE*</b> A pointer to a DXGI_COLOR_SPACE_TYPE value that indicates the colorspace
    ///                  for the video processor output surface.
    void    VideoProcessorGetOutputColorSpace1(ID3D11VideoProcessor pVideoProcessor, 
                                               DXGI_COLOR_SPACE_TYPE* pColorSpace);
    ///Gets a value indicating whether the output surface from a call to ID3D11VideoContext::VideoProcessorBlt can be
    ///read by Direct3D shaders.
    ///Params:
    ///    pVideoProcessor = Type: <b>ID3D11VideoProcessor*</b> A pointer to the ID3D11VideoProcessor interface.
    ///    pShaderUsage = Type: <b>BOOL*</b> A pointer to a boolean value indicating if the output surface can be read by Direct3D
    ///                   shaders. True if the surface rendered using ID3D11VideoContext::VideoProcessorBlt can be read by Direct3D
    ///                   shaders; otherwise, false.
    void    VideoProcessorGetOutputShaderUsage(ID3D11VideoProcessor pVideoProcessor, BOOL* pShaderUsage);
    ///Sets the color space information for the video processor input stream.
    ///Params:
    ///    pVideoProcessor = Type: <b>ID3D11VideoProcessor*</b> A pointer to the ID3D11VideoProcessor interface.
    ///    StreamIndex = Type: <b>UINT</b> An index identifying the input stream.
    ///    ColorSpace = Type: <b>DXGI_COLOR_SPACE_TYPE</b> A DXGI_COLOR_SPACE_TYPE value that specifies the colorspace for the video
    ///                 processor input stream.
    void    VideoProcessorSetStreamColorSpace1(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                               DXGI_COLOR_SPACE_TYPE ColorSpace);
    ///Specifies whether the video processor input stream should be flipped vertically or horizontally.
    ///Params:
    ///    pVideoProcessor = Type: <b>ID3D11VideoProcessor*</b> A pointer to the ID3D11VideoProcessor interface.
    ///    StreamIndex = Type: <b>UINT</b> An index identifying the input stream.
    ///    Enable = Type: <b>BOOL</b> True if mirroring should be enabled; otherwise, false.
    ///    FlipHorizontal = Type: <b>BOOL</b> True if the stream should be flipped horizontally; otherwise, false.
    ///    FlipVertical = Type: <b>BOOL</b> True if the stream should be flipped vertically; otherwise, false.
    void    VideoProcessorSetStreamMirror(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, BOOL Enable, 
                                          BOOL FlipHorizontal, BOOL FlipVertical);
    ///Gets the color space information for the video processor input stream.
    ///Params:
    ///    pVideoProcessor = Type: <b>ID3D11VideoProcessor*</b> A pointer to the ID3D11VideoProcessor interface.
    ///    StreamIndex = Type: <b>UINT</b> An index identifying the input stream.
    ///    pColorSpace = Type: <b>DXGI_COLOR_SPACE_TYPE*</b> A pointer to a DXGI_COLOR_SPACE_TYPE value that specifies the colorspace
    ///                  for the video processor input stream.
    void    VideoProcessorGetStreamColorSpace1(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                               DXGI_COLOR_SPACE_TYPE* pColorSpace);
    ///Gets values that indicate whether the video processor input stream is being flipped vertically or horizontally.
    ///Params:
    ///    pVideoProcessor = Type: <b>ID3D11VideoProcessor*</b> A pointer to the ID3D11VideoProcessor interface.
    ///    StreamIndex = Type: <b>UINT</b> An index identifying the input stream.
    ///    pEnable = Type: <b>BOOL*</b> A pointer to a boolean value indicating whether mirroring is enabled. True if mirroring is
    ///              enabled; otherwise, false.
    ///    pFlipHorizontal = Type: <b>BOOL*</b> A pointer to a boolean value indicating whether the stream is being flipped horizontally.
    ///                      True if the stream is being flipped horizontally; otherwise, false.
    ///    pFlipVertical = Type: <b>BOOL*</b> A pointer to a boolean value indicating whether the stream is being flipped vertically.
    ///                    True if the stream is being flipped vertically; otherwise, false.
    void    VideoProcessorGetStreamMirror(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, BOOL* pEnable, 
                                          BOOL* pFlipHorizontal, BOOL* pFlipVertical);
    ///Returns driver hints that indicate which of the video processor operations are best performed using multi-plane
    ///overlay hardware rather than ID3D11VideoContext::VideoProcessorBlt method.
    ///Params:
    ///    pVideoProcessor = Type: <b>ID3D11VideoProcessor*</b> A pointer to the ID3D11VideoProcessor interface.
    ///    OutputWidth = Type: <b>UINT</b> The width of the output stream.
    ///    OutputHeight = Type: <b>UINT</b> The height of the output stream.
    ///    OutputFormat = Type: <b>DXGI_FORMAT</b> The format of the output stream.
    ///    StreamCount = Type: <b>UINT</b> The number of input streams to process.
    ///    pStreams = Type: <b>const D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT*</b> An array of structures that specifies the
    ///               format of each input stream and whether each stream should be used when computing behavior hints.
    ///    pBehaviorHints = Type: <b>UINT*</b> A pointer to a bitwise OR combination of D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINTS values
    ///                     indicating which video processor operations would best be performed using multi-plane overlay hardware rather
    ///                     than the ID3D11VideoContext::VideoProcessorBlt method.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns one of the following error codes. <table> <tr> <td>S_OK</td> <td>The
    ///    operation completed successfully.</td> </tr> <tr> <td>E_INVALIDARG</td> <td>An invalid parameter was passed
    ///    or this function was called using an invalid calling pattern.</td> </tr> <tr> <td>E_OUTOFMEMORY</td>
    ///    <td>There is insufficient memory to complete the operation.</td> </tr> </table>
    ///    
    HRESULT VideoProcessorGetBehaviorHints(ID3D11VideoProcessor pVideoProcessor, uint OutputWidth, 
                                           uint OutputHeight, DXGI_FORMAT OutputFormat, uint StreamCount, 
                                           const(D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT)* pStreams, 
                                           uint* pBehaviorHints);
}

///Provides the video decoding and video processing capabilities of a Microsoft Direct3D 11 device.
@GUID("29DA1D51-1321-4454-804B-F5FC9F861F0F")
interface ID3D11VideoDevice1 : ID3D11VideoDevice
{
    ///Retrieves optional sizes for private driver data.
    ///Params:
    ///    pCryptoType = Type: <b>const GUID*</b> Indicates the crypto type for which the private input and output size is queried.
    ///    pDecoderProfile = Type: <b>const GUID*</b> Indicates the decoder profile for which the private input and output size is
    ///                      queried.
    ///    pKeyExchangeType = Type: <b>const GUID*</b> Indicates the key exchange type for which the private input and output size is
    ///                       queried.
    ///    pPrivateInputSize = Type: <b>UINT*</b> Returns the size of private data that the driver needs for input commands.
    ///    pPrivateOutputSize = Type: <b>UINT*</b> Returns the size of private data that the driver needs for output commands.
    ///Returns:
    ///    Type: <b>HRESULT</b> If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
    ///    
    HRESULT GetCryptoSessionPrivateDataSize(const(GUID)* pCryptoType, const(GUID)* pDecoderProfile, 
                                            const(GUID)* pKeyExchangeType, uint* pPrivateInputSize, 
                                            uint* pPrivateOutputSize);
    ///Retrieves capabilities and limitations of the video decoder.
    ///Params:
    ///    pDecoderProfile = Type: <b>const GUID*</b> The decode profile for which the capabilities are queried.
    ///    SampleWidth = Type: <b>UINT</b> The video width for which the capabilities are queried.
    ///    SampleHeight = Type: <b>UINT</b> The video height for which the capabilities are queried.
    ///    pFrameRate = Type: <b>const DXGI_RATIONAL*</b> The frame rate of the video content. This information is used by the driver
    ///                 to determine whether the video can be decoded in real-time.
    ///    BitRate = Type: <b>UINT</b> The bit rate of the video stream. A value of zero indicates that the bit rate can be
    ///              ignored.
    ///    pCryptoType = Type: <b>const GUID*</b> The type of cryptography used to encrypt the video stream. A value of NULL indicates
    ///                  that the video stream is not encrypted.
    ///    pDecoderCaps = Type: <b>UINT*</b> A pointer to a bitwise OR combination of D3D11_VIDEO_DECODER_CAPS values specifying the
    ///                   decoder capabilities.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns one of the following error codes. <table> <tr> <td>S_OK</td> <td>The
    ///    operation completed successfully.</td> </tr> <tr> <td>E_INVALIDARG</td> <td>An invalid parameter was passed
    ///    or this function was called using an invalid calling pattern.</td> </tr> </table>
    ///    
    HRESULT GetVideoDecoderCaps(const(GUID)* pDecoderProfile, uint SampleWidth, uint SampleHeight, 
                                const(DXGI_RATIONAL)* pFrameRate, uint BitRate, const(GUID)* pCryptoType, 
                                uint* pDecoderCaps);
    ///Indicates whether the video decoder supports downsampling with the specified input format, and whether real-time
    ///downsampling is supported.
    ///Params:
    ///    pInputDesc = Type: <b>const D3D11_VIDEO_DECODER_DESC*</b> An object describing the decoding profile, the resolution, and
    ///                 format of the input stream. This is the resolution and format to be downsampled.
    ///    InputColorSpace = Type: <b>DXGI_COLOR_SPACE_TYPE</b> A DXGI_COLOR_SPACE_TYPE value that specifies the colorspace of the
    ///                      reference frame data.
    ///    pInputConfig = Type: <b>const D3D11_VIDEO_DECODER_CONFIG*</b> The configuration data associated with the decode profile.
    ///    pFrameRate = Type: <b>const DXGI_RATIONAL*</b> The frame rate of the video content. This is used by the driver to
    ///                 determine whether the video can be decoded in real-time.
    ///    pOutputDesc = Type: <b>const D3D11_VIDEO_SAMPLE_DESC*</b> An object describing the resolution, format, and colorspace of
    ///                  the output frames. This is the destination resolution and format of the downsample operation.
    ///    pSupported = Type: <b>BOOL*</b> Pointer to a boolean value set by the driver that indicates if downsampling is supported
    ///                 with the specified input data. True if the driver supports the requested downsampling; otherwise, false.
    ///    pRealTimeHint = Type: <b>BOOL*</b> Pointer to a boolean value set by the driver that indicates if real-time decoding is
    ///                    supported with the specified input data. True if the driver supports the requested real-time decoding;
    ///                    otherwise, false. Note that the returned value is based on the current configuration of the video decoder and
    ///                    does not guarantee that real-time decoding will be supported for future downsampling operations.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns one of the following error codes. <table> <tr> <td>S_OK</td> <td>The
    ///    operation completed successfully.</td> </tr> <tr> <td>E_INVALIDARG</td> <td>An invalid parameter was passed
    ///    or this function was called using an invalid calling pattern.</td> </tr> </table>
    ///    
    HRESULT CheckVideoDecoderDownsampling(const(D3D11_VIDEO_DECODER_DESC)* pInputDesc, 
                                          DXGI_COLOR_SPACE_TYPE InputColorSpace, 
                                          const(D3D11_VIDEO_DECODER_CONFIG)* pInputConfig, 
                                          const(DXGI_RATIONAL)* pFrameRate, 
                                          const(D3D11_VIDEO_SAMPLE_DESC)* pOutputDesc, BOOL* pSupported, 
                                          BOOL* pRealTimeHint);
    ///Allows the driver to recommend optimal output downsample parameters from the input parameters.
    ///Params:
    ///    pInputDesc = Type: <b>const D3D11_VIDEO_DECODER_DESC*</b> A D3D11_VIDEO_DECODER_DESC object describing the decoding
    ///                 profile, the resolution, and format of the input stream. This is the resolution and format to be downsampled.
    ///    InputColorSpace = Type: <b>DXGI_COLOR_SPACE_TYPE</b> A DXGI_COLOR_SPACE_TYPE value that specifies the colorspace of the
    ///                      reference frame data.
    ///    pInputConfig = Type: <b>const D3D11_VIDEO_DECODER_CONFIG*</b> The configuration data associated with the decode profile.
    ///    pFrameRate = Type: <b>const DXGI_RATIONAL*</b> The frame rate of the video content. This is used by the driver to
    ///                 determine whether the video can be decoded in real-time.
    ///    pRecommendedOutputDesc = Type: <b>D3D11_VIDEO_SAMPLE_DESC*</b> Pointer to a D3D11_VIDEO_SAMPLE_DESC structure that the driver
    ///                             populates with the recommended output buffer parameters for a downsample operation. The driver will attempt
    ///                             to recommend parameters that can support real-time decoding. If it is unable to do so, the driver will
    ///                             recommend values that are as close to the real-time solution as possible.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns one of the following error codes. <table> <tr> <td>S_OK</td> <td>The
    ///    operation completed successfully.</td> </tr> <tr> <td>E_INVALIDARG</td> <td>An invalid parameter was passed
    ///    or this function was called using an invalid calling pattern.</td> </tr> </table>
    ///    
    HRESULT RecommendVideoDecoderDownsampleParameters(const(D3D11_VIDEO_DECODER_DESC)* pInputDesc, 
                                                      DXGI_COLOR_SPACE_TYPE InputColorSpace, 
                                                      const(D3D11_VIDEO_DECODER_CONFIG)* pInputConfig, 
                                                      const(DXGI_RATIONAL)* pFrameRate, 
                                                      D3D11_VIDEO_SAMPLE_DESC* pRecommendedOutputDesc);
}

///Enumerates the video processor capabilities of a Microsoft Direct3D 11 device.
@GUID("465217F2-5568-43CF-B5B9-F61D54531CA1")
interface ID3D11VideoProcessorEnumerator1 : ID3D11VideoProcessorEnumerator
{
    ///Indicates whether the driver supports the specified combination of format and colorspace conversions.
    ///Params:
    ///    InputFormat = Type: <b>DXGI_FORMAT</b> The format of the video processor input.
    ///    InputColorSpace = Type: <b>DXGI_COLOR_SPACE_TYPE</b> The colorspace of the video processor input.
    ///    OutputFormat = Type: <b>DXGI_FORMAT</b> The format of the video processor output.
    ///    OutputColorSpace = Type: <b>DXGI_COLOR_SPACE_TYPE</b> The colorspace of the video processor output.
    ///    pSupported = Type: <b>BOOL*</b> Pointer to a boolean that is set by the driver to indicate if the specified combination of
    ///                 format and colorspace conversions is supported. True if the conversion is supported; otherwise, false.
    ///Returns:
    ///    Type: <b>HRESULT</b> This method returns one of the following error codes. <table> <tr> <td>S_OK</td> <td>The
    ///    operation completed successfully.</td> </tr> <tr> <td>E_INVALIDARG</td> <td>An invalid parameter was passed
    ///    or this function was called using an invalid calling pattern.</td> </tr> </table>
    ///    
    HRESULT CheckVideoProcessorFormatConversion(DXGI_FORMAT InputFormat, DXGI_COLOR_SPACE_TYPE InputColorSpace, 
                                                DXGI_FORMAT OutputFormat, DXGI_COLOR_SPACE_TYPE OutputColorSpace, 
                                                BOOL* pSupported);
}

///Provides the video functionality of a Microsoft Direct3D 11 device.
@GUID("C4E7374C-6243-4D1B-AE87-52B4F740E261")
interface ID3D11VideoContext2 : ID3D11VideoContext1
{
    ///Sets the HDR metadata describing the display on which the content will be presented.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface.
    ///    Type = The type of HDR metadata supplied.
    ///    Size = The size of the HDR metadata supplied in <i>pHDRMetaData</i>. For <b>DXGI_HDR_METADATA_TYPE_NONE</b>, the
    ///           size should be 0. For <b>DXGI_HDR_METADATA_TYPE_HDR10</b>, the size is
    ///           <code>sizeof(DXGI_HDR_METADATA_HDR10)</code>.
    ///    pHDRMetaData = Pointer to the metadata information. For <b>DXGI_HDR_METADATA_TYPE_NONE</b>, this should be NULL. For
    ///                   <b>DXGI_HDR_METADATA_TYPE_HDR10</b>, this is a pointer to a DXGI_HDR_METADATA_HDR10 structure.
    void VideoProcessorSetOutputHDRMetaData(ID3D11VideoProcessor pVideoProcessor, DXGI_HDR_METADATA_TYPE Type, 
                                            uint Size, const(void)* pHDRMetaData);
    ///Gets the HDR metadata describing the display on which the content will be presented.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface.
    ///    pType = The type of HDR metadata supplied.
    ///    Size = The size of the memory referenced by <i>pHDRMetaData</i>. If <i>pHDRMetaData</i> is NULL, <i>Size</i> should
    ///           be 0.
    ///    pMetaData = Pointer to a buffer that receives the HDR metadata. This parameter can be NULL.
    void VideoProcessorGetOutputHDRMetaData(ID3D11VideoProcessor pVideoProcessor, DXGI_HDR_METADATA_TYPE* pType, 
                                            uint Size, void* pMetaData);
    ///Sets the HDR metadata associated with the video stream.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface.
    ///    StreamIndex = Identifies the input stream.
    ///    Type = The type of HDR metadata supplied.
    ///    Size = The size of the HDR metadata supplied in <i>pHDRMetaData</i>. For <b>DXGI_HDR_METADATA_TYPE_NONE</b>, the
    ///           size should be 0. For <b>DXGI_HDR_METADATA_TYPE_HDR10</b>, the size is
    ///           <code>sizeof(DXGI_HDR_METADATA_HDR10)</code>.
    ///    pHDRMetaData = Pointer to the metadata information. For <b>DXGI_HDR_METADATA_TYPE_NONE</b>, this should be NULL. For
    ///                   <b>DXGI_HDR_METADATA_TYPE_HDR10</b>, this is a pointer to a DXGI_HDR_METADATA_HDR10 structure.
    void VideoProcessorSetStreamHDRMetaData(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                            DXGI_HDR_METADATA_TYPE Type, uint Size, const(void)* pHDRMetaData);
    ///Gets the HDR metadata associated with the video stream.
    ///Params:
    ///    pVideoProcessor = A pointer to the ID3D11VideoProcessor interface.
    ///    StreamIndex = Identifies the input stream.
    ///    pType = The type of the HDR metadata currently associated with the stream.
    ///    Size = The size of the memory referenced by <i>pHDRMetaData</i>. If <i>pHDRMetaData</i> is NULL, <i>Size</i> should
    ///           be 0.
    ///    pMetaData = Pointer to a buffer that receives the HDR metadata. This parameter can be NULL.
    void VideoProcessorGetStreamHDRMetaData(ID3D11VideoProcessor pVideoProcessor, uint StreamIndex, 
                                            DXGI_HDR_METADATA_TYPE* pType, uint Size, void* pMetaData);
}


// GUIDs

const GUID CLSID_AACMFTEncoder                = GUIDOF!AACMFTEncoder;
const GUID CLSID_ALawCodecWrapper             = GUIDOF!ALawCodecWrapper;
const GUID CLSID_CAC3DecMediaObject           = GUIDOF!CAC3DecMediaObject;
const GUID CLSID_CClusterDetectorDmo          = GUIDOF!CClusterDetectorDmo;
const GUID CLSID_CColorControlDmo             = GUIDOF!CColorControlDmo;
const GUID CLSID_CColorConvertDMO             = GUIDOF!CColorConvertDMO;
const GUID CLSID_CColorLegalizerDmo           = GUIDOF!CColorLegalizerDmo;
const GUID CLSID_CDTVAudDecoderDS             = GUIDOF!CDTVAudDecoderDS;
const GUID CLSID_CDTVVidDecoderDS             = GUIDOF!CDTVVidDecoderDS;
const GUID CLSID_CDVDecoderMediaObject        = GUIDOF!CDVDecoderMediaObject;
const GUID CLSID_CDVEncoderMediaObject        = GUIDOF!CDVEncoderMediaObject;
const GUID CLSID_CDeColorConvMediaObject      = GUIDOF!CDeColorConvMediaObject;
const GUID CLSID_CFrameInterpDMO              = GUIDOF!CFrameInterpDMO;
const GUID CLSID_CFrameRateConvertDmo         = GUIDOF!CFrameRateConvertDmo;
const GUID CLSID_CInterlaceMediaObject        = GUIDOF!CInterlaceMediaObject;
const GUID CLSID_CMP3DecMediaObject           = GUIDOF!CMP3DecMediaObject;
const GUID CLSID_CMPEG2AudDecoderDS           = GUIDOF!CMPEG2AudDecoderDS;
const GUID CLSID_CMPEG2AudioEncoderMFT        = GUIDOF!CMPEG2AudioEncoderMFT;
const GUID CLSID_CMPEG2EncoderAudioDS         = GUIDOF!CMPEG2EncoderAudioDS;
const GUID CLSID_CMPEG2EncoderDS              = GUIDOF!CMPEG2EncoderDS;
const GUID CLSID_CMPEG2EncoderVideoDS         = GUIDOF!CMPEG2EncoderVideoDS;
const GUID CLSID_CMPEG2VidDecoderDS           = GUIDOF!CMPEG2VidDecoderDS;
const GUID CLSID_CMPEG2VideoEncoderMFT        = GUIDOF!CMPEG2VideoEncoderMFT;
const GUID CLSID_CMPEGAACDecMediaObject       = GUIDOF!CMPEGAACDecMediaObject;
const GUID CLSID_CMSAACDecMFT                 = GUIDOF!CMSAACDecMFT;
const GUID CLSID_CMSAC3Enc                    = GUIDOF!CMSAC3Enc;
const GUID CLSID_CMSALACDecMFT                = GUIDOF!CMSALACDecMFT;
const GUID CLSID_CMSALACEncMFT                = GUIDOF!CMSALACEncMFT;
const GUID CLSID_CMSDDPlusDecMFT              = GUIDOF!CMSDDPlusDecMFT;
const GUID CLSID_CMSDolbyDigitalEncMFT        = GUIDOF!CMSDolbyDigitalEncMFT;
const GUID CLSID_CMSFLACDecMFT                = GUIDOF!CMSFLACDecMFT;
const GUID CLSID_CMSFLACEncMFT                = GUIDOF!CMSFLACEncMFT;
const GUID CLSID_CMSH263EncoderMFT            = GUIDOF!CMSH263EncoderMFT;
const GUID CLSID_CMSH264DecoderMFT            = GUIDOF!CMSH264DecoderMFT;
const GUID CLSID_CMSH264EncoderMFT            = GUIDOF!CMSH264EncoderMFT;
const GUID CLSID_CMSH264RemuxMFT              = GUIDOF!CMSH264RemuxMFT;
const GUID CLSID_CMSH265EncoderMFT            = GUIDOF!CMSH265EncoderMFT;
const GUID CLSID_CMSMPEGAudDecMFT             = GUIDOF!CMSMPEGAudDecMFT;
const GUID CLSID_CMSMPEGDecoderMFT            = GUIDOF!CMSMPEGDecoderMFT;
const GUID CLSID_CMSOpusDecMFT                = GUIDOF!CMSOpusDecMFT;
const GUID CLSID_CMSSCDecMediaObject          = GUIDOF!CMSSCDecMediaObject;
const GUID CLSID_CMSSCEncMediaObject          = GUIDOF!CMSSCEncMediaObject;
const GUID CLSID_CMSSCEncMediaObject2         = GUIDOF!CMSSCEncMediaObject2;
const GUID CLSID_CMSVPXEncoderMFT             = GUIDOF!CMSVPXEncoderMFT;
const GUID CLSID_CMSVideoDSPMFT               = GUIDOF!CMSVideoDSPMFT;
const GUID CLSID_CMpeg2DecMediaObject         = GUIDOF!CMpeg2DecMediaObject;
const GUID CLSID_CMpeg43DecMediaObject        = GUIDOF!CMpeg43DecMediaObject;
const GUID CLSID_CMpeg4DecMediaObject         = GUIDOF!CMpeg4DecMediaObject;
const GUID CLSID_CMpeg4EncMediaObject         = GUIDOF!CMpeg4EncMediaObject;
const GUID CLSID_CMpeg4sDecMFT                = GUIDOF!CMpeg4sDecMFT;
const GUID CLSID_CMpeg4sDecMediaObject        = GUIDOF!CMpeg4sDecMediaObject;
const GUID CLSID_CMpeg4sEncMediaObject        = GUIDOF!CMpeg4sEncMediaObject;
const GUID CLSID_CNokiaAACCCDecMediaObject    = GUIDOF!CNokiaAACCCDecMediaObject;
const GUID CLSID_CNokiaAACDecMediaObject      = GUIDOF!CNokiaAACDecMediaObject;
const GUID CLSID_CPK_DS_AC3Decoder            = GUIDOF!CPK_DS_AC3Decoder;
const GUID CLSID_CPK_DS_MPEG2Decoder          = GUIDOF!CPK_DS_MPEG2Decoder;
const GUID CLSID_CResamplerMediaObject        = GUIDOF!CResamplerMediaObject;
const GUID CLSID_CResizerDMO                  = GUIDOF!CResizerDMO;
const GUID CLSID_CResizerMediaObject          = GUIDOF!CResizerMediaObject;
const GUID CLSID_CShotDetectorDmo             = GUIDOF!CShotDetectorDmo;
const GUID CLSID_CSmpteTransformsDmo          = GUIDOF!CSmpteTransformsDmo;
const GUID CLSID_CThumbnailGeneratorDmo       = GUIDOF!CThumbnailGeneratorDmo;
const GUID CLSID_CTocGeneratorDmo             = GUIDOF!CTocGeneratorDmo;
const GUID CLSID_CVodafoneAACCCDecMediaObject = GUIDOF!CVodafoneAACCCDecMediaObject;
const GUID CLSID_CVodafoneAACDecMediaObject   = GUIDOF!CVodafoneAACDecMediaObject;
const GUID CLSID_CWMADecMediaObject           = GUIDOF!CWMADecMediaObject;
const GUID CLSID_CWMAEncMediaObject           = GUIDOF!CWMAEncMediaObject;
const GUID CLSID_CWMATransMediaObject         = GUIDOF!CWMATransMediaObject;
const GUID CLSID_CWMAudioAEC                  = GUIDOF!CWMAudioAEC;
const GUID CLSID_CWMAudioGFXAPO               = GUIDOF!CWMAudioGFXAPO;
const GUID CLSID_CWMAudioLFXAPO               = GUIDOF!CWMAudioLFXAPO;
const GUID CLSID_CWMAudioSpdTxDMO             = GUIDOF!CWMAudioSpdTxDMO;
const GUID CLSID_CWMSPDecMediaObject          = GUIDOF!CWMSPDecMediaObject;
const GUID CLSID_CWMSPEncMediaObject          = GUIDOF!CWMSPEncMediaObject;
const GUID CLSID_CWMSPEncMediaObject2         = GUIDOF!CWMSPEncMediaObject2;
const GUID CLSID_CWMTDecMediaObject           = GUIDOF!CWMTDecMediaObject;
const GUID CLSID_CWMTEncMediaObject           = GUIDOF!CWMTEncMediaObject;
const GUID CLSID_CWMV9EncMediaObject          = GUIDOF!CWMV9EncMediaObject;
const GUID CLSID_CWMVDecMediaObject           = GUIDOF!CWMVDecMediaObject;
const GUID CLSID_CWMVEncMediaObject2          = GUIDOF!CWMVEncMediaObject2;
const GUID CLSID_CWMVXEncMediaObject          = GUIDOF!CWMVXEncMediaObject;
const GUID CLSID_CWVC1DecMediaObject          = GUIDOF!CWVC1DecMediaObject;
const GUID CLSID_CWVC1EncMediaObject          = GUIDOF!CWVC1EncMediaObject;
const GUID CLSID_CZuneAACCCDecMediaObject     = GUIDOF!CZuneAACCCDecMediaObject;
const GUID CLSID_CZuneM4S2DecMediaObject      = GUIDOF!CZuneM4S2DecMediaObject;
const GUID CLSID_KSPROPSETID_OPMVideoOutput   = GUIDOF!KSPROPSETID_OPMVideoOutput;
const GUID CLSID_MFAMRNBByteStreamHandler     = GUIDOF!MFAMRNBByteStreamHandler;
const GUID CLSID_MFAMRNBSinkClassFactory      = GUIDOF!MFAMRNBSinkClassFactory;
const GUID CLSID_MFFLACBytestreamHandler      = GUIDOF!MFFLACBytestreamHandler;
const GUID CLSID_MFFLACSinkClassFactory       = GUIDOF!MFFLACSinkClassFactory;
const GUID CLSID_MP3ACMCodecWrapper           = GUIDOF!MP3ACMCodecWrapper;
const GUID CLSID_MSAMRNBDecoder               = GUIDOF!MSAMRNBDecoder;
const GUID CLSID_MSAMRNBEncoder               = GUIDOF!MSAMRNBEncoder;
const GUID CLSID_MULawCodecWrapper            = GUIDOF!MULawCodecWrapper;
const GUID CLSID_VorbisDecoderMFT             = GUIDOF!VorbisDecoderMFT;

const GUID IID_IAdvancedMediaCapture                            = GUIDOF!IAdvancedMediaCapture;
const GUID IID_IAdvancedMediaCaptureInitializationSettings      = GUIDOF!IAdvancedMediaCaptureInitializationSettings;
const GUID IID_IAdvancedMediaCaptureSettings                    = GUIDOF!IAdvancedMediaCaptureSettings;
const GUID IID_IAudioSourceProvider                             = GUIDOF!IAudioSourceProvider;
const GUID IID_IClusterDetector                                 = GUIDOF!IClusterDetector;
const GUID IID_ICodecAPI                                        = GUIDOF!ICodecAPI;
const GUID IID_ID3D11AuthenticatedChannel                       = GUIDOF!ID3D11AuthenticatedChannel;
const GUID IID_ID3D11CryptoSession                              = GUIDOF!ID3D11CryptoSession;
const GUID IID_ID3D11VideoContext                               = GUIDOF!ID3D11VideoContext;
const GUID IID_ID3D11VideoContext1                              = GUIDOF!ID3D11VideoContext1;
const GUID IID_ID3D11VideoContext2                              = GUIDOF!ID3D11VideoContext2;
const GUID IID_ID3D11VideoDecoder                               = GUIDOF!ID3D11VideoDecoder;
const GUID IID_ID3D11VideoDecoderOutputView                     = GUIDOF!ID3D11VideoDecoderOutputView;
const GUID IID_ID3D11VideoDevice                                = GUIDOF!ID3D11VideoDevice;
const GUID IID_ID3D11VideoDevice1                               = GUIDOF!ID3D11VideoDevice1;
const GUID IID_ID3D11VideoProcessor                             = GUIDOF!ID3D11VideoProcessor;
const GUID IID_ID3D11VideoProcessorEnumerator                   = GUIDOF!ID3D11VideoProcessorEnumerator;
const GUID IID_ID3D11VideoProcessorEnumerator1                  = GUIDOF!ID3D11VideoProcessorEnumerator1;
const GUID IID_ID3D11VideoProcessorInputView                    = GUIDOF!ID3D11VideoProcessorInputView;
const GUID IID_ID3D11VideoProcessorOutputView                   = GUIDOF!ID3D11VideoProcessorOutputView;
const GUID IID_ID3D12VideoDecodeCommandList                     = GUIDOF!ID3D12VideoDecodeCommandList;
const GUID IID_ID3D12VideoDecodeCommandList1                    = GUIDOF!ID3D12VideoDecodeCommandList1;
const GUID IID_ID3D12VideoDecodeCommandList2                    = GUIDOF!ID3D12VideoDecodeCommandList2;
const GUID IID_ID3D12VideoDecoder                               = GUIDOF!ID3D12VideoDecoder;
const GUID IID_ID3D12VideoDecoder1                              = GUIDOF!ID3D12VideoDecoder1;
const GUID IID_ID3D12VideoDecoderHeap                           = GUIDOF!ID3D12VideoDecoderHeap;
const GUID IID_ID3D12VideoDecoderHeap1                          = GUIDOF!ID3D12VideoDecoderHeap1;
const GUID IID_ID3D12VideoDevice                                = GUIDOF!ID3D12VideoDevice;
const GUID IID_ID3D12VideoDevice1                               = GUIDOF!ID3D12VideoDevice1;
const GUID IID_ID3D12VideoDevice2                               = GUIDOF!ID3D12VideoDevice2;
const GUID IID_ID3D12VideoEncodeCommandList                     = GUIDOF!ID3D12VideoEncodeCommandList;
const GUID IID_ID3D12VideoEncodeCommandList1                    = GUIDOF!ID3D12VideoEncodeCommandList1;
const GUID IID_ID3D12VideoExtensionCommand                      = GUIDOF!ID3D12VideoExtensionCommand;
const GUID IID_ID3D12VideoMotionEstimator                       = GUIDOF!ID3D12VideoMotionEstimator;
const GUID IID_ID3D12VideoMotionVectorHeap                      = GUIDOF!ID3D12VideoMotionVectorHeap;
const GUID IID_ID3D12VideoProcessCommandList                    = GUIDOF!ID3D12VideoProcessCommandList;
const GUID IID_ID3D12VideoProcessCommandList1                   = GUIDOF!ID3D12VideoProcessCommandList1;
const GUID IID_ID3D12VideoProcessCommandList2                   = GUIDOF!ID3D12VideoProcessCommandList2;
const GUID IID_ID3D12VideoProcessor                             = GUIDOF!ID3D12VideoProcessor;
const GUID IID_ID3D12VideoProcessor1                            = GUIDOF!ID3D12VideoProcessor1;
const GUID IID_IDXVAHD_Device                                   = GUIDOF!IDXVAHD_Device;
const GUID IID_IDXVAHD_VideoProcessor                           = GUIDOF!IDXVAHD_VideoProcessor;
const GUID IID_IDirect3D9ExOverlayExtension                     = GUIDOF!IDirect3D9ExOverlayExtension;
const GUID IID_IDirect3DAuthenticatedChannel9                   = GUIDOF!IDirect3DAuthenticatedChannel9;
const GUID IID_IDirect3DCryptoSession9                          = GUIDOF!IDirect3DCryptoSession9;
const GUID IID_IDirect3DDevice9Video                            = GUIDOF!IDirect3DDevice9Video;
const GUID IID_IDirect3DDeviceManager9                          = GUIDOF!IDirect3DDeviceManager9;
const GUID IID_IDirectXVideoAccelerationService                 = GUIDOF!IDirectXVideoAccelerationService;
const GUID IID_IDirectXVideoDecoder                             = GUIDOF!IDirectXVideoDecoder;
const GUID IID_IDirectXVideoDecoderService                      = GUIDOF!IDirectXVideoDecoderService;
const GUID IID_IDirectXVideoMemoryConfiguration                 = GUIDOF!IDirectXVideoMemoryConfiguration;
const GUID IID_IDirectXVideoProcessor                           = GUIDOF!IDirectXVideoProcessor;
const GUID IID_IDirectXVideoProcessorService                    = GUIDOF!IDirectXVideoProcessorService;
const GUID IID_IEVRFilterConfig                                 = GUIDOF!IEVRFilterConfig;
const GUID IID_IEVRFilterConfigEx                               = GUIDOF!IEVRFilterConfigEx;
const GUID IID_IEVRTrustedVideoPlugin                           = GUIDOF!IEVRTrustedVideoPlugin;
const GUID IID_IEVRVideoStreamControl                           = GUIDOF!IEVRVideoStreamControl;
const GUID IID_IFileClient                                      = GUIDOF!IFileClient;
const GUID IID_IFileIo                                          = GUIDOF!IFileIo;
const GUID IID_IMF2DBuffer                                      = GUIDOF!IMF2DBuffer;
const GUID IID_IMF2DBuffer2                                     = GUIDOF!IMF2DBuffer2;
const GUID IID_IMFASFContentInfo                                = GUIDOF!IMFASFContentInfo;
const GUID IID_IMFASFIndexer                                    = GUIDOF!IMFASFIndexer;
const GUID IID_IMFASFMultiplexer                                = GUIDOF!IMFASFMultiplexer;
const GUID IID_IMFASFMutualExclusion                            = GUIDOF!IMFASFMutualExclusion;
const GUID IID_IMFASFProfile                                    = GUIDOF!IMFASFProfile;
const GUID IID_IMFASFSplitter                                   = GUIDOF!IMFASFSplitter;
const GUID IID_IMFASFStreamConfig                               = GUIDOF!IMFASFStreamConfig;
const GUID IID_IMFASFStreamPrioritization                       = GUIDOF!IMFASFStreamPrioritization;
const GUID IID_IMFASFStreamSelector                             = GUIDOF!IMFASFStreamSelector;
const GUID IID_IMFActivate                                      = GUIDOF!IMFActivate;
const GUID IID_IMFAsyncCallback                                 = GUIDOF!IMFAsyncCallback;
const GUID IID_IMFAsyncCallbackLogging                          = GUIDOF!IMFAsyncCallbackLogging;
const GUID IID_IMFAsyncResult                                   = GUIDOF!IMFAsyncResult;
const GUID IID_IMFAttributes                                    = GUIDOF!IMFAttributes;
const GUID IID_IMFAudioMediaType                                = GUIDOF!IMFAudioMediaType;
const GUID IID_IMFAudioPolicy                                   = GUIDOF!IMFAudioPolicy;
const GUID IID_IMFAudioStreamVolume                             = GUIDOF!IMFAudioStreamVolume;
const GUID IID_IMFBufferListNotify                              = GUIDOF!IMFBufferListNotify;
const GUID IID_IMFByteStream                                    = GUIDOF!IMFByteStream;
const GUID IID_IMFByteStreamBuffering                           = GUIDOF!IMFByteStreamBuffering;
const GUID IID_IMFByteStreamCacheControl                        = GUIDOF!IMFByteStreamCacheControl;
const GUID IID_IMFByteStreamCacheControl2                       = GUIDOF!IMFByteStreamCacheControl2;
const GUID IID_IMFByteStreamHandler                             = GUIDOF!IMFByteStreamHandler;
const GUID IID_IMFByteStreamProxyClassFactory                   = GUIDOF!IMFByteStreamProxyClassFactory;
const GUID IID_IMFByteStreamTimeSeek                            = GUIDOF!IMFByteStreamTimeSeek;
const GUID IID_IMFCaptureEngine                                 = GUIDOF!IMFCaptureEngine;
const GUID IID_IMFCaptureEngineClassFactory                     = GUIDOF!IMFCaptureEngineClassFactory;
const GUID IID_IMFCaptureEngineOnEventCallback                  = GUIDOF!IMFCaptureEngineOnEventCallback;
const GUID IID_IMFCaptureEngineOnSampleCallback                 = GUIDOF!IMFCaptureEngineOnSampleCallback;
const GUID IID_IMFCaptureEngineOnSampleCallback2                = GUIDOF!IMFCaptureEngineOnSampleCallback2;
const GUID IID_IMFCapturePhotoConfirmation                      = GUIDOF!IMFCapturePhotoConfirmation;
const GUID IID_IMFCapturePhotoSink                              = GUIDOF!IMFCapturePhotoSink;
const GUID IID_IMFCapturePreviewSink                            = GUIDOF!IMFCapturePreviewSink;
const GUID IID_IMFCaptureRecordSink                             = GUIDOF!IMFCaptureRecordSink;
const GUID IID_IMFCaptureSink                                   = GUIDOF!IMFCaptureSink;
const GUID IID_IMFCaptureSink2                                  = GUIDOF!IMFCaptureSink2;
const GUID IID_IMFCaptureSource                                 = GUIDOF!IMFCaptureSource;
const GUID IID_IMFCdmSuspendNotify                              = GUIDOF!IMFCdmSuspendNotify;
const GUID IID_IMFClock                                         = GUIDOF!IMFClock;
const GUID IID_IMFClockConsumer                                 = GUIDOF!IMFClockConsumer;
const GUID IID_IMFClockStateSink                                = GUIDOF!IMFClockStateSink;
const GUID IID_IMFCollection                                    = GUIDOF!IMFCollection;
const GUID IID_IMFContentDecryptionModule                       = GUIDOF!IMFContentDecryptionModule;
const GUID IID_IMFContentDecryptionModuleAccess                 = GUIDOF!IMFContentDecryptionModuleAccess;
const GUID IID_IMFContentDecryptionModuleFactory                = GUIDOF!IMFContentDecryptionModuleFactory;
const GUID IID_IMFContentDecryptionModuleSession                = GUIDOF!IMFContentDecryptionModuleSession;
const GUID IID_IMFContentDecryptionModuleSessionCallbacks       = GUIDOF!IMFContentDecryptionModuleSessionCallbacks;
const GUID IID_IMFContentDecryptorContext                       = GUIDOF!IMFContentDecryptorContext;
const GUID IID_IMFContentEnabler                                = GUIDOF!IMFContentEnabler;
const GUID IID_IMFContentProtectionDevice                       = GUIDOF!IMFContentProtectionDevice;
const GUID IID_IMFContentProtectionManager                      = GUIDOF!IMFContentProtectionManager;
const GUID IID_IMFDLNASinkInit                                  = GUIDOF!IMFDLNASinkInit;
const GUID IID_IMFDRMNetHelper                                  = GUIDOF!IMFDRMNetHelper;
const GUID IID_IMFDXGIBuffer                                    = GUIDOF!IMFDXGIBuffer;
const GUID IID_IMFDXGIDeviceManager                             = GUIDOF!IMFDXGIDeviceManager;
const GUID IID_IMFDXGIDeviceManagerSource                       = GUIDOF!IMFDXGIDeviceManagerSource;
const GUID IID_IMFDesiredSample                                 = GUIDOF!IMFDesiredSample;
const GUID IID_IMFExtendedCameraControl                         = GUIDOF!IMFExtendedCameraControl;
const GUID IID_IMFExtendedCameraController                      = GUIDOF!IMFExtendedCameraController;
const GUID IID_IMFExtendedCameraIntrinsicModel                  = GUIDOF!IMFExtendedCameraIntrinsicModel;
const GUID IID_IMFExtendedCameraIntrinsics                      = GUIDOF!IMFExtendedCameraIntrinsics;
const GUID IID_IMFExtendedCameraIntrinsicsDistortionModel6KT    = GUIDOF!IMFExtendedCameraIntrinsicsDistortionModel6KT;
const GUID IID_IMFExtendedCameraIntrinsicsDistortionModelArcTan = GUIDOF!IMFExtendedCameraIntrinsicsDistortionModelArcTan;
const GUID IID_IMFExtendedDRMTypeSupport                        = GUIDOF!IMFExtendedDRMTypeSupport;
const GUID IID_IMFFieldOfUseMFTUnlock                           = GUIDOF!IMFFieldOfUseMFTUnlock;
const GUID IID_IMFFinalizableMediaSink                          = GUIDOF!IMFFinalizableMediaSink;
const GUID IID_IMFGetService                                    = GUIDOF!IMFGetService;
const GUID IID_IMFHDCPStatus                                    = GUIDOF!IMFHDCPStatus;
const GUID IID_IMFHttpDownloadRequest                           = GUIDOF!IMFHttpDownloadRequest;
const GUID IID_IMFHttpDownloadSession                           = GUIDOF!IMFHttpDownloadSession;
const GUID IID_IMFHttpDownloadSessionProvider                   = GUIDOF!IMFHttpDownloadSessionProvider;
const GUID IID_IMFImageSharingEngine                            = GUIDOF!IMFImageSharingEngine;
const GUID IID_IMFImageSharingEngineClassFactory                = GUIDOF!IMFImageSharingEngineClassFactory;
const GUID IID_IMFInputTrustAuthority                           = GUIDOF!IMFInputTrustAuthority;
const GUID IID_IMFLocalMFTRegistration                          = GUIDOF!IMFLocalMFTRegistration;
const GUID IID_IMFMediaBuffer                                   = GUIDOF!IMFMediaBuffer;
const GUID IID_IMFMediaEngine                                   = GUIDOF!IMFMediaEngine;
const GUID IID_IMFMediaEngineAudioEndpointId                    = GUIDOF!IMFMediaEngineAudioEndpointId;
const GUID IID_IMFMediaEngineClassFactory                       = GUIDOF!IMFMediaEngineClassFactory;
const GUID IID_IMFMediaEngineClassFactory2                      = GUIDOF!IMFMediaEngineClassFactory2;
const GUID IID_IMFMediaEngineClassFactory3                      = GUIDOF!IMFMediaEngineClassFactory3;
const GUID IID_IMFMediaEngineClassFactory4                      = GUIDOF!IMFMediaEngineClassFactory4;
const GUID IID_IMFMediaEngineClassFactoryEx                     = GUIDOF!IMFMediaEngineClassFactoryEx;
const GUID IID_IMFMediaEngineEME                                = GUIDOF!IMFMediaEngineEME;
const GUID IID_IMFMediaEngineEMENotify                          = GUIDOF!IMFMediaEngineEMENotify;
const GUID IID_IMFMediaEngineEx                                 = GUIDOF!IMFMediaEngineEx;
const GUID IID_IMFMediaEngineExtension                          = GUIDOF!IMFMediaEngineExtension;
const GUID IID_IMFMediaEngineNeedKeyNotify                      = GUIDOF!IMFMediaEngineNeedKeyNotify;
const GUID IID_IMFMediaEngineNotify                             = GUIDOF!IMFMediaEngineNotify;
const GUID IID_IMFMediaEngineOPMInfo                            = GUIDOF!IMFMediaEngineOPMInfo;
const GUID IID_IMFMediaEngineProtectedContent                   = GUIDOF!IMFMediaEngineProtectedContent;
const GUID IID_IMFMediaEngineSrcElements                        = GUIDOF!IMFMediaEngineSrcElements;
const GUID IID_IMFMediaEngineSrcElementsEx                      = GUIDOF!IMFMediaEngineSrcElementsEx;
const GUID IID_IMFMediaEngineSupportsSourceTransfer             = GUIDOF!IMFMediaEngineSupportsSourceTransfer;
const GUID IID_IMFMediaEngineTransferSource                     = GUIDOF!IMFMediaEngineTransferSource;
const GUID IID_IMFMediaEngineWebSupport                         = GUIDOF!IMFMediaEngineWebSupport;
const GUID IID_IMFMediaError                                    = GUIDOF!IMFMediaError;
const GUID IID_IMFMediaEvent                                    = GUIDOF!IMFMediaEvent;
const GUID IID_IMFMediaEventGenerator                           = GUIDOF!IMFMediaEventGenerator;
const GUID IID_IMFMediaEventQueue                               = GUIDOF!IMFMediaEventQueue;
const GUID IID_IMFMediaKeySession                               = GUIDOF!IMFMediaKeySession;
const GUID IID_IMFMediaKeySession2                              = GUIDOF!IMFMediaKeySession2;
const GUID IID_IMFMediaKeySessionNotify                         = GUIDOF!IMFMediaKeySessionNotify;
const GUID IID_IMFMediaKeySessionNotify2                        = GUIDOF!IMFMediaKeySessionNotify2;
const GUID IID_IMFMediaKeySystemAccess                          = GUIDOF!IMFMediaKeySystemAccess;
const GUID IID_IMFMediaKeys                                     = GUIDOF!IMFMediaKeys;
const GUID IID_IMFMediaKeys2                                    = GUIDOF!IMFMediaKeys2;
const GUID IID_IMFMediaSession                                  = GUIDOF!IMFMediaSession;
const GUID IID_IMFMediaSharingEngine                            = GUIDOF!IMFMediaSharingEngine;
const GUID IID_IMFMediaSharingEngineClassFactory                = GUIDOF!IMFMediaSharingEngineClassFactory;
const GUID IID_IMFMediaSink                                     = GUIDOF!IMFMediaSink;
const GUID IID_IMFMediaSinkPreroll                              = GUIDOF!IMFMediaSinkPreroll;
const GUID IID_IMFMediaSource                                   = GUIDOF!IMFMediaSource;
const GUID IID_IMFMediaSource2                                  = GUIDOF!IMFMediaSource2;
const GUID IID_IMFMediaSourceEx                                 = GUIDOF!IMFMediaSourceEx;
const GUID IID_IMFMediaSourceExtension                          = GUIDOF!IMFMediaSourceExtension;
const GUID IID_IMFMediaSourceExtensionLiveSeekableRange         = GUIDOF!IMFMediaSourceExtensionLiveSeekableRange;
const GUID IID_IMFMediaSourceExtensionNotify                    = GUIDOF!IMFMediaSourceExtensionNotify;
const GUID IID_IMFMediaSourcePresentationProvider               = GUIDOF!IMFMediaSourcePresentationProvider;
const GUID IID_IMFMediaSourceTopologyProvider                   = GUIDOF!IMFMediaSourceTopologyProvider;
const GUID IID_IMFMediaStream                                   = GUIDOF!IMFMediaStream;
const GUID IID_IMFMediaStream2                                  = GUIDOF!IMFMediaStream2;
const GUID IID_IMFMediaStreamSourceSampleRequest                = GUIDOF!IMFMediaStreamSourceSampleRequest;
const GUID IID_IMFMediaTimeRange                                = GUIDOF!IMFMediaTimeRange;
const GUID IID_IMFMediaType                                     = GUIDOF!IMFMediaType;
const GUID IID_IMFMediaTypeHandler                              = GUIDOF!IMFMediaTypeHandler;
const GUID IID_IMFMetadata                                      = GUIDOF!IMFMetadata;
const GUID IID_IMFMetadataProvider                              = GUIDOF!IMFMetadataProvider;
const GUID IID_IMFMuxStreamAttributesManager                    = GUIDOF!IMFMuxStreamAttributesManager;
const GUID IID_IMFMuxStreamMediaTypeManager                     = GUIDOF!IMFMuxStreamMediaTypeManager;
const GUID IID_IMFMuxStreamSampleManager                        = GUIDOF!IMFMuxStreamSampleManager;
const GUID IID_IMFNetCredential                                 = GUIDOF!IMFNetCredential;
const GUID IID_IMFNetCredentialCache                            = GUIDOF!IMFNetCredentialCache;
const GUID IID_IMFNetCredentialManager                          = GUIDOF!IMFNetCredentialManager;
const GUID IID_IMFNetCrossOriginSupport                         = GUIDOF!IMFNetCrossOriginSupport;
const GUID IID_IMFNetProxyLocator                               = GUIDOF!IMFNetProxyLocator;
const GUID IID_IMFNetProxyLocatorFactory                        = GUIDOF!IMFNetProxyLocatorFactory;
const GUID IID_IMFNetResourceFilter                             = GUIDOF!IMFNetResourceFilter;
const GUID IID_IMFNetSchemeHandlerConfig                        = GUIDOF!IMFNetSchemeHandlerConfig;
const GUID IID_IMFObjectReferenceStream                         = GUIDOF!IMFObjectReferenceStream;
const GUID IID_IMFOutputPolicy                                  = GUIDOF!IMFOutputPolicy;
const GUID IID_IMFOutputSchema                                  = GUIDOF!IMFOutputSchema;
const GUID IID_IMFOutputTrustAuthority                          = GUIDOF!IMFOutputTrustAuthority;
const GUID IID_IMFPMPClient                                     = GUIDOF!IMFPMPClient;
const GUID IID_IMFPMPClientApp                                  = GUIDOF!IMFPMPClientApp;
const GUID IID_IMFPMPHost                                       = GUIDOF!IMFPMPHost;
const GUID IID_IMFPMPHostApp                                    = GUIDOF!IMFPMPHostApp;
const GUID IID_IMFPMPServer                                     = GUIDOF!IMFPMPServer;
const GUID IID_IMFPMediaItem                                    = GUIDOF!IMFPMediaItem;
const GUID IID_IMFPMediaPlayer                                  = GUIDOF!IMFPMediaPlayer;
const GUID IID_IMFPMediaPlayerCallback                          = GUIDOF!IMFPMediaPlayerCallback;
const GUID IID_IMFPluginControl                                 = GUIDOF!IMFPluginControl;
const GUID IID_IMFPluginControl2                                = GUIDOF!IMFPluginControl2;
const GUID IID_IMFPresentationClock                             = GUIDOF!IMFPresentationClock;
const GUID IID_IMFPresentationDescriptor                        = GUIDOF!IMFPresentationDescriptor;
const GUID IID_IMFPresentationTimeSource                        = GUIDOF!IMFPresentationTimeSource;
const GUID IID_IMFProtectedEnvironmentAccess                    = GUIDOF!IMFProtectedEnvironmentAccess;
const GUID IID_IMFQualityAdvise                                 = GUIDOF!IMFQualityAdvise;
const GUID IID_IMFQualityAdvise2                                = GUIDOF!IMFQualityAdvise2;
const GUID IID_IMFQualityAdviseLimits                           = GUIDOF!IMFQualityAdviseLimits;
const GUID IID_IMFQualityManager                                = GUIDOF!IMFQualityManager;
const GUID IID_IMFRateControl                                   = GUIDOF!IMFRateControl;
const GUID IID_IMFRateSupport                                   = GUIDOF!IMFRateSupport;
const GUID IID_IMFReadWriteClassFactory                         = GUIDOF!IMFReadWriteClassFactory;
const GUID IID_IMFRealTimeClient                                = GUIDOF!IMFRealTimeClient;
const GUID IID_IMFRealTimeClientEx                              = GUIDOF!IMFRealTimeClientEx;
const GUID IID_IMFRelativePanelReport                           = GUIDOF!IMFRelativePanelReport;
const GUID IID_IMFRelativePanelWatcher                          = GUIDOF!IMFRelativePanelWatcher;
const GUID IID_IMFRemoteAsyncCallback                           = GUIDOF!IMFRemoteAsyncCallback;
const GUID IID_IMFRemoteDesktopPlugin                           = GUIDOF!IMFRemoteDesktopPlugin;
const GUID IID_IMFRemoteProxy                                   = GUIDOF!IMFRemoteProxy;
const GUID IID_IMFSAMIStyle                                     = GUIDOF!IMFSAMIStyle;
const GUID IID_IMFSSLCertificateManager                         = GUIDOF!IMFSSLCertificateManager;
const GUID IID_IMFSample                                        = GUIDOF!IMFSample;
const GUID IID_IMFSampleAllocatorControl                        = GUIDOF!IMFSampleAllocatorControl;
const GUID IID_IMFSampleGrabberSinkCallback                     = GUIDOF!IMFSampleGrabberSinkCallback;
const GUID IID_IMFSampleGrabberSinkCallback2                    = GUIDOF!IMFSampleGrabberSinkCallback2;
const GUID IID_IMFSampleOutputStream                            = GUIDOF!IMFSampleOutputStream;
const GUID IID_IMFSampleProtection                              = GUIDOF!IMFSampleProtection;
const GUID IID_IMFSaveJob                                       = GUIDOF!IMFSaveJob;
const GUID IID_IMFSchemeHandler                                 = GUIDOF!IMFSchemeHandler;
const GUID IID_IMFSecureBuffer                                  = GUIDOF!IMFSecureBuffer;
const GUID IID_IMFSecureChannel                                 = GUIDOF!IMFSecureChannel;
const GUID IID_IMFSeekInfo                                      = GUIDOF!IMFSeekInfo;
const GUID IID_IMFSensorActivitiesReport                        = GUIDOF!IMFSensorActivitiesReport;
const GUID IID_IMFSensorActivitiesReportCallback                = GUIDOF!IMFSensorActivitiesReportCallback;
const GUID IID_IMFSensorActivityMonitor                         = GUIDOF!IMFSensorActivityMonitor;
const GUID IID_IMFSensorActivityReport                          = GUIDOF!IMFSensorActivityReport;
const GUID IID_IMFSensorDevice                                  = GUIDOF!IMFSensorDevice;
const GUID IID_IMFSensorGroup                                   = GUIDOF!IMFSensorGroup;
const GUID IID_IMFSensorProcessActivity                         = GUIDOF!IMFSensorProcessActivity;
const GUID IID_IMFSensorProfile                                 = GUIDOF!IMFSensorProfile;
const GUID IID_IMFSensorProfileCollection                       = GUIDOF!IMFSensorProfileCollection;
const GUID IID_IMFSensorStream                                  = GUIDOF!IMFSensorStream;
const GUID IID_IMFSensorTransformFactory                        = GUIDOF!IMFSensorTransformFactory;
const GUID IID_IMFSequencerSource                               = GUIDOF!IMFSequencerSource;
const GUID IID_IMFSharingEngineClassFactory                     = GUIDOF!IMFSharingEngineClassFactory;
const GUID IID_IMFShutdown                                      = GUIDOF!IMFShutdown;
const GUID IID_IMFSignedLibrary                                 = GUIDOF!IMFSignedLibrary;
const GUID IID_IMFSimpleAudioVolume                             = GUIDOF!IMFSimpleAudioVolume;
const GUID IID_IMFSinkWriter                                    = GUIDOF!IMFSinkWriter;
const GUID IID_IMFSinkWriterCallback                            = GUIDOF!IMFSinkWriterCallback;
const GUID IID_IMFSinkWriterCallback2                           = GUIDOF!IMFSinkWriterCallback2;
const GUID IID_IMFSinkWriterEncoderConfig                       = GUIDOF!IMFSinkWriterEncoderConfig;
const GUID IID_IMFSinkWriterEx                                  = GUIDOF!IMFSinkWriterEx;
const GUID IID_IMFSourceBuffer                                  = GUIDOF!IMFSourceBuffer;
const GUID IID_IMFSourceBufferAppendMode                        = GUIDOF!IMFSourceBufferAppendMode;
const GUID IID_IMFSourceBufferList                              = GUIDOF!IMFSourceBufferList;
const GUID IID_IMFSourceBufferNotify                            = GUIDOF!IMFSourceBufferNotify;
const GUID IID_IMFSourceOpenMonitor                             = GUIDOF!IMFSourceOpenMonitor;
const GUID IID_IMFSourceReader                                  = GUIDOF!IMFSourceReader;
const GUID IID_IMFSourceReaderCallback                          = GUIDOF!IMFSourceReaderCallback;
const GUID IID_IMFSourceReaderCallback2                         = GUIDOF!IMFSourceReaderCallback2;
const GUID IID_IMFSourceReaderEx                                = GUIDOF!IMFSourceReaderEx;
const GUID IID_IMFSourceResolver                                = GUIDOF!IMFSourceResolver;
const GUID IID_IMFSpatialAudioObjectBuffer                      = GUIDOF!IMFSpatialAudioObjectBuffer;
const GUID IID_IMFSpatialAudioSample                            = GUIDOF!IMFSpatialAudioSample;
const GUID IID_IMFStreamDescriptor                              = GUIDOF!IMFStreamDescriptor;
const GUID IID_IMFStreamSink                                    = GUIDOF!IMFStreamSink;
const GUID IID_IMFStreamingSinkConfig                           = GUIDOF!IMFStreamingSinkConfig;
const GUID IID_IMFSystemId                                      = GUIDOF!IMFSystemId;
const GUID IID_IMFTimecodeTranslate                             = GUIDOF!IMFTimecodeTranslate;
const GUID IID_IMFTimedText                                     = GUIDOF!IMFTimedText;
const GUID IID_IMFTimedTextBinary                               = GUIDOF!IMFTimedTextBinary;
const GUID IID_IMFTimedTextCue                                  = GUIDOF!IMFTimedTextCue;
const GUID IID_IMFTimedTextCueList                              = GUIDOF!IMFTimedTextCueList;
const GUID IID_IMFTimedTextFormattedText                        = GUIDOF!IMFTimedTextFormattedText;
const GUID IID_IMFTimedTextNotify                               = GUIDOF!IMFTimedTextNotify;
const GUID IID_IMFTimedTextRegion                               = GUIDOF!IMFTimedTextRegion;
const GUID IID_IMFTimedTextStyle                                = GUIDOF!IMFTimedTextStyle;
const GUID IID_IMFTimedTextTrack                                = GUIDOF!IMFTimedTextTrack;
const GUID IID_IMFTimedTextTrackList                            = GUIDOF!IMFTimedTextTrackList;
const GUID IID_IMFTimer                                         = GUIDOF!IMFTimer;
const GUID IID_IMFTopoLoader                                    = GUIDOF!IMFTopoLoader;
const GUID IID_IMFTopology                                      = GUIDOF!IMFTopology;
const GUID IID_IMFTopologyNode                                  = GUIDOF!IMFTopologyNode;
const GUID IID_IMFTopologyNodeAttributeEditor                   = GUIDOF!IMFTopologyNodeAttributeEditor;
const GUID IID_IMFTopologyServiceLookup                         = GUIDOF!IMFTopologyServiceLookup;
const GUID IID_IMFTopologyServiceLookupClient                   = GUIDOF!IMFTopologyServiceLookupClient;
const GUID IID_IMFTrackedSample                                 = GUIDOF!IMFTrackedSample;
const GUID IID_IMFTranscodeProfile                              = GUIDOF!IMFTranscodeProfile;
const GUID IID_IMFTranscodeSinkInfoProvider                     = GUIDOF!IMFTranscodeSinkInfoProvider;
const GUID IID_IMFTransform                                     = GUIDOF!IMFTransform;
const GUID IID_IMFTrustedInput                                  = GUIDOF!IMFTrustedInput;
const GUID IID_IMFTrustedOutput                                 = GUIDOF!IMFTrustedOutput;
const GUID IID_IMFVideoCaptureSampleAllocator                   = GUIDOF!IMFVideoCaptureSampleAllocator;
const GUID IID_IMFVideoDeviceID                                 = GUIDOF!IMFVideoDeviceID;
const GUID IID_IMFVideoDisplayControl                           = GUIDOF!IMFVideoDisplayControl;
const GUID IID_IMFVideoMediaType                                = GUIDOF!IMFVideoMediaType;
const GUID IID_IMFVideoMixerBitmap                              = GUIDOF!IMFVideoMixerBitmap;
const GUID IID_IMFVideoMixerControl                             = GUIDOF!IMFVideoMixerControl;
const GUID IID_IMFVideoMixerControl2                            = GUIDOF!IMFVideoMixerControl2;
const GUID IID_IMFVideoPositionMapper                           = GUIDOF!IMFVideoPositionMapper;
const GUID IID_IMFVideoPresenter                                = GUIDOF!IMFVideoPresenter;
const GUID IID_IMFVideoProcessor                                = GUIDOF!IMFVideoProcessor;
const GUID IID_IMFVideoProcessorControl                         = GUIDOF!IMFVideoProcessorControl;
const GUID IID_IMFVideoProcessorControl2                        = GUIDOF!IMFVideoProcessorControl2;
const GUID IID_IMFVideoProcessorControl3                        = GUIDOF!IMFVideoProcessorControl3;
const GUID IID_IMFVideoRenderer                                 = GUIDOF!IMFVideoRenderer;
const GUID IID_IMFVideoRendererEffectControl                    = GUIDOF!IMFVideoRendererEffectControl;
const GUID IID_IMFVideoSampleAllocator                          = GUIDOF!IMFVideoSampleAllocator;
const GUID IID_IMFVideoSampleAllocatorCallback                  = GUIDOF!IMFVideoSampleAllocatorCallback;
const GUID IID_IMFVideoSampleAllocatorEx                        = GUIDOF!IMFVideoSampleAllocatorEx;
const GUID IID_IMFVideoSampleAllocatorNotify                    = GUIDOF!IMFVideoSampleAllocatorNotify;
const GUID IID_IMFVideoSampleAllocatorNotifyEx                  = GUIDOF!IMFVideoSampleAllocatorNotifyEx;
const GUID IID_IMFWorkQueueServices                             = GUIDOF!IMFWorkQueueServices;
const GUID IID_IMFWorkQueueServicesEx                           = GUIDOF!IMFWorkQueueServicesEx;
const GUID IID_IOPMVideoOutput                                  = GUIDOF!IOPMVideoOutput;
const GUID IID_IPlayToControl                                   = GUIDOF!IPlayToControl;
const GUID IID_IPlayToControlWithCapabilities                   = GUIDOF!IPlayToControlWithCapabilities;
const GUID IID_IPlayToSourceClassFactory                        = GUIDOF!IPlayToSourceClassFactory;
const GUID IID_IToc                                             = GUIDOF!IToc;
const GUID IID_ITocCollection                                   = GUIDOF!ITocCollection;
const GUID IID_ITocEntry                                        = GUIDOF!ITocEntry;
const GUID IID_ITocEntryList                                    = GUIDOF!ITocEntryList;
const GUID IID_ITocParser                                       = GUIDOF!ITocParser;
const GUID IID_IValidateBinding                                 = GUIDOF!IValidateBinding;
const GUID IID_IWMCodecLeakyBucket                              = GUIDOF!IWMCodecLeakyBucket;
const GUID IID_IWMCodecOutputTimestamp                          = GUIDOF!IWMCodecOutputTimestamp;
const GUID IID_IWMCodecPrivateData                              = GUIDOF!IWMCodecPrivateData;
const GUID IID_IWMCodecProps                                    = GUIDOF!IWMCodecProps;
const GUID IID_IWMCodecStrings                                  = GUIDOF!IWMCodecStrings;
const GUID IID_IWMColorConvProps                                = GUIDOF!IWMColorConvProps;
const GUID IID_IWMColorLegalizerProps                           = GUIDOF!IWMColorLegalizerProps;
const GUID IID_IWMFrameInterpProps                              = GUIDOF!IWMFrameInterpProps;
const GUID IID_IWMInterlaceProps                                = GUIDOF!IWMInterlaceProps;
const GUID IID_IWMResamplerProps                                = GUIDOF!IWMResamplerProps;
const GUID IID_IWMResizerProps                                  = GUIDOF!IWMResizerProps;
const GUID IID_IWMSampleExtensionSupport                        = GUIDOF!IWMSampleExtensionSupport;
const GUID IID_IWMValidate                                      = GUIDOF!IWMValidate;
const GUID IID_IWMVideoDecoderHurryup                           = GUIDOF!IWMVideoDecoderHurryup;
const GUID IID_IWMVideoDecoderReconBuffer                       = GUIDOF!IWMVideoDecoderReconBuffer;
const GUID IID_IWMVideoForceKeyFrame                            = GUIDOF!IWMVideoForceKeyFrame;
