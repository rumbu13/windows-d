// Written in the D programming language.

module windows.com;

public import windows.core;
public import windows.automation : BSTR, IDispatch, IErrorLog, IPropertyBag,
                                   ITypeInfo, VARIANT;
public import windows.componentservices : IEventObjectCollection;
public import windows.controls : PROPSHEETHEADERA_V2, PROPSHEETHEADERW_V2;
public import windows.displaydevices : POINT, POINTL, RECT, RECTL, SIZE;
public import windows.gdi : HBITMAP, HCURSOR, HDC, HFONT, HICON, HPALETTE, HRGN,
                            LOGPALETTE, TEXTMETRICW;
public import windows.menusandresources : HACCEL, HMENU;
public import windows.security : TRUSTEE_A, TRUSTEE_W;
public import windows.shell : SOFTDISTINFO, UNDOCK_REASON;
public import windows.structuredstorage : IStorage, IStream;
public import windows.systemservices : BOOL, CY, HANDLE, HINSTANCE, IServiceProvider,
                                       LARGE_INTEGER, LRESULT, SECURITY_ATTRIBUTES,
                                       ULARGE_INTEGER, uCLSSPEC, userHBITMAP,
                                       userHENHMETAFILE, userHGLOBAL,
                                       userHMETAFILEPICT, userHPALETTE;
public import windows.winrt : IInspectable;
public import windows.winsock : BLOB;
public import windows.windowsandmessaging : HWND, LPARAM, MSG, OPENFILENAMEA, OPENFILENAMEW,
                                            WPARAM;
public import windows.windowsprogramming : FILETIME, IXMLElement, SYSTEMTIME;

extern(Windows):


// Enums


alias MEMCTX = int;
enum : int
{
    MEMCTX_TASK      = 0x00000001,
    MEMCTX_SHARED    = 0x00000002,
    MEMCTX_MACSYSTEM = 0x00000003,
    MEMCTX_UNKNOWN   = 0xffffffff,
    MEMCTX_SAME      = 0xfffffffe,
}

///Values that are used in activation calls to indicate the execution contexts in which an object is to be run. These
///values are also used in calls to CoRegisterClassObject to indicate the set of execution contexts in which a class
///object is to be made available for requests to construct instances.
alias CLSCTX = int;
enum : int
{
    ///The code that creates and manages objects of this class is a DLL that runs in the same process as the caller of
    ///the function specifying the class context.
    CLSCTX_INPROC_SERVER          = 0x00000001,
    ///The code that manages objects of this class is an in-process handler. This is a DLL that runs in the client
    ///process and implements client-side structures of this class when instances of the class are accessed remotely.
    CLSCTX_INPROC_HANDLER         = 0x00000002,
    ///The EXE code that creates and manages objects of this class runs on same machine but is loaded in a separate
    ///process space.
    CLSCTX_LOCAL_SERVER           = 0x00000004,
    ///Obsolete.
    CLSCTX_INPROC_SERVER16        = 0x00000008,
    ///A remote context. The LocalServer32 or LocalService code that creates and manages objects of this class is run on
    ///a different computer.
    CLSCTX_REMOTE_SERVER          = 0x00000010,
    ///Obsolete.
    CLSCTX_INPROC_HANDLER16       = 0x00000020,
    ///Reserved.
    CLSCTX_RESERVED1              = 0x00000040,
    ///Reserved.
    CLSCTX_RESERVED2              = 0x00000080,
    ///Reserved.
    CLSCTX_RESERVED3              = 0x00000100,
    ///Reserved.
    CLSCTX_RESERVED4              = 0x00000200,
    ///Disables the downloading of code from the directory service or the Internet. This flag cannot be set at the same
    ///time as CLSCTX_ENABLE_CODE_DOWNLOAD.
    CLSCTX_NO_CODE_DOWNLOAD       = 0x00000400,
    ///Reserved.
    CLSCTX_RESERVED5              = 0x00000800,
    ///Specify if you want the activation to fail if it uses custom marshalling.
    CLSCTX_NO_CUSTOM_MARSHAL      = 0x00001000,
    ///Enables the downloading of code from the directory service or the Internet. This flag cannot be set at the same
    ///time as CLSCTX_NO_CODE_DOWNLOAD.
    CLSCTX_ENABLE_CODE_DOWNLOAD   = 0x00002000,
    ///The CLSCTX_NO_FAILURE_LOG can be used to override the logging of failures in CoCreateInstanceEx. If the
    ///ActivationFailureLoggingLevel is created, the following values can determine the status of event logging: <ul>
    ///<li>0 = Discretionary logging. Log by default, but clients can override by specifying CLSCTX_NO_FAILURE_LOG in
    ///CoCreateInstanceEx.</li> <li>1 = Always log all failures no matter what the client specified.</li> <li>2 = Never
    ///log any failures no matter what client specified. If the registry entry is missing, the default is 0. If you need
    ///to control customer applications, it is recommended that you set this value to 0 and write the client code to
    ///override failures. It is strongly recommended that you do not set the value to 2. If event logging is disabled,
    ///it is more difficult to diagnose problems. </li> </ul>
    CLSCTX_NO_FAILURE_LOG         = 0x00004000,
    ///Disables activate-as-activator (AAA) activations for this activation only. This flag overrides the setting of the
    ///EOAC_DISABLE_AAA flag from the EOLE_AUTHENTICATION_CAPABILITIES enumeration. This flag cannot be set at the same
    ///time as CLSCTX_ENABLE_AAA. Any activation where a server process would be launched under the caller's identity is
    ///known as an activate-as-activator (AAA) activation. Disabling AAA activations allows an application that runs
    ///under a privileged account (such as LocalSystem) to help prevent its identity from being used to launch untrusted
    ///components. Library applications that use activation calls should always set this flag during those calls. This
    ///helps prevent the library application from being used in an escalation-of-privilege security attack. This is the
    ///only way to disable AAA activations in a library application because the EOAC_DISABLE_AAA flag from the
    ///EOLE_AUTHENTICATION_CAPABILITIES enumeration is applied only to the server process and not to the library
    ///application. <b>Windows 2000: </b>This flag is not supported.
    CLSCTX_DISABLE_AAA            = 0x00008000,
    ///Enables activate-as-activator (AAA) activations for this activation only. This flag overrides the setting of the
    ///EOAC_DISABLE_AAA flag from the EOLE_AUTHENTICATION_CAPABILITIES enumeration. This flag cannot be set at the same
    ///time as CLSCTX_DISABLE_AAA. Any activation where a server process would be launched under the caller's identity
    ///is known as an activate-as-activator (AAA) activation. Enabling this flag allows an application to transfer its
    ///identity to an activated component. <b>Windows 2000: </b>This flag is not supported.
    CLSCTX_ENABLE_AAA             = 0x00010000,
    ///Begin this activation from the default context of the current apartment.
    CLSCTX_FROM_DEFAULT_CONTEXT   = 0x00020000,
    CLSCTX_ACTIVATE_X86_SERVER    = 0x00040000,
    ///Activate or connect to a 32-bit version of the server; fail if one is not registered.
    CLSCTX_ACTIVATE_32_BIT_SERVER = 0x00040000,
    ///Activate or connect to a 64 bit version of the server; fail if one is not registered.
    CLSCTX_ACTIVATE_64_BIT_SERVER = 0x00080000,
    ///When this flag is specified, COM uses the impersonation token of the thread, if one is present, for the
    ///activation request made by the thread. When this flag is not specified or if the thread does not have an
    ///impersonation token, COM uses the process token of the thread's process for the activation request made by the
    ///thread. <b>Windows Vista or later: </b>This flag is supported.
    CLSCTX_ENABLE_CLOAKING        = 0x00100000,
    ///Indicates activation is for an app container. <div class="alert"><b>Note</b> This flag is reserved for internal
    ///use and is not intended to be used directly from your code.</div> <div> </div>
    CLSCTX_APPCONTAINER           = 0x00400000,
    ///Specify this flag for Interactive User activation behavior for As-Activator servers. A strongly named Medium IL
    ///Windows Store app can use this flag to launch an "As Activator" COM server without a strong name. Also, you can
    ///use this flag to bind to a running instance of the COM server that's launched by a desktop application. The
    ///client must be Medium IL, it must be strongly named, which means that it has a SysAppID in the client token, it
    ///can't be in session 0, and it must have the same user as the session ID's user in the client token. If the server
    ///is out-of-process and "As Activator", it launches the server with the token of the client token's session user.
    ///This token won't be strongly named. If the server is out-of-process and RunAs "Interactive User", this flag has
    ///no effect. If the server is out-of-process and is any other RunAs type, the activation fails. This flag has no
    ///effect for in-process servers. Off-machine activations fail when they use this flag.
    CLSCTX_ACTIVATE_AAA_AS_IU     = 0x00800000,
    CLSCTX_RESERVED6              = 0x01000000,
    CLSCTX_ACTIVATE_ARM32_SERVER  = 0x02000000,
    ///Used for loading Proxy/Stub DLLs. <div class="alert"><b>Note</b> This flag is reserved for internal use and is
    ///not intended to be used directly from your code.</div> <div> </div>
    CLSCTX_PS_DLL                 = 0x80000000,
}

///Specifies why the marshaling is to be done.
alias MSHLFLAGS = int;
enum : int
{
    ///The marshaling is occurring because an interface pointer is being passed from one process to another. This is the
    ///normal case. The data packet produced by the marshaling process will be unmarshaled in the destination process.
    ///The marshaled data packet can be unmarshaled just once, or not at all. If the receiver unmarshals the data packet
    ///successfully, the CoReleaseMarshalData function is automatically called on the data packet as part of the
    ///unmarshaling process. If the receiver does not or cannot unmarshal the data packet, the sender must call
    ///<b>CoReleaseMarshalData</b> on the data packet.
    MSHLFLAGS_NORMAL      = 0x00000000,
    ///The marshaling is occurring because the data packet is to be stored in a globally accessible table from which it
    ///can be unmarshaled one or more times, or not at all. The presence of the data packet in the table counts as a
    ///strong reference to the interface being marshaled, meaning that it is sufficient to keep the object alive. When
    ///the data packet is removed from the table, the table implementer must call the CoReleaseMarshalData function on
    ///the data packet. MSHLFLAGS_TABLESTRONG is used by the RegisterDragDrop function when registering a window as a
    ///drop target. This keeps the window registered as a drop target no matter how many times the end user drags across
    ///the window. The RevokeDragDrop function calls CoReleaseMarshalData.
    MSHLFLAGS_TABLESTRONG = 0x00000001,
    ///The marshaling is occurring because the data packet is to be stored in a globally accessible table from which it
    ///can be unmarshaled one or more times, or not at all. However, the presence of the data packet in the table acts
    ///as a weak reference to the interface being marshaled, meaning that it is not sufficient to keep the object alive.
    ///When the data packet is removed from the table, the table implementer must call the CoReleaseMarshalData function
    ///on the data packet. MSHLFLAGS_TABLEWEAK is typically used when registering an object in the running object table
    ///(ROT). This prevents the object's entry in the ROT from keeping the object alive in the absence of any other
    ///connections. See IRunningObjectTable::Register for more information.
    MSHLFLAGS_TABLEWEAK   = 0x00000002,
    ///Adding this flag to an original object marshaling (as opposed to marshaling a proxy) will disable the ping
    ///protocol for that object.
    MSHLFLAGS_NOPING      = 0x00000004,
    MSHLFLAGS_RESERVED1   = 0x00000008,
    MSHLFLAGS_RESERVED2   = 0x00000010,
    MSHLFLAGS_RESERVED3   = 0x00000020,
    MSHLFLAGS_RESERVED4   = 0x00000040,
}

///Specifies the destination context, which is the process in which the unmarshaling is to be done.
alias MSHCTX = int;
enum : int
{
    ///The unmarshaling process is local and has shared memory access with the marshaling process.
    MSHCTX_LOCAL            = 0x00000000,
    ///The unmarshaling process does not have shared memory access with the marshaling process.
    MSHCTX_NOSHAREDMEM      = 0x00000001,
    ///The unmarshaling process is on a different computer. The marshaling code cannot assume that a particular piece of
    ///application code is installed on that computer.
    MSHCTX_DIFFERENTMACHINE = 0x00000002,
    ///The unmarshaling will be done in another apartment in the same process.
    MSHCTX_INPROC           = 0x00000003,
    ///Create a new context in the current apartment.
    MSHCTX_CROSSCTX         = 0x00000004,
    MSHCTX_RESERVED1        = 0x00000005,
}

///Controls the type of connections to a class object.
alias REGCLS = int;
enum : int
{
    ///After an application is connected to a class object with CoGetClassObject, the class object is removed from
    ///public view so that no other applications can connect to it. This value is commonly used for single document
    ///interface (SDI) applications. Specifying this value does not affect the responsibility of the object application
    ///to call CoRevokeClassObject; it must always call <b>CoRevokeClassObject</b> when it is finished with an object
    ///class.
    REGCLS_SINGLEUSE      = 0x00000000,
    ///Multiple applications can connect to the class object through calls to CoGetClassObject. If both the
    ///REGCLS_MULTIPLEUSE and CLSCTX_LOCAL_SERVER are set in a call to CoRegisterClassObject, the class object is also
    ///automatically registered as an in-process server, whether CLSCTX_INPROC_SERVER is explicitly set.
    REGCLS_MULTIPLEUSE    = 0x00000001,
    ///Useful for registering separate CLSCTX_LOCAL_SERVER and CLSCTX_INPROC_SERVER class factories through calls to
    ///CoGetClassObject. If REGCLS_MULTI_SEPARATE is set, each execution context must be set separately;
    ///CoRegisterClassObject does not automatically register an out-of-process server (for which CLSCTX_LOCAL_SERVER is
    ///set) as an in-process server. This allows the EXE to create multiple instances of the object for in-process
    ///needs, such as self embeddings, without disturbing its CLSCTX_LOCAL_SERVER registration. If an EXE registers a
    ///REGCLS_MULTI_SEPARATE class factory and a CLSCTX_INPROC_SERVER class factory, instance creation calls that
    ///specify CLSCTX_INPROC_SERVER in the CLSCTX parameter executed by the EXE would be satisfied locally without
    ///approaching the SCM. This mechanism is useful when the EXE uses functions such as OleCreate and OleLoad to create
    ///embeddings, but at the same does not wish to launch a new instance of itself for the self-embedding case. The
    ///distinction is important for embeddings because the default handler aggregates the proxy manager by default and
    ///the application should override this default behavior by calling OleCreateEmbeddingHelper for the self-embedding
    ///case. If your application need not distinguish between the local and inproc case, you need not register your
    ///class factory using REGCLS_MULTI_SEPARATE. In fact, the application incurs an extra network round trip to the SCM
    ///when it registers its MULTIPLEUSE class factory as MULTI_SEPARATE and does not register another class factory as
    ///INPROC_SERVER.
    REGCLS_MULTI_SEPARATE = 0x00000002,
    ///Suspends registration and activation requests for the specified CLSID until there is a call to
    ///CoResumeClassObjects. This is used typically to register the CLSIDs for servers that can register multiple class
    ///objects to reduce the overall registration time, and thus the server application startup time, by making a single
    ///call to the SCM, no matter how many CLSIDs are registered for the server. <div class="alert"><b>Note</b> This
    ///flag prevents COM activation errors from a possible race condition between an application shutting down and that
    ///application attempting to register a COM class.</div> <div> </div>
    REGCLS_SUSPENDED      = 0x00000004,
    ///The class object is a surrogate process used to run DLL servers. The class factory registered by the surrogate
    ///process is not the actual class factory implemented by the DLL server, but a generic class factory implemented by
    ///the surrogate. This generic class factory delegates instance creation and marshaling to the class factory of the
    ///DLL server running in the surrogate. For further information on DLL surrogates, see the DllSurrogate registry
    ///value.
    REGCLS_SURROGATE      = 0x00000008,
    ///The class object aggregates the free-threaded marshaler and will be made visible to all inproc apartments. Can be
    ///used together with other flags. For example, REGCLS_AGILE | REGCLS_MULTIPLEUSE to register a class object that
    ///can be used multiple times from different apartments. Without other flags, behavior will retain REGCLS_SINGLEUSE
    ///semantics in that only one instance can be generated.
    REGCLS_AGILE          = 0x00000010,
}

alias COINITBASE = int;
enum : int
{
    COINITBASE_MULTITHREADED = 0x00000000,
}

///Specifies the type of external connection existing on an embedded object.
alias EXTCONN = int;
enum : int
{
    ///The external connection is a link. If this value is specified, the external connection must keep the object alive
    ///until all strong external connections are cleared through IExternalConnection::ReleaseConnection.
    EXTCONN_STRONG   = 0x00000001,
    ///This value is not used.
    EXTCONN_WEAK     = 0x00000002,
    ///This value is not used.
    EXTCONN_CALLABLE = 0x00000004,
}

///Specifies various capabilities in CoInitializeSecurity and IClientSecurity::SetBlanket (or its helper function
///CoSetProxyBlanket).
alias EOLE_AUTHENTICATION_CAPABILITIES = int;
enum : int
{
    ///Indicates that no capability flags are set.
    EOAC_NONE              = 0x00000000,
    ///If this flag is specified, it will be ignored. Support for mutual authentication is automatically provided by
    ///some authentication services. See COM and Security Packages for more information.
    EOAC_MUTUAL_AUTH       = 0x00000001,
    ///Sets static cloaking. When this flag is set, DCOM uses the thread token (if present) when determining the
    ///client's identity. However, the client's identity is determined on the first call on each proxy (if SetBlanket is
    ///not called) and each time CoSetProxyBlanket is called on the proxy. For more information about static cloaking,
    ///see Cloaking. CoInitializeSecurity and IClientSecurity::SetBlanket return errors if both cloaking flags are set
    ///or if either flag is set when Schannel is the authentication service.
    EOAC_STATIC_CLOAKING   = 0x00000020,
    ///Sets dynamic cloaking. When this flag is set, DCOM uses the thread token (if present) when determining the
    ///client's identity. On each call to a proxy, the current thread token is examined to determine whether the
    ///client's identity has changed (incurring an additional performance cost) and the client is authenticated again
    ///only if necessary. Dynamic cloaking can be set by clients only. For more information about dynamic cloaking, see
    ///Cloaking. CoInitializeSecurity and IClientSecurity::SetBlanket return errors if both cloaking flags are set or if
    ///either flag is set when Schannel is the authentication service.
    EOAC_DYNAMIC_CLOAKING  = 0x00000040,
    ///This flag is obsolete.
    EOAC_ANY_AUTHORITY     = 0x00000080,
    ///Causes DCOM to send Schannel server principal names in fullsic format to clients as part of the default security
    ///negotiation. The name is extracted from the server certificate. For more information about the fullsic form, see
    ///Principal Names.
    EOAC_MAKE_FULLSIC      = 0x00000100,
    ///Tells DCOM to use the valid capabilities from the call to CoInitializeSecurity. If <b>CoInitializeSecurity</b>
    ///was not called, EOAC_NONE will be used for the capabilities flag. This flag can be set only by clients in a call
    ///to IClientSecurity::SetBlanket or CoSetProxyBlanket.
    EOAC_DEFAULT           = 0x00000800,
    ///Authenticates distributed reference count calls to prevent malicious users from releasing objects that are still
    ///being used. If this flag is set, which can be done only in a call to CoInitializeSecurity by the client, the
    ///authentication level (in <i>dwAuthnLevel</i>) cannot be set to none. The server always authenticates Release
    ///calls. Setting this flag prevents an authenticated client from releasing the objects of another authenticated
    ///client. It is recommended that clients always set this flag, although performance is affected because of the
    ///overhead associated with the extra security.
    EOAC_SECURE_REFS       = 0x00000002,
    ///Indicates that the <i>pSecDesc</i> parameter to CoInitializeSecurity is a pointer to an IAccessControl interface
    ///on an access control object. When DCOM makes security checks, it calls IAccessControl::IsAccessAllowed. This flag
    ///is set only by the server. CoInitializeSecurity returns an error if both the EOAC_APPID and EOAC_ACCESS_CONTROL
    ///flags are set.
    EOAC_ACCESS_CONTROL    = 0x00000004,
    ///Indicates that the <i>pSecDesc</i> parameter to CoInitializeSecurity is a pointer to a GUID that is an AppID. The
    ///<b>CoInitializeSecurity</b> function looks up the AppID in the registry and reads the security settings from
    ///there. If this flag is set, all other parameters to <b>CoInitializeSecurity</b> are ignored and must be zero.
    ///Only the server can set this flag. For more information about this capability flag, see the Remarks section
    ///below. CoInitializeSecurity returns an error if both the EOAC_APPID and EOAC_ACCESS_CONTROL flags are set.
    EOAC_APPID             = 0x00000008,
    ///Reserved.
    EOAC_DYNAMIC           = 0x00000010,
    ///Causes DCOM to fail CoSetProxyBlanket calls where an Schannel principal name is specified in any format other
    ///than fullsic. This flag is currently for clients only. For more information about the fullsic form, see Principal
    ///Names.
    EOAC_REQUIRE_FULLSIC   = 0x00000200,
    ///Reserved.
    EOAC_AUTO_IMPERSONATE  = 0x00000400,
    ///Causes any activation where a server process would be launched under the caller's identity
    ///(activate-as-activator) to fail with E_ACCESSDENIED. This value, which can be specified only in a call to
    ///CoInitializeSecurity by the client, allows an application that runs under a privileged account (such as
    ///LocalSystem) to help prevent its identity from being used to launch untrusted components. An activation call that
    ///uses CLSCTX_ENABLE_AAA of the CLSCTX enumeration will allow activate-as-activator activations for that call.
    EOAC_DISABLE_AAA       = 0x00001000,
    ///Specifying this flag helps protect server security when using DCOM or COM+. It reduces the chances of executing
    ///arbitrary DLLs because it allows the marshaling of only CLSIDs that are implemented in Ole32.dll, ComAdmin.dll,
    ///ComSvcs.dll, or Es.dll, or that implement the CATID_MARSHALER category ID. Any service that is critical to system
    ///operation should set this flag.
    EOAC_NO_CUSTOM_MARSHAL = 0x00002000,
    EOAC_RESERVED1         = 0x00004000,
}

alias RPCOPT_PROPERTIES = int;
enum : int
{
    COMBND_RPCTIMEOUT      = 0x00000001,
    COMBND_SERVER_LOCALITY = 0x00000002,
    COMBND_RESERVED1       = 0x00000004,
    COMBND_RESERVED2       = 0x00000005,
    COMBND_RESERVED3       = 0x00000008,
    COMBND_RESERVED4       = 0x00000010,
}

alias RPCOPT_SERVER_LOCALITY_VALUES = int;
enum : int
{
    SERVER_LOCALITY_PROCESS_LOCAL = 0x00000000,
    SERVER_LOCALITY_MACHINE_LOCAL = 0x00000001,
    SERVER_LOCALITY_REMOTE        = 0x00000002,
}

///Identifies process-global options that you can set or query by using the IGlobalOptions interface.
alias GLOBALOPT_PROPERTIES = int;
enum : int
{
    ///Defines COM exception-handling behavior.
    COMGLB_EXCEPTION_HANDLING     = 0x00000001,
    ///Sets the AppID for the process.
    COMGLB_APPID                  = 0x00000002,
    ///Sets the thread-pool behavior of the RPC runtime in the process.
    COMGLB_RPC_THREADPOOL_SETTING = 0x00000003,
    ///Used for miscellaneous settings.
    COMGLB_RO_SETTINGS            = 0x00000004,
    ///Defines the policy that's applied in the CoUnmarshalInterface function.
    COMGLB_UNMARSHALING_POLICY    = 0x00000005,
    COMGLB_PROPERTIES_RESERVED1   = 0x00000006,
    COMGLB_PROPERTIES_RESERVED2   = 0x00000007,
    COMGLB_PROPERTIES_RESERVED3   = 0x00000008,
}

alias GLOBALOPT_EH_VALUES = int;
enum : int
{
    COMGLB_EXCEPTION_HANDLE             = 0x00000000,
    COMGLB_EXCEPTION_DONOT_HANDLE_FATAL = 0x00000001,
    COMGLB_EXCEPTION_DONOT_HANDLE       = 0x00000001,
    COMGLB_EXCEPTION_DONOT_HANDLE_ANY   = 0x00000002,
}

alias GLOBALOPT_RPCTP_VALUES = int;
enum : int
{
    COMGLB_RPC_THREADPOOL_SETTING_DEFAULT_POOL = 0x00000000,
    COMGLB_RPC_THREADPOOL_SETTING_PRIVATE_POOL = 0x00000001,
}

alias GLOBALOPT_RO_FLAGS = int;
enum : int
{
    COMGLB_STA_MODALLOOP_REMOVE_TOUCH_MESSAGES                    = 0x00000001,
    COMGLB_STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES       = 0x00000002,
    COMGLB_STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES = 0x00000004,
    COMGLB_FAST_RUNDOWN                                           = 0x00000008,
    COMGLB_RESERVED1                                              = 0x00000010,
    COMGLB_RESERVED2                                              = 0x00000020,
    COMGLB_RESERVED3                                              = 0x00000040,
    COMGLB_STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES    = 0x00000080,
    COMGLB_RESERVED4                                              = 0x00000100,
    COMGLB_RESERVED5                                              = 0x00000200,
    COMGLB_RESERVED6                                              = 0x00000400,
}

///Provides values for the COM unmarshaling policy global option.
alias GLOBALOPT_UNMARSHALING_POLICY_VALUES = int;
enum : int
{
    ///Unmarshaling behavior is the same as versions older than Windows 8. <b>EOAC_NO_CUSTOM_MARSHAL</b> restrictions
    ///apply if this flag is set in CoInitializeSecurity. Otherwise, there are no restrictions. This is the default for
    ///processes that aren't in the app container.
    COMGLB_UNMARSHALING_POLICY_NORMAL = 0x00000000,
    ///Unmarshaling allows only a system-trusted list of hardened unmarshalers and unmarshalers allowed per-process by
    ///the CoAllowUnmarshalerCLSID function. This is the default for processes in the app container.
    COMGLB_UNMARSHALING_POLICY_STRONG = 0x00000001,
    ///Unmarshaling data whose source is app container allows only a system-trusted list of hardened unmarshalers and
    ///unmarshalers allowed per-process by the CoAllowUnmarshalerCLSID function. Unmarshaling behavior for data with a
    ///source that's not app container is unchanged from previous versions.
    COMGLB_UNMARSHALING_POLICY_HYBRID = 0x00000002,
}

alias DCOM_CALL_STATE = int;
enum : int
{
    DCOM_NONE          = 0x00000000,
    DCOM_CALL_COMPLETE = 0x00000001,
    DCOM_CALL_CANCELED = 0x00000002,
}

///Specifies the set of possible COM apartment type qualifiers.
alias APTTYPEQUALIFIER = int;
enum : int
{
    ///No qualifier information for the current COM apartment type is available.
    APTTYPEQUALIFIER_NONE               = 0x00000000,
    ///This qualifier is only valid when the <i>pAptType</i> parameter of the CoGetApartmentType function specifies
    ///APTTYPE_MTA on return. A thread has an implicit MTA apartment type if it does not initialize the COM apartment
    ///itself, and if another thread has already initialized the MTA in the process. This qualifier informs the API
    ///caller that the MTA of the thread is implicitly inherited from other threads and is not initialized directly.
    APTTYPEQUALIFIER_IMPLICIT_MTA       = 0x00000001,
    ///This qualifier is only valid when the <i>pAptType</i> parameter of the CoGetApartmentType function contains
    ///APTTYPE_NA on return. When an MTA thread creates or invokes a COM in-process object using the "Neutral" threading
    ///model, the COM apartment type of the thread switches from MTA to a Neutral apartment type. This qualifier informs
    ///the API caller that the thread has switched from the MTA apartment type to the NA type.
    APTTYPEQUALIFIER_NA_ON_MTA          = 0x00000002,
    ///This qualifier is only valid when the <i>pAptType</i> parameter of the CoGetApartmentType function contains
    ///APTTYPE_NA on return. When an STA thread creates or invokes a COM in-process object using the "Neutral" threading
    ///model, the COM apartment type of the thread switches from STA to a Neutral apartment type. This qualifier informs
    ///the API caller that the thread has switched from the STA apartment type to the NA type.
    APTTYPEQUALIFIER_NA_ON_STA          = 0x00000003,
    ///This qualifier is only valid when the <i>pAptType</i> parameter of the CoGetApartmentType function contains
    ///APTTYPE_NA on return. When an implicit MTA thread creates or invokes a COM in-process object using the "Neutral"
    ///threading model, the COM apartment type of the thread switches from the implicit MTA type to a Neutral apartment
    ///type. This qualifier informs the API caller that the thread has switched from the implicit MTA apartment type to
    ///the NA type.
    APTTYPEQUALIFIER_NA_ON_IMPLICIT_MTA = 0x00000004,
    ///This qualifier is only valid when the <i>pAptType</i> parameter of the CoGetApartmentType function contains
    ///APTTYPE_NA on return. When the main STA thread creates or invokes a COM in-process object using the "Neutral"
    ///threading model, the COM apartment type of the thread switches from the main STA type to a Neutral apartment
    ///type. This qualifier informs the API caller that the thread has switched from the main STA apartment type to the
    ///NA type.
    APTTYPEQUALIFIER_NA_ON_MAINSTA      = 0x00000005,
    APTTYPEQUALIFIER_APPLICATION_STA    = 0x00000006,
    APTTYPEQUALIFIER_RESERVED_1         = 0x00000007,
}

///Specifies different types of apartments.
alias APTTYPE = int;
enum : int
{
    ///The current thread.
    APTTYPE_CURRENT = 0xffffffff,
    ///A single-threaded apartment.
    APTTYPE_STA     = 0x00000000,
    ///A multithreaded apartment.
    APTTYPE_MTA     = 0x00000001,
    ///A neutral apartment.
    APTTYPE_NA      = 0x00000002,
    ///The main single-threaded apartment.
    APTTYPE_MAINSTA = 0x00000003,
}

///Indicates whether a particular thread supports a message loop.
alias THDTYPE = int;
enum : int
{
    ///The thread does not support a message loop. This behavior is associated with multithreaded apartments.
    THDTYPE_BLOCKMESSAGES   = 0x00000000,
    ///The thread supports a message loop. This behavior is associated with single-threaded apartments.
    THDTYPE_PROCESSMESSAGES = 0x00000001,
}

///Identifies one of the marshaling context attributes that you can query by using the GetMarshalingContextAttribute
///method.
alias CO_MARSHALING_CONTEXT_ATTRIBUTES = int;
enum : int
{
    ///The source of the marshaling data is an app container process.
    CO_MARSHALING_SOURCE_IS_APP_CONTAINER       = 0x00000000,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_1  = 0x80000000,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_2  = 0x80000001,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_3  = 0x80000002,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_4  = 0x80000003,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_5  = 0x80000004,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_6  = 0x80000005,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_7  = 0x80000006,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_8  = 0x80000007,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_9  = 0x80000008,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_10 = 0x80000009,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_11 = 0x8000000a,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_12 = 0x8000000b,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_13 = 0x8000000c,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_14 = 0x8000000d,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_15 = 0x8000000e,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_16 = 0x8000000f,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_17 = 0x80000010,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_18 = 0x80000011,
}

alias STDMSHLFLAGS = int;
enum : int
{
    SMEXF_SERVER  = 0x00000001,
    SMEXF_HANDLER = 0x00000002,
}

///Specifies the behavior of the CoWaitForMultipleHandles function.
alias COWAIT_FLAGS = int;
enum : int
{
    ///Dispatch calls needed for marshaling without dispatching arbitrary calls.
    COWAIT_DEFAULT                  = 0x00000000,
    ///If set, the call to CoWaitForMultipleHandles will return S_OK only when all handles associated with the
    ///synchronization object have been signaled and an input event has been received, all at the same time. In this
    ///case, the behavior of <b>CoWaitForMultipleHandles</b> corresponds to the behavior of the
    ///MsgWaitForMultipleObjectsEx function with the <i>dwFlags</i> parameter set to <b>MWMO_WAITALL</b>. If
    ///<b>COWAIT_WAITALL</b> is not set, the call to <b>CoWaitForMultipleHandles</b> will return S_OK as soon as any
    ///handle associated with the synchronization object has been signaled, regardless of whether an input event is
    ///received.
    COWAIT_WAITALL                  = 0x00000001,
    ///If set, the call to CoWaitForMultipleHandles will return S_OK if an asynchronous procedure call (APC) has been
    ///queued to the calling thread with a call to the QueueUserAPC function, even if no handle has been signaled.
    COWAIT_ALERTABLE                = 0x00000002,
    ///If set, the call to CoWaitForMultipleHandles will return S_OK if input exists for the queue, even if the input
    ///has been seen (but not removed) using a call to another function, such as PeekMessage.
    COWAIT_INPUTAVAILABLE           = 0x00000004,
    ///Dispatch calls from CoWaitForMultipleHandles in an ASTA. Default is no call dispatch. This value has no meaning
    ///in other apartment types and is ignored.
    COWAIT_DISPATCH_CALLS           = 0x00000008,
    ///Enables dispatch of window messages from CoWaitForMultipleHandles in an ASTA or STA. Default in ASTA is no window
    ///messages dispatched, default in STA is only a small set of special-cased messages dispatched. The value has no
    ///meaning in MTA and is ignored.
    COWAIT_DISPATCH_WINDOW_MESSAGES = 0x00000010,
}

///Provides flags for the CoWaitForMultipleObjects function.
alias CWMO_FLAGS = int;
enum : int
{
    ///No call dispatch.
    CWMO_DEFAULT                  = 0x00000000,
    ///Dispatch calls from CoWaitForMultipleObjects (default is no call dispatch).
    CWMO_DISPATCH_CALLS           = 0x00000001,
    CWMO_DISPATCH_WINDOW_MESSAGES = 0x00000002,
}

///Controls aspects of moniker binding operations.
alias BIND_FLAGS = int;
enum : int
{
    ///If this flag is specified, the moniker implementation can interact with the end user. Otherwise, the moniker
    ///implementation should not interact with the user in any way, such as by asking for a password for a network
    ///volume that needs mounting. If prohibited from interacting with the user when it otherwise would, a moniker
    ///implementation can use a different algorithm that does not require user interaction, or it can fail with the
    ///error MK_E_MUSTBOTHERUSER.
    BIND_MAYBOTHERUSER     = 0x00000001,
    ///If this flag is specified, the caller is not interested in having the operation carried out, but only in learning
    ///whether the operation could have been carried out had this flag not been specified. For example, this flag lets
    ///the caller indicate only an interest in finding out whether an object actually exists by using this flag in a
    ///IMoniker::BindToObject call. Moniker implementations can, however, ignore this possible optimization and carry
    ///out the operation in full. Callers must be able to deal with both cases.
    BIND_JUSTTESTEXISTENCE = 0x00000002,
}

///Indicates the moniker's class.
alias MKSYS = int;
enum : int
{
    ///Indicates a custom moniker implementation.
    MKSYS_NONE             = 0x00000000,
    ///Indicates the system's generic composite moniker class.
    MKSYS_GENERICCOMPOSITE = 0x00000001,
    ///Indicates the system's file moniker class.
    MKSYS_FILEMONIKER      = 0x00000002,
    ///Indicates the system's anti-moniker class.
    MKSYS_ANTIMONIKER      = 0x00000003,
    ///Indicates the system's item moniker class.
    MKSYS_ITEMMONIKER      = 0x00000004,
    ///Indicates the system's pointer moniker class.
    MKSYS_POINTERMONIKER   = 0x00000005,
    ///Indicates the system's class moniker class.
    MKSYS_CLASSMONIKER     = 0x00000007,
    ///Indicates the system's OBJREF moniker class.
    MKSYS_OBJREFMONIKER    = 0x00000008,
    ///Indicates the system's terminal server session moniker class.
    MKSYS_SESSIONMONIKER   = 0x00000009,
    ///Indicates the system's elevation moniker class.
    MKSYS_LUAMONIKER       = 0x0000000a,
}

alias MKREDUCE = int;
enum : int
{
    MKRREDUCE_ONE         = 0x00030000,
    MKRREDUCE_TOUSER      = 0x00020000,
    MKRREDUCE_THROUGHUSER = 0x00010000,
    MKRREDUCE_ALL         = 0x00000000,
}

///Flags that control caching and notification of changes in data.
alias ADVF = int;
enum : int
{
    ///For data advisory connections (IDataObject::DAdvise or IDataAdviseHolder::Advise), this flag requests the data
    ///object not to send data when it calls IAdviseSink::OnDataChange. The recipient of the change notification can
    ///later request the data by calling IDataObject::GetData. The data object can honor the request by passing
    ///TYMED_NULL in the STGMEDIUM parameter, or it can provide the data anyway. For example, the data object might have
    ///multiple advisory connections, not all of which specified ADVF_NODATA, in which case the object might send the
    ///same notification to all connections. Regardless of the container's request, its IAdviseSink implementation must
    ///check the STGMEDIUM parameter because it is responsible for releasing the medium if it is not TYMED_NULL. For
    ///cache connections (IOleCache::Cache), this flag requests that the cache not be updated by changes made to the
    ///running object. Instead, the container will update the cache by explicitly calling IOleCache::SetData. This
    ///situation typically occurs when the iconic aspect of an object is being cached. ADVF_NODATA is not a valid flag
    ///for view advisory connections (IViewObject::SetAdvise) and it returns E_INVALIDARG.
    ADVF_NODATA            = 0x00000001,
    ///Requests that the object not wait for the data or view to change before making an initial call to
    ///IAdviseSink::OnDataChange (for data or view advisory connections) or updating the cache (for cache connections).
    ///Used with ADVF_ONLYONCE, this parameter provides an asynchronous IDataObject::GetData call.
    ADVF_PRIMEFIRST        = 0x00000002,
    ///Requests that the object make only one change notification or cache update before deleting the connection.
    ///ADVF_ONLYONCE automatically deletes the advisory connection after sending one data or view notification. The
    ///advisory sink receives only one IAdviseSink call. A nonzero connection identifier is returned if the connection
    ///is established, so the caller can use it to delete the connection prior to the first change notification. For
    ///data change notifications, the combination of ADVF_ONLYONCE and ADVF_PRIMEFIRST provides, in effect, an
    ///asynchronous IDataObject::GetData call. When used with caching, ADVF_ONLYONCE updates the cache one time only, on
    ///receipt of the first IAdviseSink::OnDataChange notification. After the update is complete, the advisory
    ///connection between the object and the cache is disconnected. The source object for the advisory connection calls
    ///the Release method.
    ADVF_ONLYONCE          = 0x00000004,
    ///For data advisory connections, assures accessibility to data. This flag indicates that when the data object is
    ///closing, it should call , providing data with the call. Typically, this value is used in combination with
    ///ADVF_NODATA. Without thIAdviseSink::OnDataChange is value, by the time an <b>OnDataChange</b> call without data
    ///reaches the sink, the source might have completed its shutdown and the data might not be accessible. Sinks that
    ///specify this value should accept data provided in <b>OnDataChange</b> if it is being passed, because they may not
    ///get another chance to retrieve it. For cache connections, this flag indicates that the object should update the
    ///cache as part of object closure. ADVF_DATAONSTOP is not a valid flag for view advisory connections.
    ADVF_DATAONSTOP        = 0x00000040,
    ///Synonym for ADVFCACHE_FORCEBUILTIN, which is used more often.
    ADVFCACHE_NOHANDLER    = 0x00000008,
    ///This value is used by DLL object applications and object handlers that perform the drawing of their objects.
    ///ADVFCACHE_FORCEBUILTIN instructs OLE to cache presentation data to ensure that there is a presentation in the
    ///cache. This value is not a valid flag for data or view advisory connections. For cache connections, this flag
    ///caches data that requires only code shipped with OLE (or the underlying operating system) to be present in order
    ///to produce it with IDataObject::GetData or IViewObject::Draw. By specifying this value, the container can ensure
    ///that the data can be retrieved even when the object or handler code is not available.
    ADVFCACHE_FORCEBUILTIN = 0x00000010,
    ///For cache connections, this flag updates the cached representation only when the object containing the cache is
    ///saved. The cache is also updated when the OLE object transitions from the running state back to the loaded state
    ///(because a subsequent save operation would require rerunning the object). This value is not a valid flag for data
    ///or view advisory connections.
    ADVFCACHE_ONSAVE       = 0x00000020,
}

///Indicates the type of storage medium being used in a data transfer. They are used in the STGMEDIUM or FORMATETC
///structures.
alias TYMED = int;
enum : int
{
    ///The storage medium is a global memory handle (<b>HGLOBAL</b>). Allocate the global handle with the GMEM_MOVEABLE
    ///flag. If the <b>punkForRelease</b> member of STGMEDIUM is <b>NULL</b>, the destination process should use
    ///GlobalFree to release the memory.
    TYMED_HGLOBAL  = 0x00000001,
    ///The storage medium is a disk file identified by a path. If the STGMEDIUM <b>punkForRelease</b> member is
    ///<b>NULL</b>, the destination process should use OpenFile to delete the file.
    TYMED_FILE     = 0x00000002,
    ///The storage medium is a stream object identified by an IStream pointer. Use ISequentialStream::Read to read the
    ///data. If the STGMEDIUM <b>punkForRelease</b> member is not <b>NULL</b>, the destination process should use
    ///Release to release the stream component.
    TYMED_ISTREAM  = 0x00000004,
    ///The storage medium is a storage component identified by an IStorage pointer. The data is in the streams and
    ///storages contained by this <b>IStorage</b> instance. If the STGMEDIUM <b>punkForRelease</b> member is not
    ///<b>NULL</b>, the destination process should use Release to release the storage component.
    TYMED_ISTORAGE = 0x00000008,
    ///The storage medium is a GDI component (<b>HBITMAP</b>). If the STGMEDIUM <b>punkForRelease</b> member is
    ///<b>NULL</b>, the destination process should use DeleteObject to delete the bitmap.
    TYMED_GDI      = 0x00000010,
    ///The storage medium is a metafile (<b>HMETAFILE</b>). Use the GDI functions to access the metafile's data. If the
    ///STGMEDIUM <b>punkForRelease</b> member is <b>NULL</b>, the destination process should use DeleteMetaFile to
    ///delete the bitmap.
    TYMED_MFPICT   = 0x00000020,
    ///The storage medium is an enhanced metafile. If the STGMEDIUM <b>punkForRelease</b> member is <b>NULL</b>, the
    ///destination process should use DeleteEnhMetaFile to delete the bitmap.
    TYMED_ENHMF    = 0x00000040,
    ///No data is being passed.
    TYMED_NULL     = 0x00000000,
}

///Specifies the direction of the data flow. This determines the formats that the resulting enumerator can enumerate.
alias DATADIR = int;
enum : int
{
    ///Requests that IDataObject::EnumFormatEtc supply an enumerator for the formats that can be specified
    ///inIDataObject::GetData.
    DATADIR_GET = 0x00000001,
    ///Requests that IDataObject::EnumFormatEtc supply an enumerator for the formats that can be specified in
    ///IDataObject::SetData.
    DATADIR_SET = 0x00000002,
}

///Specifies the call types used by IMessageFilter::HandleInComingCall.
alias CALLTYPE = int;
enum : int
{
    ///A top-level call has arrived and the object is not currently waiting for a reply from a previous outgoing call.
    ///Calls of this type should always be handled.
    CALLTYPE_TOPLEVEL             = 0x00000001,
    ///A call has arrived bearing the same logical thread identifier as that of a previous outgoing call for which the
    ///object is still awaiting a reply. Calls of this type should always be handled.
    CALLTYPE_NESTED               = 0x00000002,
    ///An asynchronous call has arrived. Calls of this type cannot be rejected. OLE always delivers calls of this type.
    CALLTYPE_ASYNC                = 0x00000003,
    ///A new top-level call has arrived with a new logical thread identifier and the object is currently waiting for a
    ///reply from a previous outgoing call. Calls of this type may be handled or rejected.
    CALLTYPE_TOPLEVEL_CALLPENDING = 0x00000004,
    ///An asynchronous call has arrived with a new logical thread identifier and the object is currently waiting for a
    ///reply from a previous outgoing call. Calls of this type cannot be rejected.
    CALLTYPE_ASYNC_CALLPENDING    = 0x00000005,
}

///Indicates the status of server call.
alias SERVERCALL = int;
enum : int
{
    ///The object may be able to process the call.
    SERVERCALL_ISHANDLED  = 0x00000000,
    ///The object cannot handle the call due to an unforeseen problem, such as network unavailability.
    SERVERCALL_REJECTED   = 0x00000001,
    ///The object cannot handle the call at this time. For example, an application might return this value when it is in
    ///a user-controlled modal state.
    SERVERCALL_RETRYLATER = 0x00000002,
}

///Indicates the level of nesting in the IMessageFilter::MessagePending method.
alias PENDINGTYPE = int;
enum : int
{
    ///Top-level call.
    PENDINGTYPE_TOPLEVEL = 0x00000001,
    ///Nested call.
    PENDINGTYPE_NESTED   = 0x00000002,
}

///Specifies the return values for the IMessageFilter::MessagePending method.
alias PENDINGMSG = int;
enum : int
{
    ///Cancel the outgoing call.
    PENDINGMSG_CANCELCALL     = 0x00000000,
    ///Wait for the return and don't dispatch the message.
    PENDINGMSG_WAITNOPROCESS  = 0x00000001,
    ///Wait and dispatch the message.
    PENDINGMSG_WAITDEFPROCESS = 0x00000002,
}

enum ApplicationType : int
{
    ServerApplication  = 0x00000000,
    LibraryApplication = 0x00000001,
}

enum ShutdownType : int
{
    IdleShutdown   = 0x00000000,
    ForcedShutdown = 0x00000001,
}

///Specifies what to do with caches that are to be discarded from memory if their dirty bit has been set.
alias DISCARDCACHE = int;
enum : int
{
    ///The cache is to be saved to disk.
    DISCARDCACHE_SAVEIFDIRTY = 0x00000000,
    ///The cache can be discarded without saving it.
    DISCARDCACHE_NOSAVE      = 0x00000001,
}

///Controls aspects of the behavior of the IOleObject::GetMoniker and IOleClientSite::GetMoniker methods.
alias OLEGETMONIKER = int;
enum : int
{
    ///If a moniker for the object or container does not exist, IOleClientSite::GetMoniker should return E_FAIL and not
    ///assign a moniker.
    OLEGETMONIKER_ONLYIFTHERE = 0x00000001,
    ///If a moniker for the object or container does not exist, IOleClientSite::GetMoniker should create one.
    OLEGETMONIKER_FORCEASSIGN = 0x00000002,
    ///IOleClientSite::GetMoniker can release the object's moniker (although it is not required to do so). This constant
    ///is not valid in IOleObject::GetMoniker.
    OLEGETMONIKER_UNASSIGN    = 0x00000003,
    ///If a moniker for the object does not exist, IOleObject::GetMoniker can create a temporary moniker that can be
    ///used for display purposes (IMoniker::GetDisplayName) but not for binding. This enables the object server to
    ///return a descriptive name for the object without incurring the overhead of creating and maintaining a moniker
    ///until a link is actually created.
    OLEGETMONIKER_TEMPFORUSER = 0x00000004,
}

///Indicates which part of an object's moniker is being set or retrieved.
alias OLEWHICHMK = int;
enum : int
{
    ///The moniker of the object's container. Typically, this is a file moniker. This moniker is not persistently stored
    ///inside the object, since the container can be renamed even while the object is not loaded.
    OLEWHICHMK_CONTAINER = 0x00000001,
    ///The moniker of the object relative to its container. Typically, this is an item moniker, and it is part of the
    ///persistent state of the object. If this moniker is composed on to the end of the container's moniker, the
    ///resulting moniker is the full moniker of the object.
    OLEWHICHMK_OBJREL    = 0x00000002,
    ///The full moniker of the object. Binding to this moniker results in a connection to the object. This moniker is
    ///not persistently stored inside the object, since the container can be renamed even while the object is not
    ///loaded.
    OLEWHICHMK_OBJFULL   = 0x00000003,
}

///Indicates the different variants of the display name associated with a class of objects.
alias USERCLASSTYPE = int;
enum : int
{
    ///The full type name of the class.
    USERCLASSTYPE_FULL    = 0x00000001,
    ///A short name (maximum of 15 characters) that is used for popup menus and the <b>Links</b> dialog box.
    USERCLASSTYPE_SHORT   = 0x00000002,
    ///The name of the application servicing the class and is used in the result text in dialog boxes.
    USERCLASSTYPE_APPNAME = 0x00000003,
}

///Describes miscellaneous characteristics of an object or class of objects. A container can call the
///IOleObject::GetMiscStatus method to determine the <b>OLEMISC</b> bits set for an object. The values specified in an
///object server's CLSID\MiscStatus entry in the registration database are based on the <b>OLEMISC</b> enumeration.
///These constants are also used in the <b>dwStatus</b> member of the OBJECTDESCRIPTOR structure.
alias OLEMISC = int;
enum : int
{
    ///When the container resizes the space allocated to displaying one of the object's presentations, the object wants
    ///to recompose the presentation. This means that on resize, the object wants to do more than scale its picture. If
    ///this bit is set, the container should force the object to the running state and call IOleObject::SetExtent with
    ///the new size.
    OLEMISC_RECOMPOSEONRESIZE            = 0x00000001,
    ///The object has no useful content view other than its icon. From the user's perspective, the <b>Display As
    ///Icon</b> check box (in the <b>Paste Special</b> dialog box) for this object should always be checked, and should
    ///not be uncheckable. Note that such an object should still have a drawable content aspect; it will look the same
    ///as its icon view.
    OLEMISC_ONLYICONIC                   = 0x00000002,
    ///The object has initialized itself from the data in the container's current selection. Containers should examine
    ///this bit after calling IOleObject::InitFromData to initialize an object from the current selection. If set, the
    ///container should insert the object beside the current selection rather than replacing the current selection. If
    ///this bit is not set, the object being inserted replaces the current selection.
    OLEMISC_INSERTNOTREPLACE             = 0x00000004,
    ///This object is a static object, which is an object that contains only a presentation; it contains no native data.
    ///See OleCreateStaticFromData.
    OLEMISC_STATIC                       = 0x00000008,
    ///This object cannot be the link source that when bound to activates (runs) the object. If the object is selected
    ///and copied to the clipboard, the object's container can offer a link in a clipboard data transfer that, when
    ///bound, must connect to the outside of the object. The user would see the object selected in its container, not
    ///open for editing. Rather than doing this, the container can simply refuse to offer a link source when
    ///transferring objects with this bit set. Examples of objects that have this bit set include OLE1 objects, static
    ///objects, and links.
    OLEMISC_CANTLINKINSIDE               = 0x00000010,
    ///This object can be linked to by OLE 1 containers. This bit is used in the <b>dwStatus</b> member of the
    ///OBJECTDESCRIPTOR structure transferred with the Object and Link Source Descriptor formats. An object can be
    ///linked to by OLE 1 containers if it is an untitled document, a file, or a selection of data within a file.
    ///Embedded objects or pseudo-objects that are contained within an embedded object cannot be linked to by OLE 1
    ///containers (i.e., OLE 1 containers cannot link to link sources that, when bound, require more than one object
    ///server to be run.
    OLEMISC_CANLINKBYOLE1                = 0x00000020,
    ///This object is a link object. This bit is significant to OLE 1 and is set by the OLE 2 link object; object
    ///applications have no need to set this bit.
    OLEMISC_ISLINKOBJECT                 = 0x00000040,
    ///This object is capable of activating in-place, without requiring installation of menus and toolbars to run.
    ///Several such objects can be active concurrently. Some containers, such as forms, may choose to activate such
    ///objects automatically.
    OLEMISC_INSIDEOUT                    = 0x00000080,
    ///This bit is set only when OLEMISC_INSIDEOUT is set, and indicates that this object prefers to be activated
    ///whenever it is visible. Some containers may always ignore this hint.
    OLEMISC_ACTIVATEWHENVISIBLE          = 0x00000100,
    ///This object does not pay any attention to target devices. Its presention data will be the same in all cases.
    OLEMISC_RENDERINGISDEVICEINDEPENDENT = 0x00000200,
    ///This value is used with controls. It indicates that the control has no run-time user interface, but that it
    ///should be visible at design time. For example, a timer control that fires a specific event periodically would not
    ///show itself at run time, but it needs a design-time user interface so a form designer can set the event period
    ///and other properties.
    OLEMISC_INVISIBLEATRUNTIME           = 0x00000400,
    ///This value is used with controls. It tells the container that this control always wants to be running. As a
    ///result, the container should call OleRun when loading or creating the object.
    OLEMISC_ALWAYSRUN                    = 0x00000800,
    ///This value is used with controls. It indicates that the control is buttonlike in that it understands and obeys
    ///the container's DisplayAsDefault ambient property.
    OLEMISC_ACTSLIKEBUTTON               = 0x00001000,
    ///This value is used with controls. It marks the control as a label for whatever control comes after it in the
    ///form's ordering. Pressing a mnemonic key for a label control activates the control after it.
    OLEMISC_ACTSLIKELABEL                = 0x00002000,
    ///This value is used with controls. It indicates that the control has no UI active state, meaning that it requires
    ///no in-place tools, no shared menu, and no accelerators. It also means that the control never needs the focus.
    OLEMISC_NOUIACTIVATE                 = 0x00004000,
    ///This value is used with controls. It indicates that the control understands how to align itself within its
    ///display rectangle, according to alignment properties such as left, center, and right.
    OLEMISC_ALIGNABLE                    = 0x00008000,
    ///This value is used with controls. It indicates that the control is a simple grouping of other controls and does
    ///little more than pass Windows messages to the control container managing the form. Controls of this sort require
    ///the implementation of ISimpleFrameSite on the container's site.
    OLEMISC_SIMPLEFRAME                  = 0x00010000,
    ///This value is used with controls. It indicates that the control wants to use IOleObject::SetClientSite as its
    ///initialization function, even before a call such as IPersistStreamInit::InitNew or IPersistStorage::InitNew. This
    ///allows the control to access a container's ambient properties before loading information from persistent storage.
    ///Note that the current implementations of OleCreate, OleCreateFromData, OleCreateFromFile, OleLoad, and the
    ///default handler do not understand this value. Control containers that wish to honor this value must currently
    ///implement their own versions of these functions in order to establish the correct initialization sequence for the
    ///control.
    OLEMISC_SETCLIENTSITEFIRST           = 0x00020000,
    ///Obsolete. A control that works with an Input Method Editor (IME) system component can control the state of the
    ///IME through the IMEMode property rather than using this value in the OLEMISC enumeration. You can use an IME
    ///component to enter information in Asian character sets with a regular keyboard. A Japanese IME, for example,
    ///allows you to type a word such as "sushi," on a regular keyboard and when you hit the spacebar, the IME component
    ///converts that word to appropriate kanji or proposes possible choices. The OLEMISC_IMEMODE value was previously
    ///used to mark a control as capable of controlling an IME mode system component.
    OLEMISC_IMEMODE                      = 0x00040000,
    ///For new ActiveX controls to work in an older container, the control may need to have the
    ///OLEMISC_ACTIVATEWHENVISIBLE value set. However, in a newer container that understands and uses IPointerInactive,
    ///the control does not wish to be in-place activated when it becomes visible. To allow the control to work in both
    ///kinds of containers, the control can set this value. Then, the container ignores OLEMISC_ACTIVATEWHENVISIBLE and
    ///does not in-place activate the control when it becomes visible.
    OLEMISC_IGNOREACTIVATEWHENVISIBLE    = 0x00080000,
    ///A control that can merge its menu with its container sets this value.
    OLEMISC_WANTSTOMENUMERGE             = 0x00100000,
    ///A control that supports multi-level undo sets this value.
    OLEMISC_SUPPORTSMULTILEVELUNDO       = 0x00200000,
}

///Indicates whether an object should be saved before closing.
alias OLECLOSE = int;
enum : int
{
    ///The object should be saved if it is dirty.
    OLECLOSE_SAVEIFDIRTY = 0x00000000,
    ///The object should not be saved, even if it is dirty. This flag is typically used when an object is being deleted.
    OLECLOSE_NOSAVE      = 0x00000001,
    ///If the object is dirty, the IOleObject::Close implementation should display a dialog box to let the end user
    ///determine whether to save the object. However, if the object is in the running state but its user interface is
    ///invisible, the end user should not be prompted, and the close should be handled as if OLECLOSE_SAVEIFDIRTY had
    ///been specified.
    OLECLOSE_PROMPTSAVE  = 0x00000002,
}

///Indicates the type of caching requested for newly created objects.
alias OLERENDER = int;
enum : int
{
    ///The client is not requesting any locally cached drawing or data retrieval capabilities in the object. The
    ///<i>pFormatEtc</i> parameter of the calls is ignored when this value is specified for the <i>renderopts</i>
    ///parameter.
    OLERENDER_NONE   = 0x00000000,
    ///The client will draw the content of the object on the screen (a <b>NULL</b> target device) using
    ///IViewObject::Draw. The object itself determines the data formats that need to be cached. With this render option,
    ///only the <b>ptd</b> and <b>dwAspect</b> members of <i>pFormatEtc</i> are significant, since the object may cache
    ///things differently depending on the parameter values. However, <i>pFormatEtc</i> can legally be <b>NULL</b> here,
    ///in which case the object is to assume the display target device and the DVASPECT_CONTENT aspect.
    OLERENDER_DRAW   = 0x00000001,
    ///The client will pull one format from the object using IDataObject::GetData. The format of the data to be cached
    ///is passed in <i>pFormatEtc</i>, which may not in this case be <b>NULL</b>.
    OLERENDER_FORMAT = 0x00000002,
    ///The client is not requesting any locally cached drawing or data retrieval capabilities in the object.
    ///<i>pFormatEtc</i> is ignored for this option. The difference between this and the OLERENDER_FORMAT value is
    ///important in such functions as OleCreateFromData and OleCreateLinkFromData.
    OLERENDER_ASIS   = 0x00000003,
}

///Indicates whether the linked object updates the cached data for the linked object automatically or only when the
///container calls either the IOleObject::Update or IOleLink::Update methods. The constants are used in the IOleLink
///interface.
alias OLEUPDATE = int;
enum : int
{
    ///Update the link object whenever possible, this option corresponds to the <b>Automatic update</b> option in the
    ///<b>Links</b> dialog box.
    OLEUPDATE_ALWAYS = 0x00000001,
    ///Update the link object only when IOleObject::Update or IOleLink::Update is called, this option corresponds to the
    ///<b>Manual update</b> option in the <b>Links</b> dialog box.
    OLEUPDATE_ONCALL = 0x00000003,
}

///Controls binding operations to a link source.
alias OLELINKBIND = int;
enum : int
{
    ///The binding operation should proceed even if the current class of the link source is different from the last time
    ///the link was bound. For example, the link source could be a Lotus spreadsheet that was converted to an Excel
    ///spreadsheet.
    OLELINKBIND_EVENIFCLASSDIFF = 0x00000001,
}

///Indicates approximately how long the caller will wait to bind to an object.
alias BINDSPEED = int;
enum : int
{
    ///There is no time limit on the binding operation.
    BINDSPEED_INDEFINITE = 0x00000001,
    ///The binding operation must be completed in a moderate amount of time. If this flag is specified, the
    ///implementation of IOleItemContainer::GetObject should return MK_E_EXCEEEDEDDEADLINE unless tone of the following
    ///is true: <ul> <li>The object is already in the running state. </li> <li>The object is a pseudo-object (an object
    ///internal to the item container, such as a cell-range in a spreadsheet or a character-range in a word
    ///processor).</li> <li>The object is supported by an in-process server (so it is always in the running state when
    ///it is loaded). In this case, GetObject should load the designated object, and, if the OleIsRunning function
    ///indicates that the object is running, return successfully. </li> </ul>
    BINDSPEED_MODERATE   = 0x00000002,
    ///The caller will wait only a short time. In this case, the binding operation should return MK_E_EXCEEEDEDDEADLINE
    ///unless the object is already in the running state or is a pseudo-object.
    BINDSPEED_IMMEDIATE  = 0x00000003,
}

///Indicates the type of objects to be enumerated.
alias OLECONTF = int;
enum : int
{
    ///Enumerates the embedded objects in the container.
    OLECONTF_EMBEDDINGS    = 0x00000001,
    ///Enumerates the linked objects in the container.
    OLECONTF_LINKS         = 0x00000002,
    ///Enumerates all objects in the container that are not OLE compound document objects (i.e., objects other than
    ///linked or embedded objects). Use this flag to enumerate the container's pseudo-objects.
    OLECONTF_OTHERS        = 0x00000004,
    ///Enumerates only those objects the user is aware of. For example, hidden named-ranges in Microsoft Excel would not
    ///be enumerated using this value.
    OLECONTF_ONLYUSER      = 0x00000008,
    ///Enumerates only those linked or embedded objects that are currently in the running state for this container.
    OLECONTF_ONLYIFRUNNING = 0x00000010,
}

///Describes the attributes of a specified verb for an object.
alias OLEVERBATTRIB = int;
enum : int
{
    ///Executing this verb will not cause the object to become dirty and is therefore in need of saving to persistent
    ///storage.
    OLEVERBATTRIB_NEVERDIRTIES    = 0x00000001,
    ///Indicates a verb that should appear in the container's menu of verbs for this object. OLEIVERB_HIDE,
    ///OLEIVERB_SHOW, and OLEIVERB_OPEN never have this value set.
    OLEVERBATTRIB_ONCONTAINERMENU = 0x00000002,
}

enum IEObjectType : int
{
    IE_EPM_OBJECT_EVENT          = 0x00000000,
    IE_EPM_OBJECT_MUTEX          = 0x00000001,
    IE_EPM_OBJECT_SEMAPHORE      = 0x00000002,
    IE_EPM_OBJECT_SHARED_MEMORY  = 0x00000003,
    IE_EPM_OBJECT_WAITABLE_TIMER = 0x00000004,
    IE_EPM_OBJECT_FILE           = 0x00000005,
    IE_EPM_OBJECT_NAMED_PIPE     = 0x00000006,
    IE_EPM_OBJECT_REGISTRY       = 0x00000007,
}

alias MONIKERPROPERTY = int;
enum : int
{
    MIMETYPEPROP        = 0x00000000,
    USE_SRC_URL         = 0x00000001,
    CLASSIDPROP         = 0x00000002,
    TRUSTEDDOWNLOADPROP = 0x00000003,
    POPUPLEVELPROP      = 0x00000004,
}

alias BINDVERB = int;
enum : int
{
    BINDVERB_GET       = 0x00000000,
    BINDVERB_POST      = 0x00000001,
    BINDVERB_PUT       = 0x00000002,
    BINDVERB_CUSTOM    = 0x00000003,
    BINDVERB_RESERVED1 = 0x00000004,
}

alias BINDINFOF = int;
enum : int
{
    BINDINFOF_URLENCODESTGMEDDATA = 0x00000001,
    BINDINFOF_URLENCODEDEXTRAINFO = 0x00000002,
}

alias BINDF = int;
enum : int
{
    BINDF_ASYNCHRONOUS             = 0x00000001,
    BINDF_ASYNCSTORAGE             = 0x00000002,
    BINDF_NOPROGRESSIVERENDERING   = 0x00000004,
    BINDF_OFFLINEOPERATION         = 0x00000008,
    BINDF_GETNEWESTVERSION         = 0x00000010,
    BINDF_NOWRITECACHE             = 0x00000020,
    BINDF_NEEDFILE                 = 0x00000040,
    BINDF_PULLDATA                 = 0x00000080,
    BINDF_IGNORESECURITYPROBLEM    = 0x00000100,
    BINDF_RESYNCHRONIZE            = 0x00000200,
    BINDF_HYPERLINK                = 0x00000400,
    BINDF_NO_UI                    = 0x00000800,
    BINDF_SILENTOPERATION          = 0x00001000,
    BINDF_PRAGMA_NO_CACHE          = 0x00002000,
    BINDF_GETCLASSOBJECT           = 0x00004000,
    BINDF_RESERVED_1               = 0x00008000,
    BINDF_FREE_THREADED            = 0x00010000,
    BINDF_DIRECT_READ              = 0x00020000,
    BINDF_FORMS_SUBMIT             = 0x00040000,
    BINDF_GETFROMCACHE_IF_NET_FAIL = 0x00080000,
    BINDF_FROMURLMON               = 0x00100000,
    BINDF_FWD_BACK                 = 0x00200000,
    BINDF_PREFERDEFAULTHANDLER     = 0x00400000,
    BINDF_ENFORCERESTRICTED        = 0x00800000,
    BINDF_RESERVED_2               = 0x80000000,
    BINDF_RESERVED_3               = 0x01000000,
    BINDF_RESERVED_4               = 0x02000000,
    BINDF_RESERVED_5               = 0x04000000,
    BINDF_RESERVED_6               = 0x08000000,
    BINDF_RESERVED_7               = 0x40000000,
    BINDF_RESERVED_8               = 0x20000000,
}

alias URL_ENCODING = int;
enum : int
{
    URL_ENCODING_NONE         = 0x00000000,
    URL_ENCODING_ENABLE_UTF8  = 0x10000000,
    URL_ENCODING_DISABLE_UTF8 = 0x20000000,
}

alias BINDINFO_OPTIONS = int;
enum : int
{
    BINDINFO_OPTIONS_WININETFLAG              = 0x00010000,
    BINDINFO_OPTIONS_ENABLE_UTF8              = 0x00020000,
    BINDINFO_OPTIONS_DISABLE_UTF8             = 0x00040000,
    BINDINFO_OPTIONS_USE_IE_ENCODING          = 0x00080000,
    BINDINFO_OPTIONS_BINDTOOBJECT             = 0x00100000,
    BINDINFO_OPTIONS_SECURITYOPTOUT           = 0x00200000,
    BINDINFO_OPTIONS_IGNOREMIMETEXTPLAIN      = 0x00400000,
    BINDINFO_OPTIONS_USEBINDSTRINGCREDS       = 0x00800000,
    BINDINFO_OPTIONS_IGNOREHTTPHTTPSREDIRECTS = 0x01000000,
    BINDINFO_OPTIONS_IGNORE_SSLERRORS_ONCE    = 0x02000000,
    BINDINFO_WPC_DOWNLOADBLOCKED              = 0x08000000,
    BINDINFO_WPC_LOGGING_ENABLED              = 0x10000000,
    BINDINFO_OPTIONS_ALLOWCONNECTDATA         = 0x20000000,
    BINDINFO_OPTIONS_DISABLEAUTOREDIRECTS     = 0x40000000,
    BINDINFO_OPTIONS_SHDOCVW_NAVIGATE         = 0x80000000,
}

alias BSCF = int;
enum : int
{
    BSCF_FIRSTDATANOTIFICATION        = 0x00000001,
    BSCF_INTERMEDIATEDATANOTIFICATION = 0x00000002,
    BSCF_LASTDATANOTIFICATION         = 0x00000004,
    BSCF_DATAFULLYAVAILABLE           = 0x00000008,
    BSCF_AVAILABLEDATASIZEUNKNOWN     = 0x00000010,
    BSCF_SKIPDRAINDATAFORFILEURLS     = 0x00000020,
    BSCF_64BITLENGTHDOWNLOAD          = 0x00000040,
}

alias BINDSTATUS = int;
enum : int
{
    BINDSTATUS_FINDINGRESOURCE            = 0x00000001,
    BINDSTATUS_CONNECTING                 = 0x00000002,
    BINDSTATUS_REDIRECTING                = 0x00000003,
    BINDSTATUS_BEGINDOWNLOADDATA          = 0x00000004,
    BINDSTATUS_DOWNLOADINGDATA            = 0x00000005,
    BINDSTATUS_ENDDOWNLOADDATA            = 0x00000006,
    BINDSTATUS_BEGINDOWNLOADCOMPONENTS    = 0x00000007,
    BINDSTATUS_INSTALLINGCOMPONENTS       = 0x00000008,
    BINDSTATUS_ENDDOWNLOADCOMPONENTS      = 0x00000009,
    BINDSTATUS_USINGCACHEDCOPY            = 0x0000000a,
    BINDSTATUS_SENDINGREQUEST             = 0x0000000b,
    BINDSTATUS_CLASSIDAVAILABLE           = 0x0000000c,
    BINDSTATUS_MIMETYPEAVAILABLE          = 0x0000000d,
    BINDSTATUS_CACHEFILENAMEAVAILABLE     = 0x0000000e,
    BINDSTATUS_BEGINSYNCOPERATION         = 0x0000000f,
    BINDSTATUS_ENDSYNCOPERATION           = 0x00000010,
    BINDSTATUS_BEGINUPLOADDATA            = 0x00000011,
    BINDSTATUS_UPLOADINGDATA              = 0x00000012,
    BINDSTATUS_ENDUPLOADDATA              = 0x00000013,
    BINDSTATUS_PROTOCOLCLASSID            = 0x00000014,
    BINDSTATUS_ENCODING                   = 0x00000015,
    BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE  = 0x00000016,
    BINDSTATUS_CLASSINSTALLLOCATION       = 0x00000017,
    BINDSTATUS_DECODING                   = 0x00000018,
    BINDSTATUS_LOADINGMIMEHANDLER         = 0x00000019,
    BINDSTATUS_CONTENTDISPOSITIONATTACH   = 0x0000001a,
    BINDSTATUS_FILTERREPORTMIMETYPE       = 0x0000001b,
    BINDSTATUS_CLSIDCANINSTANTIATE        = 0x0000001c,
    BINDSTATUS_IUNKNOWNAVAILABLE          = 0x0000001d,
    BINDSTATUS_DIRECTBIND                 = 0x0000001e,
    BINDSTATUS_RAWMIMETYPE                = 0x0000001f,
    BINDSTATUS_PROXYDETECTING             = 0x00000020,
    BINDSTATUS_ACCEPTRANGES               = 0x00000021,
    BINDSTATUS_COOKIE_SENT                = 0x00000022,
    BINDSTATUS_COMPACT_POLICY_RECEIVED    = 0x00000023,
    BINDSTATUS_COOKIE_SUPPRESSED          = 0x00000024,
    BINDSTATUS_COOKIE_STATE_UNKNOWN       = 0x00000025,
    BINDSTATUS_COOKIE_STATE_ACCEPT        = 0x00000026,
    BINDSTATUS_COOKIE_STATE_REJECT        = 0x00000027,
    BINDSTATUS_COOKIE_STATE_PROMPT        = 0x00000028,
    BINDSTATUS_COOKIE_STATE_LEASH         = 0x00000029,
    BINDSTATUS_COOKIE_STATE_DOWNGRADE     = 0x0000002a,
    BINDSTATUS_POLICY_HREF                = 0x0000002b,
    BINDSTATUS_P3P_HEADER                 = 0x0000002c,
    BINDSTATUS_SESSION_COOKIE_RECEIVED    = 0x0000002d,
    BINDSTATUS_PERSISTENT_COOKIE_RECEIVED = 0x0000002e,
    BINDSTATUS_SESSION_COOKIES_ALLOWED    = 0x0000002f,
    BINDSTATUS_CACHECONTROL               = 0x00000030,
    BINDSTATUS_CONTENTDISPOSITIONFILENAME = 0x00000031,
    BINDSTATUS_MIMETEXTPLAINMISMATCH      = 0x00000032,
    BINDSTATUS_PUBLISHERAVAILABLE         = 0x00000033,
    BINDSTATUS_DISPLAYNAMEAVAILABLE       = 0x00000034,
    BINDSTATUS_SSLUX_NAVBLOCKED           = 0x00000035,
    BINDSTATUS_SERVER_MIMETYPEAVAILABLE   = 0x00000036,
    BINDSTATUS_SNIFFED_CLASSIDAVAILABLE   = 0x00000037,
    BINDSTATUS_64BIT_PROGRESS             = 0x00000038,
    BINDSTATUS_LAST                       = 0x00000038,
    BINDSTATUS_RESERVED_0                 = 0x00000039,
    BINDSTATUS_RESERVED_1                 = 0x0000003a,
    BINDSTATUS_RESERVED_2                 = 0x0000003b,
    BINDSTATUS_RESERVED_3                 = 0x0000003c,
    BINDSTATUS_RESERVED_4                 = 0x0000003d,
    BINDSTATUS_RESERVED_5                 = 0x0000003e,
    BINDSTATUS_RESERVED_6                 = 0x0000003f,
    BINDSTATUS_RESERVED_7                 = 0x00000040,
    BINDSTATUS_RESERVED_8                 = 0x00000041,
    BINDSTATUS_RESERVED_9                 = 0x00000042,
    BINDSTATUS_RESERVED_A                 = 0x00000043,
    BINDSTATUS_RESERVED_B                 = 0x00000044,
    BINDSTATUS_RESERVED_C                 = 0x00000045,
    BINDSTATUS_RESERVED_D                 = 0x00000046,
    BINDSTATUS_RESERVED_E                 = 0x00000047,
    BINDSTATUS_RESERVED_F                 = 0x00000048,
    BINDSTATUS_RESERVED_10                = 0x00000049,
    BINDSTATUS_RESERVED_11                = 0x0000004a,
    BINDSTATUS_RESERVED_12                = 0x0000004b,
    BINDSTATUS_RESERVED_13                = 0x0000004c,
    BINDSTATUS_LAST_PRIVATE               = 0x0000004c,
}

alias BINDF2 = int;
enum : int
{
    BINDF2_DISABLEBASICOVERHTTP              = 0x00000001,
    BINDF2_DISABLEAUTOCOOKIEHANDLING         = 0x00000002,
    BINDF2_READ_DATA_GREATER_THAN_4GB        = 0x00000004,
    BINDF2_DISABLE_HTTP_REDIRECT_XSECURITYID = 0x00000008,
    BINDF2_SETDOWNLOADMODE                   = 0x00000020,
    BINDF2_DISABLE_HTTP_REDIRECT_CACHING     = 0x00000040,
    BINDF2_KEEP_CALLBACK_MODULE_LOADED       = 0x00000080,
    BINDF2_ALLOW_PROXY_CRED_PROMPT           = 0x00000100,
    BINDF2_RESERVED_17                       = 0x00000200,
    BINDF2_RESERVED_16                       = 0x00000400,
    BINDF2_RESERVED_15                       = 0x00000800,
    BINDF2_RESERVED_14                       = 0x00001000,
    BINDF2_RESERVED_13                       = 0x00002000,
    BINDF2_RESERVED_12                       = 0x00004000,
    BINDF2_RESERVED_11                       = 0x00008000,
    BINDF2_RESERVED_10                       = 0x00010000,
    BINDF2_RESERVED_F                        = 0x00020000,
    BINDF2_RESERVED_E                        = 0x00040000,
    BINDF2_RESERVED_D                        = 0x00080000,
    BINDF2_RESERVED_C                        = 0x00100000,
    BINDF2_RESERVED_B                        = 0x00200000,
    BINDF2_RESERVED_A                        = 0x00400000,
    BINDF2_RESERVED_9                        = 0x00800000,
    BINDF2_RESERVED_8                        = 0x01000000,
    BINDF2_RESERVED_7                        = 0x02000000,
    BINDF2_RESERVED_6                        = 0x04000000,
    BINDF2_RESERVED_5                        = 0x08000000,
    BINDF2_RESERVED_4                        = 0x10000000,
    BINDF2_RESERVED_3                        = 0x20000000,
    BINDF2_RESERVED_2                        = 0x40000000,
    BINDF2_RESERVED_1                        = 0x80000000,
}

alias AUTHENTICATEF = int;
enum : int
{
    AUTHENTICATEF_PROXY = 0x00000001,
    AUTHENTICATEF_BASIC = 0x00000002,
    AUTHENTICATEF_HTTP  = 0x00000004,
}

alias CIP_STATUS = int;
enum : int
{
    CIP_DISK_FULL                            = 0x00000000,
    CIP_ACCESS_DENIED                        = 0x00000001,
    CIP_NEWER_VERSION_EXISTS                 = 0x00000002,
    CIP_OLDER_VERSION_EXISTS                 = 0x00000003,
    CIP_NAME_CONFLICT                        = 0x00000004,
    CIP_TRUST_VERIFICATION_COMPONENT_MISSING = 0x00000005,
    CIP_EXE_SELF_REGISTERATION_TIMEOUT       = 0x00000006,
    CIP_UNSAFE_TO_ABORT                      = 0x00000007,
    CIP_NEED_REBOOT                          = 0x00000008,
    CIP_NEED_REBOOT_UI_PERMISSION            = 0x00000009,
}

alias Uri_PROPERTY = int;
enum : int
{
    Uri_PROPERTY_ABSOLUTE_URI   = 0x00000000,
    Uri_PROPERTY_STRING_START   = 0x00000000,
    Uri_PROPERTY_AUTHORITY      = 0x00000001,
    Uri_PROPERTY_DISPLAY_URI    = 0x00000002,
    Uri_PROPERTY_DOMAIN         = 0x00000003,
    Uri_PROPERTY_EXTENSION      = 0x00000004,
    Uri_PROPERTY_FRAGMENT       = 0x00000005,
    Uri_PROPERTY_HOST           = 0x00000006,
    Uri_PROPERTY_PASSWORD       = 0x00000007,
    Uri_PROPERTY_PATH           = 0x00000008,
    Uri_PROPERTY_PATH_AND_QUERY = 0x00000009,
    Uri_PROPERTY_QUERY          = 0x0000000a,
    Uri_PROPERTY_RAW_URI        = 0x0000000b,
    Uri_PROPERTY_SCHEME_NAME    = 0x0000000c,
    Uri_PROPERTY_USER_INFO      = 0x0000000d,
    Uri_PROPERTY_USER_NAME      = 0x0000000e,
    Uri_PROPERTY_STRING_LAST    = 0x0000000e,
    Uri_PROPERTY_HOST_TYPE      = 0x0000000f,
    Uri_PROPERTY_DWORD_START    = 0x0000000f,
    Uri_PROPERTY_PORT           = 0x00000010,
    Uri_PROPERTY_SCHEME         = 0x00000011,
    Uri_PROPERTY_ZONE           = 0x00000012,
    Uri_PROPERTY_DWORD_LAST     = 0x00000012,
}

alias Uri_HOST_TYPE = int;
enum : int
{
    Uri_HOST_UNKNOWN = 0x00000000,
    Uri_HOST_DNS     = 0x00000001,
    Uri_HOST_IPV4    = 0x00000002,
    Uri_HOST_IPV6    = 0x00000003,
    Uri_HOST_IDN     = 0x00000004,
}

alias BINDSTRING = int;
enum : int
{
    BINDSTRING_HEADERS               = 0x00000001,
    BINDSTRING_ACCEPT_MIMES          = 0x00000002,
    BINDSTRING_EXTRA_URL             = 0x00000003,
    BINDSTRING_LANGUAGE              = 0x00000004,
    BINDSTRING_USERNAME              = 0x00000005,
    BINDSTRING_PASSWORD              = 0x00000006,
    BINDSTRING_UA_PIXELS             = 0x00000007,
    BINDSTRING_UA_COLOR              = 0x00000008,
    BINDSTRING_OS                    = 0x00000009,
    BINDSTRING_USER_AGENT            = 0x0000000a,
    BINDSTRING_ACCEPT_ENCODINGS      = 0x0000000b,
    BINDSTRING_POST_COOKIE           = 0x0000000c,
    BINDSTRING_POST_DATA_MIME        = 0x0000000d,
    BINDSTRING_URL                   = 0x0000000e,
    BINDSTRING_IID                   = 0x0000000f,
    BINDSTRING_FLAG_BIND_TO_OBJECT   = 0x00000010,
    BINDSTRING_PTR_BIND_CONTEXT      = 0x00000011,
    BINDSTRING_XDR_ORIGIN            = 0x00000012,
    BINDSTRING_DOWNLOADPATH          = 0x00000013,
    BINDSTRING_ROOTDOC_URL           = 0x00000014,
    BINDSTRING_INITIAL_FILENAME      = 0x00000015,
    BINDSTRING_PROXY_USERNAME        = 0x00000016,
    BINDSTRING_PROXY_PASSWORD        = 0x00000017,
    BINDSTRING_ENTERPRISE_ID         = 0x00000018,
    BINDSTRING_DOC_URL               = 0x00000019,
    BINDSTRING_SAMESITE_COOKIE_LEVEL = 0x0000001a,
}

alias PI_FLAGS = int;
enum : int
{
    PI_PARSE_URL            = 0x00000001,
    PI_FILTER_MODE          = 0x00000002,
    PI_FORCE_ASYNC          = 0x00000004,
    PI_USE_WORKERTHREAD     = 0x00000008,
    PI_MIMEVERIFICATION     = 0x00000010,
    PI_CLSIDLOOKUP          = 0x00000020,
    PI_DATAPROGRESS         = 0x00000040,
    PI_SYNCHRONOUS          = 0x00000080,
    PI_APARTMENTTHREADED    = 0x00000100,
    PI_CLASSINSTALL         = 0x00000200,
    PI_PASSONBINDCTX        = 0x00002000,
    PI_NOMIMEHANDLER        = 0x00008000,
    PI_LOADAPPDIRECT        = 0x00004000,
    PD_FORCE_SWITCH         = 0x00010000,
    PI_PREFERDEFAULTHANDLER = 0x00020000,
}

alias OIBDG_FLAGS = int;
enum : int
{
    OIBDG_APARTMENTTHREADED = 0x00000100,
    OIBDG_DATAONLY          = 0x00001000,
}

alias PARSEACTION = int;
enum : int
{
    PARSE_CANONICALIZE       = 0x00000001,
    PARSE_FRIENDLY           = 0x00000002,
    PARSE_SECURITY_URL       = 0x00000003,
    PARSE_ROOTDOCUMENT       = 0x00000004,
    PARSE_DOCUMENT           = 0x00000005,
    PARSE_ANCHOR             = 0x00000006,
    PARSE_ENCODE_IS_UNESCAPE = 0x00000007,
    PARSE_DECODE_IS_ESCAPE   = 0x00000008,
    PARSE_PATH_FROM_URL      = 0x00000009,
    PARSE_URL_FROM_PATH      = 0x0000000a,
    PARSE_MIME               = 0x0000000b,
    PARSE_SERVER             = 0x0000000c,
    PARSE_SCHEMA             = 0x0000000d,
    PARSE_SITE               = 0x0000000e,
    PARSE_DOMAIN             = 0x0000000f,
    PARSE_LOCATION           = 0x00000010,
    PARSE_SECURITY_DOMAIN    = 0x00000011,
    PARSE_ESCAPE             = 0x00000012,
    PARSE_UNESCAPE           = 0x00000013,
}

alias PSUACTION = int;
enum : int
{
    PSU_DEFAULT           = 0x00000001,
    PSU_SECURITY_URL_ONLY = 0x00000002,
}

alias QUERYOPTION = int;
enum : int
{
    QUERY_EXPIRATION_DATE              = 0x00000001,
    QUERY_TIME_OF_LAST_CHANGE          = 0x00000002,
    QUERY_CONTENT_ENCODING             = 0x00000003,
    QUERY_CONTENT_TYPE                 = 0x00000004,
    QUERY_REFRESH                      = 0x00000005,
    QUERY_RECOMBINE                    = 0x00000006,
    QUERY_CAN_NAVIGATE                 = 0x00000007,
    QUERY_USES_NETWORK                 = 0x00000008,
    QUERY_IS_CACHED                    = 0x00000009,
    QUERY_IS_INSTALLEDENTRY            = 0x0000000a,
    QUERY_IS_CACHED_OR_MAPPED          = 0x0000000b,
    QUERY_USES_CACHE                   = 0x0000000c,
    QUERY_IS_SECURE                    = 0x0000000d,
    QUERY_IS_SAFE                      = 0x0000000e,
    QUERY_USES_HISTORYFOLDER           = 0x0000000f,
    QUERY_IS_CACHED_AND_USABLE_OFFLINE = 0x00000010,
}

alias INTERNETFEATURELIST = int;
enum : int
{
    FEATURE_OBJECT_CACHING                 = 0x00000000,
    FEATURE_ZONE_ELEVATION                 = 0x00000001,
    FEATURE_MIME_HANDLING                  = 0x00000002,
    FEATURE_MIME_SNIFFING                  = 0x00000003,
    FEATURE_WINDOW_RESTRICTIONS            = 0x00000004,
    FEATURE_WEBOC_POPUPMANAGEMENT          = 0x00000005,
    FEATURE_BEHAVIORS                      = 0x00000006,
    FEATURE_DISABLE_MK_PROTOCOL            = 0x00000007,
    FEATURE_LOCALMACHINE_LOCKDOWN          = 0x00000008,
    FEATURE_SECURITYBAND                   = 0x00000009,
    FEATURE_RESTRICT_ACTIVEXINSTALL        = 0x0000000a,
    FEATURE_VALIDATE_NAVIGATE_URL          = 0x0000000b,
    FEATURE_RESTRICT_FILEDOWNLOAD          = 0x0000000c,
    FEATURE_ADDON_MANAGEMENT               = 0x0000000d,
    FEATURE_PROTOCOL_LOCKDOWN              = 0x0000000e,
    FEATURE_HTTP_USERNAME_PASSWORD_DISABLE = 0x0000000f,
    FEATURE_SAFE_BINDTOOBJECT              = 0x00000010,
    FEATURE_UNC_SAVEDFILECHECK             = 0x00000011,
    FEATURE_GET_URL_DOM_FILEPATH_UNENCODED = 0x00000012,
    FEATURE_TABBED_BROWSING                = 0x00000013,
    FEATURE_SSLUX                          = 0x00000014,
    FEATURE_DISABLE_NAVIGATION_SOUNDS      = 0x00000015,
    FEATURE_DISABLE_LEGACY_COMPRESSION     = 0x00000016,
    FEATURE_FORCE_ADDR_AND_STATUS          = 0x00000017,
    FEATURE_XMLHTTP                        = 0x00000018,
    FEATURE_DISABLE_TELNET_PROTOCOL        = 0x00000019,
    FEATURE_FEEDS                          = 0x0000001a,
    FEATURE_BLOCK_INPUT_PROMPTS            = 0x0000001b,
    FEATURE_ENTRY_COUNT                    = 0x0000001c,
}

alias PUAF = int;
enum : int
{
    PUAF_DEFAULT                      = 0x00000000,
    PUAF_NOUI                         = 0x00000001,
    PUAF_ISFILE                       = 0x00000002,
    PUAF_WARN_IF_DENIED               = 0x00000004,
    PUAF_FORCEUI_FOREGROUND           = 0x00000008,
    PUAF_CHECK_TIFS                   = 0x00000010,
    PUAF_DONTCHECKBOXINDIALOG         = 0x00000020,
    PUAF_TRUSTED                      = 0x00000040,
    PUAF_ACCEPT_WILDCARD_SCHEME       = 0x00000080,
    PUAF_ENFORCERESTRICTED            = 0x00000100,
    PUAF_NOSAVEDFILECHECK             = 0x00000200,
    PUAF_REQUIRESAVEDFILECHECK        = 0x00000400,
    PUAF_DONT_USE_CACHE               = 0x00001000,
    PUAF_RESERVED1                    = 0x00002000,
    PUAF_RESERVED2                    = 0x00004000,
    PUAF_LMZ_UNLOCKED                 = 0x00010000,
    PUAF_LMZ_LOCKED                   = 0x00020000,
    PUAF_DEFAULTZONEPOL               = 0x00040000,
    PUAF_NPL_USE_LOCKED_IF_RESTRICTED = 0x00080000,
    PUAF_NOUIIFLOCKED                 = 0x00100000,
    PUAF_DRAGPROTOCOLCHECK            = 0x00200000,
}

alias PUAFOUT = int;
enum : int
{
    PUAFOUT_DEFAULT          = 0x00000000,
    PUAFOUT_ISLOCKZONEPOLICY = 0x00000001,
}

alias SZM_FLAGS = int;
enum : int
{
    SZM_CREATE = 0x00000000,
    SZM_DELETE = 0x00000001,
}

alias URLZONE = int;
enum : int
{
    URLZONE_INVALID        = 0xffffffff,
    URLZONE_PREDEFINED_MIN = 0x00000000,
    URLZONE_LOCAL_MACHINE  = 0x00000000,
    URLZONE_INTRANET       = 0x00000001,
    URLZONE_TRUSTED        = 0x00000002,
    URLZONE_INTERNET       = 0x00000003,
    URLZONE_UNTRUSTED      = 0x00000004,
    URLZONE_PREDEFINED_MAX = 0x000003e7,
    URLZONE_USER_MIN       = 0x000003e8,
    URLZONE_USER_MAX       = 0x00002710,
}

alias URLTEMPLATE = int;
enum : int
{
    URLTEMPLATE_CUSTOM         = 0x00000000,
    URLTEMPLATE_PREDEFINED_MIN = 0x00010000,
    URLTEMPLATE_LOW            = 0x00010000,
    URLTEMPLATE_MEDLOW         = 0x00010500,
    URLTEMPLATE_MEDIUM         = 0x00011000,
    URLTEMPLATE_MEDHIGH        = 0x00011500,
    URLTEMPLATE_HIGH           = 0x00012000,
    URLTEMPLATE_PREDEFINED_MAX = 0x00020000,
}

alias __MIDL_IInternetZoneManager_0001 = int;
enum : int
{
    MAX_ZONE_PATH        = 0x00000104,
    MAX_ZONE_DESCRIPTION = 0x000000c8,
}

alias ZAFLAGS = int;
enum : int
{
    ZAFLAGS_CUSTOM_EDIT              = 0x00000001,
    ZAFLAGS_ADD_SITES                = 0x00000002,
    ZAFLAGS_REQUIRE_VERIFICATION     = 0x00000004,
    ZAFLAGS_INCLUDE_PROXY_OVERRIDE   = 0x00000008,
    ZAFLAGS_INCLUDE_INTRANET_SITES   = 0x00000010,
    ZAFLAGS_NO_UI                    = 0x00000020,
    ZAFLAGS_SUPPORTS_VERIFICATION    = 0x00000040,
    ZAFLAGS_UNC_AS_INTRANET          = 0x00000080,
    ZAFLAGS_DETECT_INTRANET          = 0x00000100,
    ZAFLAGS_USE_LOCKED_ZONES         = 0x00010000,
    ZAFLAGS_VERIFY_TEMPLATE_SETTINGS = 0x00020000,
    ZAFLAGS_NO_CACHE                 = 0x00040000,
}

alias URLZONEREG = int;
enum : int
{
    URLZONEREG_DEFAULT = 0x00000000,
    URLZONEREG_HKLM    = 0x00000001,
    URLZONEREG_HKCU    = 0x00000002,
}

alias BINDHANDLETYPES = int;
enum : int
{
    BINDHANDLETYPES_APPCACHE   = 0x00000000,
    BINDHANDLETYPES_DEPENDENCY = 0x00000001,
    BINDHANDLETYPES_COUNT      = 0x00000002,
}

///Provides information about the parent undo unit.
alias UASFLAGS = int;
enum : int
{
    ///The currently open parent undo unit is in a normal, unblocked state and can accept any new units added through
    ///calls to its Open or Add methods.
    UAS_NORMAL         = 0x00000000,
    ///The currently open undo unit is blocked and will reject any undo units added through calls to its
    ///IOleParentUndoUnit::Open or IOleParentUndoUnit::Add methods. The caller need not create any new units since they
    ///will just be rejected.
    UAS_BLOCKED        = 0x00000001,
    ///The currently open undo unit will accept new units, but the caller should act like there is no currently open
    ///unit. This means that if the new unit being created requires a parent, then this parent does not satisfy that
    ///requirement and the undo stack should be cleared.
    UAS_NOPARENTENABLE = 0x00000002,
    ///When checking for a normal state, use this value to mask unused bits in the <i>pdwState</i> parameter to the
    ///IOleParentUndoUnit::GetParentState method for future compatibility. For example: <pre class="syntax"
    ///xml:space="preserve"><code>fNormal = ((pdwState &amp; UAS_MASK) == UAS_NORMAL)</code></pre>
    UAS_MASK           = 0x00000003,
}

///Flags used to specify the kind of information requested from an object in the IProvideClassInfo2.
alias GUIDKIND = int;
enum : int
{
    ///The interface identifier (IID) of the object's outgoing dispinterface, labeled [source, default]. The outgoing
    ///interface in question must be derived from <b>IDispatch</b>.
    GUIDKIND_DEFAULT_SOURCE_DISP_IID = 0x00000001,
}

alias CTRLINFO = int;
enum : int
{
    CTRLINFO_EATS_RETURN = 0x00000001,
    CTRLINFO_EATS_ESCAPE = 0x00000002,
}

alias XFORMCOORDS = int;
enum : int
{
    XFORMCOORDS_POSITION            = 0x00000001,
    XFORMCOORDS_SIZE                = 0x00000002,
    XFORMCOORDS_HIMETRICTOCONTAINER = 0x00000004,
    XFORMCOORDS_CONTAINERTOHIMETRIC = 0x00000008,
    XFORMCOORDS_EVENTCOMPAT         = 0x00000010,
}

alias PROPPAGESTATUS = int;
enum : int
{
    PROPPAGESTATUS_DIRTY    = 0x00000001,
    PROPPAGESTATUS_VALIDATE = 0x00000002,
    PROPPAGESTATUS_CLEAN    = 0x00000004,
}

enum PictureAttributes : int
{
    PICTURE_SCALABLE    = 0x00000001,
    PICTURE_TRANSPARENT = 0x00000002,
}

///Indicates whether an object is activated as a windowless object. It is used in
///IOleInPlaceSiteEx::OnInPlaceActivateEx.
alias ACTIVATEFLAGS = int;
enum : int
{
    ///Indicates that the object is activated in place as a windowless object. In the
    ///IOleInPlaceSiteEx::OnInPlaceActivateEx method, the container uses this value returned in the <i>dwFlags</i>
    ///parameter instead of calling the IOleInPlaceObjectWindowless::GetWindow method to determine if the object is
    ///windowless or not.
    ACTIVATE_WINDOWLESS = 0x00000001,
}

///Specifies additional information to the container about the device context that the object has requested.
alias OLEDCFLAGS = int;
enum : int
{
    ///Indicates that the object will not use the returned <b>HDC</b> for drawing but merely to get information about
    ///the display device. In this case, the container can simply pass the window's device context without further
    ///processing.
    OLEDC_NODRAW     = 0x00000001,
    ///Requests that the container paint the background behind the object before returning the device context. Objects
    ///should use this flag when requesting a device context to paint a transparent area.
    OLEDC_PAINTBKGND = 0x00000002,
    ///Indicates that the object prefers to draw into an offscreen device context that should then be copied to the
    ///screen. The container can honor this request or not. If this bit is cleared, the container must return an
    ///on-screen device context allowing the object to perform direct screen operations such as showing a selection
    ///through an XOR operation. An object can specify this value when the drawing operation generates a lot of screen
    ///flicker.
    OLEDC_OFFSCREEN  = 0x00000004,
}

///Specifies the opacity of the object and the drawing aspects supported by the object.
alias VIEWSTATUS = int;
enum : int
{
    ///The object is completely opaque. So, for any aspect, it promises to draw the entire rectangle passed to the
    ///IViewObject::Draw method. If this value is not set, the object contains transparent parts. If it also support
    ///DVASPECT_TRANSPARENT, then this aspect may be used to draw the transparent parts only. This bit applies only to
    ///CONTENT related aspects and not to DVASPECT_ICON or DVASPECT_DOCPRINT.
    VIEWSTATUS_OPAQUE              = 0x00000001,
    ///The object has a solid background (consisting in a solid color, not a brush pattern). This bit is meaningful only
    ///if VIEWSTATUS_OPAQUE is set. This bit applies only to CONTENT related aspects and not to DVASPECT_ICON or
    ///DVASPECT_DOCPRINT.
    VIEWSTATUS_SOLIDBKGND          = 0x00000002,
    ///The object supports DVASPECT_OPAQUE. All IViewObjectEx methods taking a drawing aspect as a parameter can be
    ///called with this aspect.
    VIEWSTATUS_DVASPECTOPAQUE      = 0x00000004,
    ///The object supports DVASPECT_TRANSPARENT. All IViewObjectEx methods taking a drawing aspect as a parameter can be
    ///called with this aspect.
    VIEWSTATUS_DVASPECTTRANSPARENT = 0x00000008,
    ///The object supports a 2-dimensional surface.
    VIEWSTATUS_SURFACE             = 0x00000010,
    ///The object supports a 3-dimensional surface.
    VIEWSTATUS_3DSURFACE           = 0x00000020,
}

///Indicates whether a location is within the image of an object.
alias HITRESULT = int;
enum : int
{
    ///The specified location is outside the object and not close to the object.
    HITRESULT_OUTSIDE     = 0x00000000,
    ///The specified location is within the bounds of the object, but not close to the image. For example, a point in
    ///the middle of a transparent circle could be HITRESULT_TRANSPARENT.
    HITRESULT_TRANSPARENT = 0x00000001,
    ///The specified location is inside the object or is outside the object but is close enough to the object to be
    ///considered inside. Small, thin or detailed objects may use this value. Even if a point is outside the bounding
    ///rectangle of an object it may still be close. This value is needed for hitting small objects.
    HITRESULT_CLOSE       = 0x00000002,
    ///The specified location is within the image of the object.
    HITRESULT_HIT         = 0x00000003,
}

///Specifies new drawing aspects used to optimize the drawing process.
alias DVASPECT2 = int;
enum : int
{
    ///Represents the opaque, easy to clip parts of an object. Objects may or may not support this aspect.
    DVASPECT_OPAQUE      = 0x00000010,
    ///Represents the transparent or irregular parts of on object, typically parts that are expensive or impossible to
    ///clip out. Objects may or may not support this aspect.
    DVASPECT_TRANSPARENT = 0x00000020,
}

enum ExtentMode : int
{
    DVEXTENT_CONTENT  = 0x00000000,
    DVEXTENT_INTEGRAL = 0x00000001,
}

enum AspectInfoFlag : int
{
    DVASPECTINFOFLAG_CANOPTIMIZE = 0x00000001,
}

///Indicate the activation policy of the object and are used in the IPointerInactive::GetActivationPolicy method.
alias POINTERINACTIVE = int;
enum : int
{
    ///The object should be in-place activated when the mouse enters it during a mouse move operation.
    POINTERINACTIVE_ACTIVATEONENTRY   = 0x00000001,
    ///The object should be deactivated when the mouse leaves the object during a mouse move operation.
    POINTERINACTIVE_DEACTIVATEONLEAVE = 0x00000002,
    ///The object should be in-place activated when the mouse is dragged over it during a drag and drop operation.
    POINTERINACTIVE_ACTIVATEONDRAG    = 0x00000004,
}

alias PROPBAG2_TYPE = int;
enum : int
{
    PROPBAG2_TYPE_UNDEFINED = 0x00000000,
    PROPBAG2_TYPE_DATA      = 0x00000001,
    PROPBAG2_TYPE_URL       = 0x00000002,
    PROPBAG2_TYPE_OBJECT    = 0x00000003,
    PROPBAG2_TYPE_STREAM    = 0x00000004,
    PROPBAG2_TYPE_STORAGE   = 0x00000005,
    PROPBAG2_TYPE_MONIKER   = 0x00000006,
}

///Indicates ambient properties supplied by the container. It is used in the <b>dwAmbientFlags</b> member of the
///QACONTAINER structure.
alias QACONTAINERFLAGS = int;
enum : int
{
    ///Specifies the ShowHatching ambient property, which has a standard ambient DISPID of -712.
    QACONTAINER_SHOWHATCHING      = 0x00000001,
    ///Specifies the ShowGrabHandles ambient property, which has a standard ambient DISPID of -711.
    QACONTAINER_SHOWGRABHANDLES   = 0x00000002,
    ///Specifies the UserMode ambient property, which has a standard ambient DISPID of -709.
    QACONTAINER_USERMODE          = 0x00000004,
    ///Specifies the DisplayAsDefault ambient property, which has a standard ambient DISPID of -713.
    QACONTAINER_DISPLAYASDEFAULT  = 0x00000008,
    ///Specifies the UIDead ambient property, which has a standard ambient DISPID of -710.
    QACONTAINER_UIDEAD            = 0x00000010,
    ///Specifies the AutoClip ambient property, which has a standard ambient DISPID of -715.
    QACONTAINER_AUTOCLIP          = 0x00000020,
    ///Specifies the MessageReflect ambient property, which has a standard ambient DISPID of -706.
    QACONTAINER_MESSAGEREFLECT    = 0x00000040,
    ///Specifies the SupportsMnemonics ambient property, which has a standard ambient DISPID of -714.
    QACONTAINER_SUPPORTSMNEMONICS = 0x00000080,
}

alias OLE_TRISTATE = int;
enum : int
{
    triUnchecked = 0x00000000,
    triChecked   = 0x00000001,
    triGray      = 0x00000002,
}

///Provides miscellaneous property information about a document object.
alias DOCMISC = int;
enum : int
{
    ///Object supports multiple views.
    DOCMISC_CANCREATEMULTIPLEVIEWS   = 0x00000001,
    ///Object supports complex rectangles and therefore implements IOleDocumentView::SetRectComplex.
    DOCMISC_SUPPORTCOMPLEXRECTANGLES = 0x00000002,
    ///Object supports activation in a separate window and therefore implements IOleDocumentView::Open.
    DOCMISC_CANTOPENEDIT             = 0x00000004,
    ///Object does not support file read/write.
    DOCMISC_NOFILESUPPORT            = 0x00000008,
}

alias __MIDL_IPrint_0001 = int;
enum : int
{
    PRINTFLAG_MAYBOTHERUSER        = 0x00000001,
    PRINTFLAG_PROMPTUSER           = 0x00000002,
    PRINTFLAG_USERMAYCHANGEPRINTER = 0x00000004,
    PRINTFLAG_RECOMPOSETODEVICE    = 0x00000008,
    PRINTFLAG_DONTACTUALLYPRINT    = 0x00000010,
    PRINTFLAG_FORCEPROPERTIES      = 0x00000020,
    PRINTFLAG_PRINTTOFILE          = 0x00000040,
}

///Specifies the type of support provided by an object for the command specified in an OLECMD structure.
alias OLECMDF = int;
enum : int
{
    ///The command is supported by this object.
    OLECMDF_SUPPORTED         = 0x00000001,
    ///The command is available and enabled.
    OLECMDF_ENABLED           = 0x00000002,
    ///The command is an on-off toggle and is currently on.
    OLECMDF_LATCHED           = 0x00000004,
    ///Reserved for future use.
    OLECMDF_NINCHED           = 0x00000008,
    ///The command is hidden.
    OLECMDF_INVISIBLE         = 0x00000010,
    ///The command is hidden on the context menu.
    OLECMDF_DEFHIDEONCTXTMENU = 0x00000020,
}

///Specifies the type of information that an object should store in the OLECMDTEXT structure passed in
///IOleCommandTarget::QueryStatus. One value from this enumeration is stored the <b>cmdtextf</b> member of the
///<b>OLECMDTEXT</b> structure to indicate the desired information.
alias OLECMDTEXTF = int;
enum : int
{
    ///No extra information is requested.
    OLECMDTEXTF_NONE   = 0x00000000,
    ///The object should provide the localized name of the command.
    OLECMDTEXTF_NAME   = 0x00000001,
    ///The object should provide a localized status string for the command.
    OLECMDTEXTF_STATUS = 0x00000002,
}

///Specifies command execution options.
alias OLECMDEXECOPT = int;
enum : int
{
    ///Prompt the user for input or not, whichever is the default behavior.
    OLECMDEXECOPT_DODEFAULT      = 0x00000000,
    ///Execute the command after obtaining user input.
    OLECMDEXECOPT_PROMPTUSER     = 0x00000001,
    ///Execute the command without prompting the user. For example, clicking the Print toolbar button causes a document
    ///to be immediately printed without user input.
    OLECMDEXECOPT_DONTPROMPTUSER = 0x00000002,
    ///Show help for the corresponding command, but do not execute.
    OLECMDEXECOPT_SHOWHELP       = 0x00000003,
}

///Specifies which standard command is to be executed. A single value from this enumeration is passed in the
///<i>nCmdID</i> argument of IOleCommandTarget::Exec.
alias OLECMDID = int;
enum : int
{
    ///<b>File</b> menu, <b>Open</b> command
    OLECMDID_OPEN                           = 0x00000001,
    ///<b>File</b> menu, <b>New</b> command
    OLECMDID_NEW                            = 0x00000002,
    ///<b>File</b> menu, <b>Save</b> command
    OLECMDID_SAVE                           = 0x00000003,
    ///<b>File</b> menu, <b>Save As</b> command
    OLECMDID_SAVEAS                         = 0x00000004,
    ///<b>File</b> menu, <b>Save Copy As</b> command
    OLECMDID_SAVECOPYAS                     = 0x00000005,
    ///<b>File</b> menu, <b>Print</b> command
    OLECMDID_PRINT                          = 0x00000006,
    ///<b>File</b> menu, <b>Print Preview</b> command
    OLECMDID_PRINTPREVIEW                   = 0x00000007,
    ///<b>File</b> menu, <b>Page Setup</b> command
    OLECMDID_PAGESETUP                      = 0x00000008,
    ///<b>Tools</b> menu, <b>Spelling</b> command
    OLECMDID_SPELL                          = 0x00000009,
    ///<b>File</b> menu, <b>Properties</b> command
    OLECMDID_PROPERTIES                     = 0x0000000a,
    ///<b>Edit</b> menu, <b>Cut</b> command
    OLECMDID_CUT                            = 0x0000000b,
    ///<b>Edit</b> menu, <b>Copy</b> command
    OLECMDID_COPY                           = 0x0000000c,
    ///<b>Edit</b> menu, <b>Paste</b> command
    OLECMDID_PASTE                          = 0x0000000d,
    ///<b>Edit</b> menu, <b>Paste Special</b> command
    OLECMDID_PASTESPECIAL                   = 0x0000000e,
    ///<b>Edit</b> menu, <b>Undo</b> command
    OLECMDID_UNDO                           = 0x0000000f,
    ///<b>Edit</b> menu, <b>Redo</b> command
    OLECMDID_REDO                           = 0x00000010,
    ///<b>Edit</b> menu, <b>Select All</b> command
    OLECMDID_SELECTALL                      = 0x00000011,
    ///<b>Edit</b> menu, <b>Clear</b> command
    OLECMDID_CLEARSELECTION                 = 0x00000012,
    ///<b>View</b> menu, <b>Zoom</b> command (see below for details.)
    OLECMDID_ZOOM                           = 0x00000013,
    ///Retrieves zoom range applicable to <b>View Zoom</b> (see below for details.)
    OLECMDID_GETZOOMRANGE                   = 0x00000014,
    ///Informs the receiver, usually a frame, of state changes. The receiver can then query the status of the commands
    ///whenever convenient.
    OLECMDID_UPDATECOMMANDS                 = 0x00000015,
    ///Asks the receiver to refresh its display. Implemented by the document/object.
    OLECMDID_REFRESH                        = 0x00000016,
    ///Stops all current processing. Implemented by the document/object.
    OLECMDID_STOP                           = 0x00000017,
    ///<b>View</b> menu, <b>Toolbars</b> command. Implemented by the document/object to hide its toolbars.
    OLECMDID_HIDETOOLBARS                   = 0x00000018,
    ///Sets the maximum value of a progress indicator if one is owned by the receiving object, usually a frame. The
    ///minimum value is always zero.
    OLECMDID_SETPROGRESSMAX                 = 0x00000019,
    ///Sets the current value of a progress indicator if one is owned by the receiving object, usually a frame.
    OLECMDID_SETPROGRESSPOS                 = 0x0000001a,
    ///Sets the text contained in a progress indicator if one is owned by the receiving object, usually a frame. If the
    ///receiver currently has no progress indicator, this text should be displayed in the status bar (if one exists) as
    ///with IOleInPlaceFrame::SetStatusText.
    OLECMDID_SETPROGRESSTEXT                = 0x0000001b,
    ///Sets the title bar text of the receiving object, usually a frame.
    OLECMDID_SETTITLE                       = 0x0000001c,
    ///Called by the object when downloading state changes. Takes a VT_BOOL parameter, which is <b>TRUE</b> if the
    ///object is downloading data and <b>FALSE</b> if it not. Primarily implemented by the frame.
    OLECMDID_SETDOWNLOADSTATE               = 0x0000001d,
    ///Stops the download when executed. Typically, this command is propagated to all contained objects. When queried,
    ///sets MSOCMDF_ENABLED. Implemented by the document/object.
    OLECMDID_STOPDOWNLOAD                   = 0x0000001e,
    OLECMDID_ONTOOLBARACTIVATED             = 0x0000001f,
    ///<b>Edit</b> menu, <b>Find</b> command
    OLECMDID_FIND                           = 0x00000020,
    ///<b>Edit</b> menu, <b>Delete</b> command
    OLECMDID_DELETE                         = 0x00000021,
    ///Issued in response to <b>HTTP-EQUIV</b> metatag and results in a call to the deprecated OnHttpEquiv method with
    ///the <i>fDone</i> parameter set to <b>false</b>. This command takes a <b>VT_BSTR</b> parameter which is passed to
    ///<b>OnHttpEquiv</b>.
    OLECMDID_HTTPEQUIV                      = 0x00000022,
    ///Issued in response to <b>HTTP-EQUIV</b> metatag and results in a call to the deprecated OnHttpEquiv method with
    ///the <i>fDone</i> parameter set to <b>true</b>. This command takes a <b>VT_BSTR</b> parameter which is passed to
    ///<b>OnHttpEquiv</b>.
    OLECMDID_HTTPEQUIV_DONE                 = 0x00000023,
    ///Pauses or resumes receiver interaction. This command takes a <b>VT_BOOL</b> parameter that pauses interaction
    ///when set to <b>FALSE</b> and resumes interaction when set to <b>TRUE</b>.
    OLECMDID_ENABLE_INTERACTION             = 0x00000024,
    ///Notifies the receiver of an intent to close the window imminently. This command takes a <b>VT_BOOL</b> output
    ///parameter that returns <b>TRUE</b> if the receiver can close and <b>FALSE</b> if it can't.
    OLECMDID_ONUNLOAD                       = 0x00000025,
    ///This command has no effect.
    OLECMDID_PROPERTYBAG2                   = 0x00000026,
    ///Notifies the receiver that a refresh is about to start.
    OLECMDID_PREREFRESH                     = 0x00000027,
    ///Tells the receiver to display the script error message.
    OLECMDID_SHOWSCRIPTERROR                = 0x00000028,
    ///This command takes an IHTMLEventObj input parameter that contains a message that the receiver shows.
    OLECMDID_SHOWMESSAGE                    = 0x00000029,
    ///Tells the receiver to show the Find dialog box. It takes a <b>VT_DISPATCH</b> input param.
    OLECMDID_SHOWFIND                       = 0x0000002a,
    ///Tells the receiver to show the Page Setup dialog box. It takes an IHTMLEventObj2 input parameter.
    OLECMDID_SHOWPAGESETUP                  = 0x0000002b,
    ///Tells the receiver to show the Print dialog box. It takes an IHTMLEventObj2 input parameter.
    OLECMDID_SHOWPRINT                      = 0x0000002c,
    ///The exit command for the File menu.
    OLECMDID_CLOSE                          = 0x0000002d,
    ///Supports the QueryStatus method.
    OLECMDID_ALLOWUILESSSAVEAS              = 0x0000002e,
    ///Notifies the receiver that CSS files should not be downloaded when in DesignMode.
    OLECMDID_DONTDOWNLOADCSS                = 0x0000002f,
    ///This command has no effect.
    OLECMDID_UPDATEPAGESTATUS               = 0x00000030,
    ///<b>File</b> menu, updated <b>Print</b> command
    OLECMDID_PRINT2                         = 0x00000031,
    ///<b>File</b> menu, updated <b>Print Preview</b> command
    OLECMDID_PRINTPREVIEW2                  = 0x00000032,
    ///Sets an explicit Print Template value of <b>TRUE</b> or <b>FALSE</b>, based on a <b>VT_BOOL</b> input parameter.
    OLECMDID_SETPRINTTEMPLATE               = 0x00000033,
    ///Gets a <b>VT_BOOL</b> output parameter indicating whether the Print Template value is <b>TRUE</b> or
    ///<b>FALSE</b>.
    OLECMDID_GETPRINTTEMPLATE               = 0x00000034,
    ///Indicates that a page action has been blocked. PAGEACTIONBLOCKED is designed for use with applications that host
    ///the Internet Explorer WebBrowser control to implement their own UI.
    OLECMDID_PAGEACTIONBLOCKED              = 0x00000037,
    ///Specifies which actions are displayed in the Internet Explorer notification band.
    OLECMDID_PAGEACTIONUIQUERY              = 0x00000038,
    ///Causes the Internet Explorer WebBrowser control to focus its default notification band. Hosts can send this
    ///command at any time. The return value is S_OK if the band is present and is in focus, or S_FALSE otherwise.
    OLECMDID_FOCUSVIEWCONTROLS              = 0x00000039,
    ///This notification event is provided for applications that display Internet Explorers default notification band
    ///implementation. By default, when the user presses the ALT-N key combination, Internet Explorer treats it as a
    ///request to focus the notification band.
    OLECMDID_FOCUSVIEWCONTROLSQUERY         = 0x0000003a,
    ///Causes the Internet Explorer WebBrowser control to show the Information Bar menu.
    OLECMDID_SHOWPAGEACTIONMENU             = 0x0000003b,
    ///Causes the Internet Explorer WebBrowser control to create an entry at the current Travel Log offset. The
    ///Docobject should implement ITravelLogClient and IPersist interfaces, which are used by the Travel Log as it
    ///processes this command with calls to GetWindowData and GetPersistID, respectively.
    OLECMDID_ADDTRAVELENTRY                 = 0x0000003c,
    ///Called when LoadHistory is processed to update the previous Docobject state. For synchronous handling, this
    ///command can be called before returning from the LoadHistory call. For asynchronous handling, it can be called
    ///later.
    OLECMDID_UPDATETRAVELENTRY              = 0x0000003d,
    ///Updates the state of the browser's Back and Forward buttons.
    OLECMDID_UPDATEBACKFORWARDSTATE         = 0x0000003e,
    ///Windows Internet Explorer 7 and later. Sets the zoom factor of the browser. Takes a VT_I4 parameter in the range
    ///of 10 to 1000 (percent).
    OLECMDID_OPTICAL_ZOOM                   = 0x0000003f,
    ///Windows Internet Explorer 7 and later. Retrieves the minimum and maximum browser zoom factor limits. Returns a
    ///VT_I4 parameter; the LOWORD is the minimum zoom factor, the HIWORD is the maximum.
    OLECMDID_OPTICAL_GETZOOMRANGE           = 0x00000040,
    ///Windows Internet Explorer 7 and later. Notifies the Internet Explorer WebBrowser control of changes in window
    ///states, such as losing focus, or becoming hidden or minimized. The host indicates what has changed by setting
    ///OLECMDID_WINDOWSTATE_FLAG option flags in nCmdExecOpt.
    OLECMDID_WINDOWSTATECHANGED             = 0x00000041,
    ///Windows Internet Explorer 8 with Windows Vista. Has no effect with Windows Internet Explorer 8 with Windows XP.
    ///Notifies Trident to use the indicated Install Scope to install the ActiveX Control specified by the indicated
    ///Class ID. For more information, see the Remarks section.
    OLECMDID_ACTIVEXINSTALLSCOPE            = 0x00000042,
    ///Internet Explorer 8. Unlike OLECMDID_UPDATETRAVELENTRY, this updates a Travel Log entry that is not initialized
    ///from a previous Docobject state. While this command is not called from IPersistHistory::LoadHistory, it can be
    ///called separately to save browser state that can be used later to recover from a crash.
    OLECMDID_UPDATETRAVELENTRY_DATARECOVERY = 0x00000043,
    OLECMDID_SHOWTASKDLG                    = 0x00000044,
    OLECMDID_POPSTATEEVENT                  = 0x00000045,
    OLECMDID_VIEWPORT_MODE                  = 0x00000046,
    OLECMDID_LAYOUT_VIEWPORT_WIDTH          = 0x00000047,
    OLECMDID_VISUAL_VIEWPORT_EXCLUDE_BOTTOM = 0x00000048,
    OLECMDID_USER_OPTICAL_ZOOM              = 0x00000049,
    OLECMDID_PAGEAVAILABLE                  = 0x0000004a,
    OLECMDID_GETUSERSCALABLE                = 0x0000004b,
    OLECMDID_UPDATE_CARET                   = 0x0000004c,
    OLECMDID_ENABLE_VISIBILITY              = 0x0000004d,
    OLECMDID_MEDIA_PLAYBACK                 = 0x0000004e,
    OLECMDID_SETFAVICON                     = 0x0000004f,
    OLECMDID_SET_HOST_FULLSCREENMODE        = 0x00000050,
    OLECMDID_EXITFULLSCREEN                 = 0x00000051,
    OLECMDID_SCROLLCOMPLETE                 = 0x00000052,
    OLECMDID_ONBEFOREUNLOAD                 = 0x00000053,
    OLECMDID_SHOWMESSAGE_BLOCKABLE          = 0x00000054,
    OLECMDID_SHOWTASKDLG_BLOCKABLE          = 0x00000055,
}

alias MEDIAPLAYBACK_STATE = int;
enum : int
{
    MEDIAPLAYBACK_RESUME              = 0x00000000,
    MEDIAPLAYBACK_PAUSE               = 0x00000001,
    MEDIAPLAYBACK_PAUSE_AND_SUSPEND   = 0x00000002,
    MEDIAPLAYBACK_RESUME_FROM_SUSPEND = 0x00000003,
}

alias IGNOREMIME = int;
enum : int
{
    IGNOREMIME_PROMPT = 0x00000001,
    IGNOREMIME_TEXT   = 0x00000002,
}

alias WPCSETTING = int;
enum : int
{
    WPCSETTING_LOGGING_ENABLED      = 0x00000001,
    WPCSETTING_FILEDOWNLOAD_BLOCKED = 0x00000002,
}

alias OLECMDID_REFRESHFLAG = int;
enum : int
{
    OLECMDIDF_REFRESH_NORMAL                              = 0x00000000,
    OLECMDIDF_REFRESH_IFEXPIRED                           = 0x00000001,
    OLECMDIDF_REFRESH_CONTINUE                            = 0x00000002,
    OLECMDIDF_REFRESH_COMPLETELY                          = 0x00000003,
    OLECMDIDF_REFRESH_NO_CACHE                            = 0x00000004,
    OLECMDIDF_REFRESH_RELOAD                              = 0x00000005,
    OLECMDIDF_REFRESH_LEVELMASK                           = 0x000000ff,
    OLECMDIDF_REFRESH_CLEARUSERINPUT                      = 0x00001000,
    OLECMDIDF_REFRESH_PROMPTIFOFFLINE                     = 0x00002000,
    OLECMDIDF_REFRESH_THROUGHSCRIPT                       = 0x00004000,
    OLECMDIDF_REFRESH_SKIPBEFOREUNLOADEVENT               = 0x00008000,
    OLECMDIDF_REFRESH_PAGEACTION_ACTIVEXINSTALL           = 0x00010000,
    OLECMDIDF_REFRESH_PAGEACTION_FILEDOWNLOAD             = 0x00020000,
    OLECMDIDF_REFRESH_PAGEACTION_LOCALMACHINE             = 0x00040000,
    OLECMDIDF_REFRESH_PAGEACTION_POPUPWINDOW              = 0x00080000,
    OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNLOCALMACHINE = 0x00100000,
    OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNTRUSTED      = 0x00200000,
    OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNINTRANET     = 0x00400000,
    OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNINTERNET     = 0x00800000,
    OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNRESTRICTED   = 0x01000000,
    OLECMDIDF_REFRESH_PAGEACTION_MIXEDCONTENT             = 0x02000000,
    OLECMDIDF_REFRESH_PAGEACTION_INVALID_CERT             = 0x04000000,
    OLECMDIDF_REFRESH_PAGEACTION_ALLOW_VERSION            = 0x08000000,
}

alias OLECMDID_PAGEACTIONFLAG = int;
enum : int
{
    OLECMDIDF_PAGEACTION_FILEDOWNLOAD                       = 0x00000001,
    OLECMDIDF_PAGEACTION_ACTIVEXINSTALL                     = 0x00000002,
    OLECMDIDF_PAGEACTION_ACTIVEXTRUSTFAIL                   = 0x00000004,
    OLECMDIDF_PAGEACTION_ACTIVEXUSERDISABLE                 = 0x00000008,
    OLECMDIDF_PAGEACTION_ACTIVEXDISALLOW                    = 0x00000010,
    OLECMDIDF_PAGEACTION_ACTIVEXUNSAFE                      = 0x00000020,
    OLECMDIDF_PAGEACTION_POPUPWINDOW                        = 0x00000040,
    OLECMDIDF_PAGEACTION_LOCALMACHINE                       = 0x00000080,
    OLECMDIDF_PAGEACTION_MIMETEXTPLAIN                      = 0x00000100,
    OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE                     = 0x00000200,
    OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE_ACTIVEXINSTALL      = 0x00000200,
    OLECMDIDF_PAGEACTION_PROTLOCKDOWNLOCALMACHINE           = 0x00000400,
    OLECMDIDF_PAGEACTION_PROTLOCKDOWNTRUSTED                = 0x00000800,
    OLECMDIDF_PAGEACTION_PROTLOCKDOWNINTRANET               = 0x00001000,
    OLECMDIDF_PAGEACTION_PROTLOCKDOWNINTERNET               = 0x00002000,
    OLECMDIDF_PAGEACTION_PROTLOCKDOWNRESTRICTED             = 0x00004000,
    OLECMDIDF_PAGEACTION_PROTLOCKDOWNDENY                   = 0x00008000,
    OLECMDIDF_PAGEACTION_POPUPALLOWED                       = 0x00010000,
    OLECMDIDF_PAGEACTION_SCRIPTPROMPT                       = 0x00020000,
    OLECMDIDF_PAGEACTION_ACTIVEXUSERAPPROVAL                = 0x00040000,
    OLECMDIDF_PAGEACTION_MIXEDCONTENT                       = 0x00080000,
    OLECMDIDF_PAGEACTION_INVALID_CERT                       = 0x00100000,
    OLECMDIDF_PAGEACTION_INTRANETZONEREQUEST                = 0x00200000,
    OLECMDIDF_PAGEACTION_XSSFILTERED                        = 0x00400000,
    OLECMDIDF_PAGEACTION_SPOOFABLEIDNHOST                   = 0x00800000,
    OLECMDIDF_PAGEACTION_ACTIVEX_EPM_INCOMPATIBLE           = 0x01000000,
    OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE_ACTIVEXUSERAPPROVAL = 0x02000000,
    OLECMDIDF_PAGEACTION_WPCBLOCKED                         = 0x04000000,
    OLECMDIDF_PAGEACTION_WPCBLOCKED_ACTIVEX                 = 0x08000000,
    OLECMDIDF_PAGEACTION_EXTENSION_COMPAT_BLOCKED           = 0x10000000,
    OLECMDIDF_PAGEACTION_NORESETACTIVEX                     = 0x20000000,
    OLECMDIDF_PAGEACTION_GENERIC_STATE                      = 0x40000000,
    OLECMDIDF_PAGEACTION_RESET                              = 0x80000000,
}

alias OLECMDID_BROWSERSTATEFLAG = int;
enum : int
{
    OLECMDIDF_BROWSERSTATE_EXTENSIONSOFF     = 0x00000001,
    OLECMDIDF_BROWSERSTATE_IESECURITY        = 0x00000002,
    OLECMDIDF_BROWSERSTATE_PROTECTEDMODE_OFF = 0x00000004,
    OLECMDIDF_BROWSERSTATE_RESET             = 0x00000008,
    OLECMDIDF_BROWSERSTATE_REQUIRESACTIVEX   = 0x00000010,
    OLECMDIDF_BROWSERSTATE_DESKTOPHTMLDIALOG = 0x00000020,
    OLECMDIDF_BROWSERSTATE_BLOCKEDVERSION    = 0x00000040,
}

alias OLECMDID_OPTICAL_ZOOMFLAG = int;
enum : int
{
    OLECMDIDF_OPTICAL_ZOOM_NOPERSIST       = 0x00000001,
    OLECMDIDF_OPTICAL_ZOOM_NOLAYOUT        = 0x00000010,
    OLECMDIDF_OPTICAL_ZOOM_NOTRANSIENT     = 0x00000020,
    OLECMDIDF_OPTICAL_ZOOM_RELOADFORNEWTAB = 0x00000040,
}

alias PAGEACTION_UI = int;
enum : int
{
    PAGEACTION_UI_DEFAULT  = 0x00000000,
    PAGEACTION_UI_MODAL    = 0x00000001,
    PAGEACTION_UI_MODELESS = 0x00000002,
    PAGEACTION_UI_SILENT   = 0x00000003,
}

///Specifies the window state.
alias OLECMDID_WINDOWSTATE_FLAG = int;
enum : int
{
    ///The window is visible.
    OLECMDIDF_WINDOWSTATE_USERVISIBLE       = 0x00000001,
    ///The window has focus.
    OLECMDIDF_WINDOWSTATE_ENABLED           = 0x00000002,
    ///The window is visible and valid.
    OLECMDIDF_WINDOWSTATE_USERVISIBLE_VALID = 0x00010000,
    ///The window has focus and is valid.
    OLECMDIDF_WINDOWSTATE_ENABLED_VALID     = 0x00020000,
}

alias OLECMDID_VIEWPORT_MODE_FLAG = int;
enum : int
{
    OLECMDIDF_VIEWPORTMODE_FIXED_LAYOUT_WIDTH          = 0x00000001,
    OLECMDIDF_VIEWPORTMODE_EXCLUDE_VISUAL_BOTTOM       = 0x00000002,
    OLECMDIDF_VIEWPORTMODE_FIXED_LAYOUT_WIDTH_VALID    = 0x00010000,
    OLECMDIDF_VIEWPORTMODE_EXCLUDE_VISUAL_BOTTOM_VALID = 0x00020000,
}

///Indicates the user options that are available to the user when pasting this format, and within which group or list of
///choices (<b>Paste</b>, <b>Paste Link</b>, etc.).
alias OLEUIPASTEFLAG = int;
enum : int
{
    ///If the container does not specify this flag for the entry in the OLEUIPASTEENTRY array passed as input to
    ///OleUIPasteSpecial, the DisplayAsIcon button will be unchecked and disabled when the user selects the format that
    ///corresponds to the entry.
    OLEUIPASTE_ENABLEICON  = 0x00000800,
    ///The entry in the OLEUIPASTEENTRY array is valid for pasting only.
    OLEUIPASTE_PASTEONLY   = 0x00000000,
    ///The entry in the OLEUIPASTEENTRY array is valid for pasting. It may also be valid for linking if any of the
    ///following linking flags are specified. If it is valid for linking, then the following flags indicate which link
    ///types are acceptable by OR'ing together the appropriate OLEUIPASTE_LINKTYPE<i>n</i> values. These values
    ///correspond as follows to the array of link types passed to OleUIPasteSpecial in the <b>arrLinkTypes</b> member of
    ///the OLEUIPASTESPECIAL structure: <ul> <li>OLEUIPASTE_LINKTYPE1=arrLinkTypes[0]</li>
    ///<li>OLEUIPASTE_LINKTYPE2=arrLinkTypes[1]</li> <li>OLEUIPASTE_LINKTYPE3=arrLinkTypes[2]</li>
    ///<li>OLEUIPASTE_LINKTYPE4=arrLinkTypes[3]</li> <li>OLEUIPASTE_LINKTYPE5=arrLinkTypes[4]</li>
    ///<li>OLEUIPASTE_LINKTYPE6=arrLinkTypes[5]</li> <li>OLEUIPASTE_LINKTYPE7=arrLinkTypes[6]</li>
    ///<li>OLEUIPASTE_LINKTYPE8=arrLinkTypes[7]</li> </ul> The <b>arrLinkTypes</b> array is an array of registered
    ///clipboard formats for linking. A maximum of 8 link types is allowed.
    OLEUIPASTE_PASTE       = 0x00000200,
    ///Any link type.
    OLEUIPASTE_LINKANYTYPE = 0x00000400,
    ///Link type 1.
    OLEUIPASTE_LINKTYPE1   = 0x00000001,
    ///Link type 2.
    OLEUIPASTE_LINKTYPE2   = 0x00000002,
    ///Link type 3.
    OLEUIPASTE_LINKTYPE3   = 0x00000004,
    ///Link type 4.
    OLEUIPASTE_LINKTYPE4   = 0x00000008,
    ///Link type 5.
    OLEUIPASTE_LINKTYPE5   = 0x00000010,
    ///Link type 6.
    OLEUIPASTE_LINKTYPE6   = 0x00000020,
    ///Link type 7.
    OLEUIPASTE_LINKTYPE7   = 0x00000040,
    ///Link type 8.
    OLEUIPASTE_LINKTYPE8   = 0x00000080,
}

///Determines whether the copied call frame data can be shared with data in the parent frame by determining its lifetime
///dependency on the parent frame.
alias CALLFRAME_COPY = int;
enum : int
{
    ///The client will be responsible for using the copied call frame in a manner that its lifetime is nested in the
    ///lifetime of its parent frame making the data sharable. When this flag is used, very significant optimizations can
    ///be made and memory allocations avoided by cleverly sharing actual parameter data. Only the interface pointers
    ///transitively reachable in the source frames are guaranteed to be deep copied and thus in the copy be stored in
    ///memory separate from that in which they are stored in the source frames; other data types may actually in the
    ///copied frame share memory with the source if the copy operation is intelligent enough to do so.
    CALLFRAME_COPY_NESTED      = 0x00000001,
    ///The copied call frame will have a lifetime independent from its parent.
    CALLFRAME_COPY_INDEPENDENT = 0x00000002,
}

///Determines the parameter type to be freed.
alias CALLFRAME_FREE = int;
enum : int
{
    ///No values are freed.
    CALLFRAME_FREE_NONE      = 0x00000000,
    ///The [in] parameters are freed. This includes both top-level pointers and the data they reference.
    CALLFRAME_FREE_IN        = 0x00000001,
    ///The data referenced by [in, out] parameters are freed. However, the top-level pointers, which are the actual
    ///parameter values, are not freed. On the server side, this is typically used post-call, as in CALLFRAME_FREE_IN.
    ///On the client side, this is typically used when the server was not actually invoked (and so unmarshaling of
    ///return values was not attempted) or when unmarshaling of the return values failed.
    CALLFRAME_FREE_INOUT     = 0x00000002,
    ///The data referenced by [out] parameters are freed. However, the top-level pointers, which are the actual
    ///parameter values, are not freed. On the server side, this is typically used post-call, as in CALLFRAME_FREE_IN.
    ///On the client side, this is typically only used when unmarshaling of return values failed.
    CALLFRAME_FREE_OUT       = 0x00000004,
    ///The [in, out] parameters are freed. This includes both top-level pointers and the data they reference.
    CALLFRAME_FREE_TOP_INOUT = 0x00000008,
    ///The [out] parameters are freed. This includes both top-level pointers and the data they reference.
    CALLFRAME_FREE_TOP_OUT   = 0x00000010,
    ///All [in], [out], and [in, out] parameters are freed. This includes both top-level pointers and the data they
    ///reference.
    CALLFRAME_FREE_ALL       = 0x0000001f,
}

///Determines the parameter type to be freed.
alias CALLFRAME_NULL = int;
enum : int
{
    ///No values are freed.
    CALLFRAME_NULL_NONE  = 0x00000000,
    ///The data referenced by [in, out] parameters are freed.
    CALLFRAME_NULL_INOUT = 0x00000002,
    ///The data referenced by [out] parameters are freed.
    CALLFRAME_NULL_OUT   = 0x00000004,
    ///All [out] and [in, out] parameters are freed.
    CALLFRAME_NULL_ALL   = 0x00000006,
}

///Determines the parameter type to be walked.
alias CALLFRAME_WALK = int;
enum : int
{
    ///The [in] parameter values will be walked.
    CALLFRAME_WALK_IN    = 0x00000001,
    ///The [in, out] parameter values will be walked.
    CALLFRAME_WALK_INOUT = 0x00000002,
    ///The [out] parameter values will be walked.
    CALLFRAME_WALK_OUT   = 0x00000004,
}

///Specifies a hint about the order in which records are to be read from a log.
alias RECORD_READING_POLICY = int;
enum : int
{
    ///Indicates that records will be read in order of increasing LSN (from least recent to most recent).
    RECORD_READING_POLICY_FORWARD  = 0x00000001,
    ///Indicates that records will be read in order of decreasing LSN (from most recent to least recent).
    RECORD_READING_POLICY_BACKWARD = 0x00000002,
    ///Indicates that records may be read in any order.
    RECORD_READING_POLICY_RANDOM   = 0x00000003,
}

///Specifies the desired data or view aspect of the object when drawing or getting data.
alias DVASPECT = int;
enum : int
{
    ///Provides a representation of an object so it can be displayed as an embedded object inside of a container. This
    ///value is typically specified for compound document objects. The presentation can be provided for the screen or
    ///printer.
    DVASPECT_CONTENT   = 0x00000001,
    ///Provides a thumbnail representation of an object so it can be displayed in a browsing tool. The thumbnail is
    ///approximately a 120 by 120 pixel, 16-color (recommended) device-independent bitmap potentially wrapped in a
    ///metafile.
    DVASPECT_THUMBNAIL = 0x00000002,
    ///Provides an iconic representation of an object.
    DVASPECT_ICON      = 0x00000004,
    ///Provides a representation of the object on the screen as though it were printed to a printer using the
    ///<b>Print</b> command from the <b>File</b> menu. The described data may represent a sequence of pages.
    DVASPECT_DOCPRINT  = 0x00000008,
}

///Specifies a mapping for a class ID.
alias TYSPEC = int;
enum : int
{
    ///A CLSID.
    TYSPEC_CLSID       = 0x00000000,
    ///A file name extension.
    TYSPEC_FILEEXT     = 0x00000001,
    ///A MIME type.
    TYSPEC_MIMETYPE    = 0x00000002,
    ///A file name.
    TYSPEC_FILENAME    = 0x00000003,
    ///A PROGID.
    TYSPEC_PROGID      = 0x00000004,
    ///A package name.
    TYSPEC_PACKAGENAME = 0x00000005,
    ///An object ID.
    TYSPEC_OBJECTID    = 0x00000006,
}

///Indicates the nature of the change to an event object.
alias EOC_ChangeType = int;
enum : int
{
    ///A new object was added.
    EOC_NewObject      = 0x00000000,
    ///An existing object was modified.
    EOC_ModifiedObject = 0x00000001,
    ///An existing object was deleted.
    EOC_DeletedObject  = 0x00000002,
}

///Determines the concurrency model used for incoming calls to objects created by this thread. This concurrency model
///can be either apartment-threaded or multithreaded.
alias COINIT = int;
enum : int
{
    ///Initializes the thread for apartment-threaded object concurrency (see Remarks).
    COINIT_APARTMENTTHREADED = 0x00000002,
    ///Initializes the thread for multithreaded object concurrency (see Remarks).
    COINIT_MULTITHREADED     = 0x00000000,
    ///Disables DDE for OLE1 support.
    COINIT_DISABLE_OLE1DDE   = 0x00000004,
    ///Increase memory usage in an attempt to increase performance.
    COINIT_SPEED_OVER_MEMORY = 0x00000008,
}

///Determines the type of COM security descriptor to get when calling CoGetSystemSecurityPermissions.
alias COMSD = int;
enum : int
{
    ///Machine-wide launch permissions.
    SD_LAUNCHPERMISSIONS  = 0x00000000,
    ///Machine-wide access permissions.
    SD_ACCESSPERMISSIONS  = 0x00000001,
    ///Machine-wide launch limits.
    SD_LAUNCHRESTRICTIONS = 0x00000002,
    ///Machine-wide access limits.
    SD_ACCESSRESTRICTIONS = 0x00000003,
}

// Callbacks

alias LPFNGETCLASSOBJECT = HRESULT function(const(GUID)* param0, const(GUID)* param1, void** param2);
alias LPFNCANUNLOADNOW = HRESULT function();
alias LPFNOLEUIHOOK = uint function(HWND param0, uint param1, WPARAM param2, LPARAM param3);
alias PFNCONTEXTCALL = HRESULT function(ComCallData* pParam);

// Structs


///Contains a user name and password.
struct COAUTHIDENTITY
{
    ///The user's name.
    ushort* User;
    ///The length of the <b>User</b> string, without the terminating <b>NULL</b>.
    uint    UserLength;
    ///The domain or workgroup name.
    ushort* Domain;
    ///The length of the <b>Domain</b> string, without the terminating <b>NULL</b>.
    uint    DomainLength;
    ///The user's password in the domain or workgroup.
    ushort* Password;
    ///The length of the <b>Password</b> string, without the terminating <b>NULL</b>.
    uint    PasswordLength;
    ///Indicates whether the strings are Unicode strings. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="SEC_WINNT_AUTH_IDENTITY_ANSI"></a><a id="sec_winnt_auth_identity_ansi"></a><dl>
    ///<dt><b>SEC_WINNT_AUTH_IDENTITY_ANSI</b></dt> <dt>0x1</dt> </dl> </td> <td width="60%"> The strings are ANSI
    ///strings. </td> </tr> <tr> <td width="40%"><a id="SEC_WINNT_AUTH_IDENTITY_UNICODE"></a><a
    ///id="sec_winnt_auth_identity_unicode"></a><dl> <dt><b>SEC_WINNT_AUTH_IDENTITY_UNICODE</b></dt> <dt>0x2</dt> </dl>
    ///</td> <td width="60%"> The strings are Unicode strings. </td> </tr> </table>
    uint    Flags;
}

///Contains the authentication settings used while making a remote activation request from the client computer to the
///server computer.
struct COAUTHINFO
{
    ///The authentication service to be used. For a list of values, see Authentication Service Constants. Use
    ///RPC_C_AUTHN_NONE if no authentication is required. RPC_C_AUTHN_WINNT is the default and RPC_C_AUTHN_GSS_KERBEROS
    ///is also supported.
    uint            dwAuthnSvc;
    ///The authorization service to be used. For a list of values, see Authorization Constants. To use the NT
    ///authentication service, specify RPC_C_AUTHZ_NONE.
    uint            dwAuthzSvc;
    ///The server principal name to use with the authentication service. If you are using RPC_C_AUTHN_WINNT, the
    ///principal name must be <b>NULL</b>.
    const(wchar)*   pwszServerPrincName;
    ///The authentication level to be used. For a list of values, see Authentication Level Constants. As of Windows
    ///Server 2003, remote activations use the default authentication level specified in the CoInitializeSecurity
    ///<i>dwAuthnLevel</i> parameter. In previous versions of Windows, RPC_C_AUTHN_LEVEL_CONNECT was always used for the
    ///security level unless another level was explicitly specified.
    uint            dwAuthnLevel;
    ///The impersonation level to be used. For a list of values, see Impersonation Level Constants. This value must be
    ///RPC_C_IMP_LEVEL_IMPERSONATE or above.
    uint            dwImpersonationLevel;
    ///A pointer to a COAUTHIDENTITY structure that establishes a nondefault client identity. If this parameter is
    ///<b>NULL</b>, the actual identity of the client is used. Values of structure members are authentication-service
    ///specific. This value must be <b>NULL</b> if <b>dwAuthnSvc</b> does not specify either the NTLMSSP or Kerberos
    ///network authentication protocol is used as the authorization service.
    COAUTHIDENTITY* pAuthIdentityData;
    ///Indicates additional capabilities of this proxy. Currently, this member must be EOAC_NONE (0x0) or
    ///RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH (0x1). Use RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH if Kerberos is required.
    uint            dwCapabilities;
}

struct BYTE_BLOB
{
    uint     clSize;
    ubyte[1] abData;
}

struct WORD_BLOB
{
    uint      clSize;
    ushort[1] asData;
}

struct DWORD_BLOB
{
    uint    clSize;
    uint[1] alData;
}

struct FLAGGED_BYTE_BLOB
{
    uint     fFlags;
    uint     clSize;
    ubyte[1] abData;
}

struct FLAGGED_WORD_BLOB
{
    uint      fFlags;
    uint      clSize;
    ushort[1] asData;
}

struct BYTE_SIZEDARR
{
    uint   clSize;
    ubyte* pData;
}

struct SHORT_SIZEDARR
{
    uint    clSize;
    ushort* pData;
}

struct LONG_SIZEDARR
{
    uint  clSize;
    uint* pData;
}

struct HYPER_SIZEDARR
{
    uint  clSize;
    long* pData;
}

///Provides a mechanism for enumerating the context properties associated with a COM+ object context.
struct IEnumContextProps
{
}

///Supports setting COM+ context properties.
struct IContext
{
}

///Performs various operations on contexts.
struct IObjContext
{
}

///Identifies a remote computer resource to the activation functions.
struct COSERVERINFO
{
    ///This member is reserved and must be 0.
    uint          dwReserved1;
    ///The name of the computer.
    const(wchar)* pwszName;
    ///A pointer to a COAUTHINFO structure to override the default activation security for machine remote activations.
    ///Otherwise, set to <b>NULL</b> to indicate that default values should be used. For more information, see the
    ///Remarks section.
    COAUTHINFO*   pAuthInfo;
    ///This member is reserved and must be 0.
    uint          dwReserved2;
}

///Represents an interface in a query for multiple interfaces.
struct MULTI_QI
{
    ///A pointer to an interface identifier.
    const(GUID)* pIID;
    ///A pointer to the interface requested in <b>pIID</b>. This member must be <b>NULL</b> on input.
    IUnknown     pItf;
    ///The return value of the QueryInterface call to locate the requested interface. Common return values include S_OK
    ///and E_NOINTERFACE. This member must be 0 on input.
    HRESULT      hr;
}

///Contains marshaling invocation arguments and return values between COM components.
struct RPCOLEMESSAGE
{
    ///This member is reserved.
    void*    reserved1;
    ///The data representation with which the data was marshaled.
    uint     dataRepresentation;
    ///A buffer for marshaled data.
    void*    Buffer;
    ///The size of the buffer, in bytes.
    uint     cbBuffer;
    ///The number of the method to be invoked.
    uint     iMethod;
    ///This member is reserved.
    void[5]* reserved2;
    ///Status flags for the RPC connection.
    uint     rpcFlags;
}

struct SChannelHookCallInfo
{
    GUID  iid;
    uint  cbSize;
    GUID  uCausality;
    uint  dwServerPid;
    uint  iMethod;
    void* pObject;
}

///Identifies an authentication service that a server is willing to use to communicate to a client.
struct SOLE_AUTHENTICATION_SERVICE
{
    ///The authentication service. This member can be a single value from the Authentication Service Constants.
    uint    dwAuthnSvc;
    ///The authorization service. This member can be a single value from the Authorization Constants.
    uint    dwAuthzSvc;
    ///The principal name to be used with the authentication service. If the principal name is <b>NULL</b>, the current
    ///user identifier is assumed. A <b>NULL</b> principal name is allowed for NTLMSSP, Kerberos, and Snego
    ///authentication services but may not work for other authentication services. For Schannel, this member must point
    ///to a CERT_CONTEXT structure that contains the server's certificate; if it <b>NULL</b> and if a certificate for
    ///the current user does not exist, RPC_E_NO_GOOD_SECURITY_PACKAGES is returned.
    ushort* pPrincipalName;
    ///When used in CoInitializeSecurity, set on return to indicate the status of the call to register the
    ///authentication services.
    HRESULT hr;
}

///Identifies an authentication service, authorization service, and the authentication information for the specified
///authentication service.
struct SOLE_AUTHENTICATION_INFO
{
    ///The authentication service. This member can be a single value from the Authentication Service Constants.
    uint  dwAuthnSvc;
    ///The authorization service. This member can be a single value from the Authorization Constants.
    uint  dwAuthzSvc;
    ///A pointer to the authentication information, whose type is specific to the authentication service identified by
    ///<b>dwAuthnSvc</b>. For Schannel (RPC_C_AUTHN_GSS_SCHANNEL), this member either points to a CERT_CONTEXT structure
    ///that contains the client's X.509 certificate or is <b>NULL</b> if the client has no certificate or wishes to
    ///remain anonymous to the server. For NTLMSSP (RPC_C_AUTHN_WINNT) and Kerberos (RPC_C_AUTHN_GSS_KERBEROS), this
    ///member points to a SEC_WINNT_AUTH_IDENTITY or SEC_WINNT_AUTH_IDENTITY_EX structure that contains the user name
    ///and password. For Snego (RPC_C_AUTHN_GSS_NEGOTIATE), this member is either <b>NULL</b>, points to a
    ///SEC_WINNT_AUTH_IDENTITY structure, or points to a SEC_WINNT_AUTH_IDENTITY_EX structure. If it is <b>NULL</b>,
    ///Snego will pick a list of authentication services based on those available on the client computer. If it points
    ///to a <b>SEC_WINNT_AUTH_IDENTITY_EX</b> structure, the structure's <b>PackageList</b> member must point to a
    ///string containing a comma-separated list of authentication service names and the <b>PackageListLength</b> member
    ///must give the number of bytes in the <b>PackageList</b> string. If <b>PackageList</b> is <b>NULL</b>, all calls
    ///using Snego will fail. For authentication services not registered with DCOM, <b>pAuthInfo</b> must be set to
    ///<b>NULL</b> and DCOM will use the process identity to represent the client. For more information, see COM and
    ///Security Packages.
    void* pAuthInfo;
}

///Indicates the default authentication information to use with each authentication service. When DCOM negotiates the
///default authentication service for a proxy, it picks the default authentication information from this list.
struct SOLE_AUTHENTICATION_LIST
{
    ///The count of pointers in the array pointed to by <b>aAuthInfo</b>.
    uint cAuthInfo;
    ///An array of SOLE_AUTHENTICATION_INFO structures. Each of these structures contains an identifier for an
    ///authentication service, an identifier for the authorization service, and a pointer to authentication information
    ///to use with the specified authentication service.
    SOLE_AUTHENTICATION_INFO* aAuthInfo;
}

struct CO_MTA_USAGE_COOKIE__
{
    int unused;
}

struct CO_DEVICE_CATALOG_COOKIE__
{
    int unused;
}

///Contains parameters used during a moniker-binding operation. The BIND_OPTS2 or BIND_OPTS3 structure can be used in
///place of the <b>BIND_OPTS</b> structure.
struct BIND_OPTS
{
    ///The size of this structure, in bytes.
    uint cbStruct;
    ///Flags that control aspects of moniker binding operations. This value is any combination of the bit flags in the
    ///BIND_FLAGS enumeration. The CreateBindCtx function initializes this member to zero.
    uint grfFlags;
    ///Flags that should be used when opening the file that contains the object identified by the moniker. Possible
    ///values are the STGM constants. The binding operation uses these flags in the call to IPersistFile::Load when
    ///loading the file. If the object is already running, these flags are ignored by the binding operation. The
    ///CreateBindCtx function initializes this field to STGM_READWRITE.
    uint grfMode;
    ///The clock time by which the caller would like the binding operation to be completed, in milliseconds. This member
    ///lets the caller limit the execution time of an operation when speed is of primary importance. A value of zero
    ///indicates that there is no deadline. Callers most often use this capability when calling the
    ///IMoniker::GetTimeOfLastChange method, though it can be usefully applied to other operations as well. The
    ///CreateBindCtx function initializes this field to zero. Typical deadlines allow for a few hundred milliseconds of
    ///execution. This deadline is a recommendation, not a requirement; however, operations that exceed their deadline
    ///by a large amount may cause delays for the end user. Each moniker implementation should try to complete its
    ///operation by the deadline, or fail with the error MK_E_EXCEEDEDDEADLINE. If a binding operation exceeds its
    ///deadline because one or more objects that it needs are not running, the moniker implementation should register
    ///the objects responsible in the bind context using the IBindCtx::RegisterObjectParam. The objects should be
    ///registered under the parameter names "ExceededDeadline", "ExceededDeadline1", "ExceededDeadline2", and so on. If
    ///the caller later finds the object in the running object table, the caller can retry the binding operation. The
    ///GetTickCount function indicates the number of milliseconds since system startup, and wraps back to zero after
    ///2^31 milliseconds. Consequently, callers should be careful not to inadvertently pass a zero value (which
    ///indicates no deadline), and moniker implementations should be aware of clock wrapping problems.
    uint dwTickCountDeadline;
}

///Contains parameters used during a moniker-binding operation.
struct BIND_OPTS2
{
    BIND_OPTS     __AnonymousBase_objidl_L8451_C36;
    ///A moniker can use this value during link tracking. If the original persisted data that the moniker is referencing
    ///has been moved, the moniker can attempt to reestablish the link by searching for the original data though some
    ///adequate mechanism. This member provides additional information on how the link should be resolved. See the
    ///documentation of the <i>fFlags</i> parameter in IShellLink::Resolve. COM's file moniker implementation uses the
    ///shell link mechanism to reestablish links and passes these flags to IShellLink::Resolve.
    uint          dwTrackFlags;
    ///The class context, taken from the CLSCTX enumeration, that is to be used for instantiating the object. Monikers
    ///typically pass this value to the <i>dwClsContext</i> parameter of CoCreateInstance.
    uint          dwClassContext;
    ///The LCID value indicating the client's preference for the locale to be used by the object to which they are
    ///binding. A moniker passes this value to IClassActivator::GetClassObject.
    uint          locale;
    ///A pointer to a COSERVERINFO structure. This member allows clients calling IMoniker::BindToObject to specify
    ///server information. Clients may pass a <b>BIND_OPTS2</b> structure to the IBindCtx::SetBindOptions method. If a
    ///server name is specified in the <b>COSERVERINFO</b> structure, the moniker bind will be forwarded to the
    ///specified computer. <b>SetBindOptions</b> only copies the struct members of <b>BIND_OPTS2</b>, not the
    ///<b>COSERVERINFO</b> structure and the pointers it contains. Callers may not free any of these pointers until the
    ///bind context is released. COM's new class moniker does not currently honor the <b>pServerInfo</b> flag.
    COSERVERINFO* pServerInfo;
}

///Contains parameters used during a moniker-binding operation.
struct BIND_OPTS3
{
    BIND_OPTS2 __AnonymousBase_objidl_L8475_C36;
    ///A handle to the window that becomes the owner of the elevation UI, if applicable. If <b>hwnd</b> is <b>NULL</b>,
    ///COM will call the GetActiveWindow function to find a window handle associated with the current thread. This case
    ///might occur if the client is a script, which cannot fill in a <b>BIND_OPTS3</b> structure. In this case, COM will
    ///try to use the window associated with the script thread.
    HWND       hwnd;
}

///Specifies information about the target device for which data is being composed. <b>DVTARGETDEVICE</b> contains enough
///information about a Windows target device so a handle to a device context (<b>HDC</b>) can be created using the
///CreateDC function.
struct DVTARGETDEVICE
{
    ///The size, in bytes, of the <b>DVTARGETDEVICE</b> structure. The initial size is included so the structure can be
    ///copied more easily.
    uint     tdSize;
    ///The offset, in bytes, from the beginning of the structure to the device driver name, which is stored as a
    ///NULL-terminated string in the <b>tdData</b> buffer.
    ushort   tdDriverNameOffset;
    ///The offset, in bytes, from the beginning of the structure to the device name, which is stored as a
    ///NULL-terminated string in the <b>tdData</b> buffer. This value can be zero to indicate no device name.
    ushort   tdDeviceNameOffset;
    ///The offset, in bytes, from the beginning of the structure to the port name, which is stored as a NULL-terminated
    ///string in the <b>tdData</b> buffer. This value can be zero to indicate no port name.
    ushort   tdPortNameOffset;
    ///The offset, in bytes, from the beginning of the structure to the DEVMODE structure retrieved by calling
    ///DocumentProperties.
    ushort   tdExtDevmodeOffset;
    ///An array of bytes containing data for the target device. It is not necessary to include empty strings in
    ///<b>tdData</b> (for names where the offset value is zero).
    ubyte[1] tdData;
}

///Represents a generalized clipboard format. It is enhanced to encompass a target device, the aspect or view of the
///data, and a storage medium indicator. Where one might expect to find a clipboard format, OLE uses a <b>FORMATETC</b>
///data structure instead. This structure is used as a parameter in OLE functions and methods that require data format
///information.
struct FORMATETC
{
    ///The clipboard format of interest. There are three types of formats recognized by OLE: <ul> <li>Standard
    ///interchange formats, such as CF_TEXT. </li> <li>Private application formats understood only by the application
    ///offering the format, or by other applications offering similar features. </li> <li>OLE formats, which are used to
    ///create linked or embedded objects. </li> </ul>
    ushort          cfFormat;
    ///A pointer to a DVTARGETDEVICE structure containing information about the target device for which the data is
    ///being composed. A <b>NULL</b> value is used whenever the specified data format is independent of the target
    ///device or when the caller doesn't care what device is used. In the latter case, if the data requires a target
    ///device, the object should pick an appropriate default device (often the display for visual components). Data
    ///obtained from an object with a <b>NULL</b> target device, such as most metafiles, is independent of the target
    ///device. The resulting data is usually the same as it would be if the user chose the <b>Save As</b> command from
    ///the <b>File</b> menu and selected an interchange format.
    DVTARGETDEVICE* ptd;
    ///Indicates how much detail should be contained in the rendering. This parameter should be one of the DVASPECT
    ///enumeration values. A single clipboard format can support multiple aspects or views of the object. Most data and
    ///presentation transfer and caching methods pass aspect information. For example, a caller might request an
    ///object's iconic picture, using the metafile clipboard format to retrieve it. Note that only one <b>DVASPECT</b>
    ///value can be used in <b>dwAspect</b>. That is, <b>dwAspect</b> cannot be the result of a Boolean OR operation on
    ///several <b>DVASPECT</b> values.
    uint            dwAspect;
    ///Part of the aspect when the data must be split across page boundaries. The most common value is -1, which
    ///identifies all of the data. For the aspects DVASPECT_THUMBNAIL and DVASPECT_ICON, lindex is ignored.
    int             lindex;
    ///One of the TYMED enumeration constants which indicate the type of storage medium used to transfer the object's
    ///data. Data can be transferred using whatever medium makes sense for the object. For example, data can be passed
    ///using global memory, a disk file, or structured storage objects. For more information, see the <b>TYMED</b>
    ///enumeration.
    uint            tymed;
}

///Contains information used to specify each advisory connection. It is used for enumerating current advisory
///connections. It holds data returned by the IEnumSTATDATA enumerator. This enumerator interface is returned by
///IDataObject:DAdvise. Each advisory connection is specified by a unique <b>STATDATA</b> structure.
struct STATDATA
{
    ///The FORMATETC structure for the data of interest to the advise sink. The advise sink receives notification of
    ///changes to the data specified by this <b>FORMATETC</b> structure.
    FORMATETC   formatetc;
    ///The ADVF enumeration value that determines when the advisory sink is notified of changes in the data.
    uint        advf;
    ///The pointer for the IAdviseSink interface that will receive change notifications.
    IAdviseSink pAdvSink;
    ///The token that uniquely identifies the advisory connection. This token is returned by the method that sets up the
    ///advisory connection.
    uint        dwConnection;
}

struct RemSTGMEDIUM
{
    uint     tymed;
    uint     dwHandleType;
    uint     pData;
    uint     pUnkForRelease;
    uint     cbData;
    ubyte[1] data;
}

struct STGMEDIUM
{
    uint     tymed;
    union
    {
        HBITMAP   hBitmap;
        void*     hMetaFilePict;
        ptrdiff_t hEnhMetaFile;
        ptrdiff_t hGlobal;
        ushort*   lpszFileName;
        IStream   pstm;
        IStorage  pstg;
    }
    IUnknown pUnkForRelease;
}

struct GDI_OBJECT
{
    uint ObjectType;
    union u
    {
        userHBITMAP*  hBitmap;
        userHPALETTE* hPalette;
        userHGLOBAL*  hGeneric;
    }
}

struct userSTGMEDIUM
{
    IUnknown pUnkForRelease;
}

struct userFLAG_STGMEDIUM
{
    int           ContextFlags;
    int           fPassOwnership;
    userSTGMEDIUM Stgmed;
}

struct FLAG_STGMEDIUM
{
    int       ContextFlags;
    int       fPassOwnership;
    STGMEDIUM Stgmed;
}

///Contains information about incoming calls.
struct INTERFACEINFO
{
    ///A pointer to the IUnknown interface on the object.
    IUnknown pUnk;
    ///The identifier of the requested interface.
    GUID     iid;
    ///The interface method.
    ushort   wMethod;
}

///Represents the data structure used for the CF_OBJECTDESRIPTOR and CF_LINKSRCDESCRIPTOR file formats. These formats
///provide user interface information during data transfer operations, for example, the <b>Paste Special</b> dialog box
///or target feedback information during drag-and-drop operations.
struct OBJECTDESCRIPTOR
{
    ///The size of structure, in bytes.
    uint   cbSize;
    ///The CLSID of the object being transferred. The clsid is used to obtain the icon for the <b>Display As Icon</b>
    ///option in the <b>Paste Special</b> dialog box and is applicable only if the Embed Source or Embedded Object
    ///formats are offered. If neither is offered, the value of clsid should be CLSID_NULL. The clsid can be retrieved
    ///by the source by loading the object and calling the IOleObject::GetUserClassID method. Note that for link
    ///objects, this value is not the same as the value returned by the IPersist::GetClassID method.
    GUID   clsid;
    ///The display aspect of the object. Typically, this value is DVASPECT_CONTENT or DVASPECT_ICON. If the source
    ///application did not draw the object originally, the <b>dwDrawAspect</b> field contains a zero value (which is not
    ///the same as DVASPECT_CONTENT). For more information, see DVASPECT.
    uint   dwDrawAspect;
    ///The true extent of the object (without cropping or scaling) in <b>HIMETRIC</b> units. Setting this field is
    ///optional. The value can be (0,0) for applications that do not draw the object being transferred. This field is
    ///used primarily by targets of drag-and-drop operations, so they can give appropriate feedback to the user.
    SIZE   sizel;
    ///The offset in <b>HIMETRIC</b> units from the upper-left corner of the object where a drag-and-drop operation was
    ///initiated. This field is only meaningful for a drag-and-drop transfer operation since it corresponds to the point
    ///where the mouse was clicked to initiate the drag-and-drop operation. The value is (0,0) for other transfer
    ///situations, such as a clipboard copy and paste.
    POINTL pointl;
    ///The copy of the status flags for the object. These flags are defined by the OLEMISC enumeration. If an embedded
    ///object is being transferred, they are returned by calling the IOleObject::GetMiscStatus method.
    uint   dwStatus;
    ///The offset for finding the full user type name of the object being transferred. It specifies the offset, in
    ///bytes, from the beginning of the <b>OBJECTDESCRIPTOR</b> data structure to the null-terminated string that
    ///specifies the full user type name of the object being transferred. The value is zero if the string is not
    ///present. This string is used by the destination of a data transfer to create labels in the <b>Paste Special</b>
    ///dialog box. The destination application must be able to handle the cases when this string is omitted.
    uint   dwFullUserTypeName;
    ///The offset, in bytes, from the beginning of the data structure to the null-terminated string that specifies the
    ///source of the transfer. The <b>dwSrcOfCopy</b> member is typically implemented as the display name of the
    ///temporary moniker that identifies the data source. The value for <b>dwSrcOfCopy</b> is displayed in the Source
    ///line of the <b>Paste Special</b> dialog box. A zero value indicates that the string is not present. If
    ///<b>dwSrcOfCopy</b> is zero, the string "Unknown Source" is displayed in the <b>Paste Special</b> dialog box.
    uint   dwSrcOfCopy;
}

struct OIFI
{
    uint   cb;
    BOOL   fMDIApp;
    HWND   hwndFrame;
    HACCEL haccel;
    uint   cAccelEntries;
}

struct OleMenuGroupWidths
{
    int[6] width;
}

///Defines a verb that an object supports. The IOleObject::EnumVerbs method creates an enumerator that can enumerate
///these structures for an object, and supplies a pointer to the enumerator's IEnumOLEVERB.
struct OLEVERB
{
    ///Integer identifier associated with this verb.
    int     lVerb;
    ///Pointer to a string that contains the verb's name.
    ushort* lpszVerbName;
    ///In Windows, a group of flags taken from the flag constants beginning with MF_ defined in AppendMenu. Containers
    ///should use these flags in building an object's verb menu. All Flags defined in <b>AppendMenu</b> are supported
    ///except for MF_BITMAP, MF_OWNERDRAW, and MF_POPUP.
    uint    fuFlags;
    ///Combination of the verb attributes in the OLEVERBATTRIB enumeration.
    uint    grfAttribs;
}

struct BINDINFO
{
    uint                cbSize;
    const(wchar)*       szExtraInfo;
    STGMEDIUM           stgmedData;
    uint                grfBindInfoF;
    uint                dwBindVerb;
    const(wchar)*       szCustomVerb;
    uint                cbstgmedData;
    uint                dwOptions;
    uint                dwOptionsFlags;
    uint                dwCodePage;
    SECURITY_ATTRIBUTES securityAttributes;
    GUID                iid;
    IUnknown            pUnk;
    uint                dwReserved;
}

struct REMSECURITY_ATTRIBUTES
{
    uint nLength;
    uint lpSecurityDescriptor;
    BOOL bInheritHandle;
}

struct RemBINDINFO
{
    uint          cbSize;
    const(wchar)* szExtraInfo;
    uint          grfBindInfoF;
    uint          dwBindVerb;
    const(wchar)* szCustomVerb;
    uint          cbstgmedData;
    uint          dwOptions;
    uint          dwOptionsFlags;
    uint          dwCodePage;
    REMSECURITY_ATTRIBUTES securityAttributes;
    GUID          iid;
    IUnknown      pUnk;
    uint          dwReserved;
}

struct RemFORMATETC
{
    uint cfFormat;
    uint ptd;
    uint dwAspect;
    int  lindex;
    uint tymed;
}

struct AUTHENTICATEINFO
{
    uint dwFlags;
    uint dwReserved;
}

struct PROTOCOLDATA
{
    uint  grfFlags;
    uint  dwState;
    void* pData;
    uint  cbData;
}

struct StartParam
{
    GUID     iid;
    IBindCtx pIBindCtx;
    IUnknown pItf;
}

struct ZONEATTRIBUTES
{
    uint        cbSize;
    ushort[260] szDisplayName;
    ushort[200] szDescription;
    ushort[260] szIconPath;
    uint        dwTemplateMinLevel;
    uint        dwTemplateRecommended;
    uint        dwTemplateCurrentLevel;
    uint        dwFlags;
}

struct CODEBASEHOLD
{
    uint          cbSize;
    const(wchar)* szDistUnit;
    const(wchar)* szCodeBase;
    uint          dwVersionMS;
    uint          dwVersionLS;
    uint          dwStyle;
}

struct PROTOCOLFILTERDATA
{
    uint              cbSize;
    IInternetProtocolSink pProtocolSink;
    IInternetProtocol pProtocol;
    IUnknown          pUnk;
    uint              dwFilterFlags;
}

struct DATAINFO
{
    uint ulTotalSize;
    uint ulavrPacketSize;
    uint ulConnectSpeed;
    uint ulProcessorSpeed;
}

struct HIT_LOGGING_INFO
{
    uint         dwStructSize;
    const(char)* lpszLoggedUrlName;
    SYSTEMTIME   StartTime;
    SYSTEMTIME   EndTime;
    const(char)* lpszExtendedInfo;
}

struct CONFIRMSAFETY
{
    GUID     clsid;
    IUnknown pUnk;
    uint     dwFlags;
}

struct PROTOCOL_ARGUMENT
{
    const(wchar)* szMethod;
    const(wchar)* szTargetUrl;
}

struct OLESTREAMVTBL
{
    ptrdiff_t Get;
    ptrdiff_t Put;
}

struct OLESTREAM
{
    OLESTREAMVTBL* lpstbl;
}

///Describes a connection that exists to a given connection point.
struct CONNECTDATA
{
    ///A pointer to the IUnknown interface on a connected advisory sink. The caller must call Release using this pointer
    ///when the <b>CONNECTDATA</b> structure is no longer needed. The caller is responsible for calling <b>Release</b>
    ///for each <b>CONNECTDATA</b> structure enumerated through IEnumConnections::Next.
    IUnknown pUnk;
    ///Connection where this value is the same token that is returned originally from calls to IConnectionPoint::Advise.
    ///This token can be used to disconnect the sink pointed to by a <b>pUnk</b> by passing <b>dwCookie</b> to
    ///IConnectionPoint::Unadvise.
    uint     dwCookie;
}

///Contains parameters that describe the licensing behavior of a class factory that supports licensing. The structure is
///filled by calling the IClassFactory2::GetLicInfo method.
struct LICINFO
{
    ///The size of the structure, in bytes.
    int  cbLicInfo;
    ///Indicates whether this class factory allows the creation of its objects on an unlicensed machine through the use
    ///of a license key. If <b>TRUE</b>, IClassFactory2::RequestLicKey can be called to obtain the key. If <b>FALSE</b>,
    ///objects can be created only on a fully licensed machine.
    BOOL fRuntimeKeyAvail;
    ///Indicates whether a full machine license exists such that calls to IClassFactory::CreateInstance and
    ///IClassFactory2::RequestLicKey will succeed. If <b>TRUE</b>, the full machine license exists. Thus, objects can be
    ///created freely. and a license key is available if <b>fRuntimeKeyAvail</b> is also <b>TRUE</b>. If <b>FALSE</b>,
    ///this class factory cannot create any instances of objects on this machine unless the proper license key is passed
    ///to IClassFactory2::CreateInstanceLic.
    BOOL fLicVerified;
}

///Contains parameters that describe a control's keyboard mnemonics and keyboard behavior. The structure is populated
///during the IOleControl::GetControlInfo method.
struct CONTROLINFO
{
    ///The size of the structure, in bytes.
    uint   cb;
    ///A handle to an array of ACCEL structures, each structure describing a keyboard mnemonic. The array is created
    ///with the CreateAcceleratorTable function. The control always maintains the memory for this array; the caller of
    ///IOleControl::GetControlInfo should not attempt to free the memory.
    HACCEL hAccel;
    ///The number of mnemonics described in the <b>hAccel</b> field. This value can be zero to indicate no mnemonics.
    ushort cAccel;
    ///Flags that indicate the keyboard behavior of the control. The possible values are: <ul> <li>CTRLINFO_EATS_RETURN:
    ///When the control has the focus, it will process the Return key. </li> <li>CTRLINFO_EATS_ESCAPE: When the control
    ///has the focus, it will process the Escape key. </li> </ul> When the control has the focus, the dialog box
    ///containing the control cannot use the Return or Escape keys as mnemonics for the default and cancel buttons.
    uint   dwFlags;
}

///Contains information that is used to convert between container units, expressed in floating point, and control units,
///expressed in <b>HIMETRIC</b>. The <b>POINTF</b> structure specifically holds the floating point container units.
///Controls do not attempt to interpret either value in the structure.
struct POINTF
{
    ///The x coordinates of the point in units that the container finds convenient.
    float x;
    ///The y coordinates of the point in units that the container finds convenient.
    float y;
}

///Contains parameters used to describe a property page to a property frame. A property page fills a caller-provided
///structure in the IPropertyPage::GetPageInfo method.
struct PROPPAGEINFO
{
    ///The size of the structure, in bytes.
    uint    cb;
    ///Pointer to an OLESTR that contains the string that appears in the tab for this page. The string must be allocated
    ///with CoTaskMemAlloc. The caller of IPropertyPage::GetPageInfo is responsible for freeing the memory with
    ///CoTaskMemFree.
    ushort* pszTitle;
    ///Required dimensions of the page's dialog box, in pixels.
    SIZE    size;
    ///Pointer to a text string describing the page, which can be displayed in the property sheet dialog box (current
    ///frame implementation doesn't use this field). The text must be allocated with CoTaskMemAlloc. The caller of
    ///IPropertyPage::GetPageInfo is responsible for freeing the memory with CoTaskMemFree.
    ushort* pszDocString;
    ///Pointer to an OLESTR that contains the simple name of the help file that describes this property page used
    ///instead of implementing IPropertyPage::Help. When the user presses Help, the Help method is normally called. If
    ///that method fails, the frame will open the help system with this help file (prefixed with the value of the
    ///HelpDir key in the property page's registry entries under its CLSID) and will instruct the help system to display
    ///the context described by the <b>dwHelpContext</b> field. The path must be allocated with CoTaskMemAlloc. The
    ///caller of IPropertyPage::GetPageInfo is responsible for freeing the memory with CoTaskMemFree.
    ushort* pszHelpFile;
    ///Context identifier for the help topic within <b>pszHelpFile</b> that describes this page.
    uint    dwHelpContext;
}

///Specifies a counted array of UUID or GUID types used to receive an array of CLSIDs for the property pages that the
///object wants to display.
struct CAUUID
{
    ///The size of the array pointed to by <b>pElems</b>.
    uint  cElems;
    ///A pointer to an array of values, each of which specifies a CLSID of a particular property page. This array is
    ///allocated by the callee using CoTaskMemAlloc and is freed by the caller using CoTaskMemFree.
    GUID* pElems;
}

struct ExtentInfo
{
    uint cb;
    uint dwExtentMode;
    SIZE sizelProposed;
}

struct AspectInfo
{
    uint cb;
    uint dwFlags;
}

///Specifies a counted array of strings used to specify the predefined strings that a property can accept.
struct CALPOLESTR
{
    ///The size of the array pointed to by <b>pElems</b>.
    uint     cElems;
    ///A pointer to an array of LPOLESTR values, each of which corresponds to an allowable value that a particular
    ///property can accept. The caller can use these string values in user interface elements, such as drop-down list
    ///boxes. This array, as well as the strings in the array, are allocated by the callee using CoTaskMemAlloc and is
    ///freed by the caller using CoTaskMemFree.
    ushort** pElems;
}

///Specifies a counted array of values that can be used to obtain the value corresponding to one of the predefined
///strings for a property.
struct CADWORD
{
    ///The size of the array pointed to by <b>pElems</b>.
    uint  cElems;
    ///A pointer to an array of values, each of which can be passed to the IPerPropertyBrowsing::GetPredefinedValue
    ///method to obtain the corresponding value for one of the property's predefined strings. This array is allocated by
    ///the callee using CoTaskMemAlloc and is freed by the caller using CoTaskMemFree.
    uint* pElems;
}

struct PROPBAG2
{
    uint    dwType;
    ushort  vt;
    ushort  cfType;
    uint    dwHint;
    ushort* pstrName;
    GUID    clsid;
}

///Specifies container information for IQuickActivate::QuickActivate.
struct QACONTAINER
{
    ///The size of the structure, in bytes.
    uint                cbSize;
    ///A pointer to an IOleClientSite interface in the container.
    IOleClientSite      pClientSite;
    ///A pointer to an IAdviseSinkEx interface in the container.
    IAdviseSinkEx       pAdviseSink;
    ///A pointer to an IPropertyNotifySink interface in the container.
    IPropertyNotifySink pPropertyNotifySink;
    ///A pointer to an IUnknown interface on the container's sink object.
    IUnknown            pUnkEventSink;
    ///The number of ambient properties supplied by the container using values from the QACONTAINERFLAGS enumeration.
    uint                dwAmbientFlags;
    ///Specifies ForeColor, an ambient property supplied by the container with a DISPID = -704.
    uint                colorFore;
    ///Specifies BackColor, an ambient property supplied by the container with a DISPID = -701.
    uint                colorBack;
    ///Specifies Font, an ambient property supplied by the container with a DISPID = -703.
    IFont               pFont;
    ///A pointer to an IOleUndoManager interface in the container.
    IOleUndoManager     pUndoMgr;
    ///Specifies Appearance, an ambient property supplied by the container with a DISPID = -716.
    uint                dwAppearance;
    ///Specifies LocaleIdentifier, an ambient property supplied by the container with a DISPID = -705.
    int                 lcid;
    ///Specifies Palette, an ambient property supplied by the container with a DISPID = -726.
    HPALETTE            hpal;
    ///A pointer to an IBindHost interface in the container.
    IBindHost           pBindHost;
    ///A pointer to the IOleControlSite interface in the container's site object.
    IOleControlSite     pOleControlSite;
    ///A pointer to the IServiceProvider interface in the container.
    IServiceProvider    pServiceProvider;
}

///Specifies control information for IQuickActivate::QuickActivate.
struct QACONTROL
{
    ///The size of the structure, in bytes.
    uint cbSize;
    ///The control's miscellaneous status bits that can also be returned by IOleObject::GetMiscStatus. See OLEMISC for
    ///more information.
    uint dwMiscStatus;
    ///The control's view status that can also be returned by IViewObjectEx::GetViewStatus. See VIEWSTATUS for more
    ///information.
    uint dwViewStatus;
    ///A unique identifier for control-defined events.
    uint dwEventCookie;
    ///A unique identifier for control-defined properties.
    uint dwPropNotifyCookie;
    ///The control's activation policy that can also be returned by IPointerInactive::GetActivationPolicy. If all the
    ///bits of <b>dwPointerActivationPolicy</b> are set, then the IPointerInactive interface may not be supported. The
    ///container should QueryInterface to obtain the interface pointer in the standard manner.
    uint dwPointerActivationPolicy;
}

///Contains parameters used to invoke a property sheet dialog box through the OleCreatePropertyFrameIndirect function.
struct OCPFIPARAMS
{
    ///The size of the structure, in bytes.
    uint      cbStructSize;
    ///Handle to the parent window of the resulting property sheet dialog box.
    HWND      hWndOwner;
    ///Horizontal position for the dialog box relative to <b>hWndOwner</b>, in pixels.
    int       x;
    ///Vertical position for the dialog box relative to <b>hWndOwner</b>, in pixels.
    int       y;
    ///Pointer to an OLESTR that contains the caption of the dialog.
    ushort*   lpszCaption;
    ///Number of object pointers passed in <b>lplpUnk</b>.
    uint      cObjects;
    ///Array of IUnknown pointers on the objects for which this property sheet is being invoked. The number of elements
    ///in the array is specified by <b>cObjects</b>. These pointers are passed to each property page through
    ///IPropertyPage::SetObjects.
    IUnknown* lplpUnk;
    ///Number of property pages specified in <b>lpPages</b>.
    uint      cPages;
    ///Pointer to an array of size <b>cPages</b> containing the CLSIDs of each property page to display in the property
    ///sheet.
    GUID*     lpPages;
    ///Locale identifier for the property sheet. This value will be returned through IPropertyPageSite::GetLocaleID.
    uint      lcid;
    ///Property that is highlighted when the dialog box is made visible.
    int       dispidInitialProperty;
}

///Contains parameters used to create a font object through the OleCreateFontIndirect function.
struct FONTDESC
{
    ///The size of the structure, in bytes.
    uint    cbSizeofstruct;
    ///Pointer to an OLESTR that specifies the caller-owned string specifying the font name. cySize
    ushort* lpstrName;
    ///Initial point size of the font. Use the <b>int64</b> member of the CY structure and scale your font size (in
    ///points) by 10000.
    CY      cySize;
    ///Initial weight of the font. If the weight is below 550 (the average of FW_NORMAL, 400, and FW_BOLD, 700), then
    ///the <b>Bold</b> property is also initialized to <b>FALSE</b>. If the weight is above 550, the <b>Bold</b>
    ///property is set to <b>TRUE</b>.
    short   sWeight;
    ///Initial character set of the font.
    short   sCharset;
    ///Initial italic state of the font.
    BOOL    fItalic;
    ///Initial underline state of the font.
    BOOL    fUnderline;
    ///Initial strikethrough state of the font.
    BOOL    fStrikethrough;
}

///Contains parameters to create a picture object through the OleCreatePictureIndirect function.
struct PICTDESC
{
    ///The size of the structure, in bytes.
    uint cbSizeofstruct;
    ///Type of picture described by this structure, which can be any value from the PICTYPE enumeration. This selects
    ///the arm of the union that corresponds to one of the picture type structures below.
    uint picType;
    union
    {
        struct bmp
        {
            HBITMAP  hbitmap;
            HPALETTE hpal;
        }
        struct wmf
        {
            ptrdiff_t hmeta;
            int       xExt;
            int       yExt;
        }
        struct icon
        {
            HICON hicon;
        }
        struct emf
        {
            ptrdiff_t hemf;
        }
    }
}

///Specifies a range of pages.
struct PAGERANGE
{
    ///The first page of the range. This member can have any page number as a value. If this value is greater than the
    ///value specified in <b>nToPage</b>, the document will be printed in reverse page order.
    int nFromPage;
    ///The last page of the range. A special value, <b>PAGESET_TOLASTPAGE</b>, indicates that all the remaining pages
    ///should be printed. This member can have any page number as a value. If this value is less than the value
    ///specified in <b>nFromPage</b>, the document will be printed in reverse page order.
    int nToPage;
}

///Identifies one or more page-ranges to be printed and, optionally, identifies only the even or odd pages as part of a
///pageset.
struct PAGESET
{
    ///The number of bytes in this instance of the <b>PAGESET</b> structure. This member must be a multiple of 4.
    uint         cbStruct;
    ///If <b>TRUE</b>, only the odd-numbered pages in the page-set indicated by <b>rgPages</b> are to be printed.
    BOOL         fOddPages;
    ///If <b>TRUE</b>, only the even-numbered pages in the page-set indicated by <b>rgPages</b> are to be printed.
    BOOL         fEvenPages;
    ///The number of page-range pairs specified in <b>rgPages</b>.
    uint         cPageRange;
    ///Pointer to an array of PAGERANGE structures specifying the pages to be printed. One or more page ranges can be
    ///specified, so long as the number of page ranges is the value of <b>cPageRange</b>. The page ranges must be sorted
    ///in ascending order and must be non-overlapping.
    PAGERANGE[1] rgPages;
}

///Associates command flags from the OLECMDF enumeration with a command identifier through a call to
///IOleCommandTarget::QueryStatus.
struct OLECMD
{
    ///A command identifier; taken from the OLECMDID enumeration.
    uint cmdID;
    ///Flags associated with <b>cmdID</b>; taken from the OLECMDF enumeration.
    uint cmdf;
}

///Specifies a text name or status string for a single command identifier.
struct OLECMDTEXT
{
    ///A value from the OLECMDTEXTF enumeration describing whether the <b>rgwz</b> member contains a command name or
    ///status text.
    uint      cmdtextf;
    ///The number of characters actually written into the <b>rgwz</b> buffer before IOleCommandTarget::QueryStatus
    ///returns.
    uint      cwActual;
    ///The number of elements in the <b>rgwz</b> array.
    uint      cwBuf;
    ///A caller-allocated array of wide characters to receive the command name or status text.
    ushort[1] rgwz;
}

///Contains information that the OLE User Interface Library uses to initialize the <b>Insert Object</b> dialog box, and
///space for the library to return information when the dialog box is dismissed.
struct OLEUIINSERTOBJECTW
{
    ///The size of the structure, in bytes. This field must be filled on input.
    uint           cbStruct;
    ///On input, specifies the initialization and creation flags. On exit, specifies the user's choices. It can be a
    ///combination of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="IOF_SHOWHELP"></a><a id="iof_showhelp"></a><dl> <dt><b>IOF_SHOWHELP</b></dt> </dl> </td> <td width="60%"> The
    ///dialog box will display a <b>Help</b> button. </td> </tr> <tr> <td width="40%"><a id="IOF_SELECTCREATENEW"></a><a
    ///id="iof_selectcreatenew"></a><dl> <dt><b>IOF_SELECTCREATENEW</b></dt> </dl> </td> <td width="60%"> The <b>Create
    ///New</b> radio button will initially be checked. This cannot be used with IOF_SELECTCREATEFROMFILE. </td> </tr>
    ///<tr> <td width="40%"><a id="IOF_SELECTCREATEFROMFILE"></a><a id="iof_selectcreatefromfile"></a><dl>
    ///<dt><b>IOF_SELECTCREATEFROMFILE</b></dt> </dl> </td> <td width="60%"> The <b>Create From File</b> radio button
    ///will initially be checked. This cannot be used with IOF_SELECTCREATENEW. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_CHECKLINK"></a><a id="iof_checklink"></a><dl> <dt><b>IOF_CHECKLINK</b></dt> </dl> </td> <td width="60%">
    ///The <b>Link</b> check box will initially be checked. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_CHECKDISPLAYASICON"></a><a id="iof_checkdisplayasicon"></a><dl> <dt><b>IOF_CHECKDISPLAYASICON</b></dt>
    ///</dl> </td> <td width="60%"> The <b>Display As Icon</b> check box will initially be checked, the current icon
    ///will be displayed, and the <b>Change Icon</b> button will be enabled. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_CREATENEWOBJECT"></a><a id="iof_createnewobject"></a><dl> <dt><b>IOF_CREATENEWOBJECT</b></dt> </dl> </td>
    ///<td width="60%"> A new object should be created when the user selects <b>OK</b> to dismiss the dialog box and the
    ///<b>Create New</b> radio button was selected. </td> </tr> <tr> <td width="40%"><a id="IOF_CREATEFILEOBJECT"></a><a
    ///id="iof_createfileobject"></a><dl> <dt><b>IOF_CREATEFILEOBJECT</b></dt> </dl> </td> <td width="60%"> A new object
    ///should be created from the specified file when the user selects <b>OK</b> to dismiss the dialog box and the
    ///<b>Create From File</b> radio button was selected. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_CREATELINKOBJECT"></a><a id="iof_createlinkobject"></a><dl> <dt><b>IOF_CREATELINKOBJECT</b></dt> </dl>
    ///</td> <td width="60%"> A new linked object should be created when the user selects <b>OK</b> to dismiss the
    ///dialog box and the user checked the <b>Link</b> check box. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_DISABLELINK"></a><a id="iof_disablelink"></a><dl> <dt><b>IOF_DISABLELINK</b></dt> </dl> </td> <td
    ///width="60%"> The <b>Link</b> check box will be disabled on initialization. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_VERIFYSERVERSEXIST"></a><a id="iof_verifyserversexist"></a><dl> <dt><b>IOF_VERIFYSERVERSEXIST</b></dt>
    ///</dl> </td> <td width="60%"> The dialog box should validate the classes it adds to the listbox by ensuring that
    ///the server specified in the registration database exists. This is a significant performance factor. </td> </tr>
    ///<tr> <td width="40%"><a id="IOF_DISABLEDISPLAYASICON"></a><a id="iof_disabledisplayasicon"></a><dl>
    ///<dt><b>IOF_DISABLEDISPLAYASICON</b></dt> </dl> </td> <td width="60%"> The <b>Display As Icon</b> check box will
    ///be disabled on initialization. </td> </tr> <tr> <td width="40%"><a id="IOF_HIDECHANGEICON"></a><a
    ///id="iof_hidechangeicon"></a><dl> <dt><b>IOF_HIDECHANGEICON</b></dt> </dl> </td> <td width="60%"> The <b>Change
    ///Icon</b> button will be hidden in the <b>Insert Object</b> dialog box. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_SHOWINSERTCONTROL"></a><a id="iof_showinsertcontrol"></a><dl> <dt><b>IOF_SHOWINSERTCONTROL</b></dt> </dl>
    ///</td> <td width="60%"> Displays the <b>Insert Control</b> radio button. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_SELECTCREATECONTROL"></a><a id="iof_selectcreatecontrol"></a><dl> <dt><b>IOF_SELECTCREATECONTROL</b></dt>
    ///</dl> </td> <td width="60%"> Displays the <b>Create Control</b> radio button. </td> </tr> </table>
    uint           dwFlags;
    ///The window that owns the dialog box. This member should not be <b>NULL</b>.
    HWND           hWndOwner;
    ///Pointer to a string to be used as the title of the dialog box. If <b>NULL</b>, then the library uses <b>Insert
    ///Object</b>.
    const(wchar)*  lpszCaption;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK  lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the <b>lpfnHook</b> member.
    ///The library passes a pointer to the <b>OLEUIINSERTOBJECT</b> structure in the <i>lParam</i> parameter of the
    ///WM_INITDIALOG message; this pointer can be used to retrieve the <b>lCustData</b> member.
    LPARAM         lCustData;
    ///Instance that contains a dialog box template specified by the <b>lpTemplateName</b> member.
    HINSTANCE      hInstance;
    ///Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that
    ///is to be substituted for the library's <b>Insert Object</b> dialog box template.
    const(wchar)*  lpszTemplate;
    ///Customized template handle.
    ptrdiff_t      hResource;
    ///CLSID for class of the object to be inserted. Filled on output.
    GUID           clsid;
    ///Pointer to the name of the file to be linked or embedded. Filled on output.
    const(wchar)*  lpszFile;
    ///Size of <b>lpszFile</b> buffer; will not exceed MAX_PATH.
    uint           cchFile;
    ///Number of CLSIDs included in the <b>lpClsidExclude</b> list. Filled on input.
    uint           cClsidExclude;
    ///Pointer to a list of CLSIDs to exclude from listing.
    GUID*          lpClsidExclude;
    ///Identifier of the requested interface. If OleUIInsertObject creates the object, then it will return a pointer to
    ///this interface. This parameter is ignored if <b>OleUIInsertObject</b> does not create the object.
    GUID           iid;
    ///Rendering option. If OleUIInsertObject creates the object, then it selects the rendering option when it creates
    ///the object. This parameter is ignored if <b>OleUIInsertObject</b> does not create the object.
    uint           oleRender;
    ///Desired format. If OleUIInsertObject creates the object, then it selects the format when it creates the object.
    ///This parameter is ignored if <b>OleUIInsertObject</b> does not create the object.
    FORMATETC*     lpFormatEtc;
    ///Pointer to the client site to be used for the object. This parameter is ignored if OleUIInsertObject does not
    ///create the object.
    IOleClientSite lpIOleClientSite;
    ///Pointer to the storage to be used for the object. This parameter is ignored if OleUIInsertObject does not create
    ///the object.
    IStorage       lpIStorage;
    ///Address of output pointer variable that contains the interface pointer for the object being inserted. This
    ///parameter is ignored if OleUIInsertObject does not create the object.
    void**         ppvObj;
    ///Result of creation calls. This parameter is ignored if OleUIInsertObject does not create the object.
    int            sc;
    ///MetafilePict structure containing the iconic aspect, if it wasn't placed in the object's cache.
    ptrdiff_t      hMetaPict;
}

///Contains information that the OLE User Interface Library uses to initialize the <b>Insert Object</b> dialog box, and
///space for the library to return information when the dialog box is dismissed.
struct OLEUIINSERTOBJECTA
{
    ///The size of the structure, in bytes. This field must be filled on input.
    uint           cbStruct;
    ///On input, specifies the initialization and creation flags. On exit, specifies the user's choices. It can be a
    ///combination of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="IOF_SHOWHELP"></a><a id="iof_showhelp"></a><dl> <dt><b>IOF_SHOWHELP</b></dt> </dl> </td> <td width="60%"> The
    ///dialog box will display a <b>Help</b> button. </td> </tr> <tr> <td width="40%"><a id="IOF_SELECTCREATENEW"></a><a
    ///id="iof_selectcreatenew"></a><dl> <dt><b>IOF_SELECTCREATENEW</b></dt> </dl> </td> <td width="60%"> The <b>Create
    ///New</b> radio button will initially be checked. This cannot be used with IOF_SELECTCREATEFROMFILE. </td> </tr>
    ///<tr> <td width="40%"><a id="IOF_SELECTCREATEFROMFILE"></a><a id="iof_selectcreatefromfile"></a><dl>
    ///<dt><b>IOF_SELECTCREATEFROMFILE</b></dt> </dl> </td> <td width="60%"> The <b>Create From File</b> radio button
    ///will initially be checked. This cannot be used with IOF_SELECTCREATENEW. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_CHECKLINK"></a><a id="iof_checklink"></a><dl> <dt><b>IOF_CHECKLINK</b></dt> </dl> </td> <td width="60%">
    ///The <b>Link</b> check box will initially be checked. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_CHECKDISPLAYASICON"></a><a id="iof_checkdisplayasicon"></a><dl> <dt><b>IOF_CHECKDISPLAYASICON</b></dt>
    ///</dl> </td> <td width="60%"> The <b>Display As Icon</b> check box will initially be checked, the current icon
    ///will be displayed, and the <b>Change Icon</b> button will be enabled. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_CREATENEWOBJECT"></a><a id="iof_createnewobject"></a><dl> <dt><b>IOF_CREATENEWOBJECT</b></dt> </dl> </td>
    ///<td width="60%"> A new object should be created when the user selects <b>OK</b> to dismiss the dialog box and the
    ///<b>Create New</b> radio button was selected. </td> </tr> <tr> <td width="40%"><a id="IOF_CREATEFILEOBJECT"></a><a
    ///id="iof_createfileobject"></a><dl> <dt><b>IOF_CREATEFILEOBJECT</b></dt> </dl> </td> <td width="60%"> A new object
    ///should be created from the specified file when the user selects <b>OK</b> to dismiss the dialog box and the
    ///<b>Create From File</b> radio button was selected. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_CREATELINKOBJECT"></a><a id="iof_createlinkobject"></a><dl> <dt><b>IOF_CREATELINKOBJECT</b></dt> </dl>
    ///</td> <td width="60%"> A new linked object should be created when the user selects <b>OK</b> to dismiss the
    ///dialog box and the user checked the <b>Link</b> check box. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_DISABLELINK"></a><a id="iof_disablelink"></a><dl> <dt><b>IOF_DISABLELINK</b></dt> </dl> </td> <td
    ///width="60%"> The <b>Link</b> check box will be disabled on initialization. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_VERIFYSERVERSEXIST"></a><a id="iof_verifyserversexist"></a><dl> <dt><b>IOF_VERIFYSERVERSEXIST</b></dt>
    ///</dl> </td> <td width="60%"> The dialog box should validate the classes it adds to the listbox by ensuring that
    ///the server specified in the registration database exists. This is a significant performance factor. </td> </tr>
    ///<tr> <td width="40%"><a id="IOF_DISABLEDISPLAYASICON"></a><a id="iof_disabledisplayasicon"></a><dl>
    ///<dt><b>IOF_DISABLEDISPLAYASICON</b></dt> </dl> </td> <td width="60%"> The <b>Display As Icon</b> check box will
    ///be disabled on initialization. </td> </tr> <tr> <td width="40%"><a id="IOF_HIDECHANGEICON"></a><a
    ///id="iof_hidechangeicon"></a><dl> <dt><b>IOF_HIDECHANGEICON</b></dt> </dl> </td> <td width="60%"> The <b>Change
    ///Icon</b> button will be hidden in the <b>Insert Object</b> dialog box. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_SHOWINSERTCONTROL"></a><a id="iof_showinsertcontrol"></a><dl> <dt><b>IOF_SHOWINSERTCONTROL</b></dt> </dl>
    ///</td> <td width="60%"> Displays the <b>Insert Control</b> radio button. </td> </tr> <tr> <td width="40%"><a
    ///id="IOF_SELECTCREATECONTROL"></a><a id="iof_selectcreatecontrol"></a><dl> <dt><b>IOF_SELECTCREATECONTROL</b></dt>
    ///</dl> </td> <td width="60%"> Displays the <b>Create Control</b> radio button. </td> </tr> </table>
    uint           dwFlags;
    ///The window that owns the dialog box. This member should not be <b>NULL</b>.
    HWND           hWndOwner;
    ///Pointer to a string to be used as the title of the dialog box. If <b>NULL</b>, then the library uses <b>Insert
    ///Object</b>.
    const(char)*   lpszCaption;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK  lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the <b>lpfnHook</b> member.
    ///The library passes a pointer to the <b>OLEUIINSERTOBJECT</b> structure in the <i>lParam</i> parameter of the
    ///WM_INITDIALOG message; this pointer can be used to retrieve the <b>lCustData</b> member.
    LPARAM         lCustData;
    ///Instance that contains a dialog box template specified by the <b>lpTemplateName</b> member.
    HINSTANCE      hInstance;
    ///Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that
    ///is to be substituted for the library's <b>Insert Object</b> dialog box template.
    const(char)*   lpszTemplate;
    ///Customized template handle.
    ptrdiff_t      hResource;
    ///CLSID for class of the object to be inserted. Filled on output.
    GUID           clsid;
    ///Pointer to the name of the file to be linked or embedded. Filled on output.
    const(char)*   lpszFile;
    ///Size of <b>lpszFile</b> buffer; will not exceed MAX_PATH.
    uint           cchFile;
    ///Number of CLSIDs included in the <b>lpClsidExclude</b> list. Filled on input.
    uint           cClsidExclude;
    ///Pointer to a list of CLSIDs to exclude from listing.
    GUID*          lpClsidExclude;
    ///Identifier of the requested interface. If OleUIInsertObject creates the object, then it will return a pointer to
    ///this interface. This parameter is ignored if <b>OleUIInsertObject</b> does not create the object.
    GUID           iid;
    ///Rendering option. If OleUIInsertObject creates the object, then it selects the rendering option when it creates
    ///the object. This parameter is ignored if <b>OleUIInsertObject</b> does not create the object.
    uint           oleRender;
    ///Desired format. If OleUIInsertObject creates the object, then it selects the format when it creates the object.
    ///This parameter is ignored if <b>OleUIInsertObject</b> does not create the object.
    FORMATETC*     lpFormatEtc;
    ///Pointer to the client site to be used for the object. This parameter is ignored if OleUIInsertObject does not
    ///create the object.
    IOleClientSite lpIOleClientSite;
    ///Pointer to the storage to be used for the object. This parameter is ignored if OleUIInsertObject does not create
    ///the object.
    IStorage       lpIStorage;
    ///Address of output pointer variable that contains the interface pointer for the object being inserted. This
    ///parameter is ignored if OleUIInsertObject does not create the object.
    void**         ppvObj;
    ///Result of creation calls. This parameter is ignored if OleUIInsertObject does not create the object.
    int            sc;
    ///MetafilePict structure containing the iconic aspect, if it wasn't placed in the object's cache.
    ptrdiff_t      hMetaPict;
}

///An array of entries to be specified in the OLEUIPASTESPECIAL structure for the <b>Paste Special</b> dialog box. Each
///entry includes a FORMATETC structure which specifies the formats that are acceptable, a string that is to represent
///the format in the dialog box's listbox, a string to customize the result text of the dialog box, and a set of flags
///from the OLEUIPASTEFLAG enumeration. The flags indicate if the entry is valid for pasting only, linking only or both
///pasting and linking. If the entry is valid for linking, the flags indicate which link types are acceptable by OR'ing
///together the appropriate OLEUIPASTE_LINKTYPE<i>n</i> values.
struct OLEUIPASTEENTRYW
{
    ///Format that is acceptable. The <b>Paste Special</b> dialog box checks if this format is offered by the object on
    ///the clipboard and if so, offers it for selection to the user.
    FORMATETC     fmtetc;
    ///Pointer to the string that represents the format to the user. Any %s in this string is replaced by the
    ///FullUserTypeName of the object on the clipboard and the resulting string is placed in the list box of the dialog
    ///box. Only one %s is allowed. The presence or absence of %s specifies whether the result-text is to indicate that
    ///data is being pasted or that an object that can be activated by an application is being pasted. If %s is present,
    ///the resulting text says that an object is being pasted. Otherwise, it says that data is being pasted.
    const(wchar)* lpstrFormatName;
    ///Pointer to the string used to customize the resulting text of the dialog box when the user selects the format
    ///corresponding to this entry. Any %s in this string is replaced by the application name or FullUserTypeName of the
    ///object on the clipboard. Only one %s is allowed.
    const(wchar)* lpstrResultText;
    ///Values from OLEUIPASTEFLAG enumeration.
    uint          dwFlags;
    ///Scratch space available to routines that loop through an IEnumFORMATETC to mark if the PasteEntry format is
    ///available. This field can be left uninitialized.
    uint          dwScratchSpace;
}

///An array of entries to be specified in the OLEUIPASTESPECIAL structure for the <b>Paste Special</b> dialog box. Each
///entry includes a FORMATETC structure which specifies the formats that are acceptable, a string that is to represent
///the format in the dialog box's listbox, a string to customize the result text of the dialog box, and a set of flags
///from the OLEUIPASTEFLAG enumeration. The flags indicate if the entry is valid for pasting only, linking only or both
///pasting and linking. If the entry is valid for linking, the flags indicate which link types are acceptable by OR'ing
///together the appropriate OLEUIPASTE_LINKTYPE<i>n</i> values.
struct OLEUIPASTEENTRYA
{
    ///Format that is acceptable. The <b>Paste Special</b> dialog box checks if this format is offered by the object on
    ///the clipboard and if so, offers it for selection to the user.
    FORMATETC    fmtetc;
    ///Pointer to the string that represents the format to the user. Any %s in this string is replaced by the
    ///FullUserTypeName of the object on the clipboard and the resulting string is placed in the list box of the dialog
    ///box. Only one %s is allowed. The presence or absence of %s specifies whether the result-text is to indicate that
    ///data is being pasted or that an object that can be activated by an application is being pasted. If %s is present,
    ///the resulting text says that an object is being pasted. Otherwise, it says that data is being pasted.
    const(char)* lpstrFormatName;
    ///Pointer to the string used to customize the resulting text of the dialog box when the user selects the format
    ///corresponding to this entry. Any %s in this string is replaced by the application name or FullUserTypeName of the
    ///object on the clipboard. Only one %s is allowed.
    const(char)* lpstrResultText;
    ///Values from OLEUIPASTEFLAG enumeration.
    uint         dwFlags;
    ///Scratch space available to routines that loop through an IEnumFORMATETC to mark if the PasteEntry format is
    ///available. This field can be left uninitialized.
    uint         dwScratchSpace;
}

///Contains information that the OLE User Interface Library uses to initialize the <b>Paste Special</b> dialog box, as
///well as space for the library to return information when the dialog box is dismissed.
struct OLEUIPASTESPECIALW
{
    ///The size of the structure, in bytes. This member must be filled on input.
    uint              cbStruct;
    ///On input, <b>dwFlags</b> specifies the initialization and creation flags. On exit, it specifies the user's
    ///choices. It may be a combination of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="PSF_SHOWHELP"></a><a id="psf_showhelp"></a><dl> <dt><b>PSF_SHOWHELP</b></dt> </dl> </td>
    ///<td width="60%"> Dialog box will display a <b>Help</b> button. </td> </tr> <tr> <td width="40%"><a
    ///id="PSF_SELECTPASTE"></a><a id="psf_selectpaste"></a><dl> <dt><b>PSF_SELECTPASTE</b></dt> </dl> </td> <td
    ///width="60%"> The <b>Paste</b> radio button will be selected at dialog box startup. This is the default, if
    ///PSF_SELECTPASTE or PSF_SELECTPASTELINK are not specified. Also, it specifies the state of the button on dialog
    ///termination. IN/OUT flag. </td> </tr> <tr> <td width="40%"><a id="PSF_SELECTPASTELINK"></a><a
    ///id="psf_selectpastelink"></a><dl> <dt><b>PSF_SELECTPASTELINK</b></dt> </dl> </td> <td width="60%"> The
    ///<b>PasteLink</b> radio button will be selected at dialog box startup. Also, specifies the state of the button on
    ///dialog termination. IN/OUT flag. </td> </tr> <tr> <td width="40%"><a id="PSF_CHECKDISPLAYASICON"></a><a
    ///id="psf_checkdisplayasicon"></a><dl> <dt><b>PSF_CHECKDISPLAYASICON</b></dt> </dl> </td> <td width="60%"> Whether
    ///the <b>Display As Icon</b> radio button was checked on dialog box termination. OUT flag. </td> </tr> <tr> <td
    ///width="40%"><a id="PSF_DISABLEDISPLAYASICON"></a><a id="psf_disabledisplayasicon"></a><dl>
    ///<dt><b>PSF_DISABLEDISPLAYASICON</b></dt> </dl> </td> <td width="60%"> The <b>Display As Icon</b> check box will
    ///be disabled on initialization. </td> </tr> <tr> <td width="40%"><a id="HIDECHANGEICON"></a><a
    ///id="hidechangeicon"></a><dl> <dt><b>HIDECHANGEICON</b></dt> </dl> </td> <td width="60%"> Used to disable the
    ///change-icon button in the dialog box, which is available to users when they're pasting an OLE object by default.
    ///See <b>STAYONCLIPBOARDCHANGE</b> otherwise. </td> </tr> <tr> <td width="40%"><a id="STAYONCLIPBOARDCHANGE"></a><a
    ///id="stayonclipboardchange"></a><dl> <dt><b>STAYONCLIPBOARDCHANGE</b></dt> </dl> </td> <td width="60%"> Used to
    ///tell the dialog box to stay up if the clipboard changes while the dialog box is up. If the user switches to
    ///another application and copies or cuts something, the dialog box will, by default, perform a cancel operation,
    ///which will remove the dialog box since the options it's in the middle of presenting to the user are no longer
    ///up-to-date with respect to what's really on the clipboard. </td> </tr> <tr> <td width="40%"><a
    ///id="NOREFRESHDATAOBJECT"></a><a id="norefreshdataobject"></a><dl> <dt><b>NOREFRESHDATAOBJECT</b></dt> </dl> </td>
    ///<td width="60%"> Used in conjunction with <b>STAYONCLIPBOARDCHANGE</b> (it doesn't do anything otherwise). If the
    ///clipboard changes while the dialog box is up and <b>STAYONCLIPBOARDCHANGE</b> is specified, then
    ///<b>NOREFRESHDATAOBJECT</b> indicates that the dialog box should NOT refresh the contents of the dialog box to
    ///reflect the new contents of the clipboard. This is useful if the application is using the paste-special dialog
    ///box on an IDataObject besides the one on the clipboard, for example, as part of a right-click drag-and-drop
    ///operation. </td> </tr> </table>
    uint              dwFlags;
    ///The window that owns the dialog box. This member should not be <b>NULL</b>.
    HWND              hWndOwner;
    ///Pointer to a string to be used as the title of the dialog box. If <b>NULL</b>, then the library uses <b>Paste
    ///Special</b>.
    const(wchar)*     lpszCaption;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK     lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the <b>lpfnHook</b> member.
    ///The library passes a pointer to the <b>OLEUIPASTESPECIAL</b> structure in the <b>lParam</b> parameter of the
    ///WM_INITDIALOG message; this pointer can be used to retrieve the <b>lCustData</b> member.
    LPARAM            lCustData;
    ///Instance that contains a dialog box template specified by the <b>lpTemplateName</b> member.
    HINSTANCE         hInstance;
    ///Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that
    ///is to be substituted for the library's <b>Paste Special</b> dialog box template.
    const(wchar)*     lpszTemplate;
    ///Customized template handle.
    ptrdiff_t         hResource;
    ///Pointer to the IDataObject interface of the data object to be pasted (from the clipboard). This member is filled
    ///on input. If <b>lpSrcDataObj</b> is <b>NULL</b> when OleUIPasteSpecial is called, then <b>OleUIPasteSpecial</b>
    ///will attempt to retrieve a pointer to an <b>IDataObject</b> from the clipboard. If <b>OleUIPasteSpecial</b>
    ///succeeds, it is the caller's responsibility to free the <b>IDataObject</b> returned in <b>lpSrcDataObj</b>.
    IDataObject       lpSrcDataObj;
    ///The OLEUIPASTEENTRY array which specifies acceptable formats. This member is filled on input.
    OLEUIPASTEENTRYW* arrPasteEntries;
    ///Number of OLEUIPASTEENTRY array entries. This member is filled on input.
    int               cPasteEntries;
    ///List of link types that are acceptable. Link types are referred to using OLEUIPASTEFLAG in
    ///<b>arrPasteEntries</b>. This member is filled on input.
    uint*             arrLinkTypes;
    ///Number of link types. This member is filled on input.
    int               cLinkTypes;
    ///Number of CLSIDs in <b>lpClsidExclude</b>. This member is filled on input.
    uint              cClsidExclude;
    ///Pointer to an array of CLSIDs to exclude from the list of available server objects for a Paste operation. Note
    ///that this does not affect <b>Paste Link</b>. An application can prevent embedding into itself by listing its own
    ///CLSID in this list. This field is filled on input.
    GUID*             lpClsidExclude;
    ///Index of <b>arrPasteEntries</b> that the user selected. This member is filled on output.
    int               nSelectedIndex;
    ///Whether <b>Paste</b> or <b>Paste Link</b> was selected by the user. This member is filled on output.
    BOOL              fLink;
    ///Handle to the Metafile containing the icon and icon title selected by the user. This member is filled on output.
    ptrdiff_t         hMetaPict;
    ///The size of object as displayed in its source, if the display aspect chosen by the user matches the aspect
    ///displayed in the source. If the user chooses a different aspect, then <b>sizel.cx</b> and <b>sizel.cy</b> are
    ///both set to zero. The size of the object as it is displayed in the source is retrieved from the ObjectDescriptor
    ///if <b>fLink</b> is <b>FALSE</b> and from the LinkSrcDescriptor if <b>fLink</b> is <b>TRUE</b>. This member is
    ///filled on output.
    SIZE              sizel;
}

///Contains information that the OLE User Interface Library uses to initialize the <b>Paste Special</b> dialog box, as
///well as space for the library to return information when the dialog box is dismissed.
struct OLEUIPASTESPECIALA
{
    ///The size of the structure, in bytes. This member must be filled on input.
    uint              cbStruct;
    ///On input, <b>dwFlags</b> specifies the initialization and creation flags. On exit, it specifies the user's
    ///choices. It may be a combination of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="PSF_SHOWHELP"></a><a id="psf_showhelp"></a><dl> <dt><b>PSF_SHOWHELP</b></dt> </dl> </td>
    ///<td width="60%"> Dialog box will display a <b>Help</b> button. </td> </tr> <tr> <td width="40%"><a
    ///id="PSF_SELECTPASTE"></a><a id="psf_selectpaste"></a><dl> <dt><b>PSF_SELECTPASTE</b></dt> </dl> </td> <td
    ///width="60%"> The <b>Paste</b> radio button will be selected at dialog box startup. This is the default, if
    ///PSF_SELECTPASTE or PSF_SELECTPASTELINK are not specified. Also, it specifies the state of the button on dialog
    ///termination. IN/OUT flag. </td> </tr> <tr> <td width="40%"><a id="PSF_SELECTPASTELINK"></a><a
    ///id="psf_selectpastelink"></a><dl> <dt><b>PSF_SELECTPASTELINK</b></dt> </dl> </td> <td width="60%"> The
    ///<b>PasteLink</b> radio button will be selected at dialog box startup. Also, specifies the state of the button on
    ///dialog termination. IN/OUT flag. </td> </tr> <tr> <td width="40%"><a id="PSF_CHECKDISPLAYASICON"></a><a
    ///id="psf_checkdisplayasicon"></a><dl> <dt><b>PSF_CHECKDISPLAYASICON</b></dt> </dl> </td> <td width="60%"> Whether
    ///the <b>Display As Icon</b> radio button was checked on dialog box termination. OUT flag. </td> </tr> <tr> <td
    ///width="40%"><a id="PSF_DISABLEDISPLAYASICON"></a><a id="psf_disabledisplayasicon"></a><dl>
    ///<dt><b>PSF_DISABLEDISPLAYASICON</b></dt> </dl> </td> <td width="60%"> The <b>Display As Icon</b> check box will
    ///be disabled on initialization. </td> </tr> <tr> <td width="40%"><a id="HIDECHANGEICON"></a><a
    ///id="hidechangeicon"></a><dl> <dt><b>HIDECHANGEICON</b></dt> </dl> </td> <td width="60%"> Used to disable the
    ///change-icon button in the dialog box, which is available to users when they're pasting an OLE object by default.
    ///See <b>STAYONCLIPBOARDCHANGE</b> otherwise. </td> </tr> <tr> <td width="40%"><a id="STAYONCLIPBOARDCHANGE"></a><a
    ///id="stayonclipboardchange"></a><dl> <dt><b>STAYONCLIPBOARDCHANGE</b></dt> </dl> </td> <td width="60%"> Used to
    ///tell the dialog box to stay up if the clipboard changes while the dialog box is up. If the user switches to
    ///another application and copies or cuts something, the dialog box will, by default, perform a cancel operation,
    ///which will remove the dialog box since the options it's in the middle of presenting to the user are no longer
    ///up-to-date with respect to what's really on the clipboard. </td> </tr> <tr> <td width="40%"><a
    ///id="NOREFRESHDATAOBJECT"></a><a id="norefreshdataobject"></a><dl> <dt><b>NOREFRESHDATAOBJECT</b></dt> </dl> </td>
    ///<td width="60%"> Used in conjunction with <b>STAYONCLIPBOARDCHANGE</b> (it doesn't do anything otherwise). If the
    ///clipboard changes while the dialog box is up and <b>STAYONCLIPBOARDCHANGE</b> is specified, then
    ///<b>NOREFRESHDATAOBJECT</b> indicates that the dialog box should NOT refresh the contents of the dialog box to
    ///reflect the new contents of the clipboard. This is useful if the application is using the paste-special dialog
    ///box on an IDataObject besides the one on the clipboard, for example, as part of a right-click drag-and-drop
    ///operation. </td> </tr> </table>
    uint              dwFlags;
    ///The window that owns the dialog box. This member should not be <b>NULL</b>.
    HWND              hWndOwner;
    ///Pointer to a string to be used as the title of the dialog box. If <b>NULL</b>, then the library uses <b>Paste
    ///Special</b>.
    const(char)*      lpszCaption;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK     lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the <b>lpfnHook</b> member.
    ///The library passes a pointer to the <b>OLEUIPASTESPECIAL</b> structure in the <b>lParam</b> parameter of the
    ///WM_INITDIALOG message; this pointer can be used to retrieve the <b>lCustData</b> member.
    LPARAM            lCustData;
    ///Instance that contains a dialog box template specified by the <b>lpTemplateName</b> member.
    HINSTANCE         hInstance;
    ///Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that
    ///is to be substituted for the library's <b>Paste Special</b> dialog box template.
    const(char)*      lpszTemplate;
    ///Customized template handle.
    ptrdiff_t         hResource;
    ///Pointer to the IDataObject interface of the data object to be pasted (from the clipboard). This member is filled
    ///on input. If <b>lpSrcDataObj</b> is <b>NULL</b> when OleUIPasteSpecial is called, then <b>OleUIPasteSpecial</b>
    ///will attempt to retrieve a pointer to an <b>IDataObject</b> from the clipboard. If <b>OleUIPasteSpecial</b>
    ///succeeds, it is the caller's responsibility to free the <b>IDataObject</b> returned in <b>lpSrcDataObj</b>.
    IDataObject       lpSrcDataObj;
    ///The OLEUIPASTEENTRY array which specifies acceptable formats. This member is filled on input.
    OLEUIPASTEENTRYA* arrPasteEntries;
    ///Number of OLEUIPASTEENTRY array entries. This member is filled on input.
    int               cPasteEntries;
    ///List of link types that are acceptable. Link types are referred to using OLEUIPASTEFLAG in
    ///<b>arrPasteEntries</b>. This member is filled on input.
    uint*             arrLinkTypes;
    ///Number of link types. This member is filled on input.
    int               cLinkTypes;
    ///Number of CLSIDs in <b>lpClsidExclude</b>. This member is filled on input.
    uint              cClsidExclude;
    ///Pointer to an array of CLSIDs to exclude from the list of available server objects for a Paste operation. Note
    ///that this does not affect <b>Paste Link</b>. An application can prevent embedding into itself by listing its own
    ///CLSID in this list. This field is filled on input.
    GUID*             lpClsidExclude;
    ///Index of <b>arrPasteEntries</b> that the user selected. This member is filled on output.
    int               nSelectedIndex;
    ///Whether <b>Paste</b> or <b>Paste Link</b> was selected by the user. This member is filled on output.
    BOOL              fLink;
    ///Handle to the Metafile containing the icon and icon title selected by the user. This member is filled on output.
    ptrdiff_t         hMetaPict;
    ///The size of object as displayed in its source, if the display aspect chosen by the user matches the aspect
    ///displayed in the source. If the user chooses a different aspect, then <b>sizel.cx</b> and <b>sizel.cy</b> are
    ///both set to zero. The size of the object as it is displayed in the source is retrieved from the ObjectDescriptor
    ///if <b>fLink</b> is <b>FALSE</b> and from the LinkSrcDescriptor if <b>fLink</b> is <b>TRUE</b>. This member is
    ///filled on output.
    SIZE              sizel;
}

///Contains information that the OLE User Interface Library uses to initialize the <b>Edit Links</b> dialog box, and
///contains space for the library to return information when the dialog box is dismissed.
struct OLEUIEDITLINKSW
{
    ///The size of the structure, in bytes. This member must be filled on input.
    uint                 cbStruct;
    ///On input, <b>dwFlags</b> specifies the initialization and creation flags. It may be a combination of the
    ///following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="ELF_SHOWHELP"></a><a id="elf_showhelp"></a><dl> <dt><b>ELF_SHOWHELP</b></dt> </dl> </td> <td width="60%">
    ///Specifies that the dialog box will display a <b>Help</b> button. </td> </tr> <tr> <td width="40%"><a
    ///id="ELF_DISABLEUPDATENOW"></a><a id="elf_disableupdatenow"></a><dl> <dt><b>ELF_DISABLEUPDATENOW</b></dt> </dl>
    ///</td> <td width="60%"> Specifies that the <b>Update Now</b> button will be disabled on initialization. </td>
    ///</tr> <tr> <td width="40%"><a id="ELF_DISABLEOPENSOURCE"></a><a id="elf_disableopensource"></a><dl>
    ///<dt><b>ELF_DISABLEOPENSOURCE</b></dt> </dl> </td> <td width="60%"> Specifies that the <b>Open Source</b> button
    ///will be disabled on initialization. </td> </tr> <tr> <td width="40%"><a id="ELF_DISABLECHANGESOURCE"></a><a
    ///id="elf_disablechangesource"></a><dl> <dt><b>ELF_DISABLECHANGESOURCE</b></dt> </dl> </td> <td width="60%">
    ///Specifies that the <b>Change Source</b> button will be disabled on initialization. </td> </tr> <tr> <td
    ///width="40%"><a id="ELF_DISABLECANCELLINK"></a><a id="elf_disablecancellink"></a><dl>
    ///<dt><b>ELF_DISABLECANCELLINK</b></dt> </dl> </td> <td width="60%"> Specifies that the <b>Cancel Link</b> button
    ///will be disabled on initialization. </td> </tr> </table>
    uint                 dwFlags;
    ///The window that owns the dialog box. This member should not be <b>NULL</b>.
    HWND                 hWndOwner;
    ///Pointer to a string to be used as the title of the dialog box. If <b>NULL</b>, then the library uses
    ///<b>Links</b>.
    const(wchar)*        lpszCaption;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK        lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the <b>lpfnHook</b> member.
    ///The library passes a pointer to the <b>OLEUIEDITLINKS</b> structure in the <i>lParam</i> parameter of the
    ///WM_INITDIALOG message; this pointer can be used to retrieve the <b>lCustData</b> member.
    LPARAM               lCustData;
    ///Instance that contains a dialog box template specified by the <b>lpTemplateName</b> member.
    HINSTANCE            hInstance;
    ///Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that
    ///is to be substituted for the library's <b>Edit Links</b> dialog box template.
    const(wchar)*        lpszTemplate;
    ///Customized template handle.
    ptrdiff_t            hResource;
    ///Pointer to the container's implementation of the IOleUILinkContainer Interface. The <b>Edit Links</b> dialog box
    ///uses this to allow the container to manipulate its links.
    IOleUILinkContainerW lpOleUILinkContainer;
}

///Contains information that the OLE User Interface Library uses to initialize the <b>Edit Links</b> dialog box, and
///contains space for the library to return information when the dialog box is dismissed.
struct OLEUIEDITLINKSA
{
    ///The size of the structure, in bytes. This member must be filled on input.
    uint                 cbStruct;
    ///On input, <b>dwFlags</b> specifies the initialization and creation flags. It may be a combination of the
    ///following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="ELF_SHOWHELP"></a><a id="elf_showhelp"></a><dl> <dt><b>ELF_SHOWHELP</b></dt> </dl> </td> <td width="60%">
    ///Specifies that the dialog box will display a <b>Help</b> button. </td> </tr> <tr> <td width="40%"><a
    ///id="ELF_DISABLEUPDATENOW"></a><a id="elf_disableupdatenow"></a><dl> <dt><b>ELF_DISABLEUPDATENOW</b></dt> </dl>
    ///</td> <td width="60%"> Specifies that the <b>Update Now</b> button will be disabled on initialization. </td>
    ///</tr> <tr> <td width="40%"><a id="ELF_DISABLEOPENSOURCE"></a><a id="elf_disableopensource"></a><dl>
    ///<dt><b>ELF_DISABLEOPENSOURCE</b></dt> </dl> </td> <td width="60%"> Specifies that the <b>Open Source</b> button
    ///will be disabled on initialization. </td> </tr> <tr> <td width="40%"><a id="ELF_DISABLECHANGESOURCE"></a><a
    ///id="elf_disablechangesource"></a><dl> <dt><b>ELF_DISABLECHANGESOURCE</b></dt> </dl> </td> <td width="60%">
    ///Specifies that the <b>Change Source</b> button will be disabled on initialization. </td> </tr> <tr> <td
    ///width="40%"><a id="ELF_DISABLECANCELLINK"></a><a id="elf_disablecancellink"></a><dl>
    ///<dt><b>ELF_DISABLECANCELLINK</b></dt> </dl> </td> <td width="60%"> Specifies that the <b>Cancel Link</b> button
    ///will be disabled on initialization. </td> </tr> </table>
    uint                 dwFlags;
    ///The window that owns the dialog box. This member should not be <b>NULL</b>.
    HWND                 hWndOwner;
    ///Pointer to a string to be used as the title of the dialog box. If <b>NULL</b>, then the library uses
    ///<b>Links</b>.
    const(char)*         lpszCaption;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK        lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the <b>lpfnHook</b> member.
    ///The library passes a pointer to the <b>OLEUIEDITLINKS</b> structure in the <i>lParam</i> parameter of the
    ///WM_INITDIALOG message; this pointer can be used to retrieve the <b>lCustData</b> member.
    LPARAM               lCustData;
    ///Instance that contains a dialog box template specified by the <b>lpTemplateName</b> member.
    HINSTANCE            hInstance;
    ///Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that
    ///is to be substituted for the library's <b>Edit Links</b> dialog box template.
    const(char)*         lpszTemplate;
    ///Customized template handle.
    ptrdiff_t            hResource;
    ///Pointer to the container's implementation of the IOleUILinkContainer Interface. The <b>Edit Links</b> dialog box
    ///uses this to allow the container to manipulate its links.
    IOleUILinkContainerA lpOleUILinkContainer;
}

///Contains information that the OLE User Interface Library uses to initialize the **Change Icon** dialog box, and it
///contains space for the library to return information when the dialog box is dismissed.
struct OLEUICHANGEICONW
{
    ///The size of the structure, in bytes. This field must be filled on input.
    uint          cbStruct;
    ///On input, specifies the initialization and creation flags. On exit, it specifies the user's choices. It can be a
    ///combination of the following flags. | Value | Meaning |
    ///|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    ///| **CIF\_SHOWHELP** | Dialog box will display a **Help** button. | | **CIF\_SELECTCURRENT** | On input, selects
    ///the **Current** radio button on initialization. On exit, specifies that the user selected **Current**. | |
    ///**CIF\_SELECTDEFAULT** | On input, selects the **Default** radio button on initialization. On exit, specifies
    ///that the user selected **Default**. | | **CIF\_SELECTFROMFILE** | On input, selects the **From File** radio
    ///button on initialization. On exit, specifies that the user selected **From File**. | | **CIF\_USEICONEXE** |
    ///Input only. Extracts the icon from the executable specified in the **szIconExe** member, instead of retrieving it
    ///from the class. This is useful for OLE embedding or linking to non-OLE files. |
    uint          dwFlags;
    ///The window that owns the dialog box. This member should not be **NULL**.
    HWND          hWndOwner;
    ///Pointer to a string to be used as the title of the dialog box. If **NULL**, then the library uses **Change
    ///Icon**.
    const(wchar)* lpszCaption;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the **lpfnHook** member. The
    ///library passes a pointer to the **OLEUICHANGEICON** structure in the lParam parameter of the WM\_INITDIALOG
    ///message; this pointer can be used to retrieve the **lCustData** member.
    LPARAM        lCustData;
    ///Instance that contains a dialog box template specified by the **lpTemplateName** member.
    HINSTANCE     hInstance;
    ///Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that
    ///is to be substituted for the library's **Change Icon** dialog box template.
    const(wchar)* lpszTemplate;
    ///Customized template handle.
    ptrdiff_t     hResource;
    ///Current and final image. The source of the icon is embedded in the metafile itself.
    ptrdiff_t     hMetaPict;
    ///Input only. The class to use to get the **Default** icon.
    GUID          clsid;
    ///Input only. Pointer to the executable to extract the default icon from. This member is ignored unless
    ///CIF\_USEICONEXE is included in the **dwFlags** member and an attempt to retrieve the class icon from the
    ///specified CLSID fails.
    ushort[260]   szIconExe;
    ///Input only. The number of characters in **szIconExe**. This member is ignored unless CIF\_USEICONEXE is included
    ///in the **dwFlags** member.
    int           cchIconExe;
}

///Contains information that the OLE User Interface Library uses to initialize the **Change Icon** dialog box, and it
///contains space for the library to return information when the dialog box is dismissed.
struct OLEUICHANGEICONA
{
    ///The size of the structure, in bytes. This field must be filled on input.
    uint          cbStruct;
    ///On input, specifies the initialization and creation flags. On exit, it specifies the user's choices. It can be a
    ///combination of the following flags. | Value | Meaning |
    ///|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    ///| **CIF\_SHOWHELP** | Dialog box will display a **Help** button. | | **CIF\_SELECTCURRENT** | On input, selects
    ///the **Current** radio button on initialization. On exit, specifies that the user selected **Current**. | |
    ///**CIF\_SELECTDEFAULT** | On input, selects the **Default** radio button on initialization. On exit, specifies
    ///that the user selected **Default**. | | **CIF\_SELECTFROMFILE** | On input, selects the **From File** radio
    ///button on initialization. On exit, specifies that the user selected **From File**. | | **CIF\_USEICONEXE** |
    ///Input only. Extracts the icon from the executable specified in the **szIconExe** member, instead of retrieving it
    ///from the class. This is useful for OLE embedding or linking to non-OLE files. |
    uint          dwFlags;
    ///The window that owns the dialog box. This member should not be **NULL**.
    HWND          hWndOwner;
    ///Pointer to a string to be used as the title of the dialog box. If **NULL**, then the library uses **Change
    ///Icon**.
    const(char)*  lpszCaption;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the **lpfnHook** member. The
    ///library passes a pointer to the **OLEUICHANGEICON** structure in the lParam parameter of the WM\_INITDIALOG
    ///message; this pointer can be used to retrieve the **lCustData** member.
    LPARAM        lCustData;
    ///Instance that contains a dialog box template specified by the **lpTemplateName** member.
    HINSTANCE     hInstance;
    ///Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that
    ///is to be substituted for the library's **Change Icon** dialog box template.
    const(char)*  lpszTemplate;
    ///Customized template handle.
    ptrdiff_t     hResource;
    ///Current and final image. The source of the icon is embedded in the metafile itself.
    ptrdiff_t     hMetaPict;
    ///Input only. The class to use to get the **Default** icon.
    GUID          clsid;
    ///Input only. Pointer to the executable to extract the default icon from. This member is ignored unless
    ///CIF\_USEICONEXE is included in the **dwFlags** member and an attempt to retrieve the class icon from the
    ///specified CLSID fails.
    byte[260]     szIconExe;
    ///Input only. The number of characters in **szIconExe**. This member is ignored unless CIF\_USEICONEXE is included
    ///in the **dwFlags** member.
    int           cchIconExe;
}

///Contains information that the OLE User Interface Library uses to initialize the <b>Convert</b> dialog box, and space
///for the library to return information when the dialog box is dismissed.
struct OLEUICONVERTW
{
    ///The size of the structure, in bytes. This member must be filled on input.
    uint          cbStruct;
    ///On input, this field specifies the initialization and creation flags. On exit, it specifies the user's choices.
    ///It may be a combination of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="CF_SHOWHELPBUTTON"></a><a id="cf_showhelpbutton"></a><dl> <dt><b>CF_SHOWHELPBUTTON</b></dt>
    ///</dl> </td> <td width="60%"> Dialog box will display a <b>Help</b> button. This flag is set on input. </td> </tr>
    ///<tr> <td width="40%"><a id="CF_SETCONVERTDEFAULT"></a><a id="cf_setconvertdefault"></a><dl>
    ///<dt><b>CF_SETCONVERTDEFAULT</b></dt> </dl> </td> <td width="60%"> Class whose CLSID is specified by
    ///<b>clsidConvertDefault</b> will be used as the default selection. This selection appears in the class listbox
    ///when the <b>Convert To</b> radio button is selected. This flag is set on input. </td> </tr> <tr> <td
    ///width="40%"><a id="CF_SETACTIVATEDEFAULT"></a><a id="cf_setactivatedefault"></a><dl>
    ///<dt><b>CF_SETACTIVATEDEFAULT</b></dt> </dl> </td> <td width="60%"> Class whose CLSID is specified by
    ///<b>clsidActivateDefault</b> will be used as the default selection. This selection appears in the class listbox
    ///when the <b>Activate As</b> radio button is selected. This flag is set on input. </td> </tr> <tr> <td
    ///width="40%"><a id="CF_SELECTCONVERTTO"></a><a id="cf_selectconvertto"></a><dl> <dt><b>CF_SELECTCONVERTTO</b></dt>
    ///</dl> </td> <td width="60%"> On input, this flag specifies that <b>Convert To</b> will be initially selected
    ///(default behavior). This flag is set on output if <b>Convert To</b> was selected when the user dismissed the
    ///dialog box. </td> </tr> <tr> <td width="40%"><a id="CF_SELECTACTIVATEAS"></a><a id="cf_selectactivateas"></a><dl>
    ///<dt><b>CF_SELECTACTIVATEAS</b></dt> </dl> </td> <td width="60%"> On input, this flag specifies that <b>Activate
    ///As</b> will be initially selected. This flag is set on output if <b>Activate As</b> was selected when the user
    ///dismissed the dialog box. </td> </tr> <tr> <td width="40%"><a id="CF_DISABLEDISPLAYASICON"></a><a
    ///id="cf_disabledisplayasicon"></a><dl> <dt><b>CF_DISABLEDISPLAYASICON</b></dt> </dl> </td> <td width="60%"> The
    ///<b>Display As Icon</b> button will be disabled on initialization. </td> </tr> <tr> <td width="40%"><a
    ///id="CF_DISABLEACTIVATEAS"></a><a id="cf_disableactivateas"></a><dl> <dt><b>CF_DISABLEACTIVATEAS</b></dt> </dl>
    ///</td> <td width="60%"> The <b>Activate As</b> radio button will be disabled on initialization. </td> </tr> <tr>
    ///<td width="40%"><a id="CF_HIDECHANGEICON"></a><a id="cf_hidechangeicon"></a><dl>
    ///<dt><b>CF_HIDECHANGEICON</b></dt> </dl> </td> <td width="60%"> The <b>Change Icon</b> button will be hidden in
    ///the <b>Convert</b> dialog box. </td> </tr> <tr> <td width="40%"><a id="CF_CONVERTONLY"></a><a
    ///id="cf_convertonly"></a><dl> <dt><b>CF_CONVERTONLY</b></dt> </dl> </td> <td width="60%"> The <b>Activate As</b>
    ///radio button will be disabled in the <b>Convert</b> dialog box. </td> </tr> </table>
    uint          dwFlags;
    ///The window that owns the dialog box. This member should not be <b>NULL</b>.
    HWND          hWndOwner;
    ///Pointer to a string to be used as the title of the dialog box. If <b>NULL</b>, then the library uses
    ///<b>Convert</b>.
    const(wchar)* lpszCaption;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the <b>lpfnHook</b> member.
    ///The library passes a pointer to the <b>OLEUICONVERT</b> structure in the <i>lParam</i> parameter of the
    ///WM_INITDIALOG message; this pointer can be used to retrieve the <b>lCustData</b> member.
    LPARAM        lCustData;
    ///Instance that contains a dialog box template specified by the <b>lpszTemplate</b> member. This member is ignored
    ///if the <b>lpszTemplate</b> member is <b>NULL</b> or invalid.
    HINSTANCE     hInstance;
    ///Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that
    ///is to be substituted for the library's <b>Convert</b> dialog box template.
    const(wchar)* lpszTemplate;
    ///Resource handle for a custom dialog box. If this member is <b>NULL</b>, then the library uses the standard
    ///<b>Convert</b> dialog box template, or if it is valid, the template named by the <b>lpszTemplate</b> member.
    ptrdiff_t     hResource;
    ///The CLSID of the object to be converted or activated. This member is set on input.
    GUID          clsid;
    ///The CLSID to use as the default class when <b>Convert To</b> is selected. This member is ignored if the
    ///<b>dwFlags</b> member does not include CF_SETCONVERTDEFAULT. This member is set on input.
    GUID          clsidConvertDefault;
    ///The CLSID to use as the default class when <b>Activate As</b> is selected. This member is ignored if the
    ///<b>dwFlags</b> member does not include CF_SETACTIVATEDEFAULT. This member is set on input.
    GUID          clsidActivateDefault;
    ///The CLSID of the selected class. This member is set on output.
    GUID          clsidNew;
    ///Aspect of the object. This must be either DVASPECT_CONTENT or DVASPECT_ICON. If <b>dvAspect</b> is DVASPECT_ICON
    ///on input, then the <b>Display As Icon</b> box is checked and the object's icon is displayed. This member is set
    ///on input and output. For more information, see DVASPECT.
    uint          dvAspect;
    ///Data format of the object to be converted or activated.
    ushort        wFormat;
    ///<b>TRUE</b> if the object is linked. This member is set on input.
    BOOL          fIsLinkedObject;
    ///The METAFILEPICT containing the iconic aspect. This member is set on input and output.
    ptrdiff_t     hMetaPict;
    ///Pointer to the User Type name of the object to be converted or activated. If this value is <b>NULL</b>, then the
    ///dialog box will retrieve the User Type name from the registry. This string is freed on exit.
    const(wchar)* lpszUserType;
    ///<b>TRUE</b> if the object's icon changed. (that is, if OleUIChangeIcon was called and not canceled.). This member
    ///is set on output.
    BOOL          fObjectsIconChanged;
    ///Pointer to the default label to use for the icon. If <b>NULL</b>, the short user type name will be used. If the
    ///object is a link, the caller should pass the display name of the link source. This is freed on exit.
    const(wchar)* lpszDefLabel;
    ///Number of CLSIDs in <i>lpClsidExclude</i>.
    uint          cClsidExclude;
    ///Pointer to the list of CLSIDs to exclude from the list.
    GUID*         lpClsidExclude;
}

///Contains information that the OLE User Interface Library uses to initialize the <b>Convert</b> dialog box, and space
///for the library to return information when the dialog box is dismissed.
struct OLEUICONVERTA
{
    ///The size of the structure, in bytes. This member must be filled on input.
    uint          cbStruct;
    ///On input, this field specifies the initialization and creation flags. On exit, it specifies the user's choices.
    ///It may be a combination of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="CF_SHOWHELPBUTTON"></a><a id="cf_showhelpbutton"></a><dl> <dt><b>CF_SHOWHELPBUTTON</b></dt>
    ///</dl> </td> <td width="60%"> Dialog box will display a <b>Help</b> button. This flag is set on input. </td> </tr>
    ///<tr> <td width="40%"><a id="CF_SETCONVERTDEFAULT"></a><a id="cf_setconvertdefault"></a><dl>
    ///<dt><b>CF_SETCONVERTDEFAULT</b></dt> </dl> </td> <td width="60%"> Class whose CLSID is specified by
    ///<b>clsidConvertDefault</b> will be used as the default selection. This selection appears in the class listbox
    ///when the <b>Convert To</b> radio button is selected. This flag is set on input. </td> </tr> <tr> <td
    ///width="40%"><a id="CF_SETACTIVATEDEFAULT"></a><a id="cf_setactivatedefault"></a><dl>
    ///<dt><b>CF_SETACTIVATEDEFAULT</b></dt> </dl> </td> <td width="60%"> Class whose CLSID is specified by
    ///<b>clsidActivateDefault</b> will be used as the default selection. This selection appears in the class listbox
    ///when the <b>Activate As</b> radio button is selected. This flag is set on input. </td> </tr> <tr> <td
    ///width="40%"><a id="CF_SELECTCONVERTTO"></a><a id="cf_selectconvertto"></a><dl> <dt><b>CF_SELECTCONVERTTO</b></dt>
    ///</dl> </td> <td width="60%"> On input, this flag specifies that <b>Convert To</b> will be initially selected
    ///(default behavior). This flag is set on output if <b>Convert To</b> was selected when the user dismissed the
    ///dialog box. </td> </tr> <tr> <td width="40%"><a id="CF_SELECTACTIVATEAS"></a><a id="cf_selectactivateas"></a><dl>
    ///<dt><b>CF_SELECTACTIVATEAS</b></dt> </dl> </td> <td width="60%"> On input, this flag specifies that <b>Activate
    ///As</b> will be initially selected. This flag is set on output if <b>Activate As</b> was selected when the user
    ///dismissed the dialog box. </td> </tr> <tr> <td width="40%"><a id="CF_DISABLEDISPLAYASICON"></a><a
    ///id="cf_disabledisplayasicon"></a><dl> <dt><b>CF_DISABLEDISPLAYASICON</b></dt> </dl> </td> <td width="60%"> The
    ///<b>Display As Icon</b> button will be disabled on initialization. </td> </tr> <tr> <td width="40%"><a
    ///id="CF_DISABLEACTIVATEAS"></a><a id="cf_disableactivateas"></a><dl> <dt><b>CF_DISABLEACTIVATEAS</b></dt> </dl>
    ///</td> <td width="60%"> The <b>Activate As</b> radio button will be disabled on initialization. </td> </tr> <tr>
    ///<td width="40%"><a id="CF_HIDECHANGEICON"></a><a id="cf_hidechangeicon"></a><dl>
    ///<dt><b>CF_HIDECHANGEICON</b></dt> </dl> </td> <td width="60%"> The <b>Change Icon</b> button will be hidden in
    ///the <b>Convert</b> dialog box. </td> </tr> <tr> <td width="40%"><a id="CF_CONVERTONLY"></a><a
    ///id="cf_convertonly"></a><dl> <dt><b>CF_CONVERTONLY</b></dt> </dl> </td> <td width="60%"> The <b>Activate As</b>
    ///radio button will be disabled in the <b>Convert</b> dialog box. </td> </tr> </table>
    uint          dwFlags;
    ///The window that owns the dialog box. This member should not be <b>NULL</b>.
    HWND          hWndOwner;
    ///Pointer to a string to be used as the title of the dialog box. If <b>NULL</b>, then the library uses
    ///<b>Convert</b>.
    const(char)*  lpszCaption;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the <b>lpfnHook</b> member.
    ///The library passes a pointer to the <b>OLEUICONVERT</b> structure in the <i>lParam</i> parameter of the
    ///WM_INITDIALOG message; this pointer can be used to retrieve the <b>lCustData</b> member.
    LPARAM        lCustData;
    ///Instance that contains a dialog box template specified by the <b>lpszTemplate</b> member. This member is ignored
    ///if the <b>lpszTemplate</b> member is <b>NULL</b> or invalid.
    HINSTANCE     hInstance;
    ///Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that
    ///is to be substituted for the library's <b>Convert</b> dialog box template.
    const(char)*  lpszTemplate;
    ///Resource handle for a custom dialog box. If this member is <b>NULL</b>, then the library uses the standard
    ///<b>Convert</b> dialog box template, or if it is valid, the template named by the <b>lpszTemplate</b> member.
    ptrdiff_t     hResource;
    ///The CLSID of the object to be converted or activated. This member is set on input.
    GUID          clsid;
    ///The CLSID to use as the default class when <b>Convert To</b> is selected. This member is ignored if the
    ///<b>dwFlags</b> member does not include CF_SETCONVERTDEFAULT. This member is set on input.
    GUID          clsidConvertDefault;
    ///The CLSID to use as the default class when <b>Activate As</b> is selected. This member is ignored if the
    ///<b>dwFlags</b> member does not include CF_SETACTIVATEDEFAULT. This member is set on input.
    GUID          clsidActivateDefault;
    ///The CLSID of the selected class. This member is set on output.
    GUID          clsidNew;
    ///Aspect of the object. This must be either DVASPECT_CONTENT or DVASPECT_ICON. If <b>dvAspect</b> is DVASPECT_ICON
    ///on input, then the <b>Display As Icon</b> box is checked and the object's icon is displayed. This member is set
    ///on input and output. For more information, see DVASPECT.
    uint          dvAspect;
    ///Data format of the object to be converted or activated.
    ushort        wFormat;
    ///<b>TRUE</b> if the object is linked. This member is set on input.
    BOOL          fIsLinkedObject;
    ///The METAFILEPICT containing the iconic aspect. This member is set on input and output.
    ptrdiff_t     hMetaPict;
    ///Pointer to the User Type name of the object to be converted or activated. If this value is <b>NULL</b>, then the
    ///dialog box will retrieve the User Type name from the registry. This string is freed on exit.
    const(char)*  lpszUserType;
    ///<b>TRUE</b> if the object's icon changed. (that is, if OleUIChangeIcon was called and not canceled.). This member
    ///is set on output.
    BOOL          fObjectsIconChanged;
    ///Pointer to the default label to use for the icon. If <b>NULL</b>, the short user type name will be used. If the
    ///object is a link, the caller should pass the display name of the link source. This is freed on exit.
    const(char)*  lpszDefLabel;
    ///Number of CLSIDs in <i>lpClsidExclude</i>.
    uint          cClsidExclude;
    ///Pointer to the list of CLSIDs to exclude from the list.
    GUID*         lpClsidExclude;
}

///Contains information that the OLE User Interface Library uses to initialize the <b>Busy</b> dialog box, and space for
///the library to return information when the dialog box is dismissed.
struct OLEUIBUSYW
{
    ///The size of the structure, in bytes. This field must be filled on input.
    uint          cbStruct;
    ///On input, specifies the initialization and creation flags. On exit, it specifies the user's choices. It may be a
    ///combination of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="BZ_DISABLECANCELBUTTON"></a><a id="bz_disablecancelbutton"></a><dl> <dt><b>BZ_DISABLECANCELBUTTON</b></dt>
    ///</dl> </td> <td width="60%"> This flag disables the <b>Cancel</b> button. </td> </tr> <tr> <td width="40%"><a
    ///id="BZ_DISABLESWITCHTOBUTTON"></a><a id="bz_disableswitchtobutton"></a><dl>
    ///<dt><b>BZ_DISABLESWITCHTOBUTTON</b></dt> </dl> </td> <td width="60%"> Input only. This flag disables the
    ///<b>Switch To...</b> button. </td> </tr> <tr> <td width="40%"><a id="BZ_DISABLERETRYBUTTON"></a><a
    ///id="bz_disableretrybutton"></a><dl> <dt><b>BZ_DISABLERETRYBUTTON</b></dt> </dl> </td> <td width="60%"> Input
    ///only. This flag disables the <b>Retry</b> button. </td> </tr> <tr> <td width="40%"><a
    ///id="BZ_NOTRESPONDINGDIALOG"></a><a id="bz_notrespondingdialog"></a><dl> <dt><b>BZ_NOTRESPONDINGDIALOG</b></dt>
    ///</dl> </td> <td width="60%"> Input only. This flag generates a <b>Not Responding</b> dialog box instead of a
    ///<b>Busy</b> dialog box. The text is slightly different, and the <b>Cancel</b> button is disabled. </td> </tr>
    ///</table>
    uint          dwFlags;
    ///The window that owns the dialog box. This member should not be <b>NULL</b>.
    HWND          hWndOwner;
    ///A pointer to a string to be used as the title of the dialog box. If <b>NULL</b>, then the library uses
    ///<b>Busy</b>.
    const(wchar)* lpszCaption;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the <b>lpfnHook</b> member.
    ///The library passes a pointer to the <b>OLEUIBUSY</b> structure in the <i>lParam</i> parameter of the
    ///WM_INITDIALOG message; this pointer can be used to retrieve the <b>lCustData</b> member.
    LPARAM        lCustData;
    ///Instance that contains a dialog box template specified by the <b>lpTemplateName</b> member.
    HINSTANCE     hInstance;
    ///Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that
    ///is to be substituted for the library's <b>Busy</b> dialog box template.
    const(wchar)* lpszTemplate;
    ///Customized template handle.
    ptrdiff_t     hResource;
    ///Input only. Handle to the task that is blocking.
    ptrdiff_t     hTask;
    ///Pointer to the dialog box's <b>HWND</b>.
    HWND*         lphWndDialog;
}

///Contains information that the OLE User Interface Library uses to initialize the <b>Busy</b> dialog box, and space for
///the library to return information when the dialog box is dismissed.
struct OLEUIBUSYA
{
    ///The size of the structure, in bytes. This field must be filled on input.
    uint          cbStruct;
    ///On input, specifies the initialization and creation flags. On exit, it specifies the user's choices. It may be a
    ///combination of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="BZ_DISABLECANCELBUTTON"></a><a id="bz_disablecancelbutton"></a><dl> <dt><b>BZ_DISABLECANCELBUTTON</b></dt>
    ///</dl> </td> <td width="60%"> This flag disables the <b>Cancel</b> button. </td> </tr> <tr> <td width="40%"><a
    ///id="BZ_DISABLESWITCHTOBUTTON"></a><a id="bz_disableswitchtobutton"></a><dl>
    ///<dt><b>BZ_DISABLESWITCHTOBUTTON</b></dt> </dl> </td> <td width="60%"> Input only. This flag disables the
    ///<b>Switch To...</b> button. </td> </tr> <tr> <td width="40%"><a id="BZ_DISABLERETRYBUTTON"></a><a
    ///id="bz_disableretrybutton"></a><dl> <dt><b>BZ_DISABLERETRYBUTTON</b></dt> </dl> </td> <td width="60%"> Input
    ///only. This flag disables the <b>Retry</b> button. </td> </tr> <tr> <td width="40%"><a
    ///id="BZ_NOTRESPONDINGDIALOG"></a><a id="bz_notrespondingdialog"></a><dl> <dt><b>BZ_NOTRESPONDINGDIALOG</b></dt>
    ///</dl> </td> <td width="60%"> Input only. This flag generates a <b>Not Responding</b> dialog box instead of a
    ///<b>Busy</b> dialog box. The text is slightly different, and the <b>Cancel</b> button is disabled. </td> </tr>
    ///</table>
    uint          dwFlags;
    ///The window that owns the dialog box. This member should not be <b>NULL</b>.
    HWND          hWndOwner;
    ///A pointer to a string to be used as the title of the dialog box. If <b>NULL</b>, then the library uses
    ///<b>Busy</b>.
    const(char)*  lpszCaption;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the <b>lpfnHook</b> member.
    ///The library passes a pointer to the <b>OLEUIBUSY</b> structure in the <i>lParam</i> parameter of the
    ///WM_INITDIALOG message; this pointer can be used to retrieve the <b>lCustData</b> member.
    LPARAM        lCustData;
    ///Instance that contains a dialog box template specified by the <b>lpTemplateName</b> member.
    HINSTANCE     hInstance;
    ///Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that
    ///is to be substituted for the library's <b>Busy</b> dialog box template.
    const(char)*  lpszTemplate;
    ///Customized template handle.
    ptrdiff_t     hResource;
    ///Input only. Handle to the task that is blocking.
    ptrdiff_t     hTask;
    ///Pointer to the dialog box's <b>HWND</b>.
    HWND*         lphWndDialog;
}

///Contains information that is used to initialize the standard <b>Change Source</b> dialog box. It allows the user to
///modify the destination or source of a link. This may simply entail selecting a different file name for the link, or
///possibly changing the item reference within the file, for example, changing the destination range of cells within the
///spreadsheet that the link is to.
struct OLEUICHANGESOURCEW
{
    ///The size of the structure, in bytes.
    uint                 cbStruct;
    ///On input, this field specifies the initialization and creation flags. On exit, it specifies the user's choices.
    ///It may be a combination of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="CSF_SHOWHELP"></a><a id="csf_showhelp"></a><dl> <dt><b>CSF_SHOWHELP</b></dt> </dl> </td> <td
    ///width="60%"> Enables or shows the Help button. </td> </tr> <tr> <td width="40%"><a id="CSF_VALIDSOURCE"></a><a
    ///id="csf_validsource"></a><dl> <dt><b>CSF_VALIDSOURCE</b></dt> </dl> </td> <td width="60%"> Indicates that the
    ///link was validated. </td> </tr> <tr> <td width="40%"><a id="CSF_ONLYGETSOURCE"></a><a
    ///id="csf_onlygetsource"></a><dl> <dt><b>CSF_ONLYGETSOURCE</b></dt> </dl> </td> <td width="60%"> Disables automatic
    ///validation of the link source when the user presses <b>OK</b>. If you specify this flag, you should validate the
    ///source when the dialog box returns <b>OK</b>. </td> </tr> </table>
    uint                 dwFlags;
    ///The window that owns the dialog box.
    HWND                 hWndOwner;
    ///Pointer to a string to be used as the title of the dialog box. If <b>NULL</b>, then the library uses <b>Change
    ///Source</b>.
    const(wchar)*        lpszCaption;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK        lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the
    ///[OLEUICHANGEICON](./nf-oledlg-oleuichangeicona.md) structure in the <i>lParam</i> parameter of the WM_INITDIALOG
    ///message; this pointer can be used to retrieve the <b>lCustData</b> member.
    LPARAM               lCustData;
    ///Instance that contains a dialog box template specified by the <b>lpszTemplate</b> member. This member is ignored
    ///if the <b>lpszTemplate</b> member is <b>NULL</b> or invalid.
    HINSTANCE            hInstance;
    ///Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that
    ///is to be substituted for the library's <b>Convert</b> dialog box template.
    const(wchar)*        lpszTemplate;
    ///Resource handle for a custom dialog box. If this member is <b>NULL</b>, then the library uses the standard
    ///<b>Convert</b> dialog box template, or if it is valid, the template named by the <b>lpszTemplate</b> member.
    ptrdiff_t            hResource;
    ///Pointer to the OPENFILENAME structure, which contains information used by the operating system to initialize the
    ///system-defined <b>Open</b> or <b>Save As</b> dialog boxes.
    OPENFILENAMEW*       lpOFN;
    ///This member is reserved.
    uint[4]              dwReserved1;
    ///Pointer to the container's implementation of the IOleUILinkContainer interface, used to validate the link source.
    ///The <b>Edit Links</b> dialog box uses this to allow the container to manipulate its links.
    IOleUILinkContainerW lpOleUILinkContainer;
    ///Container-defined unique link identifier used to validate link sources. Used by <b>lpOleUILinkContainer</b>.
    uint                 dwLink;
    ///Pointer to the complete source display name.
    const(wchar)*        lpszDisplayName;
    ///File moniker portion of <b>lpszDisplayName</b>.
    uint                 nFileLength;
    ///Pointer to the prefix of the source that was changed from.
    const(wchar)*        lpszFrom;
    ///Pointer to the prefix of the source to be changed to.
    const(wchar)*        lpszTo;
}

///Contains information that is used to initialize the standard <b>Change Source</b> dialog box. It allows the user to
///modify the destination or source of a link. This may simply entail selecting a different file name for the link, or
///possibly changing the item reference within the file, for example, changing the destination range of cells within the
///spreadsheet that the link is to.
struct OLEUICHANGESOURCEA
{
    ///The size of the structure, in bytes.
    uint                 cbStruct;
    ///On input, this field specifies the initialization and creation flags. On exit, it specifies the user's choices.
    ///It may be a combination of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="CSF_SHOWHELP"></a><a id="csf_showhelp"></a><dl> <dt><b>CSF_SHOWHELP</b></dt> </dl> </td> <td
    ///width="60%"> Enables or shows the Help button. </td> </tr> <tr> <td width="40%"><a id="CSF_VALIDSOURCE"></a><a
    ///id="csf_validsource"></a><dl> <dt><b>CSF_VALIDSOURCE</b></dt> </dl> </td> <td width="60%"> Indicates that the
    ///link was validated. </td> </tr> <tr> <td width="40%"><a id="CSF_ONLYGETSOURCE"></a><a
    ///id="csf_onlygetsource"></a><dl> <dt><b>CSF_ONLYGETSOURCE</b></dt> </dl> </td> <td width="60%"> Disables automatic
    ///validation of the link source when the user presses <b>OK</b>. If you specify this flag, you should validate the
    ///source when the dialog box returns <b>OK</b>. </td> </tr> </table>
    uint                 dwFlags;
    ///The window that owns the dialog box.
    HWND                 hWndOwner;
    ///Pointer to a string to be used as the title of the dialog box. If <b>NULL</b>, then the library uses <b>Change
    ///Source</b>.
    const(char)*         lpszCaption;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK        lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the
    ///[OLEUICHANGEICON](./nf-oledlg-oleuichangeicona.md) structure in the <i>lParam</i> parameter of the WM_INITDIALOG
    ///message; this pointer can be used to retrieve the <b>lCustData</b> member.
    LPARAM               lCustData;
    ///Instance that contains a dialog box template specified by the <b>lpszTemplate</b> member. This member is ignored
    ///if the <b>lpszTemplate</b> member is <b>NULL</b> or invalid.
    HINSTANCE            hInstance;
    ///Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that
    ///is to be substituted for the library's <b>Convert</b> dialog box template.
    const(char)*         lpszTemplate;
    ///Resource handle for a custom dialog box. If this member is <b>NULL</b>, then the library uses the standard
    ///<b>Convert</b> dialog box template, or if it is valid, the template named by the <b>lpszTemplate</b> member.
    ptrdiff_t            hResource;
    ///Pointer to the OPENFILENAME structure, which contains information used by the operating system to initialize the
    ///system-defined <b>Open</b> or <b>Save As</b> dialog boxes.
    OPENFILENAMEA*       lpOFN;
    ///This member is reserved.
    uint[4]              dwReserved1;
    ///Pointer to the container's implementation of the IOleUILinkContainer interface, used to validate the link source.
    ///The <b>Edit Links</b> dialog box uses this to allow the container to manipulate its links.
    IOleUILinkContainerA lpOleUILinkContainer;
    ///Container-defined unique link identifier used to validate link sources. Used by <b>lpOleUILinkContainer</b>.
    uint                 dwLink;
    ///Pointer to the complete source display name.
    const(char)*         lpszDisplayName;
    ///File moniker portion of <b>lpszDisplayName</b>.
    uint                 nFileLength;
    ///Pointer to the prefix of the source that was changed from.
    const(char)*         lpszFrom;
    ///Pointer to the prefix of the source to be changed to.
    const(char)*         lpszTo;
}

///Initializes the <b>General</b> tab of the <b>Object Properties</b> dialog box. A reference to it is passed in as part
///of the OLEUIOBJECTPROPS structure to the OleUIObjectProperties function. This tab shows the type and size of an OLE
///embedding and allows it the user to tunnel to the <b>Convert</b> dialog box. This tab also shows the link destination
///if the object is a link.
struct OLEUIGNRLPROPSW
{
    ///The size of the structure, in bytes. This field must be filled on input.
    uint               cbStruct;
    ///Currently no flags associated with this member. It should be set to 0 (zero).
    uint               dwFlags;
    ///This member is reserved.
    uint[2]            dwReserved1;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK      lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the <b>lpfnHook</b> member
    ///during WM_INITDIALOG.
    LPARAM             lCustData;
    ///This member is reserved.
    uint[3]            dwReserved2;
    ///Used internally.
    OLEUIOBJECTPROPSW* lpOP;
}

///Initializes the <b>General</b> tab of the <b>Object Properties</b> dialog box. A reference to it is passed in as part
///of the OLEUIOBJECTPROPS structure to the OleUIObjectProperties function. This tab shows the type and size of an OLE
///embedding and allows it the user to tunnel to the <b>Convert</b> dialog box. This tab also shows the link destination
///if the object is a link.
struct OLEUIGNRLPROPSA
{
    ///The size of the structure, in bytes. This field must be filled on input.
    uint               cbStruct;
    ///Currently no flags associated with this member. It should be set to 0 (zero).
    uint               dwFlags;
    ///This member is reserved.
    uint[2]            dwReserved1;
    ///Pointer to a hook function that processes messages intended for the dialog box. The hook function must return
    ///zero to pass a message that it didn't process back to the dialog box procedure in the library. The hook function
    ///must return a nonzero value to prevent the library's dialog box procedure from processing a message it has
    ///already processed.
    LPFNOLEUIHOOK      lpfnHook;
    ///Application-defined data that the library passes to the hook function pointed to by the <b>lpfnHook</b> member
    ///during WM_INITDIALOG.
    LPARAM             lCustData;
    ///This member is reserved.
    uint[3]            dwReserved2;
    ///Used internally.
    OLEUIOBJECTPROPSA* lpOP;
}

///Contains information that is used to initialize the <b>View</b> tab of the <b>Object properties</b> dialog box. A
///reference to it is passed in as part of the OLEUIOBJECTPROPS structure to the OleUIObjectProperties function. This
///tab allows the user to toggle between "content" and "iconic" views of the object, and change its scaling within the
///container. It also allows the user to tunnel to the change icon dialog box when the object is being displayed
///iconically.
struct OLEUIVIEWPROPSW
{
    ///The size of the structure, in bytes.
    uint               cbStruct;
    ///Flags specific to view page. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="VPF_SELECTRELATIVE"></a><a id="vpf_selectrelative"></a><dl> <dt><b>VPF_SELECTRELATIVE</b></dt> </dl> </td>
    ///<td width="60%"> Relative to origin. </td> </tr> <tr> <td width="40%"><a id="VPF_DISABLERELATIVE"></a><a
    ///id="vpf_disablerelative"></a><dl> <dt><b>VPF_DISABLERELATIVE</b></dt> </dl> </td> <td width="60%"> Disable
    ///relative to origin. </td> </tr> <tr> <td width="40%"><a id="VPF_DISABLESCALE"></a><a
    ///id="vpf_disablescale"></a><dl> <dt><b>VPF_DISABLESCALE</b></dt> </dl> </td> <td width="60%"> Disable scale
    ///option. </td> </tr> </table>
    uint               dwFlags;
    ///This member is reserved.
    uint[2]            dwReserved1;
    ///Pointer to a hook callback (not used in this dialog box).
    LPFNOLEUIHOOK      lpfnHook;
    ///Custom data to pass to the hook (not used in this dialog box).
    LPARAM             lCustData;
    ///This member is reserved.
    uint[3]            dwReserved2;
    ///Used internally.
    OLEUIOBJECTPROPSW* lpOP;
    ///Minimum value for the scale range.
    int                nScaleMin;
    ///Maximum value for the scale range.
    int                nScaleMax;
}

///Contains information that is used to initialize the <b>View</b> tab of the <b>Object properties</b> dialog box. A
///reference to it is passed in as part of the OLEUIOBJECTPROPS structure to the OleUIObjectProperties function. This
///tab allows the user to toggle between "content" and "iconic" views of the object, and change its scaling within the
///container. It also allows the user to tunnel to the change icon dialog box when the object is being displayed
///iconically.
struct OLEUIVIEWPROPSA
{
    ///The size of the structure, in bytes.
    uint               cbStruct;
    ///Flags specific to view page. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="VPF_SELECTRELATIVE"></a><a id="vpf_selectrelative"></a><dl> <dt><b>VPF_SELECTRELATIVE</b></dt> </dl> </td>
    ///<td width="60%"> Relative to origin. </td> </tr> <tr> <td width="40%"><a id="VPF_DISABLERELATIVE"></a><a
    ///id="vpf_disablerelative"></a><dl> <dt><b>VPF_DISABLERELATIVE</b></dt> </dl> </td> <td width="60%"> Disable
    ///relative to origin. </td> </tr> <tr> <td width="40%"><a id="VPF_DISABLESCALE"></a><a
    ///id="vpf_disablescale"></a><dl> <dt><b>VPF_DISABLESCALE</b></dt> </dl> </td> <td width="60%"> Disable scale
    ///option. </td> </tr> </table>
    uint               dwFlags;
    ///This member is reserved.
    uint[2]            dwReserved1;
    ///Pointer to a hook callback (not used in this dialog box).
    LPFNOLEUIHOOK      lpfnHook;
    ///Custom data to pass to the hook (not used in this dialog box).
    LPARAM             lCustData;
    ///This member is reserved.
    uint[3]            dwReserved2;
    ///Used internally.
    OLEUIOBJECTPROPSA* lpOP;
    ///Minimum value for the scale range.
    int                nScaleMin;
    ///Maximum value for the scale range.
    int                nScaleMax;
}

///Contains information that is used to initialize the <b>Link</b> tab of the <b>Object Properties</b> dialog box. A
///reference to it is passed in as part of the OLEUIOBJECTPROPS structure to the OleUIObjectProperties function. This
///tab shows the location, update status, and update time for a link. It allows the user to change the source of the
///link, toggle its update status between automatic and manual update, open the source, force an update of the link, or
///break the link (convert it to a static picture).
struct OLEUILINKPROPSW
{
    ///The size of the structure, in bytes.
    uint               cbStruct;
    ///Contains in/out flags specific to the <b>Links</b> page.
    uint               dwFlags;
    ///This member is reserved.
    uint[2]            dwReserved1;
    ///Pointer to the hook callback (not used in this dialog box).
    LPFNOLEUIHOOK      lpfnHook;
    ///Custom data to pass to hook (not used in this dialog box).
    LPARAM             lCustData;
    ///This member is reserved.
    uint[3]            dwReserved2;
    ///Used internally.
    OLEUIOBJECTPROPSW* lpOP;
}

///Contains information that is used to initialize the <b>Link</b> tab of the <b>Object Properties</b> dialog box. A
///reference to it is passed in as part of the OLEUIOBJECTPROPS structure to the OleUIObjectProperties function. This
///tab shows the location, update status, and update time for a link. It allows the user to change the source of the
///link, toggle its update status between automatic and manual update, open the source, force an update of the link, or
///break the link (convert it to a static picture).
struct OLEUILINKPROPSA
{
    ///The size of the structure, in bytes.
    uint               cbStruct;
    ///Contains in/out flags specific to the <b>Links</b> page.
    uint               dwFlags;
    ///This member is reserved.
    uint[2]            dwReserved1;
    ///Pointer to the hook callback (not used in this dialog box).
    LPFNOLEUIHOOK      lpfnHook;
    ///Custom data to pass to hook (not used in this dialog box).
    LPARAM             lCustData;
    ///This member is reserved.
    uint[3]            dwReserved2;
    ///Used internally.
    OLEUIOBJECTPROPSA* lpOP;
}

///Contains information that is used to initialize the standard <b>Object Properties</b> dialog box. It contains
///references to interfaces used to gather information about the embedding or link, references to three structures that
///are used to initialize the default tabs - <b>General</b> (OLEUIGNRLPROPS), <b>View</b> (OLEUIVIEWPROPS), and
///<b>Link</b> (OLEUILINKPROPS), if appropriate - and a standard property-sheet extensibility interface that allows the
///caller to add additional custom property sheets to the dialog box.
struct OLEUIOBJECTPROPSW
{
    ///The size of the structure, in bytes.
    uint                 cbStruct;
    ///Contains in/out global flags for the property sheet. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="OPF_OBJECTISLINK"></a><a id="opf_objectislink"></a><dl> <dt><b>OPF_OBJECTISLINK</b></dt> </dl>
    ///</td> <td width="60%"> Object is a link object and therefore has a link property page. </td> </tr> <tr> <td
    ///width="40%"><a id="OPF_NOFILLDEFAULT"></a><a id="opf_nofilldefault"></a><dl> <dt><b>OPF_NOFILLDEFAULT</b></dt>
    ///</dl> </td> <td width="60%"> Do not fill in default values for the object. </td> </tr> <tr> <td width="40%"><a
    ///id="OPF_SHOWHELP"></a><a id="opf_showhelp"></a><dl> <dt><b>OPF_SHOWHELP</b></dt> </dl> </td> <td width="60%"> The
    ///dialog box will display a <b>Help</b> button. </td> </tr> <tr> <td width="40%"><a id="OPF_DISABLECONVERT"></a><a
    ///id="opf_disableconvert"></a><dl> <dt><b>OPF_DISABLECONVERT</b></dt> </dl> </td> <td width="60%"> The
    ///<b>Convert</b> button will be disabled on the general property page. </td> </tr> </table>
    uint                 dwFlags;
    ///Pointer to the standard property sheet header (PROPSHEETHEADER), used for extensibility.
    PROPSHEETHEADERW_V2* lpPS;
    ///Identifier for the object.
    uint                 dwObject;
    ///Pointer to the interface to manipulate object.
    IOleUIObjInfoW       lpObjInfo;
    ///Container-defined unique identifier for a single link. Containers can use the pointer to the link's container
    ///site for this value.
    uint                 dwLink;
    ///Pointer to the interface to manipulate link.
    IOleUILinkInfoW      lpLinkInfo;
    ///Pointer to the general page data.
    OLEUIGNRLPROPSW*     lpGP;
    ///Pointer to the view page data.
    OLEUIVIEWPROPSW*     lpVP;
    ///Pointer to the link page data.
    OLEUILINKPROPSW*     lpLP;
}

///Contains information that is used to initialize the standard <b>Object Properties</b> dialog box. It contains
///references to interfaces used to gather information about the embedding or link, references to three structures that
///are used to initialize the default tabs - <b>General</b> (OLEUIGNRLPROPS), <b>View</b> (OLEUIVIEWPROPS), and
///<b>Link</b> (OLEUILINKPROPS), if appropriate - and a standard property-sheet extensibility interface that allows the
///caller to add additional custom property sheets to the dialog box.
struct OLEUIOBJECTPROPSA
{
    ///The size of the structure, in bytes.
    uint                 cbStruct;
    ///Contains in/out global flags for the property sheet. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="OPF_OBJECTISLINK"></a><a id="opf_objectislink"></a><dl> <dt><b>OPF_OBJECTISLINK</b></dt> </dl>
    ///</td> <td width="60%"> Object is a link object and therefore has a link property page. </td> </tr> <tr> <td
    ///width="40%"><a id="OPF_NOFILLDEFAULT"></a><a id="opf_nofilldefault"></a><dl> <dt><b>OPF_NOFILLDEFAULT</b></dt>
    ///</dl> </td> <td width="60%"> Do not fill in default values for the object. </td> </tr> <tr> <td width="40%"><a
    ///id="OPF_SHOWHELP"></a><a id="opf_showhelp"></a><dl> <dt><b>OPF_SHOWHELP</b></dt> </dl> </td> <td width="60%"> The
    ///dialog box will display a <b>Help</b> button. </td> </tr> <tr> <td width="40%"><a id="OPF_DISABLECONVERT"></a><a
    ///id="opf_disableconvert"></a><dl> <dt><b>OPF_DISABLECONVERT</b></dt> </dl> </td> <td width="60%"> The
    ///<b>Convert</b> button will be disabled on the general property page. </td> </tr> </table>
    uint                 dwFlags;
    ///Pointer to the standard property sheet header (PROPSHEETHEADER), used for extensibility.
    PROPSHEETHEADERA_V2* lpPS;
    ///Identifier for the object.
    uint                 dwObject;
    ///Pointer to the interface to manipulate object.
    IOleUIObjInfoA       lpObjInfo;
    ///Container-defined unique identifier for a single link. Containers can use the pointer to the link's container
    ///site for this value.
    uint                 dwLink;
    ///Pointer to the interface to manipulate link.
    IOleUILinkInfoA      lpLinkInfo;
    ///Pointer to the general page data.
    OLEUIGNRLPROPSA*     lpGP;
    ///Pointer to the view page data.
    OLEUIVIEWPROPSA*     lpVP;
    ///Pointer to the link page data.
    OLEUILINKPROPSA*     lpLP;
}

///Provides information about a call frame such as the method in the call frame, if it has in, out, or in/out
///parameters, the number of [in], [out], or [in, out] interfaces, the interface ID, the number of methods in the
///interface and the number of parameters in this method.
struct CALLFRAMEINFO
{
    ///The method number within the interface in question.
    uint iMethod;
    ///<b>TRUE</b> if there are any [in] parameters in the method; otherwise, <b>FALSE</b>.
    BOOL fHasInValues;
    ///<b>TRUE</b> if there are any [in, out] parameters in the method; otherwise, <b>FALSE</b>.
    BOOL fHasInOutValues;
    ///<b>TRUE</b> if there are any out parameters other than <b>HRESULT</b> or <b>void</b> return values in the method;
    ///otherwise, <b>FALSE</b>.
    BOOL fHasOutValues;
    ///<b>TRUE</b> if the interface is derived from <b>IDispatch</b>; otherwise, <b>FALSE</b>.
    BOOL fDerivesFromIDispatch;
    ///If this parameter has a value greater or equal to 0, then the value is an absolute upper bound on the number [in]
    ///interfaces. If this parameter is less than 0, then the method may have an unbounded number of [in] interfaces. If
    ///this parameter is equal to 0, then there are no [in] interfaces.
    int  cInInterfacesMax;
    ///If this parameter has a value greater or equal to 0, then the value is an absolute upper bound on the number [in,
    ///out] interfaces. If this parameter is less than 0, then the method may have an unbounded number of [in, out]
    ///interfaces. If this parameter is equal to 0, then there are no [in, out] interfaces.
    int  cInOutInterfacesMax;
    ///If this parameter has a value greater or equal to 0, then the value is an absolute upper bound on the number
    ///[out] interfaces. If this parameter is less than 0, then the method may have an unbounded number of [out]
    ///interfaces. If this parameter is equal to 0, then there are no [out] interfaces.
    int  cOutInterfacesMax;
    ///The number of parameters that are in interface pointers.
    int  cTopLevelInInterfaces;
    ///The interface ID.
    GUID iid;
    ///The number of methods in <b>iid</b>.
    uint cMethod;
    ///The number of parameters in <b>imethod</b>. The receiver is excluded.
    uint cParams;
}

///Provides information about the parameter on the stack.
struct CALLFRAMEPARAMINFO
{
    ///<b>TRUE</b> if this is an [in] parameter; otherwise, <b>FALSE</b>.
    ubyte fIn;
    ///<b>TRUE</b> if this is an [out] parameter; otherwise, <b>FALSE</b>.
    ubyte fOut;
    ///Represents the offset in bytes from the stack location of the frame to the start of the parameter.
    uint  stackOffset;
    ///Represents the size in bytes occupied by the parameter on the stack.
    uint  cbParam;
}

///Provides information about the context in which marshalling should be carried out.
struct CALLFRAME_MARSHALCONTEXT
{
    ///<b>TRUE</b> if the in parameter values are to be marshaled and <b>FALSE</b> if the out parameter values are to be
    ///marshaled. The in parameter values are marshaled on the client side and the out parameter values are marshaled on
    ///the server side.
    ubyte    fIn;
    ///Context in which unmarshaling is to be carried out.
    uint     dwDestContext;
    ///Context in which unmarshaling is to be carried out.
    void*    pvDestContext;
    ///This parameter should be <b>NULL</b>.
    IUnknown punkReserved;
    ///The transfer syntax for which the marshalling should occur.
    GUID     guidTransferSyntax;
}

///Describes a component category.
struct CATEGORYINFO
{
    ///The category identifier for the component.
    GUID        catid;
    ///The locale identifier. See Language Identifier Constants and Strings.
    uint        lcid;
    ///The description of the category (cannot exceed 128 characters).
    ushort[128] szDescription;
}

struct ComCallData
{
    uint  dwDispid;
    uint  dwReserved;
    void* pUserDefined;
}

alias HRESULT = int;

///Contains an operating system platform and processor architecture.
struct CSPLATFORM
{
    ///The operating system platform. See the <b>dwPlatformId</b> member of OSVERSIONINFO.
    uint dwPlatformId;
    ///The major version of the operating system.
    uint dwVersionHi;
    ///The minor version of the operating system.
    uint dwVersionLo;
    ///The processor architecture. See the <b>wProcessorArchitecture</b> member of SYSTEM_INFO.
    uint dwProcessorArch;
}

///Contains a list of attributes used to look up a class implementation.
struct QUERYCONTEXT
{
    ///The execution context.
    uint       dwContext;
    ///The operating system platform and processor architecture. For more information, see CSPLATFORM.
    CSPLATFORM Platform;
    ///The locale identifier. For more information, see Language Identifier Constants and Strings.
    uint       Locale;
    ///The high version number.
    uint       dwVersionHi;
    ///The low version number.
    uint       dwVersionLo;
}

///Contains access-control information for a specified trustee. This structure stores information equivalent to the
///access-control information stored in an ACE.
struct ACTRL_ACCESS_ENTRYA
{
    ///A TRUSTEE structure that identifies the user, group, or program (such as a service) to which the access-control
    ///entry applies.
    TRUSTEE_A    Trustee;
    ///Indicates how the access rights specified by the <b>Access</b> and <b>ProvSpecificAccess</b> members apply to the
    ///trustee. This member can be one of the following values. If you are using this structure with the COM
    ///implementation of IAccessControl, this member must be ACTRL_ACCESS_ALLOWED or ACTRL_ACCESS_DENIED. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ACTRL_ACCESS_ALLOWED"></a><a
    ///id="actrl_access_allowed"></a><dl> <dt><b>ACTRL_ACCESS_ALLOWED</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> The rights are allowed. </td> </tr> <tr> <td width="40%"><a id="ACTRL_ACCESS_DENIED"></a><a
    ///id="actrl_access_denied"></a><dl> <dt><b>ACTRL_ACCESS_DENIED</b></dt> <dt>0x00000002</dt> </dl> </td> <td
    ///width="60%"> The rights are denied. </td> </tr> <tr> <td width="40%"><a id="ACTRL_AUDIT_SUCCESS"></a><a
    ///id="actrl_audit_success"></a><dl> <dt><b>ACTRL_AUDIT_SUCCESS</b></dt> <dt>0x00000004</dt> </dl> </td> <td
    ///width="60%"> The system generates audit messages for failed attempts to use the rights. </td> </tr> <tr> <td
    ///width="40%"><a id="ACTRL_AUDIT_FAILURE"></a><a id="actrl_audit_failure"></a><dl>
    ///<dt><b>ACTRL_AUDIT_FAILURE</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> The system generates audit
    ///messages for successful attempts to use the rights. </td> </tr> </table>
    uint         fAccessFlags;
    ///A bitmask that specifies the access rights that the entry allows, denies, or audits for the trustee. This member
    ///must use the provider-independent access flags, such as ACTRL_READ_CONTROL, rather than access flags such as
    ///READ_CONTROL. The provider for the object type converts these provider-independent flags to the corresponding
    ///provider-specific flags. If you are using this structure with the COM implementation of IAccessControl, this
    ///member must be COM_RIGHTS_EXECUTE. <a id="ACTRL_SYSTEM_ACCESS"></a> <a id="actrl_system_access"></a>
    uint         Access;
    ///A bitmask that specifies access rights specific to the provider type. The functions that use the
    ///<b>ACTRL_ACCESS_ENTRY</b> structure pass these bits on to the provider without interpreting them. In most cases,
    ///this member should be 0.
    uint         ProvSpecificAccess;
    ///A set of bit flags that determines whether other containers or objects can inherit the access-control entry from
    ///the primary object to which the access list is attached. If you are using this structure with the COM
    ///implementation of IAccessControl, this value must be NO_INHERITANCE, which indicates that the access-control
    ///entry is not inheritable. Otherwise, this value can be NO_INHERITANCE or it can be a combination of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="CONTAINER_INHERIT_ACE"></a><a id="container_inherit_ace"></a><dl> <dt><b>CONTAINER_INHERIT_ACE</b></dt>
    ///<dt>0x2</dt> </dl> </td> <td width="60%"> Other containers that are contained by the primary object inherit the
    ///entry. </td> </tr> <tr> <td width="40%"><a id="INHERIT_ONLY_ACE_"></a><a id="inherit_only_ace_"></a><dl>
    ///<dt><b>INHERIT_ONLY_ACE </b></dt> <dt>0x8</dt> </dl> </td> <td width="60%"> The ACE does not apply to the primary
    ///object to which the ACL is attached, but objects contained by the primary object inherit the entry. </td> </tr>
    ///<tr> <td width="40%"><a id="NO_PROPAGATE_INHERIT_ACE"></a><a id="no_propagate_inherit_ace"></a><dl>
    ///<dt><b>NO_PROPAGATE_INHERIT_ACE</b></dt> <dt>0x4</dt> </dl> </td> <td width="60%"> The OBJECT_INHERIT_ACE and
    ///CONTAINER_INHERIT_ACE flags are not propagated to an inherited entry. </td> </tr> <tr> <td width="40%"><a
    ///id="OBJECT_INHERIT_ACE"></a><a id="object_inherit_ace"></a><dl> <dt><b>OBJECT_INHERIT_ACE</b></dt> <dt>0x1</dt>
    ///</dl> </td> <td width="60%"> Noncontainer objects contained by the primary object inherit the entry. </td> </tr>
    ///<tr> <td width="40%"><a id="SUB_CONTAINERS_AND_OBJECTS_INHERIT"></a><a
    ///id="sub_containers_and_objects_inherit"></a><dl> <dt><b>SUB_CONTAINERS_AND_OBJECTS_INHERIT</b></dt> <dt>0x3</dt>
    ///</dl> </td> <td width="60%"> Both containers and noncontainer objects that are contained by the primary object
    ///inherit the entry. This flag corresponds to the combination of the CONTAINER_INHERIT_ACE and OBJECT_INHERIT_ACE
    ///flags. </td> </tr> <tr> <td width="40%"><a id="SUB_CONTAINERS_ONLY_INHERIT"></a><a
    ///id="sub_containers_only_inherit"></a><dl> <dt><b>SUB_CONTAINERS_ONLY_INHERIT</b></dt> <dt>0x2</dt> </dl> </td>
    ///<td width="60%"> Other containers that are contained by the primary object inherit the entry. This flag
    ///corresponds to the CONTAINER_INHERIT_ACE flag. </td> </tr> <tr> <td width="40%"><a
    ///id="SUB_OBJECTS_ONLY_INHERIT"></a><a id="sub_objects_only_inherit"></a><dl>
    ///<dt><b>SUB_OBJECTS_ONLY_INHERIT</b></dt> <dt>0x1</dt> </dl> </td> <td width="60%"> Noncontainer objects contained
    ///by the primary object inherit the entry. This flag corresponds to the OBJECT_INHERIT_ACE flag. </td> </tr>
    ///</table>
    uint         Inheritance;
    ///A pointer to a null-terminated string that identifies the object types that can inherit the entry. If you are
    ///using this structure with the COM implementation of IAccessControl, this member must be <b>NULL</b>.
    const(char)* lpInheritProperty;
}

///Contains access-control information for a specified trustee. This structure stores information equivalent to the
///access-control information stored in an ACE.
struct ACTRL_ACCESS_ENTRYW
{
    ///A TRUSTEE structure that identifies the user, group, or program (such as a service) to which the access-control
    ///entry applies.
    TRUSTEE_W     Trustee;
    ///Indicates how the access rights specified by the <b>Access</b> and <b>ProvSpecificAccess</b> members apply to the
    ///trustee. This member can be one of the following values. If you are using this structure with the COM
    ///implementation of IAccessControl, this member must be ACTRL_ACCESS_ALLOWED or ACTRL_ACCESS_DENIED. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ACTRL_ACCESS_ALLOWED"></a><a
    ///id="actrl_access_allowed"></a><dl> <dt><b>ACTRL_ACCESS_ALLOWED</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> The rights are allowed. </td> </tr> <tr> <td width="40%"><a id="ACTRL_ACCESS_DENIED"></a><a
    ///id="actrl_access_denied"></a><dl> <dt><b>ACTRL_ACCESS_DENIED</b></dt> <dt>0x00000002</dt> </dl> </td> <td
    ///width="60%"> The rights are denied. </td> </tr> <tr> <td width="40%"><a id="ACTRL_AUDIT_SUCCESS"></a><a
    ///id="actrl_audit_success"></a><dl> <dt><b>ACTRL_AUDIT_SUCCESS</b></dt> <dt>0x00000004</dt> </dl> </td> <td
    ///width="60%"> The system generates audit messages for failed attempts to use the rights. </td> </tr> <tr> <td
    ///width="40%"><a id="ACTRL_AUDIT_FAILURE"></a><a id="actrl_audit_failure"></a><dl>
    ///<dt><b>ACTRL_AUDIT_FAILURE</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> The system generates audit
    ///messages for successful attempts to use the rights. </td> </tr> </table>
    uint          fAccessFlags;
    ///A bitmask that specifies the access rights that the entry allows, denies, or audits for the trustee. This member
    ///must use the provider-independent access flags, such as ACTRL_READ_CONTROL, rather than access flags such as
    ///READ_CONTROL. The provider for the object type converts these provider-independent flags to the corresponding
    ///provider-specific flags. If you are using this structure with the COM implementation of IAccessControl, this
    ///member must be COM_RIGHTS_EXECUTE. <a id="ACTRL_SYSTEM_ACCESS"></a> <a id="actrl_system_access"></a>
    uint          Access;
    ///A bitmask that specifies access rights specific to the provider type. The functions that use the
    ///<b>ACTRL_ACCESS_ENTRY</b> structure pass these bits on to the provider without interpreting them. In most cases,
    ///this member should be 0.
    uint          ProvSpecificAccess;
    ///A set of bit flags that determines whether other containers or objects can inherit the access-control entry from
    ///the primary object to which the access list is attached. If you are using this structure with the COM
    ///implementation of IAccessControl, this value must be NO_INHERITANCE, which indicates that the access-control
    ///entry is not inheritable. Otherwise, this value can be NO_INHERITANCE or it can be a combination of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="CONTAINER_INHERIT_ACE"></a><a id="container_inherit_ace"></a><dl> <dt><b>CONTAINER_INHERIT_ACE</b></dt>
    ///<dt>0x2</dt> </dl> </td> <td width="60%"> Other containers that are contained by the primary object inherit the
    ///entry. </td> </tr> <tr> <td width="40%"><a id="INHERIT_ONLY_ACE_"></a><a id="inherit_only_ace_"></a><dl>
    ///<dt><b>INHERIT_ONLY_ACE </b></dt> <dt>0x8</dt> </dl> </td> <td width="60%"> The ACE does not apply to the primary
    ///object to which the ACL is attached, but objects contained by the primary object inherit the entry. </td> </tr>
    ///<tr> <td width="40%"><a id="NO_PROPAGATE_INHERIT_ACE"></a><a id="no_propagate_inherit_ace"></a><dl>
    ///<dt><b>NO_PROPAGATE_INHERIT_ACE</b></dt> <dt>0x4</dt> </dl> </td> <td width="60%"> The OBJECT_INHERIT_ACE and
    ///CONTAINER_INHERIT_ACE flags are not propagated to an inherited entry. </td> </tr> <tr> <td width="40%"><a
    ///id="OBJECT_INHERIT_ACE"></a><a id="object_inherit_ace"></a><dl> <dt><b>OBJECT_INHERIT_ACE</b></dt> <dt>0x1</dt>
    ///</dl> </td> <td width="60%"> Noncontainer objects contained by the primary object inherit the entry. </td> </tr>
    ///<tr> <td width="40%"><a id="SUB_CONTAINERS_AND_OBJECTS_INHERIT"></a><a
    ///id="sub_containers_and_objects_inherit"></a><dl> <dt><b>SUB_CONTAINERS_AND_OBJECTS_INHERIT</b></dt> <dt>0x3</dt>
    ///</dl> </td> <td width="60%"> Both containers and noncontainer objects that are contained by the primary object
    ///inherit the entry. This flag corresponds to the combination of the CONTAINER_INHERIT_ACE and OBJECT_INHERIT_ACE
    ///flags. </td> </tr> <tr> <td width="40%"><a id="SUB_CONTAINERS_ONLY_INHERIT"></a><a
    ///id="sub_containers_only_inherit"></a><dl> <dt><b>SUB_CONTAINERS_ONLY_INHERIT</b></dt> <dt>0x2</dt> </dl> </td>
    ///<td width="60%"> Other containers that are contained by the primary object inherit the entry. This flag
    ///corresponds to the CONTAINER_INHERIT_ACE flag. </td> </tr> <tr> <td width="40%"><a
    ///id="SUB_OBJECTS_ONLY_INHERIT"></a><a id="sub_objects_only_inherit"></a><dl>
    ///<dt><b>SUB_OBJECTS_ONLY_INHERIT</b></dt> <dt>0x1</dt> </dl> </td> <td width="60%"> Noncontainer objects contained
    ///by the primary object inherit the entry. This flag corresponds to the OBJECT_INHERIT_ACE flag. </td> </tr>
    ///</table>
    uint          Inheritance;
    ///A pointer to a null-terminated string that identifies the object types that can inherit the entry. If you are
    ///using this structure with the COM implementation of IAccessControl, this member must be <b>NULL</b>.
    const(wchar)* lpInheritProperty;
}

///Contains a list of access entries.
struct ACTRL_ACCESS_ENTRY_LISTA
{
    ///The number of entries in the <b>pAccessList</b> array.
    uint                 cEntries;
    ///A pointer to an array of ACTRL_ACCESS_ENTRY structures. Each structure specifies access-control information for a
    ///specified trustee.
    ACTRL_ACCESS_ENTRYA* pAccessList;
}

///Contains a list of access entries.
struct ACTRL_ACCESS_ENTRY_LISTW
{
    ///The number of entries in the <b>pAccessList</b> array.
    uint                 cEntries;
    ///A pointer to an array of ACTRL_ACCESS_ENTRY structures. Each structure specifies access-control information for a
    ///specified trustee.
    ACTRL_ACCESS_ENTRYW* pAccessList;
}

///Contains a list of access-control entries for an object or a specified property on an object.
struct ACTRL_PROPERTY_ENTRYA
{
    ///The GUID of a property on an object. Use the UuidToString function to generate a string representation of a
    ///property GUID.
    const(char)* lpProperty;
    ///A pointer to an ACTRL_ACCESS_ENTRY_LIST structure that contains a list of access-control entries.
    ACTRL_ACCESS_ENTRY_LISTA* pAccessEntryList;
    ///Flags that specify information about the <b>pProperty</b> property. This member can be 0 or the following value.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ACTRL_ACCESS_PROTECTED_"></a><a
    ///id="actrl_access_protected_"></a><dl> <dt><b>ACTRL_ACCESS_PROTECTED </b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> Protects the object or property from inheriting access-control entries. </td> </tr> </table>
    uint         fListFlags;
}

///Contains a list of access-control entries for an object or a specified property on an object.
struct ACTRL_PROPERTY_ENTRYW
{
    ///The GUID of a property on an object. Use the UuidToString function to generate a string representation of a
    ///property GUID.
    const(wchar)* lpProperty;
    ///A pointer to an ACTRL_ACCESS_ENTRY_LIST structure that contains a list of access-control entries.
    ACTRL_ACCESS_ENTRY_LISTW* pAccessEntryList;
    ///Flags that specify information about the <b>pProperty</b> property. This member can be 0 or the following value.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ACTRL_ACCESS_PROTECTED_"></a><a
    ///id="actrl_access_protected_"></a><dl> <dt><b>ACTRL_ACCESS_PROTECTED </b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> Protects the object or property from inheriting access-control entries. </td> </tr> </table>
    uint          fListFlags;
}

///Contains an array of access-control lists for an object and its properties.
struct ACTRL_ACCESSA
{
    ///The number of entries in the <b>pPropertyAccessList</b> array.
    uint cEntries;
    ///An array of ACTRL_PROPERTY_ENTRY structures. Each structure contains a list of access-control entries for an
    ///object or a specified property on the object.
    ACTRL_PROPERTY_ENTRYA* pPropertyAccessList;
}

///Contains an array of access-control lists for an object and its properties.
struct ACTRL_ACCESSW
{
    ///The number of entries in the <b>pPropertyAccessList</b> array.
    uint cEntries;
    ///An array of ACTRL_PROPERTY_ENTRY structures. Each structure contains a list of access-control entries for an
    ///object or a specified property on the object.
    ACTRL_PROPERTY_ENTRYW* pPropertyAccessList;
}

// Functions

///Retrieves a pointer to the default OLE task memory allocator (which supports the system implementation of the IMalloc
///interface) so applications can call its methods to manage memory.
///Params:
///    dwMemContext = This parameter must be 1.
///    ppMalloc = The address of an <b>IMalloc*</b> pointer variable that receives the interface pointer to the memory allocator.
///Returns:
///    This function can return the standard return values S_OK, E_INVALIDARG, and E_OUTOFMEMORY.
///    
@DllImport("OLE32")
HRESULT CoGetMalloc(uint dwMemContext, IMalloc* ppMalloc);

///Closes the COM library on the current thread, unloads all DLLs loaded by the thread, frees any other resources that
///the thread maintains, and forces all RPC connections on the thread to close.
@DllImport("OLE32")
void CoUninitialize();

///Returns a value that is unique to the current thread. <b>CoGetCurrentProcess</b> can be used to avoid thread ID reuse
///problems.
///Returns:
///    The function returns the unique identifier of the current thread.
///    
@DllImport("OLE32")
uint CoGetCurrentProcess();

///Initializes the COM library for use by the calling thread, sets the thread's concurrency model, and creates a new
///apartment for the thread if one is required. You should call Windows::Foundation::Initialize to initialize the thread
///instead of <b>CoInitializeEx</b> if you want to use the Windows Runtime APIs or if you want to use both COM and
///Windows Runtime components. Windows::Foundation::Initialize is sufficient to use for COM components.
///Params:
///    pvReserved = This parameter is reserved and must be <b>NULL</b>.
///    dwCoInit = The concurrency model and initialization options for the thread. Values for this parameter are taken from the
///               COINIT enumeration. Any combination of values from <b>COINIT</b> can be used, except that the
///               COINIT_APARTMENTTHREADED and COINIT_MULTITHREADED flags cannot both be set. The default is COINIT_MULTITHREADED.
///Returns:
///    This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The COM library was initialized successfully on this thread.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The COM library is
///    already initialized on this thread. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>RPC_E_CHANGED_MODE</b></dt>
///    </dl> </td> <td width="60%"> A previous call to CoInitializeEx specified the concurrency model for this thread as
///    multithread apartment (MTA). This could also indicate that a change from neutral-threaded apartment to
///    single-threaded apartment has occurred. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoInitializeEx(void* pvReserved, uint dwCoInit);

///Returns a pointer to a <b>DWORD</b> that contains the apartment ID of the caller's thread.
///Params:
///    lpdwTID = Receives the apartment ID of the caller's thread. For a single threaded apartment (STA), this is the current
///              thread ID. For a multithreaded apartment (MTA), the value is 0. For a neutral apartment (NA), the value is -1.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_TRUE</b></dt> </dl> </td> <td width="60%"> The caller's thread ID is set and the
///    caller is in the same process. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
///    width="60%"> The caller's thread ID is set and the caller is in a different process. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller's thread ID was not set.
///    </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoGetCallerTID(uint* lpdwTID);

///Returns the logical thread identifier of the current physical thread.
///Params:
///    pguid = A pointer to a GUID that contains the logical thread ID on return.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The logical thread ID was retrieved
///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> An
///    invalid pointer was passed in for the <i>pguid</i> parameter. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> A memory allocation failed during the operation of the
///    function. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoGetCurrentLogicalThreadId(GUID* pguid);

///Returns a pointer to an implementation of IObjContext for the current context.
///Params:
///    pToken = A pointer to an implementation of IObjContext for the current context.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The token was retrieved successfully.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller did not
///    pass a valid token pointer variable. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_NOTINITIALIZED</b></dt>
///    </dl> </td> <td width="60%"> The caller is not in an initialized apartment. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoGetContextToken(size_t* pToken);

///Returns the current apartment type and type qualifier.
///Params:
///    pAptType = APTTYPE enumeration value that specifies the type of the current apartment.
///    pAptQualifier = APTTYPEQUALIFIER enumeration value that specifies the type qualifier of the current apartment.
///Returns:
///    Returns S_OK if the call succeeded. Otherwise, one of the following error codes is returned. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
///    width="60%"> The call could not successfully query the current apartment type and type qualifier. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> An invalid parameter value
///    was supplied to the function. Specifically, one or both of the parameters were set to <b>NULL</b> by the caller.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_NOTINITIALIZED</b></dt> </dl> </td> <td width="60%">
///    CoInitialize or CoInitializeEx was not called on this thread prior to calling CoGetApartmentType. </td> </tr>
///    </table>
///    
@DllImport("OLE32")
HRESULT CoGetApartmentType(APTTYPE* pAptType, APTTYPEQUALIFIER* pAptQualifier);

///Keeps MTA support active when no MTA threads are running.
///Params:
///    pCookie = Address of a <b>PVOID</b> variable that receives the cookie for the CoDecrementMTAUsage function, or <b>NULL</b>
///              if the call fails.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("OLE32")
HRESULT CoIncrementMTAUsage(ptrdiff_t* pCookie);

///Releases the increment made by a previous call to the CoIncrementMTAUsage function.
///Params:
///    Cookie = A <b>PVOID</b> variable that was set by a previous call to the CoIncrementMTAUsage function.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("OLE32")
HRESULT CoDecrementMTAUsage(ptrdiff_t Cookie);

///Adds an unmarshaler CLSID to the allowed list for the calling process only.
///Params:
///    clsid = The CLSID of the unmarshaler to be added to the per-process allowed list.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("OLE32")
HRESULT CoAllowUnmarshalerCLSID(const(GUID)* clsid);

///Returns the context for the current object.
///Params:
///    riid = A reference to the ID of an interface that is implemented on the context object. For objects running within COM
///           applications, IID_IComThreadingInfo, IID_IContext, and IID_IContextCallback are available. For objects running
///           within COM+ applications, IID_IObjectContext, IID_IObjectContextActivity IID_IObjectContextInfo, and
///           IID_IContextState are available.
///    ppv = The address of a pointer to the interface specified by <i>riid</i> on the context object.
///Returns:
///    This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The object context was successfully retrieved. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The requested interface was not
///    available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_NOTINITIALIZED</b></dt> </dl> </td> <td
///    width="60%"> Before this function can be called, the CoInitializeEx function must be called on the current
///    thread. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoGetObjectContext(const(GUID)* riid, void** ppv);

///Provides a pointer to an interface on a class object associated with a specified CLSID. <b>CoGetClassObject</b>
///locates, and if necessary, dynamically loads the executable code required to do this. Call <b>CoGetClassObject</b>
///directly to create multiple objects through a class object for which there is a CLSID in the system registry. You can
///also retrieve a class object from a specific remote computer. Most class objects implement the IClassFactory
///interface. You would then call CreateInstance to create an uninitialized object. It is not always necessary to go
///through this process however. To create a single object, call the CoCreateInstanceEx function, which allows you to
///create an instance on a remote machine. This replaces the CoCreateInstance function, which can still be used to
///create an instance on a local computer. Both functions encapsulate connecting to the class object, creating the
///instance, and releasing the class object. Two other functions, CoGetInstanceFromFile and CoGetInstanceFromIStorage,
///provide both instance creation on a remote system and object activation. There are numerous functions and interface
///methods whose purpose is to create objects of a single type and provide a pointer to an interface on that object.
///Params:
///    rclsid = The CLSID associated with the data and code that you will use to create the objects.
///    dwClsContext = The context in which the executable code is to be run. To enable a remote activation, include
///                   CLSCTX_REMOTE_SERVER. For more information on the context values and their use, see the CLSCTX enumeration.
///    pvReserved = A pointer to computer on which to instantiate the class object. If this parameter is <b>NULL</b>, the class
///                 object is instantiated on the current computer or at the computer specified under the class's RemoteServerName
///                 key, according to the interpretation of the <i>dwClsCtx</i> parameter. See COSERVERINFO.
///    riid = Reference to the identifier of the interface, which will be supplied in _ppv_ on successful return. This
///           interface will be used to communicate with the class object. Typically this value is IID_IClassFactory, although
///           other values such as IID_IClassFactory2 which supports a form of licensing are allowed. All OLE-defined interface
///           IIDs are defined in the OLE header files as IID_interfacename, where interfacename is the name of the interface.
///    ppv = The address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful
///          return, *<i>ppv</i> contains the requested interface pointer.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Location and connection to the specified
///    class object was successful. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_CLASSNOTREG</b></dt> </dl>
///    </td> <td width="60%"> The CLSID is not properly registered. This error can also indicate that the value you
///    specified in <i>dwClsContext</i> is not in the registry. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_NOINTERFACE </b></dt> </dl> </td> <td width="60%"> Either the object pointed to by <i>ppv</i> does not
///    support the interface identified by <i>riid</i>, or the QueryInterface operation on the class object returned
///    E_NOINTERFACE. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_READREGDB</b></dt> </dl> </td> <td
///    width="60%"> There was an error reading the registration database. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>CO_E_DLLNOTFOUND</b></dt> </dl> </td> <td width="60%"> Either the in-process DLL or handler DLL was not
///    found (depending on the context). </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_APPNOTFOUND</b></dt> </dl>
///    </td> <td width="60%"> The executable (.exe) was not found (CLSCTX_LOCAL_SERVER only). </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> There was a general access failure
///    on load. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_ERRORINDLL</b></dt> </dl> </td> <td width="60%">
///    There is an error in the executable image. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>CO_E_APPDIDNTREG</b></dt> </dl> </td> <td width="60%"> The executable was launched, but it did not
///    register the class object (and it may have shut down). </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoGetClassObject(const(GUID)* rclsid, uint dwClsContext, void* pvReserved, const(GUID)* riid, void** ppv);

///Registers an EXE class object with OLE so other applications can connect to it.
///Params:
///    rclsid = The CLSID to be registered.
///    pUnk = A pointer to the IUnknown interface on the class object whose availability is being published.
///    dwClsContext = The context in which the executable code is to be run. For information on these context values, see the CLSCTX
///                   enumeration.
///    flags = Indicates how connections are made to the class object. For information on these flags, see the REGCLS
///            enumeration.
///    lpdwRegister = A pointer to a value that identifies the class object registered; later used by the CoRevokeClassObject function
///                   to revoke the registration.
///Returns:
///    This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The class object was registered successfully. </td> </tr>
///    </table>
///    
@DllImport("OLE32")
HRESULT CoRegisterClassObject(const(GUID)* rclsid, IUnknown pUnk, uint dwClsContext, uint flags, 
                              uint* lpdwRegister);

///Informs OLE that a class object, previously registered with the CoRegisterClassObject function, is no longer
///available for use.
///Params:
///    dwRegister = A token previously returned from the CoRegisterClassObject function.
///Returns:
///    This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The class object was revoked successfully. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoRevokeClassObject(uint dwRegister);

///Called by a server that can register multiple class objects to inform the SCM about all registered classes, and
///permits activation requests for those class objects.
///Returns:
///    This function returns S_OK to indicate that the CLSID was retrieved successfully.
///    
@DllImport("OLE32")
HRESULT CoResumeClassObjects();

///Prevents any new activation requests from the SCM on all class objects registered within the process.
///Returns:
///    This function returns S_OK to indicate that the activation of class objects was successfully suspended.
///    
@DllImport("OLE32")
HRESULT CoSuspendClassObjects();

///Increments a global per-process reference count.
///Returns:
///    The current reference count.
///    
@DllImport("OLE32")
uint CoAddRefServerProcess();

///Decrements the global per-process reference count.
///Returns:
///    If the server application should initiate its cleanup, the function returns 0; otherwise, the function returns a
///    nonzero value.
///    
@DllImport("OLE32")
uint CoReleaseServerProcess();

///Returns the CLSID of the DLL that implements the proxy and stub for the specified interface.
///Params:
///    riid = The interface whose proxy/stub CLSID is to be returned.
///    pClsid = Specifies where to store the proxy/stub CLSID for the interface specified by <i>riid</i>.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The proxy/stub CLSID was successfully
///    returned. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of
///    the parameters is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
///    width="60%"> There is insufficient memory to complete this operation. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoGetPSClsid(const(GUID)* riid, GUID* pClsid);

///Enables a downloaded DLL to register its custom interfaces within its running process so that the marshaling code
///will be able to marshal those interfaces.
///Params:
///    riid = A pointer to the IID of the interface to be registered.
///    rclsid = A pointer to the CLSID of the DLL that contains the proxy/stub code for the custom interface specified by
///             <i>riid</i>.
///Returns:
///    This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.
///    
@DllImport("OLE32")
HRESULT CoRegisterPSClsid(const(GUID)* riid, const(GUID)* rclsid);

///Registers the surrogate process through its ISurrogate interface pointer.
///Params:
///    pSurrogate = A pointer to the ISurrogate interface on the surrogate process to be registered.
///Returns:
///    This function returns S_OK to indicate that the surrogate process was registered successfully.
///    
@DllImport("OLE32")
HRESULT CoRegisterSurrogate(ISurrogate pSurrogate);

///Returns an upper bound on the number of bytes needed to marshal the specified interface pointer to the specified
///object.
///Params:
///    pulSize = A pointer to the upper-bound value on the size, in bytes, of the data packet to be written to the marshaling
///              stream. If this parameter is 0, the size of the packet is unknown.
///    riid = A reference to the identifier of the interface whose pointer is to be marshaled. This interface must be derived
///           from the IUnknown interface.
///    pUnk = A pointer to the interface to be marshaled. This interface must be derived from the IUnknown interface.
///    dwDestContext = The destination context where the specified interface is to be unmarshaled. Values for <i>dwDestContext</i> come
///                    from the enumeration MSHCTX.
///    pvDestContext = This parameter is reserved and must be <b>NULL</b>.
///    mshlflags = Indicates whether the data to be marshaled is to be transmitted back to the client processthe normal case or
///                written to a global table, where it can be retrieved by multiple clients. Values come from the enumeration
///                MSHLFLAGS.
///Returns:
///    This function can return the standard return value E_UNEXPECTED, as well as the following values. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> The upper bound was returned successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>CO_E_NOTINITIALIZED</b></dt> </dl> </td> <td width="60%"> Before this function can be called, either the
///    CoInitialize or OleInitialize function must be called. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoGetMarshalSizeMax(uint* pulSize, const(GUID)* riid, IUnknown pUnk, uint dwDestContext, 
                            void* pvDestContext, uint mshlflags);

///Writes into a stream the data required to initialize a proxy object in some client process.
///Params:
///    pStm = A pointer to the stream to be used during marshaling. See IStream.
///    riid = A reference to the identifier of the interface to be marshaled. This interface must be derived from the IUnknown
///           interface.
///    pUnk = A pointer to the interface to be marshaled. This interface must be derived from the IUnknown interface.
///    dwDestContext = The destination context where the specified interface is to be unmarshaled. The possible values come from the
///                    enumeration MSHCTX. Currently, unmarshaling can occur in another apartment of the current process
///                    (MSHCTX_INPROC), in another process on the same computer as the current process (MSHCTX_LOCAL), or in a process
///                    on a different computer (MSHCTX_DIFFERENTMACHINE).
///    pvDestContext = This parameter is reserved and must be <b>NULL</b>.
///    mshlflags = The flags that specify whether the data to be marshaled is to be transmitted back to the client process (the
///                typical case) or written to a global table, where it can be retrieved by multiple clients. The possibles values
///                come from the MSHLFLAGS enumeration.
///Returns:
///    This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, the stream-access
///    error values returned by IStream, as well as the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
///    <b>HRESULT</b> was marshaled successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>CO_E_NOTINITIALIZED</b></dt> </dl> </td> <td width="60%"> The CoInitialize or OleInitialize function was
///    not called on the current thread before this function was called. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoMarshalInterface(IStream pStm, const(GUID)* riid, IUnknown pUnk, uint dwDestContext, void* pvDestContext, 
                           uint mshlflags);

///Initializes a newly created proxy using data written into the stream by a previous call to the CoMarshalInterface
///function, and returns an interface pointer to that proxy.
///Params:
///    pStm = A pointer to the stream from which the interface is to be unmarshaled.
///    riid = A reference to the identifier of the interface to be unmarshaled. For <b>IID_NULL</b>, the returned interface is
///           the one defined by the stream, objref.iid.
///    ppv = The address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///          *<i>ppv</i> contains the requested interface pointer for the unmarshaled interface.
///Returns:
///    This function can return the standard return value E_FAIL, errors returned by CoCreateInstance, and the following
///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The interface pointer was unmarshaled successfully. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>STG_E_INVALIDPOINTER</b></dt> </dl> </td> <td width="60%"> <i>pStm</i> is an
///    invalid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_NOTINITIALIZED</b></dt> </dl> </td> <td
///    width="60%"> The CoInitialize or OleInitialize function was not called on the current thread before this function
///    was called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_OBJNOTCONNECTED</b></dt> </dl> </td> <td
///    width="60%"> The object application has been disconnected from the remoting system (for example, as a result of a
///    call to the CoDisconnectObject function). </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>REGDB_E_CLASSNOTREG</b></dt> </dl> </td> <td width="60%"> An error occurred reading the registration
///    database. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The
///    final QueryInterface of this function for the requested interface returned E_NOINTERFACE. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoUnmarshalInterface(IStream pStm, const(GUID)* riid, void** ppv);

///Marshals an <b>HRESULT</b> to the specified stream, from which it can be unmarshaled using the CoUnmarshalHresult
///function.
///Params:
///    pstm = A pointer to the marshaling stream. See IStream.
///    hresult = The <b>HRESULT</b> in the originating process.
///Returns:
///    This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The <b>HRESULT</b> was marshaled successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>STG_E_INVALIDPOINTER</b></dt> </dl> </td> <td width="60%"> A bad pointer was
///    specified for <i>pstm</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>STG_E_MEDIUMFULL</b></dt> </dl> </td>
///    <td width="60%"> The medium is full. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoMarshalHresult(IStream pstm, HRESULT hresult);

///Unmarshals an <b>HRESULT</b> type from the specified stream.
///Params:
///    pstm = A pointer to the stream from which the <b>HRESULT</b> is to be unmarshaled.
///    phresult = A pointer to the unmarshaled <b>HRESULT</b>.
///Returns:
///    This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The <b>HRESULT</b> was unmarshaled successfully. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>STG_E_INVALIDPOINTER</b></dt> </dl> </td> <td width="60%"> <i>pStm</i> is an
///    invalid pointer. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoUnmarshalHresult(IStream pstm, int* phresult);

///Destroys a previously marshaled data packet.
///Params:
///    pStm = A pointer to the stream that contains the data packet to be destroyed. See IStream.
///Returns:
///    This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as
///    well as the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The data packet was successfully destroyed. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>STG_E_INVALIDPOINTER</b></dt> </dl> </td> <td width="60%"> An error related to
///    the <i>pStm</i> parameter. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_NOTINITIALIZED</b></dt> </dl> </td>
///    <td width="60%"> The CoInitialize or OleInitialize function was not called on the current thread before this
///    function was called. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoReleaseMarshalData(IStream pStm);

///Disconnects all remote process connections being maintained on behalf of all the interface pointers that point to a
///specified object. Only the process that actually manages the object should call <b>CoDisconnectObject</b>.
///Params:
///    pUnk = A pointer to any interface derived from IUnknown on the object to be disconnected.
///    dwReserved = This parameter is reserved and must be 0.
///Returns:
///    This function returns S_OK to indicate that all connections to remote processes were successfully deleted.
///    
@DllImport("OLE32")
HRESULT CoDisconnectObject(IUnknown pUnk, uint dwReserved);

///Called either to lock an object to ensure that it stays in memory, or to release such a lock.
///Params:
///    pUnk = A pointer to the IUnknown interface on the object to be locked or unlocked.
///    fLock = Indicates whether the object is to be locked or released. If this parameter is <b>TRUE</b>, the object is kept in
///            memory, independent of <b>AddRef</b>/<b>Release</b> operations, registrations, or revocations. If this parameter
///            is <b>FALSE</b>, the lock previously set with a call to this function is released.
///    fLastUnlockReleases = If the lock is the last reference that is supposed to keep an object alive, specify <b>TRUE</b> to release all
///                          pointers to the object (there may be other references that are not supposed to keep it alive). Otherwise, specify
///                          <b>FALSE</b>. If <i>fLock</i> is <b>TRUE</b>, this parameter is ignored.
///Returns:
///    This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.
///    
@DllImport("OLE32")
HRESULT CoLockObjectExternal(IUnknown pUnk, BOOL fLock, BOOL fLastUnlockReleases);

///Creates a default, or standard, marshaling object in either the client process or the server process, depending on
///the caller, and returns a pointer to that object's IMarshal implementation.
///Params:
///    riid = A reference to the identifier of the interface whose pointer is to be marshaled. This interface must be derived
///           from the IUnknown interface.
///    pUnk = A pointer to the interface to be marshaled.
///    dwDestContext = The destination context where the specified interface is to be unmarshaled. Values come from the enumeration
///                    MSHCTX. Unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or in another
///                    process on the same computer as the current process (MSHCTX_LOCAL).
///    pvDestContext = This parameter is reserved and must be <b>NULL</b>.
///    mshlflags = Indicates whether the data to be marshaled is to be transmitted back to the client process (the normal case) or
///                written to a global table where it can be retrieved by multiple clients. Values come from the MSHLFLAGS
///                enumeration.
///    ppMarshal = The address of <b>IMarshal*</b> pointer variable that receives the interface pointer to the standard marshaler.
///Returns:
///    This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The IMarshal instance was returned successfully. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>CO_E_NOTINITIALIZED</b></dt> </dl> </td> <td width="60%"> Before this function
///    can be called, the CoInitialize or OleInitialize function must be called on the current thread. </td> </tr>
///    </table>
///    
@DllImport("OLE32")
HRESULT CoGetStandardMarshal(const(GUID)* riid, IUnknown pUnk, uint dwDestContext, void* pvDestContext, 
                             uint mshlflags, IMarshal* ppMarshal);

///Creates an aggregated standard marshaler for use with lightweight client-side handlers.
///Params:
///    pUnkOuter = A pointer to the controlling IUnknown.
///    smexflags = One of two values indicating whether the aggregated standard marshaler is on the client side or the server side.
///                These flags are defined in the <b>STDMSHLFLAGS</b> enumeration. <table> <tr> <th>Value</th> <th>Meaning</th>
///                </tr> <tr> <td width="40%"><a id="SMEXF_SERVER"></a><a id="smexf_server"></a><dl> <dt><b>SMEXF_SERVER</b></dt>
///                <dt>0x01</dt> </dl> </td> <td width="60%"> Indicates a server-side aggregated standard marshaler. </td> </tr>
///                <tr> <td width="40%"><a id="SMEXF_HANDLER"></a><a id="smexf_handler"></a><dl> <dt><b>SMEXF_HANDLER</b></dt>
///                <dt>0x0</dt> </dl> </td> <td width="60%"> Indicates a client-side (handler) aggregated standard marshaler. </td>
///                </tr> </table>
///    ppUnkInner = On successful return, address of pointer to the IUnknown interface on the newly-created aggregated standard
///                 marshaler. If an error occurs, this value is <b>NULL</b>.
///Returns:
///    This function returns S_OK.
///    
@DllImport("OLE32")
HRESULT CoGetStdMarshalEx(IUnknown pUnkOuter, uint smexflags, IUnknown* ppUnkInner);

///Determines whether a remote object is connected to the corresponding in-process object.
///Params:
///    pUnk = A pointer to the controlling IUnknown interface on the remote object.
///Returns:
///    If the object is not remote or if it is remote and still connected, the return value is <b>TRUE</b>; otherwise,
///    it is <b>FALSE</b>.
///    
@DllImport("OLE32")
BOOL CoIsHandlerConnected(IUnknown pUnk);

///Marshals an interface pointer from one thread to another thread in the same process.
///Params:
///    riid = A reference to the identifier of the interface to be marshaled.
///    pUnk = A pointer to the interface to be marshaled, which must be derived from IUnknown. This parameter can be
///           <b>NULL</b>.
///    ppStm = The address of the IStream* pointer variable that receives the interface pointer to the stream that contains the
///            marshaled interface.
///Returns:
///    This function can return the standard return values E_OUTOFMEMORY and S_OK.
///    
@DllImport("OLE32")
HRESULT CoMarshalInterThreadInterfaceInStream(const(GUID)* riid, IUnknown pUnk, IStream* ppStm);

///Unmarshals a buffer containing an interface pointer and releases the stream when an interface pointer has been
///marshaled from another thread to the calling thread.
///Params:
///    pStm = A pointer to the IStream interface on the stream to be unmarshaled.
///    iid = A reference to the identifier of the interface requested from the unmarshaled object.
///    ppv = The address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///          *<i>ppv</i> contains the requested interface pointer to the unmarshaled interface.
///Returns:
///    This function can return the standard return values S_OK and E_INVALIDARG, as well as any of the values returned
///    by CoUnmarshalInterface.
///    
@DllImport("OLE32")
HRESULT CoGetInterfaceAndReleaseStream(IStream pStm, const(GUID)* iid, void** ppv);

///Creates an aggregatable object capable of context-dependent marshaling.
///Params:
///    punkOuter = A pointer to the aggregating object's controlling IUnknown.
///    ppunkMarshal = Address of the pointer variable that receives the interface pointer to the aggregatable marshaler.
///Returns:
///    This function can return the standard return value E_OUTOFMEMORY, as well as the following value. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> The marshaler was created. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoCreateFreeThreadedMarshaler(IUnknown punkOuter, IUnknown* ppunkMarshal);

///Unloads any DLLs that are no longer in use, probably because the DLL no longer has any instantiated COM objects
///outstanding. <div class="alert"><b>Note</b> This function is provided for compatibility with 16-bit
///Windows.</div><div> </div>
@DllImport("OLE32")
void CoFreeUnusedLibraries();

///Unloads any DLLs that are no longer in use and whose unload delay has expired.
///Params:
///    dwUnloadDelay = The delay in milliseconds between the time that the DLL has stated it can be unloaded until it becomes a
///                    candidate to unload. Setting this parameter to INFINITE uses the system default delay (10 minutes). Setting this
///                    parameter to 0 forces the unloading of any DLLs without any delay.
///    dwReserved = This parameter is reserved and must be 0.
@DllImport("OLE32")
void CoFreeUnusedLibrariesEx(uint dwUnloadDelay, uint dwReserved);

///Disconnects all proxy connections that are being maintained on behalf of all interface pointers that point to objects
///in the current context. This function blocks connections until all objects are successfully disconnected or the
///time-out expires. Only the context that actually manages the objects should call <b>CoDisconnectContext</b>.
///Params:
///    dwTimeout = The time in milliseconds after which <b>CoDisconnectContext</b> returns even if the proxy connections for all
///                objects have not been disconnected. INFINITE is an acceptable value for this parameter.
///Returns:
///    This function can return the standard return values E_FAIL, E_INVALIDARG, and E_OUTOFMEMORY, as well as the
///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The proxy connections for all objects were successfully
///    disconnected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>RPC_E_TIMEOUT</b></dt> </dl> </td> <td width="60%">
///    Not all proxy connections were successfully deleted in the time specified in <i>dwTimeout</i>. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>CO_E_NOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> The current context cannot
///    be disconnected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CONTEXT_E_WOULD_DEADLOCK</b></dt> </dl> </td> <td
///    width="60%"> An object tried to call CoDisconnectContext on the context it is residing in. This would cause the
///    function to time-out and deadlock if <i>dwTimeout</i> were set to INFINITE. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoDisconnectContext(uint dwTimeout);

///Registers security and sets the default security values for the process.
///Params:
///    pSecDesc = The access permissions that a server will use to receive calls. This parameter is used by COM only when a server
///               calls <b>CoInitializeSecurity</b>. Its value is a pointer to one of three types: an AppID, an IAccessControl
///               object, or a SECURITY_DESCRIPTOR, in absolute format. See the Remarks section for more information.
///    cAuthSvc = The count of entries in the <i>asAuthSvc</i> parameter. This parameter is used by COM only when a server calls
///               <b>CoInitializeSecurity</b>. If this parameter is 0, no authentication services will be registered and the server
///               cannot receive secure calls. A value of -1 tells COM to choose which authentication services to register, and if
///               this is the case, the <i>asAuthSvc</i> parameter must be <b>NULL</b>. However, Schannel will never be chosen as
///               an authentication service by the server if this parameter is -1.
///    asAuthSvc = An array of authentication services that a server is willing to use to receive a call. This parameter is used by
///                COM only when a server calls <b>CoInitializeSecurity</b>. For more information, see SOLE_AUTHENTICATION_SERVICE.
///    pReserved1 = This parameter is reserved and must be <b>NULL</b>.
///    dwAuthnLevel = The default authentication level for the process. Both servers and clients use this parameter when they call
///                   <b>CoInitializeSecurity</b>. COM will fail calls that arrive with a lower authentication level. By default, all
///                   proxies will use at least this authentication level. This value should contain one of the authentication level
///                   constants. By default, all calls to IUnknown are made at this level.
///    dwImpLevel = The default impersonation level for proxies. The value of this parameter is used only when the process is a
///                 client. It should be a value from the impersonation level constants, except for RPC_C_IMP_LEVEL_DEFAULT, which is
///                 not for use with <b>CoInitializeSecurity</b>. Outgoing calls from the client always use the impersonation level
///                 as specified. (It is not negotiated.) Incoming calls to the client can be at any impersonation level. By default,
///                 all IUnknown calls are made with this impersonation level, so even security-aware applications should set this
///                 level carefully. To determine which impersonation levels each authentication service supports, see the
///                 description of the authentication services in COM and Security Packages. For more information about impersonation
///                 levels, see Impersonation.
///    pAuthList = A pointer to SOLE_AUTHENTICATION_LIST, which is an array of SOLE_AUTHENTICATION_INFO structures. This list
///                indicates the information for each authentication service that a client can use to call a server. This parameter
///                is used by COM only when a client calls <b>CoInitializeSecurity</b>.
///    dwCapabilities = Additional capabilities of the client or server, specified by setting one or more
///                     EOLE_AUTHENTICATION_CAPABILITIES values. Some of these value cannot be used simultaneously, and some cannot be
///                     set when particular authentication services are being used. For more information about these flags, see the
///                     Remarks section.
///    pReserved3 = This parameter is reserved and must be <b>NULL</b>.
///Returns:
///    This function can return the standard return value E_INVALIDARG, as well as the following values. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> Indicates success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>RPC_E_TOO_LATE</b></dt> </dl> </td>
///    <td width="60%"> CoInitializeSecurity has already been called. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>RPC_E_NO_GOOD_SECURITY_PACKAGES</b></dt> </dl> </td> <td width="60%"> The <i>asAuthSvc</i> parameter was
///    not <b>NULL</b>, and none of the authentication services in the list could be registered. Check the results saved
///    in <i>asAuthSvc</i> for authentication servicespecific error codes. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_OUT_OF_MEMORY</b></dt> </dl> </td> <td width="60%"> Out of memory. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoInitializeSecurity(void* pSecDesc, int cAuthSvc, char* asAuthSvc, void* pReserved1, uint dwAuthnLevel, 
                             uint dwImpLevel, void* pAuthList, uint dwCapabilities, void* pReserved3);

///Retrieves the context of the current call on the current thread.
///Params:
///    riid = Interface identifier (IID) of the call context that is being requested. If you are using the default call context
///           supported by standard marshaling, IID_IServerSecurity is available. For COM+ applications using role-based
///           security, IID_ISecurityCallContext is available.
///    ppInterface = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///                  *<i>ppInterface</i> contains the requested interface pointer.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The context was retrieved successfully.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The call
///    context does not support the interface specified by <i>riid</i>. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoGetCallContext(const(GUID)* riid, void** ppInterface);

///Retrieves the authentication information the client uses to make calls on the specified proxy. This is a helper
///function for IClientSecurity::QueryBlanket.
///Params:
///    pProxy = A pointer indicating the proxy to query. This parameter cannot be <b>NULL</b>. For more information, see the
///             Remarks section.
///    pwAuthnSvc = A pointer to a variable that receives the current authentication service. This will be a single value taken from
///                 the authentication service constants. This parameter cannot be <b>NULL</b>.
///    pAuthzSvc = A pointer to a variable that receives the current authorization service. This will be a single value taken from
///                the authorization constants. If the caller specifies <b>NULL</b>, the current authorization service is not
///                retrieved.
///    pServerPrincName = The current principal name. The string will be allocated by the callee using CoTaskMemAlloc, and must be freed by
///                       the caller using CoTaskMemFree. The EOAC_MAKE_FULLSIC flag is not accepted in the <i>pCapabilities</i> parameter.
///                       For more information about the msstd and fullsic forms, see Principal Names. If the caller specifies <b>NULL</b>,
///                       the current principal name is not retrieved.
///    pAuthnLevel = A pointer to a variable that receives the current authentication level. This will be a single value taken from
///                  the authentication level constants. If the caller specifies <b>NULL</b>, the current authentication level is not
///                  retrieved.
///    pImpLevel = A pointer to a variable that receives the current impersonation level. This will be a single value taken from the
///                impersonation level constants. If the caller specifies <b>NULL</b>, the current impersonation level is not
///                retrieved.
///    pAuthInfo = A pointer to a handle that receives the identity of the client that was passed to the last
///                IClientSecurity::SetBlanket call (or the default value). Default values are only valid until the proxy is
///                released. If the caller specifies <b>NULL</b>, the client identity is not retrieved. The format of the structure
///                that the handle refers to depends on the authentication service. The application should not write or free the
///                memory. For NTLMSSP and Kerberos, if the client specified a structure in the <i>pAuthInfo</i> parameter to
///                CoInitializeSecurity, that value is returned. For Schannel, if a certificate for the client could be retrieved
///                from the certificate manager, that value is returned here. Otherwise, <b>NULL</b> is returned. See
///                RPC_AUTH_IDENTITY_HANDLE.
///    pCapabilites = A pointer to a variable that receives the capabilities of the proxy. If the caller specifies <b>NULL</b>, the
///                   current capability flags are not retrieved.
///Returns:
///    This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.
///    
@DllImport("OLE32")
HRESULT CoQueryProxyBlanket(IUnknown pProxy, uint* pwAuthnSvc, uint* pAuthzSvc, ushort** pServerPrincName, 
                            uint* pAuthnLevel, uint* pImpLevel, void** pAuthInfo, uint* pCapabilites);

///Sets the authentication information that will be used to make calls on the specified proxy. This is a helper function
///for IClientSecurity::SetBlanket.
///Params:
///    pProxy = The proxy to be set.
///    dwAuthnSvc = The authentication service to be used. For a list of possible values, see Authentication Service Constants. Use
///                 RPC_C_AUTHN_NONE if no authentication is required. If RPC_C_AUTHN_DEFAULT is specified, DCOM will pick an
///                 authentication service following its normal security blanket negotiation algorithm.
///    dwAuthzSvc = The authorization service to be used. For a list of possible values, see Authorization Constants. If
///                 RPC_C_AUTHZ_DEFAULT is specified, DCOM will pick an authorization service following its normal security blanket
///                 negotiation algorithm. RPC_C_AUTHZ_NONE should be used as the authorization service if NTLMSSP, Kerberos, or
///                 Schannel is used as the authentication service.
///    pServerPrincName = The server principal name to be used with the authentication service. If COLE_DEFAULT_PRINCIPAL is specified,
///                       DCOM will pick a principal name using its security blanket negotiation algorithm. If Kerberos is used as the
///                       authentication service, this value must not be <b>NULL</b>. It must be the correct principal name of the server
///                       or the call will fail. If Schannel is used as the authentication service, this value must be one of the msstd or
///                       fullsic forms described in Principal Names, or <b>NULL</b> if you do not want mutual authentication. Generally,
///                       specifying <b>NULL</b> will not reset the server principal name on the proxy; rather, the previous setting will
///                       be retained. You must be careful when using <b>NULL</b> as <i>pServerPrincName</i> when selecting a different
///                       authentication service for the proxy, because there is no guarantee that the previously set principal name would
///                       be valid for the newly selected authentication service.
///    dwAuthnLevel = The authentication level to be used. For a list of possible values, see Authentication Level Constants. If
///                   RPC_C_AUTHN_LEVEL_DEFAULT is specified, DCOM will pick an authentication level following its normal security
///                   blanket negotiation algorithm. If this value is none, the authentication service must also be none.
///    dwImpLevel = The impersonation level to be used. For a list of possible values, see Impersonation Level Constants. If
///                 RPC_C_IMP_LEVEL_DEFAULT is specified, DCOM will pick an impersonation level following its normal security blanket
///                 negotiation algorithm. If NTLMSSP is the authentication service, this value must be RPC_C_IMP_LEVEL_IMPERSONATE
///                 or RPC_C_IMP_LEVEL_IDENTIFY. NTLMSSP also supports delegate-level impersonation (RPC_C_IMP_LEVEL_DELEGATE) on the
///                 same computer. If Schannel is the authentication service, this parameter must be RPC_C_IMP_LEVEL_IMPERSONATE.
///    pAuthInfo = A pointer to an <b>RPC_AUTH_IDENTITY_HANDLE</b> value that establishes the identity of the client. The format of
///                the structure referred to by the handle depends on the provider of the authentication service. For calls on the
///                same computer, RPC logs on the user with the supplied credentials and uses the resulting token for the method
///                call. For NTLMSSP or Kerberos, the structure is a SEC_WINNT_AUTH_IDENTITY or SEC_WINNT_AUTH_IDENTITY_EX
///                structure. The client can discard <i>pAuthInfo</i> after calling the API. RPC does not keep a copy of the
///                <i>pAuthInfo</i> pointer, and the client cannot retrieve it later in the CoQueryProxyBlanket method. If this
///                parameter is <b>NULL</b>, DCOM uses the current proxy identity (which is either the process token or the
///                impersonation token). If the handle refers to a structure, that identity is used. For Schannel, this parameter
///                must be either a pointer to a CERT_CONTEXT structure that contains the client's X.509 certificate or is
///                <b>NULL</b> if the client wishes to make an anonymous connection to the server. If a certificate is specified,
///                the caller must not free it as long as any proxy to the object exists in the current apartment. For Snego, this
///                member is either <b>NULL</b>, points to a SEC_WINNT_AUTH_IDENTITY structure, or points to a
///                SEC_WINNT_AUTH_IDENTITY_EX structure. If it is <b>NULL</b>, Snego will pick a list of authentication services
///                based on those available on the client computer. If it points to a <b>SEC_WINNT_AUTH_IDENTITY_EX</b> structure,
///                the structure's <b>PackageList</b> member must point to a string containing a comma-separated list of
///                authentication service names and the <b>PackageListLength</b> member must give the number of bytes in the
///                <b>PackageList</b> string. If <b>PackageList</b> is <b>NULL</b>, all calls using Snego will fail. If
///                COLE_DEFAULT_AUTHINFO is specified for this parameter, DCOM will pick the authentication information following
///                its normal security blanket negotiation algorithm. <b>CoSetProxyBlanket</b> will fail if <i>pAuthInfo</i> is set
///                and one of the cloaking flags is set in the <i>dwCapabilities</i> parameter.
///    dwCapabilities = The capabilities of this proxy. For a list of possible values, see the EOLE_AUTHENTICATION_CAPABILITIES
///                     enumeration. The only flags that can be set through this function are EOAC_MUTUAL_AUTH, EOAC_STATIC_CLOAKING,
///                     EOAC_DYNAMIC_CLOAKING, EOAC_ANY_AUTHORITY (this flag is deprecated), EOAC_MAKE_FULLSIC, and EOAC_DEFAULT. Either
///                     EOAC_STATIC_CLOAKING or EOAC_DYNAMIC_CLOAKING can be set if <i>pAuthInfo</i> is not set and Schannel is not the
///                     authentication service. (See Cloaking for more information.) If any capability flags other than those mentioned
///                     here are set, <b>CoSetProxyBlanket</b> will fail.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function was successful. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or more arguments is
///    invalid. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoSetProxyBlanket(IUnknown pProxy, uint dwAuthnSvc, uint dwAuthzSvc, ushort* pServerPrincName, 
                          uint dwAuthnLevel, uint dwImpLevel, void* pAuthInfo, uint dwCapabilities);

///Makes a private copy of the specified proxy.
///Params:
///    pProxy = A pointer to the IUnknown interface on the proxy to be copied. This parameter cannot be <b>NULL</b>.
///    ppCopy = Address of the pointer variable that receives the interface pointer to the copy of the proxy. This parameter
///             cannot be <b>NULL</b>.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Indicates success. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or more arguments are invalid.
///    </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoCopyProxy(IUnknown pProxy, IUnknown* ppCopy);

///Called by the server to find out about the client that invoked the method executing on the current thread. This is a
///helper function for IServerSecurity::QueryBlanket.
///Params:
///    pAuthnSvc = A pointer to a variable that receives the current authentication service. This will be a single value taken from
///                the authentication service constants. If the caller specifies <b>NULL</b>, the current authentication service is
///                not retrieved.
///    pAuthzSvc = A pointer to a variable that receives the current authorization service. This will be a single value taken from
///                the authorization constants. If the caller specifies <b>NULL</b>, the current authorization service is not
///                retrieved.
///    pServerPrincName = The current principal name. The string will be allocated by the callee using CoTaskMemAlloc, and must be freed by
///                       the caller using CoTaskMemFree. By default, Schannel principal names will be in the msstd form. The fullsic form
///                       will be returned if EOAC_MAKE_FULLSIC is specified in the <i>pCapabilities</i> parameter. For more information
///                       about the msstd and fullsic forms, see Principal Names. If the caller specifies <b>NULL</b>, the current
///                       principal name is not retrieved.
///    pAuthnLevel = A pointer to a variable that receives the current authentication level. This will be a single value taken from
///                  the authentication level constants. If the caller specifies <b>NULL</b>, the current authentication level is not
///                  retrieved.
///    pImpLevel = This parameter must be <b>NULL</b>.
///    pPrivs = A pointer to a handle that receives the privilege information for the client application. The format of the
///             structure that the handle refers to depends on the authentication service. The application should not write or
///             free the memory. The information is valid only for the duration of the current call. For NTLMSSP and Kerberos,
///             this is a string identifying the client principal. For Schannel, this is a CERT_CONTEXT structure that represents
///             the client's certificate. If the client has no certificate, <b>NULL</b> is returned. If the caller specifies
///             <b>NULL</b>, the current privilege information is not retrieved. See RPC_AUTHZ_HANDLE.
///    pCapabilities = A pointer to return flags indicating capabilities of the call. To request that the principal name be returned in
///                    fullsic form if Schannel is the authentication service, the caller can set the EOAC_MAKE_FULLSIC flag in this
///                    parameter. If the caller specifies <b>NULL</b>, the current capabilities are not retrieved.
///Returns:
///    This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.
///    
@DllImport("OLE32")
HRESULT CoQueryClientBlanket(uint* pAuthnSvc, uint* pAuthzSvc, ushort** pServerPrincName, uint* pAuthnLevel, 
                             uint* pImpLevel, void** pPrivs, uint* pCapabilities);

///Enables the server to impersonate the client of the current call for the duration of the call.
///Returns:
///    This function supports the standard return values, including S_OK.
///    
@DllImport("OLE32")
HRESULT CoImpersonateClient();

///Restores the authentication information on a thread of execution.
///Returns:
///    This function supports the standard return values, including S_OK to indicate success.
///    
@DllImport("OLE32")
HRESULT CoRevertToSelf();

///Retrieves a list of the authentication services registered when the process called CoInitializeSecurity.
///Params:
///    pcAuthSvc = A pointer to a variable that receives the number of entries returned in the <i>asAuthSvc</i> array.
///    asAuthSvc = A pointer to an array of SOLE_AUTHENTICATION_SERVICE structures. The list is allocated through a call to the
///                CoTaskMemAlloc function. The caller must free the list when finished with it by calling the CoTaskMemFree
///                function.
///Returns:
///    This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.
///    
@DllImport("OLE32")
HRESULT CoQueryAuthenticationServices(uint* pcAuthSvc, SOLE_AUTHENTICATION_SERVICE** asAuthSvc);

///Switches the call context object used by CoGetCallContext.
///Params:
///    pNewObject = A pointer to an interface on the new call context object. COM stores this pointer without adding a reference to
///                 the pointer until <b>CoSwitchCallContext</b> is called with another object. This parameter may be <b>NULL</b> if
///                 you are calling <b>CoSwitchCallContext</b> to switch back to the original call context but there was no original
///                 call context.
///    ppOldObject = The address of pointer variable that receives a pointer to the call context object of the call currently in
///                  progress. This value is returned so that the original call context can be restored by the custom marshaller. The
///                  returned pointer will be <b>NULL</b> if there was no call in progress.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function was successful. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>E_OUT_OF_MEMORY</b></dt> </dl> </td> <td width="60%"> Out of memory. </td>
///    </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoSwitchCallContext(IUnknown pNewObject, IUnknown* ppOldObject);

///Creates and default-initializes a single object of the class associated with a specified CLSID. Call
///<b>CoCreateInstance</b> when you want to create only one object on the local system. To create a single object on a
///remote system, call the CoCreateInstanceEx function. To create multiple objects based on a single CLSID, call the
///CoGetClassObject function.
///Params:
///    rclsid = The CLSID associated with the data and code that will be used to create the object.
///    pUnkOuter = If <b>NULL</b>, indicates that the object is not being created as part of an aggregate. If non-<b>NULL</b>,
///                pointer to the aggregate object's IUnknown interface (the controlling <b>IUnknown</b>).
///    dwClsContext = Context in which the code that manages the newly created object will run. The values are taken from the
///                   enumeration CLSCTX.
///    riid = A reference to the identifier of the interface to be used to communicate with the object.
///    ppv = Address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful return,
///          *<i>ppv</i> contains the requested interface pointer. Upon failure, *<i>ppv</i> contains <b>NULL</b>.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> An instance of the specified object class
///    was successfully created. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_CLASSNOTREG</b></dt> </dl> </td>
///    <td width="60%"> A specified class is not registered in the registration database. Also can indicate that the
///    type of server you requested in the CLSCTX enumeration is not registered or the values for the server types in
///    the registry are corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CLASS_E_NOAGGREGATION</b></dt> </dl>
///    </td> <td width="60%"> This class cannot be created as part of an aggregate. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The specified class does not implement the
///    requested interface, or the controlling IUnknown does not expose the requested interface. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppv</i> parameter is <b>NULL</b>.
///    </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoCreateInstance(const(GUID)* rclsid, IUnknown pUnkOuter, uint dwClsContext, const(GUID)* riid, void** ppv);

///Creates an instance of a specific class on a specific computer.
///Params:
///    Clsid = The CLSID of the object to be created.
///    punkOuter = If this parameter non-<b>NULL</b>, indicates the instance is being created as part of an aggregate, and
///                <i>punkOuter</i> is to be used as the new instance's controlling IUnknown. Aggregation is currently not supported
///                cross-process or cross-computer. When instantiating an object out of process, CLASS_E_NOAGGREGATION will be
///                returned if <i>punkOuter</i> is non-<b>NULL</b>.
///    dwClsCtx = A value from the CLSCTX enumeration.
///    pServerInfo = Information about the computer on which to instantiate the object. See COSERVERINFO. This parameter can be
///                  <b>NULL</b>, in which case the object is instantiated on the local computer or at the computer specified in the
///                  registry under the class's RemoteServerName value, according to the interpretation of the <i>dwClsCtx</i>
///                  parameter.
///    dwCount = The number of structures in <i>pResults</i>. This value must be greater than 0.
///    pResults = An array of MULTI_QI structures. Each structure has three members: the identifier for a requested interface
///               (<b>pIID</b>), the location to return the interface pointer (<b>pItf</b>) and the return value of the call to
///               QueryInterface (<b>hr</b>).
///Returns:
///    This function can return the standard return value E_INVALIDARG, as well as the following values. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> Indicates success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_CLASSNOTREG</b></dt> </dl>
///    </td> <td width="60%"> A specified class is not registered in the registration database. Also can indicate that
///    the type of server you requested in the CLSCTX enumeration is not registered or the values for the server types
///    in the registry are corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CLASS_E_NOAGGREGATION</b></dt> </dl>
///    </td> <td width="60%"> This class cannot be created as part of an aggregate. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>CO_S_NOTALLINTERFACES</b></dt> </dl> </td> <td width="60%"> At least one, but not all of the
///    interfaces requested in the <i>pResults</i> array were successfully retrieved. The <b>hr</b> member of each of
///    the MULTI_QI structures in <i>pResults</i> indicates with S_OK or E_NOINTERFACE whether the specific interface
///    was returned. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%">
///    None of the interfaces requested in the <i>pResults</i> array were successfully retrieved. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoCreateInstanceEx(const(GUID)* Clsid, IUnknown punkOuter, uint dwClsCtx, COSERVERINFO* pServerInfo, 
                           uint dwCount, char* pResults);

///Creates an instance of a specific class on a specific computer from within an app container.
///Params:
///    Clsid = The CLSID of the object to be created.
///    punkOuter = If this parameter non-<b>NULL</b>, indicates the instance is being created as part of an aggregate, and
///                <i>punkOuter</i> is to be used as the new instance's controlling IUnknown. Aggregation is currently not supported
///                cross-process or cross-computer. When instantiating an object out of process, CLASS_E_NOAGGREGATION will be
///                returned if <i>punkOuter</i> is non-<b>NULL</b>.
///    dwClsCtx = A value from the CLSCTX enumeration.
///    reserved = Reserved for future use.
///    dwCount = The number of structures in <i>pResults</i>. This value must be greater than 0.
///    pResults = An array of MULTI_QI structures. Each structure has three members: the identifier for a requested interface
///               (<b>pIID</b>), the location to return the interface pointer (<b>pItf</b>) and the return value of the call to
///               QueryInterface (<b>hr</b>).
///Returns:
///    This function can return the standard return value E_INVALIDARG, as well as the following values. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> Indicates success. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_CLASSNOTREG</b></dt> </dl>
///    </td> <td width="60%"> A specified class is not registered in the registration database, or the class is not
///    supported in the app container. Also can indicate that the type of server you requested in the CLSCTX enumeration
///    is not registered or the values for the server types in the registry are corrupt. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>CLASS_E_NOAGGREGATION</b></dt> </dl> </td> <td width="60%"> This class cannot be created
///    as part of an aggregate. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_S_NOTALLINTERFACES</b></dt> </dl> </td>
///    <td width="60%"> At least one, but not all of the interfaces requested in the <i>pResults</i> array were
///    successfully retrieved. The <b>hr</b> member of each of the MULTI_QI structures in <i>pResults</i> indicates with
///    S_OK or E_NOINTERFACE whether the specific interface was returned. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> None of the interfaces requested in the
///    <i>pResults</i> array were successfully retrieved. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoCreateInstanceFromApp(const(GUID)* Clsid, IUnknown punkOuter, uint dwClsCtx, void* reserved, 
                                uint dwCount, char* pResults);

///Registers a process-wide filter to process activation requests.
///Params:
///    pActivationFilter = Pointer to the filter to register.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("OLE32")
HRESULT CoRegisterActivationFilter(IActivationFilter pActivationFilter);

///Obtains a pointer to a call control interface, normally ICancelMethodCalls, on the cancel object corresponding to an
///outbound COM method call pending on the same or another client thread.
///Params:
///    dwThreadId = The identifier of the thread on which the pending COM call is to be canceled. If this parameter is 0, the call is
///                 on the current thread.
///    iid = The globally unique identifier of an interface on the cancel object for the call to be canceled. This argument is
///          usually IID_ICancelMethodCalls.
///    ppUnk = Receives the address of a pointer to the interface specified by <i>riid</i>.
///Returns:
///    This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as
///    well as the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The call control object was retrieved successfully. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The object on which
///    the call is executing does not support the interface specified by <i>riid</i>. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoGetCancelObject(uint dwThreadId, const(GUID)* iid, void** ppUnk);

///Sets (registers) or resets (unregisters) a cancel object for use during subsequent cancel operations on the current
///thread.
///Params:
///    pUnk = Pointer to the IUnknown interface on the cancel object to be set or reset on the current thread. If this
///           parameter is <b>NULL</b>, the topmost cancel object is reset.
///Returns:
///    This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as
///    well as the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The cancel object was successfully set or reset. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> The cancel object
///    cannot be set or reset at this time because of a block on cancel operations. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoSetCancelObject(IUnknown pUnk);

///Requests cancellation of an outbound DCOM method call pending on a specified thread.
///Params:
///    dwThreadId = The identifier of the thread on which the pending DCOM call is to be canceled. If this parameter is 0, the call
///                 is on the current thread.
///    ulTimeout = The number of seconds <b>CoCancelCall</b> waits for the server to complete the outbound call after the client
///                requests cancellation.
///Returns:
///    This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The cancellation request was made. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> There is no cancel object
///    corresponding to the specified thread. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>CO_E_CANCEL_DISABLED</b></dt> </dl> </td> <td width="60%"> Call cancellation is not enabled on the
///    specified thread. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>RPC_E_CALL_COMPLETE</b></dt> </dl> </td> <td
///    width="60%"> The call was completed during the timeout interval. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>RPC_E_CALL_CANCELED</b></dt> </dl> </td> <td width="60%"> The call was already canceled. </td> </tr>
///    </table>
///    
@DllImport("OLE32")
HRESULT CoCancelCall(uint dwThreadId, uint ulTimeout);

///Determines whether the call being executed on the server has been canceled by the client.
///Returns:
///    This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as
///    well as the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>RPC_S_CALLPENDING</b></dt> </dl> </td> <td width="60%"> The call is still pending and has not yet
///    been canceled by the client. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>RPC_E_CALL_CANCELED</b></dt> </dl>
///    </td> <td width="60%"> The call has been canceled by the client. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoTestCancel();

///Enables cancellation of synchronous calls on the calling thread.
///Params:
///    pReserved = This parameter is reserved and must be <b>NULL</b>.
///Returns:
///    This function can return the standard return values S_OK, E_FAIL, E_INVALIDARG, and E_OUTOFMEMORY.
///    
@DllImport("OLE32")
HRESULT CoEnableCallCancellation(void* pReserved);

///Undoes the action of a call to CoEnableCallCancellation. Disables cancellation of synchronous calls on the calling
///thread when all calls to <b>CoEnableCallCancellation</b> are balanced by calls to <b>CoDisableCallCancellation</b>.
///Params:
///    pReserved = This parameter is reserved and must be <b>NULL</b>.
///Returns:
///    This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as
///    well as the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Call cancellation was successfully disabled on the thread.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_CANCEL_DISABLED</b></dt> </dl> </td> <td width="60%"> There
///    have been more successful calls to CoEnableCallCancellation on the thread than there have been calls to
///    CoDisableCallCancellation. Cancellation is still enabled on the thread. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoDisableCallCancellation(void* pReserved);

///Converts a CLSID into a string of printable characters. Different CLSIDs always convert to different strings.
///Params:
///    rclsid = The CLSID to be converted.
///    lplpsz = The address of a pointer variable that receives a pointer to the resulting string. The string that represents
///             <i>rclsid</i> includes enclosing braces.
///Returns:
///    This function can return the standard return values E_OUTOFMEMORY and S_OK.
///    
@DllImport("OLE32")
HRESULT StringFromCLSID(const(GUID)* rclsid, ushort** lplpsz);

///Converts a string generated by the StringFromCLSID function back into the original CLSID.
///Params:
///    lpsz = The string representation of the CLSID.
///    pclsid = A pointer to the CLSID.
///Returns:
///    This function can return the standard return value E_INVALIDARG, as well as the following values. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>NOERROR</b></dt> </dl> </td>
///    <td width="60%"> The CLSID was obtained successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>CO_E_CLASSSTRING</b></dt> </dl> </td> <td width="60%"> The class string was improperly formatted. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_CLASSNOTREG</b></dt> </dl> </td> <td width="60%"> The CLSID
///    corresponding to the class string was not found in the registry. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>REGDB_E_READREGDB</b></dt> </dl> </td> <td width="60%"> The registry could not be opened for reading.
///    </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CLSIDFromString(ushort* lpsz, GUID* pclsid);

///Converts an interface identifier into a string of printable characters.
///Params:
///    rclsid = The interface identifier to be converted.
///    lplpsz = The address of a pointer variable that receives a pointer to the resulting string. The string that represents
///             <i>rclsid</i> includes enclosing braces.
///Returns:
///    This function can return the standard return values E_OUTOFMEMORY and S_OK.
///    
@DllImport("OLE32")
HRESULT StringFromIID(const(GUID)* rclsid, ushort** lplpsz);

///Converts a string generated by the StringFromIID function back into the original interface identifier (IID).
///Params:
///    lpsz = A pointer to the string representation of the IID.
///    lpiid = A pointer to the requested IID on return.
///Returns:
///    This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.
///    
@DllImport("OLE32")
HRESULT IIDFromString(ushort* lpsz, GUID* lpiid);

///Retrieves the ProgID for a given CLSID.
///Params:
///    clsid = The CLSID for which the ProgID is to be requested.
///    lplpszProgID = The address of a pointer variable that receives the ProgID string. The string that represents <i>clsid</i>
///                   includes enclosing braces.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The ProgID was returned successfully.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_CLASSNOTREG</b></dt> </dl> </td> <td width="60%"> Class not
///    registered in the registry. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_READREGDB</b></dt> </dl> </td>
///    <td width="60%"> There was an error reading from the registry. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT ProgIDFromCLSID(const(GUID)* clsid, ushort** lplpszProgID);

///Looks up a CLSID in the registry, given a ProgID.
///Params:
///    lpszProgID = A pointer to the ProgID whose CLSID is requested.
///    lpclsid = Receives a pointer to the retrieved CLSID on return.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The CLSID was retrieved successfully.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_CLASSSTRING</b></dt> </dl> </td> <td width="60%"> The
///    registered CLSID for the ProgID is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>REGDB_E_WRITEREGDB</b></dt> </dl> </td> <td width="60%"> An error occurred writing the CLSID to the
///    registry. See Remarks below. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CLSIDFromProgID(ushort* lpszProgID, GUID* lpclsid);

///Converts a globally unique identifier (GUID) into a string of printable characters.
///Params:
///    rguid = The GUID to be converted.
///    lpsz = A pointer to a caller-allocated string variable to receive the resulting string. The string that represents
///           <i>rguid</i> includes enclosing braces.
///    cchMax = The number of characters available in the <i>lpsz</i> buffer.
///Returns:
///    If the function succeeds, the return value is the number of characters in the returned string, including the null
///    terminator. If the buffer is too small to contain the string, the return value is 0.
///    
@DllImport("OLE32")
int StringFromGUID2(const(GUID)* rguid, char* lpsz, int cchMax);

///Creates a GUID, a unique 128-bit integer used for CLSIDs and interface identifiers.
///Params:
///    pguid = A pointer to the requested GUID.
///Returns:
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
///    </dl> </td> <td width="60%"> The GUID was successfully created. </td> </tr> </table> Errors returned by
///    UuidCreate are wrapped as an <b>HRESULT</b>.
///    
@DllImport("OLE32")
HRESULT CoCreateGuid(GUID* pguid);

///Waits for specified handles to be signaled or for a specified timeout period to elapse.
///Params:
///    dwFlags = The wait options. Possible values are taken from the COWAIT_FLAGS enumeration.
///    dwTimeout = The timeout period, in milliseconds.
///    cHandles = The number of elements in the <i>pHandles</i> array.
///    pHandles = An array of handles.
///    lpdwindex = A pointer to a variable that, when the returned status is S_OK, receives a value indicating the event that caused
///                the function to return. This value is usually the index into <i>pHandles</i> for the handle that was signaled. If
///                <i>pHandles</i> includes one or more handles to mutex objects, a value between WAIT_ABANDONED_0 and
///                (WAIT_ABANDONED_0 + nCount - 1) indicates the index into <i>pHandles</i> for the mutex that was abandoned. If the
///                COWAIT_ALERTABLE flag is set in <i>dwFlags</i>, a value of WAIT_IO_COMPLETION indicates the wait was ended by one
///                or more user-mode asynchronous procedure calls (APC) queued to the thread. See WaitForMultipleObjectsEx for more
///                information.
///Returns:
///    This function can return the following values. <div class="alert"><b>Note</b> The return value of
///    <b>CoWaitForMultipleHandles</b> can be nondeterministic if the COWAIT_ALERTABLE flag is set in <i>dwFlags</i>, or
///    if <i>pHandles</i> includes one or more handles to mutex objects. The recommended workaround is to call
///    SetLastError(ERROR_SUCCESS) before <b>CoWaitForMultipleHandles</b>.</div> <div> </div> <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
///    The required handle or handles were signaled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
///    </dl> </td> <td width="60%"> <i>pHandles</i> was <b>NULL</b>, <i>lpdwindex</i> was <b>NULL</b>, or <i>dwFlags</i>
///    was not a value from the COWAIT_FLAGS enumeration. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>RPC_E_NO_SYNC</b></dt> </dl> </td> <td width="60%"> The value of <i>pHandles</i> was 0. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>RPC_S_CALLPENDING</b></dt> </dl> </td> <td width="60%"> The timeout period elapsed
///    before the required handle or handles were signaled. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoWaitForMultipleHandles(uint dwFlags, uint dwTimeout, uint cHandles, char* pHandles, uint* lpdwindex);

///A replacement for CoWaitForMultipleHandles. This replacement API hides the options for
///<b>CoWaitForMultipleHandles</b> that are not supported in ASTA.
///Params:
///    dwFlags = CWMO_FLAGS flag controlling whether call/window message reentrancy is enabled from this wait. By default, neither
///              COM calls nor window messages are dispatched from <b>CoWaitForMultipleObjects</b> in ASTA.
///    dwTimeout = The timeout in milliseconds of the wait.
///    cHandles = The length of the <i>pHandles</i> array. Must be &lt;= 56.
///    pHandles = An array of handles to waitable kernel objects.
///    lpdwindex = Receives the index of the handle that satisfied the wait.
@DllImport("OLE32")
HRESULT CoWaitForMultipleObjects(uint dwFlags, uint dwTimeout, uint cHandles, char* pHandles, uint* lpdwindex);

///Returns the CLSID of an object that can emulate the specified object.
///Params:
///    clsidOld = The CLSID of the object that can be emulated (treated as) an object with a different CLSID.
///    pClsidNew = A pointer to where the CLSID that can emulate <i>clsidOld</i> objects is retrieved. This parameter cannot be
///                <b>NULL</b>. If there is no emulation information for <i>clsidOld</i> objects, the <i>clsidOld</i> parameter is
///                supplied.
///Returns:
///    This function can return the following values, as well as any error values returned by the CLSIDFromString
///    function. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> A new CLSID was successfully returned. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> There is no emulation information for the
///    <i>clsidOld</i> parameter, so the <i>pClsidNew</i> parameter is set to <i>clsidOld</i>. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>REGDB_E_READREGDB </b></dt> </dl> </td> <td width="60%"> There was an error reading the
///    registry. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoGetTreatAsClass(const(GUID)* clsidOld, GUID* pClsidNew);

///Tells the service control manager to flush any cached RPC binding handles for the specified computer. Only
///administrators may call this function.
///Params:
///    pszMachineName = The computer name for which binding handles should be flushed, or an empty string to signify that all handles in
///                     the cache should be flushed.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Indicates success. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>CO_S_MACHINENAMENOTFOUND</b></dt> </dl> </td> <td width="60%"> Indicates that the
///    specified computer name was not found or that the binding handle cache was empty, indicating that an empty string
///    was passed instead of a specific computer name. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Indicates the caller was not an administrator for
///    this computer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
///    Indicates that a <b>NULL</b> value was passed for <i>pszMachineName</i>. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoInvalidateRemoteMachineBindings(ushort* pszMachineName);

///Allocates a block of task memory in the same way that IMalloc::Alloc does.
///Params:
///    cb = The size of the memory block to be allocated, in bytes.
///Returns:
///    If the function succeeds, it returns the allocated memory block. Otherwise, it returns <b>NULL</b>.
///    
@DllImport("OLE32")
void* CoTaskMemAlloc(size_t cb);

///Changes the size of a previously allocated block of task memory.
///Params:
///    pv = A pointer to the memory block to be reallocated. This parameter can be <b>NULL</b>, as discussed in Remarks.
///    cb = The size of the memory block to be reallocated, in bytes. This parameter can be 0, as discussed in Remarks.
///Returns:
///    If the function succeeds, it returns the reallocated memory block. Otherwise, it returns <b>NULL</b>.
///    
@DllImport("OLE32")
void* CoTaskMemRealloc(void* pv, size_t cb);

///Frees a block of task memory previously allocated through a call to the CoTaskMemAlloc or CoTaskMemRealloc function.
///Params:
///    pv = A pointer to the memory block to be freed. If this parameter is <b>NULL</b>, the function has no effect.
@DllImport("OLE32")
void CoTaskMemFree(void* pv);

///Returns the current time as a FILETIME structure. <div class="alert"><b>Note</b> This function is provided for
///compatibility with 16-bit Windows.</div><div> </div>
///Params:
///    lpFileTime = A pointer to the FILETIME structure that receives the current time.
///Returns:
///    This function returns S_OK to indicate success.
///    
@DllImport("OLE32")
HRESULT CoFileTimeNow(FILETIME* lpFileTime);

///Triggers automatic installation if the COMClassStore policy is enabled. This is analogous to the behavior of
///CoCreateInstance when neither CLSCTX_ENABLE_CODE_DOWNLOAD nor CLSCTX_NO_CODE_DOWNLOAD are specified.
///Params:
///    lpszProgID = A pointer to the ProgID whose CLSID is requested.
///    lpclsid = Receives a pointer to the retrieved CLSID on return.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The CLSID was retrieved successfully.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_CLASSSTRING</b></dt> </dl> </td> <td width="60%"> The
///    registered CLSID for the ProgID is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>REGDB_E_WRITEREGDB</b></dt> </dl> </td> <td width="60%"> An error occurred writing the CLSID to the
///    registry. See Remarks below. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CLSIDFromProgIDEx(ushort* lpszProgID, GUID* lpclsid);

@DllImport("OLE32")
HRESULT CoRegisterDeviceCatalog(const(wchar)* deviceInstanceId, ptrdiff_t* cookie);

@DllImport("OLE32")
HRESULT CoRevokeDeviceCatalog(ptrdiff_t cookie);

@DllImport("OLE32")
uint CLIPFORMAT_UserSize(uint* param0, uint param1, ushort* param2);

@DllImport("OLE32")
ubyte* CLIPFORMAT_UserMarshal(uint* param0, ubyte* param1, ushort* param2);

@DllImport("OLE32")
ubyte* CLIPFORMAT_UserUnmarshal(uint* param0, char* param1, ushort* param2);

@DllImport("OLE32")
void CLIPFORMAT_UserFree(uint* param0, ushort* param1);

@DllImport("OLE32")
uint HBITMAP_UserSize(uint* param0, uint param1, HBITMAP* param2);

@DllImport("OLE32")
ubyte* HBITMAP_UserMarshal(uint* param0, ubyte* param1, HBITMAP* param2);

@DllImport("OLE32")
ubyte* HBITMAP_UserUnmarshal(uint* param0, char* param1, HBITMAP* param2);

@DllImport("OLE32")
void HBITMAP_UserFree(uint* param0, HBITMAP* param1);

@DllImport("OLE32")
uint HDC_UserSize(uint* param0, uint param1, HDC* param2);

@DllImport("OLE32")
ubyte* HDC_UserMarshal(uint* param0, ubyte* param1, HDC* param2);

@DllImport("OLE32")
ubyte* HDC_UserUnmarshal(uint* param0, char* param1, HDC* param2);

@DllImport("OLE32")
void HDC_UserFree(uint* param0, HDC* param1);

@DllImport("OLE32")
uint HICON_UserSize(uint* param0, uint param1, HICON* param2);

@DllImport("OLE32")
ubyte* HICON_UserMarshal(uint* param0, ubyte* param1, HICON* param2);

@DllImport("OLE32")
ubyte* HICON_UserUnmarshal(uint* param0, char* param1, HICON* param2);

@DllImport("OLE32")
void HICON_UserFree(uint* param0, HICON* param1);

@DllImport("ole32")
uint SNB_UserSize(uint* param0, uint param1, ushort*** param2);

@DllImport("ole32")
ubyte* SNB_UserMarshal(uint* param0, ubyte* param1, ushort*** param2);

@DllImport("ole32")
ubyte* SNB_UserUnmarshal(uint* param0, char* param1, ushort*** param2);

@DllImport("ole32")
void SNB_UserFree(uint* param0, ushort*** param1);

@DllImport("OLE32")
uint CLIPFORMAT_UserSize64(uint* param0, uint param1, ushort* param2);

@DllImport("OLE32")
ubyte* CLIPFORMAT_UserMarshal64(uint* param0, ubyte* param1, ushort* param2);

@DllImport("OLE32")
ubyte* CLIPFORMAT_UserUnmarshal64(uint* param0, char* param1, ushort* param2);

@DllImport("OLE32")
void CLIPFORMAT_UserFree64(uint* param0, ushort* param1);

@DllImport("OLE32")
uint HBITMAP_UserSize64(uint* param0, uint param1, HBITMAP* param2);

@DllImport("OLE32")
ubyte* HBITMAP_UserMarshal64(uint* param0, ubyte* param1, HBITMAP* param2);

@DllImport("OLE32")
ubyte* HBITMAP_UserUnmarshal64(uint* param0, char* param1, HBITMAP* param2);

@DllImport("OLE32")
void HBITMAP_UserFree64(uint* param0, HBITMAP* param1);

@DllImport("OLE32")
uint HDC_UserSize64(uint* param0, uint param1, HDC* param2);

@DllImport("OLE32")
ubyte* HDC_UserMarshal64(uint* param0, ubyte* param1, HDC* param2);

@DllImport("OLE32")
ubyte* HDC_UserUnmarshal64(uint* param0, char* param1, HDC* param2);

@DllImport("OLE32")
void HDC_UserFree64(uint* param0, HDC* param1);

@DllImport("OLE32")
uint HICON_UserSize64(uint* param0, uint param1, HICON* param2);

@DllImport("OLE32")
ubyte* HICON_UserMarshal64(uint* param0, ubyte* param1, HICON* param2);

@DllImport("OLE32")
ubyte* HICON_UserUnmarshal64(uint* param0, char* param1, HICON* param2);

@DllImport("OLE32")
void HICON_UserFree64(uint* param0, HICON* param1);

@DllImport("ole32")
uint SNB_UserSize64(uint* param0, uint param1, ushort*** param2);

@DllImport("ole32")
ubyte* SNB_UserMarshal64(uint* param0, ubyte* param1, ushort*** param2);

@DllImport("ole32")
ubyte* SNB_UserUnmarshal64(uint* param0, char* param1, ushort*** param2);

@DllImport("ole32")
void SNB_UserFree64(uint* param0, ushort*** param1);

@DllImport("OLE32")
uint HACCEL_UserSize(uint* param0, uint param1, HACCEL* param2);

@DllImport("OLE32")
ubyte* HACCEL_UserMarshal(uint* param0, ubyte* param1, HACCEL* param2);

@DllImport("OLE32")
ubyte* HACCEL_UserUnmarshal(uint* param0, char* param1, HACCEL* param2);

@DllImport("OLE32")
void HACCEL_UserFree(uint* param0, HACCEL* param1);

@DllImport("OLE32")
uint HGLOBAL_UserSize(uint* param0, uint param1, ptrdiff_t* param2);

@DllImport("OLE32")
ubyte* HGLOBAL_UserMarshal(uint* param0, ubyte* param1, ptrdiff_t* param2);

@DllImport("OLE32")
ubyte* HGLOBAL_UserUnmarshal(uint* param0, char* param1, ptrdiff_t* param2);

@DllImport("OLE32")
void HGLOBAL_UserFree(uint* param0, ptrdiff_t* param1);

@DllImport("OLE32")
uint HMENU_UserSize(uint* param0, uint param1, HMENU* param2);

@DllImport("OLE32")
ubyte* HMENU_UserMarshal(uint* param0, ubyte* param1, HMENU* param2);

@DllImport("OLE32")
ubyte* HMENU_UserUnmarshal(uint* param0, char* param1, HMENU* param2);

@DllImport("OLE32")
void HMENU_UserFree(uint* param0, HMENU* param1);

@DllImport("OLE32")
uint HACCEL_UserSize64(uint* param0, uint param1, HACCEL* param2);

@DllImport("OLE32")
ubyte* HACCEL_UserMarshal64(uint* param0, ubyte* param1, HACCEL* param2);

@DllImport("OLE32")
ubyte* HACCEL_UserUnmarshal64(uint* param0, char* param1, HACCEL* param2);

@DllImport("OLE32")
void HACCEL_UserFree64(uint* param0, HACCEL* param1);

@DllImport("OLE32")
uint HGLOBAL_UserSize64(uint* param0, uint param1, ptrdiff_t* param2);

@DllImport("OLE32")
ubyte* HGLOBAL_UserMarshal64(uint* param0, ubyte* param1, ptrdiff_t* param2);

@DllImport("OLE32")
ubyte* HGLOBAL_UserUnmarshal64(uint* param0, char* param1, ptrdiff_t* param2);

@DllImport("OLE32")
void HGLOBAL_UserFree64(uint* param0, ptrdiff_t* param1);

@DllImport("OLE32")
uint HMENU_UserSize64(uint* param0, uint param1, HMENU* param2);

@DllImport("OLE32")
ubyte* HMENU_UserMarshal64(uint* param0, ubyte* param1, HMENU* param2);

@DllImport("OLE32")
ubyte* HMENU_UserUnmarshal64(uint* param0, char* param1, HMENU* param2);

@DllImport("OLE32")
void HMENU_UserFree64(uint* param0, HMENU* param1);

@DllImport("urlmon")
HRESULT CreateURLMoniker(IMoniker pMkCtx, const(wchar)* szURL, IMoniker* ppmk);

@DllImport("urlmon")
HRESULT CreateURLMonikerEx(IMoniker pMkCtx, const(wchar)* szURL, IMoniker* ppmk, uint dwFlags);

@DllImport("urlmon")
HRESULT GetClassURL(const(wchar)* szURL, GUID* pClsID);

///Creates an asynchronous bind context for use with asynchronous monikers.
///Params:
///    reserved = This parameter is reserved and must be 0.
///    pBSCb = A pointer to the IBindStatusCallback interface used for receiving data availability and progress notification.
///    pEFetc = A pointer to the IEnumFORMATETC interface that can be used to enumerate formats for format negotiation during
///             binding. This parameter can be <b>NULL</b>, in which case the caller is not interested in format negotiation
///             during binding, and the default format of the object will be bound to.
///    ppBC = Address of an IBindCtx* pointer variable that receives the interface pointer to the new bind context.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation completed successfully.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY </b></dt> </dl> </td> <td width="60%"> The method ran
///    out of memory and did not complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
///    </td> <td width="60%"> One or more parameters are invalid. </td> </tr> </table>
///    
@DllImport("urlmon")
HRESULT CreateAsyncBindCtx(uint reserved, IBindStatusCallback pBSCb, IEnumFORMATETC pEFetc, IBindCtx* ppBC);

@DllImport("urlmon")
HRESULT CreateURLMonikerEx2(IMoniker pMkCtx, IUri pUri, IMoniker* ppmk, uint dwFlags);

@DllImport("urlmon")
HRESULT CreateAsyncBindCtxEx(IBindCtx pbc, uint dwOptions, IBindStatusCallback pBSCb, IEnumFORMATETC pEnum, 
                             IBindCtx* ppBC, uint reserved);

@DllImport("urlmon")
HRESULT MkParseDisplayNameEx(IBindCtx pbc, const(wchar)* szDisplayName, uint* pchEaten, IMoniker* ppmk);

@DllImport("urlmon")
HRESULT RegisterBindStatusCallback(IBindCtx pBC, IBindStatusCallback pBSCb, IBindStatusCallback* ppBSCBPrev, 
                                   uint dwReserved);

@DllImport("urlmon")
HRESULT RevokeBindStatusCallback(IBindCtx pBC, IBindStatusCallback pBSCb);

@DllImport("urlmon")
HRESULT GetClassFileOrMime(IBindCtx pBC, const(wchar)* szFilename, char* pBuffer, uint cbSize, 
                           const(wchar)* szMime, uint dwReserved, GUID* pclsid);

@DllImport("urlmon")
HRESULT IsValidURL(IBindCtx pBC, const(wchar)* szURL, uint dwReserved);

@DllImport("urlmon")
HRESULT CoGetClassObjectFromURL(const(GUID)* rCLASSID, const(wchar)* szCODE, uint dwFileVersionMS, 
                                uint dwFileVersionLS, const(wchar)* szTYPE, IBindCtx pBindCtx, uint dwClsContext, 
                                void* pvReserved, const(GUID)* riid, void** ppv);

@DllImport("urlmon")
HRESULT IEInstallScope(uint* pdwScope);

@DllImport("urlmon")
HRESULT FaultInIEFeature(HWND hWnd, uCLSSPEC* pClassSpec, QUERYCONTEXT* pQuery, uint dwFlags);

@DllImport("urlmon")
HRESULT GetComponentIDFromCLSSPEC(uCLSSPEC* pClassspec, byte** ppszComponentID);

@DllImport("urlmon")
HRESULT IsAsyncMoniker(IMoniker pmk);

@DllImport("urlmon")
HRESULT RegisterMediaTypes(uint ctypes, char* rgszTypes, char* rgcfTypes);

@DllImport("urlmon")
HRESULT FindMediaType(const(char)* rgszTypes, ushort* rgcfTypes);

///Creates an object that implements IEnumFORMATETC over a static array of FORMATETC structures.
///Params:
///    cfmtetc = Number of FORMATETC structures in the static array specified by the <i>rgfmtetc</i> parameter. The <i>cfmtetc</i>
///              parameter cannot be zero.
///    rgfmtetc = Pointer to a static array of FORMATETC structures.
///    ppenumfmtetc = Address of IEnumFORMATETC pointer variable that receives the interface pointer to the enumerator object.
///Returns:
///    This function returns S_OK on success. Other possible return values include the following. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG </b></dt> </dl>
///    </td> <td width="60%"> One or more parameters are invalid. </td> </tr> </table>
///    
@DllImport("urlmon")
HRESULT CreateFormatEnumerator(uint cfmtetc, char* rgfmtetc, IEnumFORMATETC* ppenumfmtetc);

@DllImport("urlmon")
HRESULT RegisterFormatEnumerator(IBindCtx pBC, IEnumFORMATETC pEFetc, uint reserved);

@DllImport("urlmon")
HRESULT RevokeFormatEnumerator(IBindCtx pBC, IEnumFORMATETC pEFetc);

@DllImport("urlmon")
HRESULT RegisterMediaTypeClass(IBindCtx pBC, uint ctypes, char* rgszTypes, char* rgclsID, uint reserved);

@DllImport("urlmon")
HRESULT FindMediaTypeClass(IBindCtx pBC, const(char)* szType, GUID* pclsID, uint reserved);

@DllImport("urlmon")
HRESULT UrlMkSetSessionOption(uint dwOption, char* pBuffer, uint dwBufferLength, uint dwReserved);

@DllImport("urlmon")
HRESULT UrlMkGetSessionOption(uint dwOption, char* pBuffer, uint dwBufferLength, uint* pdwBufferLengthOut, 
                              uint dwReserved);

@DllImport("urlmon")
HRESULT FindMimeFromData(IBindCtx pBC, const(wchar)* pwzUrl, char* pBuffer, uint cbSize, 
                         const(wchar)* pwzMimeProposed, uint dwMimeFlags, ushort** ppwzMimeOut, uint dwReserved);

@DllImport("urlmon")
HRESULT ObtainUserAgentString(uint dwOption, const(char)* pszUAOut, uint* cbSize);

@DllImport("urlmon")
HRESULT CompareSecurityIds(char* pbSecurityId1, uint dwLen1, char* pbSecurityId2, uint dwLen2, uint dwReserved);

@DllImport("urlmon")
HRESULT CompatFlagsFromClsid(GUID* pclsid, uint* pdwCompatFlags, uint* pdwMiscStatusFlags);

@DllImport("urlmon")
HRESULT SetAccessForIEAppContainer(HANDLE hObject, IEObjectType ieObjectType, uint dwAccessMask);

@DllImport("URLMON")
HRESULT CreateUri(const(wchar)* pwzURI, uint dwFlags, size_t dwReserved, IUri* ppURI);

@DllImport("URLMON")
HRESULT CreateUriWithFragment(const(wchar)* pwzURI, const(wchar)* pwzFragment, uint dwFlags, size_t dwReserved, 
                              IUri* ppURI);

@DllImport("urlmon")
HRESULT CreateUriFromMultiByteString(const(char)* pszANSIInputUri, uint dwEncodingFlags, uint dwCodePage, 
                                     uint dwCreateFlags, size_t dwReserved, IUri* ppUri);

@DllImport("URLMON")
HRESULT CreateIUriBuilder(IUri pIUri, uint dwFlags, size_t dwReserved, IUriBuilder* ppIUriBuilder);

@DllImport("urlmon")
HRESULT HlinkSimpleNavigateToString(const(wchar)* szTarget, const(wchar)* szLocation, 
                                    const(wchar)* szTargetFrameName, IUnknown pUnk, IBindCtx pbc, 
                                    IBindStatusCallback param5, uint grfHLNF, uint dwReserved);

@DllImport("urlmon")
HRESULT HlinkSimpleNavigateToMoniker(IMoniker pmkTarget, const(wchar)* szLocation, const(wchar)* szTargetFrameName, 
                                     IUnknown pUnk, IBindCtx pbc, IBindStatusCallback param5, uint grfHLNF, 
                                     uint dwReserved);

@DllImport("urlmon")
HRESULT URLOpenStreamA(IUnknown param0, const(char)* param1, uint param2, IBindStatusCallback param3);

@DllImport("urlmon")
HRESULT URLOpenStreamW(IUnknown param0, const(wchar)* param1, uint param2, IBindStatusCallback param3);

@DllImport("urlmon")
HRESULT URLOpenPullStreamA(IUnknown param0, const(char)* param1, uint param2, IBindStatusCallback param3);

@DllImport("urlmon")
HRESULT URLOpenPullStreamW(IUnknown param0, const(wchar)* param1, uint param2, IBindStatusCallback param3);

@DllImport("urlmon")
HRESULT URLDownloadToFileA(IUnknown param0, const(char)* param1, const(char)* param2, uint param3, 
                           IBindStatusCallback param4);

@DllImport("urlmon")
HRESULT URLDownloadToFileW(IUnknown param0, const(wchar)* param1, const(wchar)* param2, uint param3, 
                           IBindStatusCallback param4);

@DllImport("urlmon")
HRESULT URLDownloadToCacheFileA(IUnknown param0, const(char)* param1, const(char)* param2, uint cchFileName, 
                                uint param4, IBindStatusCallback param5);

@DllImport("urlmon")
HRESULT URLDownloadToCacheFileW(IUnknown param0, const(wchar)* param1, const(wchar)* param2, uint cchFileName, 
                                uint param4, IBindStatusCallback param5);

@DllImport("urlmon")
HRESULT URLOpenBlockingStreamA(IUnknown param0, const(char)* param1, IStream* param2, uint param3, 
                               IBindStatusCallback param4);

@DllImport("urlmon")
HRESULT URLOpenBlockingStreamW(IUnknown param0, const(wchar)* param1, IStream* param2, uint param3, 
                               IBindStatusCallback param4);

@DllImport("urlmon")
HRESULT HlinkGoBack(IUnknown pUnk);

@DllImport("urlmon")
HRESULT HlinkGoForward(IUnknown pUnk);

@DllImport("urlmon")
HRESULT HlinkNavigateString(IUnknown pUnk, const(wchar)* szTarget);

@DllImport("urlmon")
HRESULT HlinkNavigateMoniker(IUnknown pUnk, IMoniker pmkTarget);

@DllImport("urlmon")
HRESULT CoInternetParseUrl(const(wchar)* pwzUrl, PARSEACTION ParseAction, uint dwFlags, const(wchar)* pszResult, 
                           uint cchResult, uint* pcchResult, uint dwReserved);

@DllImport("urlmon")
HRESULT CoInternetParseIUri(IUri pIUri, PARSEACTION ParseAction, uint dwFlags, const(wchar)* pwzResult, 
                            uint cchResult, uint* pcchResult, size_t dwReserved);

@DllImport("urlmon")
HRESULT CoInternetCombineUrl(const(wchar)* pwzBaseUrl, const(wchar)* pwzRelativeUrl, uint dwCombineFlags, 
                             const(wchar)* pszResult, uint cchResult, uint* pcchResult, uint dwReserved);

@DllImport("urlmon")
HRESULT CoInternetCombineUrlEx(IUri pBaseUri, const(wchar)* pwzRelativeUrl, uint dwCombineFlags, 
                               IUri* ppCombinedUri, size_t dwReserved);

@DllImport("urlmon")
HRESULT CoInternetCombineIUri(IUri pBaseUri, IUri pRelativeUri, uint dwCombineFlags, IUri* ppCombinedUri, 
                              size_t dwReserved);

@DllImport("urlmon")
HRESULT CoInternetCompareUrl(const(wchar)* pwzUrl1, const(wchar)* pwzUrl2, uint dwFlags);

@DllImport("urlmon")
HRESULT CoInternetGetProtocolFlags(const(wchar)* pwzUrl, uint* pdwFlags, uint dwReserved);

@DllImport("urlmon")
HRESULT CoInternetQueryInfo(const(wchar)* pwzUrl, QUERYOPTION QueryOptions, uint dwQueryFlags, char* pvBuffer, 
                            uint cbBuffer, uint* pcbBuffer, uint dwReserved);

@DllImport("urlmon")
HRESULT CoInternetGetSession(uint dwSessionMode, IInternetSession* ppIInternetSession, uint dwReserved);

@DllImport("urlmon")
HRESULT CoInternetGetSecurityUrl(const(wchar)* pwszUrl, ushort** ppwszSecUrl, PSUACTION psuAction, uint dwReserved);

@DllImport("urlmon")
HRESULT CoInternetGetSecurityUrlEx(IUri pUri, IUri* ppSecUri, PSUACTION psuAction, size_t dwReserved);

@DllImport("urlmon")
HRESULT CoInternetSetFeatureEnabled(INTERNETFEATURELIST FeatureEntry, uint dwFlags, BOOL fEnable);

@DllImport("urlmon")
HRESULT CoInternetIsFeatureEnabled(INTERNETFEATURELIST FeatureEntry, uint dwFlags);

@DllImport("urlmon")
HRESULT CoInternetIsFeatureEnabledForUrl(INTERNETFEATURELIST FeatureEntry, uint dwFlags, const(wchar)* szURL, 
                                         IInternetSecurityManager pSecMgr);

@DllImport("urlmon")
HRESULT CoInternetIsFeatureEnabledForIUri(INTERNETFEATURELIST FeatureEntry, uint dwFlags, IUri pIUri, 
                                          IInternetSecurityManagerEx2 pSecMgr);

@DllImport("urlmon")
HRESULT CoInternetIsFeatureZoneElevationEnabled(const(wchar)* szFromURL, const(wchar)* szToURL, 
                                                IInternetSecurityManager pSecMgr, uint dwFlags);

@DllImport("urlmon")
HRESULT CopyStgMedium(const(STGMEDIUM)* pcstgmedSrc, STGMEDIUM* pstgmedDest);

@DllImport("urlmon")
HRESULT CopyBindInfo(const(BINDINFO)* pcbiSrc, BINDINFO* pbiDest);

@DllImport("urlmon")
void ReleaseBindInfo(BINDINFO* pbindinfo);

@DllImport("urlmon")
ushort* IEGetUserPrivateNamespaceName();

@DllImport("urlmon")
HRESULT CoInternetCreateSecurityManager(IServiceProvider pSP, IInternetSecurityManager* ppSM, uint dwReserved);

@DllImport("urlmon")
HRESULT CoInternetCreateZoneManager(IServiceProvider pSP, IInternetZoneManager* ppZM, uint dwReserved);

@DllImport("urlmon")
HRESULT GetSoftwareUpdateInfo(const(wchar)* szDistUnit, SOFTDISTINFO* psdi);

@DllImport("urlmon")
HRESULT SetSoftwareUpdateAdvertisementState(const(wchar)* szDistUnit, uint dwAdState, uint dwAdvertisedVersionMS, 
                                            uint dwAdvertisedVersionLS);

@DllImport("urlmon")
BOOL IsLoggingEnabledA(const(char)* pszUrl);

@DllImport("urlmon")
BOOL IsLoggingEnabledW(const(wchar)* pwszUrl);

@DllImport("urlmon")
BOOL WriteHitLogging(HIT_LOGGING_INFO* lpLogginginfo);

///Retrieves a pointer to the OLE implementation of IDataAdviseHolder on the data advise holder object.
///Params:
///    ppDAHolder = Address of an IDataAdviseHolder pointer variable that receives the interface pointer to the new advise holder
///                 object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
///    width="60%"> Insufficient memory for the operation. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CreateDataAdviseHolder(IDataAdviseHolder* ppDAHolder);

///This function is obsolete.
@DllImport("ole32")
uint OleBuildVersion();

///Initializes the COM library on the current apartment, identifies the concurrency model as single-thread apartment
///(STA), and enables additional functionality described in the Remarks section below. Applications must initialize the
///COM library before they can call COM library functions other than CoGetMalloc and memory allocation functions.
///Params:
///    pvReserved = This parameter is reserved and must be <b>NULL</b>.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
///    width="60%"> The COM library is already initialized on this apartment. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLE_E_WRONGCOMPOBJ</b></dt> </dl> </td> <td width="60%"> The versions of COMPOBJ.DLL and OLE2.DLL on your
///    machine are incompatible with each other. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>RPC_E_CHANGED_MODE</b></dt> </dl> </td> <td width="60%"> A previous call to CoInitializeEx specified the
///    concurrency model for this apartment as multithread apartment (MTA). This could also mean that a change from
///    neutral threaded apartment to single threaded apartment occurred. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleInitialize(void* pvReserved);

///Closes the COM library on the apartment, releases any class factories, other COM objects, or servers held by the
///apartment, disables RPC on the apartment, and frees any resources the apartment maintains.
@DllImport("OLE32")
void OleUninitialize();

///Determines whether an OLE linked object (rather than an OLE embedded object) can be created from a clipboard data
///object.
///Params:
///    pSrcDataObject = Pointer to the IDataObject interface on the clipboard data object from which the object is to be created.
///Returns:
///    Returns S_OK if the OleCreateLinkFromData function can be used to create the linked object; otherwise S_FALSE.
///    
@DllImport("OLE32")
HRESULT OleQueryLinkFromData(IDataObject pSrcDataObject);

///Checks whether a data object has one of the formats that would allow it to become an embedded object through a call
///to either the OleCreateFromData or OleCreateStaticFromData function.
///Params:
///    pSrcDataObject = Pointer to the IDataObject interface on the data transfer object to be queried.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
///    width="60%"> No formats are present that support either embedded- or static-object creation. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLE_S_STATIC</b></dt> </dl> </td> <td width="60%"> Formats that support static-object
///    creation are present. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleQueryCreateFromData(IDataObject pSrcDataObject);

///Creates an embedded object identified by a CLSID. You use it typically to implement the menu item that allows the end
///user to insert a new object.
///Params:
///    rclsid = CLSID of the embedded object that is to be created.
///    riid = Reference to the identifier of the interface, usually IID_IOleObject (defined in the OLE headers as the interface
///           identifier for IOleObject), through which the caller will communicate with the new object.
///    renderopt = A value from the enumeration OLERENDER, indicating the locally cached drawing capabilities the newly created
///                object is to have. The <b>OLERENDER</b> value chosen affects the possible values for the <i>pFormatEtc</i>
///                parameter.
///    pFormatEtc = Depending on which of the OLERENDER flags is used as the value of renderopt, pointer to one of the FORMATETC
///                 enumeration values. Refer to the <b>OLERENDER</b> enumeration for restrictions. This parameter, along with the
///                 <i>renderopt</i> parameter, specifies what the new object can cache initially.
///    pClientSite = If you want <b>OleCreate</b> to call IOleObject::SetClientSite, pointer to the IOleClientSite interface on the
///                  container. The value may be <b>NULL</b>, in which case you must specifically call
///                  <b>IOleObject::SetClientSite</b> before attempting operations.
///    pStg = Pointer to an instance of the IStorage interface on the storage object. This parameter may not be <b>NULL</b>.
///    ppvObj = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///             *<i>ppvObject</i> contains the requested interface pointer.
///Returns:
///    This function returns S_OK on success and supports the standard return value E_OUTOFMEMORY. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
///    </td> <td width="60%"> Insufficient memory for the operation. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleCreate(const(GUID)* rclsid, const(GUID)* riid, uint renderopt, FORMATETC* pFormatEtc, 
                  IOleClientSite pClientSite, IStorage pStg, void** ppvObj);

///Extends OleCreate functionality by supporting more efficient instantiation of objects in containers requiring caching
///of multiple presentation formats or data, instead of the single format supported by <b>OleCreate</b>.
///Params:
///    rclsid = Identifies the class of the object to create.
///    riid = Reference to the identifier of the interface of the object to return.
///    dwFlags = This value can be 0 or OLECREATE_LEAVERUNNING (0x00000001).
///    renderopt = Value taken from the OLERENDER enumeration.
///    cFormats = When renderopt is OLERENDER_FORMAT, indicates the number of FORMATETC structures in the <i>rgFormatEtc</i> array,
///               which must be at least one. In all other cases, this parameter must be zero.
///    rgAdvf = When renderopt is OLERENDER_FORMAT, points to an array of cFormats DWORD elements, each of which is a combination
///             of values from the ADVF enumeration. Each element of this array is passed in as the <i>advf</i> parameter to a
///             call to either IOleCache::Cache or IDataObject::DAdvise, depending on whether <i>pAdviseSink</i> is <b>NULL</b>
///             or non-<b>NULL</b> (see below). In all other cases, this parameter must be <b>NULL</b>.
///    rgFormatEtc = When renderopt is OLERENDER_FORMAT, points to an array of cFormats FORMATETC structures. When <i>pAdviseSink</i>
///                  is <b>NULL</b>, each element of this array is passed as the <i>pFormatEtc</i> parameter to a call to the object's
///                  IOleCache::Cache. This populates the data and presentation cache managed by the objects in-process handler
///                  (typically the default handler) with presentation or other cacheable data. When <i>pAdviseSink</i> is
///                  non-<b>NULL</b>, each element of this array is passed as the <i>pFormatEtc</i> parameter to a call to
///                  IDataObject::DAdvise. This allows the caller (typically an OLE Container) to do its own caching or processing of
///                  data received from the object. In all other cases, this parameter must be <b>NULL</b>.
///    lpAdviseSink = When <i>renderopt</i> is OLERENDER_FORMAT, may be either a valid IAdviseSink pointer, indicating custom caching
///                   or processing of data advises, or <b>NULL</b>, indicating default caching of data formats. In all other cases,
///                   this parameter must be <b>NULL</b>.
///    rgdwConnection = Location to return the array of <i>dwConnection</i> values returned when the <i>pAdviseSink</i> interface is
///                     registered for each advisory connection using IDataObject::DAdvise, or <b>NULL</b> if the returned advisory
///                     connections are not needed. Must be <b>NULL</b>, if <i>pAdviseSink</i> is <b>NULL</b>.
///    pClientSite = Pointer to the primary interface through which the object will request services from its container. This
///                  parameter may be <b>NULL</b>, in which case it is the caller's responsibility to establish the client site as
///                  soon as possible using IOleObject::SetClientSite.
///    pStg = Pointer to the storage to use for the object and any default data or presentation caching established for it.
///           This parameter may not be <b>NULL</b>.
///    ppvObj = Address of output pointer variable that receives the interface pointer requested in riid. Upon successful return,
///             *<i>ppvObj</i> contains the requested interface pointer on the newly created object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
///    width="60%"> The provided interface identifier is invalid. </td> </tr> </table>
///    
@DllImport("ole32")
HRESULT OleCreateEx(const(GUID)* rclsid, const(GUID)* riid, uint dwFlags, uint renderopt, uint cFormats, 
                    uint* rgAdvf, FORMATETC* rgFormatEtc, IAdviseSink lpAdviseSink, uint* rgdwConnection, 
                    IOleClientSite pClientSite, IStorage pStg, void** ppvObj);

///Creates an embedded object from a data transfer object retrieved either from the clipboard or as part of an OLE
///drag-and-drop operation. It is intended to be used to implement a paste from an OLE drag-and-drop operation.
///Params:
///    pSrcDataObj = Pointer to the IDataObject interface on the data transfer object that holds the data from which the object is
///                  created.
///    riid = Reference to the identifier of the interface the caller later uses to communicate with the new object (usually
///           IID_IOleObject, defined in the OLE headers as the interface identifier for IOleObject).
///    renderopt = Value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval capabilities the
///                newly created object is to have. Additional considerations are described in the following Remarks section.
///    pFormatEtc = Pointer to a value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval
///                 capabilities the newly created object is to have. The <b>OLERENDER</b> value chosen affects the possible values
///                 for the <i>pFormatEtc</i> parameter.
///    pClientSite = Pointer to an instance of IOleClientSite, the primary interface through which the object will request services
///                  from its container. This parameter can be <b>NULL</b>.
///    pStg = Pointer to the IStorage interface on the storage object. This parameter may not be <b>NULL</b>.
///    ppvObj = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///             *<i>ppvObj</i> contains the requested interface pointer on the newly created object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_STATIC</b></dt> </dl> </td> <td
///    width="60%"> Indicates OLE can create only a static object. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>DV_E_FORMATETC</b></dt> </dl> </td> <td width="60%"> No acceptable formats are available for object
///    creation. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleCreateFromData(IDataObject pSrcDataObj, const(GUID)* riid, uint renderopt, FORMATETC* pFormatEtc, 
                          IOleClientSite pClientSite, IStorage pStg, void** ppvObj);

///Extends OleCreateFromData functionality by supporting more efficient instantiation of objects in containers requiring
///caching of multiple formats of presentation or data, instead of the single format supported by
///<b>OleCreateFromData</b>.
///Params:
///    pSrcDataObj = Pointer to the data transfer object holding the new data used to create the new object. (see OleCreateFromData).
///    riid = Reference to the identifier of the interface of the object to return.
///    dwFlags = This parameter can be 0 or OLECREATE_LEAVERUNNING (0x00000001).
///    renderopt = Value taken from the OLERENDER enumeration.
///    cFormats = When <i>renderopt</i> is OLERENDER_FORMAT, indicates the number of FORMATETC structures in the <i>rgFormatEtc</i>
///               array, which must be at least one. In all other cases, this parameter must be zero.
///    rgAdvf = When <i>renderopt</i> is OLERENDER_FORMAT, points to an array of <b>DWORD</b> elements, each of which is a
///             combination of values from the ADVF enumeration. Each element of this array is passed in as the advf parameter to
///             a call to either IOleCache::Cache or IDataObject::DAdvise, depending on whether <i>pAdviseSink</i> is <b>NULL</b>
///             or non-<b>NULL</b> (see below). In all other cases, this parameter must be <b>NULL</b>.
///    rgFormatEtc = When <i>renderopt</i> is OLERENDER_FORMAT, points to an array of FORMATETC structures. When <i>pAdviseSink</i> is
///                  <b>NULL</b>, each element of this array is passed as the <i>pFormatEtc</i> parameter to a call to the object's
///                  IOleCache::Cache. This populates the data and presentation cache managed by the object's in-process handler
///                  (typically the default handler) with presentation or other cacheable data. When <i>pAdviseSink</i> is
///                  non-<b>NULL</b>, each element of this array is passed as the <i>pFormatEtc</i> parameter to a call to
///                  IDataObject::DAdvise. This allows the caller (typically an OLE Container) to do its own caching or processing of
///                  data received from the object.
///    lpAdviseSink = When renderopt is OLERENDER_FORMAT, may be either a valid IAdviseSink pointer, indicating custom caching or
///                   processing of data advises, or <b>NULL</b>, indicating default caching of data formats.
///    rgdwConnection = Location to return the array of dwConnection values returned when the IAdviseSink interface is registered for
///                     each advisory connection using IDataObject::DAdvise, or <b>NULL</b> if the returned advisory connections are not
///                     needed. This parameter must be <b>NULL</b> if <i>pAdviseSink</i> is <b>NULL</b>.
///    pClientSite = Pointer to the primary interface through which the object will request services from its container. This
///                  parameter may be <b>NULL</b>, in which case it is the caller's responsibility to establish the client site as
///                  soon as possible using IOleObject::SetClientSite.
///    pStg = Pointer to the storage to use for the object and any default data or presentation caching established for it.
///    ppvObj = Address of output pointer variable that receives the interface pointer requested in riid. Upon successful return,
///             *<i>ppvObj</i> contains the requested interface pointer on the newly created object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
///    width="60%"> The provided interface identifier is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG </b></dt> </dl> </td> <td width="60%"> One or more parameters are invalid. </td> </tr>
///    </table>
///    
@DllImport("ole32")
HRESULT OleCreateFromDataEx(IDataObject pSrcDataObj, const(GUID)* riid, uint dwFlags, uint renderopt, 
                            uint cFormats, uint* rgAdvf, FORMATETC* rgFormatEtc, IAdviseSink lpAdviseSink, 
                            uint* rgdwConnection, IOleClientSite pClientSite, IStorage pStg, void** ppvObj);

///Creates a linked object from a data transfer object retrieved either from the clipboard or as part of an OLE
///drag-and-drop operation.
///Params:
///    pSrcDataObj = Pointer to the IDataObject interface on the data transfer object from which the linked object is to be created.
///    riid = Reference to the identifier of interface the caller later uses to communicate with the new object (usually
///           IID_IOleObject, defined in the OLE headers as the interface identifier for IOleObject).
///    renderopt = Value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval capabilities the
///                newly created object is to have. Additional considerations are described in the following Remarks section.
///    pFormatEtc = Pointer to a value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval
///                 capabilities the newly created object is to have. The <b>OLERENDER</b> value chosen affects the possible values
///                 for the <i>pFormatEtc</i> parameter.
///    pClientSite = Pointer to an instance of IOleClientSite, the primary interface through which the object will request services
///                  from its container. This parameter can be <b>NULL</b>.
///    pStg = Pointer to the IStorage interface on the storage object. This parameter cannot be <b>NULL</b>.
///    ppvObj = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///             <i>ppvObj</i> contains the requested interface pointer on the newly created object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>CLIPBRD_E_CANT_OPEN</b></dt> </dl> </td>
///    <td width="60%"> Not able to open the clipboard. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLE_E_CANT_GETMONIKER</b></dt> </dl> </td> <td width="60%"> Not able to extract the object's moniker.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_CANT_BINDTOSOURCE</b></dt> </dl> </td> <td width="60%"> Not
///    able to bind to source. Binding is necessary to get the cache's initialization data. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleCreateLinkFromData(IDataObject pSrcDataObj, const(GUID)* riid, uint renderopt, FORMATETC* pFormatEtc, 
                              IOleClientSite pClientSite, IStorage pStg, void** ppvObj);

///Extends OleCreateLinkFromData functionality by supporting more efficient instantiation of objects in containers
///requiring caching of multiple formats of presentations or data, instead of the single format supported by
///<b>OleCreateLinkFromData</b>.
///Params:
///    pSrcDataObj = Pointer to the data object to create a link object from.
///    riid = Reference to the identifier of the interface of the object to return.
///    dwFlags = This parameter can be 0 or OLECREATE_LEAVERUNNING (0x00000001).
///    renderopt = Value taken from the OLERENDER enumeration.
///    cFormats = When <i>renderopt</i> is OLERENDER_FORMAT, indicates the number of FORMATETC structures in the <i>rgFormatEtc</i>
///               array, which must be at least one. In all other cases, this parameter must be zero.
///    rgAdvf = When <i>renderopt</i> is OLERENDER_FORMAT, points to an array of <b>DWORD</b> elements, each of which is a
///             combination of values from the ADVF enumeration. Each element of this array is passed in as the <i>advf</i>
///             parameter to a call to either IOleCache::Cache or IDataObject::DAdvise, depending on whether <i>pAdviseSink</i>
///             is <b>NULL</b> or non-<b>NULL</b> (see below). In all other cases, this parameter must be <b>NULL</b>.
///    rgFormatEtc = When <i>renderopt</i> is OLERENDER_FORMAT, points to an array of FORMATETC structures. When <i>pAdviseSink</i> is
///                  <b>NULL</b>, each element of this array is passed as the <i>pFormatEtc</i> parameter to a call to the object's
///                  IOleCache::Cache. This populates the data and presentation cache managed by the objects in-process handler
///                  (typically the default handler) with presentation or other cacheable data. When <i>pAdviseSink</i> is
///                  non-<b>NULL</b>, each element of this array is passed as the <i>pFormatEtc</i> parameter to a call to
///                  IDataObject::DAdvise. This allows the caller (typically an OLE Container) to do its own caching or processing of
///                  data received from the object.
///    lpAdviseSink = When <i>renderopt</i> is OLERENDER_FORMAT, may be either a valid IAdviseSink pointer, indicating custom caching
///                   or processing of data advises, or <b>NULL</b>, indicating default caching of data formats.
///    rgdwConnection = Location to return the array of <i>dwConnection</i> values returned when the <i>pAdviseSink</i> interface is
///                     registered for each advisory connection using IDataObject::DAdvise, or <b>NULL</b> if the returned advisory
///                     connections are not needed. This parameter must be <b>NULL</b> if <i>pAdviseSink</i> is <b>NULL</b>.
///    pClientSite = Pointer to the primary interface through which the object will request services from its container. This
///                  parameter can be <b>NULL</b>, in which case it is the caller's responsibility to establish the client site as
///                  soon as possible using IOleObject::SetClientSite.
///    pStg = Pointer to the storage to use for the object and any default data or presentation caching established for it.
///    ppvObj = Address of output pointer variable that receives the interface pointer requested in riid. Upon successful return,
///             *<i>ppvObj</i> contains the requested interface pointer on the newly created object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
///    width="60%"> The provided interface identifier is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG </b></dt> </dl> </td> <td width="60%"> One or more parameters are invalid. </td> </tr>
///    </table>
///    
@DllImport("ole32")
HRESULT OleCreateLinkFromDataEx(IDataObject pSrcDataObj, const(GUID)* riid, uint dwFlags, uint renderopt, 
                                uint cFormats, uint* rgAdvf, FORMATETC* rgFormatEtc, IAdviseSink lpAdviseSink, 
                                uint* rgdwConnection, IOleClientSite pClientSite, IStorage pStg, void** ppvObj);

///Creates a static object, that contains only a representation, with no native data, from a data transfer object. <div
///class="alert"><b>Note</b> The OLESTREAM to IStorage conversion functions also convert static objects.</div><div>
///</div>
///Params:
///    pSrcDataObj = Pointer to the IDataObject interface on the data transfer object that holds the data from which the object will
///                  be created.
///    iid = Reference to the identifier of the interface with which the caller is to communicate with the new object (usually
///          IID_IOleObject, defined in the OLE headers as the interface identifier for IOleObject).
///    renderopt = Value from the enumeration OLERENDER indicating the locally cached drawing or data-retrieval capabilities that
///                the container wants in the newly created component. It is an error to pass the render options OLERENDER_NONE or
///                OLERENDER_ASIS to this function.
///    pFormatEtc = Depending on which of the OLERENDER flags is used as the value of <i>renderopt</i>, may be a pointer to one of
///                 the FORMATETC enumeration values. Refer to the <b>OLERENDER</b> enumeration for restrictions.
///    pClientSite = Pointer to an instance of IOleClientSite, the primary interface through which the object will request services
///                  from its container. This parameter can be <b>NULL</b>.
///    pStg = Pointer to the IStorage interface for storage for the object. This parameter cannot be <b>NULL</b>.
///    ppvObj = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///             *<i>ppvObj</i> contains the requested interface pointer on the newly created object.
///Returns:
///    This function returns S_OK on success.
///    
@DllImport("OLE32")
HRESULT OleCreateStaticFromData(IDataObject pSrcDataObj, const(GUID)* iid, uint renderopt, FORMATETC* pFormatEtc, 
                                IOleClientSite pClientSite, IStorage pStg, void** ppvObj);

///Creates an OLE compound-document linked object.
///Params:
///    pmkLinkSrc = Pointer to the IMoniker interface on the moniker that can be used to locate the source of the linked object.
///    riid = Reference to the identifier of the interface the caller later uses to communicate with the new object (usually
///           IID_IOleObject, defined in the OLE headers as the interface identifier for IOleObject).
///    renderopt = Specifies a value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval
///                capabilities the newly created object is to have. Additional considerations are described in the Remarks section
///                below.
///    lpFormatEtc = Pointer to a value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval
///                  capabilities the newly created object is to have. The <b>OLERENDER</b> value chosen affects the possible values
///                  for the <i>lpFormatEtc</i> parameter.
///    pClientSite = Pointer to an instance of IOleClientSite, the primary interface through which the object will request services
///                  from its container. This parameter can be <b>NULL</b>.
///    pStg = Pointer to the IStorage interface on the storage object. This parameter cannot be <b>NULL</b>.
///    ppvObj = Address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful return,
///             *<i>ppvObj</i> contains the requested interface pointer on the newly created object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_CANT_BINDTOSOURCE</b></dt> </dl>
///    </td> <td width="60%"> Not able to bind to source. </td> </tr> </table>
///    
@DllImport("ole32")
HRESULT OleCreateLink(IMoniker pmkLinkSrc, const(GUID)* riid, uint renderopt, FORMATETC* lpFormatEtc, 
                      IOleClientSite pClientSite, IStorage pStg, void** ppvObj);

///Extends <b>OleCreateLink</b> functionality by supporting more efficient instantiation of objects in containers
///requiring caching of multiple formats of presentations or data, instead of the single format supported by
///OleCreateLink.
///Params:
///    pmkLinkSrc = Pointer to a moniker to the object to create a link to.
///    riid = Reference to the identifier of the interface of the object to return.
///    dwFlags = This parameter can be 0 or OLECREATE_LEAVERUNNING (0x00000001).
///    renderopt = Value taken from the OLERENDER enumeration.
///    cFormats = When <i>renderopt</i> is OLERENDER_FORMAT, indicates the number of FORMATETC structures in the <i>rgFormatEtc</i>
///               array, which must be at least one. In all other cases, this parameter must be zero.
///    rgAdvf = When <i>renderopt</i> is OLERENDER_FORMAT, points to an array of <b>DWORD</b> elements, each of which is a
///             combination of values from the ADVF enumeration. Each element of this array is passed in as the <i>advf</i>
///             parameter to a call to either IOleCache::Cache or IDataObject::DAdvise, depending on whether <i>pAdviseSink</i>
///             is <b>NULL</b> or non-<b>NULL</b> (see below). In all other cases, this parameter must be <b>NULL</b>.
///    rgFormatEtc = When <i>renderopt</i> is OLERENDER_FORMAT, points to an array of FORMATETC structures. When <i>pAdviseSink</i> is
///                  <b>NULL</b>, each element of this array is passed as the <i>pFormatEtc</i> parameter to a call to the object's
///                  IOleCache::Cache. This populates the data and presentation cache managed by the objects in-process handler
///                  (typically the default handler) with presentation or other cacheable data. When <i>pAdviseSink</i> is
///                  non-<b>NULL</b>, each element of this array is passed as the <i>pFormatEtc</i> parameter to a call to
///                  IDataObject::DAdvise. This allows the caller (typically an OLE Container) to do its own caching or processing of
///                  data received from the object.
///    lpAdviseSink = When <i>renderopt</i> is OLERENDER_FORMAT, may be either a valid IAdviseSink pointer, indicating custom caching
///                   or processing of data advises, or <b>NULL</b>, indicating default caching of data formats.
///    rgdwConnection = Location to return the array of <i>dwConnection</i> values returned when the IAdviseSink interface is registered
///                     for each advisory connection using IDataObject::DAdvise, or <b>NULL</b> if the returned advisory connections are
///                     not needed. This parameter must be <b>NULL</b> if <i>pAdviseSink</i> is <b>NULL</b>.
///    pClientSite = Pointer to the primary interface through which the object will request services from its container. This
///                  parameter can be <b>NULL</b>, in which case it is the caller's responsibility to establish the client site as
///                  soon as possible using IOleObject::SetClientSite.
///    pStg = Pointer to the storage to use for the object and any default data or presentation caching established for it.
///    ppvObj = Address of output pointer variable that receives the interface pointer requested in riid. Upon successful return,
///             *<i>ppvObj</i> contains the requested interface pointer on the newly created object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
///    width="60%"> The provided interface identifier is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG </b></dt> </dl> </td> <td width="60%"> One or more parameters are invalid. </td> </tr>
///    </table>
///    
@DllImport("ole32")
HRESULT OleCreateLinkEx(IMoniker pmkLinkSrc, const(GUID)* riid, uint dwFlags, uint renderopt, uint cFormats, 
                        uint* rgAdvf, FORMATETC* rgFormatEtc, IAdviseSink lpAdviseSink, uint* rgdwConnection, 
                        IOleClientSite pClientSite, IStorage pStg, void** ppvObj);

///Creates an object that is linked to a file.
///Params:
///    lpszFileName = Pointer to a string naming the source file to be linked to.
///    riid = Reference to the identifier of the interface the caller later uses to communicate with the new object (usually
///           IID_IOleObject, defined in the OLE headers as the interface identifier for IOleObject).
///    renderopt = Value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval capabilities the
///                newly created object is to have. Additional considerations are described in the following Remarks section.
///    lpFormatEtc = Pointer to a value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval
///                  capabilities the newly created object is to have. The <b>OLERENDER</b> value chosen affects the possible values
///                  for the <i>pFormatEtc</i> parameter.
///    pClientSite = Pointer to an instance of IOleClientSite, the primary interface through which the object will request services
///                  from its container. This parameter can be <b>NULL</b>.
///    pStg = Pointer to the IStorage interface on the storage object. This parameter cannot be <b>NULL</b>.
///    ppvObj = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///             *<i>ppvObj</i> contains the requested interface pointer on the newly created object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>STG_E_FILENOTFOUND</b></dt> </dl> </td>
///    <td width="60%"> The file name is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLE_E_CANT_BINDTOSOURCE</b></dt> </dl> </td> <td width="60%"> Not able to bind to source. </td> </tr>
///    </table>
///    
@DllImport("OLE32")
HRESULT OleCreateLinkToFile(ushort* lpszFileName, const(GUID)* riid, uint renderopt, FORMATETC* lpFormatEtc, 
                            IOleClientSite pClientSite, IStorage pStg, void** ppvObj);

///Extends OleCreateLinkToFile functionality by supporting more efficient instantiation of objects in containers
///requiring caching of multiple formats of presentations or data, instead of the single format supported by
///<b>OleCreateLinkToFile</b>.
///Params:
///    lpszFileName = Pointer to the name of the file to create a link to.
///    riid = Reference to the identifier of the interface of the object to return.
///    dwFlags = This parameter can be 0 or OLECREATE_LEAVERUNNING (0x00000001).
///    renderopt = Value taken from the OLERENDER enumeration.
///    cFormats = When <i>renderopt</i> is OLERENDER_FORMAT, indicates the number of FORMATETC structures in the <i>rgFormatEtc</i>
///               array, which must be at least one. In all other cases, this parameter must be zero.
///    rgAdvf = When <i>renderopt</i> is OLERENDER_FORMAT, points to an array of <b>DWORD</b> elements, each of which is a
///             combination of values from the ADVF enumeration. Each element of this array is passed in as the <i>advf</i>
///             parameter to a call to either IOleCache::Cache or IDataObject::DAdvise, depending on whether <i>pAdviseSink</i>
///             is <b>NULL</b> or non-<b>NULL</b> (see below). In all other cases, this parameter must be <b>NULL</b>.
///    rgFormatEtc = When <i>renderopt</i> is OLERENDER_FORMAT, points to an array of FORMATETC structures. When <i>pAdviseSink</i> is
///                  <b>NULL</b>, each element of this array is passed as the <i>pFormatEtc</i> parameter to a call to the object's
///                  IOleCache::Cache. This populates the data and presentation cache managed by the objects in-process handler
///                  (typically the default handler) with presentation or other cacheable data. When <i>pAdviseSink</i> is
///                  non-<b>NULL</b>, each element of this array is passed as the <i>pFormatEtc</i> parameter to a call to
///                  IDataObject::DAdvise. This allows the caller (typically an OLE Container) to do its own caching or processing of
///                  data received from the object.
///    lpAdviseSink = When <i>renderopt</i> is OLERENDER_FORMAT, may be either a valid IAdviseSink pointer, indicating custom caching
///                   or processing of data advises, or <b>NULL</b>, indicating default caching of data formats.
///    rgdwConnection = Location to return the array of <i>dwConnection</i> values returned when the IAdviseSink interface is registered
///                     for each advisory connection using IDataObject::DAdvise, or <b>NULL</b> if the returned advisory connections are
///                     not needed. This parameter must be <b>NULL</b> if <i>pAdviseSink</i> is <b>NULL</b>.
///    pClientSite = Pointer to the primary interface through which the object will request services from its container. This
///                  parameter may be <b>NULL</b>, in which case it is the caller's responsibility to establish the client site as
///                  soon as possible using IOleObject::SetClientSite.
///    pStg = Pointer to the storage to use for the object and any default data or presentation caching established for it.
///    ppvObj = Address of output pointer variable that receives the interface pointer requested in riid. Upon successful return,
///             *<i>ppvObj</i> contains the requested interface pointer on the newly created object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
///    width="60%"> The provided interface identifier is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG </b></dt> </dl> </td> <td width="60%"> One or more parameters are invalid. </td> </tr>
///    </table>
///    
@DllImport("ole32")
HRESULT OleCreateLinkToFileEx(ushort* lpszFileName, const(GUID)* riid, uint dwFlags, uint renderopt, uint cFormats, 
                              uint* rgAdvf, FORMATETC* rgFormatEtc, IAdviseSink lpAdviseSink, uint* rgdwConnection, 
                              IOleClientSite pClientSite, IStorage pStg, void** ppvObj);

///Creates an embedded object from the contents of a named file.
///Params:
///    rclsid = This parameter is reserved and must be CLSID_NULL.
///    lpszFileName = Pointer to a string specifying the full path of the file from which the object should be initialized.
///    riid = Reference to the identifier of the interface the caller later uses to communicate with the new object (usually
///           IID_IOleObject, defined in the OLE headers as the interface ID of IOleObject).
///    renderopt = Value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval capabilities the
///                newly created object is to have. The <b>OLERENDER</b> value chosen affects the possible values for the
///                <i>lpFormatEtc</i> parameter.
///    lpFormatEtc = Depending on which of the OLERENDER flags is used as the value of <i>renderopt</i>, pointer to one of the
///                  FORMATETC enumeration values. Refer also to the <b>OLERENDER</b> enumeration for restrictions.
///    pClientSite = Pointer to an instance of IOleClientSite, the primary interface through which the object will request services
///                  from its container. This parameter can be <b>NULL</b>.
///    pStg = Pointer to the IStorage interface on the storage object. This parameter cannot be <b>NULL</b>.
///    ppvObj = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///             *<i>ppvObj</i> contains the requested interface pointer on the newly created object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>STG_E_FILENOTFOUND </b></dt> </dl> </td>
///    <td width="60%"> File not bound. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_CANT_BINDTOSOURCE</b></dt>
///    </dl> </td> <td width="60%"> Not able to bind to source. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>STG_E_MEDIUMFULL</b></dt> </dl> </td> <td width="60%"> The medium is full. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>DV_E_TYMED</b></dt> </dl> </td> <td width="60%"> Invalid TYMED. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>DV_E_LINDEX</b></dt> </dl> </td> <td width="60%"> Invalid LINDEX. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>DV_E_FORMATETC</b></dt> </dl> </td> <td width="60%"> Invalid FORMATETC structure. </td>
///    </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleCreateFromFile(const(GUID)* rclsid, ushort* lpszFileName, const(GUID)* riid, uint renderopt, 
                          FORMATETC* lpFormatEtc, IOleClientSite pClientSite, IStorage pStg, void** ppvObj);

///Extends OleCreateFromFile functionality by supporting more efficient instantiation of objects in containers requiring
///caching of multiple presentation formats or data, instead of the single format supported by <b>OleCreateFromFile</b>.
///Params:
///    rclsid = This parameter is reserved and must be CLSID_NULL.
///    lpszFileName = Pointer to the name of the file from which the new object should be initialized.
///    riid = Reference to the identifier of the interface of the object to return.
///    dwFlags = This parameter can be 0 or OLECREATE_LEAVERUNNING (0x00000001).
///    renderopt = Value taken from the OLERENDER enumeration.
///    cFormats = When <i>renderopt</i> is OLERENDER_FORMAT, indicates the number of FORMATETC structures in the <i>rgFormatEtc</i>
///               array, which must be at least one. In all other cases, this parameter must be zero.
///    rgAdvf = When <i>renderopt</i> is OLERENDER_FORMAT, points to an array of <b>DWORD</b> elements, each of which is a
///             combination of values from the ADVF enumeration. Each element of this array is passed in as the <i>advf</i>
///             parameter to a call to either IOleCache::Cache or IDataObject::DAdvise, depending on whether <i>pAdviseSink</i>
///             is <b>NULL</b> or non-<b>NULL</b> (see below). In all other cases, this parameter must be <b>NULL</b>.
///    rgFormatEtc = When <i>renderopt</i> is OLERENDER_FORMAT, points to an array of FORMATETC structures. When <i>pAdviseSink</i> is
///                  <b>NULL</b>, each element of this array is passed as the <i>pFormatEtc</i> parameter to a call to the object's
///                  IOleCache::Cache. This populates the data and presentation cache managed by the objects in-process handler
///                  (typically the default handler) with presentation or other cacheable data. When <i>pAdviseSink</i> is
///                  non-<b>NULL</b>, each element of this array is passed as the <i>pFormatEtc</i> parameter to a call to
///                  IDataObject::DAdvise. This allows the caller (typically an OLE Container) to do its own caching or processing of
///                  data received from the object.
///    lpAdviseSink = When <i>renderopt</i> is OLERENDER_FORMAT, may be either a valid IAdviseSink pointer, indicating custom caching
///                   or processing of data advises, or <b>NULL</b>, indicating default caching of data formats.
///    rgdwConnection = Location to return the array of <i>dwConnection</i> values returned when the <i>pAdviseSink</i> interface is
///                     registered for each advisory connection using IDataObject::DAdvise, or <b>NULL</b> if the returned advisory
///                     connections are not needed. This parameter must be <b>NULL</b> if <i>pAdviseSink</i> is <b>NULL</b>.
///    pClientSite = Pointer to the primary interface through which the object will request services from its container. This
///                  parameter may be <b>NULL</b>, in which case it is the caller's responsibility to establish the client site as
///                  soon as possible using IOleObject::SetClientSite.
///    pStg = Pointer to the storage to use for the object and any default data or presentation caching established for it.
///    ppvObj = Address of output pointer variable that receives the interface pointer requested in riid. Upon successful return,
///             *<i>ppvObj</i> contains the requested interface pointer on the newly created object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
///    width="60%"> The provided interface identifier is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG </b></dt> </dl> </td> <td width="60%"> One or more parameters are invalid. </td> </tr>
///    </table>
///    
@DllImport("ole32")
HRESULT OleCreateFromFileEx(const(GUID)* rclsid, ushort* lpszFileName, const(GUID)* riid, uint dwFlags, 
                            uint renderopt, uint cFormats, uint* rgAdvf, FORMATETC* rgFormatEtc, 
                            IAdviseSink lpAdviseSink, uint* rgdwConnection, IOleClientSite pClientSite, 
                            IStorage pStg, void** ppvObj);

///Loads into memory an object nested within a specified storage object.
///Params:
///    pStg = Pointer to the IStorage interface on the storage object from which to load the specified object.
///    riid = Reference to the identifier of the interface that the caller wants to use to communicate with the object after it
///           is loaded.
///    pClientSite = Pointer to the IOleClientSite interface on the client site object being loaded.
///    ppvObj = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///             *<i>ppvObj</i> contains the requested interface pointer on the newly loaded object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
///    width="60%"> The object does not support the specified interface. </td> </tr> </table> Additionally, this
///    function can return any of the error values returned by the IPersistStorage::Load method.
///    
@DllImport("OLE32")
HRESULT OleLoad(IStorage pStg, const(GUID)* riid, IOleClientSite pClientSite, void** ppvObj);

///Saves an object opened in transacted mode into the specified storage object.
///Params:
///    pPS = Pointer to the IPersistStorage interface on the object to be saved.
///    pStg = Pointer to the IStorage interface on the destination storage object to which the object indicated in <i>pPS</i>
///           is to be saved.
///    fSameAsLoad = <b>TRUE</b> indicates that <i>pStg</i> is the same storage object from which the object was loaded or created;
///                  <b>FALSE</b> indicates that <i>pStg</i> was loaded or created from a different storage object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>STGMEDIUM_E_FULL</b></dt> </dl> </td> <td
///    width="60%"> The object could not be saved due to lack of disk space. This function can also return any of the
///    error values returned by the IPersistStorage::Save method. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleSave(IPersistStorage pPS, IStorage pStg, BOOL fSameAsLoad);

///Loads an object from the stream.
///Params:
///    pStm = Pointer to the IStream interface on the stream from which the object is to be loaded.
///    iidInterface = Interface identifier (IID) the caller wants to use to communicate with the object after it is loaded.
///    ppvObj = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///             *<i>ppvObj</i> contains the requested interface pointer on the newly loaded object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
///    width="60%"> Insufficient memory for the operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The object does not support the specified interface.
///    </td> </tr> </table> This function can also return any of the error values returned by the ReadClassStm and
///    CoCreateInstance functions, and the IPersistStream::Load method.
///    
@DllImport("OLE32")
HRESULT OleLoadFromStream(IStream pStm, const(GUID)* iidInterface, void** ppvObj);

///Saves an object with the IPersistStream interface on it to the specified stream.
///Params:
///    pPStm = Pointer to the IPersistStream interface on the object to be saved to the stream. The <i>pPStm</i> parameter
///            cannot be <b>NULL</b>.
///    pStm = Pointer to the IStream interface on the stream in which the object is to be saved.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>STGMEDIUM_E_FULL</b></dt> </dl> </td> <td
///    width="60%"> The object could not be saved due to lack of disk space. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLE_E_BLANK</b></dt> </dl> </td> <td width="60%"> The <i>pPStm</i> parameter is <b>NULL</b>. </td> </tr>
///    </table> This function can also return any of the error values returned by the WriteClassStm function or the
///    IPersistStream::Save method.
///    
@DllImport("OLE32")
HRESULT OleSaveToStream(IPersistStream pPStm, IStream pStm);

///Notifies an object that it is embedded in an OLE container, which ensures that reference counting is done correctly
///for containers that support links to embedded objects.
///Params:
///    pUnknown = Pointer to the IUnknown interface of the object.
///    fContained = <b>TRUE</b> if the object is an embedded object; <b>FALSE</b> otherwise.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
///    width="60%"> Insufficient memory for the operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or more parameters are invalid. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error occurred.
///    </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleSetContainedObject(IUnknown pUnknown, BOOL fContained);

///Increments or decrements an external reference that keeps an object in the running state.
///Params:
///    pUnknown = Pointer to the IUnknown interface on the object that is to be locked or unlocked.
///    fVisible = Whether the object is visible. If <b>TRUE</b>, OLE increments the reference count to hold the object visible and
///               alive regardless of external or internal IUnknown::AddRef and IUnknown::Release operations, registrations, or
///               revocation. If <b>FALSE</b>, OLE releases its hold (decrements the reference count) and the object can be closed.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
///    width="60%"> Insufficient memory for the operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or more parameters are invalid. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error occurred.
///    </td> </tr> </table>
///    
@DllImport("ole32")
HRESULT OleNoteObjectVisible(IUnknown pUnknown, BOOL fVisible);

///Registers the specified window as one that can be the target of an OLE drag-and-drop operation and specifies the
///IDropTarget instance to use for drop operations.
///Params:
///    hwnd = Handle to a window that can be a target for an OLE drag-and-drop operation.
///    pDropTarget = Pointer to the IDropTarget interface on the object that is to be the target of a drag-and-drop operation in a
///                  specified window. This interface is used to communicate OLE drag-and-drop information for that window.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>DRAGDROP_E_INVALIDHWND</b></dt> </dl>
///    </td> <td width="60%"> Invalid handle returned in the hwnd parameter. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>DRAGDROP_E_ALREADYREGISTERED</b></dt> </dl> </td> <td width="60%"> The specified window has already been
///    registered as a drop target. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
///    width="60%"> Insufficient memory for the operation. </td> </tr> </table> <div class="alert"><b>Note</b> If you
///    use CoInitialize or CoInitializeEx instead of OleInitialize to initialize COM, <b>RegisterDragDrop</b> will
///    always return an E_OUTOFMEMORY error.</div> <div> </div>
///    
@DllImport("OLE32")
HRESULT RegisterDragDrop(HWND hwnd, IDropTarget pDropTarget);

///Revokes the registration of the specified application window as a potential target for OLE drag-and-drop operations.
///Params:
///    hwnd = Handle to a window previously registered as a target for an OLE drag-and-drop operation.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>DRAGDROP_E_NOTREGISTERED</b></dt> </dl>
///    </td> <td width="60%"> An attempt was made to revoke a drop target that has not been registered. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>DRAGDROP_E_INVALIDHWND</b></dt> </dl> </td> <td width="60%"> Invalid handle returned
///    in the <i>hwnd</i> parameter. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td>
///    <td width="60%"> There is insufficient memory for the operation. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT RevokeDragDrop(HWND hwnd);

///Carries out an OLE drag and drop operation. <div class="alert"><b>Note</b> You must call OleInitialize before calling
///this function.</div><div> </div>
///Params:
///    pDataObj = Pointer to the IDataObject interface on a data object that contains the data being dragged.
///    pDropSource = Pointer to an implementation of the IDropSource interface, which is used to communicate with the source during
///                  the drag operation.
///    dwOKEffects = Effects the source allows in the OLE drag-and-drop operation. Most significant is whether it permits a move. The
///                  <i>dwOKEffect</i> and <i>pdwEffect</i> parameters obtain values from the DROPEFFECT enumeration. For a list of
///                  values, see <b>DROPEFFECT</b>.
///    pdwEffect = Pointer to a value that indicates how the OLE drag-and-drop operation affected the source data. The
///                <i>pdwEffect</i> parameter is set only if the operation is not canceled.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>DRAGDROP_S_DROP</b></dt> </dl> </td> <td
///    width="60%"> The OLE drag-and-drop operation was successful. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>DRAGDROP_S_CANCEL</b></dt> </dl> </td> <td width="60%"> The OLE drag-and-drop operation was canceled.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNSPEC</b></dt> </dl> </td> <td width="60%"> Unexpected error
///    occurred. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT DoDragDrop(IDataObject pDataObj, IDropSource pDropSource, uint dwOKEffects, uint* pdwEffect);

///Places a pointer to a specific data object onto the clipboard. This makes the data object accessible to the
///OleGetClipboard function.
///Params:
///    pDataObj = Pointer to the IDataObject interface on the data object from which the data to be placed on the clipboard can be
///               obtained. This parameter can be <b>NULL</b>; in which case the clipboard is emptied.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>CLIPBRD_E_CANT_OPEN</b></dt> </dl> </td>
///    <td width="60%"> The OpenClipboard function used within OleSetClipboard failed. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>CLIPBRD_E_CANT_EMPTY</b></dt> </dl> </td> <td width="60%"> The EmptyClipboard function used within
///    OleSetClipboard failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CLIPBRD_E_CANT_CLOSE</b></dt> </dl> </td>
///    <td width="60%"> The CloseClipboard function used within OleSetClipboard failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>CLIPBRD_E_CANT_SET</b></dt> </dl> </td> <td width="60%"> The SetClipboardData function
///    used within OleSetClipboard failed. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleSetClipboard(IDataObject pDataObj);

///Retrieves a data object that you can use to access the contents of the clipboard.
///Params:
///    ppDataObj = Address of IDataObject pointer variable that receives the interface pointer to the clipboard data object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>CLIPBRD_E_CANT_OPEN</b></dt> </dl> </td>
///    <td width="60%"> The OpenClipboard function used within OleFlushClipboard failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>CLIPBRD_E_CANT_CLOSE</b></dt> </dl> </td> <td width="60%"> The CloseClipboard function
///    used within OleFlushClipboard failed. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleGetClipboard(IDataObject* ppDataObj);

///Enables Windows Information Protection enlightened applications to retrieve an IDataObject from the OLE Clipboard
///accompanied by Windows Information Protection information about the data and the source application.This information
///allows the enlightened application to take over responsibility for applying Windows Information Protection policy,
///including flying any appropriate UI prompts, and auditing cases where the user explicitly approves copying enterprise
///data into a personal context. If the calling application is not enlightened, or is configured as "unallowed" to
///access enterprise data, then this call behaves exactly like OleGetClipboard - applying policy before deciding what
///IDataObject to return, and supplying empty strings as output.
///Params:
///    dataObject = Address of IDataObject pointer variable that receives the interface pointer to the clipboard data object.
///    dataEnterpriseId = The enterprise id of the application that set the clipboard data. If the data is personal, this will be an empty
///                       string.
///    sourceDescription = The description of the application that set the clipboard.
///    targetDescription = The description of the caller's application to be used in auditing.
///    dataDescription = The description of the data object to be used in auditing.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>CLIPBRD_E_CANT_OPEN</b></dt> </dl> </td>
///    <td width="60%"> The OpenClipboard function used within OleFlushClipboard failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>CLIPBRD_E_CANT_CLOSE</b></dt> </dl> </td> <td width="60%"> The CloseClipboard function
///    used within OleFlushClipboard failed. </td> </tr> </table>
///    
@DllImport("ole32")
HRESULT OleGetClipboardWithEnterpriseInfo(IDataObject* dataObject, ushort** dataEnterpriseId, 
                                          ushort** sourceDescription, ushort** targetDescription, 
                                          ushort** dataDescription);

///Carries out the clipboard shutdown sequence. It also releases the IDataObject pointer that was placed on the
///clipboard by the OleSetClipboard function.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>CLIPBRD_E_CANT_OPEN</b></dt> </dl> </td>
///    <td width="60%"> The Windows OpenClipboard function used within OleFlushClipboard failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>CLIPBRD_E_CANT_CLOSE</b></dt> </dl> </td> <td width="60%"> The Windows CloseClipboard
///    function used within OleFlushClipboard failed. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleFlushClipboard();

///Determines whether the data object pointer previously placed on the clipboard by the OleSetClipboard function is
///still on the clipboard.
///Params:
///    pDataObj = Pointer to the IDataObject interface on the data object containing clipboard data of interest, which the caller
///               previously placed on the clipboard.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
///    width="60%"> The specified pointer is not on the clipboard. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleIsCurrentClipboard(IDataObject pDataObj);

///Creates and returns an OLE menu descriptor (that is, an OLE-provided data structure that describes the menus) for OLE
///to use when dispatching menu messages and commands.
///Params:
///    hmenuCombined = Handle to the combined menu created by the object.
///    lpMenuWidths = Pointer to an array of six <b>LONG</b> values giving the number of menus in each group.
///Returns:
///    Returns the handle to the descriptor, or <b>NULL</b> if insufficient memory is available.
///    
@DllImport("OLE32")
ptrdiff_t OleCreateMenuDescriptor(HMENU hmenuCombined, OleMenuGroupWidths* lpMenuWidths);

///Installs or removes OLE dispatching code from the container's frame window.
///Params:
///    holemenu = Handle to the composite menu descriptor returned by the OleCreateMenuDescriptor function. If <b>NULL</b>, the
///               dispatching code is unhooked.
///    hwndFrame = Handle to the container's frame window where the in-place composite menu is to be installed.
///    hwndActiveObject = Handle to the object's in-place activation window. OLE dispatches menu messages and commands to this window.
///    lpFrame = Pointer to the IOleInPlaceFrame interface on the container's frame window.
///    lpActiveObj = Pointer to the IOleInPlaceActiveObject interface on the active in-place object.
///Returns:
///    This function returns S_OK on success.
///    
@DllImport("OLE32")
HRESULT OleSetMenuDescriptor(ptrdiff_t holemenu, HWND hwndFrame, HWND hwndActiveObject, IOleInPlaceFrame lpFrame, 
                             IOleInPlaceActiveObject lpActiveObj);

///Called by the container to free the shared menu descriptor allocated by the OleCreateMenuDescriptor function.
///Params:
///    holemenu = Handle to the shared menu descriptor that was returned by the OleCreateMenuDescriptor function.
///Returns:
///    This function does not return a value.
///    
@DllImport("OLE32")
HRESULT OleDestroyMenuDescriptor(ptrdiff_t holemenu);

///Called by the object application, allows an object's container to translate accelerators according to the container's
///accelerator table.
///Params:
///    lpFrame = Pointer to the IOleInPlaceFrame interface to which the keystroke might be sent.
///    lpFrameInfo = Pointer to an OLEINPLACEFRAMEINFO structure containing the accelerator table obtained from the container.
///    lpmsg = Pointer to an MSG structure containing the keystroke.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
///    width="60%"> The object should continue processing this message. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleTranslateAccelerator(IOleInPlaceFrame lpFrame, OIFI* lpFrameInfo, MSG* lpmsg);

///Duplicates the data found in the specified handle and returns a handle to the duplicated data. The source data is in
///a clipboard format. Use this function to help implement some of the data transfer interfaces such as IDataObject.
///Params:
///    hSrc = Handle of the source data.
///    cfFormat = Clipboard format of the source data.
///    uiFlags = Flags to be used to allocate global memory for the copied data. These flags are passed to GlobalAlloc. If the
///              value of <i>uiFlags</i> is <b>NULL</b>, GMEM_MOVEABLE is used as a default flag.
///Returns:
///    On success the HANDLE to the source data is returned; on failure a <b>NULL</b> value is returned.
///    
@DllImport("OLE32")
HANDLE OleDuplicateData(HANDLE hSrc, ushort cfFormat, uint uiFlags);

///Enables drawing objects more easily. You can use it instead of calling IViewObject::Draw directly.
///Params:
///    pUnknown = Pointer to the IUnknown interface on the view object that is to be drawn.
///    dwAspect = How the object is to be represented. Representations include content, an icon, a thumbnail, or a printed
///               document. Possible values are taken from the DVASPECT enumeration.
///    hdcDraw = Device context on which to draw. Cannot be a metafile device context.
///    lprcBounds = Pointer to a RECT structure specifying the rectangle in which the object should be drawn. This parameter is
///                 converted to a RECTL structure and passed to IViewObject::Draw.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_BLANK</b></dt> </dl> </td> <td
///    width="60%"> No data to draw from. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td
///    width="60%"> The draw operation was aborted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VIEW_E_DRAW</b></dt>
///    </dl> </td> <td width="60%"> No data to draw from. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLE_E_INVALIDRECT</b></dt> </dl> </td> <td width="60%"> The rectangle is invalid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_INVALIDARG </b></dt> </dl> </td> <td width="60%"> One or more parameters are invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient
///    memory for the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_NOIVIEWOBJECT</b></dt> </dl> </td>
///    <td width="60%"> The object doesn't support the IViewObject interface. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleDraw(IUnknown pUnknown, uint dwAspect, HDC hdcDraw, RECT* lprcBounds);

///Puts an OLE compound document object into the running state.
///Params:
///    pUnknown = Pointer to the IUnknown interface on the object, with which it will query for a pointer to the IRunnableObject
///               interface, and then call its Run method.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_CLASSDIFF</b></dt> </dl> </td> <td
///    width="60%"> The source of an OLE link has been converted to a different class. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleRun(IUnknown pUnknown);

///Determines whether a compound document object is currently in the running state.
///Params:
///    pObject = Pointer to the IOleObject interface on the object of interest.
///Returns:
///    The return value is <b>TRUE</b> if the object is running; otherwise, it is <b>FALSE</b>.
///    
@DllImport("OLE32")
BOOL OleIsRunning(IOleObject pObject);

///Locks an already running object into its running state or unlocks it from its running state.
///Params:
///    pUnknown = Pointer to the IUnknown interface on the object, which the function uses to query for a pointer to
///               IRunnableObject.
///    fLock = <b>TRUE</b> locks the object into its running state. <b>FALSE</b> unlocks the object from its running state.
///    fLastUnlockCloses = <b>TRUE</b> specifies that if the connection being released is the last external lock on the object, the object
///                        should close. <b>FALSE</b> specifies that the object should remain open until closed by the user or another
///                        process.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
///    width="60%"> Insufficient memory for the operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or more parameters are invalid. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error occurred.
///    </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleLockRunning(IUnknown pUnknown, BOOL fLock, BOOL fLastUnlockCloses);

///Frees the specified storage medium.
///Params:
///    LPSTGMEDIUM = Pointer to the storage medium that is to be freed.
@DllImport("OLE32")
void ReleaseStgMedium(STGMEDIUM* param0);

///Creates an advise holder object for managing compound document notifications. It returns a pointer to the object's
///OLE implementation of the IOleAdviseHolder interface.
///Params:
///    ppOAHolder = Address of IOleAdviseHolder pointer variable that receives the interface pointer to the new advise holder object.
///Returns:
///    This function returns S_OK on success and supports the standard return value E_OUTOFMEMORY.
///    
@DllImport("OLE32")
HRESULT CreateOleAdviseHolder(IOleAdviseHolder* ppOAHolder);

///Creates a new instance of the default embedding handler. This instance is initialized so it creates a local server
///when the embedded object enters the running state.
///Params:
///    clsid = CLSID identifying the OLE server to be loaded when the embedded object enters the running state.
///    pUnkOuter = Pointer to the controlling IUnknown interface if the handler is to be aggregated; <b>NULL</b> if it is not to be
///                aggregated.
///    riid = Reference to the identifier of the interface, usually IID_IOleObject, through which the caller will communicate
///           with the handler.
///    lplpObj = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///              *<i>ppvObj</i> contains the requested interface pointer on the newly created handler.
///Returns:
///    This function returns NOERROR on success and supports the standard return value E_OUTOFMEMORY.
///    
@DllImport("ole32")
HRESULT OleCreateDefaultHandler(const(GUID)* clsid, IUnknown pUnkOuter, const(GUID)* riid, void** lplpObj);

///Creates an OLE embedding helper object using application-supplied code aggregated with pieces of the OLE default
///object handler. This helper object can be created and used in a specific context and role, as determined by the
///caller.
///Params:
///    clsid = CLSID of the class to be helped.
///    pUnkOuter = If the embedding helper is to be aggregated, pointer to the outer object's controlling IUnknown interface. If it
///                is not to be aggregated, although this is rare, the value should be <b>NULL</b>.
///    flags = DWORD containing flags that specify the role and creation context for the embedding helper. For legal values, see
///            the following Remarks section.
///    pCF = Pointer to the IClassFactory interface on the class object the function uses to create the secondary object. In
///          some situations, this value may be <b>NULL</b>. For more information, see the following Remarks section.
///    riid = Reference to the identifier of the interface desired by the caller.
///    lplpObj = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///              *<i>ppvObj</i> contains the requested interface pointer on the newly created embedding helper.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
///    width="60%"> Insufficient memory for the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG
///    </b></dt> </dl> </td> <td width="60%"> One or more parameters are invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The provided interface identifier is
///    invalid. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleCreateEmbeddingHelper(const(GUID)* clsid, IUnknown pUnkOuter, uint flags, IClassFactory pCF, 
                                 const(GUID)* riid, void** lplpObj);

///Determines whether the specified keystroke maps to an accelerator in the specified accelerator table.
///Params:
///    hAccel = A handle to the accelerator table.
///    cAccelEntries = The number of entries in the accelerator table.
///    lpMsg = A pointer to the keystroke message to be translated.
///    lpwCmd = A pointer to a variable to receive the corresponding command identifier if there is an accelerator for the
///             keystroke. This parameter may be <b>NULL</b>.
///Returns:
///    If the message is for the object application, the return value is <b>TRUE</b>. If the message is not for the
///    object and should be forwarded to the container, the return value is <b>FALSE</b>.
///    
@DllImport("OLE32")
BOOL IsAccelerator(HACCEL hAccel, int cAccelEntries, MSG* lpMsg, ushort* lpwCmd);

///Returns a handle to a metafile containing an icon and string label for the specified file name.
///Params:
///    lpszPath = A pointer to a file for which the icon and string are to be requested.
///    fUseFileAsLabel = Indicates whether to use the file name as the icon label.
///Returns:
///    If the function succeeds, the return value is a handle to a metafile that contains and icon and label for the
///    specified file. If there is no CLSID in the registration database for the file, then the function returns the
///    string "Document". If <i>lpszPath</i> is <b>NULL</b>, the function returns <b>NULL</b>.
///    
@DllImport("ole32")
ptrdiff_t OleGetIconOfFile(ushort* lpszPath, BOOL fUseFileAsLabel);

///Returns a handle to a metafile containing an icon and a string label for the specified CLSID.
///Params:
///    rclsid = The CLSID for which the icon and string are to be requested.
///    lpszLabel = A pointer to the label for the icon.
///    fUseTypeAsLabel = Indicates whether to use the user type string in the CLSID as the icon label.
///Returns:
///    If the function succeeds, the return value is a handle to a metafile that contains and icon and label for the
///    specified CLSID. Otherwise, the function returns <b>NULL</b>.
///    
@DllImport("OLE32")
ptrdiff_t OleGetIconOfClass(const(GUID)* rclsid, ushort* lpszLabel, BOOL fUseTypeAsLabel);

///Creates a metafile in which the specified icon and label are drawn.
///Params:
///    hIcon = Handle to the icon that is to be drawn into the metafile. This parameter can be <b>NULL</b>. If <i>hIcon</i> is
///            <b>NULL</b>, this function returns <b>NULL</b> without creating a metafile.
///    lpszLabel = The icon label. This parameter can be <b>NULL</b>. If <i>lpszLabel</i> is <b>NULL</b>, the resulting metafile
///                will not include a label.
///    lpszSourceFile = The path and file name of the icon file. This string can be obtained through the user interface or from the
///                     registration database. This parameter can be <b>NULL</b>.
///    iIconIndex = The location of the icon within the file named by <i>lpszSourceFile</i>, expressed as an offset in bytes from the
///                 beginning of file.
///Returns:
///    A global handle to a METAFILEPICT structure containing the icon and label. The metafile uses the MM_ANISOTROPIC
///    mapping mode. If an error occurs, the returned handle is <b>NULL</b>. In this case, the caller can call
///    GetLastError to obtain further information.
///    
@DllImport("ole32")
ptrdiff_t OleMetafilePictFromIconAndLabel(HICON hIcon, ushort* lpszLabel, ushort* lpszSourceFile, uint iIconIndex);

///Gets the user type of the specified class from the registry. Developers of custom DLL object applications use this
///function to emulate the behavior of the OLE default handler.
///Params:
///    clsid = The CLSID of the class for which the user type is to be requested.
///    dwFormOfType = The form of the user-presentable string. Possible values are taken from the enumeration USERCLASSTYPE.
///    pszUserType = A pointer to a string that receives the user type.
///Returns:
///    This function can return the standard return value E_OUTOFMEMORY, as well as the following values. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> The user type was returned successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>REGDB_E_CLASSNOTREG</b></dt> </dl> </td> <td width="60%"> No CLSID is registered for the class object.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_READREGDB</b></dt> </dl> </td> <td width="60%"> There was
///    an error reading from the registry. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_REGDB_KEY</b></dt> </dl>
///    </td> <td width="60%"> The <b>ProgID</b> = <i>MainUserTypeName</i> and <b>CLSID</b> = <i>MainUserTypeName</i>
///    keys are missing from the registry. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleRegGetUserType(const(GUID)* clsid, uint dwFormOfType, ushort** pszUserType);

///Returns miscellaneous information about the presentation and behaviors supported by the specified CLSID from the
///registry. This function is used by developers of custom DLL object applications to emulate the behavior of the OLE
///default handler.
///Params:
///    clsid = The CLSID of the class for which status information is to be requested.
///    dwAspect = The presentation aspect of the class for which information is requested. Possible values are taken from the
///               DVASPECT enumeration.
///    pdwStatus = A pointer to the variable that receives the status information.
///Returns:
///    This function can return the standard return value E_OUTOFMEMORY, as well as the following values. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> The status information was returned successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>REGDB_E_CLASSNOTREG</b></dt> </dl> </td> <td width="60%"> No CLSID is registered for the class object.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_READREGDB</b></dt> </dl> </td> <td width="60%"> There was
///    an error reading from the registry. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_REGDB_KEY</b></dt> </dl>
///    </td> <td width="60%"> The <b>GetMiscStatus</b> key is missing from the registry. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleRegGetMiscStatus(const(GUID)* clsid, uint dwAspect, uint* pdwStatus);

///Creates an enumeration object that can be used to enumerate data formats that an OLE object server has registered in
///the system registry. An object application or object handler calls this function when it must enumerate those
///formats. Developers of custom DLL object applications use this function to emulate the behavior of the default object
///handler.
///Params:
///    clsid = CLSID of the class whose formats are being requested.
///    dwDirection = Indicates whether to enumerate formats that can be passed to IDataObject::GetData or formats that can be passed
///                  to IDataObject::SetData. Possible values are taken from the enumeration DATADIR.
///    ppenum = Address of IEnumFORMATETC pointer variable that receives the interface pointer to the enumeration object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
///    width="60%"> Insufficient memory for the operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>REGDB_E_CLASSNOTREG</b></dt> </dl> </td> <td width="60%"> There is no CLSID registered for the class
///    object. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_READREGDB</b></dt> </dl> </td> <td width="60%">
///    There was an error reading the registry. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_REGDB_KEY</b></dt>
///    </dl> </td> <td width="60%"> The DataFormats/GetSet key is missing from the registry. </td> </tr> </table>
///    
@DllImport("ole32")
HRESULT OleRegEnumFormatEtc(const(GUID)* clsid, uint dwDirection, IEnumFORMATETC* ppenum);

///Supplies an enumeration of the registered verbs for the specified class. Developers of custom DLL object applications
///use this function to emulate the behavior of the default object handler.
///Params:
///    clsid = Class identifier whose verbs are being requested.
///    ppenum = Address of IEnumOLEVERB* pointer variable that receives the interface pointer to the new enumeration object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEOBJ_E_NOVERBS</b></dt> </dl> </td> <td
///    width="60%"> No verbs are registered for the class. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>REGDB_E_CLASSNOTREG</b></dt> </dl> </td> <td width="60%"> No CLSID is registered for the class object.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_READREGDB</b></dt> </dl> </td> <td width="60%"> An error
///    occurred reading the registry. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_REGDB_KEY</b></dt> </dl> </td>
///    <td width="60%"> The DataFormats/GetSet key is missing from the registry. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleRegEnumVerbs(const(GUID)* clsid, IEnumOLEVERB* ppenum);

///Automatically converts an object to a new class if automatic conversion for that object class is set in the registry.
///Params:
///    pStg = A pointer to the IStorage interface on the storage object to be converted.
///    pClsidNew = A pointer to the new CLSID for the object being converted. If there was no automatic conversion, this may be the
///                same as the original class.
///Returns:
///    This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> No conversion is needed or a conversion was successfully
///    completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_KEYMISSING</b></dt> </dl> </td> <td width="60%">
///    The function cannot read a key from the registry. </td> </tr> </table> This function can also return any of the
///    error values returned by the OleGetAutoConvert function. When accessing storage and stream objects, see the
///    IStorage::OpenStorage and IStorage::OpenStream methods for possible errors. When it is not possible to determine
///    the existing CLSID or when it is not possible to update the storage object with new information, see the IStream
///    interface for other error return values.
///    
@DllImport("ole32")
HRESULT OleDoAutoConvert(IStorage pStg, GUID* pClsidNew);

///Determines whether the registry is set for objects of a specified CLSID to be automatically converted to another
///CLSID, and if so, retrieves the new CLSID.
///Params:
///    clsidOld = The CLSID for the object.
///    pClsidNew = A pointer to a variable to receive the new CLSID, if any. If auto-conversion for <i>clsidOld</i> is not set in
///                the registry, <i>clsidOld</i> is returned. The <i>pClsidNew</i> parameter is never <b>NULL</b>.
///Returns:
///    This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> A value was successfully returned through the <i>pclsidNew</i>
///    parameter. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_CLASSNOTREG</b></dt> </dl> </td> <td
///    width="60%"> The CLSID is not properly registered in the registry. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>REGDB_E_READREGDB</b></dt> </dl> </td> <td width="60%"> Error reading from the registry. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>REGDB_E_KEYMISSING</b></dt> </dl> </td> <td width="60%"> Auto-convert is not active
///    or there was no registry entry for the <i>clsidOld</i> parameter. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT OleGetAutoConvert(const(GUID)* clsidOld, GUID* pClsidNew);

///Specifies a CLSID for automatic conversion to a different class when an object of that class is loaded.
///Params:
///    clsidOld = The CLSID of the object class to be converted.
///    clsidNew = The CLSID of the object class that should replace <i>clsidOld</i>. This new CLSID replaces any existing
///               auto-conversion information in the registry for <i>clsidOld</i>. If this value is CLSID_NULL, any existing
///               auto-conversion information for <i>clsidOld</i> is removed from the registry.
///Returns:
///    This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The object was tagged successfully. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>REGDB_E_CLASSNOTREG</b></dt> </dl> </td> <td width="60%"> The CLSID is not properly
///    registered in the registry. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_READREGDB</b></dt> </dl> </td>
///    <td width="60%"> Error reading from the registry. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>REGDB_E_WRITEREGDB</b></dt> </dl> </td> <td width="60%"> Error writing to the registry. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>REGDB_E_KEYMISSING</b></dt> </dl> </td> <td width="60%"> Cannot read a key from the
///    registry. </td> </tr> </table>
///    
@DllImport("ole32")
HRESULT OleSetAutoConvert(const(GUID)* clsidOld, const(GUID)* clsidNew);

@DllImport("OLE32")
uint HPALETTE_UserSize(uint* param0, uint param1, HPALETTE* param2);

@DllImport("OLE32")
ubyte* HPALETTE_UserMarshal(uint* param0, ubyte* param1, HPALETTE* param2);

@DllImport("OLE32")
ubyte* HPALETTE_UserUnmarshal(uint* param0, char* param1, HPALETTE* param2);

@DllImport("OLE32")
void HPALETTE_UserFree(uint* param0, HPALETTE* param1);

@DllImport("OLE32")
uint HRGN_UserSize(uint* param0, uint param1, HRGN* param2);

@DllImport("OLE32")
ubyte* HRGN_UserMarshal(uint* param0, ubyte* param1, HRGN* param2);

@DllImport("OLE32")
ubyte* HRGN_UserUnmarshal(uint* param0, char* param1, HRGN* param2);

@DllImport("OLE32")
void HRGN_UserFree(uint* param0, HRGN* param1);

@DllImport("OLE32")
uint HPALETTE_UserSize64(uint* param0, uint param1, HPALETTE* param2);

@DllImport("OLE32")
ubyte* HPALETTE_UserMarshal64(uint* param0, ubyte* param1, HPALETTE* param2);

@DllImport("OLE32")
ubyte* HPALETTE_UserUnmarshal64(uint* param0, char* param1, HPALETTE* param2);

@DllImport("OLE32")
void HPALETTE_UserFree64(uint* param0, HPALETTE* param1);

///Invokes a new property frame, that is, a property sheet dialog box, whose parent is <i>hwndOwner</i>, where the
///dialog is positioned at the point (x,y) in the parent window and has the caption <i>lpszCaption</i>.
///Params:
///    hwndOwner = Handle to the parent window of the resulting property sheet dialog box.
///    x = Reserved. Horizontal position for the dialog box relative to <i>hwndOwner</i>.
///    y = Reserved. Vertical position for the dialog box relative to <i>hwndOwner</i>.
///    lpszCaption = Pointer to the string used for the caption of the dialog box.
///    cObjects = Number of object pointers passed in <i>ppUnk</i>.
///    ppUnk = An array of IUnknown pointers on the objects for which this property sheet is being invoked. The number of
///            elements in the array is specified by <i>cObjects</i>. These pointers are passed to each property page through
///            IPropertyPage::SetObjects.
///    cPages = Number of property pages specified in <i>pPageCIsID</i>.
///    pPageClsID = Array of size <i>cPages</i> containing the CLSIDs of each property page to display in the property sheet.
///    lcid = Locale identifier to use for the property sheet. Property pages can retrieve this identifier through
///           IPropertyPageSite::GetLocaleID.
///    dwReserved = Reserved for future use; must be zero.
///    pvReserved = Reserved for future use; must be <b>NULL</b>.
///Returns:
///    This function supports the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
///    following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The dialog box was invoked and operated successfully. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in
///    <i>lpszCaption</i>, <i>ppUnk</i>, or <i>pPageCIsID</i> is not valid. For example, any one of them may be
///    <b>NULL</b>. </td> </tr> </table>
///    
@DllImport("OLEAUT32")
HRESULT OleCreatePropertyFrame(HWND hwndOwner, uint x, uint y, ushort* lpszCaption, uint cObjects, IUnknown* ppUnk, 
                               uint cPages, GUID* pPageClsID, uint lcid, uint dwReserved, void* pvReserved);

///Creates a property frame, that is, a property sheet dialog box, based on a structure (OCPFIPARAMS) that contains the
///parameters, rather than specifying separate parameters as when calling OleCreatePropertyFrame.
///Params:
///    lpParams = Pointer to the caller-allocated structure containing the creation parameters for the dialog box.
///Returns:
///    This function supports the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
///    following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The dialog box was invoked and operated successfully. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in
///    <i>lpParams</i> is not valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
///    
@DllImport("OLEAUT32")
HRESULT OleCreatePropertyFrameIndirect(OCPFIPARAMS* lpParams);

///Converts an <b>OLE_COLOR</b> type to a <b>COLORREF</b>.
///Params:
///    clr = The OLE color to be converted into a <b>COLORREF</b>.
///    hpal = Palette used as a basis for the conversion.
///    lpcolorref = Pointer to the caller's variable that receives the converted <b>COLORREF</b> result. This parameter can be
///                 <b>NULL</b>, indicating that the caller wants only to verify that a converted color exists.
///Returns:
///    This function supports the standard return values E_INVALIDARG and E_UNEXPECTED, as well as the following value.
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
///    </dl> </td> <td width="60%"> The color was translated successfully. </td> </tr> </table>
///    
@DllImport("OLEAUT32")
HRESULT OleTranslateColor(uint clr, HPALETTE hpal, uint* lpcolorref);

///Creates and initializes a standard font object using an initial description of the font's properties in a FONTDESC
///structure. The function returns an interface pointer to the new font object specified by caller in the riid
///parameter. A QueryInterface call is part of this call. The caller is responsible for calling Release through the
///interface pointer returned.
///Params:
///    lpFontDesc = Address of a caller-allocated, FONTDESC structure containing the initial state of the font. This value must not
///                 be <b>NULL</b>.
///    riid = Reference to the identifier of the interface describing the type of interface pointer to return in
///           <i>lplpvObj</i>.
///    lplpvObj = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, this
///               parameter contains the requested interface pointer on the newly created font object. If successful, the caller is
///               responsible to call Release through this interface pointer when the new object is no longer needed. If
///               unsuccessful, the value of is set to <b>NULL</b>.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
///    width="60%"> The provided interface identifier is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory for the
///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG </b></dt> </dl> </td> <td width="60%"> One
///    or more parameters are invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
///    width="60%"> The address in <i>pFontDesc</i> or <i>ppvObj</i> is not valid. Note that if <i>pFontDesc</i> is set
///    to <b>NULL</b>, the function returns NO_ERROR. </td> </tr> </table>
///    
@DllImport("OLEAUT32")
HRESULT OleCreateFontIndirect(FONTDESC* lpFontDesc, const(GUID)* riid, void** lplpvObj);

///Creates a new picture object initialized according to a PICTDESC structure.
///Params:
///    lpPictDesc = Pointer to a caller-allocated structure containing the initial state of the picture. The specified structure can
///                 be <b>NULL</b> to create an uninitialized object, in the event the picture needs to initialize via
///                 IPersistStream::Load.
///    riid = Reference to the identifier of the interface describing the type of interface pointer to return in
///           <i>lplpvObj</i>.
///    fOwn = If <b>TRUE</b>, the picture object is to destroy its picture when the object is destroyed. If <b>FALSE</b>, the
///           caller is responsible for destroying the picture.
///    lplpvObj = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, this
///               parameter contains the requested interface pointer on the newly created object. If the call is successful, the
///               caller is responsible for calling Release through this interface pointer when the new object is no longer needed.
///               If the call fails, the value is set to <b>NULL</b>.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
///    width="60%"> The object does not support the interface specified in riid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in <i>pPictDesc</i> or <i>lplpvObj</i> is not
///    valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
///    
@DllImport("OLEAUT32")
HRESULT OleCreatePictureIndirect(PICTDESC* lpPictDesc, const(GUID)* riid, BOOL fOwn, void** lplpvObj);

///Creates a new picture object and initializes it from the contents of a stream. This is equivalent to calling
///OleCreatePictureIndirect with <b>NULL</b> as the first parameter, followed by a call to IPersistStream::Load.
///Params:
///    lpstream = Pointer to the stream that contains the picture's data.
///    lSize = The number of bytes that should be read from the stream, or zero if the entire stream should be read.
///    fRunmode = The opposite of the initial value of the KeepOriginalFormat property. If <b>TRUE</b>, KeepOriginalFormat is set
///               to <b>FALSE</b> and vice-versa.
///    riid = Reference to the identifier of the interface describing the type of interface pointer to return in <i>ppvObj</i>.
///    lplpvObj = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///               *<i>ppvObj</i> contains the requested interface pointer on the storage of the object identified by the moniker.
///               If *<i>ppvObj</i> is non-<b>NULL</b>, this function calls IUnknown::AddRef on the interface; it is the caller's
///               responsibility to call IUnknown::Release. If an error occurs, *<i>ppvObj</i> is set to <b>NULL</b>.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
///    width="60%"> The object does not support the specified interface. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The stream is not valid. For example, it may be
///    <b>NULL</b>. </td> </tr> </table>
///    
@DllImport("OLEAUT32")
HRESULT OleLoadPicture(IStream lpstream, int lSize, BOOL fRunmode, const(GUID)* riid, void** lplpvObj);

///Creates a new picture object and initializes it from the contents of a stream. This is equivalent to calling
///OleCreatePictureIndirect with <b>NULL</b> as the first parameter, followed by a call to IPersistStream::Load.
///Params:
///    lpstream = Pointer to the stream that contains the picture's data.
///    lSize = The number of bytes that should be read from the stream, or zero if the entire stream should be read.
///    fRunmode = The opposite of the initial value of the KeepOriginalFormat property. If <b>TRUE</b>, KeepOriginalFormat is set
///               to <b>FALSE</b> and vice versa.
///    riid = Reference to the identifier of the interface describing the type of interface pointer to return in <i>ppvObj</i>.
///    xSizeDesired = Desired width of icon or cursor. Valid values are 16, 32, and 48. Pass LP_DEFAULT to both size parameters to use
///                   system default size.
///    ySizeDesired = Desired height of icon or cursor. Valid values are 16, 32, and 48. Pass LP_DEFAULT to both size parameters to use
///                   system default size.
///    dwFlags = Desired color depth for icon or cursor. Values are LP_MONOCHROME (monochrome), LP_VGACOLOR (16 colors), LP_COLOR
///              (256 colors), or LP_DEFAULT (selects best depth for current display).
///    lplpvObj = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///               *<i>ppvObj</i> contains the requested interface pointer on the storage of the object identified by the moniker.
///               If *<i>ppvObj</i> is non-<b>NULL</b>, this function calls IUnknown::AddRef on the interface; it is the caller's
///               responsibility to call IUnknown::Release. If an error occurs, *<i>ppvObj</i> is set to <b>NULL</b>.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
///    width="60%"> The object does not support the interface specified in riid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in <i>pPictDesc</i> or <i>ppvObj</i> is not
///    valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
///    
@DllImport("OLEAUT32")
HRESULT OleLoadPictureEx(IStream lpstream, int lSize, BOOL fRunmode, const(GUID)* riid, uint xSizeDesired, 
                         uint ySizeDesired, uint dwFlags, void** lplpvObj);

///Creates a new picture object and initializes it from the contents of a stream. This is equivalent to calling
///OleCreatePictureIndirect(NULL, ...) followed by IPersistStream::Load.
///Params:
///    szURLorPath = The path or URL to the file you want to open.
///    punkCaller = Points to IUnknown for COM aggregation.
///    dwReserved = Reserved.
///    clrReserved = The color you want to reserve to be transparent.
///    riid = Reference to the identifier of the interface describing the type of interface pointer to return in ppvRet.
///    ppvRet = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///             *<i>ppvRet</i> contains the requested interface pointer on the storage of the object identified by the moniker.
///             If *<i>ppvRet</i> is non-<b>NULL</b>, this function calls IUnknown::AddRef on the interface; it is the caller's
///             responsibility to call IUnknown::Release. If an error occurs, *<i>ppvRet</i> is set to <b>NULL</b>.
///Returns:
///    This function supports the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following:
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
///    </dl> </td> <td width="60%"> The dialog box was created successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unable to load picture stream. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in <i>ppvRet</i> is
///    <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%">
///    The object does not support the interface specified in <i>riid</i>. </td> </tr> </table>
///    
@DllImport("OLEAUT32")
HRESULT OleLoadPicturePath(ushort* szURLorPath, IUnknown punkCaller, uint dwReserved, uint clrReserved, 
                           const(GUID)* riid, void** ppvRet);

///Converts an icon to a cursor.
///Params:
///    hinstExe = This parameter is ignored.
///    hIcon = A handle to the icon to be converted.
///Returns:
///    The function returns a handle to the new cursor object. The caller is responsible for deleting this cursor with
///    the DestroyCursor function. If the conversion could not be completed, the return value is <b>NULL</b>.
///    
@DllImport("OLEAUT32")
HCURSOR OleIconToCursor(HINSTANCE hinstExe, HICON hIcon);

///Adds the <b>Verb</b> menu for the specified object to the specified menu.
///Params:
///    lpOleObj = Pointer to the IOleObject interface on the selected object. If this is <b>NULL</b>, then a default disabled menu
///               item is created.
///    lpszShortType = Pointer to the short name defined in the registry (AuxName==2) for the object identified with <i>lpOleObj</i>. If
///                    the string is not known, then <b>NULL</b> may be passed. If <b>NULL</b> is passed, IOleObject::GetUserType is
///                    called to retrieve it. If the caller has easy access to the string, it is faster to pass it in.
///    hMenu = Handle to the menu in which to make modifications.
///    uPos = Position of the menu item.
///    uIDVerbMin = The identifier value at which to start the verbs.
///    uIDVerbMax = The maximum identifier value to be used for object verbs. If <i>uIDVerbMax</i> is 0, then no maximum identifier
///                 value is used.
///    bAddConvert = Indicates whether to add a <b>Convert</b> item to the bottom of the menu (preceded by a separator).
///    idConvert = The identifier value to use for the <b>Convert</b> menu item, if <i>bAddConvert</i> is <b>TRUE</b>.
///    lphMenu = An <b>HMENU</b> pointer to the cascading verb menu if it's created. If there is only one verb, this will be
///              filled with <b>NULL</b>.
///Returns:
///    This function returns <b>TRUE</b> if <i>lpOleObj</i> was valid and at least one verb was added to the menu. A
///    <b>FALSE</b> return indicates that <i>lpOleObj</i> was <b>NULL</b> and a disabled default menu item was created.
///    
@DllImport("oledlg")
BOOL OleUIAddVerbMenuW(IOleObject lpOleObj, const(wchar)* lpszShortType, HMENU hMenu, uint uPos, uint uIDVerbMin, 
                       uint uIDVerbMax, BOOL bAddConvert, uint idConvert, HMENU* lphMenu);

///Adds the <b>Verb</b> menu for the specified object to the specified menu.
///Params:
///    lpOleObj = Pointer to the IOleObject interface on the selected object. If this is <b>NULL</b>, then a default disabled menu
///               item is created.
///    lpszShortType = Pointer to the short name defined in the registry (AuxName==2) for the object identified with <i>lpOleObj</i>. If
///                    the string is not known, then <b>NULL</b> may be passed. If <b>NULL</b> is passed, IOleObject::GetUserType is
///                    called to retrieve it. If the caller has easy access to the string, it is faster to pass it in.
///    hMenu = Handle to the menu in which to make modifications.
///    uPos = Position of the menu item.
///    uIDVerbMin = The identifier value at which to start the verbs.
///    uIDVerbMax = The maximum identifier value to be used for object verbs. If <i>uIDVerbMax</i> is 0, then no maximum identifier
///                 value is used.
///    bAddConvert = Indicates whether to add a <b>Convert</b> item to the bottom of the menu (preceded by a separator).
///    idConvert = The identifier value to use for the <b>Convert</b> menu item, if <i>bAddConvert</i> is <b>TRUE</b>.
///    lphMenu = An <b>HMENU</b> pointer to the cascading verb menu if it's created. If there is only one verb, this will be
///              filled with <b>NULL</b>.
///Returns:
///    This function returns <b>TRUE</b> if <i>lpOleObj</i> was valid and at least one verb was added to the menu. A
///    <b>FALSE</b> return indicates that <i>lpOleObj</i> was <b>NULL</b> and a disabled default menu item was created.
///    
@DllImport("oledlg")
BOOL OleUIAddVerbMenuA(IOleObject lpOleObj, const(char)* lpszShortType, HMENU hMenu, uint uPos, uint uIDVerbMin, 
                       uint uIDVerbMax, BOOL bAddConvert, uint idConvert, HMENU* lphMenu);

///Invokes the standard <b>Insert Object</b> dialog box, which allows the user to select an object source and class
///name, as well as the option of displaying the object as itself or as an icon.
///Params:
///    Arg1 = Pointer to the in-out OLEUIINSERTOBJECT structure for this dialog box.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the OK button.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No error, same
///    as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td width="60%"> The
///    user pressed the Cancel button. </td> </tr> </table> Standard Field Validation Errors <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td>
///    <td width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to
///    OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard messages in order to display error
///    messages to the user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td>
///    <td width="60%"> The pointer to an OLEUIXXX structure passed into the function was <b>NULL</b>. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient
///    permissions for read or write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the
///    dialog box template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl>
///    </td> <td width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString for localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX </b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_IOERR_LPSZFILEINVALID </b></dt> </dl> </td> <td width="60%">
///    The <b>lpszFile</b> value is invalid or user has insufficient write access permissions.This <b>lpszFile</b>
///    member points to the name of the file linked to or inserted. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_IOERR_PPVOBJINVALID</b></dt> </dl> </td> <td width="60%"> The <i>ppvOjb</i> value is invalid. This
///    member points to the location where the pointer for the object is returned. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>OLEUI_IOERR_LPIOLECLIENTSITEINVALID</b></dt> </dl> </td> <td width="60%"> The <b>lpIOleClientSite</b>
///    value is invalid. This member points to the client site for the object. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_IOERR_LPISTORAGEINVALID</b></dt> </dl> </td> <td width="60%"> The <b>lpIStorage</b> value is
///    invalid. This member points to the storage to be used for the object. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_IOERR_SCODEHASERROR</b></dt> </dl> </td> <td width="60%"> The <b>sc</b> member of <i>lpIO</i> has
///    additional error information. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_IOERR_LPCLSIDEXCLUDEINVALID</b></dt> </dl> </td> <td width="60%"> The <b>lpClsidExclude</b> value is
///    invalid. This member contains the list of CLSIDs to exclude. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_IOERR_CCHFILEINVALID</b></dt> </dl> </td> <td width="60%"> The <b>cchFile</b> or <b>lpszFile</b>
///    value is invalid. The <b>cchFile</b> member specifies the size of the <b>lpszFile</b> buffer. The <b>lpszFile</b>
///    member points to the name of the file linked to or inserted. </td> </tr> </table>
///    
@DllImport("oledlg")
uint OleUIInsertObjectW(OLEUIINSERTOBJECTW* param0);

///Invokes the standard <b>Insert Object</b> dialog box, which allows the user to select an object source and class
///name, as well as the option of displaying the object as itself or as an icon.
///Params:
///    Arg1 = Pointer to the in-out OLEUIINSERTOBJECT structure for this dialog box.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the OK button.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No error, same
///    as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td width="60%"> The
///    user pressed the Cancel button. </td> </tr> </table> Standard Field Validation Errors <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td>
///    <td width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to
///    OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard messages in order to display error
///    messages to the user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td>
///    <td width="60%"> The pointer to an OLEUIXXX structure passed into the function was <b>NULL</b>. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient
///    permissions for read or write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the
///    dialog box template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl>
///    </td> <td width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString for localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX </b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_IOERR_LPSZFILEINVALID </b></dt> </dl> </td> <td width="60%">
///    The <b>lpszFile</b> value is invalid or user has insufficient write access permissions.This <b>lpszFile</b>
///    member points to the name of the file linked to or inserted. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_IOERR_PPVOBJINVALID</b></dt> </dl> </td> <td width="60%"> The <i>ppvOjb</i> value is invalid. This
///    member points to the location where the pointer for the object is returned. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>OLEUI_IOERR_LPIOLECLIENTSITEINVALID</b></dt> </dl> </td> <td width="60%"> The <b>lpIOleClientSite</b>
///    value is invalid. This member points to the client site for the object. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_IOERR_LPISTORAGEINVALID</b></dt> </dl> </td> <td width="60%"> The <b>lpIStorage</b> value is
///    invalid. This member points to the storage to be used for the object. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_IOERR_SCODEHASERROR</b></dt> </dl> </td> <td width="60%"> The <b>sc</b> member of <i>lpIO</i> has
///    additional error information. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_IOERR_LPCLSIDEXCLUDEINVALID</b></dt> </dl> </td> <td width="60%"> The <b>lpClsidExclude</b> value is
///    invalid. This member contains the list of CLSIDs to exclude. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_IOERR_CCHFILEINVALID</b></dt> </dl> </td> <td width="60%"> The <b>cchFile</b> or <b>lpszFile</b>
///    value is invalid. The <b>cchFile</b> member specifies the size of the <b>lpszFile</b> buffer. The <b>lpszFile</b>
///    member points to the name of the file linked to or inserted. </td> </tr> </table>
///    
@DllImport("oledlg")
uint OleUIInsertObjectA(OLEUIINSERTOBJECTA* param0);

///Invokes the standard <b>Paste Special</b> dialog box, allowing the user to select the format of the clipboard object
///to be pasted or paste-linked.
///Params:
///    Arg1 = A pointer to an OLEUIPASTESPECIAL structure.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the OK button.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No error, same
///    as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td width="60%"> The
///    user pressed the Cancel button. </td> </tr> </table> Standard Field Validation Errors <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td>
///    <td width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to
///    OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard messages in order to display error
///    messages to the user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td>
///    <td width="60%"> The pointer to an OLEUIXXX structure passed into the function was <b>NULL</b>. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient
///    permissions for read or write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the
///    dialog box template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl>
///    </td> <td width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString to get localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_IOERR_SRCDATAOBJECTINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <b>lpSrcDataObject</b> member of OLEUIPASTESPECIAL is invalid. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>OLEUI_IOERR_ARRPASTEENTRIESINVALID </b></dt> </dl> </td> <td width="60%"> The <b>arrPasteEntries</b>
///    member of OLEUIPASTESPECIAL is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_IOERR_ARRLINKTYPESINVALID</b></dt> </dl> </td> <td width="60%"> The <b>arrLinkTypes</b> member of
///    OLEUIPASTESPECIAL is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_PSERR_CLIPBOARDCHANGED</b></dt>
///    </dl> </td> <td width="60%"> The clipboard contents changed while the dialog box was displayed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_PSERR_GETCLIPBOAARDFAILED </b></dt> </dl> </td> <td width="60%"> The
///    <b>lpSrcDataObj</b> member is incorrect. </td> </tr> </table>
///    
@DllImport("oledlg")
uint OleUIPasteSpecialW(OLEUIPASTESPECIALW* param0);

///Invokes the standard <b>Paste Special</b> dialog box, allowing the user to select the format of the clipboard object
///to be pasted or paste-linked.
///Params:
///    Arg1 = A pointer to an OLEUIPASTESPECIAL structure.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the OK button.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No error, same
///    as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td width="60%"> The
///    user pressed the Cancel button. </td> </tr> </table> Standard Field Validation Errors <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td>
///    <td width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to
///    OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard messages in order to display error
///    messages to the user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td>
///    <td width="60%"> The pointer to an OLEUIXXX structure passed into the function was <b>NULL</b>. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient
///    permissions for read or write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the
///    dialog box template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl>
///    </td> <td width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString to get localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_IOERR_SRCDATAOBJECTINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <b>lpSrcDataObject</b> member of OLEUIPASTESPECIAL is invalid. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>OLEUI_IOERR_ARRPASTEENTRIESINVALID </b></dt> </dl> </td> <td width="60%"> The <b>arrPasteEntries</b>
///    member of OLEUIPASTESPECIAL is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_IOERR_ARRLINKTYPESINVALID</b></dt> </dl> </td> <td width="60%"> The <b>arrLinkTypes</b> member of
///    OLEUIPASTESPECIAL is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_PSERR_CLIPBOARDCHANGED</b></dt>
///    </dl> </td> <td width="60%"> The clipboard contents changed while the dialog box was displayed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_PSERR_GETCLIPBOAARDFAILED </b></dt> </dl> </td> <td width="60%"> The
///    <b>lpSrcDataObj</b> member is incorrect. </td> </tr> </table>
///    
@DllImport("oledlg")
uint OleUIPasteSpecialA(OLEUIPASTESPECIALA* param0);

///Invokes the standard <b>Links</b> dialog box, allowing the user to make modifications to a container's linked
///objects.
///Params:
///    Arg1 = Pointer to an OLEUIEDITLINKS structure that contains information used to initialize the dialog box.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the OK button.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No error, same
///    as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td width="60%"> The
///    user pressed the Cancel button. </td> </tr> </table> Standard Field Validation Errors <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td>
///    <td width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to
///    OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard messages in order to display error
///    messages to the user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td>
///    <td width="60%"> The pointer to an OLEUIXXX structure passed into the function was <b>NULL</b>. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient
///    permissions for read or write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the
///    dialog box template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl>
///    </td> <td width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString for localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> </table>
///    
@DllImport("oledlg")
uint OleUIEditLinksW(OLEUIEDITLINKSW* param0);

///Invokes the standard <b>Links</b> dialog box, allowing the user to make modifications to a container's linked
///objects.
///Params:
///    Arg1 = Pointer to an OLEUIEDITLINKS structure that contains information used to initialize the dialog box.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the OK button.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No error, same
///    as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td width="60%"> The
///    user pressed the Cancel button. </td> </tr> </table> Standard Field Validation Errors <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td>
///    <td width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to
///    OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard messages in order to display error
///    messages to the user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td>
///    <td width="60%"> The pointer to an OLEUIXXX structure passed into the function was <b>NULL</b>. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient
///    permissions for read or write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the
///    dialog box template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl>
///    </td> <td width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString for localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> </table>
///    
@DllImport("oledlg")
uint OleUIEditLinksA(OLEUIEDITLINKSA* param0);

///Invokes the standard <b>Change Icon</b> dialog box, which allows the user to select an icon from an icon file,
///executable, or DLL.
///Params:
///    Arg1 = Pointer to the In/Out [OLEUICHANGEICON](./nf-oledlg-oleuichangeicona.md) structure for this dialog box.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the OK button.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No error, same
///    as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td width="60%"> The
///    user pressed the Cancel button. </td> </tr> </table> Standard Field Validation Errors <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td>
///    <td width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to
///    OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard messages in order to display error
///    messages to the user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td>
///    <td width="60%"> The pointer to an OLEUIXXX structure passed into the function was <b>NULL</b>. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient
///    permissions for read or write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the
///    dialog box template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl>
///    </td> <td width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString for localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CIERR_MUSTHAVECLSID</b></dt> </dl> </td> <td width="60%"> The
///    <b>clsid</b> member was not the current CLSID. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_CIERR_MUSTHAVECURRENTMETAFILE</b></dt> </dl> </td> <td width="60%"> The <b>hMetaPict</b> member was
///    not the current metafile. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CIERR_SZICONEXEINVALID</b></dt>
///    </dl> </td> <td width="60%"> The <i>szIconExe</i> value was invalid. </td> </tr> </table>
///    
@DllImport("oledlg")
uint OleUIChangeIconW(OLEUICHANGEICONW* param0);

///Invokes the standard <b>Change Icon</b> dialog box, which allows the user to select an icon from an icon file,
///executable, or DLL.
///Params:
///    Arg1 = Pointer to the In/Out [OLEUICHANGEICON]() structure for this dialog box.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the OK button.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No error, same
///    as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td width="60%"> The
///    user pressed the Cancel button. </td> </tr> </table> Standard Field Validation Errors <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td>
///    <td width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to
///    OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard messages in order to display error
///    messages to the user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td>
///    <td width="60%"> The pointer to an OLEUIXXX structure passed into the function was <b>NULL</b>. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient
///    permissions for read or write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the
///    dialog box template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl>
///    </td> <td width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString for localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CIERR_MUSTHAVECLSID</b></dt> </dl> </td> <td width="60%"> The
///    <b>clsid</b> member was not the current CLSID. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_CIERR_MUSTHAVECURRENTMETAFILE</b></dt> </dl> </td> <td width="60%"> The <b>hMetaPict</b> member was
///    not the current metafile. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CIERR_SZICONEXEINVALID</b></dt>
///    </dl> </td> <td width="60%"> The <i>szIconExe</i> value was invalid. </td> </tr> </table>
///    
@DllImport("oledlg")
uint OleUIChangeIconA(OLEUICHANGEICONA* param0);

///Invokes the standard <b>Convert</b> dialog box, allowing the user to change the type of a single specified object, or
///the type of all OLE objects of the specified object's class.
///Params:
///    Arg1 = Pointer to an OLEUICONVERT structure that contains information used to initialize the dialog box.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the OK button.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No error, same
///    as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td width="60%"> The
///    user pressed the Cancel button. </td> </tr> </table> Standard Field Validation Errors <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td>
///    <td width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to
///    OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard messages in order to display error
///    messages to the user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td>
///    <td width="60%"> The pointer to an OLEUIXXX structure passed into the function was <b>NULL</b>. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient
///    permissions for read or write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the
///    dialog box template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl>
///    </td> <td width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString for localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CTERR_CLASSIDINVALID</b></dt> </dl> </td> <td width="60%"> A
///    <b>clsid</b> value was invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_CTERR_DVASPECTINVALID</b></dt> </dl> </td> <td width="60%"> The <b>dvAspect</b> value was invalid.
///    This member specifies the aspect of the object. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_CTERR_CBFORMATINVALID</b></dt> </dl> </td> <td width="60%"> The <b>wFormat</b> value was invalid.
///    This member specifies the data format of the object. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_CTERR_STRINGINVALID</b></dt> </dl> </td> <td width="60%"> A string value (for example,
///    <b>lpszUserType</b> or <b>lpszDefLabel</b>) was invalid. </td> </tr> </table>
///    
@DllImport("oledlg")
uint OleUIConvertW(OLEUICONVERTW* param0);

///Invokes the standard <b>Convert</b> dialog box, allowing the user to change the type of a single specified object, or
///the type of all OLE objects of the specified object's class.
///Params:
///    Arg1 = Pointer to an OLEUICONVERT structure that contains information used to initialize the dialog box.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the OK button.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No error, same
///    as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td width="60%"> The
///    user pressed the Cancel button. </td> </tr> </table> Standard Field Validation Errors <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td>
///    <td width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to
///    OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard messages in order to display error
///    messages to the user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td>
///    <td width="60%"> The pointer to an OLEUIXXX structure passed into the function was <b>NULL</b>. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient
///    permissions for read or write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the
///    dialog box template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl>
///    </td> <td width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString for localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CTERR_CLASSIDINVALID</b></dt> </dl> </td> <td width="60%"> A
///    <b>clsid</b> value was invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_CTERR_DVASPECTINVALID</b></dt> </dl> </td> <td width="60%"> The <b>dvAspect</b> value was invalid.
///    This member specifies the aspect of the object. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_CTERR_CBFORMATINVALID</b></dt> </dl> </td> <td width="60%"> The <b>wFormat</b> value was invalid.
///    This member specifies the data format of the object. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_CTERR_STRINGINVALID</b></dt> </dl> </td> <td width="60%"> A string value (for example,
///    <b>lpszUserType</b> or <b>lpszDefLabel</b>) was invalid. </td> </tr> </table>
///    
@DllImport("oledlg")
uint OleUIConvertA(OLEUICONVERTA* param0);

///Determines if there are any OLE object classes in the registry that can be used to convert or activate the specified
///CLSID from.
///Params:
///    rClsid = The CLSID of the class for which the information is required.
///    fIsLinkedObject = <b>TRUE</b> if the original object is a linked object; <b>FALSE</b> otherwise.
///    wFormat = Format of the original class.
///Returns:
///    This function returns <b>TRUE</b> if the specified class can be converted to another class; <b>FALSE</b>
///    otherwise.
///    
@DllImport("oledlg")
BOOL OleUICanConvertOrActivateAs(const(GUID)* rClsid, BOOL fIsLinkedObject, ushort wFormat);

///Invokes the standard <b>Busy</b> dialog box, allowing the user to manage concurrency.
///Params:
///    Arg1 = Pointer to an OLEUIBUSY structure that contains information used to initialize the dialog box.
///Returns:
///    This function returns the following values: Standard Success/Error Definitions <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%">
///    Unknown failure (unused). </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td
///    width="60%"> No error, same as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl>
///    </td> <td width="60%"> The user pressed the <b>OK</b> button. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td width="60%"> The user has pressed the <b>Cancel</b> button and that
///    the caller should cancel the operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_BZ_SWITCHTOSELECTED</b></dt> </dl> </td> <td width="60%"> The user has pressed <b>Switch To</b> and
///    OleUIBusy was unable to determine how to switch to the blocking application. In this case, the caller should
///    either take measures to attempt to resolve the conflict itself, if possible, or retry the operation.
///    <b>OleUIBusy</b> will only return OLEUI_BZ_SWITCHTOSELECTED if the user has pressed the <b>Switch To</b> button,
///    <i>hTask</i> is <b>NULL</b> and the BZ_NOTRESPONDING flag is set. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_BZ_SWITCHTOSELECTED</b></dt> </dl> </td> <td width="60%"> The user has pressed <b>Switch To</b> and
///    OleUIBusy was unable to determine how to switch to the blocking application. In this case, the caller should
///    either take measures to attempt to resolve the conflict itself, if possible, or retry the operation.
///    <b>OleUIBusy</b> will only return OLEUI_BZ_SWITCHTOSELECTED if the user has pressed the <b>Switch To</b> button,
///    <i>hTask</i> is <b>NULL</b> and the BZ_NOTRESPONDING flag is set. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_BZ_SWITCHTOSELECTED</b></dt> </dl> </td> <td width="60%"> The user has pressed <b>Switch To</b> and
///    OleUIBusy was unable to determine how to switch to the blocking application. In this case, the caller should
///    either take measures to attempt to resolve the conflict itself, if possible, or retry the operation.
///    <b>OleUIBusy</b> will only return OLEUI_BZ_SWITCHTOSELECTED if the user has pressed the <b>Switch To</b> button,
///    <i>hTask</i> is <b>NULL</b> and the BZ_NOTRESPONDING flag is set. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_BZ_RETRYSELECTED </b></dt> </dl> </td> <td width="60%"> The user has either pressed the <b>Retry</b>
///    button or attempted to resolve the conflict (probably by switching to the blocking application). In this case,
///    the caller should retry the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_BZ_CALLUNBLOCKED
///    </b></dt> </dl> </td> <td width="60%"> The dialog box has been informed that the operation is no longer blocked.
///    </td> </tr> </table> Standard Field Validation Errors <table> <tr> <th>Return code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td> <td width="60%"> Errors common
///    to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX. This value allows the
///    application to test for standard messages in order to display error messages to the user. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td> <td width="60%"> The pointer to an OLEUIXXX
///    structure passed into the function was <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient permissions for read or
///    write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT
///    </b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hWndOwner</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpszCaption</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpfnHook</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hInstance</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszTemplate</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>hResource</i> value is invalid. </td> </tr> </table> Initialization Errors <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the dialog box
///    template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl> </td> <td
///    width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString for the localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_BZERR_HTASKINVALID</b></dt> </dl> </td> <td width="60%"> The
///    hTask specified in the <i>hTask</i> member of the OLEUIBUSY structure is invalid. </td> </tr> </table>
///    
@DllImport("oledlg")
uint OleUIBusyW(OLEUIBUSYW* param0);

///Invokes the standard <b>Busy</b> dialog box, allowing the user to manage concurrency.
///Params:
///    Arg1 = Pointer to an OLEUIBUSY structure that contains information used to initialize the dialog box.
///Returns:
///    This function returns the following values: Standard Success/Error Definitions <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%">
///    Unknown failure (unused). </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td
///    width="60%"> No error, same as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl>
///    </td> <td width="60%"> The user pressed the <b>OK</b> button. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td width="60%"> The user has pressed the <b>Cancel</b> button and that
///    the caller should cancel the operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_BZ_SWITCHTOSELECTED</b></dt> </dl> </td> <td width="60%"> The user has pressed <b>Switch To</b> and
///    OleUIBusy was unable to determine how to switch to the blocking application. In this case, the caller should
///    either take measures to attempt to resolve the conflict itself, if possible, or retry the operation.
///    <b>OleUIBusy</b> will only return OLEUI_BZ_SWITCHTOSELECTED if the user has pressed the <b>Switch To</b> button,
///    <i>hTask</i> is <b>NULL</b> and the BZ_NOTRESPONDING flag is set. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_BZ_SWITCHTOSELECTED</b></dt> </dl> </td> <td width="60%"> The user has pressed <b>Switch To</b> and
///    OleUIBusy was unable to determine how to switch to the blocking application. In this case, the caller should
///    either take measures to attempt to resolve the conflict itself, if possible, or retry the operation.
///    <b>OleUIBusy</b> will only return OLEUI_BZ_SWITCHTOSELECTED if the user has pressed the <b>Switch To</b> button,
///    <i>hTask</i> is <b>NULL</b> and the BZ_NOTRESPONDING flag is set. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_BZ_SWITCHTOSELECTED</b></dt> </dl> </td> <td width="60%"> The user has pressed <b>Switch To</b> and
///    OleUIBusy was unable to determine how to switch to the blocking application. In this case, the caller should
///    either take measures to attempt to resolve the conflict itself, if possible, or retry the operation.
///    <b>OleUIBusy</b> will only return OLEUI_BZ_SWITCHTOSELECTED if the user has pressed the <b>Switch To</b> button,
///    <i>hTask</i> is <b>NULL</b> and the BZ_NOTRESPONDING flag is set. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_BZ_RETRYSELECTED </b></dt> </dl> </td> <td width="60%"> The user has either pressed the <b>Retry</b>
///    button or attempted to resolve the conflict (probably by switching to the blocking application). In this case,
///    the caller should retry the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_BZ_CALLUNBLOCKED
///    </b></dt> </dl> </td> <td width="60%"> The dialog box has been informed that the operation is no longer blocked.
///    </td> </tr> </table> Standard Field Validation Errors <table> <tr> <th>Return code</th> <th>Description</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td> <td width="60%"> Errors common
///    to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX. This value allows the
///    application to test for standard messages in order to display error messages to the user. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td> <td width="60%"> The pointer to an OLEUIXXX
///    structure passed into the function was <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient permissions for read or
///    write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT
///    </b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hWndOwner</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpszCaption</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpfnHook</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hInstance</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszTemplate</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>hResource</i> value is invalid. </td> </tr> </table> Initialization Errors <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the dialog box
///    template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl> </td> <td
///    width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString for the localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_BZERR_HTASKINVALID</b></dt> </dl> </td> <td width="60%"> The
///    hTask specified in the <i>hTask</i> member of the OLEUIBUSY structure is invalid. </td> </tr> </table>
///    
@DllImport("oledlg")
uint OleUIBusyA(OLEUIBUSYA* param0);

///Invokes the <b>Change Source</b> dialog box, allowing the user to change the source of a link.
///Params:
///    Arg1 = Pointer to the in-out OLEUICHANGESOURCE structure for this dialog box.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the OK button.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No error, same
///    as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td width="60%"> The
///    user pressed the Cancel button. </td> </tr> </table> Standard Field Validation Errors <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td>
///    <td width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to
///    OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard messages in order to display error
///    messages to the user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td>
///    <td width="60%"> The pointer to an OLEUIXXX structure passed into the function was <b>NULL</b>. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient
///    permissions for read or write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the
///    dialog box template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl>
///    </td> <td width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString for localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CSERR_LINKCNTRNULL</b></dt> </dl> </td> <td width="60%"> The
///    <i>lpOleUILinkContainer</i> value is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_CSERR_LINKCNTRINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpOleUILinkContainer</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CSERR_FROMNOTNULL</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpszFrom</i> value is not <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_CSERR_TONOTNULL</b></dt> </dl> </td> <td width="60%"> The <i>lpszTo</i> value is not <b>NULL</b>.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CSERR_SOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The
///    <i>lpszDisplayName</i> or <i>nFileLength</i> value is invalid, or cannot retrieve the link source. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_CSERR_SOURCEPARSEERROR</b></dt> </dl> </td> <td width="60%"> The
///    <i>nFilename</i> value is wrong. </td> </tr> </table>
///    
@DllImport("oledlg")
uint OleUIChangeSourceW(OLEUICHANGESOURCEW* param0);

///Invokes the <b>Change Source</b> dialog box, allowing the user to change the source of a link.
///Params:
///    Arg1 = Pointer to the in-out OLEUICHANGESOURCE structure for this dialog box.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the OK button.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No error, same
///    as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td width="60%"> The
///    user pressed the Cancel button. </td> </tr> </table> Standard Field Validation Errors <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td>
///    <td width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to
///    OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard messages in order to display error
///    messages to the user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td>
///    <td width="60%"> The pointer to an OLEUIXXX structure passed into the function was <b>NULL</b>. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient
///    permissions for read or write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the
///    dialog box template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl>
///    </td> <td width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString for localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CSERR_LINKCNTRNULL</b></dt> </dl> </td> <td width="60%"> The
///    <i>lpOleUILinkContainer</i> value is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_CSERR_LINKCNTRINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpOleUILinkContainer</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CSERR_FROMNOTNULL</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpszFrom</i> value is not <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_CSERR_TONOTNULL</b></dt> </dl> </td> <td width="60%"> The <i>lpszTo</i> value is not <b>NULL</b>.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CSERR_SOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The
///    <i>lpszDisplayName</i> or <i>nFileLength</i> value is invalid, or cannot retrieve the link source. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_CSERR_SOURCEPARSEERROR</b></dt> </dl> </td> <td width="60%"> The
///    <i>nFilename</i> value is wrong. </td> </tr> </table>
///    
@DllImport("oledlg")
uint OleUIChangeSourceA(OLEUICHANGESOURCEA* param0);

///Invokes the <b>Object Properties</b> dialog box, which displays <b>General</b>, <b>View</b>, and <b>Link</b>
///information about an object.
///Params:
///    Arg1 = Pointer to the OLEUIOBJECTPROPS structure.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the <b>OK</b>
///    button. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No
///    error, same as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td
///    width="60%"> The user pressed the <b>Cancel</b> button. </td> </tr> </table> Standard Field Validation Errors
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td> <td width="60%"> Errors common to all dialog boxes lie in the
///    range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard
///    messages in order to display error messages to the user. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td> <td width="60%"> The pointer to an OLEUIXXX structure passed
///    into the function was <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient permissions for read or
///    write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors Initialization Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td>
///    <td width="60%"> Unable to find the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to load the dialog box
///    template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td
///    width="60%"> Dialog box initialization failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to LocalAlloc or the standard IMalloc
///    allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td
///    width="60%"> A call to GlobalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td> <td width="60%"> Unable to call LoadString for localized
///    resources from the library. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl>
///    </td> <td width="60%"> A call to the standard IMalloc allocator failed. </td> </tr> </table> Function Specific
///    Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td width="60%"> Errors common to all dialog boxes lie in the
///    range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard
///    messages in order to display error messages to the user. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_OPERR_SUBPROPNULL</b></dt> </dl> </td> <td width="60%"> <i>lpGP</i> or <i>lpVP</i> is <b>NULL</b>,
///    or <i>dwFlags</i> and OPF_OBJECTISLINK and <i>lpLP</i> are <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_OPERR_SUBPROPINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient write-access permissions for
///    the structures pointed to by <i>lpGP</i>, <i>lpVP</i>, or <i>lpLP</i>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_OPERR_PROPSHEETNULL</b></dt> </dl> </td> <td width="60%"> The <i>lpLP</i> value is <b>NULL</b>.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OPERR_PROPSHEETINVALID</b></dt> </dl> </td> <td width="60%">
///    Insufficient write-access permissions for the structures pointed to by <i>lpGP</i>, <i>lpVP</i>, or <i>lpLP</i>.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OPERR_SUPPROP</b></dt> </dl> </td> <td width="60%"> The
///    sub-link property pointer, <i>lpLP</i>, is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_OPERR_PROPSINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient write access for the sub-link
///    property pointer, <i>lpLP</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OPERR_PAGESINCORRECT</b></dt>
///    </dl> </td> <td width="60%"> Some sub-link properties of the <i>lpPS</i> member are incorrect. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_OPERR_INVALIDPAGES</b></dt> </dl> </td> <td width="60%"> Some sub-link
///    properties of the <i>lpPS</i> member are incorrect. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_OPERR_NOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> A sub-link property of the <i>lpPS</i>
///    member is incorrect. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OPERR_DLGPROCNOTNULL</b></dt> </dl>
///    </td> <td width="60%"> A sub-link property of the <i>lpPS</i> member is incorrect. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_OPERR_LPARAMNOTZERO</b></dt> </dl> </td> <td width="60%"> A sub-link property of
///    the <i>lpPS</i> member is incorrect. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_GPERR_STRINGINVALID</b></dt> </dl> </td> <td width="60%"> A string value (for example,
///    <i>lplpszLabel</i> or <i>lplpszType</i>) is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_GPERR_CLASSIDINVALID</b></dt> </dl> </td> <td width="60%"> The <i>clsid</i> value is invalid. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_GPERR_LPCLSIDEXCLUDEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>ClsidExcluded</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_GPERR_CBFORMATINVALID</b></dt> </dl> </td> <td width="60%"> The <i>wFormat</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_VPERR_METAPICTINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hMetaPict</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_VPERR_DVASPECTINVALID</b></dt> </dl> </td> <td width="60%"> The <i>dvAspect</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OPERR_PROPERTYSHEET</b></dt> </dl> </td> <td width="60%"> The
///    <i>lpPS</i> value is incorrect. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OPERR_OBJINFOINVALID</b></dt>
///    </dl> </td> <td width="60%"> The <i>lpObjInfo</i> value is <b>NULL</b> or the calling process doesn't have read
///    access. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OPERR_LINKINFOINVALID </b></dt> </dl> </td> <td
///    width="60%"> The <i>lpLinkInfo</i> value is <b>NULL</b> or the calling process doesn't have read access. </td>
///    </tr> </table>
///    
@DllImport("oledlg")
uint OleUIObjectPropertiesW(OLEUIOBJECTPROPSW* param0);

///Invokes the <b>Object Properties</b> dialog box, which displays <b>General</b>, <b>View</b>, and <b>Link</b>
///information about an object.
///Params:
///    Arg1 = Pointer to the OLEUIOBJECTPROPS structure.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the <b>OK</b>
///    button. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No
///    error, same as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td
///    width="60%"> The user pressed the <b>Cancel</b> button. </td> </tr> </table> Standard Field Validation Errors
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td> <td width="60%"> Errors common to all dialog boxes lie in the
///    range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard
///    messages in order to display error messages to the user. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td> <td width="60%"> The pointer to an OLEUIXXX structure passed
///    into the function was <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient permissions for read or
///    write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors Initialization Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td>
///    <td width="60%"> Unable to find the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to load the dialog box
///    template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td
///    width="60%"> Dialog box initialization failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to LocalAlloc or the standard IMalloc
///    allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td
///    width="60%"> A call to GlobalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td> <td width="60%"> Unable to call LoadString for localized
///    resources from the library. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl>
///    </td> <td width="60%"> A call to the standard IMalloc allocator failed. </td> </tr> </table> Function Specific
///    Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td width="60%"> Errors common to all dialog boxes lie in the
///    range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard
///    messages in order to display error messages to the user. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_OPERR_SUBPROPNULL</b></dt> </dl> </td> <td width="60%"> <i>lpGP</i> or <i>lpVP</i> is <b>NULL</b>,
///    or <i>dwFlags</i> and OPF_OBJECTISLINK and <i>lpLP</i> are <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_OPERR_SUBPROPINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient write-access permissions for
///    the structures pointed to by <i>lpGP</i>, <i>lpVP</i>, or <i>lpLP</i>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_OPERR_PROPSHEETNULL</b></dt> </dl> </td> <td width="60%"> The <i>lpLP</i> value is <b>NULL</b>.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OPERR_PROPSHEETINVALID</b></dt> </dl> </td> <td width="60%">
///    Insufficient write-access permissions for the structures pointed to by <i>lpGP</i>, <i>lpVP</i>, or <i>lpLP</i>.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OPERR_SUPPROP</b></dt> </dl> </td> <td width="60%"> The
///    sub-link property pointer, <i>lpLP</i>, is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_OPERR_PROPSINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient write access for the sub-link
///    property pointer, <i>lpLP</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OPERR_PAGESINCORRECT</b></dt>
///    </dl> </td> <td width="60%"> Some sub-link properties of the <i>lpPS</i> member are incorrect. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>OLEUI_OPERR_INVALIDPAGES</b></dt> </dl> </td> <td width="60%"> Some sub-link
///    properties of the <i>lpPS</i> member are incorrect. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_OPERR_NOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> A sub-link property of the <i>lpPS</i>
///    member is incorrect. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OPERR_DLGPROCNOTNULL</b></dt> </dl>
///    </td> <td width="60%"> A sub-link property of the <i>lpPS</i> member is incorrect. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_OPERR_LPARAMNOTZERO</b></dt> </dl> </td> <td width="60%"> A sub-link property of
///    the <i>lpPS</i> member is incorrect. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_GPERR_STRINGINVALID</b></dt> </dl> </td> <td width="60%"> A string value (for example,
///    <i>lplpszLabel</i> or <i>lplpszType</i>) is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_GPERR_CLASSIDINVALID</b></dt> </dl> </td> <td width="60%"> The <i>clsid</i> value is invalid. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_GPERR_LPCLSIDEXCLUDEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>ClsidExcluded</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_GPERR_CBFORMATINVALID</b></dt> </dl> </td> <td width="60%"> The <i>wFormat</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_VPERR_METAPICTINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hMetaPict</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_VPERR_DVASPECTINVALID</b></dt> </dl> </td> <td width="60%"> The <i>dvAspect</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OPERR_PROPERTYSHEET</b></dt> </dl> </td> <td width="60%"> The
///    <i>lpPS</i> value is incorrect. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OPERR_OBJINFOINVALID</b></dt>
///    </dl> </td> <td width="60%"> The <i>lpObjInfo</i> value is <b>NULL</b> or the calling process doesn't have read
///    access. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_OPERR_LINKINFOINVALID </b></dt> </dl> </td> <td
///    width="60%"> The <i>lpLinkInfo</i> value is <b>NULL</b> or the calling process doesn't have read access. </td>
///    </tr> </table>
///    
@DllImport("oledlg")
uint OleUIObjectPropertiesA(OLEUIOBJECTPROPSA* param0);

///Displays a dialog box with the specified template and returns the response (button identifier) from the user. This
///function is used to display OLE warning messages, for example, Class Not Registered.
///Params:
///    nTemplate = The resource number of the dialog box to be displayed. See Remarks.
///    hwndParent = The handle to the parent window of the dialog box.
///    arg3 = Optional. The title of the dialog box followed by a list of arguments for the format string in the static control
///           (IDC_PU_TEXT) of the dialog box. The caller must be sure to pass the correct number and types of arguments.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the <b>OK</b>
///    button. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No
///    error, same as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td
///    width="60%"> The user pressed the <b>Cancel</b> button. </td> </tr> </table> Standard Field Validation Errors
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td> <td width="60%"> Errors common to all dialog boxes lie in the
///    range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard
///    messages in order to display error messages to the user. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td> <td width="60%"> The pointer to an OLEUIXXX structure passed
///    into the function was <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient permissions for read or
///    write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the
///    dialog box template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl>
///    </td> <td width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString for localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> </table>
///    
@DllImport("oledlg")
int OleUIPromptUserW(int nTemplate, HWND hwndParent);

///Displays a dialog box with the specified template and returns the response (button identifier) from the user. This
///function is used to display OLE warning messages, for example, Class Not Registered.
///Params:
///    nTemplate = The resource number of the dialog box to be displayed. See Remarks.
///    hwndParent = The handle to the parent window of the dialog box.
///    arg3 = Optional. The title of the dialog box followed by a list of arguments for the format string in the static control
///           (IDC_PU_TEXT) of the dialog box. The caller must be sure to pass the correct number and types of arguments.
///Returns:
///    Standard Success/Error Definitions <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_FALSE</b></dt> </dl> </td> <td width="60%"> Unknown failure (unused). </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>OLEUI_OK</b></dt> </dl> </td> <td width="60%"> The user pressed the <b>OK</b>
///    button. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_SUCCESS</b></dt> </dl> </td> <td width="60%"> No
///    error, same as OLEUI_OK. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_CANCEL</b></dt> </dl> </td> <td
///    width="60%"> The user pressed the <b>Cancel</b> button. </td> </tr> </table> Standard Field Validation Errors
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STANDARDMIN</b></dt> </dl> </td> <td width="60%"> Errors common to all dialog boxes lie in the
///    range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX. This value allows the application to test for standard
///    messages in order to display error messages to the user. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STRUCTURENULL</b></dt> </dl> </td> <td width="60%"> The pointer to an OLEUIXXX structure passed
///    into the function was <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_STRUCTUREINVALID</b></dt> </dl> </td> <td width="60%"> Insufficient permissions for read or
///    write access to an OLEUIXXX structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_CBSTRUCTINCORRECT</b></dt> </dl> </td> <td width="60%"> The <i>cbstruct</i> value is incorrect.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_HWNDOWNERINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>hWndOwner</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_LPSZCAPTIONINVALID</b></dt> </dl> </td> <td width="60%"> The <i>lpszCaption</i> value is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPFNHOOKINVALID</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpfnHook</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HINSTANCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hInstance</i> value is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LPSZTEMPLATEINVALID</b></dt> </dl> </td> <td width="60%">
///    The <i>lpszTemplate</i> value is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_HRESOURCEINVALID</b></dt> </dl> </td> <td width="60%"> The <i>hResource</i> value is invalid.
///    </td> </tr> </table> Initialization Errors <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_FINDTEMPLATEFAILURE</b></dt> </dl> </td> <td width="60%"> Unable to find the
///    dialog box template. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADTEMPLATEFAILURE</b></dt> </dl>
///    </td> <td width="60%"> Unable to load the dialog box template. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_DIALOGFAILURE</b></dt> </dl> </td> <td width="60%"> Dialog box initialization failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOCALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to
///    LocalAlloc or the standard IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>OLEUI_ERR_GLOBALMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to GlobalAlloc or the standard
///    IMalloc allocator failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_LOADSTRING</b></dt> </dl> </td>
///    <td width="60%"> Unable to call LoadString for localized resources from the library. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>OLEUI_ERR_OLEMEMALLOC</b></dt> </dl> </td> <td width="60%"> A call to the standard
///    IMalloc allocator failed. </td> </tr> </table> Function Specific Errors <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEUI_ERR_STANDARDMAX</b></dt> </dl> </td> <td
///    width="60%"> Errors common to all dialog boxes lie in the range OLEUI_ERR_STANDARDMIN to OLEUI_ERR_STANDARDMAX.
///    This value allows the application to test for standard messages in order to display error messages to the user.
///    </td> </tr> </table>
///    
@DllImport("oledlg")
int OleUIPromptUserA(int nTemplate, HWND hwndParent);

///Updates all links in the link container and displays a dialog box that shows the progress of the updating process.
///The process is stopped if the user presses the <b>Stop</b> button or when all links are processed.
///Params:
///    lpOleUILinkCntr = Pointer to the IOleUILinkContainer interface on the link container.
///    hwndParent = Parent window of the dialog box.
///    lpszTitle = Pointer to the title of the dialog box.
///    cLinks = Total number of links.
///Returns:
///    Returns <b>TRUE</b> if the links were successfully updated; otherwise, <b>FALSE</b>.
///    
@DllImport("oledlg")
BOOL OleUIUpdateLinksW(IOleUILinkContainerW lpOleUILinkCntr, HWND hwndParent, const(wchar)* lpszTitle, int cLinks);

///Updates all links in the link container and displays a dialog box that shows the progress of the updating process.
///The process is stopped if the user presses the <b>Stop</b> button or when all links are processed.
///Params:
///    lpOleUILinkCntr = Pointer to the IOleUILinkContainer interface on the link container.
///    hwndParent = Parent window of the dialog box.
///    lpszTitle = Pointer to the title of the dialog box.
///    cLinks = Total number of links.
///Returns:
///    Returns <b>TRUE</b> if the links were successfully updated; otherwise, <b>FALSE</b>.
///    
@DllImport("oledlg")
BOOL OleUIUpdateLinksA(IOleUILinkContainerA lpOleUILinkCntr, HWND hwndParent, const(char)* lpszTitle, int cLinks);

///Instantiates the appropriate interceptor for the specified interface to be intercepted and returns the newly created
///interceptor.
///Params:
///    iidIntercepted = A reference to the identifier of the interface for which an interceptor is to be returned.
///    punkOuter = If this parameter is <b>NULL</b>, the object is not being created as part of an aggregate. Otherwise, this
///                parameter is a pointer to the aggregate object's IUnknown interface (the controlling <b>IUnknown</b>).
///    iid = A reference to the identifier of the interface desired on the interceptor.
///    ppv = The address of a pointer variable that receives the interface pointer requested in <i>iid</i>. Upon successful
///          return, **<i>ppv</i> contains the requested interceptor pointer.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function returned successfully. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error
///    occurred. </td> </tr> </table>
///    
@DllImport("ole32")
HRESULT CoGetInterceptor(const(GUID)* iidIntercepted, IUnknown punkOuter, const(GUID)* iid, void** ppv);

@DllImport("ole32")
HRESULT CoGetInterceptorFromTypeInfo(const(GUID)* iidIntercepted, IUnknown punkOuter, ITypeInfo typeInfo, 
                                     const(GUID)* iid, void** ppv);

///Registers or unregisters the per-thread message dispatcher that is to be invoked when there are window messages
///available to dispatch within COM wait APIs on an ASTA thread. This function is usually called by CoreWindow, but in
///certain circumstances other components that need to specialize how messages are dispatched on an ASTA thread can also
///call this function.
///Params:
///    pMessageDispatcher = If non-null, message dispatcher object to register. This object must also implement IWeakReferenceSource. If
///                         null, unregisters the current message dispatcher.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("ole32")
void CoSetMessageDispatcher(IMessageDispatcher pMessageDispatcher);

///Called by message dispatchers on an ASTA thread after dispatching a windows message to provide an opportunity for
///short-running infrastructural COM calls and other high-priority or short-running COM work to be dispatched between
///messages. This helps to provide similar responsiveness to these infrastructural calls in an ASTA as in a classic STA,
///even when there is a long stream of window messages to be handled.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("ole32")
void CoHandlePriorityEventsFromMessagePump();

///Initializes the COM library on the current thread and identifies the concurrency model as single-thread apartment
///(STA). New applications should call CoInitializeEx instead of CoInitialize. If you want to use the Windows Runtime,
///you must call Windows::Foundation::Initialize instead.
///Params:
///    pvReserved = This parameter is reserved and must be <b>NULL</b>.
///Returns:
///    This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The COM library was initialized successfully on this thread.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The COM library is
///    already initialized on this thread. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>RPC_E_CHANGED_MODE</b></dt>
///    </dl> </td> <td width="60%"> A previous call to CoInitializeEx specified the concurrency model for this thread as
///    multithread apartment (MTA). This could also indicate that a change from neutral-threaded apartment to
///    single-threaded apartment has occurred. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoInitialize(void* pvReserved);

///Registers an implementation of the IMallocSpy interface, thereafter requiring OLE to call its wrapper methods around
///every call to the corresponding IMalloc method.
///Params:
///    pMallocSpy = A pointer to an instance of the IMallocSpy implementation.
///Returns:
///    This function can return the standard return value E_INVALIDARG, as well as the following values. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> The object was successfully registered. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>CO_E_OBJISREG</b></dt> </dl> </td> <td width="60%"> The object is already registered. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoRegisterMallocSpy(IMallocSpy pMallocSpy);

///Revokes a registered IMallocSpy object.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The object was revoked successfully.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_OBJNOTREG</b></dt> </dl> </td> <td width="60%"> No spy is
///    currently registered. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
///    width="60%"> A spy is registered but there are outstanding allocations (not yet freed) made while this spy was
///    active. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoRevokeMallocSpy();

///Registers an implementation of the IInitializeSpy interface. The <b>IInitializeSpy</b> interface is defied to allow
///developers to perform initialization and cleanup on COM apartments.
///Params:
///    pSpy = A pointer to an instance of the IInitializeSpy implementation.
///    puliCookie = The address at which to store a cookie that identifies this registration.
///Returns:
///    This function can return the standard return value E_INVALIDARG, as well as the following values. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> The object was successfully registered. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The object does not support IInitializeSpy. </td>
///    </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoRegisterInitializeSpy(IInitializeSpy pSpy, ULARGE_INTEGER* puliCookie);

///Revokes a registered implementation of the IInitializeSpy interface.
///Params:
///    uliCookie = A ULARGE_INTEGER cookie identifying the registration.
///Returns:
///    This function can return the standard return value E_INVALIDARG, as well as S_OK to indicate success.
///    
@DllImport("OLE32")
HRESULT CoRevokeInitializeSpy(ULARGE_INTEGER uliCookie);

///Returns the default values of the Security Descriptors of the machine-wide launch and access permissions, as well as
///launch and access limits.
///Params:
///    comSDType = A value from the COMSD enumeration. Specifies the type of the requested system security permissions, such as
///                launch permissions, access permissions, launch restrictions, and access restrictions.
///    ppSD = Pointer to a caller-supplied variable that this routine sets to the address of a buffer containing the
///           SECURITY_DESCRIPTOR for the system security permissions. Memory will be allocated by
///           <b>CoGetSystemSecurityPermissions</b> and should be freed by caller with LocalFree.
///Returns:
///    This function can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid parameter <i>comSDType</i> or
///    <i>ppSD</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> No
///    connection to the resolver process. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
///    </td> <td width="60%"> Not enough memory for the security descriptor's allocation. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoGetSystemSecurityPermissions(COMSD comSDType, void** ppSD);

///Loads a specific DLL into the caller's process. <b>CoLoadLibrary</b> is equivalent to LoadLibraryEx.
///<b>CoLoadLibrary</b> does not affect the lifetime of the library.
///Params:
///    lpszLibName = The name of the library to be loaded.
///    bAutoFree = This parameter is maintained for compatibility with 16-bit applications, but is ignored.
///Returns:
///    If the function succeeds, the return value is a handle to the loaded library; otherwise, it is <b>NULL</b>.
///    
@DllImport("OLE32")
HINSTANCE CoLoadLibrary(ushort* lpszLibName, BOOL bAutoFree);

///Frees a library that, when loaded, was specified to be freed explicitly. <div class="alert"><b>Note</b> This function
///is provided for compatibility with 16-bit Windows.</div><div> </div>
///Params:
///    hInst = A handle to the library module to be freed, as returned by the CoLoadLibrary function.
@DllImport("OLE32")
void CoFreeLibrary(HINSTANCE hInst);

///Frees all the DLLs that have been loaded with the CoLoadLibrary function (called internally by CoGetClassObject),
///regardless of whether they are currently in use.
@DllImport("OLE32")
void CoFreeAllLibraries();

///Creates a new object and initializes it from a file using IPersistFile::Load.
///Params:
///    pServerInfo = A pointer to a COSERVERINFO structure that specifies the computer on which to instantiate the object and the
///                  authentication setting to be used. This parameter can be <b>NULL</b>, in which case the object is instantiated on
///                  the current computer, at the computer specified under the RemoteServerName registry value for the class, or at
///                  the computer where the <i>pwszName</i> file resides if the ActivateAtStorage value is specified for the class or
///                  there is no local registry information.
///    pClsid = A pointer to the class identifier of the object to be created. This parameter can be <b>NULL</b>, in which case
///             there is a call to GetClassFile, using <i>pwszName</i> as its parameter to get the class of the object to be
///             instantiated.
///    punkOuter = When non-<b>NULL</b>, indicates the instance is being created as part of an aggregate, and <i>punkOuter</i> is to
///                be used as the pointer to the new instance's controlling IUnknown. Aggregation is not supported cross-process or
///                cross-computer. When instantiating an object out of process, CLASS_E_NOAGGREGATION will be returned if
///                <i>punkOuter</i> is non-<b>NULL</b>.
///    dwClsCtx = Values from the CLSCTX enumeration.
///    grfMode = Specifies how the file is to be opened. See STGM Constants.
///    pwszName = The file used to initialize the object with IPersistFile::Load. This parameter cannot be <b>NULL</b>.
///    dwCount = The number of structures in <i>pResults</i>. This parameter must be greater than 0.
///    pResults = An array of MULTI_QI structures. Each structure has three members: the identifier for a requested interface
///               (<b>pIID</b>), the location to return the interface pointer (<b>pItf</b>) and the return value of the call to
///               QueryInterface (<b>hr</b>).
///Returns:
///    This function can return the standard return value E_INVALIDARG, as well as the following values. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> The function retrieved all of the interfaces successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>CO_S_NOTALLINTERFACES</b></dt> </dl> </td> <td width="60%"> At least one, but not all of the interfaces
///    requested in the <i>pResults</i> array were successfully retrieved. The <b>hr</b> member of each of the MULTI_QI
///    structures indicates with S_OK or E_NOINTERFACE whether the specific interface was returned. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> None of the interfaces requested in
///    the <i>pResults</i> array were successfully retrieved. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoGetInstanceFromFile(COSERVERINFO* pServerInfo, GUID* pClsid, IUnknown punkOuter, uint dwClsCtx, 
                              uint grfMode, ushort* pwszName, uint dwCount, char* pResults);

///Creates a new object and initializes it from a storage object through an internal call to IPersistFile::Load.
///Params:
///    pServerInfo = A pointer to a COSERVERINFO structure that specifies the computer on which to instantiate the object and the
///                  authentication setting to be used. This parameter can be <b>NULL</b>, in which case the object is instantiated on
///                  the current computer, at the computer specified under the RemoteServerName registry value for the class, or at
///                  the computer where the <i>pstg</i> storage object resides if the ActivateAtStorage value is specified for the
///                  class or there is no local registry information.
///    pClsid = A pointer to the class identifier of the object to be created. This parameter can be <b>NULL</b>, in which case
///             there is a call to IStorage::Stat to find the class of the object.
///    punkOuter = When non-<b>NULL</b>, indicates the instance is being created as part of an aggregate, and <i>punkOuter</i> is to
///                be used as the pointer to the new instance's controlling IUnknown. Aggregation is not supported cross-process or
///                cross-computer. When instantiating an object out of process, CLASS_E_NOAGGREGATION will be returned if
///                <i>punkOuter</i> is non-<b>NULL</b>.
///    dwClsCtx = Values from the CLSCTX enumeration.
///    pstg = A pointer to the storage object used to initialize the object with IPersistFile::Load. This parameter cannot be
///           <b>NULL</b>.
///    dwCount = The number of structures in <i>pResults</i>. This parameter must be greater than 0.
///    pResults = An array of MULTI_QI structures. Each structure has three members: the identifier for a requested interface
///               (<b>pIID</b>), the location to return the interface pointer (<b>pItf</b>) and the return value of the call to
///               QueryInterface (<b>hr</b>).
///Returns:
///    This function can return the standard return value E_INVALIDARG, as well as the following values. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> The function retrieved all of the interfaces successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>CO_S_NOTALLINTERFACES</b></dt> </dl> </td> <td width="60%"> At least one, but not all of the interfaces
///    requested in the <i>pResults</i> array were successfully retrieved. The <b>hr</b> member of each of the MULTI_QI
///    structures indicates with S_OK or E_NOINTERFACE whether the specific interface was returned. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> None of the interfaces requested in
///    the <i>pResults</i> array were successfully retrieved. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoGetInstanceFromIStorage(COSERVERINFO* pServerInfo, GUID* pClsid, IUnknown punkOuter, uint dwClsCtx, 
                                  IStorage pstg, uint dwCount, char* pResults);

///This function passes the foreground privilege (the privilege to set the foreground window) from one process to
///another. The process that has the foreground privilege can call this function to pass that privilege on to a local
///COM server process. Note that calling <b>CoAllowSetForegroundWindow</b> only confers the privilege; it does not set
///the foreground window itself. Foreground and focus are only taken away from the client application when the target
///COM server calls either SetForegroundWindow or another API that does so indirectly.
///Params:
///    pUnk = A pointer to the IUnknown interface on the proxy of the target COM server.
///    lpvReserved = This parameter is reserved and must be <b>NULL</b>.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method was successful. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>lpvReserved</i>
///    parameter is not <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td>
///    <td width="60%"> The <i>pUnk</i> parameter does not support foreground window control. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> The calling process does not
///    currently possess the foreground privilege. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoAllowSetForegroundWindow(IUnknown pUnk, void* lpvReserved);

///Determines whether the specified CLSID represents an OLE 1 object.
///Params:
///    rclsid = The CLSID to be checked.
///Returns:
///    If the CLSID refers to an OLE 1 object, the return value is <b>TRUE</b>; otherwise, it is <b>FALSE</b>.
///    
@DllImport("ole32")
BOOL CoIsOle1Class(const(GUID)* rclsid);

///Converts a FILETIME into MS-DOS date and time values. <div class="alert"><b>Note</b> This function is provided for
///compatibility with 16-bit Windows.</div><div> </div>
///Params:
///    lpFileTime = A pointer to the FILETIME structure.
///    lpDosDate = Receives the MS-DOS date.
///    lpDosTime = Receives the MS-DOS time.
///Returns:
///    If the function succeeds, the return value is <b>TRUE</b>; otherwise, it is <b>FALSE</b>.
///    
@DllImport("OLE32")
BOOL CoFileTimeToDosDateTime(FILETIME* lpFileTime, ushort* lpDosDate, ushort* lpDosTime);

///Converts the MS-DOS representation of the time and date to a FILETIME structure used by Windows. <div
///class="alert"><b>Note</b> This function is provided for compatibility with 16-bit Windows.</div><div> </div>
///Params:
///    nDosDate = The MS-DOS date.
///    nDosTime = The MS-DOS time.
///    lpFileTime = A pointer to the FILETIME structure.
///Returns:
///    If the function succeeds, the return value is <b>TRUE</b>; otherwise, it is <b>FALSE</b>, probably because of
///    invalid arguments.
///    
@DllImport("OLE32")
BOOL CoDosDateTimeToFileTime(ushort nDosDate, ushort nDosTime, FILETIME* lpFileTime);

///Registers with OLE the instance of an IMessageFilter interface, which is to be used for handling concurrency issues
///on the current thread. Only one message filter can be registered for each thread. Threads in multithreaded apartments
///cannot have message filters.
///Params:
///    lpMessageFilter = A pointer to the IMessageFilter interface on the message filter. This message filter should be registered on the
///                      current thread, replacing the previous message filter (if any). This parameter can be <b>NULL</b>, indicating
///                      that no message filter should be registered on the current thread. Note that this function calls AddRef on the
///                      interface pointer to the message filter.
///    lplpMessageFilter = Address of the IMessageFilter* pointer variable that receives the interface pointer to the previously registered
///                        message filter. If there was no previously registered message filter for the current thread, the value of
///                        *<i>lplpMessageFilter</i> is <b>NULL</b>.
///Returns:
///    If the instance was registered or revoked successfully, the return value is S_OK; otherwise, it is S_FALSE.
///    
@DllImport("OLE32")
HRESULT CoRegisterMessageFilter(IMessageFilter lpMessageFilter, IMessageFilter* lplpMessageFilter);

///Registers a channel hook.
///Params:
///    ExtensionUuid = The extension to register.
///    pChannelHook = The channel hook to register.
@DllImport("ole32")
HRESULT CoRegisterChannelHook(const(GUID)* ExtensionUuid, IChannelHook pChannelHook);

///Establishes or removes an emulation, in which objects of one class are treated as objects of a different class.
///Params:
///    clsidOld = The CLSID of the object to be emulated.
///    clsidNew = The CLSID of the object that should emulate the original object. This replaces any existing emulation for
///               <i>clsidOld</i>. This parameter can be CLSID_NULL, in which case any existing emulation for <i>clsidOld</i> is
///               removed.
///Returns:
///    This function can return the standard return values E_INVALIDARG, as well as the following values. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> The emulation was successfully established or removed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>REGDB_E_CLASSNOTREG</b></dt> </dl> </td> <td width="60%"> The <i>clsidOld</i> parameter is not properly
///    registered in the registration database. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REGDB_E_READREGDB</b></dt>
///    </dl> </td> <td width="60%"> Error reading from registration database. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>REGDB_E_WRITEREGDB</b></dt> </dl> </td> <td width="60%"> Error writing to registration database. </td>
///    </tr> </table>
///    
@DllImport("OLE32")
HRESULT CoTreatAsClass(const(GUID)* clsidOld, const(GUID)* clsidNew);

///Retrieves a pointer to a new instance of an OLE-provided implementation of a data cache.
///Params:
///    pUnkOuter = If the cache is to be created as part of an aggregate, pointer to the controlling IUnknown of the aggregate. If
///                not, the parameter should be <b>NULL</b>.
///    rclsid = CLSID used to generate icon labels. This value is typically CLSID_NULL.
///    iid = Reference to the identifier of the interface the caller wants to use to communicate with the cache. This value is
///          typically IID_IOleCache (defined in the OLE headers to equal the interface identifier for IOleCache).
///    ppv = Address of pointer variable that receives the interface pointer requested in riid. Upon successful return,
///          *<i>ppvObj</i> contains the requested interface pointer to the supplied cache object.
///Returns:
///    This function returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
///    width="60%"> The interface represented by riid is not supported by the object. The parameter <i>ppvObj</i> is set
///    to <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
///    Insufficient memory for the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG </b></dt> </dl>
///    </td> <td width="60%"> One or more parameters are invalid. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CreateDataCache(IUnknown pUnkOuter, const(GUID)* rclsid, const(GUID)* iid, void** ppv);

///Locates an object by means of its moniker, activates the object if it is inactive, and retrieves a pointer to the
///specified interface on that object.
///Params:
///    pmk = A pointer to the object's moniker. See IMoniker.
///    grfOpt = This parameter is reserved for future use and must be 0.
///    iidResult = The interface identifier to be used to communicate with the object.
///    ppvResult = The address of pointer variable that receives the interface pointer requested in <i>iidResult</i>. Upon
///                successful return, *<i>ppvResult</i> contains the requested interface pointer. If an error occurs,
///                *<i>ppvResult</i> is <b>NULL</b>. If the call is successful, the caller is responsible for releasing the pointer
///                with a call to the object's IUnknown::Release method.
///Returns:
///    This function can return the following error codes, or any of the error values returned by the
///    IMoniker::BindToObject method. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The object was located and activated, if necessary, and a
///    pointer to the requested interface was returned. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MK_E_NOOBJECT</b></dt> </dl> </td> <td width="60%"> The object that the moniker object identified could
///    not be found. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT BindMoniker(IMoniker pmk, uint grfOpt, const(GUID)* iidResult, void** ppvResult);

///Converts a display name into a moniker that identifies the object named, and then binds to the object identified by
///the moniker.
///Params:
///    pszName = The display name of the object to be created.
///    pBindOptions = The binding options used to create a moniker that creates the actual object. For details, see BIND_OPTS. This
///                   parameter can be <b>NULL</b>.
///    riid = A reference to the identifier of an interface that is implemented on the object to be created.
///    ppv = The address of a pointer to the interface specified by <i>riid</i> on the object that is created.
///Returns:
///    This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The object was created successfully. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>MK_E_SYNTAX</b></dt> </dl> </td> <td width="60%"> The <i>pszName</i> parameter is not a
///    properly formed display name. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_E_NOOBJECT</b></dt> </dl> </td>
///    <td width="60%"> The object identified by this moniker, or some object identified by the composite moniker of
///    which this moniker is a part, could not be found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MK_E_EXCEEDEDDEADLINE</b></dt> </dl> </td> <td width="60%"> The binding operation could not be completed
///    within the time limit specified by the BIND_OPTS structure passed in <i>pBindOptions</i>. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>MK_E_CONNECTMANUALLY</b></dt> </dl> </td> <td width="60%"> The binding operation
///    requires assistance from the end user. The most common reasons for returning this value are that a password is
///    needed or that a floppy needs to be mounted. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MK_E_INTERMEDIATEINTERFACENOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> An intermediate object was
///    found but it did not support an interface required to complete the binding operation. For example, an item
///    moniker returns this value if its container does not support the IOleItemContainer interface. </td> </tr>
///    </table>
///    
@DllImport("OLE32")
HRESULT CoGetObject(const(wchar)* pszName, BIND_OPTS* pBindOptions, const(GUID)* riid, void** ppv);

///Converts a string into a moniker that identifies the object named by the string. This function is the inverse of the
///IMoniker::GetDisplayName operation, which retrieves the display name associated with a moniker.
///Params:
///    pbc = A pointer to the IBindCtx interface on the bind context object to be used in this binding operation.
///    szUserName = A pointer to the display name to be parsed.
///    pchEaten = A pointer to the number of characters of <i>szUserName</i> that were consumed. If the function is successful,
///               *<i>pchEaten</i> is the length of <i>szUserName</i>; otherwise, it is the number of characters successfully
///               parsed.
///    ppmk = The address of the IMoniker* pointer variable that receives the interface pointer to the moniker that was built
///           from <i>szUserName</i>. When successful, the function has called AddRef on the moniker and the caller is
///           responsible for calling Release. If an error occurs, the specified interface pointer will contain as much of the
///           moniker that the method was able to create before the error occurred.
///Returns:
///    This function can return the standard return value E_OUTOFMEMORY, as well as the following values. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> The parse operation was successful and the moniker was created. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>MK_E_SYNTAX</b></dt> </dl> </td> <td width="60%"> Error in the syntax of a file name or an error in
///    the syntax of the resulting composite moniker. </td> </tr> </table> This function can also return any of the
///    error values returned by IMoniker::BindToObject, IOleItemContainer::GetObject, or
///    IParseDisplayName::ParseDisplayName.
///    
@DllImport("OLE32")
HRESULT MkParseDisplayName(IBindCtx pbc, ushort* szUserName, uint* pchEaten, IMoniker* ppmk);

///Provides a moniker that, when composed onto the end of the first specified moniker (or one with a similar structure),
///yields the second specified moniker. This function is intended for use only by IMoniker::RelativePathTo
///implementations.
///Params:
///    pmkSrc = A pointer to the IMoniker interface on the moniker that, when composed with the relative moniker to be created,
///             produces <i>pmkDest</i>. This moniker identifies the "source" of the relative moniker to be created.
///    pmkDest = A pointer to the IMoniker interface on the moniker to be expressed relative to <i>pmkSrc</i>. This moniker
///              identifies the destination of the relative moniker to be created.
///    ppmkRelPath = The address of an IMoniker* pointer variable that receives the interface pointer to the new relative moniker.
///                  When successful, the function has called AddRef on the moniker and the caller is responsible for calling Release.
///                  If an error occurs, the interface pointer value is <b>NULL</b>.
///    dwReserved = This parameter is reserved and must be nonzero.
///Returns:
///    This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> A meaningful relative path has been returned. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>MK_S_HIM</b></dt> </dl> </td> <td width="60%"> The only form of the relative path is
///    the other moniker. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_E_NOTBINDABLE</b></dt> </dl> </td> <td
///    width="60%"> The <i>pmkSrc</i> parameter is a relative moniker, such as an item moniker, and must be composed
///    with the moniker of its container before a relative path can be determined. </td> </tr> </table>
///    
@DllImport("ole32")
HRESULT MonikerRelativePathTo(IMoniker pmkSrc, IMoniker pmkDest, IMoniker* ppmkRelPath, BOOL dwReserved);

///Creates a new moniker based on the common prefix that this moniker (the one comprising the data of this moniker
///object) shares with another moniker. This function is intended to be called only in implementations of
///IMoniker::CommonPrefixWith.
///Params:
///    pmkThis = A pointer to the IMoniker interface on one of the monikers for which a common prefix is sought; usually the
///              moniker in which this call is used to implement IMoniker::CommonPrefixWith.
///    pmkOther = A pointer to the IMoniker interface on the moniker to be compared with the first moniker.
///    ppmkCommon = The address of an IMoniker* pointer variable that receives the interface pointer to the moniker based on the
///                 common prefix of <i>pmkThis</i> and <i>pmkOther</i>. When successful, the function has called AddRef on the
///                 moniker and the caller is responsible for calling Release. If an error occurs, the supplied interface pointer
///                 value is <b>NULL</b>.
///Returns:
///    This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> A common prefix exists that is neither <i>pmkThis</i> nor
///    <i>pmkOther</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_S_HIM</b></dt> </dl> </td> <td width="60%"> The
///    entire <i>pmkOther</i> moniker is a prefix of the <i>pmkThis</i> moniker. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MK_S_ME</b></dt> </dl> </td> <td width="60%"> The entire <i>pmkThis</i> moniker is a prefix of the
///    <i>pmkOther</i> moniker. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_S_US</b></dt> </dl> </td> <td
///    width="60%"> The <i>pmkThis</i> and <i>pmkOther</i> monikers are equal. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MK_E_NOPREFIX</b></dt> </dl> </td> <td width="60%"> The monikers have no common prefix. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>MK_E_NOTBINDABLE</b></dt> </dl> </td> <td width="60%"> This function was called on a
///    relative moniker. It is not meaningful to take the common prefix of relative monikers. </td> </tr> </table>
///    
@DllImport("ole32")
HRESULT MonikerCommonPrefixWith(IMoniker pmkThis, IMoniker pmkOther, IMoniker* ppmkCommon);

///Returns a pointer to an implementation of IBindCtx (a bind context object). This object stores information about a
///particular moniker-binding operation.
///Params:
///    reserved = This parameter is reserved and must be 0.
///    ppbc = Address of an IBindCtx* pointer variable that receives the interface pointer to the new bind context object. When
///           the function is successful, the caller is responsible for calling Release on the bind context. A <b>NULL</b>
///           value for the bind context indicates that an error occurred.
///Returns:
///    This function can return the standard return values E_OUTOFMEMORY and S_OK.
///    
@DllImport("OLE32")
HRESULT CreateBindCtx(uint reserved, IBindCtx* ppbc);

///Performs a generic composition of two monikers and supplies a pointer to the resulting composite moniker.
///Params:
///    pmkFirst = A pointer to the moniker to be composed to the left of the moniker that pmkRest points to. Can point to any kind
///               of moniker, including a generic composite.
///    pmkRest = A pointer to the moniker to be composed to the right of the moniker to which <i>pmkFirst</i> points. Can point to
///              any kind of moniker compatible with the type of the <i>pmkRest</i> moniker, including a generic composite.
///    ppmkComposite = The address of an IMoniker* pointer variable that receives the interface pointer to the composite moniker object
///                    that is the result of composing <i>pmkFirst</i> and <i>pmkRest</i>. This object supports the OLE composite
///                    moniker implementation of <b>IMoniker</b>. When successful, the function has called AddRef on the moniker and the
///                    caller is responsible for calling Release. If either <i>pmkFirst</i> or <i>pmkRest</i> are <b>NULL</b>, the
///                    supplied pointer is the one that is non-<b>NULL</b>. If both <i>pmkFirst</i> and <i>pmkRest</i> are <b>NULL</b>,
///                    or if an error occurs, the returned pointer is <b>NULL</b>.
///Returns:
///    This function can return the standard return value E_OUTOFMEMORY, as well as the following values. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> The input monikers were composed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MK_E_SYNTAX</b></dt> </dl> </td> <td width="60%"> The two monikers could not be composed due to an error
///    in the syntax of a path (for example, if both pmkFirst and pmkRest are file monikers based on absolute paths).
///    </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CreateGenericComposite(IMoniker pmkFirst, IMoniker pmkRest, IMoniker* ppmkComposite);

///Returns the CLSID associated with the specified file name.
///Params:
///    szFilename = A pointer to the filename for which you are requesting the associated CLSID.
///    pclsid = A pointer to the location where the associated CLSID is written on return.
///Returns:
///    This function can return any of the file system errors, as well as the following values. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
///    The CLSID was retrieved successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_E_CANTOPENFILE</b></dt>
///    </dl> </td> <td width="60%"> Unable to open the specified file name. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MK_E_INVALIDEXTENSION</b></dt> </dl> </td> <td width="60%"> The specified extension in the registry is
///    invalid. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT GetClassFile(ushort* szFilename, GUID* pclsid);

///Creates a class moniker that refers to the specified class.
///Params:
///    rclsid = A reference to the CLSID of the object type to which this moniker binds.
///    ppmk = The address of an IMoniker* pointer variable that receives the interface pointer to the new class moniker. On
///           successful return, the function has called AddRef on the moniker and the caller is responsible for calling
///           Release. When an error occurs, the value of the moniker pointer is <b>NULL</b>.
///Returns:
///    This function can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The moniker has been created
///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
///    One or more arguments are invalid. </td> </tr> </table>
///    
@DllImport("OLE32")
HRESULT CreateClassMoniker(const(GUID)* rclsid, IMoniker* ppmk);

///Creates a file moniker based on the specified path.
///Params:
///    lpszPathName = The path on which this moniker is to be based. This parameter can specify a relative path, a UNC path, or a
///                   drive-letter-based path. If based on a relative path, the resulting moniker must be composed onto another file
///                   moniker before it can be bound.
///    ppmk = The address of an IMoniker* pointer variable that receives the interface pointer to the new file moniker. When
///           successful, the function has called AddRef on the file moniker and the caller is responsible for calling Release.
///           When an error occurs, the value of the interface pointer is <b>NULL</b>.
///Returns:
///    This function can return the standard return value E_OUTOFMEMORY, as well as the following values. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
///    width="60%"> The moniker was created successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MK_E_SYNTAX</b></dt> </dl> </td> <td width="60%"> There was an error in the syntax of the path. </td>
///    </tr> </table>
///    
@DllImport("OLE32")
HRESULT CreateFileMoniker(ushort* lpszPathName, IMoniker* ppmk);

///Creates an item moniker that identifies an object within a containing object (typically a compound document).
///Params:
///    lpszDelim = A pointer to a wide character string (two bytes per character) zero-terminated string containing the delimiter
///                (typically "!") used to separate this item's display name from the display name of its containing object.
///    lpszItem = A pointer to a zero-terminated string indicating the containing object's name for the object being identified.
///               This name can later be used to retrieve a pointer to the object in a call to IOleItemContainer::GetObject.
///    ppmk = The address of an IMoniker* pointer variable that receives the interface pointer to the item moniker. When
///           successful, the function has called AddRef on the item moniker and the caller is responsible for calling Release.
///           If an error occurs, the supplied interface pointer has a <b>NULL</b> value.
///Returns:
///    This function can return the standard return values E_OUTOFMEMORY and S_OK.
///    
@DllImport("OLE32")
HRESULT CreateItemMoniker(ushort* lpszDelim, ushort* lpszItem, IMoniker* ppmk);

///Creates and returns a new anti-moniker.
///Params:
///    ppmk = The address of an IMoniker* pointer variable that receives the interface pointer to the new anti-moniker. When
///           successful, the function has called AddRef on the anti-moniker and the caller is responsible for calling Release.
///           When an error occurs, the anti-moniker pointer is <b>NULL</b>.
///Returns:
///    This function can return the standard return values E_OUTOFMEMORY and S_OK.
///    
@DllImport("OLE32")
HRESULT CreateAntiMoniker(IMoniker* ppmk);

///Creates a pointer moniker based on a pointer to an object.
///Params:
///    punk = A pointer to an IUnknown interface on the object to be identified by the resulting moniker.
///    ppmk = The address of an IMoniker* pointer variable that receives the interface pointer to the new pointer moniker. When
///           successful, the function has called AddRef on the moniker and the caller is responsible for calling Release. When
///           an error occurs, the returned interface pointer has a <b>NULL</b> value.
///Returns:
///    This function can return the standard return values E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.
///    
@DllImport("OLE32")
HRESULT CreatePointerMoniker(IUnknown punk, IMoniker* ppmk);

///Creates an OBJREF moniker based on a pointer to an object.
///Params:
///    punk = A pointer to the IUnknown interface on the object that the moniker is to represent.
///    ppmk = Address of a pointer to the IMoniker interface on the OBJREF moniker that was created.
///Returns:
///    This function can return the standard return values E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.
///    
@DllImport("OLE32")
HRESULT CreateObjrefMoniker(IUnknown punk, IMoniker* ppmk);

///Returns a pointer to the IRunningObjectTable interface on the local running object table (ROT).
///Params:
///    reserved = This parameter is reserved and must be 0.
///    pprot = The address of an IRunningObjectTable* pointer variable that receives the interface pointer to the local ROT.
///            When the function is successful, the caller is responsible for calling Release on the interface pointer. If an
///            error occurs, *<i>pprot</i> is undefined.
///Returns:
///    This function can return the standard return values E_UNEXPECTED and S_OK.
///    
@DllImport("OLE32")
HRESULT GetRunningObjectTable(uint reserved, IRunningObjectTable* pprot);


// Interfaces

///Enables clients to get pointers to other interfaces on a given object through the QueryInterface method, and manage
///the existence of the object through the AddRef and Release methods. All other COM interfaces are inherited, directly
///or indirectly, from <b>IUnknown</b>. Therefore, the three methods in <b>IUnknown</b> are the first entries in the
///vtable for every interface.
@GUID("00000000-0000-0000-C000-000000000046")
interface IUnknown
{
    HRESULT QueryInterface(const(GUID)* riid, void** ppvObject);
    ///Increments the reference count for an interface pointer to a COM object. You should call this method whenever you
    ///make a copy of an interface pointer
    ///Returns:
    ///    The method returns the new reference count. This value is intended to be used only for test purposes.
    ///    
    uint    AddRef();
    ///Decrements the reference count for an interface on a COM object.
    ///Returns:
    ///    The method returns the new reference count. This value is intended to be used only for test purposes.
    ///    
    uint    Release();
}

@GUID("000E0000-0000-0000-C000-000000000046")
interface AsyncIUnknown : IUnknown
{
    HRESULT Begin_QueryInterface(const(GUID)* riid);
    HRESULT Finish_QueryInterface(void** ppvObject);
    HRESULT Begin_AddRef();
    uint    Finish_AddRef();
    HRESULT Begin_Release();
    uint    Finish_Release();
}

///Enables a class of objects to be created.
@GUID("00000001-0000-0000-C000-000000000046")
interface IClassFactory : IUnknown
{
    ///Creates an uninitialized object.
    ///Params:
    ///    pUnkOuter = If the object is being created as part of an aggregate, specify a pointer to the controlling IUnknown
    ///                interface of the aggregate. Otherwise, this parameter must be <b>NULL</b>.
    ///    riid = A reference to the identifier of the interface to be used to communicate with the newly created object. If
    ///           <i>pUnkOuter</i> is <b>NULL</b>, this parameter is generally the IID of the initializing interface; if
    ///           <i>pUnkOuter</i> is non-<b>NULL</b>, <i>riid</i> must be IID_IUnknown.
    ///    ppvObject = The address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful
    ///                return, *<i>ppvObject</i> contains the requested interface pointer. If the object does not support the
    ///                interface specified in <i>riid</i>, the implementation must set *<i>ppvObject</i> to <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as
    ///    the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The specified object was created. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>CLASS_E_NOAGGREGATION</b></dt> </dl> </td> <td width="60%"> The <i>pUnkOuter</i>
    ///    parameter was non-<b>NULL</b> and the object does not support aggregation. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The object that <i>ppvObject</i> points to
    ///    does not support the interface identified by <i>riid</i>. </td> </tr> </table>
    ///    
    HRESULT CreateInstance(IUnknown pUnkOuter, const(GUID)* riid, void** ppvObject);
    ///Locks an object application open in memory. This enables instances to be created more quickly.
    ///Params:
    ///    fLock = If <b>TRUE</b>, increments the lock count; if <b>FALSE</b>, decrements the lock count.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and S_OK.
    ///    
    HRESULT LockServer(BOOL fLock);
}

///Enables a COM object to define and manage the marshaling of its interface pointers.
@GUID("00000003-0000-0000-C000-000000000046")
interface IMarshal : IUnknown
{
    ///Retrieves the CLSID of the unmarshaling code.
    ///Params:
    ///    riid = A reference to the identifier of the interface to be marshaled.
    ///    pv = A pointer to the interface to be marshaled; can be <b>NULL</b> if the caller does not have a pointer to the
    ///         desired interface.
    ///    dwDestContext = The destination context where the specified interface is to be unmarshaled. Possible values come from the
    ///                    enumeration MSHCTX. Unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC)
    ///                    or in another process on the same computer as the current process (MSHCTX_LOCAL).
    ///    pvDestContext = This parameter is reserved and must be <b>NULL</b>.
    ///    mshlflags = Indicates whether the data to be marshaled is to be transmitted back to the client processthe typical
    ///                caseor written to a global table, where it can be retrieved by multiple clients. Possible values come
    ///                from the MSHLFLAGS enumeration.
    ///    pCid = A pointer that receives the CLSID to be used to create a proxy in the client process.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT GetUnmarshalClass(const(GUID)* riid, void* pv, uint dwDestContext, void* pvDestContext, uint mshlflags, 
                              GUID* pCid);
    ///Retrieves the maximum size of the buffer that will be needed during marshaling.
    ///Params:
    ///    riid = A reference to the identifier of the interface to be marshaled.
    ///    pv = The interface pointer to be marshaled. This parameter can be <b>NULL</b>.
    ///    dwDestContext = The destination context where the specified interface is to be unmarshaled. Possible values come from the
    ///                    enumeration MSHCTX. Unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC)
    ///                    or in another process on the same computer as the current process (MSHCTX_LOCAL).
    ///    pvDestContext = This parameter is reserved and must be <b>NULL</b>.
    ///    mshlflags = Indicates whether the data to be marshaled is to be transmitted back to the client processthe typical
    ///                caseor written to a global table, where it can be retrieved by multiple clients. Possible values come
    ///                from the MSHLFLAGS enumeration.
    ///    pSize = A pointer to a variable that receives the maximum size of the buffer.
    ///Returns:
    ///    This method can return the standard return values E_FAIL and S_OK, as well as the following value. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt>
    ///    </dl> </td> <td width="60%"> The specified interface is not supported. </td> </tr> </table>
    ///    
    HRESULT GetMarshalSizeMax(const(GUID)* riid, void* pv, uint dwDestContext, void* pvDestContext, uint mshlflags, 
                              uint* pSize);
    ///Marshals an interface pointer.
    ///Params:
    ///    pStm = A pointer to the stream to be used during marshaling.
    ///    riid = A reference to the identifier of the interface to be marshaled. This interface must be derived from the
    ///           IUnknown interface.
    ///    pv = A pointer to the interface pointer to be marshaled. This parameter can be <b>NULL</b> if the caller does not
    ///         have a pointer to the desired interface.
    ///    dwDestContext = The destination context where the specified interface is to be unmarshaled. Possible values for
    ///                    <i>dwDestContext</i> come from the enumeration MSHCTX. Currently, unmarshaling can occur either in another
    ///                    apartment of the current process (MSHCTX_INPROC) or in another process on the same computer as the current
    ///                    process (MSHCTX_LOCAL).
    ///    pvDestContext = This parameter is reserved and must be 0.
    ///    mshlflags = Indicates whether the data to be marshaled is to be transmitted back to the client processthe typical
    ///                caseor written to a global table, where it can be retrieved by multiple clients. Possible values come from
    ///                the MSHLFLAGS enumeration.
    ///Returns:
    ///    This method can return the standard return value E_FAIL, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The interface pointer was marshaled successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The specified interface is not supported. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>STG_E_MEDIUMFULL</b></dt> </dl> </td> <td width="60%"> The stream is
    ///    full. </td> </tr> </table>
    ///    
    HRESULT MarshalInterface(IStream pStm, const(GUID)* riid, void* pv, uint dwDestContext, void* pvDestContext, 
                             uint mshlflags);
    ///Unmarshals an interface pointer.
    ///Params:
    ///    pStm = A pointer to the stream from which the interface pointer is to be unmarshaled.
    ///    riid = A reference to the identifier of the interface to be unmarshaled.
    ///    ppv = The address of pointer variable that receives the interface pointer. Upon successful return, *<i>ppv</i>
    ///          contains the requested interface pointer of the interface to be unmarshaled.
    ///Returns:
    ///    This method can return the standard return value E_FAIL, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The interface pointer was unmarshaled successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The specified interface is not supported. </td>
    ///    </tr> </table>
    ///    
    HRESULT UnmarshalInterface(IStream pStm, const(GUID)* riid, void** ppv);
    ///Destroys a marshaled data packet.
    ///Params:
    ///    pStm = A pointer to a stream that contains the data packet to be destroyed.
    ///Returns:
    ///    This method can return the standard return values S_OK and E_FAIL, as well as any of the stream-access errors
    ///    for the IStream interface.
    ///    
    HRESULT ReleaseMarshalData(IStream pStm);
    ///Releases all connections to an object. The object's server calls the object's implementation of this method prior
    ///to shutting down.
    ///Params:
    ///    dwReserved = This parameter is reserved and must be 0.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.
    ///    
    HRESULT DisconnectObject(uint dwReserved);
}

///Marks an object that doesn't support being marshaled or stored in the Global Interface Table.
@GUID("ECC8691B-C1DB-4DC0-855E-65F6C551AF49")
interface INoMarshal : IUnknown
{
}

///Marks an interface as agile across apartments.
@GUID("94EA2B94-E9CC-49E0-C0FF-EE64CA8F5B90")
interface IAgileObject : IUnknown
{
}

@GUID("00000017-0000-0000-C000-000000000046")
interface IActivationFilter : IUnknown
{
    HRESULT HandleActivation(uint dwActivationType, const(GUID)* rclsid, GUID* pReplacementClsId);
}

@GUID("000001CF-0000-0000-C000-000000000046")
interface IMarshal2 : IMarshal
{
}

///Allocates, frees, and manages memory.
@GUID("00000002-0000-0000-C000-000000000046")
interface IMalloc : IUnknown
{
    ///Allocates a block of memory.
    ///Params:
    ///    cb = The size of the memory block to be allocated, in bytes.
    ///Returns:
    ///    If the method succeeds, the return value is a pointer to the allocated block of memory. Otherwise, it is
    ///    <b>NULL</b>. Applications should always check the return value from this method, even when requesting small
    ///    amounts of memory, because there is no guarantee the memory will be allocated.
    ///    
    void*  Alloc(size_t cb);
    ///Changes the size of a previously allocated block of memory.
    ///Params:
    ///    pv = A pointer to the block of memory to be reallocated. This parameter can be <b>NULL</b>, as discussed in the
    ///         Remarks section below.
    ///    cb = The size of the memory block to be reallocated, in bytes. This parameter can be 0, as discussed in the
    ///         Remarks section below.
    ///Returns:
    ///    If the method succeeds, the return value is a pointer to the reallocated block of memory. Otherwise, it is
    ///    <b>NULL</b>.
    ///    
    void*  Realloc(void* pv, size_t cb);
    ///Frees a previously allocated block of memory.
    ///Params:
    ///    pv = A pointer to the memory block to be freed. If this parameter is <b>NULL</b>, this method has no effect.
    void   Free(void* pv);
    ///Retrieves the size of a previously allocated block of memory.
    ///Params:
    ///    pv = A pointer to the block of memory.
    ///Returns:
    ///    The size of the allocated memory block in bytes or, if <i>pv</i> is a <b>NULL</b> pointer, -1.
    ///    
    size_t GetSize(void* pv);
    ///Determines whether this allocator was used to allocate the specified block of memory.
    ///Params:
    ///    pv = A pointer to the block of memory. If this parameter is a <b>NULL</b> pointer, -1 is returned.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>1</dt> </dl> </td> <td width="60%"> The block of memory was allocated by this
    ///    allocator. </td> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> The block of memory
    ///    was not allocated by this allocator. </td> </tr> <tr> <td width="40%"> <dl> <dt>-1</dt> </dl> </td> <td
    ///    width="60%"> This method cannot determine whether this allocator allocated the block of memory. </td> </tr>
    ///    </table>
    ///    
    int    DidAlloc(void* pv);
    ///Minimizes the heap as much as possible by releasing unused memory to the operating system, coalescing adjacent
    ///free blocks, and committing free pages.
    void   HeapMinimize();
}

///Retrieves the CLSID identifying the handler to be used in the destination process during standard marshaling.
@GUID("00000018-0000-0000-C000-000000000046")
interface IStdMarshalInfo : IUnknown
{
    ///Retrieves the CLSID of the object handler to be used in the destination process during standard marshaling.
    ///Params:
    ///    dwDestContext = The destination context, that is, the process in which the unmarshaling will be done. Possible values are
    ///                    taken from the enumeration MSHCTX.
    ///    pvDestContext = This parameter must be <b>NULL</b>.
    ///    pClsid = A pointer to the handler's CLSID.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.
    ///    
    HRESULT GetClassForHandler(uint dwDestContext, void* pvDestContext, GUID* pClsid);
}

///Manages a server object's count of marshaled, or external, connections. A server that maintains such a count can
///detect when it has no external connections and shut itself down in an orderly fashion.
@GUID("00000019-0000-0000-C000-000000000046")
interface IExternalConnection : IUnknown
{
    ///Increments the count of an object's strong external connections.
    ///Params:
    ///    extconn = The type of external connection to the object. The only type of external connection currently supported by
    ///              this interface is strong, which means that the object must remain alive as long as this external connection
    ///              exists. Strong external connections are represented by the value EXTCONN_STRONG, which is defined in the
    ///              enumeration EXTCONN.
    ///    reserved = Information about the connection. This parameter is reserved for use by OLE. Its value can be zero, but not
    ///               necessarily. Therefore, implementations of <b>AddConnection</b> should not contain blocks of code whose
    ///               execution depends on whether a zero value is returned.
    ///Returns:
    ///    The method returns the count of connections. This value is intended to be used only for debugging purposes.
    ///    
    uint AddConnection(uint extconn, uint reserved);
    ///Decrements the count of an object's strong external connections.
    ///Params:
    ///    extconn = The type of external connection to the object. The only type of external connection currently supported by
    ///              this interface is strong, which means that the object must remain alive as long as this external connection
    ///              exists. Strong external connections are represented by the value EXTCONN_STRONG, which is defined in the
    ///              enumeration EXTCONN.
    ///    reserved = Information about the connection. This parameter is reserved for use by OLE. Its value can be zero, but not
    ///               necessarily. Therefore, implementations of <b>ReleaseConnection</b> should not contain blocks of code whose
    ///               execution depends on whether a zero value is returned.
    ///    fLastReleaseCloses = This parameter is <b>TRUE</b> if the connection being released is the last external lock on the object, and
    ///                         therefore the object should close. Otherwise, the object should remain open until closed by the user or
    ///                         another process.
    ///Returns:
    ///    The method returns the count of connections. This value is intended to be used only for debugging purposes.
    ///    
    uint ReleaseConnection(uint extconn, uint reserved, BOOL fLastReleaseCloses);
}

///Enables a client to query an object proxy, or handler, for multiple interfaces by using a single RPC call. By using
///this interface, instead of relying on separate calls to IUnknown::QueryInterface, clients can reduce the number of
///RPC calls that have to cross thread, process, or machine boundaries and, therefore, the amount of time required to
///obtain the requested interface pointers.
@GUID("00000020-0000-0000-C000-000000000046")
interface IMultiQI : IUnknown
{
    ///Retrieves pointers to multiple supported interfaces on an object. Calling this method is equivalent to issuing a
    ///series of separate QueryInterface calls except that you do not incur the overhead of a corresponding number of
    ///RPC calls. In multithreaded applications and distributed environments, keeping RPC calls to a minimum is
    ///essential for optimal performance.
    ///Params:
    ///    cMQIs = The number of elements in the <i>pMQIs</i> array.
    ///    pMQIs = An array of MULTI_QI structures. For more information, see Remarks.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method retrieved pointers to
    ///    all requested interfaces. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> The method retrieved pointers to some, but not all, of the requested interfaces. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The method retrieved
    ///    pointers to none of the requested interfaces. </td> </tr> </table>
    ///    
    HRESULT QueryMultipleInterfaces(uint cMQIs, char* pMQIs);
}

@GUID("000E0020-0000-0000-C000-000000000046")
interface AsyncIMultiQI : IUnknown
{
    HRESULT Begin_QueryMultipleInterfaces(uint cMQIs, char* pMQIs);
    HRESULT Finish_QueryMultipleInterfaces(char* pMQIs);
}

///Used exclusively in lightweight client-side handlers that require access to some of the internal interfaces on the
///proxy.
@GUID("00000021-0000-0000-C000-000000000046")
interface IInternalUnknown : IUnknown
{
    ///Retrieves pointers to the supported internal interfaces on an object.
    ///Params:
    ///    riid = The identifier of the internal interface being requested.
    ///    ppv = The address of a pointer variable that receives the interface pointer requested in the <i>riid</i> parameter.
    ///          Upon successful return, *<i>ppv</i> contains the requested interface pointer to the object. If the object
    ///          does not support the interface, *<i>ppv</i> is set to <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK if the interface is supported, and E_NOINTERFACE otherwise.
    ///    
    HRESULT QueryInternalInterface(const(GUID)* riid, void** ppv);
}

///Enumerates objects with the IUnknown interface. It can be used to enumerate through the objects in a component
///containing multiple objects.
@GUID("00000100-0000-0000-C000-000000000046")
interface IEnumUnknown : IUnknown
{
    ///Retrieves the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be retrieved. If there are fewer than the requested number of items left in the
    ///           sequence, this method retrieves the remaining elements.
    ///    rgelt = An array of enumerated items. The enumerator is responsible for calling AddRef, and the caller is responsible
    ///            for calling Release through each pointer enumerated. If <i>celt</i> is greater than 1, the caller must also
    ///            pass a non-NULL pointer passed to <i>pceltFetched</i> to know how many pointers to release.
    ///    pceltFetched = The number of items that were retrieved. This parameter is always less than or equal to the number of items
    ///                   requested.
    ///Returns:
    ///    If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Skips over the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be skipped.
    ///Returns:
    ///    If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Skip(uint celt);
    ///Resets the enumeration sequence to the beginning.
    ///Returns:
    ///    The return value is S_OK.
    ///    
    HRESULT Reset();
    ///Creates a new enumerator that contains the same enumeration state as the current one. This method makes it
    ///possible to record a point in the enumeration sequence in order to return to that point at a later time. The
    ///caller must release this new enumerator separately from the first enumerator.
    ///Params:
    ///    ppenum = A pointer to the cloned enumerator object.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.
    ///    
    HRESULT Clone(IEnumUnknown* ppenum);
}

///Enumerate strings. <b>LPWSTR</b> is the type that indicates a pointer to a zero-terminated string of wide, or
///Unicode, characters.
@GUID("00000101-0000-0000-C000-000000000046")
interface IEnumString : IUnknown
{
    ///Retrieves the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be retrieved. If there are fewer than the requested number of items left in the
    ///           sequence, this method retrieves the remaining elements.
    ///    rgelt = An array of enumerated items. The enumerator is responsible for allocating any memory, and the caller is
    ///            responsible for freeing it. If <i>celt</i> is greater than 1, the caller must also pass a non-NULL pointer
    ///            passed to <i>pceltFetched</i> to know how many pointers to release.
    ///    pceltFetched = The number of items that were retrieved. This parameter is always less than or equal to the number of items
    ///                   requested.
    ///Returns:
    ///    If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Skips over the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be skipped.
    ///Returns:
    ///    If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Skip(uint celt);
    ///Resets the enumeration sequence to the beginning.
    ///Returns:
    ///    The return value is S_OK.
    ///    
    HRESULT Reset();
    ///Creates a new enumerator that contains the same enumeration state as the current one. This method makes it
    ///possible to record a point in the enumeration sequence in order to return to that point at a later time. The
    ///caller must release this new enumerator separately from the first enumerator.
    ///Params:
    ///    ppenum = A pointer to the cloned enumerator object.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.
    ///    
    HRESULT Clone(IEnumString* ppenum);
}

///Marshals data between a COM client proxy and a COM server stub.
@GUID("D5F56B60-593B-101A-B569-08002B2DBF7A")
interface IRpcChannelBuffer : IUnknown
{
    ///Retrieves a buffer into which data can be marshaled for transmission.
    ///Params:
    ///    pMessage = A pointer to an RPCOLEMESSAGE data structure.
    ///    riid = A reference to the identifier of the interface to be marshaled.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT GetBuffer(RPCOLEMESSAGE* pMessage, const(GUID)* riid);
    ///Sends a method invocation across an RPC channel to the server stub.
    ///Params:
    ///    pMessage = A pointer to an RPCOLEMESSAGE structure that has been populated with marshaled data.
    ///    pStatus = If not <b>NULL</b>, set to 0 on successful execution.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT SendReceive(RPCOLEMESSAGE* pMessage, uint* pStatus);
    ///Frees a previously allocated RPC channel buffer.
    ///Params:
    ///    pMessage = A pointer to an RPCOLEMESSAGE data structure.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT FreeBuffer(RPCOLEMESSAGE* pMessage);
    ///Retrieves the destination context for the RPC channel.
    ///Params:
    ///    pdwDestContext = The destination context in which the interface is unmarshaled. Possible values come from the MSHCTX
    ///                     enumeration.
    ///    ppvDestContext = This parameter is reserved and must be <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT GetDestCtx(uint* pdwDestContext, void** ppvDestContext);
    ///Determines whether the RPC channel is connected.
    ///Returns:
    ///    If the RPC channel exists, the return value is <b>TRUE</b>. Otherwise, it is <b>FALSE</b>.
    ///    
    HRESULT IsConnected();
}

@GUID("594F31D0-7F19-11D0-B194-00A0C90DC8BF")
interface IRpcChannelBuffer2 : IRpcChannelBuffer
{
    HRESULT GetProtocolVersion(uint* pdwVersion);
}

@GUID("A5029FB6-3C34-11D1-9C99-00C04FB998AA")
interface IAsyncRpcChannelBuffer : IRpcChannelBuffer2
{
    HRESULT Send(RPCOLEMESSAGE* pMsg, ISynchronize pSync, uint* pulStatus);
    HRESULT Receive(RPCOLEMESSAGE* pMsg, uint* pulStatus);
    HRESULT GetDestCtxEx(RPCOLEMESSAGE* pMsg, uint* pdwDestContext, void** ppvDestContext);
}

@GUID("25B15600-0115-11D0-BF0D-00AA00B8DFD2")
interface IRpcChannelBuffer3 : IRpcChannelBuffer2
{
    HRESULT Send(RPCOLEMESSAGE* pMsg, uint* pulStatus);
    HRESULT Receive(RPCOLEMESSAGE* pMsg, uint ulSize, uint* pulStatus);
    HRESULT Cancel(RPCOLEMESSAGE* pMsg);
    HRESULT GetCallContext(RPCOLEMESSAGE* pMsg, const(GUID)* riid, void** pInterface);
    HRESULT GetDestCtxEx(RPCOLEMESSAGE* pMsg, uint* pdwDestContext, void** ppvDestContext);
    HRESULT GetState(RPCOLEMESSAGE* pMsg, uint* pState);
    HRESULT RegisterAsync(RPCOLEMESSAGE* pMsg, IAsyncManager pAsyncMgr);
}

@GUID("58A08519-24C8-4935-B482-3FD823333A4F")
interface IRpcSyntaxNegotiate : IUnknown
{
    HRESULT NegotiateSyntax(RPCOLEMESSAGE* pMsg);
}

///Controls the RPC proxy used to marshal data between COM components.
@GUID("D5F56A34-593B-101A-B569-08002B2DBF7A")
interface IRpcProxyBuffer : IUnknown
{
    ///Initializes a client proxy, binding it to the specified RPC channel.
    ///Params:
    ///    pRpcChannelBuffer = A pointer to the IRpcChannelBuffer interface that the proxy uses to marshal data.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT Connect(IRpcChannelBuffer pRpcChannelBuffer);
    ///Disconnects a client proxy from any RPC channel to which it is connected.
    void    Disconnect();
}

///Controls the RPC stub used to marshal data between COM components.
@GUID("D5F56AFC-593B-101A-B569-08002B2DBF7A")
interface IRpcStubBuffer : IUnknown
{
    ///Initializes a server stub, binding it to the specified interface.
    ///Params:
    ///    pUnkServer = A pointer to the interface.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT Connect(IUnknown pUnkServer);
    ///Disconnects a server stub from any interface to which it is connected.
    void    Disconnect();
    ///Invokes the interface that a stub represents.
    ///Params:
    ///    _prpcmsg = A pointer to an RPCOLEMESSAGE data structure containing the marshaled invocation arguments.
    ///    _pRpcChannelBuffer = A pointer to an IRpcChannelBuffer interface that controls an RPC marshaling channel.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT Invoke(RPCOLEMESSAGE* _prpcmsg, IRpcChannelBuffer _pRpcChannelBuffer);
    ///Determines whether a stub is designed to handle the unmarshaling of a particular interface.
    ///Params:
    ///    riid = The IID of the interface. This parameter cannot be IID_IUnknown.
    ///Returns:
    ///    If the stub can handle the indicated interface, then this method returns an IRpcStubBuffer pointer for that
    ///    interface; otherwise, it returns <b>NULL</b>.
    ///    
    IRpcStubBuffer IsIIDSupported(const(GUID)* riid);
    ///Retrieves the total number of references that a stub has on the server object to which it is connected.
    ///Returns:
    ///    This method returns the total number of references that a stub has on the server object to which it is
    ///    connected.
    ///    
    uint    CountRefs();
    ///Retrieves a pointer to the interface that a stub represents.
    ///Params:
    ///    ppv = A pointer to the interface that the stub represents.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT DebugServerQueryInterface(void** ppv);
    ///Releases an interface pointer that was previously returned by DebugServerQueryInterface.
    ///Params:
    ///    pv = A pointer to the interface that the caller no longer needs.
    void    DebugServerRelease(void* pv);
}

///Provides custom methods for the creation of COM object proxies and stubs. This interface is not marshalable.
@GUID("D5F569D0-593B-101A-B569-08002B2DBF7A")
interface IPSFactoryBuffer : IUnknown
{
    ///Creates a proxy for the specified remote interface.
    ///Params:
    ///    pUnkOuter = A controlling IUnknown interface; used for aggregation.
    ///    riid = The identifier of the interface to proxy.
    ///    ppProxy = A pointer to an IRpcProxyBuffer interface to control marshaling.
    ///    ppv = A pointer to the interface specified by <i>riid</i>.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT CreateProxy(IUnknown pUnkOuter, const(GUID)* riid, IRpcProxyBuffer* ppProxy, void** ppv);
    ///Creates a stub for the remote use of the specified interface.
    ///Params:
    ///    riid = The identifier of the interface for which a stub is to be created.
    ///    pUnkServer = A controlling IUnknown interface; used for aggregation.
    ///    ppStub = A pointer to an IRpcStubBuffer interface pointer to control marshaling.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT CreateStub(const(GUID)* riid, IUnknown pUnkServer, IRpcStubBuffer* ppStub);
}

@GUID("1008C4A0-7613-11CF-9AF1-0020AF6E72F4")
interface IChannelHook : IUnknown
{
    void ClientGetSize(const(GUID)* uExtent, const(GUID)* riid, uint* pDataSize);
    void ClientFillBuffer(const(GUID)* uExtent, const(GUID)* riid, uint* pDataSize, void* pDataBuffer);
    void ClientNotify(const(GUID)* uExtent, const(GUID)* riid, uint cbDataSize, void* pDataBuffer, uint lDataRep, 
                      HRESULT hrFault);
    void ServerNotify(const(GUID)* uExtent, const(GUID)* riid, uint cbDataSize, void* pDataBuffer, uint lDataRep);
    void ServerGetSize(const(GUID)* uExtent, const(GUID)* riid, HRESULT hrFault, uint* pDataSize);
    void ServerFillBuffer(const(GUID)* uExtent, const(GUID)* riid, uint* pDataSize, void* pDataBuffer, 
                          HRESULT hrFault);
}

///Gives the client control over the security settings for each individual interface proxy of an object.
@GUID("0000013D-0000-0000-C000-000000000046")
interface IClientSecurity : IUnknown
{
    ///Retrieves authentication information the client uses to make calls on the specified proxy.
    ///Params:
    ///    pProxy = A pointer to the proxy. This parameter cannot be <b>NULL</b>. For more information, see the Remarks section.
    ///    pAuthnSvc = The current authentication service. This will be a single value taken from the list of authentication service
    ///                constants. This parameter cannot be <b>NULL</b>.
    ///    pAuthzSvc = The current authorization service. This will be a single value taken from the list of authorization
    ///                constants. This parameter cannot be <b>NULL</b>.
    ///    pServerPrincName = The current principal name. The string will be allocated by the callee using the CoTaskMemAlloc function and
    ///                       must be freed by the caller using the CoTaskMemFree function. Note that the actual principal name is
    ///                       returned. The EOAC_MAKE_FULLSIC flag is not accepted to convert the prinicpal name. If the caller specifies
    ///                       <b>NULL</b>, the current principal name is not retrieved.
    ///    pAuthnLevel = The current authentication level. This will be a single value taken from the list of authentication level
    ///                  constants. If this parameter is <b>NULL</b>, the current authentication level is not retrieved.
    ///    pImpLevel = The current impersonation level. This will be a single value taken from the list of impersonation level
    ///                constants. If this parameter is <b>NULL</b>, the current impersonation level is not retrieved.
    ///    pAuthInfo = A pointer to a handle indicating the identity of the client that was passed to the last
    ///                IClientSecurity::SetBlanket call (or the default value). Default values are only valid until the proxy is
    ///                released. If the caller specifies <b>NULL</b>, the client identity is not retrieved. The format of the
    ///                structure that the returned handle refers to depends on the authentication service. For NTLMSSP and Kerberos,
    ///                if the client specified a structure in the <i>pAuthInfo</i> parameter to CoInitializeSecurity, that value is
    ///                returned. For Schannel, if a certificate for the client could be retrieved from the certificate manager, that
    ///                value is returned here. Otherwise, <b>NULL</b> is returned. Because this points to the value itself and is
    ///                not a copy, it should not be manipulated or freed.
    ///    pCapabilites = The capabilities of the proxy. These flags are defined in the EOLE_AUTHENTICATION_CAPABILITIES enumeration.
    ///                   If this parameter is <b>NULL</b>, the current capability flags are not retrieved.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One or more arguments are not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is insufficient memory to create the
    ///    <i>pServerPrincName</i> buffer. </td> </tr> </table>
    ///    
    HRESULT QueryBlanket(IUnknown pProxy, uint* pAuthnSvc, uint* pAuthzSvc, ushort** pServerPrincName, 
                         uint* pAuthnLevel, uint* pImpLevel, void** pAuthInfo, uint* pCapabilites);
    ///Sets the authentication information (the security blanket) that will be used to make calls on the specified
    ///proxy. This setting overrides the process default settings for the specified proxy. Calling this method changes
    ///the security values for all other users of the specified proxy.
    ///Params:
    ///    pProxy = A pointer to the proxy.
    ///    dwAuthnSvc = The authentication service. This will be a single value taken from the list of authentication service
    ///                 constants. If no authentication is required, use RPC_C_AUTHN_NONE. If RPC_C_AUTHN_DEFAULT is specified, COM
    ///                 will pick an authentication service following its normal security blanket negotiation algorithm.
    ///    dwAuthzSvc = The authorization service. This will be a single value taken from the list of authorization constants. If
    ///                 RPC_C_AUTHZ_DEFAULT is specified, COM will pick an authorization service following its normal security
    ///                 blanket negotiation algorithm. If NTLMSSP, Kerberos, or Schannel is used as the authentication service,
    ///                 RPC_C_AUTHZ_NONE should be used as the authorization service.
    ///    pServerPrincName = The server principal name. If COLE_DEFAULT_PRINCIPAL is specified, DCOM will pick a principal name using its
    ///                       security blanket negotiation algorithm. If Kerberos is used as the authentication service, this parameter
    ///                       must be the correct principal name of the server or the call will fail. If Schannel is used as the
    ///                       authentication service, this value must be one of the msstd or fullsic forms described in Principal Names, or
    ///                       <b>NULL</b> if you do not want mutual authentication. Generally, specifying <b>NULL</b> will not reset server
    ///                       principal name on the proxy, rather, the previous setting will be retained. You must exercise care when using
    ///                       <b>NULL</b> as <i>pServerPrincName</i> when selecting a different authentication service for the proxy,
    ///                       because there is no guarantee that the previously set principal name would be valid for the newly selected
    ///                       authentication service.
    ///    dwAuthnLevel = The authentication level. This will be a single value taken from the list of authentication level constants.
    ///                   If RPC_C_AUTHN_LEVEL_DEFAULT is specified, COM will pick an authentication level following its normal
    ///                   security blanket negotiation algorithm. If this value is set to RPC_C_AUTHN_LEVEL_NONE, the authentication
    ///                   service must be RPC_C_AUTHN_NONE. Each authentication service may choose to use a higher security
    ///                   authentication level than the one specified.
    ///    dwImpLevel = The impersonation level. This will be a single value taken from the list of impersonation level constants. If
    ///                 RPC_C_IMP_LEVEL_DEFAULT is specified, COM will pick an impersonation level following its normal security
    ///                 blanket negotiation algorithm. If you are using NTLMSSP remotely, this value must be
    ///                 RPC_C_IMP_LEVEL_IMPERSONATE or RPC_C_IMP_LEVEL_IDENTIFY. When using NTLMSSP on the same computer,
    ///                 RPC_C_IMP_LEVEL_DELEGATE is also supported. For Kerberos, this value can be RPC_C_IMP_LEVEL_IDENTIFY,
    ///                 RPC_C_IMP_LEVEL_IMPERSONATE, or RPC_C_IMP_LEVEL_DELEGATE. For Schannel, this value must be
    ///                 RPC_C_IMP_LEVEL_IMPERSONATE.
    ///    pAuthInfo = An RPC_AUTH_IDENTITY_HANDLE value that indicates the identity of the client. This parameter is not used for
    ///                calls on the same computer. If <i>pAuthInfo</i> is <b>NULL</b>, COM uses the current proxy identity, which is
    ///                either the process token, the impersonation token, or the authentication identity from the
    ///                CoInitializeSecurity function. If the handle is not <b>NULL</b>, that identity is used. The format of the
    ///                structure referred to by the handle depends on the provider of the authentication service. For NTLMSSP or
    ///                Kerberos, the structure is a SEC_WINNT_AUTH_IDENTITY or SEC_WINNT_AUTH_IDENTITY_EX structure. If the client
    ///                obtains the credentials set on the proxy by calling CoQueryProxyBlanket, it must ensure that the memory
    ///                remains valid and unchanged until a different identity is set on the proxy or all proxies on the object are
    ///                released. If this parameter is <b>NULL</b>, COM uses the current proxy identity (which is either the process
    ///                token or the impersonation token). If the handle refers to a structure, that identity is used. For Schannel,
    ///                this parameter must either be a pointer to a CERT_CONTEXT structure that contains the client's X.509
    ///                certificate, or <b>NULL</b> if the client wishes to make an anonymous connection to the server. If a
    ///                certificate is specified, the caller must not free it as long as any proxy to the object exists in the
    ///                current apartment. For Snego, this member is either <b>NULL</b>, points to a SEC_WINNT_AUTH_IDENTITY
    ///                structure, or points to a SEC_WINNT_AUTH_IDENTITY_EX structure. If it is <b>NULL</b>, Snego will pick a list
    ///                of authentication services based on those available on the client computer. If it points to a
    ///                <b>SEC_WINNT_AUTH_IDENTITY_EX</b> structure, the structure's <b>PackageList</b> member must point to a string
    ///                containing a comma-separated list of authentication service names and the <b>PackageListLength</b> member
    ///                must give the number of bytes in the <b>PackageList</b> string. If <b>PackageList</b> is <b>NULL</b>, all
    ///                calls using Snego will fail. If COLE_DEFAULT_AUTHINFO is specified, COM will pick the authentication
    ///                information following its normal security blanket negotiation algorithm. <b>SetBlanket</b> will return an
    ///                error if both <i>pAuthInfo</i> is set and one of the cloaking flags is set in <i>dwCapabilities</i>.
    ///    dwCapabilities = The capabilities of this proxy. Capability flags are defined in the EOLE_AUTHENTICATION_CAPABILITIES
    ///                     enumeration. The only flags that can be set through this method are EOAC_MUTUAL_AUTH, EOAC_STATIC_CLOAKING,
    ///                     EOAC_DYNAMIC_CLOAKING, EOAC_ANY_AUTHORITY (this flag is deprecated), EOAC_MAKE_FULLSIC, and EOAC_DEFAULT.
    ///                     Either EOAC_STATIC_CLOAKING or EOAC_DYNAMIC_CLOAKING can be set if <i>pAuthInfo</i> is not set and Schannel
    ///                     is not the authentication service. (See Cloaking for more information.) If any capability flags other than
    ///                     those mentioned here are indicated, <b>SetBlanket</b> will return an error.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One or more arguments are not valid. </td> </tr> </table>
    ///    
    HRESULT SetBlanket(IUnknown pProxy, uint dwAuthnSvc, uint dwAuthzSvc, ushort* pServerPrincName, 
                       uint dwAuthnLevel, uint dwImpLevel, void* pAuthInfo, uint dwCapabilities);
    ///Makes a private copy of the proxy for the specified interface.
    ///Params:
    ///    pProxy = A pointer to the interface whose proxy is to be copied. This parameter cannot be <b>NULL</b>.
    ///    ppCopy = A pointer to the IUnknown interface pointer that receives the copy of the proxy. This parameter cannot be
    ///             <b>NULL</b>.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One or more arguments are not valid. </td> </tr> </table>
    ///    
    HRESULT CopyProxy(IUnknown pProxy, IUnknown* ppCopy);
}

///Used by a server to help authenticate the client and to manage impersonation of the client.
@GUID("0000013E-0000-0000-C000-000000000046")
interface IServerSecurity : IUnknown
{
    ///Retrieves information about the client that invoked one of the server's methods.
    ///Params:
    ///    pAuthnSvc = A pointer to the current authentication service. This will be a single value taken from the list of
    ///                authentication service constants. If the caller specifies <b>NULL</b>, the current authentication service is
    ///                not retrieved.
    ///    pAuthzSvc = A pointer to a variable that receives the current authorization service. This will be a single value from the
    ///                list of authorization constants. If the caller specifies <b>NULL</b>, the current authorization service is
    ///                not retrieved.
    ///    pServerPrincName = The current principal name. The string will be allocated by the callee using CoTaskMemAlloc, and must be
    ///                       freed by the caller using CoTaskMemFree. By default, Schannel principal names will be in the msstd form. The
    ///                       fullsic form will be returned if EOAC_MAKE_FULLSIC is specified in the <i>pCapabilities</i> parameter. For
    ///                       more information on the msstd and fullsic forms, see Principal Names. If the caller specifies <b>NULL</b>,
    ///                       the current principal name is not retrieved.
    ///    pAuthnLevel = A pointer to a variable that receives the current authentication level. This will be a single value taken
    ///                  from the list of authentication level constants. If the caller specifies <b>NULL</b>, the current
    ///                  authentication level is not retrieved.
    ///    pImpLevel = This parameter must be <b>NULL</b>.
    ///    pPrivs = The privilege information for the client application. The format of the structure that the handle refers to
    ///             depends on the authentication service. The application should not write or free the memory. The information
    ///             is only valid for the duration of the current call. For NTLMSSP, and Kerberos, this is a
    ///             SEC_WINNT_AUTH_IDENTITY or SEC_WINNT_AUTH_IDENTITY_EX structure. For Schannel, this is a CERT_CONTEXT
    ///             structure that represents the client's certificate. If the client has no certificate, <b>NULL</b> is
    ///             returned. If the caller specifies <b>NULL</b>, the current privilege information is not retrieved.
    ///    pCapabilities = The capabilities of the call. To request that the principal name be returned in fullsic form if Schannel is
    ///                    the authentication service, the caller can set the EOAC_MAKE_FULLSIC flag in this parameter. If the caller
    ///                    specifies <b>NULL</b>, the current capabilities are not retrieved.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.
    ///    
    HRESULT QueryBlanket(uint* pAuthnSvc, uint* pAuthzSvc, ushort** pServerPrincName, uint* pAuthnLevel, 
                         uint* pImpLevel, void** pPrivs, uint* pCapabilities);
    ///Enables a server to impersonate a client for the duration of a call.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.
    ///    
    HRESULT ImpersonateClient();
    ///Restores the authentication information of a thread to what it was before impersonation began.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.
    ///    
    HRESULT RevertToSelf();
    ///Indicates whether the server is currently impersonating the client.
    ///Returns:
    ///    If the thread is currently impersonating, the return value is <b>TRUE</b>. Otherwise, it is <b>FALSE</b>.
    ///    
    BOOL    IsImpersonating();
}

///Enables callers to set or query the values of various properties that control how COM handles remote procedure calls
///(RPC).
@GUID("00000144-0000-0000-C000-000000000046")
interface IRpcOptions : IUnknown
{
    ///Sets the value of an RPC binding option property.
    ///Params:
    ///    pPrx = A pointer to the proxy whose property is being set.
    ///    dwProperty = An identifier of the property to be set, which must be COMBND_RPCTIMEOUT.
    ///    dwValue = The new value of the property.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT Set(IUnknown pPrx, RPCOPT_PROPERTIES dwProperty, size_t dwValue);
    ///Retrieves the value of an RPC binding option property.
    ///Params:
    ///    pPrx = A pointer to the proxy whose property is being queried.
    ///    dwProperty = An identifier of the property to be queried, which must be COMBND_RPCTIMEOUT or COMBND_SERVER_LOCALITY (this
    ///                 flag is available starting with Windows Server 2003.)
    ///    pdwValue = A pointer to the property value.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT Query(IUnknown pPrx, RPCOPT_PROPERTIES dwProperty, size_t* pdwValue);
}

///Sets and queries global properties of the Component Object Model (COM) runtime.
@GUID("0000015B-0000-0000-C000-000000000046")
interface IGlobalOptions : IUnknown
{
    ///Sets the specified global property of the COM runtime.
    ///Params:
    ///    dwProperty = The global property of the COM runtime. For a list of properties that can be set with this method, see
    ///                 IGlobalOptions.
    ///    dwValue = The value of the property.<div class="alert"><b>Important</b> For the COMGLB_APPID property, this parameter
    ///              must specify a pointer to the APPID GUID.</div> <div> </div>
    ///Returns:
    ///    The return value is S_OK if the property was set successfully.
    ///    
    HRESULT Set(GLOBALOPT_PROPERTIES dwProperty, size_t dwValue);
    ///Queries the specified global property of the COM runtime.
    ///Params:
    ///    dwProperty = The global property of the COM runtime. For a list of properties that can be set with this method, see
    ///                 IGlobalOptions.
    ///    pdwValue = The value of the property.<div class="alert"><b>Important</b> For the COMGLB_APPID property, this parameter
    ///               receives a pointer to the AppID GUID.</div> <div> </div>
    ///Returns:
    ///    The return value is S_OK if the property is queried successfully.
    ///    
    HRESULT Query(GLOBALOPT_PROPERTIES dwProperty, size_t* pdwValue);
}

///Used to dynamically load new DLL servers into an existing surrogate and free the surrogate when it is no longer
///needed.
@GUID("00000022-0000-0000-C000-000000000046")
interface ISurrogate : IUnknown
{
    ///Loads a DLL server into the implementing surrogate. COM calls this method when there is an activation request for
    ///the DLL server's class, if the class is registered as DllSurrogate.
    ///Params:
    ///    Clsid = The CLSID of the DLL server to be loaded.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.
    ///    
    HRESULT LoadDllServer(const(GUID)* Clsid);
    ///Unloads a DLL server.
    ///Returns:
    ///    This method can return the standard return values E_UNEXPECTED, E_FAIL, and S_OK.
    ///    
    HRESULT FreeSurrogate();
}

///Enables any apartment in a process to get access to an interface implemented on an object in any other apartment in
///the process.
@GUID("00000146-0000-0000-C000-000000000046")
interface IGlobalInterfaceTable : IUnknown
{
    ///Registers the specified interface on an object residing in one apartment of a process as a global interface,
    ///enabling other apartments access to that interface.
    ///Params:
    ///    pUnk = An interface pointer of type <i>riid</i> on the object on which the interface to be registered as global is
    ///           implemented.
    ///    riid = The IID of the interface to be registered as global.
    ///    pdwCookie = An identifier that can be used by another apartment to get access to a pointer to the interface being
    ///                registered. The value of an invalid cookie is 0.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One or more parameters are invalid. </td> </tr> </table>
    ///    
    HRESULT RegisterInterfaceInGlobal(IUnknown pUnk, const(GUID)* riid, uint* pdwCookie);
    ///Revokes the registration of an interface in the global interface table.
    ///Params:
    ///    dwCookie = Identifies the interface whose global registration is to be revoked.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The parameter is invalid. </td> </tr> </table>
    ///    
    HRESULT RevokeInterfaceFromGlobal(uint dwCookie);
    ///Retrieves a pointer to an interface on an object that is usable by the calling apartment. This interface must be
    ///currently registered in the global interface table.
    ///Params:
    ///    dwCookie = Identifies the interface (and its object), and is retrieved through a call to
    ///               IGlobalInterfaceTable::RegisterInterfaceInGlobal.
    ///    riid = The IID of the interface.
    ///    ppv = A pointer to the pointer for the requested interface.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One or more parameters are invalid. </td> </tr> </table>
    ///    
    HRESULT GetInterfaceFromGlobal(uint dwCookie, const(GUID)* riid, void** ppv);
}

///Provides asynchronous communication between objects about the occurrence of an event. Objects that implement
///<b>ISynchronize</b> can receive indications that an event has occurred, and they can respond to queries about the
///event. In this way, clients can make sure that one request has been processed before they submit a subsequent request
///that depends on completion of the first one.
@GUID("00000030-0000-0000-C000-000000000046")
interface ISynchronize : IUnknown
{
    ///Waits for the synchronization object to be signaled or for a specified timeout period to elapse, whichever comes
    ///first.
    ///Params:
    ///    dwFlags = The wait options. Possible values are taken from the COWAIT_FLAGS enumeration.
    ///    dwMilliseconds = The time this call will wait before returning, in milliseconds. If this parameter is INFINITE, the caller
    ///                     will wait until the synchronization object is signaled, no matter how long it takes. If this parameter is 0,
    ///                     the method returns immediately.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_FAIL, as well as the
    ///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The synchronization object was signaled. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>RPC_E_CALLPENDING</b></dt> </dl> </td> <td width="60%"> The time-out period
    ///    elapsed before the synchronization object was signaled. </td> </tr> </table>
    ///    
    HRESULT Wait(uint dwFlags, uint dwMilliseconds);
    ///Sets the synchronization object to the signaled state and causes pending wait operations to return S_OK.
    ///Returns:
    ///    This method returns S_OK to indicate that the method completed successfully.
    ///    
    HRESULT Signal();
    ///Sets the synchronization object to the nonsignaled state.
    ///Returns:
    ///    This method returns S_OK to indicate that the method completed successfully.
    ///    
    HRESULT Reset();
}

///Retrieves a handle associated with a synchronization object.
@GUID("00000031-0000-0000-C000-000000000046")
interface ISynchronizeHandle : IUnknown
{
    ///Retrieves a handle to the synchronization object.
    ///Params:
    ///    ph = A pointer to the variable that receives a handle to the synchronization object.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_FAIL, and S_OK.
    ///    
    HRESULT GetHandle(HANDLE* ph);
}

///Assigns an event handle to a synchronization object. The synchronization object can use a handle to manage its
///activities. For example, the wait functions use handles to identify the event they control. Thus, the logic of the
///ISynchronize::Signal method on an event synchronization object can pass its handle to the SetEvent function.
@GUID("00000032-0000-0000-C000-000000000046")
interface ISynchronizeEvent : ISynchronizeHandle
{
    ///Assigns an event handle to a synchronization object.
    ///Params:
    ///    ph = A pointer to the event handle.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_FAIL, and S_OK.
    ///    
    HRESULT SetEventHandle(HANDLE* ph);
}

///Manages a group of unsignaled synchronization objects.
@GUID("00000033-0000-0000-C000-000000000046")
interface ISynchronizeContainer : IUnknown
{
    ///Adds a synchronization object to the container.
    ///Params:
    ///    pSync = A pointer to the synchronization object to be added to the container. See ISynchronize.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_FAIL, as well as the
    ///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>RPC_E_OUT_OF_RESOURCES</b></dt> </dl> </td> <td width="60%"> The synchronization
    ///    object container is full. </td> </tr> </table>
    ///    
    HRESULT AddSynchronize(ISynchronize pSync);
    ///Waits for any synchronization object in the container to be signaled or for a specified timeout period to elapse,
    ///whichever comes first.
    ///Params:
    ///    dwFlags = The wait options. Possible values are taken from the COWAIT_FLAGS enumeration. COWAIT_WAITALL is not a valid
    ///              setting for this method.
    ///    dwTimeOut = The time this call will wait before returning, in milliseconds. If this parameter is INFINITE, the caller
    ///                will wait until a synchronization object is signaled, no matter how long it takes. If this parameter is 0,
    ///                the method returns immediately.
    ///    ppSync = A pointer to an ISynchronize interface pointer on the synchronization object that was signaled. This
    ///             parameter cannot be <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_FAIL, as well as the
    ///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The synchronization object was signaled. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>RPC_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The time-out period elapsed
    ///    before the synchronization object was signaled. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>RPC_E_NO_SYNC</b></dt> </dl> </td> <td width="60%"> There are no synchronization objects in the
    ///    container. </td> </tr> </table>
    ///    
    HRESULT WaitMultiple(uint dwFlags, uint dwTimeOut, ISynchronize* ppSync);
}

@GUID("00000025-0000-0000-C000-000000000046")
interface ISynchronizeMutex : ISynchronize
{
    HRESULT ReleaseMutex();
}

///Manages cancellation requests on an outbound method call and monitors the current state of that method call on the
///server thread.
@GUID("00000029-0000-0000-C000-000000000046")
interface ICancelMethodCalls : IUnknown
{
    ///Requests that a method call be canceled.
    ///Params:
    ///    ulSeconds = The number of seconds to wait for the server to complete the outbound call after the client requests
    ///                cancellation.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The cancellation request was made.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>RPC_S_CALL_CANCELED</b></dt> </dl> </td> <td width="60%"> The
    ///    call was already canceled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_CANCEL_DISABLED</b></dt> </dl>
    ///    </td> <td width="60%"> Call cancellation is not enabled on the thread that is processing the call. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>RPC_E_CALL_COMPLETE</b></dt> </dl> </td> <td width="60%"> The call
    ///    was completed during the timeout interval. </td> </tr> </table>
    ///    
    HRESULT Cancel(uint ulSeconds);
    ///Determines whether a call has been canceled.
    ///Returns:
    ///    If the call was canceled, the return value is RPC_E_CALL_CANCELED. Otherwise, it is RPC_S_CALLPENDING.
    ///    
    HRESULT TestCancel();
}

@GUID("0000002A-0000-0000-C000-000000000046")
interface IAsyncManager : IUnknown
{
    HRESULT CompleteCall(HRESULT Result);
    HRESULT GetCallContext(const(GUID)* riid, void** pInterface);
    HRESULT GetState(uint* pulStateFlags);
}

///Creates a call object for processing calls to the methods of an asynchronous interface.
@GUID("1C733A30-2A1C-11CE-ADE5-00AA0044773D")
interface ICallFactory : IUnknown
{
    ///Creates an instance of the call object that corresponds to a specified asynchronous interface.
    ///Params:
    ///    riid = A reference to the identifier for the asynchronous interface.
    ///    pCtrlUnk = A pointer to the controlling IUnknown of the call object. If this parameter is not <b>NULL</b>, the call
    ///               object is aggregated in the specified object. If this parameter is <b>NULL</b>, the call object is not
    ///               aggregated.
    ///    riid2 = The identifier of an interface on the call object. Typical values are IID_IUnknown and IID_ISynchronize.
    ///    ppv = The address of a pointer to the interface specified by <i>riid2</i>. This parameter cannot be <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as
    ///    the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The call object was created successfully. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The <i>riid</i> parameter
    ///    does not reference the identifier for the asynchronous interface, such as IID_AsyncIEventSourceCallback.
    ///    </td> </tr> </table>
    ///    
    HRESULT CreateCall(const(GUID)* riid, IUnknown pCtrlUnk, const(GUID)* riid2, IUnknown* ppv);
}

@GUID("00000149-0000-0000-C000-000000000046")
interface IRpcHelper : IUnknown
{
    HRESULT GetDCOMProtocolVersion(uint* pComVersion);
    HRESULT GetIIDFromOBJREF(void* pObjRef, GUID** piid);
}

@GUID("EB0CB9E8-7996-11D2-872E-0000F8080859")
interface IReleaseMarshalBuffers : IUnknown
{
    HRESULT ReleaseMarshalBuffer(RPCOLEMESSAGE* pMsg, uint dwFlags, IUnknown pChnl);
}

@GUID("0000002B-0000-0000-C000-000000000046")
interface IWaitMultiple : IUnknown
{
    HRESULT WaitMultiple(uint timeout, ISynchronize* pSync);
    HRESULT AddSynchronize(ISynchronize pSync);
}

@GUID("00000147-0000-0000-C000-000000000046")
interface IAddrTrackingControl : IUnknown
{
    HRESULT EnableCOMDynamicAddrTracking();
    HRESULT DisableCOMDynamicAddrTracking();
}

@GUID("00000148-0000-0000-C000-000000000046")
interface IAddrExclusionControl : IUnknown
{
    HRESULT GetCurrentAddrExclusionList(const(GUID)* riid, void** ppEnumerator);
    HRESULT UpdateAddrExclusionList(IUnknown pEnumerator);
}

///Transfers data of the byte type (which is 8 bits wide).
@GUID("DB2F3ACA-2F86-11D1-8E04-00C04FB9989A")
interface IPipeByte : IUnknown
{
    ///Retrieves data of the byte type from the pipe source.
    ///Params:
    ///    buf = A pointer to the memory buffer that receives the data. The buffer must be able to hold at least the number of
    ///          bytes specified in <i>cRequest</i>.
    ///    cRequest = The number of bytes requested.
    ///    pcReturned = The actual number of bytes returned.
    ///Returns:
    ///    This method returns S_OK to indicate that the data was retrieved successfully.
    ///    
    HRESULT Pull(char* buf, uint cRequest, uint* pcReturned);
    ///Sends data of the byte type to the pipe source.
    ///Params:
    ///    buf = A pointer to the memory buffer that holds the data to be sent.
    ///    cSent = The number of bytes in the buffer.
    ///Returns:
    ///    This method returns S_OK to indicate that the data was sent successfully.
    ///    
    HRESULT Push(char* buf, uint cSent);
}

@GUID("DB2F3ACB-2F86-11D1-8E04-00C04FB9989A")
interface AsyncIPipeByte : IUnknown
{
    HRESULT Begin_Pull(uint cRequest);
    HRESULT Finish_Pull(ubyte* buf, uint* pcReturned);
    HRESULT Begin_Push(char* buf, uint cSent);
    HRESULT Finish_Push();
}

///Transfers data of the long integer type (which is 32 bits wide).
@GUID("DB2F3ACC-2F86-11D1-8E04-00C04FB9989A")
interface IPipeLong : IUnknown
{
    ///Retrieves data of the long integer type from the pipe source.
    ///Params:
    ///    buf = A pointer to the memory buffer that receives the data. The buffer must be able to hold at least the number of
    ///          long integers specified in <i>cRequest</i>.
    ///    cRequest = The number of long integers requested.
    ///    pcReturned = The actual number of long integers returned.
    ///Returns:
    ///    This method returns S_OK to indicate that the data was retrieved successfully.
    ///    
    HRESULT Pull(char* buf, uint cRequest, uint* pcReturned);
    ///Sends data of the long integer type to the pipe source.
    ///Params:
    ///    buf = A pointer to the memory buffer that holds the data to be sent.
    ///    cSent = The number of long integers in the buffer.
    ///Returns:
    ///    This method returns S_OK to indicate that the data was sent successfully.
    ///    
    HRESULT Push(char* buf, uint cSent);
}

@GUID("DB2F3ACD-2F86-11D1-8E04-00C04FB9989A")
interface AsyncIPipeLong : IUnknown
{
    HRESULT Begin_Pull(uint cRequest);
    HRESULT Finish_Pull(int* buf, uint* pcReturned);
    HRESULT Begin_Push(char* buf, uint cSent);
    HRESULT Finish_Push();
}

///Transfers data of the double type (which is 64 bits wide).
@GUID("DB2F3ACE-2F86-11D1-8E04-00C04FB9989A")
interface IPipeDouble : IUnknown
{
    ///Retrieves data of the double integer type from the pipe source.
    ///Params:
    ///    buf = A pointer to the memory buffer that receives the data. The buffer must be able to hold at least the number of
    ///          double integers specified in <i>cRequest</i>.
    ///    cRequest = The number of double integers requested.
    ///    pcReturned = The actual number of double integers returned.
    ///Returns:
    ///    This method returns S_OK to indicate that the data was retrieved successfully.
    ///    
    HRESULT Pull(char* buf, uint cRequest, uint* pcReturned);
    ///Sends data of the double integer type to the pipe source.
    ///Params:
    ///    buf = A pointer to the memory buffer that holds the data to be sent.
    ///    cSent = The number of double integers in the buffer.
    ///Returns:
    ///    This method returns S_OK to indicate that the data was sent successfully.
    ///    
    HRESULT Push(char* buf, uint cSent);
}

@GUID("DB2F3ACF-2F86-11D1-8E04-00C04FB9989A")
interface AsyncIPipeDouble : IUnknown
{
    HRESULT Begin_Pull(uint cRequest);
    HRESULT Finish_Pull(double* buf, uint* pcReturned);
    HRESULT Begin_Push(char* buf, uint cSent);
    HRESULT Finish_Push();
}

///Enables you to obtain the following information about the apartment and thread that the caller is executing in:
///apartment type, thread type, and thread GUID. It also allows you to specify a thread GUID.
@GUID("000001CE-0000-0000-C000-000000000046")
interface IComThreadingInfo : IUnknown
{
    ///Retrieves the type of apartment in which the caller is executing.
    ///Params:
    ///    pAptType = A points to an APTTYPE enumeration value that characterizes the caller's apartment.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The
    ///    caller is not executing in an apartment. </td> </tr> </table>
    ///    
    HRESULT GetCurrentApartmentType(APTTYPE* pAptType);
    ///Retrieves the type of thread in which the caller is executing.
    ///Params:
    ///    pThreadType = A pointer to a THDTYPE enumeration value that characterizes the caller's thread.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The
    ///    caller is not executing in an apartment. </td> </tr> </table>
    ///    
    HRESULT GetCurrentThreadType(THDTYPE* pThreadType);
    ///Retrieves the GUID of the thread in which the caller is executing.
    ///Params:
    ///    pguidLogicalThreadId = A pointer to the GUID of the caller's thread.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The
    ///    caller is not executing in an apartment. </td> </tr> </table>
    ///    
    HRESULT GetCurrentLogicalThreadId(GUID* pguidLogicalThreadId);
    ///Sets the GUID of the thread in which the caller is executing.
    ///Params:
    ///    rguid = A reference to a GUID for the caller's thread.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The
    ///    caller is not executing in an apartment. </td> </tr> </table>
    ///    
    HRESULT SetCurrentLogicalThreadId(const(GUID)* rguid);
}

///Specifies the process initialization time-out interval.
@GUID("72380D55-8D2B-43A3-8513-2B6EF31434E9")
interface IProcessInitControl : IUnknown
{
    ///Sets the process initialization time-out.
    ///Params:
    ///    dwSecondsRemaining = The number of seconds after this method is called before process initialization times out.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT ResetInitializerTimeout(uint dwSecondsRemaining);
}

///Marks an interface as eligible for fast rundown behavior.
@GUID("00000040-0000-0000-C000-000000000046")
interface IFastRundown : IUnknown
{
}

///Provides additional information about the marshaling context to custom-marshaled objects and unmarshalers.
@GUID("D8F2F5E6-6102-4863-9F26-389A4676EFDE")
interface IMarshalingStream : IStream
{
    ///Gets information about the marshaling context.
    ///Params:
    ///    attribute = The attribute to query.
    ///    pAttributeValue = The value of <i>attribute</i>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMarshalingContextAttribute(CO_MARSHALING_CONTEXT_ATTRIBUTES attribute, size_t* pAttributeValue);
}

///Enables application developers to monitor (spy on) memory allocation, detect memory leaks, and simulate memory
///failure in calls to IMalloc methods.
@GUID("0000001D-0000-0000-C000-000000000046")
interface IMallocSpy : IUnknown
{
    ///Performs operations required before calling IMalloc::Alloc.
    ///Params:
    ///    cbRequest = The number of bytes specified in the allocation request the caller is passing to Alloc.
    ///Returns:
    ///    The number of bytes specified in the call to Alloc, which can be greater than or equal to the value of
    ///    <i>cbRequest</i>.
    ///    
    size_t PreAlloc(size_t cbRequest);
    ///Performs operations required after calling IMalloc::Alloc.
    ///Params:
    ///    pActual = The pointer returned from Alloc.
    ///Returns:
    ///    This method returns a pointer to the beginning of the block of memory actually allocated. This pointer is
    ///    also returned to the caller of Alloc. If debug information is written at the front of the caller's
    ///    allocation, this should be a forward offset from <i>pActual</i>. The value is the same as <i>pActual</i> if
    ///    debug information is appended or if no debug information is attached.
    ///    
    void*  PostAlloc(void* pActual);
    ///Performs operations required before calling IMalloc::Free. This method ensures that the pointer passed to
    ///<b>Free</b> points to the beginning of the actual allocation.
    ///Params:
    ///    pRequest = A pointer to the block of memory that the caller is passing to Free.
    ///    fSpyed = Indicates whether the block of memory to be freed was allocated while the current spy was active.
    ///Returns:
    ///    The value to be passed to IMalloc::Free.
    ///    
    void*  PreFree(void* pRequest, BOOL fSpyed);
    ///Performs operations required after calling IMalloc::Free.
    ///Params:
    ///    fSpyed = Indicates whether the block of memory to be freed was allocated while the current spy was active.
    void   PostFree(BOOL fSpyed);
    ///Performs operations required before calling IMalloc::Realloc.
    ///Params:
    ///    pRequest = The pointer to the block of memory specified in the call to IMalloc::Realloc.
    ///    cbRequest = The byte count of the block of memory as specified in the original call to IMalloc::Realloc.
    ///    ppNewRequest = Address of pointer variable that receives a pointer to the memory block to be reallocated. This may be
    ///                   different from the pointer in <i>pRequest</i> if the implementation of <b>PreRealloc</b> extends or modifies
    ///                   the reallocation. This is pointer should always be stored by <b>PreRealloc</b>.
    ///    fSpyed = Indicates whether the block of memory was allocated while this spy was active.
    ///Returns:
    ///    The byte count to be passed to IMalloc::Realloc.
    ///    
    size_t PreRealloc(void* pRequest, size_t cbRequest, void** ppNewRequest, BOOL fSpyed);
    ///Performs operations required after calling IMalloc::Realloc.
    ///Params:
    ///    pActual = The pointer specified in the call to Realloc.
    ///    fSpyed = Indicates whether the block of memory was allocated while the current spy was active.
    ///Returns:
    ///    The method returns a pointer to the beginning of the block actually allocated. This pointer is also returned
    ///    to the caller of IMalloc::Realloc. If debug information is written at the front of the caller's allocation,
    ///    it should be a forward offset from <i>pActual</i>. The value should be the same as <i>pActual</i> if debug
    ///    information is appended or if no debug information is attached.
    ///    
    void*  PostRealloc(void* pActual, BOOL fSpyed);
    ///Performs operations required before calling IMalloc::GetSize.
    ///Params:
    ///    pRequest = The pointer that the caller is passing to GetSize.
    ///    fSpyed = Indicates whether the block of memory was allocated while the current spy was active.
    ///Returns:
    ///    A pointer to the actual allocation for which the size is to be determined.
    ///    
    void*  PreGetSize(void* pRequest, BOOL fSpyed);
    ///Performs operations required after calling IMalloc::GetSize.
    ///Params:
    ///    cbActual = The number of bytes in the allocation, as returned by GetSize.
    ///    fSpyed = Indicates whether the block of memory was allocated while the current spy was active.
    ///Returns:
    ///    The value returned by IMalloc::GetSize, which is the size of the allocated block of memory, in bytes.
    ///    
    size_t PostGetSize(size_t cbActual, BOOL fSpyed);
    ///Performs operations required before calling IMalloc::DidAlloc.
    ///Params:
    ///    pRequest = The pointer specified in the call to DidAlloc.
    ///    fSpyed = Indicates whether the allocation was done while this spy was active.
    ///Returns:
    ///    The value passed to DidAlloc as the <i>fActual</i> parameter.
    ///    
    void*  PreDidAlloc(void* pRequest, BOOL fSpyed);
    ///Performs operations required after calling IMalloc::DidAlloc.
    ///Params:
    ///    pRequest = The pointer specified in the call to DidAlloc.
    ///    fSpyed = Indicates whether the allocation was done while this spy was active.
    ///    fActual = The value returned by DidAlloc.
    ///Returns:
    ///    The value returned to the caller of DidAlloc.
    ///    
    int    PostDidAlloc(void* pRequest, BOOL fSpyed, int fActual);
    ///Performs operations required before calling IMalloc::HeapMinimize.
    void   PreHeapMinimize();
    ///Performs operations required after calling IMalloc::HeapMinimize.
    void   PostHeapMinimize();
}

///Provides access to a bind context, which is an object that stores information about a particular moniker binding
///operation.
@GUID("0000000E-0000-0000-C000-000000000046")
interface IBindCtx : IUnknown
{
    ///Registers an object with the bind context to ensure that the object remains active until the bind context is
    ///released.
    ///Params:
    ///    punk = A pointer to the IUnknown interface on the object that is being registered as bound.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and S_OK.
    ///    
    HRESULT RegisterObjectBound(IUnknown punk);
    ///Removes the object from the bind context, undoing a previous call to RegisterObjectBound.
    ///Params:
    ///    punk = A pointer to the IUnknown interface on the object to be removed.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The object was released
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_E_NOTBOUND</b></dt> </dl> </td> <td
    ///    width="60%"> The object was not previously registered. </td> </tr> </table>
    ///    
    HRESULT RevokeObjectBound(IUnknown punk);
    ///Releases all pointers to all objects that were previously registered by calls to RegisterObjectBound.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ReleaseBoundObjects();
    ///Sets new values for the binding parameters stored in the bind context.
    ///Params:
    ///    pbindopts = A pointer to a [BIND_OPTS3](./ns-objidl-bind_opts3~r1.md) structure containing the binding parameters.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and S_OK.
    ///    
    HRESULT SetBindOptions(BIND_OPTS* pbindopts);
    ///Retrieves the binding options stored in this bind context.
    ///Params:
    ///    pbindopts = A pointer to an initialized structure that receives the current binding parameters on return. See
    ///                [BIND_OPTS3](./ns-objidl-bind_opts3~r1.md).
    ///Returns:
    ///    This method can return the standard return values E_UNEXPECTED and S_OK.
    ///    
    HRESULT GetBindOptions(BIND_OPTS* pbindopts);
    ///Retrieves an interface pointer to the running object table (ROT) for the computer on which this bind context is
    ///running.
    ///Params:
    ///    pprot = The address of a IRunningObjectTable* pointer variable that receives the interface pointer to the running
    ///            object table. If an error occurs, *<i>pprot</i> is set to <b>NULL</b>. If *<i>pprot</i> is non-<b>NULL</b>,
    ///            the implementation calls AddRef on the running table object; it is the caller's responsibility to call
    ///            Release.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.
    ///    
    HRESULT GetRunningObjectTable(IRunningObjectTable* pprot);
    ///Associates an object with a string key in the bind context's string-keyed table of pointers.
    ///Params:
    ///    pszKey = The bind context string key under which the object is being registered. Key string comparison is
    ///             case-sensitive.
    ///    punk = A pointer to the IUnknown interface on the object that is to be registered. The method calls AddRef on the
    ///           pointer.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and S_OK.
    ///    
    HRESULT RegisterObjectParam(ushort* pszKey, IUnknown punk);
    ///Retrieves an interface pointer to the object associated with the specified key in the bind context's string-keyed
    ///table of pointers.
    ///Params:
    ///    pszKey = The bind context string key to be searched for. Key string comparison is case-sensitive.
    ///    ppunk = The address of an IUnknown* pointer variable that receives the interface pointer to the object associated
    ///            with <i>pszKey</i>. When successful, the implementation calls AddRef on *<i>ppunk</i>. It is the caller's
    ///            responsibility to call Release. If an error occurs, the implementation sets *<i>ppunk</i> to <b>NULL</b>.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.
    ///    
    HRESULT GetObjectParam(ushort* pszKey, IUnknown* ppunk);
    ///Retrieves a pointer to an interface that can be used to enumerate the keys of the bind context's string-keyed
    ///table of pointers.
    ///Params:
    ///    ppenum = The address of an IEnumString* pointer variable that receives the interface pointer to the enumerator. If an
    ///             error occurs, *<i>ppenum</i> is set to <b>NULL</b>. If *<i>ppenum</i> is non-<b>NULL</b>, the implementation
    ///             calls AddRef on *<i>ppenum</i>; it is the caller's responsibility to call Release.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and S_OK.
    ///    
    HRESULT EnumObjectParam(IEnumString* ppenum);
    ///Removes the specified key and its associated pointer from the bind context's string-keyed table of objects. The
    ///key must have previously been inserted into the table with a call to RegisterObjectParam.
    ///Params:
    ///    pszKey = The bind context string key to be removed. Key string comparison is case-sensitive.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The specified key was removed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The
    ///    object was not previously registered. </td> </tr> </table>
    ///    
    HRESULT RevokeObjectParam(ushort* pszKey);
}

///Enumerates the components of a moniker or the monikers in a table of monikers.
@GUID("00000102-0000-0000-C000-000000000046")
interface IEnumMoniker : IUnknown
{
    ///Retrieves the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be retrieved. If there are fewer than the requested number of items left in the
    ///           sequence, this method retrieves the remaining elements.
    ///    rgelt = An array of enumerated items. The enumerator is responsible for calling AddRef, and the caller is responsible
    ///            for calling Release through each pointer enumerated. If <i>celt</i> is greater than 1, the caller must also
    ///            pass a non-<b>NULL</b> pointer passed to <i>pceltFetched</i> to know how many pointers to release.
    ///    pceltFetched = The number of items that were retrieved. This parameter is always less than or equal to the number of items
    ///                   requested. This parameter can be <b>NULL</b> if <i>celt</i> is 1.
    ///Returns:
    ///    If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Skips over the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be skipped.
    ///Returns:
    ///    If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Skip(uint celt);
    ///Resets the enumeration sequence to the beginning.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT Reset();
    ///Creates a new enumerator that contains the same enumeration state as the current one. This method makes it
    ///possible to record a particular point in the enumeration sequence and then return to that point at a later time.
    ///The caller must release this new enumerator separately from the first enumerator.
    ///Params:
    ///    ppenum = Address of an IEnumMoniker pointer variable that receives the interface pointer to the enumeration object. If
    ///             the method is unsuccessful, the value of this output variable is undefined.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified enumerator is invalid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory
    ///    available for this operation. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumMoniker* ppenum);
}

///Enables a container to control the running of its embedded objects. In the case of an object implemented with a local
///server, calling the Run method launches the server's .EXE file. In the case of an object implemented with an
///in-process server, calling <b>Run</b> causes the object .DLL file to transition into the running state.
@GUID("00000126-0000-0000-C000-000000000046")
interface IRunnableObject : IUnknown
{
    ///Retrieves the CLSID of a running object.
    ///Params:
    ///    lpClsid = A pointer to the object's class identifier.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_UNEXPECTED, and S_OK.
    ///    
    HRESULT GetRunningClass(GUID* lpClsid);
    ///Forces an object to run.
    ///Params:
    ///    pbc = A pointer to the binding context of the run operation. See IBindCtx. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_UNEXPECTED, and S_OK.
    ///    
    HRESULT Run(IBindCtx pbc);
    ///Determines whether an object is currently in the running state.
    ///Returns:
    ///    If the object is in the running state, the return value is <b>TRUE</b>. Otherwise, it is <b>FALSE</b>.
    ///    
    BOOL    IsRunning();
    ///Locks an already running object into its running state or unlocks it from its running state.
    ///Params:
    ///    fLock = <b>TRUE</b> locks the object into its running state. <b>FALSE</b> unlocks the object from its running state.
    ///    fLastUnlockCloses = <b>TRUE</b> specifies that if the connection being released is the last external lock on the object, the
    ///                        object should close. <b>FALSE</b> specifies that the object should remain open until closed by the user or
    ///                        another process.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT LockRunning(BOOL fLock, BOOL fLastUnlockCloses);
    ///Notifies an object that it is embedded in an OLE container, which ensures that reference counting is done
    ///correctly for containers that support links to embedded objects.
    ///Params:
    ///    fContained = <b>TRUE</b> specifies that the object is contained in an OLE container. <b>FALSE</b> indicates that it is
    ///                 not.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.
    ///    
    HRESULT SetContainedObject(BOOL fContained);
}

///Manages access to the running object table (ROT), a globally accessible look-up table on each workstation. A
///workstation's ROT keeps track of those objects that can be identified by a moniker and that are currently running on
///the workstation. When a client tries to bind a moniker to an object, the moniker checks the ROT to see if the object
///is already running; this allows the moniker to bind to the current instance instead of loading a new one.
@GUID("00000010-0000-0000-C000-000000000046")
interface IRunningObjectTable : IUnknown
{
    ///Registers an object and its identifying moniker in the running object table (ROT).
    ///Params:
    ///    grfFlags = Specifies whether the ROT's reference to punkObject is weak or strong and controls access to the object
    ///               through its entry in the ROT. For details, see the Remarks section. <table> <tr> <th>Value</th>
    ///               <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ROTFLAGS_REGISTRATIONKEEPSALIVE"></a><a
    ///               id="rotflags_registrationkeepsalive"></a><dl> <dt><b>ROTFLAGS_REGISTRATIONKEEPSALIVE</b></dt> </dl> </td> <td
    ///               width="60%"> When set, indicates a strong registration for the object. </td> </tr> <tr> <td width="40%"><a
    ///               id="ROTFLAGS_ALLOWANYCLIENT"></a><a id="rotflags_allowanyclient"></a><dl>
    ///               <dt><b>ROTFLAGS_ALLOWANYCLIENT</b></dt> </dl> </td> <td width="60%"> When set, any client can connect to the
    ///               running object through its entry in the ROT. When not set, only clients in the window station that registered
    ///               the object can connect to it. </td> </tr> </table>
    ///    punkObject = A pointer to the object that is being registered as running.
    ///    pmkObjectName = A pointer to the moniker that identifies <i>punkObject</i>.
    ///    pdwRegister = An identifier for this ROT entry that can be used in subsequent calls to IRunningObjectTable::Revoke or
    ///                  IRunningObjectTable::NoteChangeTime. The caller cannot specify <b>NULL</b> for this parameter. If an error
    ///                  occurs, *<i>pdwRegister</i> is set to zero.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG and E_OUTOFMEMORY, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MK_S_MONIKERALREADYREGISTERED</b></dt> </dl> </td> <td width="60%"> The
    ///    moniker/object pair was successfully registered, but that another object (possibly the same object) has
    ///    already been registered with the same moniker. </td> </tr> </table>
    ///    
    HRESULT Register(uint grfFlags, IUnknown punkObject, IMoniker pmkObjectName, uint* pdwRegister);
    ///Removes an entry from the running object table (ROT) that was previously registered by a call to
    ///IRunningObjectTable::Register.
    ///Params:
    ///    dwRegister = The identifier of the ROT entry to be revoked.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG and S_OK.
    ///    
    HRESULT Revoke(uint dwRegister);
    ///Determines whether the object identified by the specified moniker is currently running.
    ///Params:
    ///    pmkObjectName = A pointer to the IMoniker interface on the moniker.
    ///Returns:
    ///    If the object is in the running state, the return value is <b>TRUE</b>. Otherwise, it is <b>FALSE</b>.
    ///    
    HRESULT IsRunning(IMoniker pmkObjectName);
    HRESULT GetObjectA(IMoniker pmkObjectName, IUnknown* ppunkObject);
    ///Records the time that a running object was last modified. The object must have previously been registered with
    ///the running object table (ROT). This method stores the time of last change in the ROT.
    ///Params:
    ///    dwRegister = The identifier of the ROT entry of the changed object. This value was previously returned by
    ///                 IRunningObjectTable::Register.
    ///    pfiletime = A pointer to a FILETIME structure containing the object's last change time.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG and S_OK.
    ///    
    HRESULT NoteChangeTime(uint dwRegister, FILETIME* pfiletime);
    ///Retrieves the time that an object was last modified.
    ///Params:
    ///    pmkObjectName = A pointer to the IMoniker interface on the moniker.
    ///    pfiletime = A pointer to a FILETIME structure that receives the object's last change time.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    There is no entry for <i>pmkObjectName</i> in the ROT, or that the object it identifies is no longer running
    ///    (in which case, the entry is revoked). </td> </tr> </table>
    ///    
    HRESULT GetTimeOfLastChange(IMoniker pmkObjectName, FILETIME* pfiletime);
    ///Creates and returns a pointer to an enumerator that can list the monikers of all the objects currently registered
    ///in the running object table (ROT).
    ///Params:
    ///    ppenumMoniker = A pointer to an IEnumMoniker pointer variable that receives the interface pointer to the new enumerator for
    ///                    the ROT. When successful, the implementation calls AddRef on the enumerator; it is the caller's
    ///                    responsibility to call Release. If an error occurs; the implementation sets *<i>ppenumMoniker</i> to
    ///                    <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and S_OK.
    ///    
    HRESULT EnumRunning(IEnumMoniker* ppenumMoniker);
}

///Provides the CLSID of an object that can be stored persistently in the system. Allows the object to specify which
///object handler to use in the client process, as it is used in the default implementation of marshaling.
///<b>IPersist</b> is the base interface for three other interfaces: IPersistStorage, IPersistStream, and IPersistFile.
///Each of these interfaces, therefore, includes the GetClassID method, and the appropriate one of these three
///interfaces is implemented on objects that can be serialized to a storage, a stream, or a file. The methods of these
///interfaces allow the state of these objects to be saved for later instantiations, and load the object using the saved
///state. Typically, the persistence interfaces are implemented by an embedded or linked object, and are called by the
///container application or the default object handler.
@GUID("0000010C-0000-0000-C000-000000000046")
interface IPersist : IUnknown
{
    ///Retrieves the class identifier (CLSID) of the object.
    ///Params:
    ///    pClassID = A pointer to the location that receives the CLSID on return. The CLSID is a globally unique identifier (GUID)
    ///               that uniquely represents an object class that defines the code that can manipulate the object's data.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.
    ///    
    HRESULT GetClassID(GUID* pClassID);
}

///Enables the saving and loading of objects that use a simple serial stream for their storage needs.
@GUID("00000109-0000-0000-C000-000000000046")
interface IPersistStream : IPersist
{
    ///Determines whether an object has changed since it was last saved to its stream.
    ///Returns:
    ///    This method returns S_OK to indicate that the object has changed. Otherwise, it returns S_FALSE.
    ///    
    HRESULT IsDirty();
    ///Initializes an object from the stream where it was saved previously.
    ///Params:
    ///    pStm = An IStream pointer to the stream from which the object should be loaded.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The object was not loaded due to lack of memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The object was not loaded due to some reason other than a
    ///    lack of memory. </td> </tr> </table>
    ///    
    HRESULT Load(IStream pStm);
    ///Saves an object to the specified stream.
    ///Params:
    ///    pStm = An IStream pointer to the stream into which the object should be saved.
    ///    fClearDirty = Indicates whether to clear the dirty flag after the save is complete. If <b>TRUE</b>, the flag should be
    ///                  cleared. If <b>FALSE</b>, the flag should be left unchanged.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>STG_E_CANTSAVE</b></dt> </dl> </td> <td
    ///    width="60%"> The object could not save itself to the stream. This error could indicate, for example, that the
    ///    object contains another object that is not serializable to a stream or that an ISequentialStream::Write call
    ///    returned STG_E_CANTSAVE. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>STG_E_MEDIUMFULL</b></dt> </dl> </td>
    ///    <td width="60%"> The object could not be saved because there is no space left on the storage device. </td>
    ///    </tr> </table>
    ///    
    HRESULT Save(IStream pStm, BOOL fClearDirty);
    ///Retrieves the size of the stream needed to save the object.
    ///Params:
    ///    pcbSize = The size in bytes of the stream needed to save this object, in bytes.
    ///Returns:
    ///    This method returns S_OK to indicate that the size was retrieved successfully.
    ///    
    HRESULT GetSizeMax(ULARGE_INTEGER* pcbSize);
}

///Enables you to use a moniker object, which contains information that uniquely identifies a COM object. An object that
///has a pointer to the moniker object's <b>IMoniker</b> interface can locate, activate, and get access to the
///identified object without having any other specific information on where the object is actually located in a
///distributed system. Monikers are used as the basis for linking in COM. A linked object contains a moniker that
///identifies its source. When the user activates the linked object to edit it, the moniker is bound; this loads the
///link source into memory.
@GUID("0000000F-0000-0000-C000-000000000046")
interface IMoniker : IPersistStream
{
    ///Binds to the specified object. The binding process involves finding the object, putting it into the running state
    ///if necessary, and providing the caller with a pointer to a specified interface on the identified object.
    ///Params:
    ///    pbc = A pointer to the IBindCtx interface on the bind context object, which is used in this binding operation. The
    ///          bind context caches objects bound during the binding process, contains parameters that apply to all
    ///          operations using the bind context, and provides the means by which the moniker implementation should retrieve
    ///          information about its environment.
    ///    pmkToLeft = If the moniker is part of a composite moniker, pointer to the moniker to the left of this moniker. This
    ///                parameter is primarily used by moniker implementers to enable cooperation between the various components of a
    ///                composite moniker. Moniker clients should use <b>NULL</b>.
    ///    riidResult = The IID of the interface the client wishes to use to communicate with the object that the moniker identifies.
    ///    ppvResult = The address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful
    ///                return, *<i>ppvResult</i> contains the requested interface pointer to the object the moniker identifies. When
    ///                successful, the implementation must call AddRef on the moniker. It is the caller's responsibility to call
    ///                Release. If an error occurs, *<i>ppvResult</i> should be <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The binding operation was successful. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MK_E_NOOBJECT</b></dt> </dl> </td> <td width="60%"> The object identified by this
    ///    moniker, or some object identified by the composite moniker of which this moniker is a part, could not be
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_E_EXCEEDEDDEADLINE</b></dt> </dl> </td> <td
    ///    width="60%"> The binding operation could not be completed within the time limit specified by the bind
    ///    context's BIND_OPTS structure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_E_CONNECTMANUALLY</b></dt>
    ///    </dl> </td> <td width="60%"> The binding operation requires assistance from the end user. The most common
    ///    reason for returning this value is that a password is needed or that a floppy needs to be mounted. When this
    ///    value is returned, retrieve the moniker that caused the error with a call to IBindCtx::GetObjectParam with
    ///    the key "ConnectManually". You can then call IMoniker::GetDisplayName to get the display name, display a
    ///    dialog box that communicates the desired information, such as instructions to mount a floppy or a request for
    ///    a password, and then retry the binding operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MK_E_INTERMEDIATEINTERFACENOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> An intermediate object
    ///    was found but it did not support an interface required to complete the binding operation. For example, an
    ///    item moniker returns this value if its container does not support the IOleItemContainer interface. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>STG_E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Unable to
    ///    access the storage object. </td> </tr> </table> This method can also return the errors associated with the
    ///    IOleItemContainer::GetObject method.
    ///    
    HRESULT BindToObject(IBindCtx pbc, IMoniker pmkToLeft, const(GUID)* riidResult, void** ppvResult);
    ///Binds to the storage for the specified object. Unlike the IMoniker::BindToObject method, this method does not
    ///activate the object identified by the moniker.
    ///Params:
    ///    pbc = A pointer to the IBindCtx interface on the bind context object, which is used in this binding operation. The
    ///          bind context caches objects bound during the binding process, contains parameters that apply to all
    ///          operations using the bind context, and provides the means by which the moniker implementation should retrieve
    ///          information about its environment.
    ///    pmkToLeft = If the moniker is part of a composite moniker, pointer to the moniker to the left of this moniker. This
    ///                parameter is primarily used by moniker implementers to enable cooperation between the various components of a
    ///                composite moniker. Moniker clients should use <b>NULL</b>.
    ///    riid = A reference to the identifier of the storage interface requested, whose pointer will be returned in
    ///           <i>ppvObj</i>. Storage interfaces commonly requested include IStorage, IStream, and ILockBytes.
    ///    ppvObj = The address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful
    ///             return, *<i>ppvObj</i> contains the requested interface pointer to the storage of the object the moniker
    ///             identifies. When successful, the implementation must call AddRef on the storage. It is the caller's
    ///             responsibility to call Release. If an error occurs, *<i>ppvObj</i> should be <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_UNEXPECTED, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The binding operation was successful. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MK_E_NOSTORAGE</b></dt> </dl> </td> <td width="60%"> The object identified by this moniker does not
    ///    have its own storage. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_E_EXCEEDEDDEADLINE</b></dt> </dl>
    ///    </td> <td width="60%"> The binding operation could not be completed within the time limit specified by the
    ///    bind context's BIND_OPTS structure. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MK_E_CONNECTMANUALLY</b></dt> </dl> </td> <td width="60%"> The operation was unable to connect to the
    ///    storage, possibly because a network device could not be connected to. For more information, see
    ///    IMoniker::BindToObject. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MK_E_INTERMEDIATEINTERFACENOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> An intermediate object
    ///    was found but it did not support an interface required to complete the binding operation. For example, an
    ///    item moniker returns this value if its container does not support the IOleItemContainer interface. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>STG_E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> Unable to
    ///    access the storage object. </td> </tr> </table> This method can also return the errors associated with the
    ///    IOleItemContainer::GetObject method.
    ///    
    HRESULT BindToStorage(IBindCtx pbc, IMoniker pmkToLeft, const(GUID)* riid, void** ppvObj);
    ///Reduces a moniker to its simplest form.
    ///Params:
    ///    pbc = A pointer to the IBindCtx interface on the bind context to be used in this binding operation. The bind
    ///          context caches objects bound during the binding process, contains parameters that apply to all operations
    ///          using the bind context, and provides the means by which the moniker implementation should retrieve
    ///          information about its environment.
    ///    dwReduceHowFar = Specifies how far this moniker should be reduced. This parameter must be one of the values from the MKRREDUCE
    ///                     enumeration.
    ///    ppmkToLeft = On entry, a pointer to an IMoniker pointer variable that contains the interface pointer to moniker to the
    ///                 left of this moniker. This parameter is used primarily by moniker implementers to enable cooperation between
    ///                 the various components of a composite moniker; moniker clients can usually pass <b>NULL</b>. On return,
    ///                 *<i>ppmkToLeft</i> is usually set to <b>NULL</b>, indicating no change in the original moniker to the left.
    ///                 In rare situations, *<i>ppmkToLeft</i> indicates a moniker, indicating that the previous moniker to the left
    ///                 should be disregarded and the moniker returned through *<i>ppmkToLeft</i> is the replacement. In such a
    ///                 situation, the implementation must call Release on the old moniker to the left of this moniker and must call
    ///                 AddRef on the new returned moniker; the caller must release it later. If an error occurs, the implementation
    ///                 can either leave the interface pointer unchanged or set it to <b>NULL</b>.
    ///    ppmkReduced = A pointer to an IMoniker pointer variable that receives the interface pointer to the reduced form of this
    ///                  moniker, which can be <b>NULL</b> if an error occurs or if this moniker is reduced to nothing. If this
    ///                  moniker cannot be reduced, *<i>ppmkReduced</i> is simply set to this moniker and the return value is
    ///                  MK_S_REDUCED_TO_SELF. If *<i>ppmkReduced</i> is non-<b>NULL</b>, the implementation must call AddRef on the
    ///                  new moniker; it is the caller's responsibility to call Release. (This is true even if *<i>ppmkReduced</i> is
    ///                  set to this moniker.)
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MK_S_REDUCED_TO_SELF</b></dt> </dl> </td> <td width="60%"> This moniker could not be
    ///    reduced any further, so <i>ppmkReduced</i> indicates this moniker. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MK_E_EXCEEDEDDEADLINE</b></dt> </dl> </td> <td width="60%"> The operation could not be completed
    ///    within the time limit specified by the bind context's BIND_OPTS structure. </td> </tr> </table>
    ///    
    HRESULT Reduce(IBindCtx pbc, uint dwReduceHowFar, IMoniker* ppmkToLeft, IMoniker* ppmkReduced);
    ///Creates a new composite moniker by combining the current moniker with the specified moniker.
    ///Params:
    ///    pmkRight = A pointer to the IMoniker interface on the moniker to compose onto the end of this moniker.
    ///    fOnlyIfNotGeneric = If <b>TRUE</b>, the caller requires a nongeneric composition, so the operation should proceed only if
    ///                        <i>pmkRight</i> is a moniker class that this moniker can compose with in some way other than forming a
    ///                        generic composite. If <b>FALSE</b>, the method can create a generic composite if necessary. Most callers
    ///                        should set this parameter to <b>FALSE</b>.
    ///    ppmkComposite = A pointer to an IMoniker pointer variable that receives the composite moniker pointer. When successful, the
    ///                    implementation must call AddRef on the resulting moniker; it is the caller's responsibility to call Release.
    ///                    If an error occurs or if the monikers compose to nothing (for example, composing an anti-moniker with an item
    ///                    moniker or a file moniker), *<i>ppmkComposite</i> should be set to <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The monikers were successfully combined. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>MK_E_NEEDGENERIC</b></dt> </dl> </td> <td width="60%"> Indicates that
    ///    <i>fOnlyIfNotGeneric</i> was <b>TRUE</b>, but the monikers could not be composed together without creating a
    ///    generic composite moniker. </td> </tr> </table>
    ///    
    HRESULT ComposeWith(IMoniker pmkRight, BOOL fOnlyIfNotGeneric, IMoniker* ppmkComposite);
    ///Retrieves a pointer to an enumerator for the components of a composite moniker.
    ///Params:
    ///    fForward = If <b>TRUE</b>, enumerates the monikers from left to right. If <b>FALSE</b>, enumerates from right to left.
    ///    ppenumMoniker = A pointer to an IEnumMoniker pointer variable that receives the interface pointer to the enumerator object
    ///                    for the moniker. When successful, the implementation must call AddRef on the enumerator object. It is the
    ///                    caller's responsibility to call Release. If an error occurs or if the moniker has no enumerable components,
    ///                    the implementation sets *<i>ppenumMoniker</i> to <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.
    ///    
    HRESULT Enum(BOOL fForward, IEnumMoniker* ppenumMoniker);
    ///Determines whether this moniker is identical to the specified moniker.
    ///Params:
    ///    pmkOtherMoniker = A pointer to the IMoniker interface on the moniker to be used for comparison with this one (the one from
    ///                      which this method is called).
    ///Returns:
    ///    This method returns S_OK to indicate that the two monikers are identical, and S_FALSE otherwise.
    ///    
    HRESULT IsEqual(IMoniker pmkOtherMoniker);
    ///Creates a hash value using the internal state of the moniker.
    ///Params:
    ///    pdwHash = A pointer to a variable that receives the hash value.
    ///Returns:
    ///    This method returns S_OK to indicate that the hash value was retrieved successfully.
    ///    
    HRESULT Hash(uint* pdwHash);
    ///Determines whether the object identified by this moniker is currently loaded and running.
    ///Params:
    ///    pbc = A pointer to the IBindCtx interface on the bind context to be used in this binding operation. The bind
    ///          context caches objects bound during the binding process, contains parameters that apply to all operations
    ///          using the bind context, and provides the means by which the moniker implementation should retrieve
    ///          information about its environment.
    ///    pmkToLeft = A pointer to the IMoniker interface on the moniker to the left of this moniker if this moniker is part of a
    ///                composite. This parameter is used primarily by moniker implementers to enable cooperation between the various
    ///                components of a composite moniker; moniker clients can usually pass <b>NULL</b>.
    ///    pmkNewlyRunning = A pointer to the IMoniker interface on the moniker most recently added to the running object table (ROT).
    ///                      This can be <b>NULL</b>. If non-<b>NULL</b>, the implementation can return the results of calling
    ///                      IMoniker::IsEqual on the <i>pmkNewlyRunning</i> parameter, passing the current moniker. This parameter is
    ///                      intended to enable <b>IsRunning</b> implementations that are more efficient than just searching the ROT, but
    ///                      the implementation can choose to ignore <i>pmkNewlyRunning</i> without causing any harm.
    ///Returns:
    ///    This method can return the standard return values E_UNEXPECTED, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The moniker is running. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The moniker is not running. </td> </tr> </table>
    ///    
    HRESULT IsRunning(IBindCtx pbc, IMoniker pmkToLeft, IMoniker pmkNewlyRunning);
    ///Retrieves the time at which the object identified by this moniker was last changed.
    ///Params:
    ///    pbc = A pointer to the bind context to be used in this binding operation. The bind context caches objects bound
    ///          during the binding process, contains parameters that apply to all operations using the bind context, and
    ///          provides the means by which the moniker implementation should retrieve information about its environment. For
    ///          more information, see IBindCtx.
    ///    pmkToLeft = If the moniker is part of a composite moniker, pointer to the moniker to the left of this moniker. This
    ///                parameter is primarily used by moniker implementers to enable cooperation between the various components of a
    ///                composite moniker. Moniker clients should pass <b>NULL</b>.
    ///    pFileTime = A pointer to the FILETIME structure that receives the time of last change. A value of {0xFFFFFFFF,0x7FFFFFFF}
    ///                indicates an error (for example, exceeded time limit, information not available).
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY, as well as the following values. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The method completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MK_E_EXCEEDEDDEADLINE</b></dt> </dl> </td> <td width="60%"> The binding operation could not be
    ///    completed within the time limit specified by the bind context's BIND_OPTS structure. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MK_E_CONNECTMANUALLY</b></dt> </dl> </td> <td width="60%"> The operation was unable
    ///    to connect to the storage for this object, possibly because a network device could not be connected to. For
    ///    more information, see IMoniker::BindToObject. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MK_E_UNAVAILABLE</b></dt> </dl> </td> <td width="60%"> The time of the change is unavailable and will
    ///    not be available regardless of the deadline that is used. </td> </tr> </table>
    ///    
    HRESULT GetTimeOfLastChange(IBindCtx pbc, IMoniker pmkToLeft, FILETIME* pFileTime);
    ///Creates a moniker that is the inverse of this moniker. When composed to the right of this moniker or one of
    ///similar structure, the moniker will compose to nothing.
    ///Params:
    ///    ppmk = The address of an IMoniker pointer variable that receives the interface pointer to a moniker that is the
    ///           inverse of this moniker. When successful, the implementation must call AddRef on the new inverse moniker. It
    ///           is the caller's responsibility to call Release. If an error occurs, the implementation should set
    ///           *<i>ppmk</i> to <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY, as well as the following values. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The inverse moniker has been returned successfully. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MK_E_NOINVERSE</b></dt> </dl> </td> <td width="60%"> The moniker class does not have an inverse.
    ///    </td> </tr> </table>
    ///    
    HRESULT Inverse(IMoniker* ppmk);
    ///Creates a new moniker based on the prefix that this moniker has in common with the specified moniker.
    ///Params:
    ///    pmkOther = A pointer to the IMoniker interface on another moniker to be compared with this one to determine whether
    ///               there is a common prefix.
    ///    ppmkPrefix = The address of an IMoniker* pointer variable that receives the interface pointer to the moniker that is the
    ///                 common prefix of this moniker and pmkOther. When successful, the implementation must call AddRef on the
    ///                 resulting moniker; it is the caller's responsibility to call Release. If an error occurs or if there is no
    ///                 common prefix, the implementation should set *<i>ppmkPrefix</i> to <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY, as well as the following values. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> A common prefix exists that is neither this moniker nor <i>pmkOther</i>. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>MK_S_NOPREFIX</b></dt> </dl> </td> <td width="60%"> No common prefix
    ///    exists. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_S_HIM</b></dt> </dl> </td> <td width="60%"> The
    ///    entire <i>pmkOther</i> is a prefix of this moniker. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MK_S_US</b></dt> </dl> </td> <td width="60%"> The two monikers are identical. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MK_S_ME</b></dt> </dl> </td> <td width="60%"> This moniker is a prefix of the
    ///    <i>pmkOther</i> moniker. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_S_NOTBINDABLE</b></dt> </dl> </td>
    ///    <td width="60%"> This method was called on a relative moniker. It is not meaningful to take the common prefix
    ///    on a relative moniker. </td> </tr> </table>
    ///    
    HRESULT CommonPrefixWith(IMoniker pmkOther, IMoniker* ppmkPrefix);
    ///Creates a relative moniker between this moniker and the specified moniker.
    ///Params:
    ///    pmkOther = A pointer to the IMoniker interface on the moniker to which a relative path should be taken.
    ///    ppmkRelPath = A pointer to an IMoniker pointer variable that receives the interface pointer to the relative moniker. When
    ///                  successful, the implementation must call AddRef on the new moniker; it is the caller's responsibility to call
    ///                  Release. If an error occurs, the implementation sets *<i>ppmkRelPath</i> to <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MK_S_HIM</b></dt> </dl> </td> <td width="60%"> No common prefix is shared by the two
    ///    monikers and the moniker returned in <i>ppmkRelPath</i> is <i>pmkOther</i>. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>MK_E_NOTBINDABLE</b></dt> </dl> </td> <td width="60%"> This moniker is a relative moniker, such
    ///    as an item moniker. This moniker must be composed with the moniker of its container before a relative path
    ///    can be determined. </td> </tr> </table>
    ///    
    HRESULT RelativePathTo(IMoniker pmkOther, IMoniker* ppmkRelPath);
    ///Retrieves the display name for the moniker.
    ///Params:
    ///    pbc = A pointer to the IBindCtx interface on the bind context to be used in this operation. The bind context caches
    ///          objects bound during the binding process, contains parameters that apply to all operations using the bind
    ///          context, and provides the means by which the moniker implementation should retrieve information about its
    ///          environment.
    ///    pmkToLeft = If the moniker is part of a composite moniker, pointer to the moniker to the left of this moniker. This
    ///                parameter is used primarily by moniker implementers to enable cooperation between the various components of a
    ///                composite moniker. Moniker clients should pass <b>NULL</b>.
    ///    ppszDisplayName = The address of a pointer variable that receives a pointer to the display name string for the moniker. The
    ///                      implementation must use IMalloc::Alloc to allocate the string returned in <i>ppszDisplayName</i>, and the
    ///                      caller is responsible for calling IMalloc::Free to free it. Both the caller and the implementation of this
    ///                      method use the COM task allocator returned by CoGetMalloc. If an error occurs, the implementation must set
    ///                      *<i>ppszDisplayName</i> should be set to <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY, as well as the following values. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The method completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MK_E_EXCEEDEDDEADLINE</b></dt> </dl> </td> <td width="60%"> The binding operation could not be
    ///    completed within the time limit specified by the bind context's BIND_OPTS structure. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> There is no display name. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetDisplayName(IBindCtx pbc, IMoniker pmkToLeft, ushort** ppszDisplayName);
    ///Converts a display name into a moniker.
    ///Params:
    ///    pbc = A pointer to the IBindCtx interface on the bind context to be used in this binding operation. The bind
    ///          context caches objects bound during the binding process, contains parameters that apply to all operations
    ///          using the bind context, and provides the means by which the moniker implementation should retrieve
    ///          information about its environment.
    ///    pmkToLeft = A pointer to the IMoniker interface on the moniker that has been built out of the display name up to this
    ///                point.
    ///    pszDisplayName = The remaining display name to be parsed.
    ///    pchEaten = A pointer to a variable that receives the number of characters in <i>pszDisplayName</i> that were consumed in
    ///               this step.
    ///    ppmkOut = A pointer to an IMoniker pointer variable that receives the interface pointer to the moniker that was built
    ///              from <i>pszDisplayName</i>. When successful, the implementation must call AddRef on the new moniker; it is
    ///              the caller's responsibility to call Release. If an error occurs, the implementation sets *<i>ppmkOut</i> to
    ///              <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return valuesE_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The parsing operation was completed successfully. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>MK_E_SYNTAX</b></dt> </dl> </td> <td width="60%"> An error in the
    ///    syntax of the input components (<i>pmkToLeft</i>, this moniker, and <i>pszDisplayName</i>). For example, a
    ///    file moniker returns this error if <i>pmkToLeft</i> is non-<b>NULL</b>, and an item moniker returns it if
    ///    <i>pmkToLeft</i> is <b>NULL</b>. </td> </tr> </table> This method can also return the errors associated with
    ///    the IMoniker::BindToObject method.
    ///    
    HRESULT ParseDisplayName(IBindCtx pbc, IMoniker pmkToLeft, ushort* pszDisplayName, uint* pchEaten, 
                             IMoniker* ppmkOut);
    ///Determines whether this moniker is one of the system-provided moniker classes.
    ///Params:
    ///    pdwMksys = A pointer to a variables that receives one of the values from the MKSYS enumeration and refers to one of the
    ///               COM moniker classes. This parameter cannot be <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK to indicate that the moniker is a system moniker, and S_FALSE otherwise.
    ///    
    HRESULT IsSystemMoniker(uint* pdwMksys);
}

///Implemented by monikers to enable the running object table (ROT) to compare monikers against each other.
@GUID("F29F6BC0-5021-11CE-AA15-00006901293F")
interface IROTData : IUnknown
{
    ///Retrieves data from a moniker that can be used to test the moniker for equality against another moniker.
    ///Params:
    ///    pbData = A pointer to a buffer that receives the comparison data.
    ///    cbMax = The length of the buffer specified in <i>pbData</i>.
    ///    pcbData = A pointer to a variable that receives the length of the comparison data.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and S_OK.
    ///    
    HRESULT GetComparisonData(char* pbData, uint cbMax, uint* pcbData);
}

///Enables an object to be loaded from or saved to a disk file, rather than a storage object or stream. Because the
///information needed to open a file varies greatly from one application to another, the implementation of
///IPersistFile::Load on the object must also open its disk file.
@GUID("0000010B-0000-0000-C000-000000000046")
interface IPersistFile : IPersist
{
    ///Determines whether an object has changed since it was last saved to its current file.
    ///Returns:
    ///    This method returns S_OK to indicate that the object has changed. Otherwise, it returns S_FALSE.
    ///    
    HRESULT IsDirty();
    ///Opens the specified file and initializes an object from the file contents.
    ///Params:
    ///    pszFileName = The absolute path of the file to be opened.
    ///    dwMode = The access mode to be used when opening the file. Possible values are taken from the STGM enumeration. The
    ///             method can treat this value as a suggestion, adding more restrictive permissions if necessary. If
    ///             <i>dwMode</i> is 0, the implementation should open the file using whatever default permissions are used when
    ///             a user opens the file.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The object could not be loaded due to a lack of memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The object could not be loaded for some reason other than
    ///    a lack of memory. </td> </tr> </table>
    ///    
    HRESULT Load(ushort* pszFileName, uint dwMode);
    ///Saves a copy of the object to the specified file.
    ///Params:
    ///    pszFileName = The absolute path of the file to which the object should be saved. If <i>pszFileName</i> is <b>NULL</b>, the
    ///                  object should save its data to the current file, if there is one.
    ///    fRemember = Indicates whether the <i>pszFileName</i> parameter is to be used as the current working file. If <b>TRUE</b>,
    ///                <i>pszFileName</i> becomes the current file and the object should clear its dirty flag after the save. If
    ///                <b>FALSE</b>, this save operation is a <b>Save A Copy As ...</b> operation. In this case, the current file is
    ///                unchanged and the object should not clear its dirty flag. If <i>pszFileName</i> is <b>NULL</b>, the
    ///                implementation should ignore the <i>fRemember</i> flag.
    ///Returns:
    ///    If the object was successfully saved, the return value is S_OK. Otherwise, it is S_FALSE. This method can
    ///    also return various storage errors.
    ///    
    HRESULT Save(ushort* pszFileName, BOOL fRemember);
    ///Notifies the object that it can write to its file. It does this by notifying the object that it can revert from
    ///NoScribble mode (in which it must not write to its file), to Normal mode (in which it can). The component enters
    ///NoScribble mode when it receives an IPersistFile::Save call.
    ///Params:
    ///    pszFileName = The absolute path of the file where the object was saved previously.
    ///Returns:
    ///    This method always returns S_OK.
    ///    
    HRESULT SaveCompleted(ushort* pszFileName);
    ///Retrieves the current name of the file associated with the object. If there is no current working file, this
    ///method retrieves the default save prompt for the object.
    ///Params:
    ///    ppszFileName = The path for the current file or the default file name prompt (such as *.txt). If an error occurs,
    ///                   <i>ppszFileName</i> is set to <b>NULL</b>.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> A valid absolute path was
    ///    returned successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> The default save prompt was returned. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The operation failed due to insufficient memory.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation
    ///    failed due to some reason other than insufficient memory. </td> </tr> </table>
    ///    
    HRESULT GetCurFile(ushort** ppszFileName);
}

///Enables a container application to pass a storage object to one of its contained objects and to load and save the
///storage object. This interface supports the structured storage model, in which each contained object has its own
///storage that is nested within the container's storage.
@GUID("0000010A-0000-0000-C000-000000000046")
interface IPersistStorage : IPersist
{
    ///Determines whether an object has changed since it was last saved to its current storage.
    ///Returns:
    ///    This method returns S_OK to indicate that the object has changed. Otherwise, it returns S_FALSE.
    ///    
    HRESULT IsDirty();
    ///Initializes a new storage object.
    ///Params:
    ///    pStg = An IStorage pointer to the new storage object to be initialized. The container creates a nested storage
    ///           object in its storage object (see IStorage::CreateStorage). Then, the container calls the WriteClassStg
    ///           function to initialize the new storage object with the object class identifier (CLSID).
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_ALREADYINITIALIZED</b></dt> </dl> </td> <td
    ///    width="60%"> The object has already been initialized by a previous call to either the IPersistStorage::Load
    ///    method or the IPersistStorage::InitNew method. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The storage object was not initialized due to a
    ///    lack of memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    The storage object was not initialized for some reason other than a lack of memory. </td> </tr> </table>
    ///    
    HRESULT InitNew(IStorage pStg);
    ///Loads an object from its existing storage.
    ///Params:
    ///    pStg = An IStorage pointer to the existing storage from which the object is to be loaded.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_ALREADYINITIALIZED</b></dt> </dl> </td> <td
    ///    width="60%"> The object has already been initialized by a previous call to the IPersistStorage::Load method
    ///    or the IPersistStorage::InitNew method. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> The object was not loaded due to lack of memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The object was not loaded due to some
    ///    reason other than a lack of memory. </td> </tr> </table>
    ///    
    HRESULT Load(IStorage pStg);
    ///Saves an object, and any nested objects that it contains, into the specified storage object. The object enters
    ///NoScribble mode.
    ///Params:
    ///    pStgSave = An IStorage pointer to the storage into which the object is to be saved.
    ///    fSameAsLoad = Indicates whether the specified storage is the current one, which was passed to the object by one of the
    ///                  following calls: IPersistStorage::InitNew, IPersistStorage::Load, or IPersistStorage::SaveCompleted. This
    ///                  parameter is set to <b>FALSE</b> when performing a <b>Save As</b> or <b>Save A Copy To</b> operation or when
    ///                  performing a full save. In the latter case, this method saves to a temporary file, deletes the original file,
    ///                  and renames the temporary file. This parameter is set to <b>TRUE</b> to perform a full save in a low-memory
    ///                  situation or to perform a fast incremental save in which only the dirty components are saved.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>STG_E_MEDIUMFULL</b></dt> </dl> </td> <td
    ///    width="60%"> The object was not saved because of a lack of space on the disk. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The object could not be saved due to
    ///    errors other than a lack of disk space. </td> </tr> </table>
    ///    
    HRESULT Save(IStorage pStgSave, BOOL fSameAsLoad);
    ///Notifies the object that it can write to its storage object. It does this by notifying the object that it can
    ///revert from NoScribble mode (in which it must not write to its storage object), to Normal mode (in which it can).
    ///The object enters NoScribble mode when it receives an IPersistStorage::Save call.
    ///Params:
    ///    pStgNew = An IStorage pointer to the new storage object, if different from the storage object prior to saving. This
    ///              pointer can be <b>NULL</b> if the current storage object does not change during the save operation. If the
    ///              object is in HandsOff mode, this parameter must be non-<b>NULL</b>.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The object remained in HandsOff mode or NoScribble mode due to a lack of memory. Typically, this
    ///    error occurs when the object is not able to open the necessary streams and storage objects in <i>pStgNew</i>.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>pStgNew</i> parameter is not valid. Typically, this error occurs if <i>pStgNew</i> is <b>NULL</b> when the
    ///    object is in HandsOff mode. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td>
    ///    <td width="60%"> The object is in Normal mode, and there was no previous call to IPersistStorage::Save or
    ///    IPersistStorage::HandsOffStorage. </td> </tr> </table>
    ///    
    HRESULT SaveCompleted(IStorage pStgNew);
    ///Instructs the object to release all storage objects that have been passed to it by its container and to enter
    ///HandsOff mode.
    ///Returns:
    ///    This method returns S_OK to indicate that the object has entered HandsOff mode successfully.
    ///    
    HRESULT HandsOffStorage();
}

///Enumerates the FORMATETC structures that define the formats and media supported by a given data object.
@GUID("00000103-0000-0000-C000-000000000046")
interface IEnumFORMATETC : IUnknown
{
    ///Retrieves the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be retrieved. If there are fewer than the requested number of items left in the
    ///           sequence, this method retrieves the remaining elements.
    ///    rgelt = An array of enumerated items. The enumerator is responsible for allocating any memory, and the caller is
    ///            responsible for freeing it. If <i>celt</i> is greater than 1, the caller must also pass a non-<b>NULL</b>
    ///            pointer passed to <i>pceltFetched</i> to know how many pointers to release.
    ///    pceltFetched = The number of items that were retrieved. This parameter is always less than or equal to the number of items
    ///                   requested. This parameter can be <b>NULL</b> if <i>celt</i> is 1.
    ///Returns:
    ///    If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Skips over the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be skipped.
    ///Returns:
    ///    If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Skip(uint celt);
    ///Resets the enumeration sequence to the beginning.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT Reset();
    ///Creates a new enumerator that contains the same enumeration state as the current one. This method makes it
    ///possible to record a particular point in the enumeration sequence and then return to that point at a later time.
    ///The caller must release this new enumerator separately from the first enumerator.
    ///Params:
    ///    ppenum = Address of an IEnumFORMATETC pointer variable that receives the interface pointer to the enumeration object.
    ///             If the method is unsuccessful, the value of this output variable is undefined.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified enumerator is invalid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory
    ///    available for this operation. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumFORMATETC* ppenum);
}

///Enumerates the advisory connection information for a data object.
@GUID("00000105-0000-0000-C000-000000000046")
interface IEnumSTATDATA : IUnknown
{
    ///Retrieves the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be retrieved. If there are fewer than the requested number of items left in the
    ///           sequence, this method retrieves the remaining elements.
    ///    rgelt = An array of enumerated items. The enumerator is responsible for allocating any memory, and the caller is
    ///            responsible for freeing it. If <i>celt</i> is greater than 1, the caller must also pass a non-<b>NULL</b>
    ///            pointer passed to <i>pceltFetched</i> to know how many pointers to release.
    ///    pceltFetched = The number of items that were retrieved. This parameter is always less than or equal to the number of items
    ///                   requested. This parameter can be <b>NULL</b> if <i>celt</i> is 1.
    ///Returns:
    ///    If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Skips over the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be skipped.
    ///Returns:
    ///    If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Skip(uint celt);
    ///Resets the enumeration sequence to the beginning.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT Reset();
    ///Creates a new enumerator that contains the same enumeration state as the current one. This method makes it
    ///possible to record a particular point in the enumeration sequence and then return to that point at a later time.
    ///The caller must release this new enumerator separately from the first enumerator.
    ///Params:
    ///    ppenum = A pointer to an IEnumSTATDATA pointer variable that receives the interface pointer to the enumeration object.
    ///             If the method is unsuccessful, the value of this output variable is undefined.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified enumerator is invalid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory
    ///    available for this operation. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumSTATDATA* ppenum);
}

///Enables containers and other objects to receive notifications of data changes, view changes, and compound-document
///changes occurring in objects of interest. Container applications, for example, require such notifications to keep
///cached presentations of their linked and embedded objects up-to-date. Calls to <b>IAdviseSink</b> methods are
///asynchronous, so the call is sent and then the next instruction is executed without waiting for the call's return.
///For an advisory connection to exist, the object that is to receive notifications must implement <b>IAdviseSink</b>,
///and the objects in which it is interested must implement IOleObject::Advise and IDataObject::DAdvise. In-process
///objects and handlers may also implement IViewObject::SetAdvise. Objects implementing IOleObject must support all
///reasonable advisory methods. To simplify advisory notifications, OLE supplies implementations of the
///IDataAdviseHolder and IOleAdviseHolder, which keep track of advisory connections and send notifications to the proper
///sinks through pointers to their <b>IAdviseSink</b> interfaces. IViewObject (and its advisory methods) is implemented
///in the default handler. As shown in the following table, an object that has implemented an advise sink registers its
///interest in receiving certain types of notifications by calling the appropriate method. <table> <tr> <th>Call This
///Method</th> <th> To Register for These Notifications</th> </tr> <tr> <td> IOleObject::Advise </td> <td>When a
///document is saved, closed, or renamed. </td> </tr> <tr> <td> IDataObject::DAdvise </td> <td>When a document's data
///changes. </td> </tr> <tr> <td> IViewObject::SetAdvise </td> <td>When a document's presentation changes. </td> </tr>
///</table> When an event occurs that applies to a registered notification type, the object application calls the
///appropriate <b>IAdviseSink</b> method. For example, when an embedded object closes, it calls the IAdviseSink::OnClose
///method to notify its container. These notifications are asynchronous, occurring after the events that trigger them.
@GUID("0000010F-0000-0000-C000-000000000046")
interface IAdviseSink : IUnknown
{
    ///Called by the server to notify a data object's currently registered advise sinks that data in the object has
    ///changed.
    ///Params:
    ///    pFormatetc = A pointer to a FORMATETC structure, which describes the format, target device, rendering, and storage
    ///                 information of the calling data object.
    ///    pStgmed = A pointer to a STGMEDIUM structure, which defines the storage medium (global memory, disk file, storage
    ///              object, stream object, GDI object, or undefined) and ownership of that medium for the calling data object.
    void OnDataChange(FORMATETC* pFormatetc, STGMEDIUM* pStgmed);
    ///Notifies an object's registered advise sinks that its view has changed.
    ///Params:
    ///    dwAspect = The aspect, or view, of the object. Contains a value taken from the DVASPECT enumeration.
    ///    lindex = The portion of the view that has changed. Currently only -1 is valid.
    void OnViewChange(uint dwAspect, int lindex);
    ///Called by the server to notify all registered advisory sinks that the object has been renamed.
    ///Params:
    ///    pmk = A pointer to the IMoniker interface on the new full moniker of the object.
    void OnRename(IMoniker pmk);
    ///Called by the server to notify all registered advisory sinks that the object has been saved.
    void OnSave();
    ///Called by the server to notify all registered advisory sinks that the object has changed from the running to the
    ///loaded state.
    void OnClose();
}

@GUID("00000150-0000-0000-C000-000000000046")
interface AsyncIAdviseSink : IUnknown
{
    void Begin_OnDataChange(FORMATETC* pFormatetc, STGMEDIUM* pStgmed);
    void Finish_OnDataChange();
    void Begin_OnViewChange(uint dwAspect, int lindex);
    void Finish_OnViewChange();
    void Begin_OnRename(IMoniker pmk);
    void Finish_OnRename();
    void Begin_OnSave();
    void Finish_OnSave();
    void Begin_OnClose();
    void Finish_OnClose();
}

///The <b>IAdviseSink2</b> interface is an extension of the IAdviseSink interface, adding the method OnLinkSrcChange to
///the contract to handle a change in the moniker of a linked object. This avoids overloading the implementation
///IAdviseSink::OnRename to handle the renaming of both embedded objects and linked objects. In applications where
///different blocks of code might execute depending on which of these two similar events has occurred, using the same
///method for both events complicates testing and debugging.
@GUID("00000125-0000-0000-C000-000000000046")
interface IAdviseSink2 : IAdviseSink
{
    ///Notifies the container that registered the advise sink that a link source has changed (either name or location),
    ///enabling the container to update the link's moniker.
    ///Params:
    ///    pmk = A pointer to the IMoniker interface identifying the source of a linked object.
    void OnLinkSrcChange(IMoniker pmk);
}

@GUID("00000151-0000-0000-C000-000000000046")
interface AsyncIAdviseSink2 : AsyncIAdviseSink
{
    void Begin_OnLinkSrcChange(IMoniker pmk);
    void Finish_OnLinkSrcChange();
}

///Enables data transfer and notification of changes in data. Data transfer methods specify the format of the
///transferred data along with the medium through which the data is to be transferred. Optionally, the data can be
///rendered for a specific target device. In addition to methods for retrieving and storing data, the <b>IDataObject</b>
///interface specifies methods for enumerating available formats and managing connections to advisory sinks for handling
///change notifications. The term <i>data object</i> is used to mean any object that supports an implementation of the
///<b>IDataObject</b> interface. Implementations vary, depending on what the data object is required to do; in some data
///objects, the implementation of certain methods not supported by the object could simply be the return of E_NOTIMPL.
///For example, some data objects do not allow callers to send them data. Other data objects do not support advisory
///connections and change notifications. However, for those data objects that do support change notifications, OLE
///provides an object called a data advise holder. An interface pointer to this holder is available through a call to
///the helper function CreateDataAdviseHolder. A data object can have multiple connections, each with its own set of
///attributes. The OLE data advise holder simplifies the task of managing these connections and sending the appropriate
///notifications.
@GUID("0000010E-0000-0000-C000-000000000046")
interface IDataObject : IUnknown
{
    ///Called by a data consumer to obtain data from a source data object. The <b>GetData</b> method renders the data
    ///described in the specified FORMATETC structure and transfers it through the specified STGMEDIUM structure. The
    ///caller then assumes responsibility for releasing the <b>STGMEDIUM</b> structure.
    ///Params:
    ///    pformatetcIn = A pointer to the FORMATETC structure that defines the format, medium, and target device to use when passing
    ///                   the data. It is possible to specify more than one medium by using the Boolean OR operator, allowing the
    ///                   method to choose the best medium among those specified.
    ///    pmedium = A pointer to the STGMEDIUM structure that indicates the storage medium containing the returned data through
    ///              its tymed member, and the responsibility for releasing the medium through the value of its
    ///              <b>pUnkForRelease</b> member. If <b>pUnkForRelease</b> is <b>NULL</b>, the receiver of the medium is
    ///              responsible for releasing it; otherwise, <b>pUnkForRelease</b> points to the IUnknown on the appropriate
    ///              object so its Release method can be called. The medium must be allocated and filled in by <b>GetData</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_LINDEX</b></dt> </dl> </td> <td
    ///    width="60%"> The value for <b>lindex</b> is not valid; currently, only -1 is supported. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>DV_E_FORMATETC</b></dt> </dl> </td> <td width="60%"> The value for
    ///    <i>pformatetcIn</i> is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_TYMED</b></dt> </dl>
    ///    </td> <td width="60%"> The <b>tymed</b> value is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DV_E_DVASPECT</b></dt> </dl> </td> <td width="60%"> The <b>dwAspect</b> value is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_NOTRUNNING</b></dt> </dl> </td> <td width="60%"> The object
    ///    application is not running. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>STG_E_MEDIUMFULL</b></dt> </dl>
    ///    </td> <td width="60%"> An error occurred when allocating the medium. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>dwDirection</i> value
    ///    is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> There was insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT GetData(FORMATETC* pformatetcIn, STGMEDIUM* pmedium);
    ///Called by a data consumer to obtain data from a source data object. This method differs from the GetData method
    ///in that the caller must allocate and free the specified storage medium.
    ///Params:
    ///    pformatetc = A pointer to the FORMATETC structure that defines the format, medium, and target device to use when passing
    ///                 the data. Only one medium can be specified in <b>tymed</b>, and only the following values are valid:
    ///                 TYMED_ISTORAGE, TYMED_ISTREAM, TYMED_HGLOBAL, or TYMED_FILE.
    ///    pmedium = A pointer to the STGMEDIUM structure that defines the storage medium containing the data being transferred.
    ///              The medium must be allocated by the caller and filled in by <b>GetDataHere</b>. The caller must also free the
    ///              medium. The implementation of this method must always supply a value of <b>NULL</b> for the
    ///              <b>punkForRelease</b> member of the <b>STGMEDIUM</b> structure to which this parameter points.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_LINDEX</b></dt> </dl> </td> <td
    ///    width="60%"> The value for <b>lindex</b> is not valid; currently, only -1 is supported. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>DV_E_FORMATETC</b></dt> </dl> </td> <td width="60%"> The value for <i>pformatetc</i>
    ///    is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_TYMED</b></dt> </dl> </td> <td width="60%">
    ///    The <b>tymed</b> value is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_DVASPECT</b></dt>
    ///    </dl> </td> <td width="60%"> The <b>dwAspect</b> value is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_NOTRUNNING</b></dt> </dl> </td> <td width="60%"> The object application is not running. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>STG_E_MEDIUMFULL</b></dt> </dl> </td> <td width="60%"> An error
    ///    occurred when allocating the medium. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt>
    ///    </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>dwDirection</i> parameter is not valid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There was
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT GetDataHere(FORMATETC* pformatetc, STGMEDIUM* pmedium);
    ///Determines whether the data object is capable of rendering the data as specified. Objects attempting a paste or
    ///drop operation can call this method before calling IDataObject::GetData to get an indication of whether the
    ///operation may be successful.
    ///Params:
    ///    pformatetc = A pointer to the FORMATETC structure defining the format, medium, and target device to use for the query.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_LINDEX</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid value for <b>lindex</b>; currently, only -1 is supported. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>DV_E_FORMATETC</b></dt> </dl> </td> <td width="60%"> Invalid value for
    ///    <i>pformatetc</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_TYMED</b></dt> </dl> </td> <td
    ///    width="60%"> The <b>tymed</b> value is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DV_E_DVASPECT</b></dt> </dl> </td> <td width="60%"> The <b>dwAspect</b> value is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_NOTRUNNING</b></dt> </dl> </td> <td width="60%"> The object
    ///    application is not running. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td>
    ///    <td width="60%"> An unexpected error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>dwDirection</i> value is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT QueryGetData(FORMATETC* pformatetc);
    ///Provides a potentially different but logically equivalent FORMATETC structure. You use this method to determine
    ///whether two different <b>FORMATETC</b> structures would return the same data, removing the need for duplicate
    ///rendering.
    ///Params:
    ///    pformatectIn = A pointer to the FORMATETC structure that defines the format, medium, and target device that the caller would
    ///                   like to use to retrieve data in a subsequent call such as IDataObject::GetData. The <b>tymed</b> member is
    ///                   not significant in this case and should be ignored.
    ///    pformatetcOut = A pointer to a FORMATETC structure that contains the most general information possible for a specific
    ///                    rendering, making it canonically equivalent to <i>pformatetcIn</i>. The caller must allocate this structure
    ///                    and the <b>GetCanonicalFormatEtc</b> method must fill in the data. To retrieve data in a subsequent call like
    ///                    IDataObject::GetData, the caller uses the specified value of <i>pformatetcOut</i>, unless the value specified
    ///                    is <b>NULL</b>. This value is <b>NULL</b> if the method returns DATA_S_SAMEFORMATETC. The <b>tymed</b> member
    ///                    is not significant in this case and should be ignored.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The returned FORMATETC structure
    ///    is different from the one that was passed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DATA_S_SAMEFORMATETC</b></dt> </dl> </td> <td width="60%"> The FORMATETC structures are the same and
    ///    <b>NULL</b> is returned in <i>pformatetcOut</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DV_E_LINDEX</b></dt> </dl> </td> <td width="60%"> The value for <b>lindex</b> is not valid; currently,
    ///    only -1 is supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_FORMATETC</b></dt> </dl> </td> <td
    ///    width="60%"> The value for <i>pformatetc</i> is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_NOTRUNNING</b></dt> </dl> </td> <td width="60%"> The object application is not running. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected
    ///    error has occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>dwDirection</i> parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient memory available for this
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT GetCanonicalFormatEtc(FORMATETC* pformatectIn, FORMATETC* pformatetcOut);
    ///Called by an object containing a data source to transfer data to the object that implements this method.
    ///Params:
    ///    pformatetc = A pointer to the FORMATETC structure defining the format used by the data object when interpreting the data
    ///                 contained in the storage medium.
    ///    pmedium = A pointer to the STGMEDIUM structure defining the storage medium in which the data is being passed.
    ///    fRelease = If <b>TRUE</b>, the data object called, which implements <b>SetData</b>, owns the storage medium after the
    ///               call returns. This means it must free the medium after it has been used by calling the ReleaseStgMedium
    ///               function. If <b>FALSE</b>, the caller retains ownership of the storage medium and the data object called uses
    ///               the storage medium for the duration of the call only.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_LINDEX</b></dt> </dl> </td> <td
    ///    width="60%"> Invalid value for <b>lindex</b>; currently, only -1 is supported. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>DV_E_FORMATETC</b></dt> </dl> </td> <td width="60%"> The value for <i>pformatetc</i>
    ///    is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_TYMED</b></dt> </dl> </td> <td width="60%">
    ///    The <b>tymed</b> value is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_DVASPECT</b></dt>
    ///    </dl> </td> <td width="60%"> The <b>dwAspect</b> value is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_NOTRUNNING</b></dt> </dl> </td> <td width="60%"> The object application is not running. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An
    ///    unexpected error has occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The <i>dwDirection</i> value is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient memory available for this
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT SetData(FORMATETC* pformatetc, STGMEDIUM* pmedium, BOOL fRelease);
    ///Creates an object to enumerate the formats supported by a data object.
    ///Params:
    ///    dwDirection = The direction of the data. Possible values come from the DATADIR enumeration. The value DATADIR_GET
    ///                  enumerates the formats that can be passed in to a call to IDataObject::GetData. The value DATADIR_SET
    ///                  enumerates those formats that can be passed in to a call to IDataObject::SetData.
    ///    ppenumFormatEtc = A pointer to an IEnumFORMATETC pointer variable that receives the interface pointer to the new enumerator
    ///                      object.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The supplied <i>dwDirection</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory available for this operation.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The direction
    ///    specified by <i>dwDirection</i> is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_S_USEREG</b></dt> </dl> </td> <td width="60%"> Requests that OLE enumerate the formats from the
    ///    registry. </td> </tr> </table>
    ///    
    HRESULT EnumFormatEtc(uint dwDirection, IEnumFORMATETC* ppenumFormatEtc);
    ///Called by an object supporting an advise sink to create a connection between a data object and the advise sink.
    ///This enables the advise sink to be notified of changes in the data of the object.
    ///Params:
    ///    pformatetc = A pointer to a FORMATETC structure that defines the format, target device, aspect, and medium that will be
    ///                 used for future notifications. For example, one sink may want to know only when the bitmap representation of
    ///                 the data in the data object changes. Another sink may be interested in only the metafile format of the same
    ///                 object. Each advise sink is notified when the data of interest changes. This data is passed back to the
    ///                 advise sink when notification occurs.
    ///    advf = A group of flags for controlling the advisory connection. Possible values are from the ADVF enumeration.
    ///           However, only some of the possible <b>ADVF</b> values are relevant for this method. The following table
    ///           briefly describes the relevant values. <table> <tr> <th>ADVF Value</th> <th>Description</th> </tr> <tr>
    ///           <td>ADVF_NODATA </td> <td> Asks the data object to avoid sending data with the notifications. Typically data
    ///           is sent. This flag is a way to override the default behavior. When ADVF_NODATA is used, the <b>tymed</b>
    ///           member of the STGMEDIUM structure that is passed to OnDataChange will usually contain TYMED_NULL. The caller
    ///           can then retrieve the data with a subsequent IDataObject::GetData call. </td> </tr> <tr> <td>ADVF_ONLYONCE
    ///           </td> <td> Causes the advisory connection to be destroyed after the first change notification is sent. An
    ///           implicit call to IDataObject::DUnadvise is made on behalf of the caller to remove the connection. </td> </tr>
    ///           <tr> <td>ADVF_PRIMEFIRST </td> <td> Asks for an additional initial notification. The combination of
    ///           ADVF_ONLYONCE and ADVF_PRIMEFIRST provides, in effect, an asynchronous IDataObject::GetData call. </td> </tr>
    ///           <tr> <td>ADVF_DATAONSTOP </td> <td> When specified with ADVF_NODATA, this flag causes a last notification
    ///           with the data included to to be sent before the data object is destroyed. If used without ADVF_NODATA,
    ///           <b>DAdvise</b> can be implemented in one of the following ways: <ul> <li>The ADVF_DATAONSTOP can be
    ///           ignored.</li> <li>The object can behave as if ADVF_NODATA was specified.</li> </ul> A change notification is
    ///           sent only in the shutdown case. Data changes prior to shutdown do not cause a notification to be sent. </td>
    ///           </tr> </table>
    ///    pAdvSink = A pointer to the IAdviseSink interface on the advisory sink that will receive the change notification.
    ///    pdwConnection = A token that identifies this connection. You can use this token later to delete the advisory connection (by
    ///                    passing it to IDataObject::DUnadvise). If this value is 0, the connection was not established.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> This method is not implemented on the data object. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DV_E_LINDEX</b></dt> </dl> </td> <td width="60%"> The value for <b>lindex</b> is not valid; currently,
    ///    only -1 is supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_FORMATETC</b></dt> </dl> </td> <td
    ///    width="60%"> The value for <i>pformatetc</i> is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_ADVISENOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> The data object does not support change
    ///    notification. </td> </tr> </table>
    ///    
    HRESULT DAdvise(FORMATETC* pformatetc, uint advf, IAdviseSink pAdvSink, uint* pdwConnection);
    ///Destroys a notification connection that had been previously set up.
    ///Params:
    ///    dwConnection = A token that specifies the connection to be removed. Use the value returned by IDataObject::DAdvise when the
    ///                   connection was originally established.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_NOCONNECTION</b></dt> </dl>
    ///    </td> <td width="60%"> The specified value for <i>dwConnection</i> is not a valid connection. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>OLE_E_ADVISENOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> This
    ///    IDataObject implementation does not support notification. </td> </tr> </table>
    ///    
    HRESULT DUnadvise(uint dwConnection);
    ///Creates an object that can be used to enumerate the current advisory connections.
    ///Params:
    ///    ppenumAdvise = A pointer to an IEnumSTATDATA pointer variable that receives the interface pointer to the new enumerator
    ///                   object. If the implementation sets *<i>ppenumAdvise</i> to <b>NULL</b>, there are no connections to advise
    ///                   sinks at this time.
    ///Returns:
    ///    This method returns S_OK if the enumerator object is successfully instantiated or there are no connections.
    ///    Other possible values include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory is
    ///    available for the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_ADVISENOTSUPPORTED</b></dt>
    ///    </dl> </td> <td width="60%"> Advisory notifications are not supported by this object. </td> </tr> </table>
    ///    
    HRESULT EnumDAdvise(IEnumSTATDATA* ppenumAdvise);
}

///Creates and manages advisory connections between a data object and one or more advise sinks. Its methods are intended
///to be used to implement the advisory methods of IDataObject. <b>IDataAdviseHolder</b> is implemented on an advise
///holder object. Its methods establish and delete data advisory connections and send notification of change in data
///from a data object to an object that requires this notification, such as an OLE container, which must contain an
///advise sink. Advise sinks are objects that require notification of change in the data the object contains and
///implement the IAdviseSink interface. Advise sinks are also usually associated with OLE compound document containers.
@GUID("00000110-0000-0000-C000-000000000046")
interface IDataAdviseHolder : IUnknown
{
    ///Creates a connection between an advise sink and a data object for receiving notifications.
    ///Params:
    ///    pDataObject = A pointer to the IDataObject interface on the data object for which notifications are requested. If data in
    ///                  this object changes, a notification is sent to the advise sinks that have requested notification.
    ///    pFetc = A pointer to a FORMATETC structure that contains the specified format, medium, and target device that is of
    ///            interest to the advise sink requesting notification. For example, one sink may want to know only when the
    ///            bitmap representation of the data in the data object changes. Another sink may be interested in only the
    ///            metafile format of the same object. Each advise sink is notified when the data of interest changes. This data
    ///            is passed back to the advise sink when notification occurs.
    ///    advf = A group of flags that control the advisory connection. Possible values are from the ADVF enumeration.
    ///           However, only some of the possible <b>ADVF</b> values are relevant for this method. The following table
    ///           briefly describes the relevant values; a more detailed description can be found in the description of the
    ///           <b>ADVF</b> enumeration. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///           id="ADVF_NODATA"></a><a id="advf_nodata"></a><dl> <dt><b>ADVF_NODATA</b></dt> </dl> </td> <td width="60%">
    ///           Asks that no data be sent along with the notification. </td> </tr> <tr> <td width="40%"><a
    ///           id="ADVF_ONLYONCE"></a><a id="advf_onlyonce"></a><dl> <dt><b>ADVF_ONLYONCE</b></dt> </dl> </td> <td
    ///           width="60%"> Causes the advisory connection to be destroyed after the first notification is sent. An implicit
    ///           call to IDataAdviseHolder::Unadvise is made on behalf of the caller to remove the connection. </td> </tr>
    ///           <tr> <td width="40%"><a id="ADVF_PRIMEFIRST"></a><a id="advf_primefirst"></a><dl>
    ///           <dt><b>ADVF_PRIMEFIRST</b></dt> </dl> </td> <td width="60%"> Causes an initial notification to be sent
    ///           regardless of whether data has changed from its current state. </td> </tr> <tr> <td width="40%"><a
    ///           id="ADVF_DATAONSTOP"></a><a id="advf_dataonstop"></a><dl> <dt><b>ADVF_DATAONSTOP</b></dt> </dl> </td> <td
    ///           width="60%"> When specified with ADVF_NODATA, this flag causes a last notification with the data included to
    ///           be sent before the data object is destroyed. When ADVF_NODATA is not specified, this flag has no effect.
    ///           </td> </tr> </table>
    ///    pAdvise = A pointer to the IAdviseSink interface on the advisory sink that receives the change notification.
    ///    pdwConnection = A pointer to a variable that receives a token that identifies this connection. The calling object can later
    ///                    delete the advisory connection by passing this token to IDataAdviseHolder::Unadvise. If this value is zero,
    ///                    the connection was not established.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT Advise(IDataObject pDataObject, FORMATETC* pFetc, uint advf, IAdviseSink pAdvise, uint* pdwConnection);
    ///Removes a connection between a data object and an advisory sink that was set up through a previous call to
    ///IDataAdviseHolder::Advise. This method is typically called in the implementation of IDataObject::DUnadvise.
    ///Params:
    ///    dwConnection = A token that specifies the connection to be removed. This value was returned by IDataAdviseHolder::Advise
    ///                   when the connection was originally established.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_NOCONNECTION</b></dt> </dl>
    ///    </td> <td width="60%"> The <i>dwConnection</i> parameter does not specify a valid connection. </td> </tr>
    ///    </table>
    ///    
    HRESULT Unadvise(uint dwConnection);
    ///Returns an object that can be used to enumerate the current advisory connections.
    ///Params:
    ///    ppenumAdvise = A pointer to an IEnumSTATDATA pointer variable that receives the interface pointer to the new enumerator
    ///                   object. If the implementation returns <b>NULL</b> in *<i>ppenumAdvise</i>, there are no connections to advise
    ///                   sinks at this time.
    ///Returns:
    ///    This method returns S_OK if the enumerator object is successfully instantiated or there are no connections.
    ///    
    HRESULT EnumAdvise(IEnumSTATDATA* ppenumAdvise);
    ///Sends notifications to each advise sink for which there is a connection established by calling the
    ///IAdviseSink::OnDataChange method for each advise sink currently being handled by this instance of the advise
    ///holder object.
    ///Params:
    ///    pDataObject = A pointer to the IDataObject interface on the data object in which the data has just changed. This pointer is
    ///                  used in subsequent calls to IAdviseSink::OnDataChange.
    ///    dwReserved = This parameter is reserved and must be 0.
    ///    advf = Container for advise flags that specify how the call to IAdviseSink::OnDataChange is made. These flag values
    ///           are from the enumeration ADVF. Typically, the value for <i>advf</i> is <b>NULL</b>. The only exception occurs
    ///           when the data object is shutting down and must send a final notification that includes the actual data to
    ///           sinks that have specified ADVF_DATAONSTOP and ADVF_NODATA in their call to IDataObject::DAdvise. In this
    ///           case, <i>advf</i> contains ADVF_DATAONSTOP.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT SendOnDataChange(IDataObject pDataObject, uint dwReserved, uint advf);
}

///Provides COM servers and applications with the ability to selectively handle incoming and outgoing COM messages while
///waiting for responses from synchronous calls. Filtering messages helps to ensure that calls are handled in a manner
///that improves performance and avoids deadlocks. COM messages can be synchronous, asynchronous, or input-synchronized;
///the majority of interface calls are synchronous.
@GUID("00000016-0000-0000-C000-000000000046")
interface IMessageFilter : IUnknown
{
    ///Provides a single entry point for incoming calls. This method is called prior to each method invocation
    ///originating outside the current process and provides the ability to filter or reject incoming calls (or
    ///callbacks) to an object or a process.
    ///Params:
    ///    dwCallType = The type of incoming call that has been received. Possible values are from the enumeration CALLTYPE.
    ///    htaskCaller = The thread id of the caller.
    ///    dwTickCount = The elapsed tick count since the outgoing call was made, if <i>dwCallType</i> is not CALLTYPE_TOPLEVEL. If
    ///                  <i>dwCallType</i> is CALLTYPE_TOPLEVEL, <i>dwTickCount</i> should be ignored.
    ///    lpInterfaceInfo = A pointer to an INTERFACEINFO structure that identifies the object, interface, and method being called. In
    ///                      the case of DDE calls, <i>lpInterfaceInfo</i> can be <b>NULL</b> because the DDE layer does not return
    ///                      interface information.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>SERVERCALL_ISHANDLED</b></dt> </dl> </td> <td width="60%"> The application
    ///    might be able to process the call. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>SERVERCALL_REJECTED</b></dt>
    ///    </dl> </td> <td width="60%"> The application cannot handle the call due to an unforeseen problem, such as
    ///    network unavailability, or if it is in the process of terminating. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>SERVERCALL_RETRYLATER</b></dt> </dl> </td> <td width="60%"> The application cannot handle the call at
    ///    this time. An application might return this value when it is in a user-controlled modal state. </td> </tr>
    ///    </table>
    ///    
    uint HandleInComingCall(uint dwCallType, ptrdiff_t htaskCaller, uint dwTickCount, 
                            INTERFACEINFO* lpInterfaceInfo);
    ///Provides applications with an opportunity to display a dialog box offering retry, cancel, or task-switching
    ///options.
    ///Params:
    ///    htaskCallee = The thread id of the called application.
    ///    dwTickCount = The number of elapsed ticks since the call was made.
    ///    dwRejectType = Specifies either SERVERCALL_REJECTED or SERVERCALL_RETRYLATER, as returned by the object application.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>-1</dt> </dl> </td> <td width="60%"> The call should be canceled. COM then
    ///    returns RPC_E_CALL_REJECTED from the original method call. </td> </tr> <tr> <td width="40%"> <dl> <dt>0 
    ///    <i>value</i> &lt; 100</dt> </dl> </td> <td width="60%"> The call is to be retried immediately. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>100  <i>value</i> </dt> </dl> </td> <td width="60%"> COM will wait for this
    ///    many milliseconds and then retry the call. </td> </tr> </table>
    ///    
    uint RetryRejectedCall(ptrdiff_t htaskCallee, uint dwTickCount, uint dwRejectType);
    ///Indicates that a message has arrived while COM is waiting to respond to a remote call. Handling input while
    ///waiting for an outgoing call to finish can introduce complications. The application should determine whether to
    ///process the message without interrupting the call, to continue waiting, or to cancel the operation.
    ///Params:
    ///    htaskCallee = The thread id of the called application.
    ///    dwTickCount = The number of ticks since the call was made. It is calculated from the GetTickCount function.
    ///    dwPendingType = The type of call made during which a message or event was received. Possible values are from the enumeration
    ///                    PENDINGTYPE, where PENDINGTYPE_TOPLEVEL means the outgoing call was not nested within a call from another
    ///                    application and PENDINTGYPE_NESTED means the outgoing call was nested within a call from another application.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>PENDINGMSG_CANCELCALL</b></dt> </dl> </td> <td width="60%"> Cancel the
    ///    outgoing call. This should be returned only under extreme conditions. Canceling a call that has not replied
    ///    or been rejected can create orphan transactions and lose resources. COM fails the original call and returns
    ///    RPC_E_CALL_CANCELLED. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>PENDINGMSG_WAITNOPROCESS</b></dt> </dl>
    ///    </td> <td width="60%"> Unused. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>PENDINGMSG_WAITDEFPROCESS</b></dt> </dl> </td> <td width="60%"> Keyboard and mouse messages are no
    ///    longer dispatched. However there are some cases where mouse and keyboard messages could cause the system to
    ///    deadlock, and in these cases, mouse and keyboard messages are discarded. WM_PAINT messages are dispatched.
    ///    Task-switching and activation messages are handled as before. </td> </tr> </table>
    ///    
    uint MessagePending(ptrdiff_t htaskCallee, uint dwTickCount, uint dwPendingType);
}

///Specifies a method that retrieves a class object.
@GUID("00000140-0000-0000-C000-000000000046")
interface IClassActivator : IUnknown
{
    ///Retrieves a class object.
    ///Params:
    ///    rclsid = The CLSID that identifies the class whose class object is to be retrieved.
    ///    dwClassContext = The context in which the class is expected to run. For a list of values, see the CLSCTX enumeration.
    ///    locale = An LCID constant as defined in WinNls.h.
    ///    riid = The IID of the interface on the object to which a pointer is desired.
    ///    ppv = The address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful
    ///          return, *<i>ppv</i> contains the requested interface pointer.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.
    ///    
    HRESULT GetClassObject(const(GUID)* rclsid, uint dwClassContext, uint locale, const(GUID)* riid, void** ppv);
}

///Enables applications and other objects to receive notifications of changes in the progress of a downloading
///operation.
@GUID("A9D758A0-4617-11CF-95FC-00AA00680DB4")
interface IProgressNotify : IUnknown
{
    ///Notifies registered objects and applications of the progress of a downloading operation.
    ///Params:
    ///    dwProgressCurrent = The amount of data available.
    ///    dwProgressMaximum = The total amount of data to be downloaded.
    ///    fAccurate = Indicates the accuracy of the values in <i>dwProgressCurrent</i> and <i>dwProgressMaximum</i>. They are
    ///                either reliable (<b>TRUE</b>) or unreliable (<b>FALSE</b>). The <b>FALSE</b> value indicates that control
    ///                structures for determining the actual position of, or amount of, data yet to be downloaded are not available.
    ///    fOwner = Indicates whether this <b>OnProgress</b> call can control the blocking behavior of the operation. If
    ///             <b>TRUE</b>, the caller can use return values from <b>OnProgress</b> to block (STG_S_BLOCK), retry
    ///             (STG_S_RETRYNOW), or monitor (STG_S_MONITORING) the operation. If <b>FALSE</b>, the return value from
    ///             <b>OnProgress</b> has no influence on blocking behavior.
    ///Returns:
    ///    This method can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as
    ///    well as the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>STG_S_RETRYNOW</b></dt> </dl> </td> <td width="60%"> The caller is to retry the
    ///    operation immediately. (This value is most useful for applications that do blocking from within the callback
    ///    routine.) </td> </tr> <tr> <td width="40%"> <dl> <dt><b>STG_S_BLOCK</b></dt> </dl> </td> <td width="60%"> The
    ///    caller is to block the download and retry the call as needed to determine if additional data is available.
    ///    This is the default behavior if no sinks are registered on the connection point. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>STG_S_MONITORING</b></dt> </dl> </td> <td width="60%"> The callback recipient
    ///    reliquishes control of the downloading process to one of the other objects or applications that have
    ///    registered progress notification sinks on the same stream. This is useful if the notification sink is
    ///    interested only in gathering statistics. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_PENDING</b></dt>
    ///    </dl> </td> <td width="60%"> Data is currently unavailable. The caller is to try again after some desired
    ///    interval. The notification sink returns this value if the asynchronous storage is to operate in nonblocking
    ///    mode. </td> </tr> </table>
    ///    
    HRESULT OnProgress(uint dwProgressCurrent, uint dwProgressMaximum, BOOL fAccurate, BOOL fOwner);
}

///Provides a semaphore that can be used to provide temporarily exclusive access to a shared resource such as a file.
@GUID("30F3D47A-6447-11D1-8E3C-00C04FB9386D")
interface IBlockingLock : IUnknown
{
    ///Requests a lock on a shared resource.
    ///Params:
    ///    dwTimeout = The time interval after which the attempted lock operation fails.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT Lock(uint dwTimeout);
    ///Releases a lock on a shared resource.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and
    ///    S_OK.
    ///    
    HRESULT Unlock();
}

@GUID("BC0BF6AE-8878-11D1-83E9-00C04FC2C6D4")
interface ITimeAndNoticeControl : IUnknown
{
    HRESULT SuppressChanges(uint res1, uint res2);
}

@GUID("8D19C834-8879-11D1-83E9-00C04FC2C6D4")
interface IOplockStorage : IUnknown
{
    HRESULT CreateStorageEx(const(wchar)* pwcsName, uint grfMode, uint stgfmt, uint grfAttrs, const(GUID)* riid, 
                            void** ppstgOpen);
    HRESULT OpenStorageEx(const(wchar)* pwcsName, uint grfMode, uint stgfmt, uint grfAttrs, const(GUID)* riid, 
                          void** ppstgOpen);
}

@GUID("00000026-0000-0000-C000-000000000046")
interface IUrlMon : IUnknown
{
    HRESULT AsyncGetClassBits(const(GUID)* rclsid, const(wchar)* pszTYPE, const(wchar)* pszExt, 
                              uint dwFileVersionMS, uint dwFileVersionLS, const(wchar)* pszCodeBase, IBindCtx pbc, 
                              uint dwClassContext, const(GUID)* riid, uint flags);
}

///Transfers the foreground window to the process hosting the COM server.
@GUID("00000145-0000-0000-C000-000000000046")
interface IForegroundTransfer : IUnknown
{
    ///Yields the foreground window to the COM server process.
    ///Params:
    ///    lpvReserved = This parameter is reserved and must be <b>NULL</b>.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>lpvReserved</i> parameter is not <b>NULL</b>, or this interface is on a proxy that does
    ///    not support foreground control. </td> </tr> </table>
    ///    
    HRESULT AllowForegroundTransfer(void* lpvReserved);
}

@GUID("969DC708-5C76-11D1-8D86-0000F804B057")
interface IThumbnailExtractor : IUnknown
{
    HRESULT ExtractThumbnail(IStorage pStg, uint ulLength, uint ulHeight, uint* pulOutputLength, 
                             uint* pulOutputHeight, HBITMAP* phOutputBitmap);
    HRESULT OnFileUpdated(IStorage pStg);
}

@GUID("947990DE-CC28-11D2-A0F7-00805F858FB1")
interface IDummyHICONIncluder : IUnknown
{
    HRESULT Dummy(HICON h1, HDC h2);
}

///<p class="CCE_Message">[The use of this interface is not recommended; use the IProcessInitControl interface instead.]
///Used by ISurrogateService to prevent the process from terminating due to a time-out.
@GUID("000001D5-0000-0000-C000-000000000046")
interface IProcessLock : IUnknown
{
    ///Increments the reference count of the process.
    ///Returns:
    ///    This method returns the new reference count.
    ///    
    uint AddRefOnProcess();
    ///Decrements the reference count of the process.
    ///Returns:
    ///    This method returns the new reference count.
    ///    
    uint ReleaseRefOnProcess();
}

///<p class="CCE_Message">[Use of ISurrogateService is not recommended; use IProcessInitControl instead.] Used to
///initialize, launch, and release a COM+ application. You can also refresh the catalog and shut down the process.
@GUID("000001D4-0000-0000-C000-000000000046")
interface ISurrogateService : IUnknown
{
    ///Initializes the process server.
    ///Params:
    ///    rguidProcessID = The process ID of the server application.
    ///    pProcessLock = A pointer to an instance of the IProcessLock interface.
    ///    pfApplicationAware = Indicates whether the application is aware of the initialization.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_UNEXPECTED.
    ///    
    HRESULT Init(const(GUID)* rguidProcessID, IProcessLock pProcessLock, int* pfApplicationAware);
    ///Launches the application.
    ///Params:
    ///    rguidApplID = The application identifier.
    ///    appType = The application type, as described in Remarks.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_UNEXPECTED.
    ///    
    HRESULT ApplicationLaunch(const(GUID)* rguidApplID, ApplicationType appType);
    ///Releases the application.
    ///Params:
    ///    rguidApplID = The application identifier.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_UNEXPECTED.
    ///    
    HRESULT ApplicationFree(const(GUID)* rguidApplID);
    ///Refreshes the catalog.
    ///Params:
    ///    ulReserved = This parameter is reserved.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_UNEXPECTED.
    ///    
    HRESULT CatalogRefresh(uint ulReserved);
    ///Shuts down the process.
    ///Params:
    ///    shutdownType = The shutdown type, as described in Remarks.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_UNEXPECTED.
    ///    
    HRESULT ProcessShutdown(ShutdownType shutdownType);
}

///Performs initialization or cleanup when entering or exiting a COM apartment.
@GUID("00000034-0000-0000-C000-000000000046")
interface IInitializeSpy : IUnknown
{
    ///Performs initialization steps required before calling the CoInitializeEx function.
    ///Params:
    ///    dwCoInit = The apartment type passed to CoInitializeEx, specified as a member of the COINIT enumeration.
    ///    dwCurThreadAptRefs = The number of times CoInitializeEx has been called on this thread.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT PreInitialize(uint dwCoInit, uint dwCurThreadAptRefs);
    ///Performs initialization steps required after calling the CoInitializeEx function.
    ///Params:
    ///    hrCoInit = The value returned by CoInitializeEx.
    ///    dwCoInit = The apartment type passed to CoInitializeEx, specified as a member of the COINIT enumeration.
    ///    dwNewThreadAptRefs = The number of times CoInitializeEx has been called on this thread.
    ///Returns:
    ///    This method returns the value that it intends the CoInitializeEx call to return to its caller. For more
    ///    information, see the Remarks section.
    ///    
    HRESULT PostInitialize(HRESULT hrCoInit, uint dwCoInit, uint dwNewThreadAptRefs);
    ///Performs cleanup steps required before calling the CoUninitialize function.
    ///Params:
    ///    dwCurThreadAptRefs = The number of times CoInitializeEx has been called on this thread.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT PreUninitialize(uint dwCurThreadAptRefs);
    ///Performs cleanup steps required after calling the CoUninitialize function.
    ///Params:
    ///    dwNewThreadAptRefs = The number of calls to CoUninitialize remaining on this thread.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT PostUninitialize(uint dwNewThreadAptRefs);
}

///Manages advisory connections and compound document notifications in an object server. Its methods are intended to be
///used to implement the advisory methods of IOleObject. <b>IOleAdviseHolder</b> is implemented on an advise holder
///object. Its methods establish and delete advisory connections from the object managed by the server to the object's
///container, which must contain an advise sink (support the IAdviseSink interface). The advise holder object must also
///keep track of which advise sinks are interested in which notifications and pass along the notifications as
///appropriate.
@GUID("00000111-0000-0000-C000-000000000046")
interface IOleAdviseHolder : IUnknown
{
    ///Establishes an advisory connection between an OLE object and the calling object's advise sink. Through that sink,
    ///the calling object can receive notification when the OLE object is renamed, saved, or closed.
    ///Params:
    ///    pAdvise = A pointer to the IAdviseSink interface on the advisory sink that should be informed of changes.
    ///    pdwConnection = A pointer to a token that can be passed to the IOleAdviseHolder::Unadvise method to delete the advisory
    ///                    connection. The calling object is responsible for calling both IUnknown::AddRef and IUnknown::Release on this
    ///                    pointer.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The supplied IAdviseSink interface pointer is invalid. </td> </tr> </table>
    ///    
    HRESULT Advise(IAdviseSink pAdvise, uint* pdwConnection);
    ///Deletes a previously established advisory connection.
    ///Params:
    ///    dwConnection = The value previously returned by IOleAdviseHolder::Advise in <i>pdwConnection</i>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_NOCONNECTION</b></dt>
    ///    </dl> </td> <td width="60%"> The <i>dwConnection</i> parameter does not represent a valid advisory
    ///    connection. </td> </tr> </table>
    ///    
    HRESULT Unadvise(uint dwConnection);
    ///Creates an enumerator that can be used to enumerate the advisory connections currently established for an object.
    ///Params:
    ///    ppenumAdvise = A pointer to an IEnumSTATDATA pointer variable that receives the interface pointer to the new enumerator. If
    ///                   this parameter is <b>NULL</b>, there are presently no advisory connections on the object, or an error
    ///                   occurred. The advise holder is responsible for incrementing the reference count on the <b>IEnumSTATDATA</b>
    ///                   pointer this method supplies. It is the caller's responsibility to call IUnknown::Release when it is finished
    ///                   with the pointer.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The enumeration operation has failed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> IOleAdviseHolder::EnumAdvise is not implemented. </td>
    ///    </tr> </table>
    ///    
    HRESULT EnumAdvise(IEnumSTATDATA* ppenumAdvise);
    ///Sends notification to all advisory sinks currently registered with the advise holder that the name of object has
    ///changed.
    ///Params:
    ///    pmk = A pointer to the new full moniker of the object.
    ///Returns:
    ///    This method returns S_OK if advise sinks were sent IAdviseSink::OnRename notifications.
    ///    
    HRESULT SendOnRename(IMoniker pmk);
    ///Sends notification to all advisory sinks currently registered with the advise holder that the object has been
    ///saved.
    ///Returns:
    ///    This method returns S_OK if advise sinks were sent IAdviseSink::OnSave notifications.
    ///    
    HRESULT SendOnSave();
    ///Sends notification to all advisory sinks currently registered with the advise holder that the object has closed.
    ///Returns:
    ///    This method returns S_OK if advise sinks were notified of the close operation through a call to the
    ///    IAdviseSink::OnClose method.
    ///    
    HRESULT SendOnClose();
}

///Provides control of the presentation data that gets cached inside of an object. Cached presentation data is available
///to the container of the object even when the server application is not running or is unavailable.
@GUID("0000011E-0000-0000-C000-000000000046")
interface IOleCache : IUnknown
{
    ///Specifies the format and other data to be cached inside an embedded object.
    ///Params:
    ///    pformatetc = A pointer to a FORMATETC structure that specifies the format and other data to be cached. View caching is
    ///                 specified by passing a zero clipboard format in <i>pformatetc</i>.
    ///    advf = A group of flags that control the caching. Possible values come from the ADVF enumeration. When used in this
    ///           context, for a cache, these values have specific meanings, which are outlined in Remarks. Refer to the
    ///           <b>ADVF</b> enumeration for a more detailed description.
    ///    pdwConnection = A pointer to a variable that receives the identifier of this connection, which can later be used to turn
    ///                    caching off (by passing it to IOleCache::Uncache). If this value is 0, the connection was not established.
    ///                    The OLE-provided implementation uses nonzero numbers for connection identifiers.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The supplied <i>pformatetc</i> or <i>advf</i> arguments are not valid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has
    ///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory available for the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CACHE_S_FORMATETC_NOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> The cache was created, but the
    ///    object application does not support the specified format. Cache creation succeeds even if the format is not
    ///    supported, allowing the caller to fill the cache. If, however, the caller does not need to keep the cache,
    ///    call IOleCache::Uncache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CACHE_S_SAMECACHE</b></dt> </dl> </td>
    ///    <td width="60%"> A cache already exists for the FORMATETC passed to IOleCache::Uncache. In this case, the new
    ///    advise flags are assigned to the cache, and the previously assigned connection identifier is returned. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_LINDEX</b></dt> </dl> </td> <td width="60%"> Invalid value for
    ///    <i>pformatetc</i>-&gt;<b>lindex</b>; currently only -1 is supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DV_E_TYMED</b></dt> </dl> </td> <td width="60%"> The value is not valid for
    ///    <i>pformatetc</i>-&gt;<b>tymed</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_DVASPECT</b></dt>
    ///    </dl> </td> <td width="60%"> The value is not valid for <i>pformatetc</i>-&gt;<b>dwAspect</b>. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>DV_E_CLIPFORMAT</b></dt> </dl> </td> <td width="60%"> The value is not
    ///    valid for <i>pformatetc</i>-&gt;<b>cfFormat</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_NOTINITIALIZED</b></dt> </dl> </td> <td width="60%"> The cache's storage is not initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_DVTARGETDEVICE</b></dt> </dl> </td> <td width="60%"> The
    ///    value is not valid for <i>pformatetc-</i>-&gt;<b>ptd</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_STATIC</b></dt> </dl> </td> <td width="60%"> The cache is for a static object and it already has
    ///    a cache node. </td> </tr> </table>
    ///    
    HRESULT Cache(FORMATETC* pformatetc, uint advf, uint* pdwConnection);
    ///Removes a cache connection created previously using IOleCache::Cache.
    ///Params:
    ///    dwConnection = The cache connection to be removed. This nonzero value was returned by IOleCache::Cache when the cache was
    ///                   originally established.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_NOCONNECTION</b></dt>
    ///    </dl> </td> <td width="60%"> No cache connection exists for <i>dwConnection</i>. </td> </tr> </table>
    ///    
    HRESULT Uncache(uint dwConnection);
    ///Creates an enumerator that can be used to enumerate the current cache connections.
    ///Params:
    ///    ppenumSTATDATA = A pointer to an IEnumSTATDATA pointer variable that receives the interface pointer to the new enumerator
    ///                     object. If this parameter is <b>NULL</b>, there are no cache connections at this time.
    ///Returns:
    ///    This method returns S_OK if enumerator object is successfully instantiated or there are no cache connections.
    ///    <div class="alert"><b>Note</b> Check the <i>ppenumSTATDATA</i> parameter to determine which result occurred.
    ///    If the <i>ppenumSTATDATA</i> parameter is <b>NULL</b>, then there are no cache connections at this
    ///    time.</div> <div> </div>
    ///    
    HRESULT EnumCache(IEnumSTATDATA* ppenumSTATDATA);
    ///Fills the cache as needed using the data provided by the specified data object.
    ///Params:
    ///    pDataObject = A pointer to the IDataObject interface on the data object from which the cache is to be initialized.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The pointer to the IDataObject interface is invalid. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory is available for the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_NOTRUNNING</b></dt> </dl> </td> <td
    ///    width="60%"> The cache is not running. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CACHE_E_NOCACHE_UPDATED</b></dt> </dl> </td> <td width="60%"> None of the caches were updated. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>CACHE_S_SOMECACHES_NOTUPDATED</b></dt> </dl> </td> <td width="60%">
    ///    Only some of the existing caches were updated. </td> </tr> </table>
    ///    
    HRESULT InitCache(IDataObject pDataObject);
    ///Initializes the cache with data in a specified format and on a specified medium.
    ///Params:
    ///    pformatetc = A pointer to a FORMATETC structure that specifies the format of the presentation data being placed in the
    ///                 cache.
    ///    pmedium = A pointer to a STGMEDIUM structure that specifies the storage medium that contains the presentation data.
    ///    fRelease = Indicates the ownership of the storage medium after completion of the method. If <i>fRelease</i> is
    ///               <b>TRUE</b>, the cache takes ownership, freeing the medium when it is finished using it. When <i>fRelease</i>
    ///               is <b>FALSE</b>, the caller retains ownership and is responsible for freeing the medium. The cache can only
    ///               use the storage medium for the duration of the call.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_LINDEX</b></dt> </dl>
    ///    </td> <td width="60%"> The value is not valid for <i>pformatetc</i>-&gt;<b>lindex</b>. Currently, only -1 is
    ///    supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_FORMATETC</b></dt> </dl> </td> <td width="60%">
    ///    The FORMATETC structure is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_TYMED</b></dt> </dl>
    ///    </td> <td width="60%"> The value is not valid for <i>pformatetc</i>-&gt;<b>tymed</b>. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>DV_E_DVASPECT</b></dt> </dl> </td> <td width="60%"> The value is not valid for
    ///    <i>pformatetc</i>-&gt;<b>dwAspect</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_BLANK</b></dt>
    ///    </dl> </td> <td width="60%"> There is an uninitialized object. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DV_E_TARGETDEVICE</b></dt> </dl> </td> <td width="60%"> The object is static and
    ///    <i>pformatetc</i>-&gt;<b>ptd</b> is non-<b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>STG_E_MEDIUMFULL</b></dt> </dl> </td> <td width="60%"> The storage medium is full. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetData(FORMATETC* pformatetc, STGMEDIUM* pmedium, BOOL fRelease);
}

///Enables object clients to selectively update each cache that was created with IOleCache::Cache.
@GUID("00000128-0000-0000-C000-000000000046")
interface IOleCache2 : IOleCache
{
    ///Updates the specified caches. This method is used when the application needs precise control over caching.
    ///Params:
    ///    pDataObject = A pointer to the IDataObject interface on the data object from which the cache is updated. Object handlers
    ///                  and in-process servers typically pass a non-<b>NULL</b> value. A container application usually passes
    ///                  <b>NULL</b>, and the source is obtained from the currently running object.
    ///    grfUpdf = The type of cache to be updated. This parameter can be one or more of the following values. <table> <tr>
    ///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="UPDFCACHE_NODATACACHE_"></a><a
    ///              id="updfcache_nodatacache_"></a><dl> <dt><b>UPDFCACHE_NODATACACHE </b></dt> </dl> </td> <td width="60%">
    ///              Updates caches created by using ADVF_NODATA in the call to IOleCache::Cache. </td> </tr> <tr> <td
    ///              width="40%"><a id="UPDFCACHE_ONSAVECACHE_"></a><a id="updfcache_onsavecache_"></a><dl>
    ///              <dt><b>UPDFCACHE_ONSAVECACHE </b></dt> </dl> </td> <td width="60%"> Updates caches created by using
    ///              ADVFCACHE_ONSAVE in the call to IOleCache::Cache. </td> </tr> <tr> <td width="40%"><a
    ///              id="UPDFCACHE_ONSTOPCACHE_"></a><a id="updfcache_onstopcache_"></a><dl> <dt><b>UPDFCACHE_ONSTOPCACHE
    ///              </b></dt> </dl> </td> <td width="60%"> Updates caches created by using ADVFCACHE_ONSTOP in the call to
    ///              IOleCache::Cache. </td> </tr> <tr> <td width="40%"><a id="UPDFCACHE_NORMALCACHE"></a><a
    ///              id="updfcache_normalcache"></a><dl> <dt><b>UPDFCACHE_NORMALCACHE</b></dt> </dl> </td> <td width="60%">
    ///              Dynamically updates the caches (as is normally done when the object sends out OnDataChange notices). </td>
    ///              </tr> <tr> <td width="40%"><a id="UPDFCACHE_IFBLANK"></a><a id="updfcache_ifblank"></a><dl>
    ///              <dt><b>UPDFCACHE_IFBLANK</b></dt> </dl> </td> <td width="60%"> Updates the cache if blank, regardless of any
    ///              other flag specified. </td> </tr> <tr> <td width="40%"><a id="UPDFCACHE_ONLYIFBLANK"></a><a
    ///              id="updfcache_onlyifblank"></a><dl> <dt><b>UPDFCACHE_ONLYIFBLANK</b></dt> </dl> </td> <td width="60%">
    ///              Updates only caches that are blank. </td> </tr> <tr> <td width="40%"><a
    ///              id="UPDFCACHE__IFBLANKORONSAVECACHE"></a><a id="updfcache__ifblankoronsavecache"></a><dl> <dt><b>UPDFCACHE_
    ///              IFBLANKORONSAVECACHE</b></dt> </dl> </td> <td width="60%"> The equivalent of using an OR operation to combine
    ///              UPDFCACHE_IFBLANK and UPDFCACHE_ONSAVECACHE. </td> </tr> <tr> <td width="40%"><a id="UPDFCACHE_ALL"></a><a
    ///              id="updfcache_all"></a><dl> <dt><b>UPDFCACHE_ALL</b></dt> </dl> </td> <td width="60%"> Updates all caches.
    ///              </td> </tr> <tr> <td width="40%"><a id="UPDFCACHE__ALLBUTNODATACACHE"></a><a
    ///              id="updfcache__allbutnodatacache"></a><dl> <dt><b>UPDFCACHE_ ALLBUTNODATACACHE</b></dt> </dl> </td> <td
    ///              width="60%"> Updates all caches except those created with ADVF_NODATA in the call to IOleCache::Cache. Thus,
    ///              you can control updates to the caches created with the ADVF_NODATA flag and only update these caches
    ///              explicitly. </td> </tr> </table>
    ///    pReserved = This parameter is reserved and must be <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> One of the arguments is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory is
    ///    available for this operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_NOTRUNNING</b></dt> </dl>
    ///    </td> <td width="60%"> The specified <i>pDataObject</i> is not running. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>CACHE_E_NOCACHE_UPDATED</b></dt> </dl> </td> <td width="60%"> None of the caches were updated.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CACHE_S_SOMECACHES_NOTUPDATED</b></dt> </dl> </td> <td
    ///    width="60%"> Some of the caches were updated. </td> </tr> </table>
    ///    
    HRESULT UpdateCache(IDataObject pDataObject, uint grfUpdf, void* pReserved);
    ///Discards the caches found in memory.
    ///Params:
    ///    dwDiscardOptions = A value from the DISCARDCACHE enumeration that indicates whether data is to be saved prior to being
    ///                       discarded. Containers that have drawn a large object and need to free up memory can specify
    ///                       DISCARDCACHE_SAVEIFDIRTY so that the newest presentation is saved for the next time the object must be drawn.
    ///                       Containers that have activated an embedded object, made some changes, and then called IOleObject::Close with
    ///                       OLECLOSE_NOSAVE to roll back the changes can specify DISCARDCACHE_NOSAVE to ensure that the native and
    ///                       presentation data are not out of synchronization.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_NOSTORAGE</b></dt>
    ///    </dl> </td> <td width="60%"> There is no storage available for saving the data in the cache. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>STG_E_MEDIUMFULL</b></dt> </dl> </td> <td width="60%"> The storage medium is
    ///    full. </td> </tr> </table>
    ///    
    HRESULT DiscardCache(uint dwDiscardOptions);
}

///Provides proper maintenance of caches. It maintains the caches by connecting the running object's IDataObject
///implementation to the cache, allowing the cache to receive notifications from the running object.
@GUID("00000129-0000-0000-C000-000000000046")
interface IOleCacheControl : IUnknown
{
    ///Notifies the cache that the data source object has entered the running state so that the cache object can
    ///establish advise sinks as needed.
    ///Params:
    ///    pDataObject = A pointer to the IDataObject interface on the object that is entering the running state.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> One of the arguments is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory is
    ///    available for this operation. </td> </tr> </table>
    ///    
    HRESULT OnRun(IDataObject pDataObject);
    ///Notifies the cache that it should terminate any existing advise sinks. No indication is given as to whether a
    ///connection actually existed.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory is available for this
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT OnStop();
}

///Parses a displayable name string to convert it into a moniker for custom moniker implementations. Display name
///parsing is necessary when the end user inputs a string to identify a component, as in the following situations: <ul>
///<li>A compound document application that supports linked components typically supports the <b>Edit:Links...</b>
///dialog box. Through this dialog box, the end user can enter a display name to specify a new link source for a
///specified linked component. The compound document needs to have this input string converted into a moniker.</li>
///<li>A script language such as the macro language of a spreadsheet can allow textual references to a component. The
///language's interpreter needs to have such a reference converted into a moniker in order to execute the macro.</li>
///</ul>This interface is not supported for use across machine boundaries.
@GUID("0000011A-0000-0000-C000-000000000046")
interface IParseDisplayName : IUnknown
{
    ///Parses the specified display name and creates a corresponding moniker.
    ///Params:
    ///    pbc = A pointer to the bind context to be used in this binding operation. See IBindCtx.
    ///    pszDisplayName = The display name to be parsed.
    ///    pchEaten = A pointer to a variable that receives the number of characters in the display name that correspond to the
    ///               <i>ppmkOut</i> moniker.
    ///    ppmkOut = A pointer to an IMoniker pointer variable that receives the interface pointer to the resulting moniker. If an
    ///              error occurs, the implementation sets *<i>ppmkOut</i> to <b>NULL</b>. If *<i>ppmkOut</i> is non-<b>NULL</b>,
    ///              the implementation must call AddRef; it is the caller's responsibility to call Release.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>MK_E_SYNTAX</b></dt> </dl> </td> <td width="60%"> There is a syntax error in the
    ///    display name. Parsing failed because <i>pszDisplayName</i> could only be partially resolved into a moniker.
    ///    In this case, *<i>pchEaten</i> has the number of characters that were successfully parsed into a moniker
    ///    prefix. The parameter <i>ppmkOut</i> should be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MK_E_NOOBJECT</b></dt> </dl> </td> <td width="60%"> The display name does not identify a component in
    ///    this namespace. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One or more parameters are not valid. </td> </tr> </table>
    ///    
    HRESULT ParseDisplayName(IBindCtx pbc, ushort* pszDisplayName, uint* pchEaten, IMoniker* ppmkOut);
}

///Enumerates objects in a compound document or lock a container in the running state. Container and object applications
///both implement this interface.
@GUID("0000011B-0000-0000-C000-000000000046")
interface IOleContainer : IParseDisplayName
{
    ///Enumerates the objects in the current container.
    ///Params:
    ///    grfFlags = Specifies which objects in a container are to be enumerated, as defined in the enumeration OLECONTF.
    ///    ppenum = A pointer to an IEnumUnknown pointer variable that receives the interface pointer to the enumerator object.
    ///             Each time a container receives a successful call to <b>EnumObjects</b>, it must increase the reference count
    ///             on the <i>ppenum</i> pointer the method returns. It is the caller's responsibility to call IUnknown::Release
    ///             when it is done with the pointer. If an error is returned, the implementation must set <i>ppenum</i> to
    ///             <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Object enumeration not supported. </td> </tr> </table>
    ///    
    HRESULT EnumObjects(uint grfFlags, IEnumUnknown* ppenum);
    ///Keeps the container for embedded objects running until explicitly released.
    ///Params:
    ///    fLock = Indicates whether to lock (<b>TRUE</b>) or unlock (<b>FALSE</b>) a container.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory available for the operation. </td> </tr> </table>
    ///    
    HRESULT LockContainer(BOOL fLock);
}

///Provides the primary means by which an embedded object obtains information about the location and extent of its
///display site, its moniker, its user interface, and other resources provided by its container. An object server calls
///<b>IOleClientSite</b> to request services from the container. A container must provide one instance of
///<b>IOleClientSite</b> for every compound-document object it contains. <div class="alert"><b>Note</b> This interface
///is not supported for use across machine boundaries.</div><div> </div>
@GUID("00000118-0000-0000-C000-000000000046")
interface IOleClientSite : IUnknown
{
    ///Saves the embedded object associated with the client site. This function is synchronous; by the time it returns,
    ///the save will be completed.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation has failed. </td> </tr> </table>
    ///    
    HRESULT SaveObject();
    ///Retrieves a moniker for the object's client site. An object can force the assignment of its own or its
    ///container's moniker by specifying a value for <i>dwAssign</i>.
    ///Params:
    ///    dwAssign = Specifies whether to get a moniker only if one already exists, force assignment of a moniker, create a
    ///               temporary moniker, or remove a moniker that has been assigned. In practice, you will usually request that the
    ///               container force assignment of the moniker. Possible values are taken from the OLEGETMONIKER enumeration.
    ///    dwWhichMoniker = Specifies whether to return the container's moniker, the object's moniker relative to the container, or the
    ///                     object's full moniker. In practice, you will usually request the object's full moniker. Possible values are
    ///                     taken from the OLEWHICHMK enumeration.
    ///    ppmk = A pointer to an IMoniker pointer variable that receives the interface pointer to the moniker for the object's
    ///           client site. If an error occurs, the implementation must set <i>ppmk</i> to <b>NULL</b>. Each time a
    ///           container receives a call to <b>IOleClientSite::GetMoniker</b>, it must increase the reference count on the
    ///           <i>ppmk</i> pointer it returns. It is the caller's responsibility to call Release when it is finished with
    ///           the pointer.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> This container cannot assign monikers to objects. This is the case with OLE 1
    ///    containers. </td> </tr> </table>
    ///    
    HRESULT GetMoniker(uint dwAssign, uint dwWhichMoniker, IMoniker* ppmk);
    ///Retrieves a pointer to the object's container.
    ///Params:
    ///    ppContainer = Address of IOleContainer pointer variable that receives the interface pointer to the container object. If an
    ///                  error occurs, the implementation must set <i>ppContainer</i> to <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_NOT_SUPPORTED</b></dt> </dl> </td> <td width="60%"> The client site is in an OLE 1 container.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The
    ///    container does not implement the IOleContainer interface. </td> </tr> </table>
    ///    
    HRESULT GetContainer(IOleContainer* ppContainer);
    ///Asks a container to display its object to the user. This method ensures that the container itself is visible and
    ///not minimized.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_NOT_SUPPORTED</b></dt> </dl> </td> <td width="60%"> Client site is in an OLE 1 container. </td>
    ///    </tr> </table>
    ///    
    HRESULT ShowObject();
    ///Notifies a container when an embedded object's window is about to become visible or invisible. This method does
    ///not apply to an object that is activated in place and therefore has no window separate from that of its
    ///container.
    ///Params:
    ///    fShow = Indicates whether an object's window is open (TRUE) or closed (FALSE).
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT OnShowWindow(BOOL fShow);
    ///Asks a container to resize the display site for embedded objects.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Client site does not support requests for new layout. </td> </tr> </table>
    ///    
    HRESULT RequestNewObjectLayout();
}

///Serves as the principal means by which an embedded object provides basic functionality to, and communicates with, its
///container.
@GUID("00000112-0000-0000-C000-000000000046")
interface IOleObject : IUnknown
{
    ///Informs an embedded object of its display location, called a "client site," within its container.
    ///Params:
    ///    pClientSite = Pointer to the IOleClientSite interface on the container application's client-site.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected error occurred. </td> </tr> </table>
    ///    
    HRESULT SetClientSite(IOleClientSite pClientSite);
    ///Retrieves a pointer to an embedded object's client site.
    ///Params:
    ///    ppClientSite = Address of IOleClientSite pointer variable that receives the interface pointer to the object's client site.
    ///                   If an object does not yet know its client site, or if an error has occurred, <i>ppClientSite</i> must be set
    ///                   to <b>NULL</b>. Each time an object receives a call to <b>IOleObject::GetClientSite</b>, it must increase the
    ///                   reference count on <i>ppClientSite</i>. It is the caller's responsibility to call Release when it is done
    ///                   with <i>ppClientSite</i>.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT GetClientSite(IOleClientSite* ppClientSite);
    ///Provides an object with the names of its container application and the compound document in which it is embedded.
    ///Params:
    ///    szContainerApp = Pointer to the name of the container application in which the object is running.
    ///    szContainerObj = Pointer to the name of the compound document that contains the object. If you do not wish to display the name
    ///                     of the compound document, you can set this parameter to <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT SetHostNames(ushort* szContainerApp, ushort* szContainerObj);
    ///Changes an embedded object from the running to the loaded state. Disconnects a linked object from its link
    ///source.
    ///Params:
    ///    dwSaveOption = Indicates whether the object is to be saved as part of the transition to the loaded state. Valid values are
    ///                   taken from the enumeration OLECLOSE. <div class="alert"><b>Note</b> The OLE 2 user model recommends that
    ///                   object applications do not prompt users before saving linked or embedded objects, including those activated
    ///                   in place. This policy represents a change from the OLE 1 user model, in which object applications always
    ///                   prompt the user to decide whether to save changes.</div> <div> </div>
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_PROMPTSAVECANCELLED</b></dt> </dl> </td> <td width="60%"> The user was prompted to save but
    ///    chose the <b>Cancel</b> button from the prompt message box. </td> </tr> </table>
    ///    
    HRESULT Close(uint dwSaveOption);
    ///Notifies an object of its container's moniker, the object's own moniker relative to the container, or the
    ///object's full moniker.
    ///Params:
    ///    dwWhichMoniker = The moniker is passed in <i>pmk</i>. Possible values are from the enumeration OLEWHICHMK.
    ///    pmk = Pointer to where to return the moniker.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> </table>
    ///    
    HRESULT SetMoniker(uint dwWhichMoniker, IMoniker pmk);
    ///Retrieves an embedded object's moniker, which the caller can use to link to the object.
    ///Params:
    ///    dwAssign = Determines how the moniker is assigned to the object. Depending on the value of <i>dwAssign</i>,
    ///               <b>IOleObject::GetMoniker</b> does one of the following: <ul> <li>Obtains a moniker only if one has already
    ///               been assigned.</li> <li>Forces assignment of a moniker, if necessary, in order to satisfy the call.</li>
    ///               <li>Obtains a temporary moniker.</li> </ul> Values for <i>dwAssign</i> are specified in the enumeration
    ///               OLEGETMONIKER. <div class="alert"><b>Note</b> You cannot pass OLEGETMONIKER_UNASSIGN when calling
    ///               <b>IOleObject::GetMoniker</b>. This value is valid only when calling <b>IOleObject::GetMoniker</b>.</div>
    ///               <div> </div>
    ///    dwWhichMoniker = Specifies the form of the moniker being requested. Possible values are taken from the enumeration OLEWHICHMK.
    ///    ppmk = Address of IMoniker pointer variable that receives the interface pointer to the object's moniker. If an error
    ///           occurs, <i>ppmk</i> must be set to <b>NULL</b>. Each time an object receives a call to
    ///           <b>IOleObject::GetMoniker</b>, it must increase the reference count on <i>ppmk</i>. It is the caller's
    ///           responsibility to call Release when it is done with <i>ppmk</i>.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT GetMoniker(uint dwAssign, uint dwWhichMoniker, IMoniker* ppmk);
    ///Initializes a newly created object with data from a specified data object, which can reside either in the same
    ///container or on the Clipboard.
    ///Params:
    ///    pDataObject = Pointer to the IDataObject interface on the data object from which the initialization data is to be obtained.
    ///                  This parameter can be <b>NULL</b>, which indicates that the caller wants to know if it is worthwhile trying
    ///                  to send data; that is, whether the container is capable of initializing an object from data passed to it. The
    ///                  data object to be passed can be based on either the current selection within the container document or on
    ///                  data transferred to the container from an external source.
    ///    fCreation = <b>TRUE</b> indicates the container is inserting a new object inside itself and initializing that object with
    ///                data from the current selection; <b>FALSE</b> indicates a more general programmatic data transfer, most
    ///                likely from a source other than the current selection.
    ///    dwReserved = This parameter is reserved and must be zero.
    ///Returns:
    ///    This method returns S_OK if <i>pDataObject</i> is not <b>NULL</b>, the object successfully attempted to
    ///    initialize itself from the provided data; if <i>pDataObject</i> is <b>NULL</b>, the object is able to attempt
    ///    a successful initialization.. Other possible return values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> If pDataObject is not <b>NULL</b>, the object made no attempt to initialize itself; if
    ///    <i>pDataObject</i> is <b>NULL</b>, the object cannot attempt to initialize itself from the data provided.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The object does
    ///    not support <i>InitFromData</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_NOTRUNNING</b></dt>
    ///    </dl> </td> <td width="60%"> The object is not running and therefore cannot perform the operation. </td>
    ///    </tr> </table>
    ///    
    HRESULT InitFromData(IDataObject pDataObject, BOOL fCreation, uint dwReserved);
    ///Retrieves a data object containing the current contents of the embedded object on which this method is called.
    ///Using the pointer to this data object, it is possible to create a new embedded object with the same data as the
    ///original.
    ///Params:
    ///    dwReserved = This parameter is reserved and must be zero.
    ///    ppDataObject = Address of IDataObject pointer variable that receives the interface pointer to the data object. If an error
    ///                   occurs, <i>ppDataObject</i> must be set to <b>NULL</b>. Each time an object receives a call to
    ///                   <b>IOleObject::GetClipboardData</b>, it must increase the reference count on <i>ppDataObject</i>. It is the
    ///                   caller's responsibility to call Release when it is done with <i>ppDataObject</i>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> GetClipboardData is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_NOTRUNNING</b></dt> </dl> </td> <td width="60%"> The object is not running. </td> </tr> </table>
    ///    
    HRESULT GetClipboardData(uint dwReserved, IDataObject* ppDataObject);
    ///Requests that an object perform an action in response to an end-user's action. The possible actions are
    ///enumerated for the object in IOleObject::EnumVerbs.
    ///Params:
    ///    iVerb = Number assigned to the verb in the OLEVERB structure returned by IOleObject::EnumVerbs.
    ///    lpmsg = Pointer to the MSG structure describing the event (such as a double-click) that invoked the verb. The caller
    ///            should pass the <b>MSG</b> structure unmodified, without attempting to interpret or alter the values of any
    ///            of the structure members.
    ///    pActiveSite = Pointer to the IOleClientSite interface on the object's active client site, where the event occurred that
    ///                  invoked the verb.
    ///    lindex = This parameter is reserved and must be zero.
    ///    hwndParent = Handle of the document window containing the object. This and <i>lprcPosRect</i> together make it possible to
    ///                 open a temporary window for an object, where <i>hwndParent</i> is the parent window in which the object's
    ///                 window is to be displayed, and <i>lprcPosRect</i> defines the area available for displaying the object window
    ///                 within that parent. A temporary window is useful, for example, to a multimedia object that opens itself for
    ///                 playback but not for editing.
    ///    lprcPosRect = Pointer to the RECT structure containing the coordinates, in pixels, that define an object's bounding
    ///                  rectangle in <i>hwndParent</i>. This and <i>hwndParent</i> together enable opening multimedia objects for
    ///                  playback but not for editing.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_NOT_INPLACEACTIVE</b></dt> </dl> </td> <td width="60%"> iVerb set to OLEIVERB_UIACTIVATE or
    ///    OLEIVERB_INPLACEACTIVATE and object is not already visible. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_CANT_BINDTOSOURCE</b></dt> </dl> </td> <td width="60%"> The object handler or link object cannot
    ///    connect to the link source. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_LINDEX</b></dt> </dl> </td>
    ///    <td width="60%"> Invalid lindex. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLEOBJ_S_CANNOT_DOVERB_NOW</b></dt> </dl> </td> <td width="60%"> The verb is valid, but in the
    ///    object's current state it cannot carry out the corresponding action. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLEOBJ_S_INVALIDHWND</b></dt> </dl> </td> <td width="60%"> DoVerb was successful but <i>hwndParent</i>
    ///    is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEOBJ_E_NOVERBS</b></dt> </dl> </td> <td
    ///    width="60%"> The object does not support any verbs. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLEOBJ_S_INVALIDVERB</b></dt> </dl> </td> <td width="60%"> Link source is across a network that is not
    ///    connected to a drive on this computer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_E_CONNECT</b></dt>
    ///    </dl> </td> <td width="60%"> Link source is across a network that is not connected to a drive on this
    ///    computer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_CLASSDIFF</b></dt> </dl> </td> <td width="60%">
    ///    Class for source of link has undergone a conversion. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Object does not support in-place activation or does
    ///    not recognize a negative verb number. </td> </tr> </table>
    ///    
    HRESULT DoVerb(int iVerb, MSG* lpmsg, IOleClientSite pActiveSite, int lindex, HWND hwndParent, 
                   RECT* lprcPosRect);
    ///Exposes a pull-down menu listing the verbs available for an object in ascending order by verb number.
    ///Params:
    ///    ppEnumOleVerb = Address of IEnumOLEVERB pointer variable that receives the interface pointer to the new enumerator object.
    ///                    Each time an object receives a call to <b>IOleObject::EnumVerbs</b>, it must increase the reference count on
    ///                    <i>ppEnumOleVerb</i>. It is the caller's responsibility to call IUnknown::Release when it is done with
    ///                    <i>ppEnumOleVerb</i>. If an error occurs, <i>ppEnumOleVerb</i> must be set to <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_S_USEREG</b></dt> </dl>
    ///    </td> <td width="60%"> Delegate to the default handler to use the entries in the registry to provide the
    ///    enumeration. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLEOBJ_E_NOVERBS</b></dt> </dl> </td> <td
    ///    width="60%"> Object does not support any verbs. </td> </tr> </table>
    ///    
    HRESULT EnumVerbs(IEnumOLEVERB* ppEnumOleVerb);
    ///Updates an object handler's or link object's data or view caches.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_CANT_BINDTOSOURCE</b></dt> </dl> </td> <td width="60%"> Cannot run object to get updated data.
    ///    The object is for some reason unavailable to the caller. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CACHE_E_NOCACHE_UPDATED</b></dt> </dl> </td> <td width="60%"> No caches were updated. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>CACHE_S_SOMECACHES_NOTUPDATED</b></dt> </dl> </td> <td width="60%"> Some caches
    ///    were not updated. </td> </tr> </table>
    ///    
    HRESULT Update();
    ///Checks whether an object is up to date.
    ///Returns:
    ///    This method returns S_OK if the object is up to date; otherwise, S_FALSE. Other possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>OLE_E_UNAVAILABLE</b></dt> </dl> </td> <td width="60%"> The status of object cannot be determined
    ///    in a timely manner. </td> </tr> </table>
    ///    
    HRESULT IsUpToDate();
    ///Retrieves an object's class identifier, the CLSID corresponding to the string identifying the object to an end
    ///user.
    ///Params:
    ///    pClsid = Pointer to the class identifier (CLSID) to be returned. An object's CLSID is the binary equivalent of the
    ///             user-type name returned by IOleObject::GetUserType.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> </table>
    ///    
    HRESULT GetUserClassID(GUID* pClsid);
    ///Retrieves the user-type name of an object for display in user-interface elements such as menus, list boxes, and
    ///dialog boxes.
    ///Params:
    ///    dwFormOfType = The form of the user-type name to be presented to users. Possible values are obtained from the USERCLASSTYPE
    ///                   enumeration.
    ///    pszUserType = Address of LPOLESTR pointer variable that receives a pointer to the user type string. The caller must free
    ///                  <i>pszUserType</i> using the current IMalloc instance. If an error occurs, the implementation must set
    ///                  <i>pszUserType</i> to <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_S_USEREG</b></dt> </dl>
    ///    </td> <td width="60%"> Delegate to the default handler's implementation using the registry to provide the
    ///    requested information. </td> </tr> </table>
    ///    
    HRESULT GetUserType(uint dwFormOfType, ushort** pszUserType);
    ///Informs an object of how much display space its container has assigned it.
    ///Params:
    ///    dwDrawAspect = DWORD that describes which form, or "aspect," of an object is to be displayed. The object's container obtains
    ///                   this value from the enumeration DVASPECT (refer to the FORMATETC enumeration). The most common aspect is
    ///                   DVASPECT_CONTENT, which specifies a full rendering of the object within its container. An object can also be
    ///                   rendered as an icon, a thumbnail version for display in a browsing tool, or a print version, which displays
    ///                   the object as it would be rendered using the <b>File Print</b> command.
    ///    psizel = Pointer to the size limit for the object.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_NOTRUNNING</b></dt> </dl> </td> <td width="60%"> The object is not running. </td> </tr> </table>
    ///    
    HRESULT SetExtent(uint dwDrawAspect, SIZE* psizel);
    ///Retrieves a running object's current display size.
    ///Params:
    ///    dwDrawAspect = The aspect of the object whose limit is to be retrieved; the value is obtained from the enumerations DVASPECT
    ///                   and from DVASPECT2. Note that newer objects and containers that support optimized drawing interfaces support
    ///                   the <b>DVASPECT2</b> enumeration values. Older objects and containers that do not support optimized drawing
    ///                   interfaces may not support <b>DVASPECT2</b>. The most common value for this method is DVASPECT_CONTENT, which
    ///                   specifies a full rendering of the object within its container.
    ///    psizel = Pointer to where the object's size is to be returned.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The supplied <i>dwDrawAspect</i> value is invalid. </td> </tr> </table>
    ///    
    HRESULT GetExtent(uint dwDrawAspect, SIZE* psizel);
    ///Establishes an advisory connection between a compound document object and the calling object's advise sink,
    ///through which the calling object receives notification when the compound document object is renamed, saved, or
    ///closed.
    ///Params:
    ///    pAdvSink = Pointer to the IAdviseSink interface on the advise sink of the calling object.
    ///    pdwConnection = Pointer to a token that can be passed to IOleObject::Unadvise to delete the advisory connection.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT Advise(IAdviseSink pAdvSink, uint* pdwConnection);
    ///Deletes a previously established advisory connection.
    ///Params:
    ///    dwConnection = Contains a token of nonzero value, which was previously returned from IOleObject::Advise through its
    ///                   <i>pdwConnection</i> parameter.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_NOCONNECTION</b></dt> </dl> </td> <td width="60%"> dwConnection does not represent a valid
    ///    advisory connection. </td> </tr> </table>
    ///    
    HRESULT Unadvise(uint dwConnection);
    ///Retrieves a pointer to an enumerator that can be used to enumerate the advisory connections registered for an
    ///object, so a container can know what to release prior to closing down.
    ///Params:
    ///    ppenumAdvise = Address of IEnumSTATDATA pointer variable that receives the interface pointer to the enumerator object. If
    ///                   the object does not have any advisory connections or if an error occurs, the implementation must set
    ///                   <i>ppenumAdvise</i> to <b>NULL</b>. Each time an object receives a successful call to
    ///                   <b>IOleObject::EnumAdvise</b>, it must increase the reference count on <i>ppenumAdvise</i>. It is the
    ///                   caller's responsibility to call Release when it is done with the <i>ppenumAdvise</i>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> IOleObject::EnumAdvise is not implemented. </td> </tr> </table>
    ///    
    HRESULT EnumAdvise(IEnumSTATDATA* ppenumAdvise);
    ///Retrieves the status of an object at creation and loading.
    ///Params:
    ///    dwAspect = The aspect of an object about which status information is being requested. The value is obtained from the
    ///               enumeration DVASPECT.
    ///    pdwStatus = Pointer to where the status information is returned. This parameter cannot be <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_S_USEREG</b></dt> </dl>
    ///    </td> <td width="60%"> Delegate the retrieval of miscellaneous status information to the default handler's
    ///    implementation of this method. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_CLASSNOTREG</b></dt> </dl>
    ///    </td> <td width="60%"> There is no CLSID registered for the object. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CO_E_READREGDB</b></dt> </dl> </td> <td width="60%"> Error accessing the registry. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetMiscStatus(uint dwAspect, uint* pdwStatus);
    ///Specifies the color palette that the object application should use when it edits the specified object.
    ///Params:
    ///    pLogpal = Pointer to a LOGPALETTE structure that specifies the recommended palette.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> Object does not support setting palettes. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_PALETTE</b></dt> </dl> </td> <td width="60%"> Invalid LOGPALETTE structure pointed to by
    ///    <i>pLogPal</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_NOTRUNNING</b></dt> </dl> </td> <td
    ///    width="60%"> Object must be running to perform this operation. </td> </tr> </table>
    ///    
    HRESULT SetColorScheme(LOGPALETTE* pLogpal);
}

///The <b>IOleWindow</b> interface provides methods that allow an application to obtain the handle to the various
///windows that participate in in-place activation, and also to enter and exit context-sensitive help mode.
@GUID("00000114-0000-0000-C000-000000000046")
interface IOleWindow : IUnknown
{
    ///Retrieves a handle to one of the windows participating in in-place activation (frame, document, parent, or
    ///in-place object window).
    ///Params:
    ///    phwnd = A pointer to a variable that receives the window handle.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The object is windowless. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified <i>fEnterMode</i> value is not valid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetWindow(HWND* phwnd);
    ///Determines whether context-sensitive help mode should be entered during an in-place activation session.
    ///Params:
    ///    fEnterMode = <b>TRUE</b> if help mode should be entered; <b>FALSE</b> if it should be exited.
    ///Returns:
    ///    This method returns S_OK if the help mode was entered or exited successfully, depending on the value passed
    ///    in <i>fEnterMode</i>. Other possible return values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The specified <i>fEnterMode</i> value is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is insufficient memory available for this
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT ContextSensitiveHelp(BOOL fEnterMode);
}

///Enables a linked object to provide its container with functions pertaining to linking. The most important of these
///functions is binding to the link source, that is, activating the connection to the document that stores the linked
///object's native data. <b>IOleLink</b> also defines functions for managing information about the linked object, such
///as the location of the link source and the cached presentation data for the linked object. A container application
///can distinguish between embedded objects and linked objects by querying for <b>IOleLink</b>; only linked objects
///implement <b>IOleLink</b>.
@GUID("0000011D-0000-0000-C000-000000000046")
interface IOleLink : IUnknown
{
    ///Specifies how often a linked object should update its cached data.
    ///Params:
    ///    dwUpdateOpt = Specifies how often a linked object should update its cached data. The possible values for <i>dwUpdateOpt</i>
    ///                  are taken from the enumeration OLEUPDATE.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The supplied value is invalid. </td> </tr> </table>
    ///    
    HRESULT SetUpdateOptions(uint dwUpdateOpt);
    ///Retrieves a value indicating how often the linked object updates its cached data.
    ///Params:
    ///    pdwUpdateOpt = A pointer to a variable that receives the current value for the linked object's update option, indicating how
    ///                   often the linked object updates the cached data for the linked object. The possible values for
    ///                   <i>pdwUpdateOpt</i> are taken from the enumeration OLEUPDATE.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT GetUpdateOptions(uint* pdwUpdateOpt);
    ///Sets the moniker for the link source.
    ///Params:
    ///    pmk = A pointer to the IMoniker interface on a moniker that identifies the new link source of the linked object. A
    ///          value of <b>NULL</b> breaks the link.
    ///    rclsid = The CLSID of the link source that the linked object should use to access information about the linked object
    ///             when it is not bound.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT SetSourceMoniker(IMoniker pmk, const(GUID)* rclsid);
    ///Retrieves the moniker identifying the link source of a linked object.
    ///Params:
    ///    ppmk = Address of an IMoniker pointer variable that receives the interface pointer to an absolute moniker that
    ///           identifies the link source. When successful, the implementation must call AddRef on <i>ppmk</i>; it is the
    ///           caller's responsibility to call Release. If an error occurs the implementation must set <i>ppmk</i> to
    ///           <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_E_UNAVAILABLE</b></dt>
    ///    </dl> </td> <td width="60%"> No moniker is available. </td> </tr> </table>
    ///    
    HRESULT GetSourceMoniker(IMoniker* ppmk);
    ///Sets the display name for the link source.
    ///Params:
    ///    pszStatusText = A pointer to the display name of the new link source. This parameter cannot be <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK on success. Values from MkParseDisplayName may also be returned here.
    ///    
    HRESULT SetSourceDisplayName(ushort* pszStatusText);
    ///Retrieves the display name of the link source of the linked object.
    ///Params:
    ///    ppszDisplayName = Address of a pointer variable that receives a pointer to the display name of the link source. If an error
    ///                      occurs, <i>ppszDisplayName</i> is set to <b>NULL</b>; otherwise, the implementation must use IMalloc::Alloc
    ///                      to allocate the string returned in <i>ppszDisplayName</i>, and the caller is responsible for calling
    ///                      IMalloc::Free to free it. Both caller and called use the allocator returned by CoGetMalloc.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> </table> Retrieving the display name requires calling
    ///    these functions; therefore, this method may return errors generated by CreateBindCtx and
    ///    IMoniker::GetDisplayName.
    ///    
    HRESULT GetSourceDisplayName(ushort** ppszDisplayName);
    ///Activates the connection to the link source by binding the moniker stored within the linked object.
    ///Params:
    ///    bindflags = Specifies how to proceed if the link source has a different CLSID from the last time it was bound. If this
    ///                parameter is zero and the CLSIDs are different, the method fails and returns OLE_E_CLASSDIFF. If the
    ///                OLELINKBIND_EVENIFCLASSDIFF value from the OLELINKBIND enumeration is specified and the CLSIDs are different,
    ///                the method binds successfully and updates the CLSID stored in the linked object.
    ///    pbc = A pointer to the IBindCtx interface on the bind context to be used in this binding operation. This parameter
    ///          can be <b>NULL</b>. The bind context caches objects bound during the binding process, contains parameters
    ///          that apply to all operations using the bind context, and provides the means by which the binding
    ///          implementation should retrieve information about its environment. For more information, see <b>IBindCtx</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_CLASSDIFF</b></dt>
    ///    </dl> </td> <td width="60%"> The link source was not bound because its CLSID has changed. This error is
    ///    returned only if the OLELINKBIND_EVENIFCLASSDIFF flag is not specified in the <i>bindflags</i> parameter.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_E_NOOBJECT</b></dt> </dl> </td> <td width="60%"> The link
    ///    source could not be found or (if the link source's moniker is a composite) some intermediate object
    ///    identified in the composite could not be found. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNSPEC</b></dt> </dl> </td> <td width="60%"> The link's moniker is <b>NULL</b>. </td> </tr> </table>
    ///    Binding the moniker might require calling the CreateBindCtx function; therefore, this method may return
    ///    errors generated by <b>CreateBindCtx</b>.
    ///    
    HRESULT BindToSource(uint bindflags, IBindCtx pbc);
    ///Activates the connection between the linked object and the link source if the link source is already running.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The link source is not running. </td> </tr> </table> Binding the moniker might require
    ///    calling CreateBindCtx, IMoniker::IsRunning, or IOleLink::BindToSource; therefore, errors generated by these
    ///    functions can also be returned.
    ///    
    HRESULT BindIfRunning();
    ///Retrieves a pointer to the link source if the connection is active.
    ///Params:
    ///    ppunk = Address of IDataObject pointer variable that receives the interface pointer to the link source. When
    ///            successful, the implementation must call IUnknown::AddRef on <i>ppunk</i>; it is the caller's responsibility
    ///            to call IUnknown::Release. If an error occurs, the implementation sets <i>ppunk</i> to <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> </table>
    ///    
    HRESULT GetBoundSource(IUnknown* ppunk);
    ///Breaks the connection between a linked object and its link source.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT UnbindSource();
    ///Updates the compound document's cached data for a linked object. This involves binding to the link source, if it
    ///is not already bound.
    ///Params:
    ///    pbc = A pointer to the IBindCtx interface on the bind context to be used in binding the link source. This parameter
    ///          can be <b>NULL</b>. The bind context caches objects bound during the binding process, contains parameters
    ///          that apply to all operations using the bind context, and provides the means by which the binding
    ///          implementation should retrieve information about its environment. For more information, see <b>IBindCtx</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CACHE_E_NOCACHE_UPDATE</b></dt> </dl> </td> <td width="60%"> The bind operation worked but no caches
    ///    were updated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CACHE_S_SOMECACHES_NOTUPDATED</b></dt> </dl>
    ///    </td> <td width="60%"> The bind operation worked but not all caches were updated. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>OLE_E_CANT_BINDTOSOURCE</b></dt> </dl> </td> <td width="60%"> Unable to bind to the
    ///    link source. </td> </tr> </table>
    ///    
    HRESULT Update(IBindCtx pbc);
}

///Used by item monikers when they are bound to the objects they identify. When any container of objects uses item
///monikers to identify its objects, it must define a naming scheme for those objects. The container's
///<b>IOleItemContainer</b> implementation uses knowledge of that naming scheme to retrieve an object given a particular
///name. Item monikers use the container's <b>IOleItemContainer</b> implementation during binding. This interface is not
///supported for use across machine boundaries.
@GUID("0000011C-0000-0000-C000-000000000046")
interface IOleItemContainer : IOleContainer
{
    HRESULT GetObjectA(ushort* pszItem, uint dwSpeedNeeded, IBindCtx pbc, const(GUID)* riid, void** ppvObject);
    ///Retrieves a pointer to the storage for the specified object.
    ///Params:
    ///    pszItem = The compound document's name for the object whose storage is requested.
    ///    pbc = A pointer to the IBindCtx interface on the bind context to be used in this binding operation. The bind
    ///          context caches objects bound during the binding process, contains parameters that apply to all operations
    ///          using the bind context, and provides the means by which the binding implementation should retrieve
    ///          information about its environment.
    ///    riid = A reference to the identifier of the interface to be used to communicate with the object, usually IStorage.
    ///    ppvStorage = Address of a pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful
    ///                 return, *<i>ppvStorage</i> contains the requested interface pointer to the storage for the object named by
    ///                 <i>pszItem</i>. When successful, the implementation must call AddRef on *<i>ppvStorage</i>; it is the
    ///                 caller's responsibility to call Release. If an error occurs, *<i>ppvStorage</i> is set to <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return value E_OUTOFMEMORY, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method completely successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>MK_E_OBJECT</b></dt> </dl> </td> <td width="60%"> The parameter <i>pszItem</i> does not identify a
    ///    object in this container. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_E_NOSTORAGE</b></dt> </dl> </td>
    ///    <td width="60%"> The object does not have its own independent storage. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The requested interface is not available. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetObjectStorage(ushort* pszItem, IBindCtx pbc, const(GUID)* riid, void** ppvStorage);
    ///Determines whether the specified object is running.
    ///Params:
    ///    pszItem = The container's name for the object.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The object is running. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The object is not
    ///    running. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MK_E_NOOBJECT</b></dt> </dl> </td> <td width="60%">
    ///    The parameter does not identify an object in this container. </td> </tr> </table>
    ///    
    HRESULT IsRunning(ushort* pszItem);
}

///Implemented by container applications and used by object applications to negotiate border space on the document or
///frame window. The container provides a RECT structure in which the object can place toolbars and other similar
///controls, determines if tools can in fact be installed around the object's window frame, allocates space for the
///border, and establishes a communication channel between the object and each frame and document window.
@GUID("00000115-0000-0000-C000-000000000046")
interface IOleInPlaceUIWindow : IOleWindow
{
    ///Retrieves the outer rectange for toolbars and controls while the object is active in place.
    ///Params:
    ///    lprectBorder = A pointer to a RECT structure where the outer rectangle is to be returned. The structure's coordinates are
    ///                   relative to the window being represented by the interface.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>INPLACE_E_NOTOOLSPACE</b></dt> </dl> </td> <td width="60%"> The object cannot install toolbars in this
    ///    window object. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory available for this operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetBorder(RECT* lprectBorder);
    ///Determines whether there is space available for tools to be installed around the object's window frame while the
    ///object is active in place.
    ///Params:
    ///    pborderwidths = A pointer to a BORDERWIDTHS structure containing the requested widths (in pixels) needed on each side of the
    ///                    window for the tools.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>INPLACE_E_NOTOOLSPACE</b></dt> </dl> </td> <td width="60%"> The object cannot install toolbars in this
    ///    window object because the implementation does not support toolbars, or there is insufficient space to install
    ///    the toolbars. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT RequestBorderSpace(RECT* pborderwidths);
    ///Allocates space for the border requested in the call to IOleInPlaceUIWindow::RequestBorderSpace.
    ///Params:
    ///    pborderwidths = Pointer to a BORDERWIDTHS structure containing the requested width of the tools, in pixels. It can be
    ///                    <b>NULL</b>, indicating the object does not need any space.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_INVALIDRECT</b></dt>
    ///    </dl> </td> <td width="60%"> The rectangle does not lie within the specifications returned by
    ///    IOleInPlaceUIWindow::GetBorder. </td> </tr> </table>
    ///    
    HRESULT SetBorderSpace(RECT* pborderwidths);
    ///Provides a direct channel of communication between the object and each of the frame and document windows.
    ///Params:
    ///    pActiveObject = A pointer to the IOleInPlaceActiveObject interface on the active in-place object.
    ///    pszObjName = A pointer to a string containing a name that describes the object an embedding container can use in composing
    ///                 its window title. It can be <b>NULL</b> if the object does not require the container to change its window
    ///                 titles. Containers should ignore this parameter and always use their own name in the title bar.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT SetActiveObject(IOleInPlaceActiveObject pActiveObject, ushort* pszObjName);
}

///Provides a direct channel of communication between an in-place object and the associated application's outer-most
///frame window and the document window within the application that contains the embedded object. The communication
///involves the translation of messages, the state of the frame window (activated or deactivated), and the state of the
///document window (activated or deactivated). Also, it informs the object when it needs to resize its borders, and
///manages modeless dialog boxes.
@GUID("00000117-0000-0000-C000-000000000046")
interface IOleInPlaceActiveObject : IOleWindow
{
    HRESULT TranslateAcceleratorA(MSG* lpmsg);
    ///Notifies the object when the container's top-level frame window is activated or deactivated.
    ///Params:
    ///    fActivate = The state of the container's top-level frame window. This parameter is <b>TRUE</b> if the window is
    ///                activating and <b>FALSE</b> if it is deactivating.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT OnFrameWindowActivate(BOOL fActivate);
    ///Notifies the active in-place object when the container's document window is activated or deactivated.
    ///Params:
    ///    fActivate = The state of the MDI child document window. If this parameter is <b>TRUE</b>, the window is in the act of
    ///                activating; if it is <b>FALSE</b>, it is in the act of deactivating.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT OnDocWindowActivate(BOOL fActivate);
    ///Alerts the object that it needs to resize its border space.
    ///Params:
    ///    prcBorder = A pointer to a RECT structure containing the new outer rectangle within which the object can request border
    ///                space for its tools.
    ///    pUIWindow = A pointer to an IOleInPlaceUIWindow interface pointer for the frame or document window object whose border
    ///                has changed.
    ///    fFrameWindow = This parameter is <b>TRUE</b> if the frame window object is calling
    ///                   <b>IOleInPlaceActiveObject::ResizeBorder</b>; otherwise, it is <b>FALSE</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The specified parameter values are not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is insufficient memory available for the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    An unexpected error occurred. </td> </tr> </table>
    ///    
    HRESULT ResizeBorder(RECT* prcBorder, IOleInPlaceUIWindow pUIWindow, BOOL fFrameWindow);
    ///Enables or disables modeless dialog boxes when the container creates or destroys a modal dialog box.
    ///Params:
    ///    fEnable = Indicates whether to enable modeless dialog box windows (<b>TRUE</b>) or disable them <b>FALSE</b>.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT EnableModeless(BOOL fEnable);
}

///Controls the container's top-level frame window. This control involves allowing the container to insert its menu
///group into the composite menu, install the composite menu into the appropriate window frame, and remove the
///container's menu elements from the composite menu. It sets and displays status text relevant to the in-place object.
///It also enables or disables the frame's modeless dialog boxes, and translates accelerator keystrokes intended for the
///container's frame.
@GUID("00000116-0000-0000-C000-000000000046")
interface IOleInPlaceFrame : IOleInPlaceUIWindow
{
    ///Enables the container to insert menu groups into the composite menu to be used during the in-place session.
    ///Params:
    ///    hmenuShared = A handle to an empty menu.
    ///    lpMenuWidths = A pointer to an OLEMENUGROUPWIDTHS array with six elements. The container fills in elements 0, 2, and 4 to
    ///                   reflect the number of menu elements it provided in the <b>File</b>, <b>View</b>, and <b>Window</b> menu
    ///                   groups.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT InsertMenus(HMENU hmenuShared, OleMenuGroupWidths* lpMenuWidths);
    ///Adds a composite menu to the window frame containing the object being activated in place.
    ///Params:
    ///    hmenuShared = A handle to the composite menu constructed by calls to IOleInPlaceFrame::InsertMenus and the InsertMenu
    ///                  function.
    ///    holemenu = A handle to the menu descriptor returned by the OleCreateMenuDescriptor function.
    ///    hwndActiveObject = A handle to a window owned by the object and to which menu messages, commands, and accelerators are to be
    ///                       sent.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The specified handle is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetMenu(HMENU hmenuShared, ptrdiff_t holemenu, HWND hwndActiveObject);
    ///Removes a container's menu elements from the composite menu.
    ///Params:
    ///    hmenuShared = A handle to the in-place composite menu that was constructed by calls to IOleInPlaceFrame::InsertMenus and
    ///                  the InsertMenu function.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The specified handle is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT RemoveMenus(HMENU hmenuShared);
    ///Sets and displays status text about the in-place object in the container's frame window status line.
    ///Params:
    ///    pszStatusText = The message to be displayed.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_TRUNCATED</b></dt> </dl>
    ///    </td> <td width="60%"> Some text was displayed but the message was too long and was truncated. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified
    ///    pointer is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error occurred. </td> </tr> </table>
    ///    
    HRESULT SetStatusText(ushort* pszStatusText);
    ///Enables or disables a frame's modeless dialog boxes.
    ///Params:
    ///    fEnable = Specifies whether the modeless dialog box windows are to be enabled (<b>TRUE</b>) or disabled (<b>FALSE</b>).
    ///Returns:
    ///    This method returns S_OK if the dialog box was either enabled or disabled successfully, depending on the
    ///    value for <i>fEnable</i>.
    ///    
    HRESULT EnableModeless(BOOL fEnable);
    HRESULT TranslateAcceleratorA(MSG* lpmsg, ushort wID);
}

///Manages the activation and deactivation of in-place objects, and determines how much of the in-place object should be
///visible. You can obtain a pointer to <b>IOleInPlaceObject</b> by calling IUnknown::QueryInterface on IOleObject.
@GUID("00000113-0000-0000-C000-000000000046")
interface IOleInPlaceObject : IOleWindow
{
    ///Deactivates an active in-place object and discards the object's undo state.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected error occurred. </td> </tr> </table>
    ///    
    HRESULT InPlaceDeactivate();
    ///Deactivates and removes the user interface of an active in-place object.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT UIDeactivate();
    ///Specifies how much of the in-place object is to be visible.
    ///Params:
    ///    lprcPosRect = A pointer to the RECT structure containing the position of the in-place object using the client coordinates
    ///                  of its parent window.
    ///    lprcClipRect = A pointer to the outer rectangle containing the in-place object's position rectangle (<i>lprcPosRect</i>).
    ///                   This rectangle is relative to the client area of the object's parent window.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The specified pointer is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is insufficient memory available for the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT SetObjectRects(RECT* lprcPosRect, RECT* lprcClipRect);
    ///Reactivates a previously deactivated object, undoing the last state of the object.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTUNDOABLE</b></dt>
    ///    </dl> </td> <td width="60%"> The undo state is not available. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is insufficient memory available for the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT ReactivateAndUndo();
}

///Manages the interaction between the container and the object's in-place client site. Recall that the client site is
///the display site for embedded objects, and provides position and conceptual information about the object. This
///interface provides methods that manage in-place objects. With <b>IOleInPlaceSite</b>, you can determine if an object
///can be activated and manage its activation and deactivation. You can notify the container when one of its objects is
///being activated and inform the container that a composite menu will replace the container's regular menu. It provides
///methods that make it possible for the in-place object to retrieve the window object hierarchy, and the position in
///the parent window where the object should place its in-place activation window. Finally, it determines how the
///container scrolls the object, manages the object undo state, and notifies the object when its borders have changed.
@GUID("00000119-0000-0000-C000-000000000046")
interface IOleInPlaceSite : IOleWindow
{
    ///Determines whether the container can activate the object in place.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The container does not allow in-place activation for this object. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred.
    ///    </td> </tr> </table>
    ///    
    HRESULT CanInPlaceActivate();
    ///Notifies the container that one of its objects is being activated in place.
    ///Returns:
    ///    This method returns S_OK if the container allows the in-place activation. Other possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT OnInPlaceActivate();
    ///Notifies the container that the object is about to be activated in place and that the object is going to replace
    ///the container's main menu with an in-place composite menu.
    ///Returns:
    ///    This method returns S_OK if the container allows the in-place activation. Other possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT OnUIActivate();
    ///Enables an in-place object to retrieve the window interfaces that form the window object hierarchy, and the
    ///position in the parent window where the object's in-place activation window should be located.
    ///Params:
    ///    ppFrame = A pointer to an IOleInPlaceFrame pointer variable that receives the interface pointer to the frame. If an
    ///              error occurs, the implementation must set <i>ppFrame</i> to <b>NULL</b>.
    ///    ppDoc = A pointer to an IOleInPlaceUIWindow pointer variable that receives the interface pointer to the document
    ///            window. If the document window is the same as the frame window, <i>ppDoc</i> is set to <b>NULL</b>. In this
    ///            case, the object can only use <i>ppFrame</i> or border negotiation. If an error is returned, the
    ///            implementation must set <i>ppDoc</i> to <b>NULL</b>.
    ///    lprcPosRect = A pointer to a RECT structure for the rectangle containing the position of the in-place object in the client
    ///                  coordinates of its parent window. If an error is returned, this parameter must be set to <b>NULL</b>.
    ///    lprcClipRect = A pointer to a RECT structure for the outer rectangle containing the in-place object's position rectangle
    ///                   (<i>lprcPosRect</i>). This rectangle is relative to the client area of the object's parent window. If an
    ///                   error is returned, this parameter must be set to <b>NULL</b>.
    ///    lpFrameInfo = A pointer to an OLEINPLACEFRAMEINFO structure the container is to fill in with appropriate data. If an error
    ///                  is returned, this parameter must be set to <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> One or more of the supplied pointers is invalid. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetWindowContext(IOleInPlaceFrame* ppFrame, IOleInPlaceUIWindow* ppDoc, RECT* lprcPosRect, 
                             RECT* lprcClipRect, OIFI* lpFrameInfo);
    ///Instructs the container to scroll the view of the object by the specified number of pixels.
    ///Params:
    ///    scrollExtant = The number of pixels by which to scroll in the X and Y directions.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The specified pointer is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT Scroll(SIZE scrollExtant);
    ///Notifies the container that it should reinstall its user interface and take focus, and whether the object has an
    ///undoable state.
    ///Params:
    ///    fUndoable = Specifies whether the object can undo changes (TRUE) or not (FALSE).
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT OnUIDeactivate(BOOL fUndoable);
    ///Notifies the container that the object is no longer active in place.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT OnInPlaceDeactivate();
    ///Instructs the container to discard its undo state. The container should not call
    ///IOleInPlaceObject::ReActivateAndUndo.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT DiscardUndoState();
    ///Deactivates the object, ends the in-place session, and reverts to the container's saved undo state.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT DeactivateAndUndo();
    ///Notifies the container that the object extents have changed.
    ///Params:
    ///    lprcPosRect = A pointer a RECT structure that contains the position of the in-place object in the client coordinates of its
    ///                  parent window.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The supplied pointer is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error occurred. </td> </tr> </table>
    ///    
    HRESULT OnPosRectChange(RECT* lprcPosRect);
}

@GUID("0000012A-0000-0000-C000-000000000046")
interface IContinue : IUnknown
{
    HRESULT FContinue();
}

///Enables an object to display itself directly without passing a data object to the caller. In addition, this interface
///can create and manage a connection with an advise sink so the caller can be notified of changes in the view object.
///The caller can request specific representations and specific target devices. For example, a caller can ask for either
///an object's content or an iconic representation. Also, the caller can ask the object to compose a picture for a
///target device that is independent of the drawing device context. As a result, the picture can be composed for one
///target device and drawn on another device context. For example, to provide a print preview operation, you can compose
///the drawing for a printer target device but actually draw the representation on the display. The <b>IViewObject</b>
///interface is similar to IDataObject; except that <b>IViewObject</b> places a representation of the data onto a device
///context while <b>IDataObject</b> places the representation onto a transfer medium. Unlike most other interfaces,
///<b>IViewObject</b> cannot be marshaled to another process. This is because device contexts are only effective in the
///context of one process.
@GUID("0000010D-0000-0000-C000-000000000046")
interface IViewObject : IUnknown
{
    ///Draws a representation of an object onto the specified device context.
    ///Params:
    ///    dwDrawAspect = Specifies the aspect to be drawn, that is, how the object is to be represented. Representations include
    ///                   content, an icon, a thumbnail, or a printed document. Valid values are taken from the enumerations DVASPECT
    ///                   and DVASPECT2. Note that newer objects and containers that support optimized drawing interfaces support the
    ///                   <b>DVASPECT2</b> enumeration values. Older objects and containers that do not support optimized drawing
    ///                   interfaces may not support <b>DVASPECT2</b>. Windowless objects allow only <b>DVASPECT</b>_CONTENT,
    ///                   <b>DVASPECT</b>_OPAQUE, and <b>DVASPECT</b>_TRANSPARENT.
    ///    lindex = Portion of the object that is of interest for the draw operation. Its interpretation varies depending on the
    ///             value in the dwAspect parameter. See the DVASPECT enumeration for more information.
    ///    pvAspect = Pointer to additional information in a DVASPECTINFO structure that enables drawing optimizations depending on
    ///               the aspect specified. Note that newer objects and containers that support optimized drawing interfaces
    ///               support this parameter as well. Older objects and containers that do not support optimized drawing interfaces
    ///               always specify <b>NULL</b> for this parameter.
    ///    ptd = Pointer to the DVTARGETDEVICE structure that describes the device for which the object is to be rendered. If
    ///          <b>NULL</b>, the view should be rendered for the default target device (typically the display). A value other
    ///          than <b>NULL</b> is interpreted in conjunction with <i>hdcTargetDev</i> and <i>hdcDraw</i>. For example, if
    ///          <i>hdcDraw</i> specifies a printer as the device context, the <i>ptd</i> parameter points to a structure
    ///          describing that printer device. The data may actually be printed if <i>hdcTargetDev</i> is a valid value or
    ///          it may be displayed in print preview mode if <i>hdcTargetDev</i> is <b>NULL</b>.
    ///    hdcTargetDev = Information context for the target device indicated by the ptd parameter from which the object can extract
    ///                   device metrics and test the device's capabilities. If <i>ptd</i> is <b>NULL</b>; the object should ignore the
    ///                   value in the <i>hdcTargetDev</i> parameter.
    ///    hdcDraw = Device context on which to draw. For a windowless object, the <i>hdcDraw</i> parameter should be in MM_TEXT
    ///              mapping mode with its logical coordinates matching the client coordinates of the containing window. For a
    ///              windowless object, the device context should be in the same state as the one normally passed by a WM_PAINT
    ///              message.
    ///    lprcBounds = Pointer to a RECTL structure specifying the rectangle on <i>hdcDraw</i> and in which the object should be
    ///                 drawn. This parameter controls the positioning and stretching of the object. This parameter should be
    ///                 <b>NULL</b> to draw a windowless in-place active object. In every other situation, <b>NULL</b> is not a legal
    ///                 value and should result in an E_INVALIDARG error code. If the container passes a non-<b>NULL</b> value to a
    ///                 windowless object, the object should render the requested aspect into the specified device context and
    ///                 rectangle. A container can request this from a windowless object to render a second, non-active view of the
    ///                 object or to print the object.
    ///    lprcWBounds = If <i>hdcDraw</i> is a metafile device context, pointer to a RECTL structure specifying the bounding
    ///                  rectangle in the underlying metafile. The rectangle structure contains the window extent and window origin.
    ///                  These values are useful for drawing metafiles. The rectangle indicated by <i>lprcBounds</i> is nested inside
    ///                  this <i>lprcWBounds</i> rectangle; they are in the same coordinate space. If <i>hdcDraw</i> is not a metafile
    ///                  device context; <i>lprcWBounds</i> will be <b>NULL</b>.
    ///    pfnContinue = Pointer to a callback function that the view object should call periodically during a lengthy drawing
    ///                  operation to determine whether the operation should continue or be canceled. This function returns
    ///                  <b>TRUE</b> to continue drawing. It returns <b>FALSE</b> to stop the drawing in which case
    ///                  <b>IViewObject::Draw</b> returns DRAW_E_ABORT.
    ///    dwContinue = Value to pass as a parameter to the function pointed to by the <i>pfnContinue</i> parameter. Typically,
    ///                 <i>dwContinue</i> is a pointer to an application-defined structure needed inside the callback function.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_BLANK</b></dt> </dl>
    ///    </td> <td width="60%"> No data to draw from. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DRAW_E_ABORT</b></dt> </dl> </td> <td width="60%"> Draw operation aborted. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VIEW_E_DRAW</b></dt> </dl> </td> <td width="60%"> Error in drawing. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>DV_E_LINDEX</b></dt> </dl> </td> <td width="60%"> Invalid value for lindex;
    ///    currently only -1 is supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_DVASPECT</b></dt> </dl>
    ///    </td> <td width="60%"> Invalid value for <i>dwAspect</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_INVALIDRECT</b></dt> </dl> </td> <td width="60%"> Invalid rectangle. </td> </tr> </table>
    ///    
    HRESULT Draw(uint dwDrawAspect, int lindex, void* pvAspect, DVTARGETDEVICE* ptd, HDC hdcTargetDev, HDC hdcDraw, 
                 RECTL* lprcBounds, RECTL* lprcWBounds, BOOL************** pfnContinue, size_t dwContinue);
    ///Returns the logical palette that the object will use for drawing in its IViewObject::Draw method with the
    ///corresponding parameters.
    ///Params:
    ///    dwDrawAspect = Specifies how the object is to be represented. Representations include content, an icon, a thumbnail, or a
    ///                   printed document. Valid values are taken from the enumeration DVASPECT. See the <b>DVASPECT</b> enumeration
    ///                   for more information.
    ///    lindex = Portion of the object that is of interest for the draw operation. Its interpretation varies with
    ///             <i>dwDrawAspect</i>. See the DVASPECT enumeration for more information.
    ///    pvAspect = Pointer to additional information about the view of the object specified in <i>dwDrawAspect</i>. Since none
    ///               of the current aspects support additional information, <i>pvAspect</i> must always be <b>NULL</b>.
    ///    ptd = Pointer to the DVTARGETDEVICE structure that describes the device for which the object is to be rendered. If
    ///          <b>NULL</b>, the view should be rendered for the default target device (typically the display). A value other
    ///          than <b>NULL</b> is interpreted in conjunction with <i>hicTargetDev</i> and <i>hdcDraw</i>. For example, if
    ///          <i>hdcDraw</i> specifies a printer as the device context, ptd points to a structure describing that printer
    ///          device. The data may actually be printed if <i>hicTargetDev</i> is a valid value or it may be displayed in
    ///          print preview mode if <i>hicTargetDev</i> is <b>NULL</b>.
    ///    hicTargetDev = Information context for the target device indicated by the <i>ptd</i> parameter from which the object can
    ///                   extract device metrics and test the device's capabilities. If <i>ptd</i> is <b>NULL</b>, the object should
    ///                   ignore the <i>hicTargetDev</i> parameter.
    ///    ppColorSet = Address of LOGPALETTE pointer variable that receives a pointer to the LOGPALETTE structure. The LOGPALETTE
    ///                 structure contains the set of colors that would be used if IViewObject::Draw were called with the same
    ///                 parameters for <i>dwAspect</i>, <i>lindex</i>, <i>pvAspect</i>, <i>ptd</i>, and <i>hicTargetDev</i>. If
    ///                 <i>ppColorSet</i> is <b>NULL</b>, the object does not use a palette.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> Set of colors is empty or the object will not give out the information. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>OLE_E_BLANK</b></dt> </dl> </td> <td width="60%"> No presentation data for
    ///    object. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_LINDEX</b></dt> </dl> </td> <td width="60%">
    ///    Invalid value for <i>lindex</i>; currently only -1 is supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DV_E_DVASPECT</b></dt> </dl> </td> <td width="60%"> Invalid value for <i>dwAspect</i>. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One or more of the
    ///    supplied parameter values is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT GetColorSet(uint dwDrawAspect, int lindex, void* pvAspect, DVTARGETDEVICE* ptd, HDC hicTargetDev, 
                        LOGPALETTE** ppColorSet);
    ///Freezes the drawn representation of an object so that it will not change until the IViewObject::Unfreeze method
    ///is called. The most common use of this method is for banded printing.
    ///Params:
    ///    dwDrawAspect = Specifies how the object is to be represented. Representations include content, an icon, a thumbnail, or a
    ///                   printed document. Valid values are taken from the enumeration DVASPECT. See the <b>DVASPECT</b> enumeration
    ///                   for more information.
    ///    lindex = Portion of the object that is of interest for the draw operation. Its interpretation varies with dwAspect.
    ///             See the DVASPECT enumeration for more information.
    ///    pvAspect = Pointer to additional information about the view of the object specified in <i>dwAspect</i>. Since none of
    ///               the current aspects support additional information, <i>pvAspect</i> must always be <b>NULL</b>.
    ///    pdwFreeze = Pointer to where an identifying DWORD key is returned. This unique key is later used to cancel the freeze by
    ///                calling IViewObject::Unfreeze. This key is an index that the default cache uses to keep track of which object
    ///                is frozen.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VIEW_S_ALREADY_FROZEN</b></dt> </dl> </td> <td width="60%"> Presentation has already been frozen. The
    ///    value of <i>pdwFreeze</i> is the identifying key of the already frozen object. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>OLE_E_BLANK</b></dt> </dl> </td> <td width="60%"> Presentation not in cache. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_LINDEX</b></dt> </dl> </td> <td width="60%"> Invalid value for
    ///    <i>lindex</i>; currently; only -1 is supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DV_E_DVASPECT</b></dt> </dl> </td> <td width="60%"> Invalid value for <i>dwAspect</i>. </td> </tr>
    ///    </table>
    ///    
    HRESULT Freeze(uint dwDrawAspect, int lindex, void* pvAspect, uint* pdwFreeze);
    ///Releases a drawing that was previously frozen using IViewObject::Freeze. The most common use of this method is
    ///for banded printing.
    ///Params:
    ///    dwFreeze = Contains a key previously returned from IViewObject::Freeze that determines which view object to unfreeze.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_NOCONNECTION</b></dt>
    ///    </dl> </td> <td width="60%"> Error in the unfreezing process or the object is currently not frozen. </td>
    ///    </tr> </table>
    ///    
    HRESULT Unfreeze(uint dwFreeze);
    ///Establishes a connection between the view object and an advise sink so that the advise sink can be notified about
    ///changes in the object's view.
    ///Params:
    ///    aspects = View for which the advisory connection is being set up. Valid values are taken from the enumeration DVASPECT.
    ///              See the <b>DVASPECT</b> enumeration for more information.
    ///    advf = Contains a group of flags for controlling the advisory connection. Valid values are from the enumeration
    ///           ADVF. However, only some of the possible <b>ADVF</b> values are relevant for this method. The following table
    ///           briefly describes the relevant values. See the <b>ADVF</b> enumeration for a more detailed description.
    ///           <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ADVF_ONLYONCE"></a><a
    ///           id="advf_onlyonce"></a><dl> <dt><b>ADVF_ONLYONCE</b></dt> </dl> </td> <td width="60%"> Causes the advisory
    ///           connection to be destroyed after the first notification is sent. </td> </tr> <tr> <td width="40%"><a
    ///           id="ADVF_PRIMEFIRST"></a><a id="advf_primefirst"></a><dl> <dt><b>ADVF_PRIMEFIRST</b></dt> </dl> </td> <td
    ///           width="60%"> Causes an initial notification to be sent regardless of whether data has changed from its
    ///           current state. </td> </tr> </table> <div class="alert"><b>Note</b> The ADVF_ONLYONCE and ADVF_PRIMEFIRST can
    ///           be combined to provide an asynchronous call to IDataObject::GetData. </div> <div> </div>
    ///    pAdvSink = Pointer to the IAdviseSink interface on the advisory sink that is to be informed of changes. A <b>NULL</b>
    ///               value deletes any existing advisory connection.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLE_E_ADVISENOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> Advisory notifications are not
    ///    supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_DVASPECT</b></dt> </dl> </td> <td width="60%">
    ///    Invalid value for <i>dwAspect</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> One or more of the supplied values is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory available for this operation.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetAdvise(uint aspects, uint advf, IAdviseSink pAdvSink);
    ///Retrieves the advisory connection on the object that was used in the most recent call to IViewObject::SetAdvise.
    ///Params:
    ///    pAspects = Pointer to where the <i>dwAspect</i> parameter from the previous IViewObject::SetAdvise call is returned. If
    ///               this pointer is <b>NULL</b>, the caller does not permit this value to be returned.
    ///    pAdvf = Pointer to where the <i>advf</i> parameter from the previous IViewObject::SetAdvise call is returned. If this
    ///            pointer is <b>NULL</b>, the caller does not permit this value to be returned.
    ///    ppAdvSink = Address of IAdviseSink pointer variable that receives the interface pointer to the advise sink. The
    ///                connection to this advise sink must have been established with a previous IViewObject::SetAdvise call, which
    ///                provides the <i>pAdvSink</i> parameter. If <i>ppvAdvSink</i> is <b>NULL</b>, there is no established advisory
    ///                connection.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT GetAdvise(uint* pAspects, uint* pAdvf, IAdviseSink* ppAdvSink);
}

///An extension to the IViewObject interface which returns the size of the drawing for a given view of an object. You
///can prevent the object from being run if it isn't already running by calling this method instead of
///IOleObject::GetExtent. Like the IViewObject interface, <b>IViewObject2</b> cannot be marshaled to another process.
///This is because device contexts are only effective in the context of one process. The OLE-provided default
///implementation provides the size of the object in the cache.
@GUID("00000127-0000-0000-C000-000000000046")
interface IViewObject2 : IViewObject
{
    ///Retrieves the size that the specified view object will be drawn on the specified target device.
    ///Params:
    ///    dwDrawAspect = Requested view of the object whose size is of interest. Possible values are taken from the DVASPECT and
    ///                   DVASPECT2 enumerations. Note that newer objects and containers that support optimized drawing interfaces
    ///                   support the <b>DVASPECT2</b> enumeration values. Older objects and containers that do not support optimized
    ///                   drawing interfaces may not support <b>DVASPECT2</b>.
    ///    lindex = The portion of the object that is of interest. Currently, the only possible value is -1.
    ///    ptd = A pointer to the DVTARGETDEVICE structure defining the target device for which the object's size should be
    ///          returned.
    ///    lpsizel = A pointer to where the object's size is returned.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_BLANK</b></dt> </dl>
    ///    </td> <td width="60%"> An appropriate cache is not available. </td> </tr> </table>
    ///    
    HRESULT GetExtent(uint dwDrawAspect, int lindex, DVTARGETDEVICE* ptd, SIZE* lpsizel);
}

///The <b>IDropSource</b> interface is one of the interfaces you implement to provide drag-and-drop operations in your
///application. It contains methods used in any application used as a data source in a drag-and-drop operation. The data
///source application in a drag-and-drop operation is responsible for: <ul> <li>Determining the data being dragged based
///on the user's selection.</li> <li>Initiating the drag-and-drop operation based on the user's mouse actions.</li>
///<li>Generating some of the visual feedback during the drag-and-drop operation, such as setting the cursor and
///highlighting the data selected for the drag-and-drop operation.</li> <li>Canceling or completing the drag-and-drop
///operation based on the user's mouse actions.</li> <li>Performing any action on the original data caused by the drop
///operation, such as deleting the data on a drag move.</li> </ul><b>IDropSource</b> contains the methods for generating
///visual feedback to the end user and for canceling or completing the drag-and-drop operation. You also need to call
///the DoDragDrop, RegisterDragDrop, and RevokeDragDrop functions in drag-and-drop operations.
@GUID("00000121-0000-0000-C000-000000000046")
interface IDropSource : IUnknown
{
    ///Determines whether a drag-and-drop operation should be continued, canceled, or completed. You do not call this
    ///method directly. The OLE DoDragDrop function calls this method during a drag-and-drop operation.
    ///Params:
    ///    fEscapePressed = Indicates whether the Esc key has been pressed since the previous call to <b>QueryContinueDrag</b> or to
    ///                     DoDragDrop if this is the first call to <b>QueryContinueDrag</b>. A <b>TRUE</b> value indicates the end user
    ///                     has pressed the escape key; a <b>FALSE</b> value indicates it has not been pressed.
    ///    grfKeyState = The current state of the keyboard modifier keys on the keyboard. Possible values can be a combination of any
    ///                  of the flags MK_CONTROL, MK_SHIFT, MK_ALT, MK_BUTTON, MK_LBUTTON, MK_MBUTTON, and MK_RBUTTON.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The drag operation should
    ///    continue. This result occurs if no errors are detected, the mouse button starting the drag-and-drop operation
    ///    has not been released, and the Esc key has not been detected. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DRAGDROP_S_DROP</b></dt> </dl> </td> <td width="60%"> The drop operation should occur completing the
    ///    drag operation. This result occurs if <i>grfKeyState</i> indicates that the key that started the
    ///    drag-and-drop operation has been released. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>DRAGDROP_S_CANCEL</b></dt> </dl> </td> <td width="60%"> The drag operation should be canceled with no
    ///    drop operation occurring. This result occurs if <i>fEscapePressed</i> is <b>TRUE</b>, indicating the Esc key
    ///    has been pressed. </td> </tr> </table>
    ///    
    HRESULT QueryContinueDrag(BOOL fEscapePressed, uint grfKeyState);
    ///Enables a source application to give visual feedback to the end user during a drag-and-drop operation by
    ///providing the DoDragDrop function with an enumeration value specifying the visual effect.
    ///Params:
    ///    dwEffect = The DROPEFFECT value returned by the most recent call to IDropTarget::DragEnter, IDropTarget::DragOver, or
    ///               IDropTarget::DragLeave.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>DRAGDROP_S_USEDEFAULTCURSORS</b></dt>
    ///    </dl> </td> <td width="60%"> Indicates successful completion of the method, and requests OLE to update the
    ///    cursor using the OLE-provided default cursors. </td> </tr> </table>
    ///    
    HRESULT GiveFeedback(uint dwEffect);
}

///The <b>IDropTarget</b> interface is one of the interfaces you implement to provide drag-and-drop operations in your
///application. It contains methods used in any application that can be a target for data during a drag-and-drop
///operation. A drop-target application is responsible for: <ul> <li>Determining the effect of the drop on the target
///application.</li> <li>Incorporating any valid dropped data when the drop occurs.</li> <li>Communicating target
///feedback to the source so the source application can provide appropriate visual feedback such as setting the
///cursor.</li> <li>Implementing drag scrolling.</li> <li>Registering and revoking its application windows as drop
///targets.</li> </ul>The <b>IDropTarget</b> interface contains methods that handle all these responsibilities except
///registering and revoking the application window as a drop target, for which you must call the RegisterDragDrop and
///the RevokeDragDrop functions.
@GUID("00000122-0000-0000-C000-000000000046")
interface IDropTarget : IUnknown
{
    ///Indicates whether a drop can be accepted, and, if so, the effect of the drop.
    ///Params:
    ///    pDataObj = A pointer to the IDataObject interface on the data object. This data object contains the data being
    ///               transferred in the drag-and-drop operation. If the drop occurs, this data object will be incorporated into
    ///               the target.
    ///    grfKeyState = The current state of the keyboard modifier keys on the keyboard. Possible values can be a combination of any
    ///                  of the flags MK_CONTROL, MK_SHIFT, MK_ALT, MK_BUTTON, MK_LBUTTON, MK_MBUTTON, and MK_RBUTTON.
    ///    pt = A POINTL structure containing the current cursor coordinates in screen coordinates.
    ///    pdwEffect = On input, pointer to the value of the <i>pdwEffect</i> parameter of the DoDragDrop function. On return, must
    ///                contain one of the DROPEFFECT flags, which indicates what the result of the drop operation would be.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pdwEffect</i> parameter is <b>NULL</b> on
    ///    input. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    There was insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT DragEnter(IDataObject pDataObj, uint grfKeyState, POINTL pt, uint* pdwEffect);
    ///Provides target feedback to the user and communicates the drop's effect to the DoDragDrop function so it can
    ///communicate the effect of the drop back to the source.
    ///Params:
    ///    grfKeyState = The current state of the keyboard modifier keys on the keyboard. Valid values can be a combination of any of
    ///                  the flags MK_CONTROL, MK_SHIFT, MK_ALT, MK_BUTTON, MK_LBUTTON, MK_MBUTTON, and MK_RBUTTON.
    ///    pt = A POINTL structure containing the current cursor coordinates in screen coordinates.
    ///    pdwEffect = On input, pointer to the value of the <i>pdwEffect</i> parameter of the DoDragDrop function. On return, must
    ///                contain one of the DROPEFFECT flags, which indicates what the result of the drop operation would be.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pdwEffect</i> value is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There was
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT DragOver(uint grfKeyState, POINTL pt, uint* pdwEffect);
    ///Removes target feedback and releases the data object.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> There is insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT DragLeave();
    ///Incorporates the source data into the target window, removes target feedback, and releases the data object.
    ///Params:
    ///    pDataObj = A pointer to the IDataObject interface on the data object being transferred in the drag-and-drop operation.
    ///    grfKeyState = The current state of the keyboard modifier keys on the keyboard. Possible values can be a combination of any
    ///                  of the flags MK_CONTROL, MK_SHIFT, MK_ALT, MK_BUTTON, MK_LBUTTON, MK_MBUTTON, and MK_RBUTTON.
    ///    pt = A POINTL structure containing the current cursor coordinates in screen coordinates.
    ///    pdwEffect = On input, pointer to the value of the <i>pdwEffect</i> parameter of the DoDragDrop function. On return, must
    ///                contain one of the DROPEFFECT flags, which indicates what the result of the drop operation would be.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pdwEffect</i> parameter is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT Drop(IDataObject pDataObj, uint grfKeyState, POINTL pt, uint* pdwEffect);
}

///The <b>IDropSourceNotify</b> interface is implemented on an IDropSource object to receive notifications from OLE when
///a user drags the mouse into or out of a potential drop target window.
@GUID("0000012B-0000-0000-C000-000000000046")
interface IDropSourceNotify : IUnknown
{
    ///OLE calls this method when the user drags the mouse cursor into a potential drop target window.
    ///Params:
    ///    hwndTarget = The window handle of the potential drop target window.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT DragEnterTarget(HWND hwndTarget);
    ///OLE calls this method when the user drags the mouse cursor out of a potential drop target window.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT DragLeaveTarget();
}

///When implemented by the drop target application, this interface gives the OLE drag and drop engine the ability to
///determine whether the drop target application intends to evaluate enterprise protection policy and gives the OLE drag
///and drop engine a way to provide the enterprise ID of the drop source application to the drop target application.
@GUID("390E3878-FD55-4E18-819D-4682081C0CFD")
interface IEnterpriseDropTarget : IUnknown
{
    ///Provides the drop target with the enterprise ID of the drop source.
    ///Params:
    ///    identity = The enterprise identity of the drop source.
    HRESULT SetDropSourceEnterpriseId(const(wchar)* identity);
    ///Indicates whether the drop target is intends to handle the evaluation of the enterprise protection policy.
    ///Params:
    ///    value = A boolean value that indicates whether the drop target intends to handle the evaluation of enterprise
    ///            protection policy.
    HRESULT IsEvaluatingEdpPolicy(int* value);
}

///Enumerates the different verbs available for an object in order of ascending verb number. An enumerator that
///implements the <b>IEnumOLEVERB</b> interface is returned by IOleObject::EnumVerbs.
@GUID("00000104-0000-0000-C000-000000000046")
interface IEnumOLEVERB : IUnknown
{
    ///Retrieves the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be retrieved. If there are fewer than the requested number of items left in the
    ///           sequence, this method retrieves the remaining elements.
    ///    rgelt = An array of enumerated items. The enumerator is responsible for allocating any memory, and the caller is
    ///            responsible for freeing it. If <i>celt</i> is greater than 1, the caller must also pass a non-<b>NULL</b>
    ///            pointer passed to <i>pceltFetched</i> to know how many pointers to release.
    ///    pceltFetched = The number of items that were retrieved. This parameter is always less than or equal to the number of items
    ///                   requested. This parameter can be <b>NULL</b> if <i>celt</i> is 1.
    ///Returns:
    ///    If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Skips over the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be skipped.
    ///Returns:
    ///    If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Skip(uint celt);
    ///Resets the enumeration sequence to the beginning.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT Reset();
    ///Creates a new enumerator that contains the same enumeration state as the current one. This method makes it
    ///possible to record a particular point in the enumeration sequence and then return to that point at a later time.
    ///The caller must release this new enumerator separately from the first enumerator.
    ///Params:
    ///    ppenum = A pointer to an IEnumOLEVERB pointer variable that receives the interface pointer to the enumeration object.
    ///             If the method is unsuccessful, the value of this output variable is undefined.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified enumerator is invalid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory
    ///    available for this operation. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumOLEVERB* ppenum);
}

@GUID("79EAC9C9-BAF9-11CE-8C82-00AA004BA90B")
interface IPersistMoniker : IUnknown
{
    HRESULT GetClassID(GUID* pClassID);
    HRESULT IsDirty();
    HRESULT Load(BOOL fFullyAvailable, IMoniker pimkName, IBindCtx pibc, uint grfMode);
    HRESULT Save(IMoniker pimkName, IBindCtx pbc, BOOL fRemember);
    HRESULT SaveCompleted(IMoniker pimkName, IBindCtx pibc);
    HRESULT GetCurMoniker(IMoniker* ppimkName);
}

@GUID("A5CA5F7F-1847-4D87-9C5B-918509F7511D")
interface IMonikerProp : IUnknown
{
    HRESULT PutProperty(MONIKERPROPERTY mkp, const(wchar)* val);
}

@GUID("79EAC9CD-BAF9-11CE-8C82-00AA004BA90B")
interface IBindProtocol : IUnknown
{
    HRESULT CreateBinding(const(wchar)* szUrl, IBindCtx pbc, IBinding* ppb);
}

@GUID("79EAC9C0-BAF9-11CE-8C82-00AA004BA90B")
interface IBinding : IUnknown
{
    HRESULT Abort();
    HRESULT Suspend();
    HRESULT Resume();
    HRESULT SetPriority(int nPriority);
    HRESULT GetPriority(int* pnPriority);
    HRESULT GetBindResult(GUID* pclsidProtocol, uint* pdwResult, ushort** pszResult, uint* pdwReserved);
}

@GUID("79EAC9C1-BAF9-11CE-8C82-00AA004BA90B")
interface IBindStatusCallback : IUnknown
{
    HRESULT OnStartBinding(uint dwReserved, IBinding pib);
    HRESULT GetPriority(int* pnPriority);
    HRESULT OnLowResource(uint reserved);
    HRESULT OnProgress(uint ulProgress, uint ulProgressMax, uint ulStatusCode, const(wchar)* szStatusText);
    HRESULT OnStopBinding(HRESULT hresult, const(wchar)* szError);
    HRESULT GetBindInfo(uint* grfBINDF, BINDINFO* pbindinfo);
    HRESULT OnDataAvailable(uint grfBSCF, uint dwSize, FORMATETC* pformatetc, STGMEDIUM* pstgmed);
    HRESULT OnObjectAvailable(const(GUID)* riid, IUnknown punk);
}

@GUID("AAA74EF9-8EE7-4659-88D9-F8C504DA73CC")
interface IBindStatusCallbackEx : IBindStatusCallback
{
    HRESULT GetBindInfoEx(uint* grfBINDF, BINDINFO* pbindinfo, uint* grfBINDF2, uint* pdwReserved);
}

@GUID("79EAC9D0-BAF9-11CE-8C82-00AA004BA90B")
interface IAuthenticate : IUnknown
{
    HRESULT Authenticate(HWND* phwnd, ushort** pszUsername, ushort** pszPassword);
}

@GUID("2AD1EDAF-D83D-48B5-9ADF-03DBE19F53BD")
interface IAuthenticateEx : IAuthenticate
{
    HRESULT AuthenticateEx(HWND* phwnd, ushort** pszUsername, ushort** pszPassword, AUTHENTICATEINFO* pauthinfo);
}

@GUID("79EAC9D2-BAF9-11CE-8C82-00AA004BA90B")
interface IHttpNegotiate : IUnknown
{
    HRESULT BeginningTransaction(const(wchar)* szURL, const(wchar)* szHeaders, uint dwReserved, 
                                 ushort** pszAdditionalHeaders);
    HRESULT OnResponse(uint dwResponseCode, const(wchar)* szResponseHeaders, const(wchar)* szRequestHeaders, 
                       ushort** pszAdditionalRequestHeaders);
}

@GUID("4F9F9FCB-E0F4-48EB-B7AB-FA2EA9365CB4")
interface IHttpNegotiate2 : IHttpNegotiate
{
    HRESULT GetRootSecurityId(char* pbSecurityId, uint* pcbSecurityId, size_t dwReserved);
}

@GUID("57B6C80A-34C2-4602-BC26-66A02FC57153")
interface IHttpNegotiate3 : IHttpNegotiate2
{
    HRESULT GetSerializedClientCertContext(char* ppbCert, uint* pcbCert);
}

@GUID("F134C4B7-B1F8-4E75-B886-74B90943BECB")
interface IWinInetFileStream : IUnknown
{
    HRESULT SetHandleForUnlock(size_t hWinInetLockHandle, size_t dwReserved);
    HRESULT SetDeleteFile(size_t dwReserved);
}

@GUID("79EAC9D5-BAFA-11CE-8C82-00AA004BA90B")
interface IWindowForBindingUI : IUnknown
{
    HRESULT GetWindow(const(GUID)* rguidReason, HWND* phwnd);
}

@GUID("79EAC9D1-BAF9-11CE-8C82-00AA004BA90B")
interface ICodeInstall : IWindowForBindingUI
{
    HRESULT OnCodeInstallProblem(uint ulStatusCode, const(wchar)* szDestination, const(wchar)* szSource, 
                                 uint dwReserved);
}

@GUID("A39EE748-6A27-4817-A6F2-13914BEF5890")
interface IUri : IUnknown
{
    HRESULT GetPropertyBSTR(Uri_PROPERTY uriProp, BSTR* pbstrProperty, uint dwFlags);
    HRESULT GetPropertyLength(Uri_PROPERTY uriProp, uint* pcchProperty, uint dwFlags);
    HRESULT GetPropertyDWORD(Uri_PROPERTY uriProp, uint* pdwProperty, uint dwFlags);
    HRESULT HasProperty(Uri_PROPERTY uriProp, int* pfHasProperty);
    HRESULT GetAbsoluteUri(BSTR* pbstrAbsoluteUri);
    HRESULT GetAuthority(BSTR* pbstrAuthority);
    HRESULT GetDisplayUri(BSTR* pbstrDisplayString);
    HRESULT GetDomain(BSTR* pbstrDomain);
    HRESULT GetExtension(BSTR* pbstrExtension);
    HRESULT GetFragment(BSTR* pbstrFragment);
    HRESULT GetHost(BSTR* pbstrHost);
    HRESULT GetPassword(BSTR* pbstrPassword);
    HRESULT GetPath(BSTR* pbstrPath);
    HRESULT GetPathAndQuery(BSTR* pbstrPathAndQuery);
    HRESULT GetQuery(BSTR* pbstrQuery);
    HRESULT GetRawUri(BSTR* pbstrRawUri);
    HRESULT GetSchemeName(BSTR* pbstrSchemeName);
    HRESULT GetUserInfo(BSTR* pbstrUserInfo);
    HRESULT GetUserNameA(BSTR* pbstrUserName);
    HRESULT GetHostType(uint* pdwHostType);
    HRESULT GetPort(uint* pdwPort);
    HRESULT GetScheme(uint* pdwScheme);
    HRESULT GetZone(uint* pdwZone);
    HRESULT GetProperties(uint* pdwFlags);
    HRESULT IsEqual(IUri pUri, int* pfEqual);
}

@GUID("A158A630-ED6F-45FB-B987-F68676F57752")
interface IUriContainer : IUnknown
{
    HRESULT GetIUri(IUri* ppIUri);
}

@GUID("4221B2E1-8955-46C0-BD5B-DE9897565DE7")
interface IUriBuilder : IUnknown
{
    HRESULT CreateUriSimple(uint dwAllowEncodingPropertyMask, size_t dwReserved, IUri* ppIUri);
    HRESULT CreateUri(uint dwCreateFlags, uint dwAllowEncodingPropertyMask, size_t dwReserved, IUri* ppIUri);
    HRESULT CreateUriWithFlags(uint dwCreateFlags, uint dwUriBuilderFlags, uint dwAllowEncodingPropertyMask, 
                               size_t dwReserved, IUri* ppIUri);
    HRESULT GetIUri(IUri* ppIUri);
    HRESULT SetIUri(IUri pIUri);
    HRESULT GetFragment(uint* pcchFragment, ushort** ppwzFragment);
    HRESULT GetHost(uint* pcchHost, ushort** ppwzHost);
    HRESULT GetPassword(uint* pcchPassword, ushort** ppwzPassword);
    HRESULT GetPath(uint* pcchPath, ushort** ppwzPath);
    HRESULT GetPort(int* pfHasPort, uint* pdwPort);
    HRESULT GetQuery(uint* pcchQuery, ushort** ppwzQuery);
    HRESULT GetSchemeName(uint* pcchSchemeName, ushort** ppwzSchemeName);
    HRESULT GetUserNameA(uint* pcchUserName, ushort** ppwzUserName);
    HRESULT SetFragment(const(wchar)* pwzNewValue);
    HRESULT SetHost(const(wchar)* pwzNewValue);
    HRESULT SetPassword(const(wchar)* pwzNewValue);
    HRESULT SetPath(const(wchar)* pwzNewValue);
    HRESULT SetPortA(BOOL fHasPort, uint dwNewValue);
    HRESULT SetQuery(const(wchar)* pwzNewValue);
    HRESULT SetSchemeName(const(wchar)* pwzNewValue);
    HRESULT SetUserName(const(wchar)* pwzNewValue);
    HRESULT RemoveProperties(uint dwPropertyMask);
    HRESULT HasBeenModified(int* pfModified);
}

@GUID("E982CE48-0B96-440C-BC37-0C869B27A29E")
interface IUriBuilderFactory : IUnknown
{
    HRESULT CreateIUriBuilder(uint dwFlags, size_t dwReserved, IUriBuilder* ppIUriBuilder);
    HRESULT CreateInitializedIUriBuilder(uint dwFlags, size_t dwReserved, IUriBuilder* ppIUriBuilder);
}

@GUID("79EAC9D6-BAFA-11CE-8C82-00AA004BA90B")
interface IWinInetInfo : IUnknown
{
    HRESULT QueryOption(uint dwOption, void* pBuffer, uint* pcbBuf);
}

@GUID("79EAC9D7-BAFA-11CE-8C82-00AA004BA90B")
interface IHttpSecurity : IWindowForBindingUI
{
    HRESULT OnSecurityProblem(uint dwProblem);
}

@GUID("79EAC9D8-BAFA-11CE-8C82-00AA004BA90B")
interface IWinInetHttpInfo : IWinInetInfo
{
    HRESULT QueryInfo(uint dwOption, void* pBuffer, uint* pcbBuf, uint* pdwFlags, uint* pdwReserved);
}

@GUID("F286FA56-C1FD-4270-8E67-B3EB790A81E8")
interface IWinInetHttpTimeouts : IUnknown
{
    HRESULT GetRequestTimeouts(uint* pdwConnectTimeout, uint* pdwSendTimeout, uint* pdwReceiveTimeout);
}

@GUID("DD1EC3B3-8391-4FDB-A9E6-347C3CAAA7DD")
interface IWinInetCacheHints : IUnknown
{
    HRESULT SetCacheExtension(const(wchar)* pwzExt, void* pszCacheFile, uint* pcbCacheFile, uint* pdwWinInetError, 
                              uint* pdwReserved);
}

@GUID("7857AEAC-D31F-49BF-884E-DD46DF36780A")
interface IWinInetCacheHints2 : IWinInetCacheHints
{
    HRESULT SetCacheExtension2(const(wchar)* pwzExt, char* pwzCacheFile, uint* pcchCacheFile, 
                               uint* pdwWinInetError, uint* pdwReserved);
}

@GUID("FC4801A1-2BA9-11CF-A229-00AA003D7352")
interface IBindHost : IUnknown
{
    HRESULT CreateMoniker(ushort* szName, IBindCtx pBC, IMoniker* ppmk, uint dwReserved);
    HRESULT MonikerBindToStorage(IMoniker pMk, IBindCtx pBC, IBindStatusCallback pBSC, const(GUID)* riid, 
                                 void** ppvObj);
    HRESULT MonikerBindToObject(IMoniker pMk, IBindCtx pBC, IBindStatusCallback pBSC, const(GUID)* riid, 
                                void** ppvObj);
}

@GUID("79EAC9E0-BAF9-11CE-8C82-00AA004BA90B")
interface IInternet : IUnknown
{
}

@GUID("79EAC9E1-BAF9-11CE-8C82-00AA004BA90B")
interface IInternetBindInfo : IUnknown
{
    HRESULT GetBindInfo(uint* grfBINDF, BINDINFO* pbindinfo);
    HRESULT GetBindString(uint ulStringType, ushort** ppwzStr, uint cEl, uint* pcElFetched);
}

@GUID("A3E015B7-A82C-4DCD-A150-569AEEED36AB")
interface IInternetBindInfoEx : IInternetBindInfo
{
    HRESULT GetBindInfoEx(uint* grfBINDF, BINDINFO* pbindinfo, uint* grfBINDF2, uint* pdwReserved);
}

@GUID("79EAC9E3-BAF9-11CE-8C82-00AA004BA90B")
interface IInternetProtocolRoot : IUnknown
{
    HRESULT Start(const(wchar)* szUrl, IInternetProtocolSink pOIProtSink, IInternetBindInfo pOIBindInfo, 
                  uint grfPI, size_t dwReserved);
    HRESULT Continue(PROTOCOLDATA* pProtocolData);
    HRESULT Abort(HRESULT hrReason, uint dwOptions);
    HRESULT Terminate(uint dwOptions);
    HRESULT Suspend();
    HRESULT Resume();
}

@GUID("79EAC9E4-BAF9-11CE-8C82-00AA004BA90B")
interface IInternetProtocol : IInternetProtocolRoot
{
    HRESULT Read(void* pv, uint cb, uint* pcbRead);
    HRESULT Seek(LARGE_INTEGER dlibMove, uint dwOrigin, ULARGE_INTEGER* plibNewPosition);
    HRESULT LockRequest(uint dwOptions);
    HRESULT UnlockRequest();
}

@GUID("C7A98E66-1010-492C-A1C8-C809E1F75905")
interface IInternetProtocolEx : IInternetProtocol
{
    HRESULT StartEx(IUri pUri, IInternetProtocolSink pOIProtSink, IInternetBindInfo pOIBindInfo, uint grfPI, 
                    size_t dwReserved);
}

@GUID("79EAC9E5-BAF9-11CE-8C82-00AA004BA90B")
interface IInternetProtocolSink : IUnknown
{
    HRESULT Switch(PROTOCOLDATA* pProtocolData);
    HRESULT ReportProgress(uint ulStatusCode, const(wchar)* szStatusText);
    HRESULT ReportData(uint grfBSCF, uint ulProgress, uint ulProgressMax);
    HRESULT ReportResult(HRESULT hrResult, uint dwError, const(wchar)* szResult);
}

@GUID("79EAC9F0-BAF9-11CE-8C82-00AA004BA90B")
interface IInternetProtocolSinkStackable : IUnknown
{
    HRESULT SwitchSink(IInternetProtocolSink pOIProtSink);
    HRESULT CommitSwitch();
    HRESULT RollbackSwitch();
}

@GUID("79EAC9E7-BAF9-11CE-8C82-00AA004BA90B")
interface IInternetSession : IUnknown
{
    HRESULT RegisterNameSpace(IClassFactory pCF, const(GUID)* rclsid, const(wchar)* pwzProtocol, uint cPatterns, 
                              const(ushort)** ppwzPatterns, uint dwReserved);
    HRESULT UnregisterNameSpace(IClassFactory pCF, const(wchar)* pszProtocol);
    HRESULT RegisterMimeFilter(IClassFactory pCF, const(GUID)* rclsid, const(wchar)* pwzType);
    HRESULT UnregisterMimeFilter(IClassFactory pCF, const(wchar)* pwzType);
    HRESULT CreateBinding(IBindCtx pBC, const(wchar)* szUrl, IUnknown pUnkOuter, IUnknown* ppUnk, 
                          IInternetProtocol* ppOInetProt, uint dwOption);
    HRESULT SetSessionOption(uint dwOption, void* pBuffer, uint dwBufferLength, uint dwReserved);
    HRESULT GetSessionOption(uint dwOption, void* pBuffer, uint* pdwBufferLength, uint dwReserved);
}

@GUID("79EAC9E8-BAF9-11CE-8C82-00AA004BA90B")
interface IInternetThreadSwitch : IUnknown
{
    HRESULT Prepare();
    HRESULT Continue();
}

@GUID("79EAC9EB-BAF9-11CE-8C82-00AA004BA90B")
interface IInternetPriority : IUnknown
{
    HRESULT SetPriority(int nPriority);
    HRESULT GetPriority(int* pnPriority);
}

@GUID("79EAC9EC-BAF9-11CE-8C82-00AA004BA90B")
interface IInternetProtocolInfo : IUnknown
{
    HRESULT ParseUrl(const(wchar)* pwzUrl, PARSEACTION ParseAction, uint dwParseFlags, const(wchar)* pwzResult, 
                     uint cchResult, uint* pcchResult, uint dwReserved);
    HRESULT CombineUrl(const(wchar)* pwzBaseUrl, const(wchar)* pwzRelativeUrl, uint dwCombineFlags, 
                       const(wchar)* pwzResult, uint cchResult, uint* pcchResult, uint dwReserved);
    HRESULT CompareUrl(const(wchar)* pwzUrl1, const(wchar)* pwzUrl2, uint dwCompareFlags);
    HRESULT QueryInfo(const(wchar)* pwzUrl, QUERYOPTION OueryOption, uint dwQueryFlags, void* pBuffer, 
                      uint cbBuffer, uint* pcbBuf, uint dwReserved);
}

@GUID("79EAC9ED-BAF9-11CE-8C82-00AA004BA90B")
interface IInternetSecurityMgrSite : IUnknown
{
    HRESULT GetWindow(HWND* phwnd);
    HRESULT EnableModeless(BOOL fEnable);
}

@GUID("79EAC9EE-BAF9-11CE-8C82-00AA004BA90B")
interface IInternetSecurityManager : IUnknown
{
    HRESULT SetSecuritySite(IInternetSecurityMgrSite pSite);
    HRESULT GetSecuritySite(IInternetSecurityMgrSite* ppSite);
    HRESULT MapUrlToZone(const(wchar)* pwszUrl, uint* pdwZone, uint dwFlags);
    HRESULT GetSecurityId(const(wchar)* pwszUrl, char* pbSecurityId, uint* pcbSecurityId, size_t dwReserved);
    HRESULT ProcessUrlAction(const(wchar)* pwszUrl, uint dwAction, char* pPolicy, uint cbPolicy, ubyte* pContext, 
                             uint cbContext, uint dwFlags, uint dwReserved);
    HRESULT QueryCustomPolicy(const(wchar)* pwszUrl, const(GUID)* guidKey, char* ppPolicy, uint* pcbPolicy, 
                              ubyte* pContext, uint cbContext, uint dwReserved);
    HRESULT SetZoneMapping(uint dwZone, const(wchar)* lpszPattern, uint dwFlags);
    HRESULT GetZoneMappings(uint dwZone, IEnumString* ppenumString, uint dwFlags);
}

@GUID("F164EDF1-CC7C-4F0D-9A94-34222625C393")
interface IInternetSecurityManagerEx : IInternetSecurityManager
{
    HRESULT ProcessUrlActionEx(const(wchar)* pwszUrl, uint dwAction, char* pPolicy, uint cbPolicy, ubyte* pContext, 
                               uint cbContext, uint dwFlags, uint dwReserved, uint* pdwOutFlags);
}

@GUID("F1E50292-A795-4117-8E09-2B560A72AC60")
interface IInternetSecurityManagerEx2 : IInternetSecurityManagerEx
{
    HRESULT MapUrlToZoneEx2(IUri pUri, uint* pdwZone, uint dwFlags, ushort** ppwszMappedUrl, uint* pdwOutFlags);
    HRESULT ProcessUrlActionEx2(IUri pUri, uint dwAction, char* pPolicy, uint cbPolicy, ubyte* pContext, 
                                uint cbContext, uint dwFlags, size_t dwReserved, uint* pdwOutFlags);
    HRESULT GetSecurityIdEx2(IUri pUri, char* pbSecurityId, uint* pcbSecurityId, size_t dwReserved);
    HRESULT QueryCustomPolicyEx2(IUri pUri, const(GUID)* guidKey, char* ppPolicy, uint* pcbPolicy, ubyte* pContext, 
                                 uint cbContext, size_t dwReserved);
}

@GUID("CD45F185-1B21-48E2-967B-EAD743A8914E")
interface IZoneIdentifier : IUnknown
{
    HRESULT GetId(uint* pdwZone);
    HRESULT SetId(uint dwZone);
    HRESULT Remove();
}

@GUID("EB5E760C-09EF-45C0-B510-70830CE31E6A")
interface IZoneIdentifier2 : IZoneIdentifier
{
    HRESULT GetLastWriterPackageFamilyName(ushort** packageFamilyName);
    HRESULT SetLastWriterPackageFamilyName(const(wchar)* packageFamilyName);
    HRESULT RemoveLastWriterPackageFamilyName();
    HRESULT GetAppZoneId(uint* zone);
    HRESULT SetAppZoneId(uint zone);
    HRESULT RemoveAppZoneId();
}

@GUID("3AF280B6-CB3F-11D0-891E-00C04FB6BFC4")
interface IInternetHostSecurityManager : IUnknown
{
    HRESULT GetSecurityId(char* pbSecurityId, uint* pcbSecurityId, size_t dwReserved);
    HRESULT ProcessUrlAction(uint dwAction, char* pPolicy, uint cbPolicy, char* pContext, uint cbContext, 
                             uint dwFlags, uint dwReserved);
    HRESULT QueryCustomPolicy(const(GUID)* guidKey, char* ppPolicy, uint* pcbPolicy, char* pContext, 
                              uint cbContext, uint dwReserved);
}

@GUID("79EAC9EF-BAF9-11CE-8C82-00AA004BA90B")
interface IInternetZoneManager : IUnknown
{
    HRESULT GetZoneAttributes(uint dwZone, ZONEATTRIBUTES* pZoneAttributes);
    HRESULT SetZoneAttributes(uint dwZone, ZONEATTRIBUTES* pZoneAttributes);
    HRESULT GetZoneCustomPolicy(uint dwZone, const(GUID)* guidKey, ubyte** ppPolicy, uint* pcbPolicy, 
                                URLZONEREG urlZoneReg);
    HRESULT SetZoneCustomPolicy(uint dwZone, const(GUID)* guidKey, char* pPolicy, uint cbPolicy, 
                                URLZONEREG urlZoneReg);
    HRESULT GetZoneActionPolicy(uint dwZone, uint dwAction, char* pPolicy, uint cbPolicy, URLZONEREG urlZoneReg);
    HRESULT SetZoneActionPolicy(uint dwZone, uint dwAction, char* pPolicy, uint cbPolicy, URLZONEREG urlZoneReg);
    HRESULT PromptAction(uint dwAction, HWND hwndParent, const(wchar)* pwszUrl, const(wchar)* pwszText, 
                         uint dwPromptFlags);
    HRESULT LogAction(uint dwAction, const(wchar)* pwszUrl, const(wchar)* pwszText, uint dwLogFlags);
    HRESULT CreateZoneEnumerator(uint* pdwEnum, uint* pdwCount, uint dwFlags);
    HRESULT GetZoneAt(uint dwEnum, uint dwIndex, uint* pdwZone);
    HRESULT DestroyZoneEnumerator(uint dwEnum);
    HRESULT CopyTemplatePoliciesToZone(uint dwTemplate, uint dwZone, uint dwReserved);
}

@GUID("A4C23339-8E06-431E-9BF4-7E711C085648")
interface IInternetZoneManagerEx : IInternetZoneManager
{
    HRESULT GetZoneActionPolicyEx(uint dwZone, uint dwAction, char* pPolicy, uint cbPolicy, URLZONEREG urlZoneReg, 
                                  uint dwFlags);
    HRESULT SetZoneActionPolicyEx(uint dwZone, uint dwAction, char* pPolicy, uint cbPolicy, URLZONEREG urlZoneReg, 
                                  uint dwFlags);
}

@GUID("EDC17559-DD5D-4846-8EEF-8BECBA5A4ABF")
interface IInternetZoneManagerEx2 : IInternetZoneManagerEx
{
    HRESULT GetZoneAttributesEx(uint dwZone, ZONEATTRIBUTES* pZoneAttributes, uint dwFlags);
    HRESULT GetZoneSecurityState(uint dwZoneIndex, BOOL fRespectPolicy, uint* pdwState, int* pfPolicyEncountered);
    HRESULT GetIESecurityState(BOOL fRespectPolicy, uint* pdwState, int* pfPolicyEncountered, BOOL fNoCache);
    HRESULT FixUnsecureSettings();
}

@GUID("B15B8DC1-C7E1-11D0-8680-00AA00BDCB71")
interface ISoftDistExt : IUnknown
{
    HRESULT ProcessSoftDist(const(wchar)* szCDFURL, IXMLElement pSoftDistElement, SOFTDISTINFO* lpsdi);
    HRESULT GetFirstCodeBase(ushort** szCodeBase, uint* dwMaxSize);
    HRESULT GetNextCodeBase(ushort** szCodeBase, uint* dwMaxSize);
    HRESULT AsyncInstallDistributionUnit(IBindCtx pbc, void* pvReserved, uint flags, CODEBASEHOLD* lpcbh);
}

@GUID("711C7600-6B48-11D1-B403-00AA00B92AF1")
interface ICatalogFileInfo : IUnknown
{
    HRESULT GetCatalogFile(byte** ppszCatalogFile);
    HRESULT GetJavaTrust(void** ppJavaTrust);
}

@GUID("69D14C80-C18E-11D0-A9CE-006097942311")
interface IDataFilter : IUnknown
{
    HRESULT DoEncode(uint dwFlags, int lInBufferSize, char* pbInBuffer, int lOutBufferSize, char* pbOutBuffer, 
                     int lInBytesAvailable, int* plInBytesRead, int* plOutBytesWritten, uint dwReserved);
    HRESULT DoDecode(uint dwFlags, int lInBufferSize, char* pbInBuffer, int lOutBufferSize, char* pbOutBuffer, 
                     int lInBytesAvailable, int* plInBytesRead, int* plOutBytesWritten, uint dwReserved);
    HRESULT SetEncodingLevel(uint dwEncLevel);
}

@GUID("70BDDE00-C18E-11D0-A9CE-006097942311")
interface IEncodingFilterFactory : IUnknown
{
    HRESULT FindBestFilter(const(wchar)* pwzCodeIn, const(wchar)* pwzCodeOut, DATAINFO info, IDataFilter* ppDF);
    HRESULT GetDefaultFilter(const(wchar)* pwzCodeIn, const(wchar)* pwzCodeOut, IDataFilter* ppDF);
}

@GUID("53C84785-8425-4DC5-971B-E58D9C19F9B6")
interface IWrappedProtocol : IUnknown
{
    HRESULT GetWrapperCode(int* pnCode, size_t dwReserved);
}

@GUID("AF0FF408-129D-4B20-91F0-02BD23D88352")
interface IGetBindHandle : IUnknown
{
    HRESULT GetBindHandle(BINDHANDLETYPES enumRequestedHandle, HANDLE* pRetHandle);
}

@GUID("11C81BC2-121E-4ED5-B9C4-B430BD54F2C0")
interface IBindCallbackRedirect : IUnknown
{
    HRESULT Redirect(const(wchar)* lpcUrl, short* vbCancel);
}

@GUID("A9EDA967-F50E-4A33-B358-206F6EF3086D")
interface IBindHttpSecurity : IUnknown
{
    HRESULT GetIgnoreCertMask(uint* pdwIgnoreCertMask);
}

///Enumerates the current connections for a connectable object.
@GUID("B196B287-BAB4-101A-B69C-00AA00341D07")
interface IEnumConnections : IUnknown
{
    ///Retrieves the specified number of items in the enumeration sequence.
    ///Params:
    ///    cConnections = The number of items to be retrieved. If there are fewer than the requested number of items left in the
    ///                   sequence, this method retrieves the remaining elements.
    ///    rgcd = An array of enumerated items. The enumerator is responsible for allocating any memory, and the caller is
    ///           responsible for freeing it. If <i>celt</i> is greater than 1, the caller must also pass a non-NULL pointer
    ///           passed to <i>pceltFetched</i> to know how many pointers to release.
    ///    pcFetched = The number of items that were retrieved. This parameter is always less than or equal to the number of items
    ///                requested.
    ///Returns:
    ///    If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Next(uint cConnections, CONNECTDATA* rgcd, uint* pcFetched);
    ///Skips over the specified number of items in the enumeration sequence.
    ///Params:
    ///    cConnections = The number of items to be skipped.
    ///Returns:
    ///    If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Skip(uint cConnections);
    ///Resets the enumeration sequence to the beginning.
    ///Returns:
    ///    The return value is S_OK.
    ///    
    HRESULT Reset();
    ///Creates a new enumerator that contains the same enumeration state as the current one. This method makes it
    ///possible to record a point in the enumeration sequence in order to return to that point at a later time. The
    ///caller must release this new enumerator separately from the first enumerator.
    ///Params:
    ///    ppEnum = A pointer to the cloned enumerator object.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.
    ///    
    HRESULT Clone(IEnumConnections* ppEnum);
}

///Supports connection points for connectable objects.
@GUID("B196B286-BAB4-101A-B69C-00AA00341D07")
interface IConnectionPoint : IUnknown
{
    ///Retrieves the IID of the outgoing interface managed by this connection point.
    ///Params:
    ///    pIID = A pointer to the identifier of the outgoing interface managed by this connection point.
    ///Returns:
    ///    This method can return the standard return value E_UNEXPECTED, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The caller's variable <i>pIID</i> contains the identifier of the outgoing interface managed
    ///    by this connection point. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The address in <i>pIID</i> is not valid. For example, it may be <b>NULL</b>. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetConnectionInterface(GUID* pIID);
    ///Retrieves the IConnectionPointContainer interface pointer for the parent connectable object.
    ///Params:
    ///    ppCPC = A pointer to an IConnectionPointContainer interface pointer.
    ///Returns:
    ///    This method can return the standard return value E_UNEXPECTED, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The IConnectionPointContainer pointer was successfully returned. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The value in <i>ppCPC</i> is not a
    ///    valid interface pointer. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT GetConnectionPointContainer(IConnectionPointContainer* ppCPC);
    ///Establishes a connection between a connection point object and the client's sink.
    ///Params:
    ///    pUnkSink = A pointer to the IUnknown interface on the client's advise sink. The client's sink receives outgoing calls
    ///               from the connection point.
    ///    pdwCookie = A pointer to a returned token that uniquely identifies this connection. The caller uses this token later to
    ///                delete the connection by passing it to the IConnectionPoint::Unadvise method. If the connection was not
    ///                successfully established, this value is zero.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The connection has been established and *<i>pdwCookie</i>
    ///    has the connection token. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The value in <i>pUnkSink</i> or <i>pdwCookie</i> is not valid. For example, either pointer may
    ///    be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CONNECT_E_ADVISELIMIT</b></dt> </dl> </td> <td
    ///    width="60%"> The connection point has already reached its limit of connections and cannot accept any more.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CONNECT_E_CANNOTCONNECT</b></dt> </dl> </td> <td width="60%">
    ///    The sink does not support the interface required by this connection point. </td> </tr> </table>
    ///    
    HRESULT Advise(IUnknown pUnkSink, uint* pdwCookie);
    ///Terminates an advisory connection previously established between a connection point object and a client's sink.
    ///Params:
    ///    dwCookie = A connection token previously returned from IConnectionPoint::Advise.
    ///Returns:
    ///    This method can return the standard return values E_UNEXPECTED, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The connection was terminated successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The value in <i>dwCookie</i> does not represent a
    ///    valid connection. </td> </tr> </table>
    ///    
    HRESULT Unadvise(uint dwCookie);
    ///Creates an enumerator object to iterate through the current connections for this connection point.
    ///Params:
    ///    ppEnum = A pointer to an IEnumConnections interface pointer that receives the newly created enumerator.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The enumerator object was created successfully. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in
    ///    <i>ppEnum</i> is not valid. For example, it may be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The connection point does not support enumeration.
    ///    </td> </tr> </table>
    ///    
    HRESULT EnumConnections(IEnumConnections* ppEnum);
}

///Enumerates connection points.
@GUID("B196B285-BAB4-101A-B69C-00AA00341D07")
interface IEnumConnectionPoints : IUnknown
{
    ///Retrieves the specified number of items in the enumeration sequence.
    ///Params:
    ///    cConnections = The number of items to be retrieved. If there are fewer than the requested number of items left in the
    ///                   sequence, this method retrieves the remaining elements.
    ///    ppCP = An array of enumerated items. The enumerator is responsible for calling AddRef, and the caller is responsible
    ///           for calling Release through each pointer enumerated. If <i>cConnections</i> is greater than 1, the caller
    ///           must also pass a non-NULL pointer passed to <i>lpcFetched</i> to know how many pointers to release.
    ///    pcFetched = The number of items that were retrieved. This parameter is always less than or equal to the number of items
    ///                requested.
    ///Returns:
    ///    If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Next(uint cConnections, IConnectionPoint* ppCP, uint* pcFetched);
    ///Skips over the specified number of items in the enumeration sequence.
    ///Params:
    ///    cConnections = The number of items to be skipped.
    ///Returns:
    ///    If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Skip(uint cConnections);
    ///Resets the enumeration sequence to the beginning.
    ///Returns:
    ///    The return value is S_OK.
    ///    
    HRESULT Reset();
    ///Creates a new enumerator that contains the same enumeration state as the current one. This method makes it
    ///possible to record a point in the enumeration sequence in order to return to that point at a later time. The
    ///caller must release this new enumerator separately from the first enumerator.
    ///Params:
    ///    ppEnum = A pointer to the cloned enumerator object.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.
    ///    
    HRESULT Clone(IEnumConnectionPoints* ppEnum);
}

///Supports connection points for connectable objects.
@GUID("B196B284-BAB4-101A-B69C-00AA00341D07")
interface IConnectionPointContainer : IUnknown
{
    ///Creates an enumerator object to iterate through all the connection points supported in the connectable object,
    ///one connection point per outgoing IID.
    ///Params:
    ///    ppEnum = A pointer to an IEnumConnectionPoints interface pointer variable that receives the pointer to the newly
    ///             created enumerator.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The enumerator object was created successfully. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in
    ///    <i>ppEnum</i> is not valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT EnumConnectionPoints(IEnumConnectionPoints* ppEnum);
    ///Returns a pointer to the IConnectionPoint interface of a connection point for a specified IID, if that IID
    ///describes a supported outgoing interface.
    ///Params:
    ///    riid = Interface identifier of the outgoing interface whose connection point object is being requested.
    ///    ppCP = The address of an IConnectionPoint interface pointer variable that receives the pointer to the connection
    ///           point that supports the <i>riid</i> interface. If an error occurs, the implementation sets the value to
    ///           <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in <i>ppCP</i> is not
    ///    valid. For example, it may be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CONNECT_E_NOCONNECTION</b></dt> </dl> </td> <td width="60%"> This connectable object does not support
    ///    the outgoing interface specified by <i>riid</i>. </td> </tr> </table>
    ///    
    HRESULT FindConnectionPoint(const(GUID)* riid, IConnectionPoint* ppCP);
}

///Enables a class factory object, in any sort of object server, to control object creation through licensing. This
///interface is an extension to IClassFactory. This extension enables a class factory executing on a licensed machine to
///provide a license key that can be used later to create an object instance on an unlicensed machine. Such
///considerations are important for objects like controls that are used to build applications on a licensed machine.
///Subsequently, the application built must be able to run on an unlicensed machine. The license key gives only that one
///client application the right to instantiate objects through <b>IClassFactory2</b> when a full machine license does
///not exist.
@GUID("B196B28F-BAB4-101A-B69C-00AA00341D07")
interface IClassFactory2 : IClassFactory
{
    ///Retrieves information about the licensing capabilities of this class factory.
    ///Params:
    ///    pLicInfo = A pointer to the caller-allocated LICINFO structure to be filled on output.
    ///Returns:
    ///    This method can return the standard return values E_UNEXPECTED, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The LICINFO structure was successfully filled in. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in <i>pLicInfo</i> is not valid. For
    ///    example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT GetLicInfo(LICINFO* pLicInfo);
    ///Creates a license key that the caller can save and use later to create an instance of the licensed object.
    ///Params:
    ///    dwReserved = This parameter is reserved and must be zero.
    ///    pBstrKey = A pointer to the caller-allocated variable that receives the callee-allocated license key on successful
    ///               return from this method. This parameter is set to <b>NULL</b> on any failure.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as
    ///    the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The license key was successfully created. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This class factory does not
    ///    support run-time license keys. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> The address passed in <i>pbstrKey</i> is not valid. For example, it may be <b>NULL</b>.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CLASS_E_NOTLICENSED</b></dt> </dl> </td> <td width="60%"> This
    ///    class factory supports run-time licensing, but the current machine itself is not licensed. Thus, a run-time
    ///    key is not available on this machine. </td> </tr> </table>
    ///    
    HRESULT RequestLicKey(uint dwReserved, BSTR* pBstrKey);
    ///Creates an instance of the licensed object for the specified license key. This method is the only possible means
    ///to create an object on an otherwise unlicensed machine.
    ///Params:
    ///    pUnkOuter = A pointer to the controlling IUnknown interface on the outer unknown if this object is being created as part
    ///                of an aggregate. If the object is not part of an aggregate, this parameter must be <b>NULL</b>.
    ///    pUnkReserved = This parameter is unused and must be <b>NULL</b>.
    ///    riid = A reference to the identifier of the interface to be used to communicate with the newly created object.
    ///    bstrKey = Run-time license key previously obtained from IClassFactory2::RequestLicKey that is required to create an
    ///              object.
    ///    ppvObj = Address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful
    ///             return, *<i>ppvObj</i> contains the requested interface pointer. If an error occurs, the implementation must
    ///             set *<i>ppvObj</i> to <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as
    ///    the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The license was successfully created. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not implemented
    ///    because objects can only be created on fully licensed machines through IClassFactory::CreateInstance. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> A pointer passed in
    ///    <i>bstrKey</i> or <i>ppvObj</i> is not valid. For example, it may be <b>NULL</b>. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The object can be created (and
    ///    the license key is valid) except the object does not support the interface specified by <i>riid</i>. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>CLASS_E_NOAGGREGATION</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>pUnkOuter</i> parameter is non-<b>NULL</b>, but this object class does not support aggregation. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>CLASS_E_NOTLICENSED</b></dt> </dl> </td> <td width="60%"> The key
    ///    provided in <i>bstrKey</i> is not a valid license key. </td> </tr> </table>
    ///    
    HRESULT CreateInstanceLic(IUnknown pUnkOuter, IUnknown pUnkReserved, const(GUID)* riid, BSTR bstrKey, 
                              void** ppvObj);
}

///Provides access to the type information for an object's coclass entry in its type library.
@GUID("B196B283-BAB4-101A-B69C-00AA00341D07")
interface IProvideClassInfo : IUnknown
{
    HRESULT GetClassInfoA(ITypeInfo* ppTI);
}

///An extension to IProvideClassInfo that makes is faster and easier to retrieve an object's outgoing interface IID for
///its default event set.
@GUID("A6BC3AC0-DBAA-11CE-9DE3-00AA004BB851")
interface IProvideClassInfo2 : IProvideClassInfo
{
    ///Retrieves the specified GUID for the object.
    ///Params:
    ///    dwGuidKind = The GUID type. Possible values are from the GUIDKIND enumeration.
    ///    pGUID = A pointer to a variable that receives the GUID.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_UNEXPECTED, E_POINTER, and S_OK.
    ///    
    HRESULT GetGUID(uint dwGuidKind, GUID* pGUID);
}

///An extension to IProvideClassInfo2 that makes it faster and easier to retrieve type information from a component that
///may have multiple coclasses that determine its behavior.
@GUID("A7ABA9C1-8983-11CF-8F20-00805F2CD064")
interface IProvideMultipleClassInfo : IProvideClassInfo2
{
    ///Retrieves the number of type information blocks that this object must provide.
    ///Params:
    ///    pcti = The number of type information blocks that this object must provide.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_POINTER, E_FAIL, and S_OK.
    ///    
    HRESULT GetMultiTypeInfoCount(uint* pcti);
    ///Retrieves the type information from the specified index.
    ///Params:
    ///    iti = The index of the type information for which you want to obtain information. Index 0 is the default interface
    ///          of the extender object; index *pcti-1 is the index of the base object.
    ///    dwFlags = A bitfield indicating which out parameters are being requested. Indicating a particular flag results in the
    ///              appropriate information being assigned to the associated out parameter. This parameter can be one of the
    ///              following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///              id="MULTICLASSINFO_GETTYPEINFO"></a><a id="multiclassinfo_gettypeinfo"></a><dl>
    ///              <dt><b>MULTICLASSINFO_GETTYPEINFO</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Indicates a
    ///              request for <i>pptiCoClass</i> information. </td> </tr> <tr> <td width="40%"><a
    ///              id="MULTICLASSINFO_GETNUMRESERVEDDISPIDS"></a><a id="multiclassinfo_getnumreserveddispids"></a><dl>
    ///              <dt><b>MULTICLASSINFO_GETNUMRESERVEDDISPIDS</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%">
    ///              Indicates a request for <i>pcdispidReserved</i> and <i>pdwTIFlags</i> information. </td> </tr> <tr> <td
    ///              width="40%"><a id="MULTICLASSINFO_GETIIDPRIMARY"></a><a id="multiclassinfo_getiidprimary"></a><dl>
    ///              <dt><b>MULTICLASSINFO_GETIIDPRIMARY</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Indicates a
    ///              request for <i>piidPrimary</i> information. </td> </tr> <tr> <td width="40%"><a
    ///              id="MULTICLASSINFO_GETIIDSOURCE"></a><a id="multiclassinfo_getiidsource"></a><dl>
    ///              <dt><b>MULTICLASSINFO_GETIIDSOURCE</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> Indicates a
    ///              request for <i>piidSource</i> information. </td> </tr> </table>
    ///    pptiCoClass = The coclass type information for the requested contributor. See ITypeInfo.
    ///    pdwTIFlags = The bitfield flag.
    ///    pcdispidReserved = The mumber of DISPIDs the default interface of <i>pptiCoClass</i> reserves for its own use. This number can
    ///                       be used to calculate the amount to offset DISPIDs in the reserved range implemented by the object this class
    ///                       is extending.
    ///    piidPrimary = The IID of the primary interface for the requested contributor.
    ///    piidSource = The IID of the default source interface for the requested contributor.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_POINTER, E_FAIL, and S_OK.
    ///    
    HRESULT GetInfoOfIndex(uint iti, uint dwFlags, ITypeInfo* pptiCoClass, uint* pdwTIFlags, 
                           uint* pcdispidReserved, GUID* piidPrimary, GUID* piidSource);
}

///Provides the features for supporting keyboard mnemonics, ambient properties, and events in control objects.
@GUID("B196B288-BAB4-101A-B69C-00AA00341D07")
interface IOleControl : IUnknown
{
    ///Retrieves information about the control's keyboard mnemonics and behavior.
    ///Params:
    ///    pCI = A pointer to a CONTROLINFO structure that receives the information.
    ///Returns:
    ///    This method can return the standard return value E_OUTOFMEMORY, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method completed succesfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The control has no mnemonics. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in <i>pCI</i> is not
    ///    valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT GetControlInfo(CONTROLINFO* pCI);
    ///Informs a control that the user has pressed a keystroke that represents a keyboard mneumonic.
    ///Params:
    ///    pMsg = A pointer to the MSG structure describing the keystroke to be processed.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The control does not handle
    ///    mnemonics. This indicates an unexpected condition and a caller error. For example, the caller has mismatched
    ///    which control has which mnemonic. </td> </tr> </table>
    ///    
    HRESULT OnMnemonic(MSG* pMsg);
    ///Informs a control that one or more of the container's ambient properties has changed.
    ///Params:
    ///    dispID = The dispatch identifier of the ambient property that changed. If this parameter is DISPID_UNKNOWN, it
    ///             indicates that multiple properties changed. In this case, the control should check all the ambient properties
    ///             of interest to obtain their current values.
    ///Returns:
    ///    This method returns S_OK in all cases.
    ///    
    HRESULT OnAmbientPropertyChange(int dispID);
    ///Indicates whether the container is ignoring or accepting events from the control.
    ///Params:
    ///    bFreeze = Indicates whether the container will ignore (<b>TRUE</b>) or now process (<b>FALSE</b>) events from the
    ///              control.
    ///Returns:
    ///    This method returns S_OK in all cases.
    ///    
    HRESULT FreezeEvents(BOOL bFreeze);
}

///Provides the methods that enable a site object to manage each embedded control within a container. A site object
///provides <b>IOleControlSite</b> as well as other site interfaces such as IOleClientSite and IOleInPlaceSite. When a
///control requires the services expressed through this interface, it will query one of the other client site interfaces
///for <b>IOleControlSite</b>.
@GUID("B196B289-BAB4-101A-B69C-00AA00341D07")
interface IOleControlSite : IUnknown
{
    ///Informs the container that the control's CONTROLINFO structure has changed and that the container should call the
    ///control's IOleControl::GetControlInfo for an update.
    ///Returns:
    ///    This method returns S_OK in all cases.
    ///    
    HRESULT OnControlInfoChanged();
    ///Indicates whether a control should remain in-place active. Calls to this method typically nest an event to ensure
    ///that the object's activation state remains stable throughout the processing of the event.
    ///Params:
    ///    fLock = Indicates whether to ensure the in-place active state (<b>TRUE</b>) or to allow activation to change
    ///            (<b>FALSE</b>). When <b>TRUE</b>, a supporting container must not deactivate the in-place object until this
    ///            method is called again with <b>FALSE</b>.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The lock or unlock was made
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%">
    ///    The container does not support in-place locking. </td> </tr> </table>
    ///    
    HRESULT LockInPlaceActive(BOOL fLock);
    ///Retrieves an <b>IDispatch</b> pointer to the extended control that the container uses to wrap the real control.
    ///Params:
    ///    ppDisp = A pointer to an <b>IDispatch</b> pointer variable that receives the interface pointer to the extended
    ///             control. If an error occurs, the implementation must set *<i>ppDisp</i> to <b>NULL</b>. On success, the
    ///             caller is responsible for calling Release when *<i>ppDisp</i> is no longer needed.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The container does not implement
    ///    extended controls. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The address in <i>ppDisp</i> or *<i>ppDisp</i> is not valid. For example, it may be <b>NULL</b>.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetExtendedControl(IDispatch* ppDisp);
    ///Converts coordinates expressed in <b>HIMETRIC</b> units (as is standard in OLE) to the units specified by the
    ///container.
    ///Params:
    ///    pPtlHimetric = Address of a POINTL structure containing coordinates expressed in <b>HIMETRIC</b> units. This is an [in]
    ///                   parameter when <i>dwFlags</i> contains XFORMCOORDS_HIMETRICTOCONTAINER; it is an [out] parameter with
    ///                   XFORMCOORDS_CONTAINERTOHIMETRIC. In the latter case, the contents are undefined on error.
    ///    pPtfContainer = Address of a caller-allocated POINTF structure that receives the converted coordinates. This is an [in]
    ///                    parameter when <i>dwFlags</i> contains XFORMCOORDS_CONTAINERTOHIMETRIC; it is an [out] parameter with
    ///                    XFORMCOORDS_HIMETRICTOCONTAINER. In the latter case, the contents are undefined on error.
    ///    dwFlags = Flags indicating the exact conversion to perform. This parameter can be any combination of the following
    ///              values, except as indicated. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///              id="XFORMCOORDS_POSITION"></a><a id="xformcoords_position"></a><dl> <dt><b>XFORMCOORDS_POSITION</b></dt>
    ///              <dt>0x1</dt> </dl> </td> <td width="60%"> The coordinates to convert represent a position point. Cannot be
    ///              used with XFORMCOORDS_SIZE. </td> </tr> <tr> <td width="40%"><a id="XFORMCOORDS_SIZE"></a><a
    ///              id="xformcoords_size"></a><dl> <dt><b>XFORMCOORDS_SIZE</b></dt> <dt>0x2</dt> </dl> </td> <td width="60%"> The
    ///              coordinates to convert represent a set of dimensions. Cannot be used with XFORMCOORDS_POSITION. </td> </tr>
    ///              <tr> <td width="40%"><a id="XFORMCOORDS_HIMETRICTOCONTAINER"></a><a
    ///              id="xformcoords_himetrictocontainer"></a><dl> <dt><b>XFORMCOORDS_HIMETRICTOCONTAINER</b></dt> <dt>0x4</dt>
    ///              </dl> </td> <td width="60%"> The operation converts pptlHimetric into pptfContainer. Cannot be used with
    ///              XFORMCOORDS_CONTAINERTOHIMETRIC. </td> </tr> <tr> <td width="40%"><a
    ///              id="XFORMCOORDS_CONTAINERTOHIMETRIC"></a><a id="xformcoords_containertohimetric"></a><dl>
    ///              <dt><b>XFORMCOORDS_CONTAINERTOHIMETRIC</b></dt> <dt>0x8</dt> </dl> </td> <td width="60%"> The operation
    ///              converts pptfContainer into pptlHimetric. Cannot be used with XFORMCOORDS_HIMETRICTOCONTAINER. </td> </tr>
    ///              <tr> <td width="40%"><a id="XFORMCOORDS_EVENTCOMPAT"></a><a id="xformcoords_eventcompat"></a><dl>
    ///              <dt><b>XFORMCOORDS_EVENTCOMPAT</b></dt> <dt>0x10</dt> </dl> </td> <td width="60%"> The operation maintains
    ///              compatibility with an event. </td> </tr> </table>
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The container does not require any
    ///    special coordinate conversions. The container deals completely in <b>HIMETRIC</b>. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in <i>pPtlHimetric</i>
    ///    or <i>pPtfContainer</i> is not valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT TransformCoords(POINTL* pPtlHimetric, POINTF* pPtfContainer, uint dwFlags);
    HRESULT TranslateAcceleratorA(MSG* pMsg, uint grfModifiers);
    ///Indicates whether the control managed by this control site has gained or lost the focus.
    ///Params:
    ///    fGotFocus = Indicates whether the control gained (TRUE) or lost the focus (FALSE).
    ///Returns:
    ///    This method returns S_OK in all cases.
    ///    
    HRESULT OnFocus(BOOL fGotFocus);
    ///Instructs a container to display a property sheet for the control embedded in this site.
    ///Returns:
    ///    This method can return the standard return value E_OUTOFMEMORY, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The container does not need to show property pages
    ///    itself. </td> </tr> </table>
    ///    
    HRESULT ShowPropertyFrame();
}

///Provides the main features of a property page object that manages a particular page within a property sheet. A
///property page implements at least <b>IPropertyPage</b> and can optionally implement IPropertyPage2 if selection of a
///specific property is supported. See IPerPropertyBrowsing::MapPropertyToPage for more information on specific property
///browsing. The methods of <b>IPropertyPage2</b> enable the property sheet or property frame to instruct the page when
///to perform specific actions, mostly based on user input such as switching between pages or pressing various buttons
///that the frame itself manages in the dialog box. A property page manages a dialog box that contains only those
///controls that should be displayed for that one page within the property sheet itself. This means that the dialog box
///template used to define the page should only carry the WS_CHILD style and no others. It should not include any style
///related to a frame, caption, or system menus or controls.
@GUID("B196B28D-BAB4-101A-B69C-00AA00341D07")
interface IPropertyPage : IUnknown
{
    ///Initializes a property page and provides the page with a pointer to the IPropertyPageSite interface through which
    ///the property page communicates with the property frame.
    ///Params:
    ///    pPageSite = A pointer to the IPropertyPageSite interface of the page site that manages and provides services to this
    ///                property page within the entire property sheet.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.
    ///    
    HRESULT SetPageSite(IPropertyPageSite pPageSite);
    ///Creates the dialog box window for the property page. The dialog box is created without a frame, caption, or
    ///system menu/controls. The text in the dialog should match the locale obtained through
    ///IPropertyPageSite::GetLocaleID.
    ///Params:
    ///    hWndParent = The window handle of the parent of the dialog box that is being created.
    ///    pRect = A pointer to the RECT structure containing the positioning information for the dialog box. This method must
    ///            create its dialog box with the placement and dimensions described by this structure.
    ///    bModal = Indicates whether the dialog box frame is modal (<b>TRUE</b>) or modeless (<b>FALSE</b>).
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in <i>prc</i> is not
    ///    valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT Activate(HWND hWndParent, RECT* pRect, BOOL bModal);
    ///Destroys the window created in IPropertyPage::Activate.
    ///Returns:
    ///    This method can return the standard return values E_UNEXPECTED and S_OK.
    ///    
    HRESULT Deactivate();
    ///Retrieves information about the property page.
    ///Params:
    ///    pPageInfo = A pointer to the caller-allocated PROPPAGEINFO structure in which the property page stores its page
    ///                information. All allocations stored in this structure become the responsibility of the caller.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The structure was successfully filled. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in <i>pPageInfo</i> is
    ///    not valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT GetPageInfo(PROPPAGEINFO* pPageInfo);
    ///Provides the property page with an array of pointers to objects associated with this property page. When the
    ///property page receives a call to IPropertyPage::Apply, it must send value changes to these objects through
    ///whatever interfaces are appropriate. The property page must query for those interfaces. This method can fail if
    ///the objects do not support the interfaces expected by the property page.
    ///Params:
    ///    cObjects = The number of pointers in the array pointed to by <i>ppUnk</i>. If this parameter is 0, the property page
    ///               must release any pointers previously passed to this method.
    ///    ppUnk = A pointer to an array of IUnknown interface pointers where each pointer identifies a unique object affected
    ///            by the property sheet in which this (and possibly other) property pages are displayed. The property page must
    ///            cache these pointers calling AddRef for each pointer at that time. This array of pointers is the same one
    ///            that was passed to OleCreatePropertyFrame or OleCreatePropertyFrameIndirect to invoke the property sheet.
    ///Returns:
    ///    This method can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as
    ///    well as the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The property page successfully saved the
    ///    pointers it needed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td
    ///    width="60%"> One of the objects in <i>ppUnk</i> did not support the interface expected by this property page,
    ///    and so this property page cannot communicate with it. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in <i>ppUnk</i> is not valid. For example,
    ///    it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT SetObjects(uint cObjects, char* ppUnk);
    ///Makes the property page dialog box visible or invisible. If the page is made visible, the page should set the
    ///focus to itself, specifically to the first property on the page.
    ///Params:
    ///    nCmdShow = A command describing whether to become visible (SW_SHOW or SW_SHOWNORMAL) or hidden (SW_HIDE). No other
    ///               values are valid for this parameter.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_UNEXPECTED, and S_OK.
    ///    
    HRESULT Show(uint nCmdShow);
    ///Positions and resizes the property page dialog box within the frame.
    ///Params:
    ///    pRect = A pointer to the RECT structure containing the positioning information for the property page dialog box.
    ///Returns:
    ///    This method can return the standard return value E_UNEXPECTED, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in <i>prc</i> is not valid. For example,
    ///    it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT Move(RECT* pRect);
    ///Indicates whether the property page has changed since it was activated or since the most recent call to Apply.
    ///Returns:
    ///    This method returns S_OK to indicate that the property page has changed. Otherwise, it returns S_FALSE.
    ///    
    HRESULT IsPageDirty();
    ///Applies the current values to the underlying objects associated with the property page as previously passed to
    ///IPropertyPage::SetObjects.
    ///Returns:
    ///    This method can return the standard return values <b>E_OUTOFMEMORY</b> and <b>E_UNEXPECTED</b>, as well as
    ///    the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Changes were successfully applied and the property page is
    ///    current with the underlying objects. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> Changes were applied, but the property page cannot determine if its state is current
    ///    with the objects. </td> </tr> </table>
    ///    
    HRESULT Apply();
    ///Invokes the property page help in response to an end-user request.
    ///Params:
    ///    pszHelpDir = A pointer to the string under the <b>HelpDir</b> key in the property page's CLSID information in the
    ///                 registry. If <b>HelpDir</b> does not exist, this will be the path found in the <b>InprocServer32</b> entry
    ///                 minus the server file name. (Note that <b>LocalServer32</b> is not checked, because local property pages are
    ///                 not supported).
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The page displayed its own help. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Help is either not provided or is
    ///    provided only through the information is PROPPAGEINFO. </td> </tr> </table>
    ///    
    HRESULT Help(ushort* pszHelpDir);
    HRESULT TranslateAcceleratorA(MSG* pMsg);
}

///An extension to IPropertyPage to support initial selection of a property on a page. This method works in conjunction
///with the implementation of IPerPropertyBrowsing::MapPropertyToPage on an object that supplies properties and
///specifies property pages through ISpecifyPropertyPages. This interface has only one extra method in addition to those
///in IPropertyPage. That method, IPropertyPage2::EditProperty tells the page which property to highlight.
@GUID("01E44665-24AC-101B-84ED-08002B2EC713")
interface IPropertyPage2 : IPropertyPage
{
    ///Specifies which field is to receive the focus when the property page is activated.
    ///Params:
    ///    dispID = The property that is to receive the focus.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%">
    ///    This method is not currently implemented; the interface is probably provided in anticipation of future work
    ///    on this page. </td> </tr> </table>
    ///    
    HRESULT EditProperty(int dispID);
}

///Provides the main features for a property page site object.
@GUID("B196B28C-BAB4-101A-B69C-00AA00341D07")
interface IPropertyPageSite : IUnknown
{
    ///Informs the frame that the property page managed by this site has changed its state, that is, one or more
    ///property values have been changed in the page. Property pages should call this method whenever changes occur in
    ///their dialog boxes.
    ///Params:
    ///    dwFlags = Indicates the changes that have occurred. This parameter can contain one of the following values. <table>
    ///              <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="PROPPAGESTATUS_DIRTY"></a><a
    ///              id="proppagestatus_dirty"></a><dl> <dt><b>PROPPAGESTATUS_DIRTY</b></dt> <dt>0x1</dt> </dl> </td> <td
    ///              width="60%"> The values in the pages have changed, so the state of the <b>Apply</b> button should be updated.
    ///              </td> </tr> <tr> <td width="40%"><a id="PROPPAGESTATUS_VALIDATE"></a><a id="proppagestatus_validate"></a><dl>
    ///              <dt><b>PROPPAGESTATUS_VALIDATE</b></dt> <dt>0x2</dt> </dl> </td> <td width="60%"> Now is an appropriate time
    ///              to apply changes. </td> </tr> </table>
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG and S_OK.
    ///    
    HRESULT OnStatusChange(uint dwFlags);
    ///Retrieves the locale identifier (an LCID) that a property page can use to adjust its locale-specific settings.
    ///Params:
    ///    pLocaleID = A pointer to a variable that receives the locale identifier. See Language Identifier Constants and Strings.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    The address in <i>pLocaleID</i> is not valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT GetLocaleID(uint* pLocaleID);
    ///Retrieves a pointer to the object representing the entire property frame dialog box that contains all the pages.
    ///Calling this method could potentially allow one page to navigate to another. However, there are no container
    ///interfaces defined for this role, so this method always fails in the property frame implementation.
    ///Params:
    ///    ppUnk = A pointer to an IUnknown pointer variable that receives the interface pointer to the container object. If an
    ///            error occurs, the implementation must set *<i>ppUnk</i> to <b>NULL</b>.
    ///Returns:
    ///    This method returns E_NOTIMPL.
    ///    
    HRESULT GetPageContainer(IUnknown* ppUnk);
    HRESULT TranslateAcceleratorA(MSG* pMsg);
}

///Implemented by a sink object to receive notifications about property changes from an object that supports
///<b>IPropertyNotifySink</b> as an outgoing interface. The client that needs to receive the notifications in this
///interface (from a supporting connectable object) creates a sink with this interface and connects it to the
///connectable object through the connection point mechanism. For more information on connection points, see
///IConnectionPointContainer.
@GUID("9BFBBC02-EFF1-101A-84ED-00AA00341D07")
interface IPropertyNotifySink : IUnknown
{
    ///Notifies a sink that a bindable property has changed.
    ///Params:
    ///    dispID = The dispatch identifier of the property that changed, or DISPID_UNKNOWN if multiple properties have changed.
    ///             The client (owner of the sink) should retrieve the current value of each property of interest from the object
    ///             that generated the notification.
    ///Returns:
    ///    This method returns S_OK in all cases.
    ///    
    HRESULT OnChanged(int dispID);
    ///Notifies a sink that a requestedit property is about to change.
    ///Params:
    ///    dispID = The dispatch identifier of the property that is about to change or DISPID_UNKNOWN if multiple properties are
    ///             about to change.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The specified property or
    ///    properties are allowed to change. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td>
    ///    <td width="60%"> The specified property or properties are not allowed to change. The caller must obey this
    ///    return value by discarding the new property value(s). This is part of the contract of the [requestedit]
    ///    attribute and this method. </td> </tr> </table>
    ///    
    HRESULT OnRequestEdit(int dispID);
}

///Indicates that an object supports property pages. OLE property pages enable an object to display its properties in a
///tabbed dialog box known as a <i>property sheet</i>. An end user can then view and change the object's properties. An
///object can display its property pages independent of its client, or the client can manage the display of property
///pages from a number of contained objects in a single property sheet. Property pages also provide a means for
///notifying a client of changes in an object's properties.
@GUID("B196B28B-BAB4-101A-B69C-00AA00341D07")
interface ISpecifyPropertyPages : IUnknown
{
    ///Retrieves a list of property pages that can be displayed in this object's property sheet.
    ///Params:
    ///    pPages = A pointer to a caller-allocated CAUUID structure that must be initialized and filled before returning. The
    ///             <b>pElems</b> member in the structure is allocated by the callee with CoTaskMemAlloc and freed by the caller
    ///             with CoTaskMemFree.
    ///Returns:
    ///    This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed succesfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in <i>pPages</i> is not
    ///    valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT GetPages(CAUUID* pPages);
}

@GUID("BD1AE5E0-A6AE-11CE-BD37-504200C10000")
interface IPersistMemory : IPersist
{
    HRESULT IsDirty();
    HRESULT Load(void* pMem, uint cbSize);
    HRESULT Save(void* pMem, BOOL fClearDirty, uint cbSize);
    HRESULT GetSizeMax(uint* pCbSize);
    HRESULT InitNew();
}

///A replacement for IPersistStream that adds an initialization method. This interface is not derived from
///IPersistStream; it is mutually exclusive with <b>IPersistStream</b>. An object chooses to support only one of the two
///interfaces, based on whether it requires the InitNew method.
@GUID("7FD52380-4E07-101B-AE2D-08002B2EC713")
interface IPersistStreamInit : IPersist
{
    ///Determines whether an object has changed since it was last saved to its stream.
    ///Returns:
    ///    This method returns S_OK to indicate that the object has changed. Otherwise, it returns S_FALSE.
    ///    
    HRESULT IsDirty();
    ///Initializes an object from the stream where it was saved previously.
    ///Params:
    ///    pStm = An IStream pointer to the stream from which the object should be loaded.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The object was not loaded due to lack of memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The object was not loaded due to some reason other than a
    ///    lack of memory. </td> </tr> </table>
    ///    
    HRESULT Load(IStream pStm);
    ///Saves an object to the specified stream.
    ///Params:
    ///    pStm = An IStream pointer to the stream into which the object should be saved.
    ///    fClearDirty = Indicates whether to clear the dirty flag after the save is complete. If <b>TRUE</b>, the flag should be
    ///                  cleared. If <b>FALSE</b>, the flag should be left unchanged.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>STG_E_CANTSAVE</b></dt> </dl> </td> <td
    ///    width="60%"> The object could not save itself to the stream. This error could indicate, for example, that the
    ///    object contains another object that is not serializable to a stream or that an ISequentialStream::Write call
    ///    returned STG_E_CANTSAVE. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>STG_E_MEDIUMFULL</b></dt> </dl> </td>
    ///    <td width="60%"> The object could not be saved because there is no space left on the storage device. </td>
    ///    </tr> </table>
    ///    
    HRESULT Save(IStream pStm, BOOL fClearDirty);
    ///Retrieves the size of the stream needed to save the object.
    ///Params:
    ///    pCbSize = The size in bytes of the stream needed to save this object, in bytes.
    ///Returns:
    ///    This method returns S_OK to indicate that the size was retrieved successfully.
    ///    
    HRESULT GetSizeMax(ULARGE_INTEGER* pCbSize);
    ///Initializes an object to a default state. This method is to be called instead of IPersistStreamInit::Load.
    ///Returns:
    ///    This method can return the standard return valuesE_OUTOFMEMORY and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The object requires no default
    ///    initialization. This error code is allowed because an object may choose to implement IPersistStreamInit
    ///    simply for orthogonality or in anticipation of a future need for this method. </td> </tr> </table>
    ///    
    HRESULT InitNew();
}

@GUID("37D84F60-42CB-11CE-8135-00AA004BB851")
interface IPersistPropertyBag : IPersist
{
    HRESULT InitNew();
    HRESULT Load(IPropertyBag pPropBag, IErrorLog pErrorLog);
    HRESULT Save(IPropertyBag pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
}

///Provides simple frame controls that act as simple containers for other nested controls. Some controls merely contain
///other controls. In such cases, the simple control container, called a simple frame, need not implement all container
///requirements. It can delegate most of the interface calls from its contained controls to the outer container that
///manages the simple frame. To support what are called simple frame controls, a container implements this interface as
///well as other site interfaces such as IOleControlSite. An example of a simple frame control is a group box that only
///needs to capture a few keystrokes for its contained controls to implement the correct tab or arrow key behavior, but
///does not want to handle every other message. Through the two methods of this interface, the simple frame control
///passes messages to its control site both before and after its own processing. If that site is itself a simple frame,
///it can continue to pass messages up the chain.
@GUID("742B0E01-14E6-101B-914E-00AA00300CAB")
interface ISimpleFrameSite : IUnknown
{
    ///Provides a site with the opportunity to process a message that is received by a control's own window before the
    ///control itself does any processing.
    ///Params:
    ///    hWnd = A handle of the control window receiving the message.
    ///    msg = The message received by the simple frame site.
    ///    wp = The <b>WPARAM</b> of the message.
    ///    lp = The <b>LPARAM</b> of the message.
    ///    plResult = A pointer to the variable that receives the result of the message processing.
    ///    pdwCookie = A pointer to the variable that will be passed to ISimpleFrameSite::PostMessageFilter if it is called later.
    ///                This parameter should only contain allocated data if this method returns S_OK so it will also receive a call
    ///                to <b>PostMessageFilter</b> which can free the allocation. The caller is not in any way responsible for
    ///                anything returned in this parameter.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The simple frame site will not
    ///    use the message in this filter so more processing can take place. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The site has processed the message and no further
    ///    processing should occur. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> The site does not do any message filtering, indicating that PostMessageFilter need not be called
    ///    later. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    address in <i>plResult</i> or <i>pdwCookie</i> is not valid. </td> </tr> </table>
    ///    
    HRESULT PreMessageFilter(HWND hWnd, uint msg, WPARAM wp, LPARAM lp, LRESULT* plResult, uint* pdwCookie);
    ///Sends the simple frame site a message that is received by a control's own window after the control has processed
    ///the message.
    ///Params:
    ///    hWnd = A handle of the control window receiving the message.
    ///    msg = The message received by the simple frame site.
    ///    wp = The <b>WPARAM</b> of the message.
    ///    lp = The <b>LPARAM</b> of the message.
    ///    plResult = A pointer to the variable that receives the result of the message processing.
    ///    dwCookie = The value that was returned by ISimpleFrameSite::PreMessageFilter through its <i>pdwCookie</i> parameter.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The site processed the message.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The site did not
    ///    process the message. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> The site does not filter any messages. </td> </tr> </table>
    ///    
    HRESULT PostMessageFilter(HWND hWnd, uint msg, WPARAM wp, LPARAM lp, LRESULT* plResult, uint dwCookie);
}

///Provides a wrapper around a Windows font object. The COM font object supports a number of read/write properties as
///well as a set of methods through its <b>IFont</b> interface. It supports the same set of properties (but not the
///methods) through the dispatch interface IFontDisp, which is derived from <b>IDispatch</b> to provide access to the
///font's properties through Automation. The system provides a standard implementation of the font object with both
///interfaces. The font object also supports the outgoing interface IPropertyNotifySink so a client can determine when
///font properties change. Because the font object supports at least one outgoing interface, it also implements
///IConnectionPointContainer and related interfaces for this purpose. The font object provides an hFont property, which
///is a Windows font handle that conforms to the other attributes specified for the font. The font object delays
///realizing this hFont object when possible, so consecutively setting two properties on a font will not cause an
///intermediate font to be realized. In addition, as an optimization, the system-implemented font object maintains a
///cache of font handles. Two font objects in the same process that have identical properties will return the same font
///handle. The font object can remove font handles from this cache at will, which introduces special considerations for
///clients using the hFont property. The font object also supports IPersistStream so that it can save and load itself
///from an instance of IStream. An object that uses a font object internally would normally save and load the font as
///part of the object's own persistence handling. In addition, the font object supports IDataObject, which can render a
///property set containing the font's attributes, allowing a client to save these properties as text.
@GUID("BEF6E002-A874-101A-8BBA-00AA00300CAB")
interface IFont : IUnknown
{
    ///Retrieves the name of the font family.
    ///Params:
    ///    pName = A pointer to the caller-allocated variable that receives the name. This string must be freed with
    ///            <b>SysFreeString</b> when it is no longer needed.
    ///Returns:
    ///    The method supports the standard return value <b>E_UNEXPECTED</b>, as well as the following values. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The name was returned successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in the <i>pname</i> parameter is not
    ///    valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT get_Name(BSTR* pName);
    ///Specifies a new name for the font family.
    ///Params:
    ///    name = The new name of the font family. This value is both allocated and freed by the caller.
    ///Returns:
    ///    The method supports the standard return value <b>E_UNEXPECTED</b>, as well as the following values. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The name was changed successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in the <i>name</i> parameter is not valid.
    ///    For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT put_Name(BSTR name);
    ///Retrieves the point size of the font.
    ///Params:
    ///    pSize = A pointer to the caller-allocated variable that receives the size, in <b>HIMETRIC</b> units.
    ///Returns:
    ///    The method supports the standard return value <b>E_UNEXPECTED</b>, as well as the following values. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The size was retrieved successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in the <i>pSize</i> parameter is not
    ///    valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT get_Size(CY* pSize);
    ///Sets the point size of the font.
    ///Params:
    ///    size = The new size of the font, in <b>HIMETRIC</b> units.
    ///Returns:
    ///    The method supports the standard return value <b>E_UNEXPECTED</b>, as well as the following values. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The font was resized successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The value of the <i>size</i> parameter is not valid.
    ///    For example, it does not contain a usable font size. </td> </tr> </table>
    ///    
    HRESULT put_Size(CY size);
    ///Gets the font's current Bold property.
    ///Params:
    ///    pBold = A pointer to a caller-allocated variable that receives the current Bold property for the font.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK </b></dt> </dl> </td> <td width="60%"> The state was retrieved
    ///    successfully. If the state is indeterminate, a font object should set *<i>pBold</i> to <b>FALSE</b> and
    ///    return <b>S_OK</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The address in pBold is not valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT get_Bold(int* pBold);
    ///Sets the font's Bold property.
    ///Params:
    ///    bold = The new Bold property for the font.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The bold state was changed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The
    ///    font does not support a bold state. Note that this is not an error condition. </td> </tr> </table>
    ///    
    HRESULT put_Bold(BOOL bold);
    ///Gets the font's current Italic property.
    ///Params:
    ///    pItalic = A pointer to the caller-allocated variable that receives the current Italic property for the font.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The state was retrieved successfully.
    ///    If the state is indeterminate, a font object should set *<i>pItalic</i> to <b>FALSE</b> and return
    ///    <b>S_OK</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    The address in pitalic is not valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT get_Italic(int* pItalic);
    ///Sets the font's Italic property.
    ///Params:
    ///    italic = The new Italic property for the font.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The italic state was changed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The
    ///    font does not support an italic state. This value is not an error condition. </td> </tr> </table>
    ///    
    HRESULT put_Italic(BOOL italic);
    ///Gets the font's current Underline property..
    ///Params:
    ///    pUnderline = A pointer to the caller-allocated variable that receives the current Underline property for the font.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The state was retrieved successfully.
    ///    If the state is indeterminate, a font object should set *<i>pUnderline</i> to <b>FALSE</b> and return
    ///    <b>S_OK</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    The address in the <i>pUnderline</i> parameter is not valid. For example, it may be <b>NULL</b>. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_Underline(int* pUnderline);
    ///Sets the font's Underline property.
    ///Params:
    ///    underline = The new Underline property for the font.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The underline state was changed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The
    ///    font does not support an underline state. This value is not an error condition. </td> </tr> </table>
    ///    
    HRESULT put_Underline(BOOL underline);
    ///Gets the font's current Strikethrough property.
    ///Params:
    ///    pStrikethrough = A pointer to the caller-allocated variable that receives the current Strikethrough property for the font.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The state was retrieved successfully.
    ///    If the state is indeterminate, a font object should set *<i>pStrikethrough</i> to <b>FALSE</b> and return
    ///    <b>S_OK</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    The address in the <i>pStrikethrough</i> parameter is not valid. For example, it may be <b>NULL</b>. </td>
    ///    </tr> </table>
    ///    
    HRESULT get_Strikethrough(int* pStrikethrough);
    ///Sets the font's Strikethrough property.
    ///Params:
    ///    strikethrough = The new Strikethrough property for the font.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The Strikethrough property was
    ///    changed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> The font does not support a strikethrough state. This value is not an error condition. </td>
    ///    </tr> </table>
    ///    
    HRESULT put_Strikethrough(BOOL strikethrough);
    ///Gets the font's current Weight property.
    ///Params:
    ///    pWeight = A pointer to the caller-allocated variable that receives the current Weight property for the font. For a list
    ///              of possible values, see the <b>lfWeight</b> member of the LOGFONT structure.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b></b></dt> </dl> </td> <td width="60%"> The weight was retrieved successfully. If
    ///    the weight is indeterminate, a font object should store <b>FW_NORMAL</b> in *<i>pWeight</i> and return
    ///    <b>S_OK</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b></b></dt> </dl> </td> <td width="60%"> The address
    ///    in the <i>pWeight</i> parameter is not valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT get_Weight(short* pWeight);
    ///Sets the font's Weight property.
    ///Params:
    ///    weight = The new Weight for the font. For a list of available font weights, see the description of the <b>lfWeight</b>
    ///             member of the LOGFONT structure.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The Weight property was changed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    This font does not support different weights. This value is not an error condition. </td> </tr> </table>
    ///    
    HRESULT put_Weight(short weight);
    ///Retrieves the character set used in the font. The character set can be any of those defined for Windows fonts.
    ///Params:
    ///    pCharset = A pointer to the caller-allocated variable that receives the character set value.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The character set was retrieved
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    The address in the <i>pCharset</i> parameter is not valid. For example, it may be <b>NULL</b>. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_Charset(short* pCharset);
    ///Sets the font's character set.
    ///Params:
    ///    charset = The new character set for the font.
    ///Returns:
    ///    The method supports the standard return value <b>E_INVALIDARG</b> and S_OK.
    ///    
    HRESULT put_Charset(short charset);
    ///Retrieves a handle to the font described by this font object.
    ///Params:
    ///    phFont = A pointer to the caller-allocated variable that receives the font handle. The caller does not own this
    ///             resource and must not attempt to destroy the font.
    ///Returns:
    ///    The method supports the standard return values <b>E_UNEXPECTED</b> and <b>E_OUTOFMEMORY</b>, as well as the
    ///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The font handle was retrieved successfully. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in the
    ///    <i>phFont</i> parameter is not valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT get_hFont(HFONT* phFont);
    ///Creates a duplicate font object with a state identical to the current font.
    ///Params:
    ///    ppFont = Address of IFont pointer variable that receives the interface pointer to the new font object. The caller must
    ///             call IFont::Release when this new font object is no longer needed.
    ///Returns:
    ///    The method supports the standard return values <b>E_UNEXPECTED</b> and <b>E_OUTOFMEMORY</b>, as well as the
    ///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The new font object was successfully created. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This font object does not
    ///    support cloning. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The address in <i>ppfont</i> is not valid. For example, it may be <b>NULL</b>. </td> </tr>
    ///    </table>
    ///    
    HRESULT Clone(IFont* ppFont);
    ///Compares this font object to another for equivalence.
    ///Params:
    ///    pFontOther = A pointer to the IFont interface on the font object to be compared to this font. The reference count of the
    ///                 object referred to by this pointer is not affected by the comparison operation.
    ///Returns:
    ///    The method supports the standard return value <b>E_UNEXPECTED</b>, as well as the following values. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The two fonts are equivalent. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The two fonts are not equivalent. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in the <i>pFontOther</i>
    ///    parameter is not valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT IsEqual(IFont pFontOther);
    ///Converts the scaling factor for this font between logical units and <b>HIMETRIC</b> units. <b>HIMETRIC</b> units
    ///are used to express the point size in the IFont::get_Size and IFont::put_Size methods. The values passed to
    ///<b>IFont::SetRatio</b> are used to compute the display size of the font in logical units from the value in the
    ///<b>Size</b> property: <code>Display Size = ( cyLogical / cyHimetric ) * Size</code>
    ///Params:
    ///    cyLogical = The font size, in logical units.
    ///    cyHimetric = The font size, in <b>HIMETRIC</b> units.
    ///Returns:
    ///    The method supports the standard return values E_UNEXPECTED, E_INVALIDARG, and S_OK.
    ///    
    HRESULT SetRatio(int cyLogical, int cyHimetric);
    ///Fills a caller-allocated structure with information about the font.
    ///Params:
    ///    pTM = Pointer to the caller-allocated structure that receives the font information. The <b>TEXTMETRICOLE</b>
    ///          structure is defined as a TEXTMETRICW structure.
    ///Returns:
    ///    The method supports the standard return value <b>E_UNEXPECTED</b>, as well as the following values. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The text metrics were returned successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in the <i>ptm</i> parameter is not valid.
    ///    For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT QueryTextMetrics(TEXTMETRICW* pTM);
    ///Notifies the font object that the previously realized font identified with <i>hFont</i> should remain valid until
    ///ReleaseHfont is called or the font object itself is released completely.
    ///Params:
    ///    hFont = Font handle previously realized through get_hFont to be locked in the font object's cache.
    ///Returns:
    ///    The method supports the standard return values <b>E_UNEXPECTED</b> and <b>E_INVALIDARG</b>, as well as the
    ///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The font was successfully locked in the cache. </td> </tr>
    ///    </table>
    ///    
    HRESULT AddRefHfont(HFONT hFont);
    ///Notifies the font object that the caller that previously locked this font in the cache with IFont::AddRefHfont no
    ///longer requires the lock.
    ///Params:
    ///    hFont = A font handle previously realized through IFont::get_hFont. This value was passed to a previous call to
    ///            IFont::AddRefHfont to lock the font, and the caller would now like to unlock the font in the cache.
    ///Returns:
    ///    The method supports the standard return values <b>E_UNEXPECTED</b> and <b>E_INVALIDARG</b>, as well as the
    ///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The font was unlocked successfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The font was not locked in the cache.
    ///    This return value is a benign notification to the caller that it may have a font reference counting problem.
    ///    </td> </tr> </table>
    ///    
    HRESULT ReleaseHfont(HFONT hFont);
    ///Provides a device context to the font that describes the logical mapping mode.
    ///Params:
    ///    hDC = A handle to the device context in which to select the font.
    ///Returns:
    ///    The method supports the standard return value <b>E_INVALIDARG</b>, as well as the following values. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl>
    ///    </td> <td width="60%"> The font was selected successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The font selection is not supported through this font
    ///    object. </td> </tr> </table>
    ///    
    HRESULT SetHdc(HDC hDC);
}

///Manages a picture object and its properties. Picture objects provide a language-neutral abstraction for bitmaps,
///icons, and metafiles. As with the standard font object, the system provides a standard implementation of the picture
///object. Its primary interfaces are <b>IPicture</b> and IPictureDisp, the latter being derived from <b>IDispatch</b>
///to provide access to the picture's properties through Automation. A picture object is created with
///OleCreatePictureIndirect. The picture object also supports the outgoing interface IPropertyNotifySink, so a client
///can determine when picture properties change. Because the picture object supports at least one outgoing interface, it
///also implements IConnectionPointContainer and its associated interfaces for this purpose. The picture object also
///supports IPersistStream so that it can save and load itself from an instance of IStream. An object that uses a
///picture object internally would normally save and load the picture as part of the object's own persistence handling.
///The function OleLoadPicture simplifies the creation of a picture object based on stream contents.
@GUID("7BF80980-BF32-101A-8BBB-00AA00300CAB")
interface IPicture : IUnknown
{
    ///Retrieves the handle to the picture managed within this picture object to a specified location.
    ///Params:
    ///    pHandle = A pointer to a variable that receives the handle. The caller is responsible for this handle upon successful
    ///              return. The variable is set to <b>NULL</b> on failure.
    ///Returns:
    ///    This method supports the standard return values E_FAIL and E_OUTOFMEMORY, as well as the following values.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The handle was returned successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The value of <i>phandle</i> is not valid. For example,
    ///    it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT get_Handle(uint* pHandle);
    ///Retrieves a copy of the palette currently used by the picture object.
    ///Params:
    ///    phPal = A pointer to a variable that receives the palette handle. The variable is set to <b>NULL</b> on failure.
    ///Returns:
    ///    This method supports the standard return values E_FAIL and E_OUTOFMEMORY, as well as the following values.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The height was returned successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> This picture has no palette. The variable that
    ///    <i>phpal</i> points to was set to <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The value of <i>phPal</i> is not valid. For example,
    ///    it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT get_hPal(uint* phPal);
    ///Retrieves the current type of the picture contained in the picture object.
    ///Params:
    ///    pType = Pointer to a variable that receives the picture type. The Type property can have any one of the values
    ///            contained in the PICTYPE enumeration.
    ///Returns:
    ///    This method supports the standard return value E_FAIL, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The type was returned successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The value of <i>pType</i> is not valid. For example,
    ///    it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT get_Type(short* pType);
    ///Retrieves the current width of the picture in the picture object.
    ///Params:
    ///    pWidth = A pointer to a variable that receives the width.
    ///Returns:
    ///    This method supports the standard return value E_FAIL, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The width was returned successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The value of <i>pWidth</i> is not valid. For example,
    ///    it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT get_Width(int* pWidth);
    ///Retrieves the current height of the picture in the picture object.
    ///Params:
    ///    pHeight = A pointer to a variable that receives the height.
    ///Returns:
    ///    This method supports the standard return value E_FAIL, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The height was returned successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The value of <i>pHeight</i> is not valid. For example,
    ///    it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT get_Height(int* pHeight);
    ///Renders (draws) a specified portion of the picture defined by the offset (<i>xSrc</i>,<i>ySrc</i>) of the source
    ///picture and the dimensions to copy (<i>cxSrc</i>,<i>xySrc</i>). This picture is rendered onto the specified
    ///device context, positioned at the point (<i>x</i>,<i>y</i>), and scaled to the dimensions (<i>cx</i>,<i>cy</i>).
    ///The <i>prcWBounds</i> parameter specifies the position of this rendering if the destination device context is
    ///itself a metafile. Such information is necessary to place one metafile in another. For more information, see the
    ///<i>prcWBounds</i> parameter of IViewObject2::Draw.
    ///Params:
    ///    hDC = A handle of the device context on which to render the image.
    ///    x = The horizontal coordinate in <i>hdc</i> at which to place the rendered image.
    ///    y = The vertical coordinate in <i>hdc</i> at which to place the rendered image.
    ///    cx = The horizontal dimension (width) of the destination rectangle.
    ///    cy = The vertical dimension (height) of the destination rectangle
    ///    xSrc = The horizontal offset in the source picture from which to start copying.
    ///    ySrc = The vertical offset in the source picture from which to start copying.
    ///    cxSrc = The horizontal extent to copy from the source picture.
    ///    cySrc = The vertical extent to copy from the source picture.
    ///    pRcWBounds = A pointer to a rectangle containing the position of the destination within a metafile device context if
    ///                 <i>hdc</i> is a metafile DC. Cannot be <b>NULL</b> in such cases.
    ///Returns:
    ///    This method supports the standard return values E_FAIL, E_INVALIDARG, and E_OUTOFMEMORY, as well as the
    ///    following: <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The picture was rendered successfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in <i>prcWBounds</i> is
    ///    not valid when <i>hdc</i> contains a metafile device context. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CTL_E_INVALIDPROPERTYVALUE</b></dt> </dl> </td> <td width="60%"> The parameter <i>cx</i>, <i>cy</i>,
    ///    <i>cxSrc</i>, or <i>cySrc</i> has a value of zero. </td> </tr> </table>
    ///    
    HRESULT Render(HDC hDC, int x, int y, int cx, int cy, int xSrc, int ySrc, int cxSrc, int cySrc, 
                   RECT* pRcWBounds);
    ///Assigns a GDI palette to the picture contained in the picture object.
    ///Params:
    ///    hPal = A handle to the GDI palette assigned to the picture.
    ///Returns:
    ///    This method supports the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and S_OK.
    ///    
    HRESULT set_hPal(uint hPal);
    ///Retrieves the handle of the current device context. This property is valid only for bitmap pictures.
    ///Params:
    ///    phDC = A pointer a variable that receives the device context.
    ///Returns:
    ///    This method supports the standard return value E_FAIL, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The attribute bits were returned successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The value of <i>phDC</i> is not valid. For example, it
    ///    may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT get_CurDC(HDC* phDC);
    ///Selects a bitmap picture into a given device context, and returns the device context in which the picture was
    ///previously selected as well as the picture's GDI handle. This method works in conjunction with
    ///IPicture::get_CurDC.
    ///Params:
    ///    hDCIn = A handle for the device context in which to select the picture.
    ///    phDCOut = A pointer to a variable that receives the previous device context. This parameter can be <b>NULL</b> if the
    ///              caller does not need this information. Ownership of the device context is always the responsibility of the
    ///              caller.
    ///    phBmpOut = A pointer to a variable that receives the GDI handle of the picture. This parameter can be <b>NULL</b> if the
    ///               caller does not need the handle. Ownership of this handle is determined by the <i>fOwn</i> parameter passed
    ///               to OleCreatePictureIndirect. Pictures loaded from a stream always own their resources.
    ///Returns:
    ///    This method supports the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and S_OK.
    ///    
    HRESULT SelectPicture(HDC hDCIn, HDC* phDCOut, uint* phBmpOut);
    ///Retrieves the current value of the picture's KeepOriginalFormat property.
    ///Params:
    ///    pKeep = A pointer to a variable that receives the value of the property.
    ///Returns:
    ///    This method supports the standard return value E_FAIL, as well as the following value. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The value of the KeepOriginalFormat property was returned successfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The value of <i>pKeep</i> is not
    ///    valid. For example, it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT get_KeepOriginalFormat(int* pKeep);
    ///Sets the value of the picture's KeepOriginalFormat property.
    ///Params:
    ///    keep = Specifies the new value to assign to the property.
    ///Returns:
    ///    This method returns S_OK on success and E_FAIL otherwise.
    ///    
    HRESULT put_KeepOriginalFormat(BOOL keep);
    ///Notifies the picture object that its picture resource has changed. This method only calls
    ///IPropertyNotifySink::OnChanged with DISPID_PICT_HANDLE for any connected sinks.
    ///Returns:
    ///    This method S_OK if it succeeds and E_FAIL if the picture object is uninitialized.
    ///    
    HRESULT PictureChanged();
    ///Saves the picture's data into a stream in the same format that it would save itself into a file. Bitmaps use the
    ///BMP file format, metafiles the WMF format, and icons the ICO format.
    ///Params:
    ///    pStream = A pointer to the stream into which the picture writes its data.
    ///    fSaveMemCopy = A flag indicating whether to save a copy of the picture in memory.
    ///    pCbSize = Pointer to a variable that receives the number of bytes written into the stream. This value can be
    ///              <b>NULL</b>, indicating that the caller does not require this information.
    ///Returns:
    ///    This method supports the standard return values E_FAIL, E_INVALIDARG, and S_OK.
    ///    
    HRESULT SaveAsFile(IStream pStream, BOOL fSaveMemCopy, int* pCbSize);
    ///Retrieves the current set of the picture's bit attributes.
    ///Params:
    ///    pDwAttr = A pointer to a variable that receives the value of the Attributes property. The Attributes property can
    ///              contain any combination of the values from the PICTUREATTRIBUTES enumeration.
    ///Returns:
    ///    This method supports the standard return value E_FAIL, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The attribute bits were returned successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The value of <i>pdwAttr</i> is not valid. For example,
    ///    it may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT get_Attributes(uint* pDwAttr);
}

@GUID("F5185DD8-2012-4B0B-AAD9-F052C6BD482B")
interface IPicture2 : IUnknown
{
    HRESULT get_Handle(size_t* pHandle);
    HRESULT get_hPal(size_t* phPal);
    HRESULT get_Type(short* pType);
    HRESULT get_Width(int* pWidth);
    HRESULT get_Height(int* pHeight);
    HRESULT Render(HDC hDC, int x, int y, int cx, int cy, int xSrc, int ySrc, int cxSrc, int cySrc, 
                   RECT* pRcWBounds);
    HRESULT set_hPal(size_t hPal);
    HRESULT get_CurDC(HDC* phDC);
    HRESULT SelectPicture(HDC hDCIn, HDC* phDCOut, size_t* phBmpOut);
    HRESULT get_KeepOriginalFormat(int* pKeep);
    HRESULT put_KeepOriginalFormat(BOOL keep);
    HRESULT PictureChanged();
    HRESULT SaveAsFile(IStream pStream, BOOL fSaveMemCopy, int* pCbSize);
    HRESULT get_Attributes(uint* pDwAttr);
}

@GUID("4EF6100A-AF88-11D0-9846-00C04FC29993")
interface IFontEventsDisp : IDispatch
{
}

///Exposes a font object's properties through Automation. It provides a subset of the IFont methods.
@GUID("BEF6E003-A874-101A-8BBA-00AA00300CAB")
interface IFontDisp : IDispatch
{
}

///Exposes the picture object's properties through Automation. It provides a subset of the functionality available
///through IPicture methods.
@GUID("7BF80981-BF32-101A-8BBB-00AA00300CAB")
interface IPictureDisp : IDispatch
{
}

///Enables a windowless object to process window messages and participate in drag and drop operations. It is derived
///from and extends the IOleInPlaceObject interface. A small object, such as a control, does not need a window of its
///own. Instead, it can rely on its container to dispatch window messages and help the object to participate in drag and
///drop operations. The container must implement the IOleInPlaceSiteWindowless interface. Otherwise, the object must act
///as a normal compound document object and create a window when it is activated.
@GUID("1C2056CC-5EF4-101B-8BC8-00AA003E3B29")
interface IOleInPlaceObjectWindowless : IOleInPlaceObject
{
    ///Dispatches a message from a container to a windowless object that is in-place active.
    ///Params:
    ///    msg = The identifier for the window message provided to the container by Windows.
    ///    wParam = A parameter for the window message provided to the container by Windows.
    ///    lParam = A parameter for the window message provided to the container by Windows.
    ///    plResult = A pointer to result code for the window message.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The windowless object did not process the window message. The container should call
    ///    the DefWindowProc for the message or process the message itself as described below. </td> </tr> </table>
    ///    
    HRESULT OnWindowMessage(uint msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);
    ///Retrieves the IDropTarget interface for an in-place active, windowless object that supports drag and drop.
    ///Params:
    ///    ppDropTarget = A pointer to an IDropTarget pointer variable that receives the interface pointer to the windowless object.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> The windowless object does not support drag and drop. </td> </tr> </table>
    ///    
    HRESULT GetDropTarget(IDropTarget* ppDropTarget);
}

///Provides an additional set of activation and deactivation notification methods that enable an object to avoid
///unnecessary flashing on the screen when the object is activated and deactivated. When an object is activated, it does
///not know if its visual display is already correct. When the object is deactivated, the container does not know if the
///visual display is correct. To avoid a redraw and the associated screen flicker in both cases, the container can
///provide this extension to IOleInPlaceSite.
@GUID("9C2CAD80-3424-11CF-B670-00AA004CD6D8")
interface IOleInPlaceSiteEx : IOleInPlaceSite
{
    ///Called by the embedded object to determine whether it needs to redraw itself upon activation.
    ///Params:
    ///    pfNoRedraw = A pointer to a variable that receives the current redraw status. The status is <b>TRUE</b> if the object need
    ///                 not redraw itself upon activation and <b>FALSE</b> otherwise. Windowless objects usually do not need the
    ///                 value returned by this parameter and may pass a <b>NULL</b> pointer to save the container the burden of
    ///                 computing this value.
    ///    dwFlags = Indicates whether the object is activated as a windowless object. This parameter takes values from the
    ///              ACTIVATEFLAGS enumeration. See IOleInPlaceSiteWindowless for more information on windowless objects.
    ///Returns:
    ///    This method returns S_OK if the container allows the in-place activation. Other possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT OnInPlaceActivateEx(int* pfNoRedraw, uint dwFlags);
    ///Notifies the container if the object needs to be redrawn upon deactivation.
    ///Params:
    ///    fNoRedraw = If <b>TRUE</b>, the container need not redraw the object after completing the deactivation; if <b>FALSE</b>
    ///                the object must be redrawn after deactivation.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT OnInPlaceDeactivateEx(BOOL fNoRedraw);
    ///Notifies the container that the object is about to enter the UI-active state.
    ///Returns:
    ///    This method returns S_OK if the object can continue the activation process and call
    ///    IOleInPlaceSite::OnUIActivate. Other possible return values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> The object cannot enter the UI-active state. The object must call
    ///    IOleInPlaceSite::OnUIDeactivate so the container can perform its the necessary processing to restore the
    ///    focus. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The
    ///    operation failed. </td> </tr> </table>
    ///    
    HRESULT RequestUIActivate();
}

///Extends the IOleInPlaceSiteEx interface. <b>IOleInPlaceSiteWindowless</b> works with IOleInPlaceObjectWindowless
///which is implemented on the windowless object. Together, these two interfaces provide services to a windowless object
///from its container allowing the windowless object to: <ul> <li>Process window messages</li> <li>Participate in drag
///and drop operations </li> <li>Perform drawing operations</li> </ul>Having a window can place unnecessary burdens on
///small objects, such as controls. It prevents an object from being non-rectangular. It prevents windows from being
///transparent. It prevents the small instance size needed by many small controls. A windowless object can enter the
///in-place active state without requiring a window or the resources associated with a window. Instead, the object's
///container provides the object with many of the services associated with having a window.
@GUID("922EADA0-3424-11CF-B670-00AA004CD6D8")
interface IOleInPlaceSiteWindowless : IOleInPlaceSiteEx
{
    ///Informs an object if its container can support it as a windowless object that can be in-place activated.
    ///Returns:
    ///    This method returns S_OK if the object can activate in-place without a window.
    ///    
    HRESULT CanWindowlessActivate();
    ///Called by an in-place active, windowless object to determine whether it still has the mouse capture.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The object does not currently have the mouse capture. </td> </tr> </table>
    ///    
    HRESULT GetCapture();
    ///Enables an in-place active, windowless object to capture all mouse messages.
    ///Params:
    ///    fCapture = If <b>TRUE</b>, the container should capture the mouse for the object. If <b>FALSE</b>, the container should
    ///               release mouse capture for the object.
    ///Returns:
    ///    This method returns S_OK if the mouse capture was successfully granted to the object. If called to release
    ///    the mouse capture, this method must not fail. Other possible return values include the following. <table>
    ///    <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> Mouse capture was denied to the object. </td> </tr> </table>
    ///    
    HRESULT SetCapture(BOOL fCapture);
    ///Called by an in-place active, windowless object to determine whether it still has the keyboard focus.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The object does not currently have the keyboard focus. </td> </tr> </table>
    ///    
    HRESULT GetFocus();
    ///Sets the keyboard focus for a UI-active, windowless object.
    ///Params:
    ///    fFocus = If <b>TRUE</b>, sets the keyboard focus to the calling object. If <b>FALSE</b>, removes the keyboard focus
    ///             from the calling object, provided that the object has the focus.
    ///Returns:
    ///    This method returns S_OK if the keyboard focus was successfully given to the object. If this method is called
    ///    to release the focus, it should never fail. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> Keyboard focus was denied to the object. </td> </tr> </table>
    ///    
    HRESULT SetFocus(BOOL fFocus);
    ///Provides an object with a handle to a device context for a screen or compatible device from its container.
    ///Params:
    ///    pRect = A pointer to the rectangle that the object wants to redraw, in client coordinates of the containing window.
    ///            If this parameter is <b>NULL</b>, the object's full extent is redrawn.
    ///    grfFlags = A combination of values from the OLEDCFLAGS enumeration.
    ///    phDC = A pointer to a returned device context.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>OLE_E_NESTEDPAINT</b></dt>
    ///    </dl> </td> <td width="60%"> The container is already in the middle of a paint session. That is, this method
    ///    has already been called, and the IOleInPlaceSiteWindowless::ReleaseDC method has not yet been called. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetDC(RECT* pRect, uint grfFlags, HDC* phDC);
    ///Releases the device context previously obtained by a call to IOleInPlaceSiteWindowless::GetDC.
    ///Params:
    ///    hDC = The device context to be released.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT ReleaseDC(HDC hDC);
    ///Enables an object to invalidate a specified rectangle of its in-place image on the screen.
    ///Params:
    ///    pRect = The rectangle to be invalidated, in client coordinates of the containing window. If this parameter is
    ///            <b>NULL</b>, the object's full extent is invalidated.
    ///    fErase = Specifies whether the background within the update region is to be erased when the region is updated. If this
    ///             parameter is <b>TRUE</b>, the background is erased. If this parameter is <b>FALSE</b>, the background remains
    ///             unchanged.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT InvalidateRect(RECT* pRect, BOOL fErase);
    ///Enables an object to invalidate a specified region of its in-place image on the screen.
    ///Params:
    ///    hRGN = The region to invalidate, in client coordinates of the containing window. If this parameter is <b>NULL</b>,
    ///           the object's full extent is invalidated.
    ///    fErase = Specifies whether the background within the update region is to be erased when the region is updated. If this
    ///             parameter is <b>TRUE</b>, the background is erased. If this parameter is <b>FALSE</b>, the background remains
    ///             unchanged.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT InvalidateRgn(HRGN hRGN, BOOL fErase);
    ///Enables an object to scroll an area within its in-place active image on the screen.
    ///Params:
    ///    dx = The amount to scroll the x-axis.
    ///    dy = The amount to scroll the y-axis.
    ///    pRectScroll = The rectangle to scroll, in client coordinates of the containing window. A value of <b>NULL</b> indicates the
    ///                  full object.
    ///    pRectClip = The rectangle to clip. Only pixels scrolling into this rectangle are drawn. Pixels scrolling out are not. If
    ///                this parameter is <b>NULL</b>, the rectangle is not clipped.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT ScrollRect(int dx, int dy, RECT* pRectScroll, RECT* pRectClip);
    ///Adjusts a specified rectangle if it is entirely or partially covered by overlapping, opaque objects.
    ///Params:
    ///    prc = The rectangle to be adjusted.
    ///Returns:
    ///    This method returns S_OK if rectangle was adjusted successfully; meaning that the rectangle was not
    ///    completely covered. Other possible return values include the following. <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    The rectangle was adjusted successfully. Note S_FALSE means that the rectangle was completely covered. Its
    ///    width and height are now <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT AdjustRect(RECT* prc);
    ///Invokes the default processing for all messages passed to an object.
    ///Params:
    ///    msg = The identifier for the window message provided to the container by Windows.
    ///    wParam = A parameter for the window message provided to the container by Windows.
    ///    lParam = A parameter for the window message provided to the container by Windows.
    ///    plResult = A pointer to result code for the window message.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The container's default processing for the window message was not invoked. See Note to
    ///    Implementers below. </td> </tr> </table>
    ///    
    HRESULT OnDefWindowMessage(uint msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);
}

///An extension derived from IViewObject2 to provide support for: <ul> <li>Enhanced, flicker-free drawing for
///non-rectangular objects and transparent objects</li> <li>Hit testing for non-rectangular objects</li> <li>Control
///sizing</li> </ul>
@GUID("3AF24292-0C96-11CE-A0CF-00AA00600AB8")
interface IViewObjectEx : IViewObject2
{
    ///Retrieves a rectangle describing a requested drawing aspect.
    ///Params:
    ///    dwAspect = The drawing aspect requested.
    ///    pRect = A pointer to the rectangle describing the requested drawing aspect.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>DV_E_DVASPECT</b></dt>
    ///    </dl> </td> <td width="60%"> The method does not support the specified aspect. Either the object does not
    ///    support the aspect requested or the aspect is not rectangular. </td> </tr> </table>
    ///    
    HRESULT GetRect(uint dwAspect, RECTL* pRect);
    ///Retrieves information about the opacity of the object, and what drawing aspects are supported.
    ///Params:
    ///    pdwStatus = A pointer to the view status. This information is returned as a combination of the VIEWSTATUS enumeration
    ///                values.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT GetViewStatus(uint* pdwStatus);
    ///Indicates whether a point is within a given aspect of an object.
    ///Params:
    ///    dwAspect = The requested drawing aspect.
    ///    pRectBounds = An object bounding rectangle in client coordinates of the containing window. This rectangle is computed and
    ///                  passed by the container so that the object can meaningfully interpret the hit location.
    ///    ptlLoc = The hit location in client coordinates of the containing window.
    ///    lCloseHint = Suggested distance in <b>HIMETRIC</b> units that the container considers close. This value is a hint, and
    ///                 objects can interpret it in their own way. Objects can also use this hint to roughly infer output resolution
    ///                 to choose expansiveness of hit test implementation.
    ///    pHitResult = A pointer to returned information about the hit expressed as the HITRESULT enumeration values.
    ///Returns:
    ///    This method returns <b>S_OK</b> on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> This method is not implemented for the requested aspect. Use DVASPECT_CONTENT instead. </td>
    ///    </tr> </table>
    ///    
    HRESULT QueryHitPoint(uint dwAspect, RECT* pRectBounds, POINT ptlLoc, int lCloseHint, uint* pHitResult);
    ///Indicates whether any point in a rectangle is within a given drawing aspect of an object.
    ///Params:
    ///    dwAspect = The requested drawing aspect.
    ///    pRectBounds = An object bounding rectangle in client coordinates of the containing window. This rectangle is computed and
    ///                  passed by the container so that the object can meaningfully interpret the hit location.
    ///    pRectLoc = The hit test rectangle, specified in <b>HIMETRIC</b> units, relative to the top-left corner of the object.
    ///    lCloseHint = The suggested distance, in <b>HIMETRIC</b> units, that the container considers close. This value is a hint,
    ///                 and objects can interpret it in their own way. Objects can also use this hint to roughly infer output
    ///                 resolution to choose expansiveness of hit test implementation.
    ///    pHitResult = A pointer to returned information about the hit expressed as the HITRESULT enumeration values.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> This method is not implemented for the requested aspect. Use DVASPECT_CONTENT instead. </td>
    ///    </tr> </table>
    ///    
    HRESULT QueryHitRect(uint dwAspect, RECT* pRectBounds, RECT* pRectLoc, int lCloseHint, uint* pHitResult);
    ///Provides sizing hints from the container for the object to use as the user resizes it.
    ///Params:
    ///    dwAspect = The requested drawing aspect. It can be any of the following values, which are defined by the DVASPECT
    ///               enumeration. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///               id="DVASPECT_CONTENT"></a><a id="dvaspect_content"></a><dl> <dt><b>DVASPECT_CONTENT</b></dt> </dl> </td> <td
    ///               width="60%"> Provide a representation of the control so it can be displayed as an embedded object inside of a
    ///               container. This value is typically specified for compound document objects. The presentation can be provided
    ///               for the screen or printer. </td> </tr> <tr> <td width="40%"><a id="DVASPECT_DOCPRINT"></a><a
    ///               id="dvaspect_docprint"></a><dl> <dt><b>DVASPECT_DOCPRINT</b></dt> </dl> </td> <td width="60%"> Provide a
    ///               representation of the control on the screen as though it were printed to a printer using the <b>Print</b>
    ///               command from the <b>File</b> menu. The described data may represent a sequence of pages. </td> </tr> <tr> <td
    ///               width="40%"><a id="DVASPECT_ICON"></a><a id="dvaspect_icon"></a><dl> <dt><b>DVASPECT_ICON</b></dt> </dl>
    ///               </td> <td width="60%"> Provide an iconic representation of the control. </td> </tr> <tr> <td width="40%"><a
    ///               id="DVASPECT_THUMBNAIL"></a><a id="dvaspect_thumbnail"></a><dl> <dt><b>DVASPECT_THUMBNAIL</b></dt> </dl>
    ///               </td> <td width="60%"> Provide a thumbnail representation of an object so it can be displayed in a browsing
    ///               tool. The thumbnail is approximately a 120 by 120 pixel, 16-color (recommended) device-independent bitmap
    ///               potentially wrapped in a metafile. </td> </tr> </table>
    ///    lindex = Indicates the portion of the object that is of interest for the draw operation. Its interpretation varies
    ///             depending on the value in the <i>dwAspect</i> parameter. See the DVASPECT enumeration for more information.
    ///    ptd = Pointer to the target device structure that describes the device for which the object is to be rendered. If
    ///          <b>NULL</b>, the view should be rendered for the default target device (typically the display). A value other
    ///          than <b>NULL</b> is interpreted in conjunction with <i>hicTargetDev</i> and <b>hdcDraw</b>. For example, if
    ///          <b>hdcDraw</b> specifies a printer as the device context, the <i>ptd</i> parameter points to a structure
    ///          describing that printer device. The data may actually be printed if <i>hicTargetDev</i> is a valid value or
    ///          it may be displayed in print preview mode if <i>hicTargetDev</i> is <b>NULL</b>.
    ///    hicTargetDev = Specifies the information context for the target device indicated by the ptd parameter from which the object
    ///                   can extract device metrics and test the device's capabilities. If <i>ptd</i> is <b>NULL</b>; the object
    ///                   should ignore the value in the <i>hicTargetDev</i> parameter.
    ///    pExtentInfo = Pointer to DVEXTENTINFO structure that specifies the sizing data.
    ///    pSizel = Pointer to sizing data returned by the object. The returned sizing data is set to -1 for any dimension that
    ///             was not adjusted. That is if <b>cx</b> is -1 then the width was not adjusted, if <b>cy</b> is -1 then the
    ///             height was not adjusted. If E_FAIL is returned indicating no size was adjusted then <i>pSizel</i> may be
    ///             <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> This method is not implemented for the specified <i>dwAspect</i>, or the size was not
    ///    adjusted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This
    ///    method was not implemented. </td> </tr> </table>
    ///    
    HRESULT GetNaturalExtent(uint dwAspect, int lindex, DVTARGETDEVICE* ptd, HDC hicTargetDev, 
                             ExtentInfo* pExtentInfo, SIZE* pSizel);
}

///Serves as the main interface on an undo unit. An undo unit encapsulates the information necessary to undo or redo a
///single action. When an object's state changes and it needs to create an undo unit, it first needs to know what parent
///units are open. It calls the IOleUndoManager::GetOpenParentState method to determine this. If the call returns
///S_FALSE, then there is no enabling parent. If the call returns S_OK but the UAS_NOPARENTENABLE flag is set, then the
///open parent is a disabling parent. In either of these cases, the object calls IOleUndoManager::DiscardFrom(NULL) on
///the undo manager and skips creating the undo unit. If the method returns S_OK, but the UAS_BLOCKED flag is set, then
///the open parent is a blocking parent. The object does not need to create an undo unit, since it would be immediately
///discarded. If the return value is S_OK and neither of the bit flags are set, then the object creates the undo unit
///and calls IOleUndoManager::Add on the undo manager. The object should retain a pointer to the undo manager.
@GUID("894AD3B0-EF97-11CE-9BC9-00AA00608E01")
interface IOleUndoUnit : IUnknown
{
    ///Instructs the undo unit to carry out its action. Note that if it contains child undo units, it must call their Do
    ///methods as well.
    ///Params:
    ///    pUndoManager = A pointer to the undo manager. See IOleUndoManager.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT Do(IOleUndoManager pUndoManager);
    ///Retrieves a description of the undo unit that can be used in the undo or redo user interface.
    ///Params:
    ///    pBstr = A pointer to string that describes this undo unit.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT GetDescription(BSTR* pBstr);
    ///Retrieves the CLSID and a type identifier for the undo unit.
    ///Params:
    ///    pClsid = A pointer to CLSID for the undo unit.
    ///    plID = A pointer to the type identifier for the undo unit.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT GetUnitType(GUID* pClsid, int* plID);
    ///Notifies the last undo unit in the collection that a new unit has been added.
    ///Returns:
    ///    Implementations of this method always return S_OK. The <b>HRESULT</b> return type is used only for
    ///    remotability.
    ///    
    HRESULT OnNextAdd();
}

///Enables undo units to contain child undo units. For example, a complex action can be presented to the end user as a
///single undo action even though a number of separate actions are involved. All the subordinate undo actions are
///contained within the top-level, parent undo unit. A parent undo unit is initially created using the
///IOleUndoManager::Open method. The addition of undo units should always be done through the undo manager. The
///IOleParentUndoUnit::Open and IOleParentUndoUnit::Close methods on parent units will end up being called by the undo
///manager. Having parent units call back into the undo manager will cause infinite recursion. While a parent unit is
///open, the undo manager adds undo units to it by calling IOleParentUndoUnit::Add. When the undo manager closes a
///top-level parent, the entire undo unit with its nested subordinates is placed on top of the undo stack. An enabling
///parent is required to be open on the stack before any other undo units can be added. If one isn't open, the stack
///should be cleared instead. This is to ensure that undo units only get added as a result of user actions and not
///programmatic actions. For example, if your application wants to make clicking a certain button undoable, but that
///same action is also exposed through the object model. That action should be undoable through the user interface but
///not the object model because you cannot restore the state of the user's script code. Because the same code implements
///the change in both cases, the UI code that handles the button click should open an enabling parent on the stack, call
///the appropriate code, and then close the parent unit. The object model code would not open a parent unit, causing the
///undo stack to be cleared. A blocking parent is used when you do not want your code to call other code that you know
///may try to add undo units to the stack. For example, you should use a blocking parent if you call code that creates
///undo units, that your outer code has already created that will fully undo all the desired behavior. A non-enabling
///parent is used when you fire an event in response to a user action. The stack would be cleared only if the event
///handler did something that tried to create an undo unit, but if no handler exists then the undo stack would be
///preserved. If an object needs to create a parent unit, there are several cases to consider: <ul> <li>To create an
///enabling parent unit, the object calls IOleUndoManager::GetOpenParentState on the undo manager and checks the return
///value. If the value is S_FALSE, then the object creates the enabling parent and opens it. If the return value is
///S_OK, then there is a parent already open. If the open parent is blocked (UAS_BLOCKED bit set), or an enabling parent
///(UAS_BLOCKED and UAS_NOPARENTENABLE bits not set), then there is no need to create the enabling parent. If the
///currently open parent is a disabling parent (UAS_NOPARENTENABLE bit set), then the enabling parent should be created
///and opened to re-enable adding undo units. Note that UAS_NORMAL has a value of zero, which means it is the absence of
///all other bits and is not a bit flag that can be set. If comparing *<i>pdwState</i> against UAS_NORMAL, mask out
///unused bits from <i>pdwState</i> with UAS_MASK to allow for future expansion.</li> <li>To create a blocked parent,
///the object calls IOleUndoManager::GetOpenParentState and checks for an open parent that is already blocked. If one
///exists, then there is no need to create the new blocking parent. Otherwise, the object creates it and opens it on the
///stack.</li> <li>To create a disabling parent, the object calls IOleUndoManager::GetOpenParentState and checks for an
///open parent that is blocked or disabling. If either one exists it is unnecessary to create the new parent. Otherwise,
///the object creates the parent and opens it on the stack.</li> </ul>In the event that both the UAS_NOPARENTENABLE and
///UAS_BLOCKED flags are set, the flag that is most relevant to the caller should be used with UAS_NOPARENTENABLE taking
///precedence. For example, if an object is creating a simple undo unit, it should pay attention to the
///UAS_NOPARENTENABLE flag and clear the undo stack. If it is creating an enabling parent unit, then it should pay
///attention to the UAS_BLOCKED flag and skip the creation. When the parent undo unit is marked blocked, it discards any
///undo units it receives.
@GUID("A1FAF330-EF97-11CE-9BC9-00AA00608E01")
interface IOleParentUndoUnit : IOleUndoUnit
{
    ///Opens a new parent undo unit, which becomes part of the containing unit's undo stack.
    ///Params:
    ///    pPUU = An IOleParentUndoUnit pointer to the parent undo unit to be opened.
    ///Returns:
    ///    This method returns S_OK if the parent undo unit was successfully opened or it is currently blocked.
    ///    
    HRESULT Open(IOleParentUndoUnit pPUU);
    ///Closes the specified parent undo unit.
    ///Params:
    ///    pPUU = An IOleParentUndoUnit pointer to the currently open parent unit to be closed.
    ///    fCommit = Indicates whether to keep or discard the unit. If <b>TRUE</b>, the unit is kept in the collection. If
    ///              <b>FALSE</b>, the unit is discarded. This parameter is used to allow the client to discard an undo unit under
    ///              construction if an error or a cancellation occurs.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl>
    ///    </td> <td width="60%"> The parent undo unit did not have an open child and it was successfully closed. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> If pPUU does not
    ///    match the currently open parent undo unit, then implementations of this method should return E_INVALIDARG
    ///    without changing any internal state unless the parent unit is blocked. </td> </tr> </table>
    ///    
    HRESULT Close(IOleParentUndoUnit pPUU, BOOL fCommit);
    ///Adds a simple undo unit to the collection.
    ///Params:
    ///    pUU = An IOleUndoUnit pointer to the undo unit to be added.
    ///Returns:
    ///    This method returns S_OK if the specified unit was successfully added or the parent unit was blocked.
    ///    
    HRESULT Add(IOleUndoUnit pUU);
    ///Indicates whether the specified unit is a child of this undo unit or one of its children, that is if the
    ///specified unit is part of the hierarchy in this parent unit.
    ///Params:
    ///    pUU = An IOleUndoUnit pointer to the undo unit to be found.
    ///Returns:
    ///    This method returns S_OK if the specified undo unit is in the hierarchy subordinate to this parent;
    ///    otherwise, S_FALSE.
    ///    
    HRESULT FindUnit(IOleUndoUnit pUU);
    ///Retrieves state information about the innermost open parent undo unit.
    ///Params:
    ///    pdwState = A pointer to the state information. This information is a value taken from the UASFLAGS enumeration.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT GetParentState(uint* pdwState);
}

///Enumerates the undo units on the undo or redo stack.
@GUID("B3E7C340-EF97-11CE-9BC9-00AA00608E01")
interface IEnumOleUndoUnits : IUnknown
{
    ///Retrieves the specified number of items in the enumeration sequence.
    ///Params:
    ///    cElt = The number of items to be retrieved. If there are fewer than the requested number of items left in the
    ///           sequence, this method retrieves the remaining elements.
    ///    rgElt = An array of enumerated items. The enumerator is responsible for calling AddRef, and the caller is responsible
    ///            for calling Release through each pointer enumerated. If <i>cElt</i> is greater than 1, the caller must also
    ///            pass a non-NULL pointer passed to <i>pcEltFetched</i> to know how many pointers to release.
    ///    pcEltFetched = The number of items that were retrieved. This parameter is always less than or equal to the number of items
    ///                   requested.
    ///Returns:
    ///    If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Next(uint cElt, IOleUndoUnit* rgElt, uint* pcEltFetched);
    ///Skips over the specified number of items in the enumeration sequence.
    ///Params:
    ///    cElt = The number of items to be skipped.
    ///Returns:
    ///    If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Skip(uint cElt);
    ///Resets the enumeration sequence to the beginning.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT Reset();
    ///Creates a new enumerator that contains the same enumeration state as the current one. This method makes it
    ///possible to record a particular point in the enumeration sequence and then return to that point at a later time.
    ///The caller must release this new enumerator separately from the first enumerator.
    ///Params:
    ///    ppEnum = A pointer to the IEnumOleUndoUnits interface pointer on the newly created enumerator. The caller must release
    ///             this enumerator separately from the one from which it was cloned.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified enumerator is invalid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory
    ///    available for this operation. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumOleUndoUnits* ppEnum);
}

///The <b>IOleUndoManager</b> interface enables containers to implement multi-level undo and redo operations for actions
///that occur within contained controls.
@GUID("D001F200-EF97-11CE-9BC9-00AA00608E01")
interface IOleUndoManager : IUnknown
{
    ///Opens a new parent undo unit, which becomes part of its containing unit's undo stack.
    ///Params:
    ///    pPUU = An IOleParentUndoUnit pointer to the parent undo unit to be opened.
    ///Returns:
    ///    This method returns S_OK if the parent undo unit was successfully opened or if a currently open unit is
    ///    blocked. If the undo manager is currently disabled, it will return S_OK and do nothing else.
    ///    
    HRESULT Open(IOleParentUndoUnit pPUU);
    ///Closes the specified parent undo unit.
    ///Params:
    ///    pPUU = A pointer to an IOleParentUndoUnit interface for the currently open parent unit to be closed.
    ///    fCommit = Indicates whether to keep or discard the unit. If <b>TRUE</b>, the unit is kept in the collection. If
    ///              <b>FALSE</b>, the unit is discarded. This parameter is used to allow the client to discard an undo unit under
    ///              construction if an error or a cancellation occurs.
    ///Returns:
    ///    This method returns S_OK if the undo manager had an open parent undo unit and it was successfully closed. If
    ///    the undo manager is disabled, it should immediately return S_OK and do nothing else. Other possible return
    ///    values include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The parent undo unit did not have an
    ///    open child and it was successfully closed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> If <i>pPUU</i> does not match the currently open
    ///    parent undo unit, then implementations of this method should return E_INVALIDARG without changing any
    ///    internal state unless the parent unit is blocked. </td> </tr> </table>
    ///    
    HRESULT Close(IOleParentUndoUnit pPUU, BOOL fCommit);
    ///Adds a simple undo unit to the collection. While a parent undo unit is open, the undo manager adds undo units to
    ///it by calling IOleParentUndoUnit::Add.
    ///Params:
    ///    pUU = An IOleUndoUnit pointer to the undo unit to be added.
    ///Returns:
    ///    This method returns S_OK if the specified unit was successfully added, the parent unit was blocked, or the
    ///    undo manager is disabled.
    ///    
    HRESULT Add(IOleUndoUnit pUU);
    ///Retrieves state information about the innermost open parent undo unit.
    ///Params:
    ///    pdwState = A pointer to a variable that receives the state information. This information is a value taken from the
    ///               UASFLAGS enumeration.
    ///Returns:
    ///    This method returns S_OK if there is an open parent unit and its state was successfully returned or the undo
    ///    manager is disabled; otherwise, S_FALSE.
    ///    
    HRESULT GetOpenParentState(uint* pdwState);
    ///Instructs the undo manager to discard the specified undo unit and all undo units below it on the undo or redo
    ///stack.
    ///Params:
    ///    pUU = An IOleUndoUnit pointer to the undo unit to be discarded. This parameter can be <b>NULL</b> to discard the
    ///          entire undo or redo stack. If the parameter is not <b>NULL</b> then the stack will not be discarded.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The specified undo unit was not found in the stacks. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The undo manager is disabled. </td> </tr>
    ///    </table>
    ///    
    HRESULT DiscardFrom(IOleUndoUnit pUU);
    ///Instructs the undo manager to invoke undo actions back through the undo stack, down to and including the
    ///specified undo unit.
    ///Params:
    ///    pUU = Pointer to the top level unit to undo. If this parameter is <b>NULL</b>, the most recently added top level
    ///          unit is used.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The specified undo unit is not on the undo stack. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td width="60%"> Both the undo attempt and the rollback attempt
    ///    failed. The undo manager should never propagate the E_ABORT obtained from a contained undo unit. Instead, it
    ///    should map any E_ABORT values returned from other undo units to E_FAIL. The undo manager should map any
    ///    E_ABORT value returned from other undo units to E_FAIL because the caller of IOleUndoManager::UndoTo knows
    ///    that the undo attempt and the rollback attempt failed and this is the only reason for the return value of
    ///    E_ABORT. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The
    ///    undo manager is disabled. </td> </tr> </table>
    ///    
    HRESULT UndoTo(IOleUndoUnit pUU);
    ///Instructs the undo manager to invoke undo actions back through the redo stack, down to and including the
    ///specified undo unit.
    ///Params:
    ///    pUU = An IOleUndoUnit pointer to the top level unit to redo. If this parameter is <b>NULL</b>, the most recently
    ///          added top level unit is used.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The specified undo unit is not on the redo stack. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td width="60%"> Both the undo attempt and the rollback attempt
    ///    failed. The undo manager should never propagate the E_ABORT obtained from a contained undo unit. Instead, it
    ///    should map any E_ABORT values returned from other undo units to E_FAIL. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The undo manager is disabled. </td> </tr>
    ///    </table>
    ///    
    HRESULT RedoTo(IOleUndoUnit pUU);
    ///Creates an enumerator object that the caller can use to iterate through a series of top-level undo units from the
    ///undo stack.
    ///Params:
    ///    ppEnum = Address of IEnumOleUndoUnits pointer variable that receives the interface pointer to the enumerator object.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> The undo manager is disabled. </td> </tr> </table>
    ///    
    HRESULT EnumUndoable(IEnumOleUndoUnits* ppEnum);
    ///Creates an enumerator object that the caller can use to iterate through a series of top-level undo units from the
    ///redo stack.
    ///Params:
    ///    ppEnum = Address of IEnumOleUndoUnits pointer variable that receives the interface pointer to the enumerator object.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> The undo manager is disabled. </td> </tr> </table>
    ///    
    HRESULT EnumRedoable(IEnumOleUndoUnits* ppEnum);
    ///Retrieves the description for the top-level undo unit that is on top of the undo stack.
    ///Params:
    ///    pBstr = A pointer to a string that contains a description of the top-level undo unit on the undo stack.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The undo stack is empty. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt>
    ///    </dl> </td> <td width="60%"> The undo manager is disabled. </td> </tr> </table>
    ///    
    HRESULT GetLastUndoDescription(BSTR* pBstr);
    ///Retrieves the description for the top-level undo unit that is on top of the redo stack.
    ///Params:
    ///    pBstr = A pointer to a string that contains a description of the top-level undo unit on the redo stack.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The undo stack is empty. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt>
    ///    </dl> </td> <td width="60%"> The undo manager is disabled. </td> </tr> </table>
    ///    
    HRESULT GetLastRedoDescription(BSTR* pBstr);
    ///Enables or disables the undo manager.
    ///Params:
    ///    fEnable = Indicates whether to enable or disable the undo manager. If <b>TRUE</b>, the undo manager should be enabled.
    ///              If <b>FALSE</b>, the undo manager should be disabled.
    ///Returns:
    ///    This method returns S_OK if the undo manager was successfully enabled or disabled. Other possible return
    ///    values include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> There is an open undo unit on the
    ///    stack or the undo manager is currently performing an undo or a redo. </td> </tr> </table>
    ///    
    HRESULT Enable(BOOL fEnable);
}

///Enables an object to remain inactive most of the time, yet still participate in interaction with the mouse, including
///drag and drop. Objects can be active (in-place or UI active) or they can be inactive (loaded or running). An active
///object creates a window and can receive Windows mouse and keyboard messages. An inactive object can render itself and
///provide a representation of its data in a given format. While they provide more functionality, active objects also
///consume more resources than inactive objects. Typically, they are larger and slower than inactive objects. Thus,
///keeping an object inactive can provide performance improvements. However, an object, such as a control, needs to be
///able to control the mouse pointer, fire mouse events, and act as a drop target so it can participate in the user
///interface of its container application.
@GUID("55980BA0-35AA-11CF-B671-00AA004CD6D8")
interface IPointerInactive : IUnknown
{
    ///Retrieves the current activation policy for the object. This method is called by the container on receipt of a
    ///WM_SETCURSOR or WM_MOUSEMOVE message when an inactive object is under the mouse pointer.
    ///Params:
    ///    pdwPolicy = A pointer to a variable that receives the activation policy. Possible values come from the POINTERINACTIVE
    ///                enumeration.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.
    ///    
    HRESULT GetActivationPolicy(uint* pdwPolicy);
    ///Notifies the object that the mouse pointer has moved over it so the object can fire mouse events. This method is
    ///called by the container on receipt of a WM_MOUSEMOVE method when an inactive object is under the mouse pointer.
    ///Params:
    ///    pRectBounds = The object bounding rectangle, in client coordinates of the containing window. This parameter tells the
    ///                  object its exact position and size on the screen when the WM_MOUSEMOVE message was received. This value is
    ///                  specified in units of the client's coordinate system.
    ///    x = The horizontal coordinate of mouse location in units of the client's containing window.
    ///    y = The vertical coordinate of mouse location in units of the client's containing window.
    ///    grfKeyState = The current state of the keyboard modifier keys on the keyboard. Possible values can be a combination of any
    ///                  of the values MK_CONTROL, MK_SHIFT, MK_ALT, MK_BUTTON, MK_LBUTTON, MK_MBUTTON, and MK_RBUTTON.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.
    ///    
    HRESULT OnInactiveMouseMove(RECT* pRectBounds, int x, int y, uint grfKeyState);
    ///Sets the mouse pointer for an inactive object. This method is called by the container on receipt of a
    ///WM_SETCURSOR method when an inactive object is under the mouse pointer.
    ///Params:
    ///    pRectBounds = The object bounding rectangle specified in client coordinate units of the containing window. This parameter
    ///                  tells the object its exact position and size on the screen when the WM_SETCURSOR message was received. This
    ///                  value is specified in units of the client's coordinate system.
    ///    x = The horizontal coordinate of mouse location in units of the client's containing window.
    ///    y = The vertical coordinate of mouse location in units of the client's containing window.
    ///    dwMouseMsg = The identifier of the mouse message for which a WM_SETCURSOR occurred.
    ///    fSetAlways = If this value is <b>TRUE</b>, the object must set the cursor; if this value is <b>FALSE</b>, the object is
    ///                 not obligated to set the cursor, and should return S_FALSE in that case.
    ///Returns:
    ///    This method can return the standard return value E_FAIL, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The mouse pointer was successfully set. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The object did not set the cursor; the container should
    ///    either set the cursor or call the object again with the parameter <i>fSetAlways</i> set to <b>TRUE</b>. </td>
    ///    </tr> </table>
    ///    
    HRESULT OnInactiveSetCursor(RECT* pRectBounds, int x, int y, uint dwMouseMsg, BOOL fSetAlways);
}

///Provides a simple way to support communication between an object and its site in the container. Often an object needs
///to communicate directly with a container site object and, in effect, manage the site object itself. Outside of
///IOleObject::SetClientSite, there is no generic means through which an object becomes aware of its site.
///<b>IObjectWithSite</b> provides simple objects with a simple siting mechanism (lighter than IOleObject) This
///interface should only be used when <b>IOleObject</b> is not already in use. Through <b>IObjectWithSite</b>, a
///container can pass the IUnknown pointer of its site to the object through IObjectWithSite::SetSite. Callers can also
///retrieve the latest site passed to <b>SetSite</b> through IObjectWithSite::GetSite. This latter method is included as
///a hooking mechanism, allowing a third party to intercept calls from the object to the site.
@GUID("FC4801A3-2BA9-11CF-A229-00AA003D7352")
interface IObjectWithSite : IUnknown
{
    ///Enables a container to pass an object a pointer to the interface for its site.
    ///Params:
    ///    pUnkSite = A pointer to the IUnknown interface pointer of the site managing this object. If <b>NULL</b>, the object
    ///               should call Release on any existing site at which point the object no longer knows its site.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT SetSite(IUnknown pUnkSite);
    ///Retrieves the latest site passed using SetSite.
    ///Params:
    ///    riid = The IID of the interface pointer that should be returned in <i>ppvSite</i>.
    ///    ppvSite = Address of pointer variable that receives the interface pointer requested in <i>riid</i>. Upon successful
    ///              return, *<i>ppvSite</i> contains the requested interface pointer to the site last seen in SetSite. The
    ///              specific interface returned depends on the <i>riid</i> argumentin essence, the two arguments act
    ///              identically to those in QueryInterface. If the appropriate interface pointer is available, the object must
    ///              call AddRef on that pointer before returning successfully. If no site is available, or the requested
    ///              interface is not supported, this method must *<i>ppvSite</i> to <b>NULL</b> and return a failure code.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> There is no site, in which case *<i>ppvSite</i> contains <b>NULL</b> on return. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> There is a site, but it
    ///    does not support the interface requested by <i>riid</i>. </td> </tr> </table>
    ///    
    HRESULT GetSite(const(GUID)* riid, void** ppvSite);
}

///Retrieves the information in the property pages offered by an object.
@GUID("376BD3AA-3845-101B-84ED-08002B2EC713")
interface IPerPropertyBrowsing : IUnknown
{
    ///Retrieves a text string describing the specified property.
    ///Params:
    ///    dispID = The dispatch identifier of the property whose display name is requested.
    ///    pBstr = A pointer to a variable that receives the display name for the property identified in <i>dispID</i>. The
    ///            string is allocated by this method using <b>SysAllocString</b>. Upon return, the string is the responsibility
    ///            of the caller, which must free it with <b>SysFreeString</b> when it is no longer needed.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as
    ///    the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The display name was successfully returned. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The object does not provide
    ///    display names for individual properties. The caller has the recourse to check the object's type information
    ///    for the text name of the object in this case. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in pbstr is not valid. For example, it may
    ///    be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT GetDisplayString(int dispID, BSTR* pBstr);
    ///Retrieves the CLSID of the property page associated with the specified property.
    ///Params:
    ///    dispID = The dispatch identifier of the property.
    ///    pClsid = A pointer to the CLSID identifying the property page associated with the property specified by <i>dispID</i>.
    ///             If this method fails, *<i>pClsid</i> is set to CLSID_NULL.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG and E_UNEXPECTED, as well as the following
    ///    values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed succesfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The object does not support property
    ///    pages at all or does not support mapping properties to the page CLSID. In other words, this feature of
    ///    specific property browsing is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt>
    ///    </dl> </td> <td width="60%"> The address in <i>pClsid</i> is not valid. For example, it may be <b>NULL</b>.
    ///    </td> </tr> </table>
    ///    
    HRESULT MapPropertyToPage(int dispID, GUID* pClsid);
    ///Retrieves an array description strings for the allowable values that the specified property can accept.
    ///Params:
    ///    dispID = The dispatch identifier of the property.
    ///    pCaStringsOut = A pointer to a caller-allocated, counted array structure that contains the element count and address of a
    ///                    method-allocated array of string pointers. This method also allocates memory for the string values containing
    ///                    the predefined names, and it stores the string pointers in the array. If the method fails, no memory is
    ///                    allocated, and the contents of the structure are undefined.
    ///    pCaCookiesOut = A pointer to the caller-allocated, counted array structure that contains the element count and address of a
    ///                    method-allocated array of <b>DWORD</b> values. The values in the array can be passed to
    ///                    IPerPropertyBrowsing::GetPredefinedValue to retrieve the value associated with the name in the same array
    ///                    position inside <i>pCaStringsOut</i>. If the method fails, no memory is allocated, and the contents of the
    ///                    structure are undefined.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as
    ///    the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed succesfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not implemented and
    ///    predefined names are not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> The address in <i>pCaStringsOut</i> or <i>pCaCookiesOut</i> is not valid. For example,
    ///    either parameter may be <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT GetPredefinedStrings(int dispID, CALPOLESTR* pCaStringsOut, CADWORD* pCaCookiesOut);
    ///Retrieves the value of the specified property that is associated with a predefined string name. This property is
    ///associated with a predefined string name as returned from IPerPropertyBrowsing::GetPredefinedStrings. The
    ///predefined string is identified by a token returned from <b>GetPredefinedStrings</b>.
    ///Params:
    ///    dispID = The dispatch identifier of the property for which a predefined value is requested.
    ///    dwCookie = A token identifying which value to return. The token was previously returned in the <i>pCaCookiesOut</i>
    ///               array filled by GetPredefinedStrings.
    ///    pVarOut = A pointer to the <b>VARIANT</b> value for the property.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as
    ///    the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed succesfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This object does not support
    ///    predefined strings or predefined values. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt>
    ///    </dl> </td> <td width="60%"> The address in <i>pVarOut</i> is not valid. For example, it may be <b>NULL</b>.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetPredefinedValue(int dispID, uint dwCookie, VARIANT* pVarOut);
}

@GUID("22F55882-280B-11D0-A8A9-00A0C90C2004")
interface IPropertyBag2 : IUnknown
{
    HRESULT Read(uint cProperties, char* pPropBag, IErrorLog pErrLog, char* pvarValue, char* phrError);
    HRESULT Write(uint cProperties, char* pPropBag, char* pvarValue);
    HRESULT CountProperties(uint* pcProperties);
    HRESULT GetPropertyInfo(uint iProperty, uint cProperties, char* pPropBag, uint* pcProperties);
    HRESULT LoadObject(ushort* pstrName, uint dwHint, IUnknown pUnkObject, IErrorLog pErrLog);
}

@GUID("22F55881-280B-11D0-A8A9-00A0C90C2004")
interface IPersistPropertyBag2 : IPersist
{
    HRESULT InitNew();
    HRESULT Load(IPropertyBag2 pPropBag, IErrorLog pErrLog);
    HRESULT Save(IPropertyBag2 pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
    HRESULT IsDirty();
}

///This interface is derived from IAdviseSink to provide extensions for notifying the sink of changes in an object's
///view status.
@GUID("3AF24290-0C96-11CE-A0CF-00AA00600AB8")
interface IAdviseSinkEx : IAdviseSink
{
    ///Notifies the sink that a view status of an object has changed.
    ///Params:
    ///    dwViewStatus = The new view status. Possible values are from the VIEWSTATUS enumeration.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    void OnViewStatusChange(uint dwViewStatus);
}

///Enables controls and containers to avoid performance bottlenecks on loading controls. It combines the load-time or
///initialization-time handshaking between the control and its container into a single call.
@GUID("CF51ED10-62FE-11CF-BF86-00A0C9034836")
interface IQuickActivate : IUnknown
{
    ///Quick activates a control.
    ///Params:
    ///    pQaContainer = A pointer to the QACONTAINER structure containing information about the container.
    ///    pQaControl = A pointer to the QACONTROL structure filled in by the control to return information about the control to the
    ///                 container. The container calling this method must reserve memory for this structure.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.
    ///    
    HRESULT QuickActivate(QACONTAINER* pQaContainer, QACONTROL* pQaControl);
    ///Sets the content extent of a control.
    ///Params:
    ///    pSizel = The size of the content extent.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.
    ///    
    HRESULT SetContentExtent(SIZE* pSizel);
    ///Gets the content extent of a control.
    ///Params:
    ///    pSizel = A pointer to a structure that contains size of the content extent.
    ///Returns:
    ///    If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.
    ///    
    HRESULT GetContentExtent(SIZE* pSizel);
}

///Provides access to all the controls on a Visual Basic container.
interface IVBGetControl : IUnknown
{
    ///Enumerates the controls on the form. <div class="alert"><b>Note</b> The use of this method is no longer
    ///recommended because containers other than Visual Basic do not support it.</div><div> </div>
    ///Params:
    ///    dwOleContF = Specifies the type of OLE objects to be enumerated. This parameter can be one of the following values
    ///                 enumerated by the OLECONTF enumeration. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///                 width="40%"><a id="OLECONTF_EMBEDDINGS"></a><a id="olecontf_embeddings"></a><dl>
    ///                 <dt><b>OLECONTF_EMBEDDINGS</b></dt> </dl> </td> <td width="60%"> Enumerates the embedded objects on the form.
    ///                 Include this flag to enumerate OLE controls. </td> </tr> <tr> <td width="40%"><a id="OLECONTF_LINKS"></a><a
    ///                 id="olecontf_links"></a><dl> <dt><b>OLECONTF_LINKS</b></dt> </dl> </td> <td width="60%"> Enumerates the
    ///                 linked objects on the form. </td> </tr> <tr> <td width="40%"><a id="OLECONTF_OTHER"></a><a
    ///                 id="olecontf_other"></a><dl> <dt><b>OLECONTF_OTHER</b></dt> </dl> </td> <td width="60%"> Enumerates all
    ///                 pseudo OLE objects. Include this flag to enumerate VBX controls. </td> </tr> <tr> <td width="40%"><a
    ///                 id="OLECONTF_ONLYUSER"></a><a id="olecontf_onlyuser"></a><dl> <dt><b>OLECONTF_ONLYUSER</b></dt> </dl> </td>
    ///                 <td width="60%"> Enumerates only objects that the user is aware of. </td> </tr> <tr> <td width="40%"><a
    ///                 id="OLECONTF_ONLYIFRUNNING"></a><a id="olecontf_onlyifrunning"></a><dl>
    ///                 <dt><b>OLECONTF_ONLYIFRUNNING</b></dt> </dl> </td> <td width="60%"> Enumerates only the objects that are
    ///                 running on the form. </td> </tr> </table> When enumerating OLE controls, it is recommended that you combine
    ///                 the flags <b>OLECONTF_ONLYUSER</b>, <b>OLECONTF_ONLYIFRUNNING</b>, and <b>OLECONTF_EMBEDDINGS</b>. To include
    ///                 both OLE controls and VBX controls, add the <b>OLECONTF_OTHERS</b> flag to this list. To enumerate only VBX
    ///                 controls, remove the <b>OLECONTF_EMBEDDINGS</b> flag and include the <b>OLECONTF_OTHERS</b> flag.
    ///    dwWhich = Specifies the set of controls to be enumerated. This parameter can be one of the following values. <table>
    ///              <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="GCW_WCH_SIBLING"></a><a
    ///              id="gcw_wch_sibling"></a><dl> <dt><b>GCW_WCH_SIBLING</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///              width="60%"> Enumerates all siblings of the control. </td> </tr> <tr> <td width="40%"><a
    ///              id="GC_WCH_CONTAINER"></a><a id="gc_wch_container"></a><dl> <dt><b>GC_WCH_CONTAINER</b></dt>
    ///              <dt>0x00000002</dt> </dl> </td> <td width="60%"> Enumerates all objects that are parents of your control. You
    ///              cannot use the <b>GC_WCH_FONLYAFTER</b> or <b>GC_WCH_FONLYBEFORE</b> flags with this flag. </td> </tr> <tr>
    ///              <td width="40%"><a id="GC_WCH_CONTAINED"></a><a id="gc_wch_contained"></a><dl>
    ///              <dt><b>GC_WCH_CONTAINED</b></dt> <dt>0x00000003</dt> </dl> </td> <td width="60%"> Enumerates all objects that
    ///              are children of your control. You cannot use the <b>GC_WCH_FONLYAFTER</b> or <b>GC_WCH_FONLYBEFORE</b> flags
    ///              with this flag. </td> </tr> <tr> <td width="40%"><a id="GC_WCH_ALL"></a><a id="gc_wch_all"></a><dl>
    ///              <dt><b>GC_WCH_ALL</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Enumerates all objects. </td>
    ///              </tr> <tr> <td width="40%"><a id="GC_WCH_FREVERSEDIR"></a><a id="gc_wch_freversedir"></a><dl>
    ///              <dt><b>GC_WCH_FREVERSEDIR</b></dt> <dt>0x08000000</dt> </dl> </td> <td width="60%"> Enumerates and organizes
    ///              controls in the reverse tab order direction. This flag can be combined with any other flag. </td> </tr> <tr>
    ///              <td width="40%"><a id="GC_WCH_FONLYAFTER"></a><a id="gc_wch_fonlyafter"></a><dl>
    ///              <dt><b>GC_WCH_FONLYAFTER</b></dt> <dt>0x10000000</dt> </dl> </td> <td width="60%"> Enumerates all controls
    ///              that appear after your control in the tab order. </td> </tr> <tr> <td width="40%"><a
    ///              id="GC_WCH_FONLYBEFORE"></a><a id="gc_wch_fonlybefore"></a><dl> <dt><b>GC_WCH_FONLYBEFORE</b></dt>
    ///              <dt>0x20000000</dt> </dl> </td> <td width="60%"> Enumerates all controls that appear before your control in
    ///              the tab order. </td> </tr> <tr> <td width="40%"><a id="GC_WCH_FSELECTED"></a><a
    ///              id="gc_wch_fselected"></a><dl> <dt><b>GC_WCH_FSELECTED</b></dt> <dt>0x40000000</dt> </dl> </td> <td
    ///              width="60%"> Enumerates all the controls that are currently selected. </td> </tr> </table> Use one of the
    ///              flags <b>GC_WCH_SIBLING</b>, <b>GC_WCH_CONTAINER</b>, <b>GC_WCH_CONTAINED</b>, or <b>GC_WCH_ALL</b> in
    ///              combination with any of the GC_WCH_F<i>xxx</i> flags. In VBX code, the GC_FORM flag was passed to
    ///              <b>VBGetControl</b> to obtain a pointer to the form. In OLE control code, there is no direct replacement for
    ///              this flag. Instead, pass <b>GC_WHC_ALL</b> to <b>EnumControls</b> and use the pointer to the first control in
    ///              the enumeration. The first control in the enumeration is always the form when using <b>GC_WHC_ALL</b>.
    ///    ppenumUnk = Pointer to an enumeration of OLE objects.
    ///Returns:
    ///    This method supports the standard return values <b>E_INVALIDARG</b>, <b>E_OUTOFMEMORY</b>, and
    ///    <b>E_UNEXPECTED</b>, as well as the following:
    ///    
    HRESULT EnumControls(uint dwOleContF, uint dwWhich, IEnumUnknown* ppenumUnk);
}

///Gets access to an OLE control on a Visual Basic container.
interface IGetOleObject : IUnknown
{
    ///Gets a pointer to an OLE control on a Visual Basic container. <div class="alert"><b>Note</b> The use of this
    ///method is no longer recommended because containers other than Visual Basic do not support it.</div><div> </div>
    ///Params:
    ///    riid = Specifies the interface to retrieve. Pass <b>IID_IOleObject</b> to obtain a pointer to the control.
    ///    ppvObj = Pointer to the control.
    ///Returns:
    ///    This method supports the standard return values <b>E_INVALIDARG</b>, <b>E_OUTOFMEMORY</b>, and
    ///    <b>E_UNEXPECTED</b>, as well as the following:
    ///    
    HRESULT GetOleObject(const(GUID)* riid, void** ppvObj);
}

///Provides formatting support for controls on a Visual Basic container.
interface IVBFormat : IUnknown
{
    ///Formats a string according to a pattern. <div class="alert"><b>Note</b> The use of this method is no longer
    ///recommended because containers other than Visual Basic do not support it.</div><div> </div>
    ///Params:
    ///    vData = Data to be formatted.
    ///    bstrFormat = Format string to be applied to the data.
    ///    lpBuffer = Pointer to result buffer.
    ///    cb = Length of result buffer.
    ///    lcid = Locale ID.
    ///    sFirstDayOfWeek = Affects the 'w', FirstDayOfWeek, format result. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///                      width="40%"><a id="vbUseSystem"></a><a id="vbusesystem"></a><a id="VBUSESYSTEM"></a><dl>
    ///                      <dt><b>vbUseSystem</b></dt> </dl> </td> <td width="60%"> Use the <b>FirstWeekday</b> setting in the host UI.
    ///                      If no host value is provided, use the current system value from the NLS API. </td> </tr> <tr> <td
    ///                      width="40%"><a id="vbSunday"></a><a id="vbsunday"></a><a id="VBSUNDAY"></a><dl> <dt><b>vbSunday</b></dt>
    ///                      </dl> </td> <td width="60%"> Sunday </td> </tr> <tr> <td width="40%"><a id="vbMonday"></a><a
    ///                      id="vbmonday"></a><a id="VBMONDAY"></a><dl> <dt><b>vbMonday</b></dt> </dl> </td> <td width="60%"> Monday
    ///                      </td> </tr> <tr> <td width="40%"><a id="vbTuesday"></a><a id="vbtuesday"></a><a id="VBTUESDAY"></a><dl>
    ///                      <dt><b>vbTuesday</b></dt> </dl> </td> <td width="60%"> Tuesday </td> </tr> <tr> <td width="40%"><a
    ///                      id="vbWednesday"></a><a id="vbwednesday"></a><a id="VBWEDNESDAY"></a><dl> <dt><b>vbWednesday</b></dt> </dl>
    ///                      </td> <td width="60%"> Wednesday </td> </tr> <tr> <td width="40%"><a id="vbThursday"></a><a
    ///                      id="vbthursday"></a><a id="VBTHURSDAY"></a><dl> <dt><b>vbThursday</b></dt> </dl> </td> <td width="60%">
    ///                      Thursday </td> </tr> <tr> <td width="40%"><a id="vbFriday"></a><a id="vbfriday"></a><a id="VBFRIDAY"></a><dl>
    ///                      <dt><b>vbFriday</b></dt> </dl> </td> <td width="60%"> Friday </td> </tr> <tr> <td width="40%"><a
    ///                      id="vbSaturday"></a><a id="vbsaturday"></a><a id="VBSATURDAY"></a><dl> <dt><b>vbSaturday</b></dt> </dl> </td>
    ///                      <td width="60%"> Saturday </td> </tr> </table>
    ///    sFirstWeekOfYear = Affects the 'ww', FirstWeekOfYear, format result. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///                       width="40%"><a id="vbUseSystem"></a><a id="vbusesystem"></a><a id="VBUSESYSTEM"></a><dl>
    ///                       <dt><b>vbUseSystem</b></dt> </dl> </td> <td width="60%"> Use the <b>FirstWeekOfYear</b> setting in the host
    ///                       UI. If no host value is provided, use the current system value from the NLS API. </td> </tr> <tr> <td
    ///                       width="40%"><a id="vbFirstJan1"></a><a id="vbfirstjan1"></a><a id="VBFIRSTJAN1"></a><dl>
    ///                       <dt><b>vbFirstJan1</b></dt> </dl> </td> <td width="60%"> Start on January 1 (default). </td> </tr> <tr> <td
    ///                       width="40%"><a id="vbFirstFourDays"></a><a id="vbfirstfourdays"></a><a id="VBFIRSTFOURDAYS"></a><dl>
    ///                       <dt><b>vbFirstFourDays</b></dt> </dl> </td> <td width="60%"> Start with the first four-day week. </td> </tr>
    ///                       <tr> <td width="40%"><a id="vbFirstFullWeek"></a><a id="vbfirstfullweek"></a><a id="VBFIRSTFULLWEEK"></a><dl>
    ///                       <dt><b>vbFirstFullWeek</b></dt> </dl> </td> <td width="60%"> Start with the first full week. </td> </tr>
    ///                       </table>
    ///    rcb = Number of bytes copied to the result buffer.
    ///Returns:
    ///    This method supports the standard return values <b>E_INVALIDARG</b>, <b>E_OUTOFMEMORY</b>, and
    ///    <b>E_UNEXPECTED</b>, as well as the following:
    ///    
    HRESULT Format(VARIANT* vData, BSTR bstrFormat, void* lpBuffer, ushort cb, int lcid, short sFirstDayOfWeek, 
                   ushort sFirstWeekOfYear, ushort* rcb);
}

///Gets access to the IVBFormat interface.
interface IGetVBAObject : IUnknown
{
    HRESULT GetObjectA(const(GUID)* riid, void** ppvObj, uint dwReserved);
}

///Enables a document object to communicate to containers its ability to create views of its data. This interface also
///enables a document object to enumerate its views and to provide containers with miscellaneous information about
///itself, such as whether it supports multiple views or complex rectangles.
@GUID("B722BCC5-4E68-101B-A2BC-00AA00404770")
interface IOleDocument : IUnknown
{
    ///Creates a document view object in the caller's process and obtains a pointer to that object's IOleDocumentView
    ///interface.
    ///Params:
    ///    pIPSite = A pointer to the IOleInPlaceSite interface that represents the view site object to be associated with the new
    ///              document view object. This parameter can be <b>NULL</b>, for example, when the view is contained in a new,
    ///              uninitialized document object, in which case the caller must initialize the view with a subsequent call to
    ///              IOleDocumentView::SetInPlaceSite.
    ///    pstm = A pointer to a stream containing data from which the new document view object should initialize itself. If
    ///           <b>NULL</b>, the document object initializes the new document view object with a default state.
    ///    dwReserved = This parameter is reserved and must be zero.
    ///    ppView = A pointer to an IOleDocumentView pointer variable that receives the interface pointer to the new document
    ///             view object. When successful, the caller is responsible for calling IUnknown::Release on the <i>ppview</i>
    ///             pointer when the view object is no longer needed.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory available for the operation. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in
    ///    <i>ppView</i> is <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT CreateView(IOleInPlaceSite pIPSite, IStream pstm, uint dwReserved, IOleDocumentView* ppView);
    ///Retrieves status information about the document object.
    ///Params:
    ///    pdwStatus = A pointer to the information on supported behaviors. Possible values are taken from the DOCMISC enumeration.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> The address in <i>pdwStatus</i> is <b>NULL</b>. </td> </tr> </table>
    ///    
    HRESULT GetDocMiscStatus(uint* pdwStatus);
    ///Creates an object that enumerates the views supported by a document object, or if only one view is supported,
    ///returns a pointer to that view.
    ///Params:
    ///    ppEnum = A pointer to an IEnumOleDocumentViews pointer variable that receives the interface pointer to the enumerator
    ///             object.
    ///    ppView = A pointer to an IOleDocumentView pointer variable that receives the interface pointer to a single view
    ///             object.
    ///Returns:
    ///    This method returns S_OK if the object supports multiple views, then <i>ppEnum</i> contains a pointer to the
    ///    enumerator object, and <i>ppView</i> is <b>NULL</b>. Otherwise, <i>ppEnum</i> is <b>NULL</b>, and
    ///    <i>ppView</i> contains an interface pointer on the single view. Other possible return values include the
    ///    following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory available for the operation.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The address in
    ///    <i>ppEnum</i> or <i>ppView</i> is invalid. The caller must pass valid pointers for both arguments. </td>
    ///    </tr> </table>
    ///    
    HRESULT EnumViews(IEnumOleDocumentViews* ppEnum, IOleDocumentView* ppView);
}

///Enables a document that has been implemented as a document object to bypass the normal activation sequence for
///in-place-active objects and to directly instruct its client site to activate it as a document object. A client site
///with this ability is called a document site. For each document object to be hosted, a container must provide a
///corresponding document site, which is an OLE Documents client site that, in addition to implementing IOleClientSite
///and IAdviseSink, also implements <b>IOleDocumentSite</b>. Each document site implements a separate document view site
///object for each view of a document to be activated. The document view site implements IOleInPlaceSite and,
///optionally, IContinueCallback.
@GUID("B722BCC7-4E68-101B-A2BC-00AA00404770")
interface IOleDocumentSite : IUnknown
{
    ///Asks a document site to activate the document making the call as a document object rather than an in-place-active
    ///object and, optionally, specifies which view of the object document to activate.
    ///Params:
    ///    pViewToActivate = A pointer to an IOleDocumentView interface pointer that represents the document view to be used in activating
    ///                      the document object. This parameter can be <b>NULL</b>, in which case the container should call
    ///                      IOleDocument::CreateView to obtain a document view pointer.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT ActivateMe(IOleDocumentView pViewToActivate);
}

///The <b>IOleDocumentView</b> interface enables a container to communicate with each view supported by a document
///object. A document object that supports multiple views of its data represents each view as a separate object. Each
///document view object implements <b>IOleDocumentView</b>, along with IOleInPlaceObject, IOleInPlaceActiveObject, and
///optional interfaces such as IPrint and IOleCommandTarget. A document object that supports only a single view does not
///require that view to be implemented as a separate object. Instead, both document and view can be implemented as a
///single class.
@GUID("B722BCC6-4E68-101B-A2BC-00AA00404770")
interface IOleDocumentView : IUnknown
{
    ///Associates a container's document view site with a document's view object.
    ///Params:
    ///    pIPSite = A pointer to the document view site's IOleInPlaceSite interface. This parameter can be <b>NULL</b>, in which
    ///              case the document view object loses all asociation with the container.
    ///Returns:
    ///    This method returns S_OK if a document view site was successfully associated (or disassociated if
    ///    <i>pIPSite</i> is <b>NULL</b>) with a document view object. Other possible return values include the
    ///    following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> </table>
    ///    
    HRESULT SetInPlaceSite(IOleInPlaceSite pIPSite);
    ///Retrieves the view site associated with this view object.
    ///Params:
    ///    ppIPSite = A pointer to an IOleInPlaceSite pointer variable that receives the interface pointer to the document's view
    ///               site.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include: <table> <tr> <th>Return code</th>
    ///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The
    ///    operation failed. </td> </tr> </table>
    ///    
    HRESULT GetInPlaceSite(IOleInPlaceSite* ppIPSite);
    ///Obtains the IUnknown interface pointer on the document object that owns this view.
    ///Params:
    ///    ppunk = A pointer to an IUnknown interface pointer that receives a pointer to the document object that owns this
    ///            view.
    ///Returns:
    ///    This method returns S_OK on success. S_OK is the only valid return value for this method.
    ///    
    HRESULT GetDocument(IUnknown* ppunk);
    ///Sets the rectangular coordinates of the viewport in which the view is to be activated or resets the coordinates
    ///of the viewport in which a view is currently activated.
    ///Params:
    ///    prcView = A pointer to a RECT structure containing the coordinates of the viewport.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> </table>
    ///    
    HRESULT SetRect(RECT* prcView);
    ///Retrieves the rectangular coordinates of the viewport in which the view is or will be activated.
    ///Params:
    ///    prcView = A pointer to a RECT structure to contain the coordinates of the current viewport set with
    ///              IOleDocumentView::SetRect.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> This view has not yet seen a call to IOleDocumentView::SetRect or
    ///    IOleDocumentView::SetRectComplex and therefore has no rectangle to return. </td> </tr> </table>
    ///    
    HRESULT GetRect(RECT* prcView);
    ///Sets the rectangular coordinates of the viewport, scroll bars, and size box.
    ///Params:
    ///    prcView = A pointer to a RECT structure containing the coordinates of the viewport.
    ///    prcHScroll = A pointer to a RECT structure containing the coordinates of the horizontal scroll bar.
    ///    prcVScroll = A pointer to a RECT structure containing the coordinates of the vertical scroll bar.
    ///    prcSizeBox = A pointer to a RECT structure containing the coordinates of the size box.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl>
    ///    </td> <td width="60%"> The document object that owns this view does not support complex rectangles. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetRectComplex(RECT* prcView, RECT* prcHScroll, RECT* prcVScroll, RECT* prcSizeBox);
    ///Activates or deactivates a view.
    ///Params:
    ///    fShow = If <b>TRUE</b>, the view is to show itself. If <b>FALSE</b>, the view is to hide itself.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory available for operation. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT Show(BOOL fShow);
    ///Activates or deactivates a document view's user interface elements, such as menus, toolbars, and accelerators.
    ///Params:
    ///    fUIActivate = If <b>TRUE</b>, the view is to activate its user interface. If <b>FALSE</b>, the view is to deactivate its
    ///                  user interface.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory available for operation. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT UIActivate(BOOL fUIActivate);
    ///Displays a document view in a separate pop-up window. The semantics are equivalent to IOleObject::DoVerb with
    ///OLEIVERB_OPEN.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory available for the operation. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error occurred.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The document
    ///    object that owns this view does not support separate window activation. </td> </tr> </table>
    ///    
    HRESULT Open();
    ///Instructs a document view to close itself and release its IOleInPlaceSite pointer.
    ///Params:
    ///    dwReserved = This parameter is reserved and cannot be <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT CloseView(uint dwReserved);
    ///Saves the view state into the specified stream.
    ///Params:
    ///    pstm = A pointer to the stream in which the view is to save its state data.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> The value in pstm is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This view has no meaningful state to save. This error
    ///    should be rare because most views have at least some state information worth saving. </td> </tr> </table>
    ///    
    HRESULT SaveViewState(IStream pstm);
    ///Initializes a view with view state previously saved in call to IOleDocumentView::SaveViewState.
    ///Params:
    ///    pstm = A pointer to a stream containing data from which the view should initialize itself.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> The value in <i>pstm</i> is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This view has no meaningful state to load. This error
    ///    should be rare because most views will have at least some state information worth loading. </td> </tr>
    ///    </table>
    ///    
    HRESULT ApplyViewState(IStream pstm);
    ///Creates a duplicate view object with an internal state identical to that of the current view.
    ///Params:
    ///    pIPSiteNew = A pointer to a IOleInPlaceSite interface that represents the view site in which the new view object will be
    ///                 activated. On receiving this pointer, the view being cloned should pass it to the new view's
    ///                 IOleDocumentView::SetInPlaceSite method. This pointer can be <b>NULL</b>, in which case the caller is
    ///                 responsible for calling <b>IOleDocumentView::SetInPlaceSite</b> on the new view directly.
    ///    ppViewNew = A pointer to an IOleDocumentView pointer variable that receives the interface pointer to the new view object.
    ///                The caller is responsible for releasing <i>ppViewNew</i> when it is no longer needed.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl>
    ///    </td> <td width="60%"> The value in <i>ppViewNew</i> is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> The view object does not implement this interface.
    ///    </td> </tr> </table>
    ///    
    HRESULT Clone(IOleInPlaceSite pIPSiteNew, IOleDocumentView* ppViewNew);
}

///Enumerates the views supported by a document object.
@GUID("B722BCC8-4E68-101B-A2BC-00AA00404770")
interface IEnumOleDocumentViews : IUnknown
{
    ///Retrieves the specified number of items in the enumeration sequence.
    ///Params:
    ///    cViews = The number of items to be retrieved. If there are fewer than the requested number of items left in the
    ///             sequence, this method retrieves the remaining elements. If <i>pcFetched</i> is <b>NULL</b>, this parameter
    ///             must be 1.
    ///    rgpView = An array of enumerated items. The enumerator is responsible for calling AddRef, and the caller is responsible
    ///              for calling Release through each pointer enumerated. If <i>cViews</i> is greater than 1, the caller must also
    ///              pass a non-<b>NULL</b> pointer passed to <i>pcFetched</i> to know how many pointers to release.
    ///    pcFetched = The number of items that were retrieved. This parameter is always less than or equal to the number of items
    ///                requested. This parameter can be <b>NULL</b>, in which case the <i>cViews</i> parameter must be 1.
    ///Returns:
    ///    If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Next(uint cViews, IOleDocumentView* rgpView, uint* pcFetched);
    ///Skips over the specified number of items in the enumeration sequence.
    ///Params:
    ///    cViews = The number of items to be skipped.
    ///Returns:
    ///    If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Skip(uint cViews);
    ///Resets the enumeration sequence to the beginning.
    ///Returns:
    ///    This method returns S_OK on success.
    ///    
    HRESULT Reset();
    ///Creates a new enumerator that contains the same enumeration state as the current one. This method makes it
    ///possible to record a particular point in the enumeration sequence and then return to that point at a later time.
    ///The caller must release this new enumerator separately from the first enumerator.
    ///Params:
    ///    ppEnum = A pointer to the IEnumOleDocumentViews interface pointer on the newly created enumerator. The caller must
    ///             release this enumerator separately from the one from which it was cloned.
    ///Returns:
    ///    This method returns S_OK on success. Other possible values include the following. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified enumerator is invalid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory
    ///    available for this operation. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumOleDocumentViews* ppEnum);
}

///Provides a generic callback mechanism for interruptible processes that should periodically ask an object whether to
///continue. The FContinue method is a generic continuation request. FContinuePrinting carries extra information
///pertaining to a printing process and is used in the context of IPrint.
@GUID("B722BCCA-4E68-101B-A2BC-00AA00404770")
interface IContinueCallback : IUnknown
{
    ///Indicates whether a generic operation should continue.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Continue the operation. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Cancel the operation as
    ///    soon as possible. </td> </tr> </table>
    ///    
    HRESULT FContinue();
    ///Indicates whether a lengthy printing operation should continue.
    ///Params:
    ///    nCntPrinted = The total number of pages that have been printed at the time the object receives a call to
    ///                  <b>FContinuePrinting</b>.
    ///    nCurPage = The page number of the page being printed at the time the object receives a call to <b>FContinuePrinting</b>.
    ///    pwszPrintStatus = A pointer to the message about the current status of the print job. The object being printed may or may not
    ///                      display this message to the user. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return value E_UNEXPECTED, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> Continue the printing operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Cancel the printing operation as soon as possible. </td>
    ///    </tr> </table>
    ///    
    HRESULT FContinuePrinting(int nCntPrinted, int nCurPage, ushort* pwszPrintStatus);
}

///Enables compound documents in general and active documents in particular to support programmatic printing.
@GUID("B722BCC9-4E68-101B-A2BC-00AA00404770")
interface IPrint : IUnknown
{
    ///Sets the page number of the first page of a document.
    ///Params:
    ///    nFirstPage = The page number of the first page.
    ///Returns:
    ///    This method can return the standard return values E_UNEXPECTED, E_FAIL, and S_OK.
    ///    
    HRESULT SetInitialPageNum(int nFirstPage);
    ///Retrieves the number of a document's first page and the total number of pages.
    ///Params:
    ///    pnFirstPage = A pointer to a variable that receives the page number of the first page. This parameter can be <b>NULL</b>,
    ///                  indicating that the caller is not interested in this number. If IPrint::SetInitialPageNum has been called,
    ///                  this parameter should contain the same value passed to that method. Otherwise, the value is the document's
    ///                  internal first page number.
    ///    pcPages = A pointer to a variable that receives the total number of pages in this document. This parameter can be
    ///              <b>NULL</b>, indicating that the caller is not interested in this number.
    ///Returns:
    ///    This method can return the standard return values E_UNEXPECTED and S_OK.
    ///    
    HRESULT GetPageInfo(int* pnFirstPage, int* pcPages);
    ///Prints an object on the specified printer, using the specified job requirements.
    ///Params:
    ///    grfFlags = A bitfield specifying print options from the <b>PRINTFLAG</b> enumeration.
    ///    pptd = A pointer to a DVTARGETDEVICE structure that describes the target print device.
    ///    ppPageSet = A pointer to a PAGESET pointer variable that receives a pointer to the structure that indicates which pages
    ///                are to be printed.
    ///    pstgmOptions = A pointer to object-specific printing options in a serialized OLE property set. This parameter can be
    ///                   <b>NULL</b> on input or return.
    ///    pcallback = A pointer to the IContinueCallback interface on the view site, which is to be periodically polled at
    ///                human-response speeds to determine whether printing should be abandoned. This parameter can be <b>NULL</b>.
    ///    nFirstPage = The page number of the first page to be printed. This value overrides any value previously passed to
    ///                 IPrint::SetInitialPageNum.
    ///    pcPagesPrinted = A pointer to a variable that receives the actual number of pages that were successfully printed.
    ///    pnLastPage = A pointer to a variable that receives the page number of the last page that was printed.
    ///Returns:
    ///    This method can return the standard return value E_UNEXPECTED, as well as the following values. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td>
    ///    <td width="60%"> The method completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>PRINT_E_CANCELED</b></dt> </dl> </td> <td width="60%"> The print process was canceled before
    ///    completion. *<i>pcPagesPrinted</i> indicates the number of pages that were in fact successfully printed
    ///    before this error occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>PRINT_E_NOSUCHPAGE</b></dt> </dl>
    ///    </td> <td width="60%"> A page specified in **<i>ppPageSet</i> or <i>nFirstPage</i> does not exist. </td>
    ///    </tr> </table>
    ///    
    HRESULT Print(uint grfFlags, DVTARGETDEVICE** pptd, PAGESET** ppPageSet, STGMEDIUM* pstgmOptions, 
                  IContinueCallback pcallback, int nFirstPage, int* pcPagesPrinted, int* pnLastPage);
}

///Enables objects and their containers to dispatch commands to each other. For example, an object's toolbars may
///contain buttons for commands such as <b>Print</b>, <b>Print Preview</b>, <b>Save</b>, <b>New</b>, and <b>Zoom</b>.
///Normal in-place activation guidelines recommend that you remove or disable such buttons because no efficient,
///standard mechanism has been available to dispatch them to the container. Similarly, a container has heretofore had no
///efficient means to send commands such as <b>Print</b>, <b>Page Setup</b>, and <b>Properties</b> to an in-place active
///object. Such simple command routing could have been handled through existing OLE Automation standards and the
///<b>IDispatch</b> interface, but the overhead with IDispatch is more than is required in the case of document objects.
///The <b>IOleCommandTarget</b> interface provides a simpler means to achieve the same ends. Available commands are
///defined by integer identifiers in a group. The group itself is identified with a GUID. The interface allows a caller
///both to query for support of one or more commands within a group and to issue a supported command to the object.
@GUID("B722BCCB-4E68-101B-A2BC-00AA00404770")
interface IOleCommandTarget : IUnknown
{
    ///Queries the object for the status of one or more commands generated by user interface events.
    ///Params:
    ///    pguidCmdGroup = The unique identifier of the command group; can be <b>NULL</b> to specify the standard group. All the
    ///                    commands that are passed in the <i>prgCmds</i> array must belong to the group specified by
    ///                    <i>pguidCmdGroup</i>.
    ///    cCmds = The number of commands in the <i>prgCmds</i> array.
    ///    prgCmds = A caller-allocated array of OLECMD structures that indicate the commands for which the caller needs status
    ///              information. This method fills the <b>cmdf</b> member of each structure with values taken from the OLECMDF
    ///              enumeration.
    ///    pCmdText = A pointer to an OLECMDTEXT structure in which to return name and/or status information of a single command.
    ///               This parameter can be <b>NULL</b> to indicate that the caller does not need this information.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt>
    ///    </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>prgCmds</i> argument is <b>NULL</b>. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>OLECMDERR_E_UNKNOWNGROUP</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>pguidCmdGroup</i> parameter is not <b>NULL</b> but does not specify a recognized command group. </td>
    ///    </tr> </table>
    ///    
    HRESULT QueryStatus(const(GUID)* pguidCmdGroup, uint cCmds, char* prgCmds, OLECMDTEXT* pCmdText);
    ///Executes the specified command or displays help for the command.
    ///Params:
    ///    pguidCmdGroup = The unique identifier of the command group; can be <b>NULL</b> to specify the standard group.
    ///    nCmdID = The command to be executed. This command must belong to the group specified with <i>pguidCmdGroup</i>.
    ///    nCmdexecopt = Specifies how the object should execute the command. Possible values are taken from the OLECMDEXECOPT and
    ///                  OLECMDID_WINDOWSTATE_FLAG enumerations.
    ///    pvaIn = A pointer to a VARIANTARG structure containing input arguments. This parameter can be <b>NULL</b>.
    ///    pvaOut = Pointer to a VARIANTARG structure to receive command output. This parameter can be <b>NULL</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLECMDERR_E_UNKNOWNGROUP</b></dt> </dl> </td> <td width="60%"> The <i>pguidCmdGroup</i> parameter is
    ///    not <b>NULL</b> but does not specify a recognized command group. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLECMDERR_E_NOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> The <i>nCmdID</i> parameter is not a
    ///    valid command in the group identified by <i>pguidCmdGroup</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLECMDERR_E_DISABLED</b></dt> </dl> </td> <td width="60%"> The command identified by <i>nCmdID</i> is
    ///    currently disabled and cannot be executed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLECMDERR_E_NOHELP</b></dt> </dl> </td> <td width="60%"> The caller has asked for help on the command
    ///    identified by <i>nCmdID</i>, but no help is available. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>OLECMDERR_E_CANCELED</b></dt> </dl> </td> <td width="60%"> The user canceled the execution of the
    ///    command. </td> </tr> </table>
    ///    
    HRESULT Exec(const(GUID)* pguidCmdGroup, uint nCmdID, uint nCmdexecopt, VARIANT* pvaIn, VARIANT* pvaOut);
}

@GUID("41B68150-904C-4E17-A0BA-A438182E359D")
interface IZoomEvents : IUnknown
{
    HRESULT OnZoomPercentChanged(uint ulZoomPercent);
}

@GUID("D81F90A3-8156-44F7-AD28-5ABB87003274")
interface IProtectFocus : IUnknown
{
    HRESULT AllowFocusChange(int* pfAllow);
}

@GUID("73C105EE-9DFF-4A07-B83C-7EFF290C266E")
interface IProtectedModeMenuServices : IUnknown
{
    HRESULT CreateMenu(HMENU* phMenu);
    HRESULT LoadMenuA(const(wchar)* pszModuleName, const(wchar)* pszMenuName, HMENU* phMenu);
    HRESULT LoadMenuID(const(wchar)* pszModuleName, ushort wResourceID, HMENU* phMenu);
}

///Implemented by containers and used by OLE common dialog boxes. It supports these dialog boxes by providing the
///methods needed to manage a container's links. The <b>IOleUILinkContainer</b> methods enumerate the links associated
///with a container, and specify how they should be updated, automatically or manually. They change the source of a link
///and obtain information associated with a link. They also open a link's source document, update links, and break a
///link to the source.
interface IOleUILinkContainerW : IUnknown
{
    ///Enumerates the links in a container.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. This value is only passed to other methods on this
    ///             interface, so it can be any value that uniquely identifies a link to the container. Containers frequently use
    ///             the pointer to the link's container site object for this value.
    ///Returns:
    ///    Returns a container's link identifiers in sequence; <b>NULL</b> if it has returned the last link.
    ///    
    uint    GetNextLink(uint dwLink);
    ///Sets a link's update options to automatic or manual.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. See IOleUILinkContainer::GetNextLink.
    ///    dwUpdateOpt = Update options, which can be automatic (OLEUPDATE_ALWAYS) or manual (OLEUPDATE_ONCALL).
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT SetLinkUpdateOptions(uint dwLink, uint dwUpdateOpt);
    ///Determines the current update options for a link.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. See IOleUILinkContainer::GetNextLink.
    ///    lpdwUpdateOpt = A pointer to the location that the current update options will be written.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT GetLinkUpdateOptions(uint dwLink, uint* lpdwUpdateOpt);
    ///Changes the source of a link.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. See IOleUILinkContainer::GetNextLink.
    ///    lpszDisplayName = Pointer to new source string to be parsed.
    ///    lenFileName = Length of the leading file name portion of the <i>lpszDisplayName</i> string. If the link source is not
    ///                  stored in a file, then <i>lenFileName</i> should be 0. For OLE links, call IOleLink::GetSourceDisplayName.
    ///    pchEaten = Pointer to the number of characters successfully parsed in <i>lpszDisplayName</i>.
    ///    fValidateSource = <b>TRUE</b> if the moniker should be validated; for OLE links, MkParseDisplayName should be called.
    ///                      <b>FALSE</b> if the moniker should not be validated. If possible, the link should accept the unvalidated
    ///                      source, and mark itself as unavailable.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The supplied identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient
    ///    memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT SetLinkSource(uint dwLink, const(wchar)* lpszDisplayName, uint lenFileName, uint* pchEaten, 
                          BOOL fValidateSource);
    ///Retrieves information about a link that can be displayed in the <b>Links</b> dialog box.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. See IOleUILinkContainer::GetNextLink.
    ///    lplpszDisplayName = Address of a pointer variable that receives a pointer to the full display name string for the link source.
    ///                        The <b>Links</b> dialog box will free this string.
    ///    lplenFileName = Pointer to the length of the leading file name portion of the <i>lplpszDisplayName</i> string. If the link
    ///                    source is not stored in a file, then <i>lplenFileName</i> should be 0. For OLE links, call
    ///                    IOleLink::GetSourceDisplayName.
    ///    lplpszFullLinkType = Address of a pointer variable that receives a pointer to the full link type string that is displayed at the
    ///                         bottom of the <b>Links</b> dialog box. The caller allocates this string. The <b>Links</b> dialog box will
    ///                         free this string. For OLE links, this should be the full User Type name. Use IOleObject::GetUserType,
    ///                         specifying USERCLASSTYPE_FULL for <i>dwFormOfType</i>.
    ///    lplpszShortLinkType = Address of a pointer variable that receives a pointer to the short link type string that is displayed in the
    ///                          listbox of the <b>Links</b> dialog box. The caller allocates this string. The <b>Links</b> dialog box will
    ///                          free this string. For OLE links, this should be the short user type name. Use IOleObject::GetUserType,
    ///                          specifying USERCLASSTYPE_SHORT for <i>dwFormOfType</i>.
    ///    lpfSourceAvailable = Pointer that returns <b>FALSE</b> if it is known that a link is unavailable since the link is to some known
    ///                         but unavailable document. Certain options, such as <b>Update Now</b>, are disabled (grayed in the user
    ///                         interface) for such cases.
    ///    lpfIsSelected = Pointer to a variable that tells the <b>Edit Links</b> dialog box that this link's entry should be selected
    ///                    in the dialog's multi-selection listbox. OleUIEditLinks calls this method at least once for each item to be
    ///                    placed in the links list. If none of them return <b>TRUE</b>, then none of them will be selected when the
    ///                    dialog box is first displayed. If all of them return <b>TRUE</b>, then all will be displayed. That is, it
    ///                    returns <b>TRUE</b> if this link is currently part of the selection in the underlying document, <b>FALSE</b>
    ///                    if not. Any links that are selected in the underlying document are selected in the dialog box; this way, the
    ///                    user can select a set of links and use the dialog box to update them or change their source(s)
    ///                    simultaneously.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT GetLinkSource(uint dwLink, ushort** lplpszDisplayName, uint* lplenFileName, 
                          ushort** lplpszFullLinkType, ushort** lplpszShortLinkType, int* lpfSourceAvailable, 
                          int* lpfIsSelected);
    ///Opens the link's source.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. Containers can use the pointer to the link's container
    ///             site for this value.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT OpenLinkSource(uint dwLink);
    ///Forces selected links to connect to their source and retrieve current information.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. Containers can use the pointer to the link's container
    ///             site for this value.
    ///    fErrorMessage = Determines whether the caller (implementer of IOleUILinkContainer) should show an error message upon failure
    ///                    to update a link. The <b>Update Links</b> dialog box sets this to <b>FALSE</b>. The <b>Object Properties</b>
    ///                    and <b>Links</b> dialog boxes set it to <b>TRUE</b>.
    ///    fReserved = This parameter is reserved and must be set to <b>FALSE</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT UpdateLink(uint dwLink, BOOL fErrorMessage, BOOL fReserved);
    ///Disconnects the selected links.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. Containers can use the pointer to the link's container
    ///             site for this value.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT CancelLink(uint dwLink);
}

///Implemented by containers and used by OLE common dialog boxes. It supports these dialog boxes by providing the
///methods needed to manage a container's links. The <b>IOleUILinkContainer</b> methods enumerate the links associated
///with a container, and specify how they should be updated, automatically or manually. They change the source of a link
///and obtain information associated with a link. They also open a link's source document, update links, and break a
///link to the source.
interface IOleUILinkContainerA : IUnknown
{
    ///Enumerates the links in a container.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. This value is only passed to other methods on this
    ///             interface, so it can be any value that uniquely identifies a link to the container. Containers frequently use
    ///             the pointer to the link's container site object for this value.
    ///Returns:
    ///    Returns a container's link identifiers in sequence; <b>NULL</b> if it has returned the last link.
    ///    
    uint    GetNextLink(uint dwLink);
    ///Sets a link's update options to automatic or manual.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. See IOleUILinkContainer::GetNextLink.
    ///    dwUpdateOpt = Update options, which can be automatic (OLEUPDATE_ALWAYS) or manual (OLEUPDATE_ONCALL).
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT SetLinkUpdateOptions(uint dwLink, uint dwUpdateOpt);
    ///Determines the current update options for a link.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. See IOleUILinkContainer::GetNextLink.
    ///    lpdwUpdateOpt = A pointer to the location that the current update options will be written.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT GetLinkUpdateOptions(uint dwLink, uint* lpdwUpdateOpt);
    ///Changes the source of a link.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. See IOleUILinkContainer::GetNextLink.
    ///    lpszDisplayName = Pointer to new source string to be parsed.
    ///    lenFileName = Length of the leading file name portion of the <i>lpszDisplayName</i> string. If the link source is not
    ///                  stored in a file, then <i>lenFileName</i> should be 0. For OLE links, call IOleLink::GetSourceDisplayName.
    ///    pchEaten = Pointer to the number of characters successfully parsed in <i>lpszDisplayName</i>.
    ///    fValidateSource = <b>TRUE</b> if the moniker should be validated; for OLE links, MkParseDisplayName should be called.
    ///                      <b>FALSE</b> if the moniker should not be validated. If possible, the link should accept the unvalidated
    ///                      source, and mark itself as unavailable.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The supplied identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient
    ///    memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT SetLinkSource(uint dwLink, const(char)* lpszDisplayName, uint lenFileName, uint* pchEaten, 
                          BOOL fValidateSource);
    ///Retrieves information about a link that can be displayed in the <b>Links</b> dialog box.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. See IOleUILinkContainer::GetNextLink.
    ///    lplpszDisplayName = Address of a pointer variable that receives a pointer to the full display name string for the link source.
    ///                        The <b>Links</b> dialog box will free this string.
    ///    lplenFileName = Pointer to the length of the leading file name portion of the <i>lplpszDisplayName</i> string. If the link
    ///                    source is not stored in a file, then <i>lplenFileName</i> should be 0. For OLE links, call
    ///                    IOleLink::GetSourceDisplayName.
    ///    lplpszFullLinkType = Address of a pointer variable that receives a pointer to the full link type string that is displayed at the
    ///                         bottom of the <b>Links</b> dialog box. The caller allocates this string. The <b>Links</b> dialog box will
    ///                         free this string. For OLE links, this should be the full User Type name. Use IOleObject::GetUserType,
    ///                         specifying USERCLASSTYPE_FULL for <i>dwFormOfType</i>.
    ///    lplpszShortLinkType = Address of a pointer variable that receives a pointer to the short link type string that is displayed in the
    ///                          listbox of the <b>Links</b> dialog box. The caller allocates this string. The <b>Links</b> dialog box will
    ///                          free this string. For OLE links, this should be the short user type name. Use IOleObject::GetUserType,
    ///                          specifying USERCLASSTYPE_SHORT for <i>dwFormOfType</i>.
    ///    lpfSourceAvailable = Pointer that returns <b>FALSE</b> if it is known that a link is unavailable since the link is to some known
    ///                         but unavailable document. Certain options, such as <b>Update Now</b>, are disabled (grayed in the user
    ///                         interface) for such cases.
    ///    lpfIsSelected = Pointer to a variable that tells the <b>Edit Links</b> dialog box that this link's entry should be selected
    ///                    in the dialog's multi-selection listbox. OleUIEditLinks calls this method at least once for each item to be
    ///                    placed in the links list. If none of them return <b>TRUE</b>, then none of them will be selected when the
    ///                    dialog box is first displayed. If all of them return <b>TRUE</b>, then all will be displayed. That is, it
    ///                    returns <b>TRUE</b> if this link is currently part of the selection in the underlying document, <b>FALSE</b>
    ///                    if not. Any links that are selected in the underlying document are selected in the dialog box; this way, the
    ///                    user can select a set of links and use the dialog box to update them or change their source(s)
    ///                    simultaneously.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT GetLinkSource(uint dwLink, byte** lplpszDisplayName, uint* lplenFileName, byte** lplpszFullLinkType, 
                          byte** lplpszShortLinkType, int* lpfSourceAvailable, int* lpfIsSelected);
    ///Opens the link's source.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. Containers can use the pointer to the link's container
    ///             site for this value.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT OpenLinkSource(uint dwLink);
    ///Forces selected links to connect to their source and retrieve current information.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. Containers can use the pointer to the link's container
    ///             site for this value.
    ///    fErrorMessage = Determines whether the caller (implementer of IOleUILinkContainer) should show an error message upon failure
    ///                    to update a link. The <b>Update Links</b> dialog box sets this to <b>FALSE</b>. The <b>Object Properties</b>
    ///                    and <b>Links</b> dialog boxes set it to <b>TRUE</b>.
    ///    fReserved = This parameter is reserved and must be set to <b>FALSE</b>.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT UpdateLink(uint dwLink, BOOL fErrorMessage, BOOL fReserved);
    ///Disconnects the selected links.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. Containers can use the pointer to the link's container
    ///             site for this value.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT CancelLink(uint dwLink);
}

///Implemented by containers and used by the container's <b>Object Properties</b> dialog box and by the <b>Convert</b>
///dialog box. It provides information used by the <b>General</b> and <b>View</b> pages of the <b>Object Properties</b>
///dialog box , which display information about the object's size, location, type, and name. It also allows the object
///to be converted using the <b>Convert</b> dialog box. The <b>View</b> page allows the object's icon to be modified
///from its original form, and its display aspect to be changed (iconic versus content). Optionally, you can have your
///implementation of this interface allow the scale of the object to be changed.
interface IOleUIObjInfoW : IUnknown
{
    ///Gets the size, type, name, and location information for an object.
    ///Params:
    ///    dwObject = Unique identifier for the object.
    ///    lpdwObjSize = Pointer to the object's size, in bytes, on disk. This may be an approximate value.
    ///    lplpszLabel = Address of a pointer variable that receives a pointer to the object's label string. This parameter may be
    ///                  <b>NULL</b> to indicate that the implementation should not return the label string.
    ///    lplpszType = Address of a pointer variable that receives a pointer to the object's long type string. This parameter may be
    ///                 <b>NULL</b> to indicate that the implementation should not return the long type string.
    ///    lplpszShortType = Address of a pointer variable that receives a pointer to the object's short type string. This parameter may
    ///                      be <b>NULL</b> to indicate that the implementation should not return the short type string.
    ///    lplpszLocation = Address of a pointer variable that receives a pointer to the object's source location string. This parameter
    ///                     may be <b>NULL</b> to indicate that the implementation should not return the location string.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> The specified identifier is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is insufficient memory available for this
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT GetObjectInfo(uint dwObject, uint* lpdwObjSize, ushort** lplpszLabel, ushort** lplpszType, 
                          ushort** lplpszShortType, ushort** lplpszLocation);
    ///Gets the conversion information associated with the specified object.
    ///Params:
    ///    dwObject = Unique identifier for the object.
    ///    lpClassID = Pointer to the location to return the object's CLSID.
    ///    lpwFormat = Pointer to the clipboard format of the object.
    ///    lpConvertDefaultClassID = Pointer to the default class, selected from the UI, to convert the object to.
    ///    lplpClsidExclude = Address of a pointer variable that receives a pointer to an array of CLSIDs that should be excluded from the
    ///                       user interface for this object. If <i>lpcClsidExclude</i> is zero, then <i>lpClsidExclude</i> is set to
    ///                       <b>NULL</b>.
    ///    lpcClsidExclude = Address of an output variable that receives the number of CLSIDs in <i>lplpClsidExclude</i>. This parameter
    ///                      may be zero.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT GetConvertInfo(uint dwObject, GUID* lpClassID, ushort* lpwFormat, GUID* lpConvertDefaultClassID, 
                           GUID** lplpClsidExclude, uint* lpcClsidExclude);
    ///Converts the object to the type of the specified CLSID.
    ///Params:
    ///    dwObject = A unique identifier for the object.
    ///    clsidNew = The CLSID.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT ConvertObject(uint dwObject, const(GUID)* clsidNew);
    ///Gets the view information associated with the object.
    ///Params:
    ///    dwObject = Unique identifier for the object.
    ///    phMetaPict = Pointer to the object's current icon. This parameter can be <b>NULL</b>, indicating that the caller is not
    ///                 interested in the object's current presentation.
    ///    pdvAspect = Pointer to the object's current aspect. This parameter can be <b>NULL</b>, indicating that the caller is not
    ///                interested in the object's current aspect, for example, DVASPECT_ICONIC or DVASPECT_CONTENT.
    ///    pnCurrentScale = Pointer to the object's current scale. This parameter can be <b>NULL</b>, indicating that the caller is not
    ///                     interested in the current scaling factor applied to the object in the container's view.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT GetViewInfo(uint dwObject, ptrdiff_t* phMetaPict, uint* pdvAspect, int* pnCurrentScale);
    ///Sets the view information associated with the object.
    ///Params:
    ///    dwObject = Unique identifier for the object.
    ///    hMetaPict = The new icon.
    ///    dvAspect = The new display aspect or view.
    ///    nCurrentScale = The new scale.
    ///    bRelativeToOrig = The new scale of the object, relative to the origin. This value is <b>TRUE</b> if the scale should be
    ///                      relative to the original scale of the object. If <b>FALSE</b>, <i>nCurrentScale</i> applies to the object's
    ///                      current size.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT SetViewInfo(uint dwObject, ptrdiff_t hMetaPict, uint dvAspect, int nCurrentScale, BOOL bRelativeToOrig);
}

///Implemented by containers and used by the container's <b>Object Properties</b> dialog box and by the <b>Convert</b>
///dialog box. It provides information used by the <b>General</b> and <b>View</b> pages of the <b>Object Properties</b>
///dialog box , which display information about the object's size, location, type, and name. It also allows the object
///to be converted using the <b>Convert</b> dialog box. The <b>View</b> page allows the object's icon to be modified
///from its original form, and its display aspect to be changed (iconic versus content). Optionally, you can have your
///implementation of this interface allow the scale of the object to be changed.
interface IOleUIObjInfoA : IUnknown
{
    ///Gets the size, type, name, and location information for an object.
    ///Params:
    ///    dwObject = Unique identifier for the object.
    ///    lpdwObjSize = Pointer to the object's size, in bytes, on disk. This may be an approximate value.
    ///    lplpszLabel = Address of a pointer variable that receives a pointer to the object's label string. This parameter may be
    ///                  <b>NULL</b> to indicate that the implementation should not return the label string.
    ///    lplpszType = Address of a pointer variable that receives a pointer to the object's long type string. This parameter may be
    ///                 <b>NULL</b> to indicate that the implementation should not return the long type string.
    ///    lplpszShortType = Address of a pointer variable that receives a pointer to the object's short type string. This parameter may
    ///                      be <b>NULL</b> to indicate that the implementation should not return the short type string.
    ///    lplpszLocation = Address of a pointer variable that receives a pointer to the object's source location string. This parameter
    ///                     may be <b>NULL</b> to indicate that the implementation should not return the location string.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> The specified identifier is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is insufficient memory available for this
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT GetObjectInfo(uint dwObject, uint* lpdwObjSize, byte** lplpszLabel, byte** lplpszType, 
                          byte** lplpszShortType, byte** lplpszLocation);
    ///Gets the conversion information associated with the specified object.
    ///Params:
    ///    dwObject = Unique identifier for the object.
    ///    lpClassID = Pointer to the location to return the object's CLSID.
    ///    lpwFormat = Pointer to the clipboard format of the object.
    ///    lpConvertDefaultClassID = Pointer to the default class, selected from the UI, to convert the object to.
    ///    lplpClsidExclude = Address of a pointer variable that receives a pointer to an array of CLSIDs that should be excluded from the
    ///                       user interface for this object. If <i>lpcClsidExclude</i> is zero, then <i>lpClsidExclude</i> is set to
    ///                       <b>NULL</b>.
    ///    lpcClsidExclude = Address of an output variable that receives the number of CLSIDs in <i>lplpClsidExclude</i>. This parameter
    ///                      may be zero.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT GetConvertInfo(uint dwObject, GUID* lpClassID, ushort* lpwFormat, GUID* lpConvertDefaultClassID, 
                           GUID** lplpClsidExclude, uint* lpcClsidExclude);
    ///Converts the object to the type of the specified CLSID.
    ///Params:
    ///    dwObject = A unique identifier for the object.
    ///    clsidNew = The CLSID.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT ConvertObject(uint dwObject, const(GUID)* clsidNew);
    ///Gets the view information associated with the object.
    ///Params:
    ///    dwObject = Unique identifier for the object.
    ///    phMetaPict = Pointer to the object's current icon. This parameter can be <b>NULL</b>, indicating that the caller is not
    ///                 interested in the object's current presentation.
    ///    pdvAspect = Pointer to the object's current aspect. This parameter can be <b>NULL</b>, indicating that the caller is not
    ///                interested in the object's current aspect, for example, DVASPECT_ICONIC or DVASPECT_CONTENT.
    ///    pnCurrentScale = Pointer to the object's current scale. This parameter can be <b>NULL</b>, indicating that the caller is not
    ///                     interested in the current scaling factor applied to the object in the container's view.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT GetViewInfo(uint dwObject, ptrdiff_t* phMetaPict, uint* pdvAspect, int* pnCurrentScale);
    ///Sets the view information associated with the object.
    ///Params:
    ///    dwObject = Unique identifier for the object.
    ///    hMetaPict = The new icon.
    ///    dvAspect = The new display aspect or view.
    ///    nCurrentScale = The new scale.
    ///    bRelativeToOrig = The new scale of the object, relative to the origin. This value is <b>TRUE</b> if the scale should be
    ///                      relative to the original scale of the object. If <b>FALSE</b>, <i>nCurrentScale</i> applies to the object's
    ///                      current size.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT SetViewInfo(uint dwObject, ptrdiff_t hMetaPict, uint dvAspect, int nCurrentScale, BOOL bRelativeToOrig);
}

///An extension of the IOleUILinkContainer interface. It returns the time that an object was last updated, which is link
///information that <b>IOleUILinkContainer</b> does not provide.
interface IOleUILinkInfoW : IOleUILinkContainerW
{
    ///Determines the last time the object was updated.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. Containers can use the pointer to the link's container
    ///             site for this value.
    ///    lpLastUpdate = A pointer to a FILETIME structure that indicates the time that the object was last updated.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT GetLastUpdate(uint dwLink, FILETIME* lpLastUpdate);
}

///An extension of the IOleUILinkContainer interface. It returns the time that an object was last updated, which is link
///information that <b>IOleUILinkContainer</b> does not provide.
interface IOleUILinkInfoA : IOleUILinkContainerA
{
    ///Determines the last time the object was updated.
    ///Params:
    ///    dwLink = Container-defined unique identifier for a single link. Containers can use the pointer to the link's container
    ///             site for this value.
    ///    lpLastUpdate = A pointer to a FILETIME structure that indicates the time that the object was last updated.
    ///Returns:
    ///    This method returns S_OK on success. Other possible return values include the following. <table> <tr>
    ///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient access permissions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The specified identifier is invalid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is
    ///    insufficient memory available for this operation. </td> </tr> </table>
    ///    
    HRESULT GetLastUpdate(uint dwLink, FILETIME* lpLastUpdate);
}

///Enables manipulation of call frames such as stack frames. The call frame is the body of information that a procedure
///must save to allow it to properly return to its caller. A call frame may exist on the stack or in registers. A stack
///frame maintains its caller's context information on the stack. An instance of the <b>ICallFrame</b> interface can
///perform various transformations on a call frame. The call can be marshaled or persisted. The instance of this
///interface is bound and has an associated method number.
@GUID("D573B4B0-894E-11D2-B8B6-00C04FB9618A")
interface ICallFrame : IUnknown
{
    ///Retrieves information about the call frame.
    ///Params:
    ///    pInfo = A pointer to a CALLFRAMEINFO structure.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT GetInfo(CALLFRAMEINFO* pInfo);
    ///Retrieves the interface ID or the method number.
    ///Params:
    ///    pIID = A pointer to the interface ID.
    ///    piMethod = A pointer to the method number.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT GetIIDAndMethod(GUID* pIID, uint* piMethod);
    ///Retrieves the method or interface name of this call.
    ///Params:
    ///    pwszInterface = A pointer to the interface name.
    ///    pwszMethod = A pointer to the method name.
    ///Returns:
    ///    If the requested name is not available, the return value is a null string. This method can also return the
    ///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetNames(ushort** pwszInterface, ushort** pwszMethod);
    ///Retrieves the stack location onto which this call frame is bound.
    ///Returns:
    ///    This method returns the requested stack location.
    ///    
    void*   GetStackLocation();
    ///Sets the stack location onto which this call frame is bound.
    ///Params:
    ///    pvStack = A pointer to the stack location.
    void    SetStackLocation(void* pvStack);
    ///Sets the return value within the call frame.
    ///Params:
    ///    hr = The new return value.
    void    SetReturnValue(HRESULT hr);
    ///Retrieves the return value stored in the call frame.
    ///Returns:
    ///    This method returns the <b>HRESULT</b> value stored in the call frame.
    ///    
    HRESULT GetReturnValue();
    ///Retrieves the information for the specified parameter.
    ///Params:
    ///    iparam = The parameter number.
    ///    pInfo = A pointer to a CALLFRAMEPARAMINFO structure.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT GetParamInfo(uint iparam, CALLFRAMEPARAMINFO* pInfo);
    ///Sets the value of a specified parameter in the call frame.
    ///Params:
    ///    iparam = The parameter number.
    ///    pvar = The new value for the parameter.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT SetParam(uint iparam, VARIANT* pvar);
    ///Retrieves the value of a specified parameter in the call frame.
    ///Params:
    ///    iparam = The parameter number.
    ///    pvar = The value of the parameter.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT GetParam(uint iparam, VARIANT* pvar);
    ///Creates a copy of this call frame and all of its associated data. <div class="alert"><b>Warning</b> The call
    ///frame does not clean up the copied data automatically. Therefore once the copy is returned then the user is
    ///responsible for calling Free on the frame copy. This must be done to avoid a memory leak.</div><div> </div>
    ///Params:
    ///    copyControl = Determines whether the copied call frame data can be shared with data in the parent frame by determining its
    ///                  lifetime dependency on the parent frame. For a list of values, see the CALLFRAME_COPY enumeration. If the
    ///                  CALLFRAME_COPY_NESTED flag is set, then the client will be responsible for using the copied call frame in a
    ///                  manner that its lifetime is nested in the lifetime of its parent frame making the data sharable. If the
    ///                  CALLFRAME_COPY_INDEPENDENT is set, then the lifetime of the copied frame will be independent of the parents.
    ///    pWalker = A pointer to an instance of the ICallFrameWalker interface. The OnWalkInterface method will be called for
    ///              each interface pointer that is copied. If this parameter is not provided, then any interface pointer that is
    ///              copied will be passed to AddRef.
    ///    ppFrame = A pointer to an ICallFrame pointer to a copy of the call frame.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Copy(CALLFRAME_COPY copyControl, ICallFrameWalker pWalker, ICallFrame* ppFrame);
    ///Frees the frame copy to avoid a memory leak. When a copy of a call frame is made with the Copy method, the call
    ///frame does not clean up the copied data automatically. Therefore, after a copy of the call frame is returned, the
    ///user is responsible for calling the <b>Free</b> method to free the frame copy and avoid a memory leak.
    ///Params:
    ///    pframeArgsDest = A pointer to an instance of the ICallFrame interface. Represents the stack pointer of the call frame to which
    ///                     the out parameters should be copied before the frame copy is freed. The destination frame is usually the
    ///                     parent frame from which the frame was originally copied. This parameter is optional. When freeing a frame and
    ///                     specifying a <i>pframeArgsDest</i> parameter which is in the same memory space as that of the receiver frame,
    ///                     then only the <i>pWalkerCopy</i> parameter is called on each interface pointer.
    ///    pWalkerDestFree = A pointer to an instance of the ICallFrameWalker interface. If there exist in and out parameters in
    ///                      <i>pframeArgsDest</i>, then the propagation requires that those values be freed. By providing the
    ///                      <i>pWalkerDestFree</i> object, interface pointers will be freed. If <i>pframeArgsDest</i> is <b>NULL</b>,
    ///                      then this parameter must also be <b>NULL</b> and the interface pointers should be released by calling the
    ///                      Release method.
    ///    pWalkerCopy = A pointer to an instance of the ICallFrameWalker interface. When the in and out parameters in
    ///                  <i>pframeArgsDest</i> are freed, then the propagation of out parameters is carried out. If this parameter is
    ///                  not specified, then the interface pointers will be passed to AddRef. This parameter is optional.
    ///    freeFlags = Flags from the CALLFRAME_FREE enumeration.
    ///    pWalkerFree = A pointer to an instance of the ICallFrameWalker interface. When specified, a callback is made for each
    ///                  interface pointer encountered while freeing occurs. If this parameter is not specified, then the interface
    ///                  pointers are freed by the Release method.
    ///    nullFlags = Flags from the CALLFRAME_NULL enumeration.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT Free(ICallFrame pframeArgsDest, ICallFrameWalker pWalkerDestFree, ICallFrameWalker pWalkerCopy, 
                 uint freeFlags, ICallFrameWalker pWalkerFree, uint nullFlags);
    ///Frees the specified parameter in the frame.
    ///Params:
    ///    iparam = The number of the parameter to be freed.
    ///    freeFlags = Represents flags from the CALLFRAME_FREE enumeration.
    ///    pWalkerFree = A pointer to an instance of the ICallFrameWalker interface. When specified, a callback is made for each
    ///                  interface pointer encountered while freeing occurs. If this parameter is not specified, then the interface
    ///                  pointers are freed by the Release method.
    ///    nullFlags = Represents flags from the CALLFRAME_NULL enumeration.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT FreeParam(uint iparam, uint freeFlags, ICallFrameWalker pWalkerFree, uint nullFlags);
    ///Searches for interface pointers that are reachable from [in], [in, out], or [out] parameters of the frame.
    ///Params:
    ///    walkWhat = Flags from the CALLFRAME_WALK enumeration.
    ///    pWalker = A pointer to an instance of the ICallFrameWalker interface. When specified, a call back is made for each
    ///              interface pointer encountered. This parameter is optional.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT WalkFrame(uint walkWhat, ICallFrameWalker pWalker);
    ///Retrieves an upper bound on the number of bytes needed to marshal the call frame. Usually an interface proxy
    ///calls this method to learn how big a buffer is needed, allocates the buffer, and then calls the Marshal method to
    ///carry out the marshalling.
    ///Params:
    ///    pmshlContext = A pointer to the CALLFRAME_MARSHALCONTEXT structure containing context information about how marshalling is
    ///                   carried out.
    ///    mshlflags = Indicates whether the data to be marshaled is to be transmitted back to the client process - the normal case
    ///                - or written to a global table, where it can be retrieved by multiple clients. For a list of values, see the
    ///                MSHLFLAGS enumeration.
    ///    pcbBufferNeeded = A pointer to the size of the buffer, in bytes, that will be needed to marshal the call frame.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT* pmshlContext, MSHLFLAGS mshlflags, uint* pcbBufferNeeded);
    ///Marshals the call frame by turning its reachable data into a flat buffer without disturbing the frame.
    ///Params:
    ///    pmshlContext = A pointer to the CALLFRAME_MARSHALCONTEXT structure containing context information about how marshalling is
    ///                   carried out.
    ///    mshlflags = Flag indicating whether the data to be marshaled is to be transmitted back to the client process - the normal
    ///                case - or written to a global table, where it can be retrieved by multiple clients. The possible values are
    ///                from the MSHLFLAGS enumeration.
    ///    pBuffer = A pointer to the buffer into which the marshaled data is to be placed.
    ///    cbBuffer = The size of the buffer, in bytes.
    ///    pcbBufferUsed = Receives the size of the buffer that was actually used. This parameter is optional.
    ///    pdataRep = Receives the NDR data representation with which the data was marshaled. This parameter is optional. For more
    ///               information, see IRpcChannelBuffer::GetBuffer.
    ///    prpcFlags = Receives an RPC flag associated with the call. This parameter is optional. For more information, see
    ///                IRpcChannelBuffer::GetBuffer.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT Marshal(CALLFRAME_MARSHALCONTEXT* pmshlContext, MSHLFLAGS mshlflags, void* pBuffer, uint cbBuffer, 
                    uint* pcbBufferUsed, uint* pdataRep, uint* prpcFlags);
    ///Unmarshals a packet of data containing the previously marshaled [out] parameters of a call into this already
    ///existing activation record.
    ///Params:
    ///    pBuffer = A pointer to the buffer containing the marshaled [out] values.
    ///    cbBuffer = The size of the buffer, in bytes.
    ///    dataRep = The NDR data representation with which the data was marshaled. For more information, see
    ///              IRpcChannelBuffer::GetBuffer.
    ///    pcontext = A pointer to the CALLFRAME_MARSHALCONTEXT structure containing context information about how unmarshalling is
    ///               carried out.
    ///    pcbUnmarshalled = Receives the number of bytes that were successfully unmarshaled. This parameter is returned even in error
    ///                      situations. This parameter is optional.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT Unmarshal(void* pBuffer, uint cbBuffer, uint dataRep, CALLFRAME_MARSHALCONTEXT* pcontext, 
                      uint* pcbUnmarshalled);
    ///Releases resources that are held by interface pointers residing in a packet of marshaled data. This method finds
    ///all interface pointers in the packet, and calls the CoReleaseMarshalData function on each one.
    ///Params:
    ///    pBuffer = A pointer to the buffer containing the marshaled [out] values.
    ///    cbBuffer = The size of the buffer, in bytes.
    ///    ibFirstRelease = The first byte in the buffer, which is to be released. A value of zero implies that the interface pointers in
    ///                     the whole buffer are to be released. The marshaled interface pointers are assumed to have been released by
    ///                     some other mechanism.
    ///    dataRep = The data representation with which the data was marshaled.
    ///    pcontext = A pointer to the CALLFRAME_MARSHALCONTEXT structure containing context information about how un-marshalling
    ///               is carried out.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT ReleaseMarshalData(void* pBuffer, uint cbBuffer, uint ibFirstRelease, uint dataRep, 
                               CALLFRAME_MARSHALCONTEXT* pcontext);
    ///Applies this activation record to an object. In a marshalling situation, typically this is carried out on the
    ///server side, and is the means by which the work of the actual object is accomplished.
    ///Params:
    ///    pvReceiver = The interface on which the invocation is to occur. The caller is responsible for ensuring that this interface
    ///                 is of the appropriate IID; the implementation will simply do a cast and assume that is the case.
    ///    arg2 = Additional parameters.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CALLFRAME_E_ALREADYINVOKED</b></dt> </dl> </td>
    ///    <td width="60%"> An invocation has already been made from this frame. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT Invoke(void* pvReceiver);
}

///Invokes an object with an indirect reference to the invocations arguments, rather than the traditional direct call.
///An instance of <b>ICallIndirect</b> supports indirect invocations for only one interface ID.
@GUID("D573B4B1-894E-11D2-B8B6-00C04FB9618A")
interface ICallIndirect : IUnknown
{
    ///Invokes one of the methods in the interface with an indirect reference to the arguments of the invocation.
    ///Params:
    ///    phrReturn = The value returned from the invocation of the method.
    ///    iMethod = The method number to be invoked.
    ///    pvArgs = A pointer to the stack frame with which to make the invocation. Details of the exact representation of this
    ///             stack frame are processor-architecture specific.
    ///    cbArgs = The number of bytes to be popped from the stack to clear the stack of arguments to this invocation.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT CallIndirect(int* phrReturn, uint iMethod, void* pvArgs, uint* cbArgs);
    ///Retrieves information about the interface method from the call frame.
    ///Params:
    ///    iMethod = The method number.
    ///    pInfo = A pointer to the CALLFRAMEINFO structure containing information about the specified method.
    ///    pwszMethod = The method name. This parameter is optional.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT GetMethodInfo(uint iMethod, CALLFRAMEINFO* pInfo, ushort** pwszMethod);
    ///Retrieves the number of bytes that should be popped from the stack in order to return from an invocation of the
    ///method.
    ///Params:
    ///    iMethod = The method number.
    ///    cbArgs = The number of bytes to be popped from the stack to clear the stack of arguments to an invocation.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT GetStackSize(uint iMethod, uint* cbArgs);
    ///Retrieves the interface id supported by this ICallIndirect implementation.
    ///Params:
    ///    piid = A pointer to the interface. This parameter is optional.
    ///    pfDerivesFromIDispatch = Indicates whether the interface is derived from <b>IDispatch</b>. This parameter is optional.
    ///    pcMethod = Receives the number of methods in the inferface.
    ///    pwszInterface = Receives the interface name if it is available.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT GetIID(GUID* piid, int* pfDerivesFromIDispatch, uint* pcMethod, ushort** pwszInterface);
}

///Supports the registration and un-registering of event sinks wishing to be notified of calls made directly on the
///interface. In addition, this interface provides a means by which an invocation can be carried out with an indirect
///reference to the invocations arguments.
@GUID("60C7CA75-896D-11D2-B8B6-00C04FB9618A")
interface ICallInterceptor : ICallIndirect
{
    ///Registers an event sink for receiving notifications of method calls. Only a single event sink may be registered
    ///with an interceptor at a time. Registering a sink of <b>NULL</b> is legal, and causes the interceptor to release
    ///any previously registered sink that it might be holding on to.
    ///Params:
    ///    psink = A pointer to the event sink. See ICallFrameEvents.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT RegisterSink(ICallFrameEvents psink);
    ///Retrieves the registered event sink.
    ///Params:
    ///    ppsink = A pointer to a pointer to the event sink. See ICallFrameEvents.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CO_E_OBJNOTREG</b></dt> </dl> </td> <td
    ///    width="60%"> No event sink is registered with this interceptor. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error has occurred. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetRegisteredSink(ICallFrameEvents* ppsink);
}

///Delivers method call notifications.
@GUID("FD5E0843-FC91-11D0-97D7-00C04FB9618A")
interface ICallFrameEvents : IUnknown
{
    ///Informs the event sink if it receives a method call on the interceptor. The sink is provided with an ICallFrame
    ///instance which is bound to the intercepted incoming method invocation. Through that sink the call frame can be
    ///manipulated in various ways.
    ///Params:
    ///    pFrame = A call frame bound to the just-received invocation.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT OnCall(ICallFrame pFrame);
}

///Is used on the server (receiving) side of a remote invocation. An appropriate instance of <b>ICallUnmarshal</b> can
///be used to transform back into an call frame a method invocation previously marshaled by a call to
///ICallFrame::Marshal on the client (sending) side. After such a reconstituted call frame is obtained, the call can be
///carried out on an actual object using ICallFrame::Invoke.
@GUID("5333B003-2E42-11D2-B89D-00C04FB9618A")
interface ICallUnmarshal : IUnknown
{
    ///Turns a marshaled packet of data back into an activation record that can then be invoked or manipulated in some
    ///other way.
    ///Params:
    ///    iMethod = The method number. If this parameter is -1, the method number will be determined from the data to be
    ///              unmarshaled.
    ///    pBuffer = A pointer to the buffer from which the activation record is to be created.
    ///    cbBuffer = The size of the buffer, in bytes.
    ///    fForceBufferCopy = Indicates whether the buffer should be copied and retained (nonzero) or the buffer will remain valid (zero).
    ///    dataRep = The data representation with which the data was marshaled.
    ///    pcontext = A pointer to a CALLFRAME_MARSHALCONTEXT structure that contains information about the context in which
    ///               unmarshaling is to be carried out.
    ///    pcbUnmarshalled = A pointer to the number of bytes that were successfully unmarshaled.
    ///    ppFrame = A call frame bound to the umarshaled invocation.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT Unmarshal(uint iMethod, void* pBuffer, uint cbBuffer, BOOL fForceBufferCopy, uint dataRep, 
                      CALLFRAME_MARSHALCONTEXT* pcontext, uint* pcbUnmarshalled, ICallFrame* ppFrame);
    ///Releases resources that may be held by interface pointers residing in a packet of marshaled data. This method
    ///finds all interface pointers in the packet and calls the CoReleaseMarshalData function on each interface pointer.
    ///Params:
    ///    iMethod = The method number.
    ///    pBuffer = A pointer to the buffer containing the marshaled out parameters.
    ///    cbBuffer = The size of the buffer, in bytes.
    ///    ibFirstRelease = The first byte in the buffer to be released. A value of zero implies that the interface pointers in the whole
    ///                     buffer are to be released. The idea is that marshaled interface pointers prior to the indicated byte are
    ///                     assumed to have already been released by some other mechanism.
    ///    dataRep = The data representation with which the data was marshaled.
    ///    pcontext = A pointer to a CALLFRAME_MARSHALCONTEXT structure that contains information about the context in which
    ///               unmarshaling is to be carried out.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT ReleaseMarshalData(uint iMethod, void* pBuffer, uint cbBuffer, uint ibFirstRelease, uint dataRep, 
                               CALLFRAME_MARSHALCONTEXT* pcontext);
}

///Walks a stack frame looking for interesting values.
@GUID("08B23919-392D-11D2-B8A4-00C04FB9618A")
interface ICallFrameWalker : IUnknown
{
    ///Walks through a call frame to look for the specified interface in the call frame. The interface can be
    ///manipulated or replaced by paying close attention to the reference count.
    ///Params:
    ///    iid = The IID of the interface to be found.
    ///    ppvInterface = A points to the buffer from which the activation record is to be reconstituted.
    ///    fIn = This parameter is nonzero if an interface is inside an [in] or [in, out] parameter.
    ///    fOut = This parameter is nonzero if an interface is inside an [out] or [in, out] parameter.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> An unexpected error has occurred. </td> </tr> </table>
    ///    
    HRESULT OnWalkInterface(const(GUID)* iid, void** ppvInterface, BOOL fIn, BOOL fOut);
}

@GUID("D1FB5A79-7706-11D1-ADBA-00C04FC2ADC0")
interface IInterfaceRelated : IUnknown
{
    HRESULT SetIID(const(GUID)* iid);
    HRESULT GetIID(GUID* piid);
}

///Provides generic low-level logging functionality. The Common Log File System (CLFS), provides functionality that is a
///superset of that provided by <b>ILog</b>.
@GUID("FF222117-0C6C-11D2-B89A-00C04FB9618A")
interface ILog : IUnknown
{
    ///Forces the contents of the log to disk, at least up through the specified LSN.
    ///Params:
    ///    lsnMinToForce = At the very least, all records that have not yet been written to disk with an LSN less than or equal to
    ///                    <i>lsnMinToForce</i> must be written to disk now. An implementation may, however, choose to write more
    ///                    records than what is strictly required. For example, an implementation is allowed to force all records to
    ///                    disk, regardless of the value of <i>lsnMinToForce</i>. Passing 0 as <i>lsnMinToForce</i> indicates that the
    ///                    entire log is to be forced to disk.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Force(LARGE_INTEGER lsnMinToForce);
    ///Write a new record to the end of the log.
    ///Params:
    ///    rgBlob = A pointer to an array of BLOBs of data to be written.
    ///    cBlob = The size of the <i>rgBlob</i> array, in elements.
    ///    fForceNow = Indicates whether to force the data to disk. If <b>TRUE</b>, the contents of the log up to this record must
    ///                be forced to disk before the call returns. If <b>FALSE</b>, this record may be buffered in memory to be
    ///                written after the call returns successfully.
    ///    plsn = A pointer to the LSN of the newly appended record. If the LSN of the newly appended record is not needed,
    ///           this parameter can be <b>NULL</b>.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT AppendRecord(char* rgBlob, uint cBlob, BOOL fForceNow, LARGE_INTEGER* plsn);
    ///Read a record from the log.
    ///Params:
    ///    lsnToRead = The LSN of the record to be read.
    ///    plsnPrev = A pointer to the LSN of the previous record (the record immediately preceding the record to be read). This
    ///               parameter can be <b>NULL</b> if the LSN of the previous record is not needed. This parameter is 0 if there is
    ///               no previous record in the log, or if an error occurs.
    ///    plsnNext = A pointer to the LSN of the next record (the record immediately following the record to read). This parameter
    ///               can be <b>NULL</b> if the LSN of the next record is not needed. This parameter is MAXLSN (0x7FFFFFFFFFFFFFFF)
    ///               if there is no next record in the log. This parameter is 0 if an error occurs.
    ///    ppbData = A pointer to a variable that will contain a pointer to the record data on return. The memory for this data is
    ///              allocated by <b>ReadRecord</b> and freed by the caller (see CoTaskMemFree). This parameter is <b>NULL</b> if
    ///              an error occurs.
    ///    pcbData = A pointer to a variable that receives the size of the record data, in bytes, on return.
    ///Returns:
    ///    This method can return the following values, as well as other <b>HRESULT</b> values. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The record was successfully read from the log. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>XACT_E_INVALIDLSN</b></dt> </dl> </td> <td width="60%"> <i>lsnToRead</i> is outside of the current
    ///    limits of the log. See ILog::GetLogLimits. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>lsnToRead</i> is within the current limits of
    ///    the log, but it is not the LSN of a record in the log. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The record was not returned due to a lack of
    ///    memory. </td> </tr> </table>
    ///    
    HRESULT ReadRecord(LARGE_INTEGER lsnToRead, LARGE_INTEGER* plsnPrev, LARGE_INTEGER* plsnNext, char* ppbData, 
                       uint* pcbData);
    ///Reads an initial part of a record from the log.
    ///Params:
    ///    lsnToRead = The LSN of the record to be read.
    ///    plsnPrev = A pointer to the LSN of the previous record (the record immediately preceding the record to read). You may
    ///               pass <b>NULL</b> if the LSN of the previous record is not needed. This parameter is 0 if there is no previous
    ///               record in the log or if an error occurs.
    ///    plsnNext = A pointer to the LSN of the next record (the record immediately following the record to read). You may pass
    ///               <b>NULL</b> if the LSN of the next record is not needed. This parameter is MAXLSN (0x7FFFFFFFFFFFFFFF) if
    ///               there is no next record in the log. This parameter is 0 if an error occurs.
    ///    pbData = A pointer to a buffer into which the record data is to be read.
    ///    pcbData = A pointer to a variable that contains the size in bytes of the buffer on input, and will contain the size in
    ///              bytes of the record data read on return.
    ///    pcbRecord = A pointer to a variable that will contain the size in bytes of the entire record on return. You may pass
    ///                <b>NULL</b> if the size of the entire record is not needed.
    ///Returns:
    ///    This method can return the following values, as well as other <b>HRESULT</b> values. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The record was successfully read from the log. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>XACT_E_INVALIDLSN</b></dt> </dl> </td> <td width="60%"> <i>lsnToRead</i> is outside of the current
    ///    limits of the log. See ILog::GetLogLimits. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>lsnToRead</i> is within the current limits of
    ///    the log, but it is not the LSN of a record in the log. </td> </tr> </table>
    ///    
    HRESULT ReadRecordPrefix(LARGE_INTEGER lsnToRead, LARGE_INTEGER* plsnPrev, LARGE_INTEGER* plsnNext, 
                             char* pbData, uint* pcbData, uint* pcbRecord);
    ///Retrieves information about the current bounds of the log.
    ///Params:
    ///    plsnFirst = A pointer to the LSN of the first record in the log. This parameter can be <b>NULL</b> if the LSN of the
    ///                first record is not needed.
    ///    plsnLast = A pointer to the LSN of the last record in the log. This parameter can be <b>NULL</b> if the LSN of the last
    ///               record is not needed.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetLogLimits(LARGE_INTEGER* plsnFirst, LARGE_INTEGER* plsnLast);
    ///Throws away the specified prefix of the log, making it no longer retrievable.
    ///Params:
    ///    lsnFirstToKeep = The LSN of the first record not to be thrown away. If this parameter is 0, the entire log is emptied.
    ///Returns:
    ///    This method can return the following values, as well as other <b>HRESULT</b> values. <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The log was successfully truncated. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> <i>lsnFirstToKeep</i> is outside the current limits
    ///    of the log. See ILog::GetLogLimits. </td> </tr> </table>
    ///    
    HRESULT TruncatePrefix(LARGE_INTEGER lsnFirstToKeep);
    ///Provides a hint to the implementation about the pattern in which records will be read.
    ///Params:
    ///    policy = The pattern in which records will most often be read. For more information, see the RECORD_READING_POLICY
    ///             enumeration.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetAccessPolicyHint(RECORD_READING_POLICY policy);
}

///Initializes an instance of a file based implementation of ILog.
@GUID("00951E8C-1294-11D1-97E4-00C04FB9618A")
interface IFileBasedLogInit : IUnknown
{
    ///Create a new log instance on the specified file. If a file with that name already exists, it is overwritten.
    ///Params:
    ///    filename = The absolute path of the file to be created.
    ///    cbCapacityHint = A hint to the implementation about the total capacity that will be needed.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT InitNew(const(wchar)* filename, uint cbCapacityHint);
}

///Enables clients to enumerate through a collection of class IDs for COM classes.
@GUID("0002E000-0000-0000-C000-000000000046")
interface IEnumGUID : IUnknown
{
    ///Retrieves the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be retrieved. If there are fewer than the requested number of items left in the
    ///           sequence, this method retrieves the remaining elements.
    ///    rgelt = An array of enumerated items. The enumerator is responsible for allocating any memory, and the caller is
    ///            responsible for freeing it. If <i>celt</i> is greater than 1, the caller must also pass a non-NULL pointer
    ///            passed to <i>pceltFetched</i> to know how many pointers to release.
    ///    pceltFetched = The number of items that were retrieved. This parameter is always less than or equal to the number of items
    ///                   requested.
    ///Returns:
    ///    If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Skips over the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be skipped.
    ///Returns:
    ///    If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Skip(uint celt);
    ///Resets the enumeration sequence to the beginning.
    ///Returns:
    ///    The return value is S_OK.
    ///    
    HRESULT Reset();
    ///Creates a new enumerator that contains the same enumeration state as the current one. This method makes it
    ///possible to record a point in the enumeration sequence in order to return to that point at a later time. The
    ///caller must release this new enumerator separately from the first enumerator.
    ///Params:
    ///    ppenum = A pointer to the cloned enumerator object.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.
    ///    
    HRESULT Clone(IEnumGUID* ppenum);
}

///Enumerates component categories registered in the system.
@GUID("0002E011-0000-0000-C000-000000000046")
interface IEnumCATEGORYINFO : IUnknown
{
    ///Retrieves the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be retrieved. If there are fewer than the requested number of items left in the
    ///           sequence, this method retrieves the remaining elements.
    ///    rgelt = An array of enumerated items. The enumerator is responsible for allocating any memory, and the caller is
    ///            responsible for freeing it. If <i>celt</i> is greater than 1, the caller must also pass a non-NULL pointer
    ///            passed to <i>pceltFetched</i> to know how many pointers to release.
    ///    pceltFetched = The number of items that were retrieved. This parameter is always less than or equal to the number of items
    ///                   requested.
    ///Returns:
    ///    If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Next(uint celt, char* rgelt, uint* pceltFetched);
    ///Skips over the specified number of items in the enumeration sequence.
    ///Params:
    ///    celt = The number of items to be skipped.
    ///Returns:
    ///    If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.
    ///    
    HRESULT Skip(uint celt);
    ///Resets the enumeration sequence to the beginning.
    ///Returns:
    ///    The return value is S_OK.
    ///    
    HRESULT Reset();
    ///Creates a new enumerator that contains the same enumeration state as the current one. This method makes it
    ///possible to record a point in the enumeration sequence in order to return to that point at a later time. The
    ///caller must release this new enumerator separately from the first enumerator.
    ///Params:
    ///    ppenum = A pointer to the cloned enumerator object.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.
    ///    
    HRESULT Clone(IEnumCATEGORYINFO* ppenum);
}

///Provides methods for registering and unregistering component category information in the registry. This includes both
///the human-readable names of categories and the categories implemented/required by a given component or class.
@GUID("0002E012-0000-0000-C000-000000000046")
interface ICatRegister : IUnknown
{
    ///Registers one or more component categories. Each component category consists of a CATID and a list of
    ///locale-dependent description strings.
    ///Params:
    ///    cCategories = The number of component categories to be registered.
    ///    rgCategoryInfo = An array of CATEGORYINFO structures, one for each category to be registered. By providing the same CATID for
    ///                     multiple <b>CATEGORYINFO</b> structures, multiple locales can be registered for the same component category.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One or more arguments are incorrect. </td> </tr> </table>
    ///    
    HRESULT RegisterCategories(uint cCategories, char* rgCategoryInfo);
    ///Removes the registration of one or more component categories. Each component category consists of a CATID and a
    ///list of locale-dependent description strings.
    ///Params:
    ///    cCategories = The number of categories to be removed.
    ///    rgcatid = The CATIDs of the categories to be removed.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One or more arguments are incorrect. </td> </tr> </table>
    ///    
    HRESULT UnRegisterCategories(uint cCategories, char* rgcatid);
    ///Registers the class as implementing one or more component categories.
    ///Params:
    ///    rclsid = The class identifier.
    ///    cCategories = The number of categories to be associated as category identifiers for the class.
    ///    rgcatid = An array of CATIDs to associate as category identifiers for the class.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One or more arguments are incorrect. </td> </tr> </table>
    ///    
    HRESULT RegisterClassImplCategories(const(GUID)* rclsid, uint cCategories, char* rgcatid);
    ///Removes one or more implemented category identifiers from a class.
    ///Params:
    ///    rclsid = The class identifier.
    ///    cCategories = The number of category CATIDs to be removed.
    ///    rgcatid = An array of CATIDs that are to be removed. Only the category IDs specified in this array are removed.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One or more arguments are incorrect. </td> </tr> </table>
    ///    
    HRESULT UnRegisterClassImplCategories(const(GUID)* rclsid, uint cCategories, char* rgcatid);
    ///Registers the class as requiring one or more component categories.
    ///Params:
    ///    rclsid = The class identifier.
    ///    cCategories = The number of category CATIDs to be associated as category identifiers for the class.
    ///    rgcatid = An array of CATIDs to be associated as category identifiers for the class.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One or more arguments are incorrect. </td> </tr> </table>
    ///    
    HRESULT RegisterClassReqCategories(const(GUID)* rclsid, uint cCategories, char* rgcatid);
    ///Removes one or more required category identifiers from a class.
    ///Params:
    ///    rclsid = The class identifier.
    ///    cCategories = The number of category CATIDs to be removed.
    ///    rgcatid = An array of CATIDs that are to be removed. Only the category IDs specified in this array are removed.
    ///Returns:
    ///    This method can return the following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One or more arguments are incorrect. </td> </tr> </table>
    ///    
    HRESULT UnRegisterClassReqCategories(const(GUID)* rclsid, uint cCategories, char* rgcatid);
}

///Obtains information about the categories implemented or required by a certain class, as well as information about the
///categories registered on the specified computer.
@GUID("0002E013-0000-0000-C000-000000000046")
interface ICatInformation : IUnknown
{
    ///Retrieves an enumerator for the component categories registered on the system.
    ///Params:
    ///    lcid = The requested locale for any return szDescription of the enumerated categories. Typically, the caller
    ///           specifies the value returned from the GetUserDefaultLCID function.
    ///    ppenumCategoryInfo = A pointer to a pointer to an IEnumCATEGORYINFO interface. This can be used to enumerate the CATIDs and
    ///                         localized description strings of the component categories registered with the system.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.
    ///    
    HRESULT EnumCategories(uint lcid, IEnumCATEGORYINFO* ppenumCategoryInfo);
    ///Retrieves the localized description string for a specific category ID.
    ///Params:
    ///    rcatid = The category identifier.
    ///    lcid = The locale.
    ///    pszDesc = A pointer to the string pointer for the description. This string must be released by the caller using the
    ///              CoTaskMemFree function.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK, as well as the
    ///    following values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>CAT_E_CATIDNOEXIST</b></dt> </dl> </td> <td width="60%"> The category ID <i>rcatid</i> is not
    ///    registered. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>CAT_E_NODESCRIPTION</b></dt> </dl> </td> <td
    ///    width="60%"> There is no description string for <i>rcatid</i> with the specified locale. </td> </tr> </table>
    ///    
    HRESULT GetCategoryDesc(GUID* rcatid, uint lcid, ushort** pszDesc);
    ///Retrieves an enumerator for the classes that implement one or more specified category identifiers.
    ///Params:
    ///    cImplemented = The number of category IDs in the <i>rgcatidImpl</i> array. This value cannot be zero. If this value is -1,
    ///                   classes are included in the enumeration, regardless of the categories they implement.
    ///    rgcatidImpl = An array of category identifiers. If a class requires a category identifier that is not specified, it is not
    ///                  included in the enumeration.
    ///    cRequired = The number of category IDs in the <i>rgcatidReq</i> array. This value can be zero. If this value is -1,
    ///                classes are included in the enumeration, regardless of the categories they require.
    ///    rgcatidReq = An array of category identifiers.
    ///    ppenumClsid = A pointer to an IEnumCLSID interface pointer that can be used to enumerate the CLSIDs of the classes that
    ///                  implement the specified category.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.
    ///    
    HRESULT EnumClassesOfCategories(uint cImplemented, const(GUID)* rgcatidImpl, uint cRequired, 
                                    const(GUID)* rgcatidReq, IEnumGUID* ppenumClsid);
    ///Determines whether a class implements one or more categories.
    ///Params:
    ///    rclsid = The class identifier.
    ///    cImplemented = The number of category IDs in the <i>rgcatidImpl</i> array. This value cannot be zero. If this value is -1,
    ///                   the implemented categories are not tested.
    ///    rgcatidImpl = An array of category identifiers. If the class requires a category not listed in <i>rgcatidReq</i>, it is not
    ///                  included in the enumeration.
    ///    cRequired = The number of category IDs in the <i>rgcatidReq</i> array. This value can be zero. If this value is -1, the
    ///                required categories are not tested.
    ///    rgcatidReq = An array of category identifiers.
    ///Returns:
    ///    If the class ID is of one of the specified categories, the return value is S_OK. Otherwise, is it S_FALSE.
    ///    
    HRESULT IsClassOfCategories(const(GUID)* rclsid, uint cImplemented, const(GUID)* rgcatidImpl, uint cRequired, 
                                const(GUID)* rgcatidReq);
    ///Retrieves an enumerator for the CATIDs implemented by the specified class.
    ///Params:
    ///    rclsid = The class ID.
    ///    ppenumCatid = A pointer to an IEnumCATID interface pointer. This can be used to enumerate the CATIDs that are implemented
    ///                  by <i>rclsid</i>.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.
    ///    
    HRESULT EnumImplCategoriesOfClass(const(GUID)* rclsid, IEnumGUID* ppenumCatid);
    ///Retrieves an enumerator for the CATIDs required by the specified class.
    ///Params:
    ///    rclsid = The class identifier.
    ///    ppenumCatid = A pointer to an IEnumCATID interface pointer. This can be used to enumerate the CATIDs that are required by
    ///                  <i>rclsid</i>.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.
    ///    
    HRESULT EnumReqCategoriesOfClass(const(GUID)* rclsid, IEnumGUID* ppenumCatid);
}

///Enables the management of access to objects and properties on the objects.
@GUID("EEDD23E0-8410-11CE-A1C3-08002B2B8D8F")
interface IAccessControl : IUnknown
{
    ///Merges the new list of access rights with the existing access rights on the object.
    ///Params:
    ///    pAccessList = A pointer to the [ACTRL_ACCESS](../accctrl/ns-accctrl-explicit_access_a.md) structure that contains an array
    ///                  of access lists for the object.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GrantAccessRights(ACTRL_ACCESSW* pAccessList);
    ///Replaces the existing access rights on an object with the specified list.
    ///Params:
    ///    pAccessList = A pointer to the [ACTRL_ACCESS](../accctrl/ns-accctrl-explicit_access_a.md) list that contains an array of
    ///                  access lists to be written to the object.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetAccessRights(ACTRL_ACCESSW* pAccessList);
    ///Sets the owner or the group of an item.
    ///Params:
    ///    pOwner = The address of the TRUSTEE structure for the owner.
    ///    pGroup = The address of the TRUSTEE structure for the group.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetOwner(TRUSTEE_W* pOwner, TRUSTEE_W* pGroup);
    ///Removes any explicit entries for the list of trustees.
    ///Params:
    ///    lpProperty = The name of the property. If you are using the COM implementation of IAccessControl, this parameter must be
    ///                 <b>NULL</b>.
    ///    cTrustees = The number of trustees in the list. This parameter cannot be 0.
    ///    prgTrustees = A pointer to an array of trustee names. See TRUSTEE.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RevokeAccessRights(const(wchar)* lpProperty, uint cTrustees, char* prgTrustees);
    ///Gets the entire list of access rights and/or the owner and group for the specified object.
    ///Params:
    ///    lpProperty = The name of the property. If you are using the COM implementation of IAccessControl, this parameter must be
    ///                 <b>NULL</b>.
    ///    ppAccessList = The address of the pointer variable that receives a pointer to the access list structure. This parameter
    ///                   cannot be [ACTRL_ACCESS](../accctrl/ns-accctrl-explicit_access_a.md). If the call succeeds, the caller must
    ///                   free the allocated memory with the CoTaskMemFree function. Note that the memory is allocate(all_nodes), which
    ///                   means that all the substructures are allocated in one block. Therefore, the entire data structure must be
    ///                   freed by a single call to <b>CoTaskMemFree</b>.
    ///    ppOwner = A pointer to a TRUSTEE structure that receives the owner information. If this parameter is not <b>NULL</b>
    ///              and the function succeeds, the caller must free the memory with CoTaskMemFree.
    ///    ppGroup = A pointer to a TRUSTEE structure that receives the group information. If this parameter is not <b>NULL</b>
    ///              and the function succeeds, the caller must free the memory with CoTaskMemFree.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetAllAccessRights(const(wchar)* lpProperty, ACTRL_ACCESSW** ppAccessList, TRUSTEE_W** ppOwner, 
                               TRUSTEE_W** ppGroup);
    ///Determines whether the specified trustee has access rights to the object or property.
    ///Params:
    ///    pTrustee = A pointer to a TRUSTEE structure.
    ///    lpProperty = The name of the property. If you are using the COM implementation of IAccessControl, this parameter must be
    ///                 <b>NULL</b>.
    ///    AccessRights = The access rights on the object. If you are using the COM implementation of IAccessControl, this value must
    ///                   be either 0 or 1 (COM_RIGHTS_EXECUTE).
    ///    pfAccessAllowed = Indicates whether access is allowed.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT IsAccessAllowed(TRUSTEE_W* pTrustee, const(wchar)* lpProperty, uint AccessRights, int* pfAccessAllowed);
}

@GUID("1DA6292F-BC66-11CE-AAE3-00AA004C2737")
interface IAuditControl : IUnknown
{
    HRESULT GrantAuditRights(ACTRL_ACCESSW* pAuditList);
    HRESULT SetAuditRights(ACTRL_ACCESSW* pAuditList);
    HRESULT RevokeAuditRights(const(wchar)* lpProperty, uint cTrustees, char* prgTrustees);
    HRESULT GetAllAuditRights(const(wchar)* lpProperty, ACTRL_ACCESSW** ppAuditList);
    HRESULT IsAccessAudited(TRUSTEE_W* pTrustee, uint AuditRights, int* pfAccessAudited);
}

///Provides a mechanism to execute a function inside a specific COM+ object context.
@GUID("000001DA-0000-0000-C000-000000000046")
interface IContextCallback : IUnknown
{
    ///Enters the object context, executes the specified function, and returns.
    ///Params:
    ///    pfnCallback = The function to be called inside the object context.
    ///    pParam = The data to be passed to the function when it is called in the context.
    ///    riid = The IID of the call that is being simulated. See Remarks for more information.
    ///    iMethod = The method number of the call that is being simulated. See Remarks for more information.
    ///    pUnk = This parameter is reserved and must be <b>NULL</b>.
    ///Returns:
    ///    This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and E_FAIL. If
    ///    none of these failures occur, the return value of this function is the <b>HRESULT</b> value returned by the
    ///    <i>pfnCallback</i> function.
    ///    
    HRESULT ContextCallback(PFNCONTEXTCALL pfnCallback, ComCallData* pParam, const(GUID)* riid, int iMethod, 
                            IUnknown pUnk);
}

///Callback interface implemented by components that need to perform special processing of window messages on an ASTA
///thread.
@GUID("F5F84C8F-CFD0-4CD6-B66B-C5D26FF1689D")
interface IMessageDispatcher : IInspectable
{
    ///Performs custom dispatching when window messages are available to be dispatched on an ASTA thread.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT PumpMessages();
}

///Registers, modifies, removes, and provides information about an event publisher.
@GUID("E341516B-2E32-11D1-9964-00C04FBBB345")
interface IEventPublisher : IDispatch
{
    HRESULT get_PublisherID(BSTR* pbstrPublisherID);
    ///The identifier for the event publisher. This property is write-only.
    HRESULT put_PublisherID(BSTR bstrPublisherID);
    ///The display name for the event publisher. This property is read/write.
    HRESULT get_PublisherName(BSTR* pbstrPublisherName);
    ///The display name for the event publisher. This property is read/write.
    HRESULT put_PublisherName(BSTR bstrPublisherName);
    ///The optional administrative group for the event publisher. This property is read/write.
    HRESULT get_PublisherType(BSTR* pbstrPublisherType);
    ///The optional administrative group for the event publisher. This property is read/write.
    HRESULT put_PublisherType(BSTR bstrPublisherType);
    ///The security identifier of the creator of the event publisher. This property is read/write.
    HRESULT get_OwnerSID(BSTR* pbstrOwnerSID);
    ///The security identifier of the creator of the event publisher. This property is read/write.
    HRESULT put_OwnerSID(BSTR bstrOwnerSID);
    ///The display text for the event publisher. This property is read/write.
    HRESULT get_Description(BSTR* pbstrDescription);
    ///The display text for the event publisher. This property is read/write.
    HRESULT put_Description(BSTR bstrDescription);
    ///Retrieves a named property and its value from the property bag associated with the event publisher.
    ///Params:
    ///    bstrPropertyName = The name of the property whose value is to be retrieved.
    ///    propertyValue = A pointer to the variable that receives the property.
    ///Returns:
    ///    The possible return values include E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and S_OK.
    ///    
    HRESULT GetDefaultProperty(BSTR bstrPropertyName, VARIANT* propertyValue);
    ///Writes a named property and its value to the property bag associated with the event publisher.
    ///Params:
    ///    bstrPropertyName = The name of the property whose value is to be set.
    ///    propertyValue = The new value for the property.
    ///Returns:
    ///    The possible return values include E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and S_OK.
    ///    
    HRESULT PutDefaultProperty(BSTR bstrPropertyName, VARIANT* propertyValue);
    ///Removes a named property and its value from the property bag associated with the event publisher object.
    ///Params:
    ///    bstrPropertyName = The name of the property to be removed.
    ///Returns:
    ///    The possible return values include E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and S_OK.
    ///    
    HRESULT RemoveDefaultProperty(BSTR bstrPropertyName);
    ///Creates a collection object that enumerates the properties contained in the property bag associated with the
    ///event publisher object.
    ///Params:
    ///    collection = A pointer to an IEventObjectCollection interface pointer on an event object collection. This parameter cannot
    ///                 be <b>NULL</b>.
    ///Returns:
    ///    The possible return values include E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and S_OK.
    ///    
    HRESULT GetDefaultPropertyCollection(IEventObjectCollection* collection);
}

///Associates a named event property with its value.
@GUID("DA538EE2-F4DE-11D1-B6BB-00805FC79216")
interface IEventProperty : IDispatch
{
    ///The name of the event property. This property is read/write.
    HRESULT get_Name(BSTR* propertyName);
    ///The name of the event property. This property is read/write.
    HRESULT put_Name(BSTR propertyName);
    ///The value of the event property. This property is read/write.
    HRESULT get_Value(VARIANT* propertyValue);
    ///The value of the event property. This property is read/write.
    HRESULT put_Value(VARIANT* propertyValue);
}

///Receives Acessibility Window Docking events.
@GUID("157733FD-A592-42E5-B594-248468C5A81B")
interface IAccessibilityDockingServiceCallback : IUnknown
{
    ///Undocks the accessibility window so that it will not be automatically moved to its previous location.
    ///Params:
    ///    undockReason = Specifies the reason why the accessibility application's window was undocked.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Undocked(UNDOCK_REASON undockReason);
}

///Docks an application window to the bottom of a monitor when a Windows Store app is visible and not snapped, or when
///the launcher is visible.
@GUID("8849DC22-CEDF-4C95-998D-051419DD3F76")
interface IAccessibilityDockingService : IUnknown
{
    ///Retrieves the dimensions available on a specific screen for displaying an accessibility window.
    ///Params:
    ///    hMonitor = Type: <b>HMONITOR</b> The handle of the monitor whose available docking size is to be retrieved. For
    ///               information on how to retrieve an <b>HMONITOR</b>, see MonitorFromWindow.
    ///    pcxFixed = Type: <b>UINT*</b> When this method returns successfully, this parameter receives the fixed width, in
    ///               physical pixels, available for docking on the specified monitor. Any window docked to this monitor will be
    ///               sized to this width. If the method fails, this value is set to 0. If this value is <b>NULL</b>, an access
    ///               violation will occur.
    ///    pcyMax = Type: <b>UINT*</b> When this method returns successfully, this parameter receives the maximum height, in
    ///             physical pixels, available for a docked window on the specified monitor. If the method fails, this value is
    ///             set to 0. If this value is <b>NULL</b>, an access violation will occur.
    ///Returns:
    ///    Type: <b>HRESULT</b> Returns a standard return value, including the following: <table> <tr> <th>Return
    ///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>HRESULT_FROM_WIN32(ERROR_INVALID_MONITOR_HANDLE)</b></dt> </dl> </td> <td width="60%"> The monitor
    ///    specified by <i>hMonitor</i> does not support docking. </td> </tr> </table>
    ///    
    HRESULT GetAvailableSize(ptrdiff_t hMonitor, uint* pcxFixed, uint* pcyMax);
    ///Docks the specified window handle to the specified monitor handle.
    ///Params:
    ///    hwnd = The accessibility application window that will be docked on the passed monitor handle.
    ///    hMonitor = The monitor on which the accessibility application window will be docked.
    ///    cyRequested = TBD
    ///    pCallback = The callback pointer on which the accessibility application will receive the Undock notification.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The window handle or monitor
    ///    handle is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The calling process is not a UIAcess accessibility application or the calling process does not
    ///    own the window. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>IMM_E_DOCKOCCUPIED</b></dt> </dl> </td> <td
    ///    width="60%"> There is already another window occupying the docking space. Only one window can be docked at a
    ///    time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>IMM_E_INSUFFICIENTHEIGHT</b></dt> </dl> </td> <td
    ///    width="60%"> The requested <i>uHeight</i> is larger than the maximum allowed docking height for the specified
    ///    monitor. However, if this error code is being returned, it means that this monitor does support docking,
    ///    though at a height indicated by a call to the GetAvailableSize method. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>HRESULT_FROM_WIN32(ERROR_INVALID_MONITOR_HANDLE)</b></dt> </dl> </td> <td width="60%"> The monitor
    ///    specified by the monitor handle does not support docking. </td> </tr> </table>
    ///    
    HRESULT DockWindow(HWND hwnd, ptrdiff_t hMonitor, uint cyRequested, 
                       IAccessibilityDockingServiceCallback pCallback);
    ///Undocks the specified window handle if it is currently docked.
    ///Params:
    ///    hwnd = TBD
    ///    hWnd = Specifies the window that will be undocked.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Success. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%"> The window does not belong to
    ///    the calling process. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>HRESULT_FROM_WIN32(ERROR_INVALID_WINDOW_HANDLE)</b></dt> </dl> </td> <td width="60%"> The window is
    ///    not docked. </td> </tr> </table>
    ///    
    HRESULT UndockWindow(HWND hwnd);
}


// GUIDs


const GUID IID_AsyncIAdviseSink                     = GUIDOF!AsyncIAdviseSink;
const GUID IID_AsyncIAdviseSink2                    = GUIDOF!AsyncIAdviseSink2;
const GUID IID_AsyncIMultiQI                        = GUIDOF!AsyncIMultiQI;
const GUID IID_AsyncIPipeByte                       = GUIDOF!AsyncIPipeByte;
const GUID IID_AsyncIPipeDouble                     = GUIDOF!AsyncIPipeDouble;
const GUID IID_AsyncIPipeLong                       = GUIDOF!AsyncIPipeLong;
const GUID IID_AsyncIUnknown                        = GUIDOF!AsyncIUnknown;
const GUID IID_IAccessControl                       = GUIDOF!IAccessControl;
const GUID IID_IAccessibilityDockingService         = GUIDOF!IAccessibilityDockingService;
const GUID IID_IAccessibilityDockingServiceCallback = GUIDOF!IAccessibilityDockingServiceCallback;
const GUID IID_IActivationFilter                    = GUIDOF!IActivationFilter;
const GUID IID_IAddrExclusionControl                = GUIDOF!IAddrExclusionControl;
const GUID IID_IAddrTrackingControl                 = GUIDOF!IAddrTrackingControl;
const GUID IID_IAdviseSink                          = GUIDOF!IAdviseSink;
const GUID IID_IAdviseSink2                         = GUIDOF!IAdviseSink2;
const GUID IID_IAdviseSinkEx                        = GUIDOF!IAdviseSinkEx;
const GUID IID_IAgileObject                         = GUIDOF!IAgileObject;
const GUID IID_IAsyncManager                        = GUIDOF!IAsyncManager;
const GUID IID_IAsyncRpcChannelBuffer               = GUIDOF!IAsyncRpcChannelBuffer;
const GUID IID_IAuditControl                        = GUIDOF!IAuditControl;
const GUID IID_IAuthenticate                        = GUIDOF!IAuthenticate;
const GUID IID_IAuthenticateEx                      = GUIDOF!IAuthenticateEx;
const GUID IID_IBindCallbackRedirect                = GUIDOF!IBindCallbackRedirect;
const GUID IID_IBindCtx                             = GUIDOF!IBindCtx;
const GUID IID_IBindHost                            = GUIDOF!IBindHost;
const GUID IID_IBindHttpSecurity                    = GUIDOF!IBindHttpSecurity;
const GUID IID_IBindProtocol                        = GUIDOF!IBindProtocol;
const GUID IID_IBindStatusCallback                  = GUIDOF!IBindStatusCallback;
const GUID IID_IBindStatusCallbackEx                = GUIDOF!IBindStatusCallbackEx;
const GUID IID_IBinding                             = GUIDOF!IBinding;
const GUID IID_IBlockingLock                        = GUIDOF!IBlockingLock;
const GUID IID_ICallFactory                         = GUIDOF!ICallFactory;
const GUID IID_ICallFrame                           = GUIDOF!ICallFrame;
const GUID IID_ICallFrameEvents                     = GUIDOF!ICallFrameEvents;
const GUID IID_ICallFrameWalker                     = GUIDOF!ICallFrameWalker;
const GUID IID_ICallIndirect                        = GUIDOF!ICallIndirect;
const GUID IID_ICallInterceptor                     = GUIDOF!ICallInterceptor;
const GUID IID_ICallUnmarshal                       = GUIDOF!ICallUnmarshal;
const GUID IID_ICancelMethodCalls                   = GUIDOF!ICancelMethodCalls;
const GUID IID_ICatInformation                      = GUIDOF!ICatInformation;
const GUID IID_ICatRegister                         = GUIDOF!ICatRegister;
const GUID IID_ICatalogFileInfo                     = GUIDOF!ICatalogFileInfo;
const GUID IID_IChannelHook                         = GUIDOF!IChannelHook;
const GUID IID_IClassActivator                      = GUIDOF!IClassActivator;
const GUID IID_IClassFactory                        = GUIDOF!IClassFactory;
const GUID IID_IClassFactory2                       = GUIDOF!IClassFactory2;
const GUID IID_IClientSecurity                      = GUIDOF!IClientSecurity;
const GUID IID_ICodeInstall                         = GUIDOF!ICodeInstall;
const GUID IID_IComThreadingInfo                    = GUIDOF!IComThreadingInfo;
const GUID IID_IConnectionPoint                     = GUIDOF!IConnectionPoint;
const GUID IID_IConnectionPointContainer            = GUIDOF!IConnectionPointContainer;
const GUID IID_IContextCallback                     = GUIDOF!IContextCallback;
const GUID IID_IContinue                            = GUIDOF!IContinue;
const GUID IID_IContinueCallback                    = GUIDOF!IContinueCallback;
const GUID IID_IDataAdviseHolder                    = GUIDOF!IDataAdviseHolder;
const GUID IID_IDataFilter                          = GUIDOF!IDataFilter;
const GUID IID_IDataObject                          = GUIDOF!IDataObject;
const GUID IID_IDropSource                          = GUIDOF!IDropSource;
const GUID IID_IDropSourceNotify                    = GUIDOF!IDropSourceNotify;
const GUID IID_IDropTarget                          = GUIDOF!IDropTarget;
const GUID IID_IDummyHICONIncluder                  = GUIDOF!IDummyHICONIncluder;
const GUID IID_IEncodingFilterFactory               = GUIDOF!IEncodingFilterFactory;
const GUID IID_IEnterpriseDropTarget                = GUIDOF!IEnterpriseDropTarget;
const GUID IID_IEnumCATEGORYINFO                    = GUIDOF!IEnumCATEGORYINFO;
const GUID IID_IEnumConnectionPoints                = GUIDOF!IEnumConnectionPoints;
const GUID IID_IEnumConnections                     = GUIDOF!IEnumConnections;
const GUID IID_IEnumFORMATETC                       = GUIDOF!IEnumFORMATETC;
const GUID IID_IEnumGUID                            = GUIDOF!IEnumGUID;
const GUID IID_IEnumMoniker                         = GUIDOF!IEnumMoniker;
const GUID IID_IEnumOLEVERB                         = GUIDOF!IEnumOLEVERB;
const GUID IID_IEnumOleDocumentViews                = GUIDOF!IEnumOleDocumentViews;
const GUID IID_IEnumOleUndoUnits                    = GUIDOF!IEnumOleUndoUnits;
const GUID IID_IEnumSTATDATA                        = GUIDOF!IEnumSTATDATA;
const GUID IID_IEnumString                          = GUIDOF!IEnumString;
const GUID IID_IEnumUnknown                         = GUIDOF!IEnumUnknown;
const GUID IID_IEventProperty                       = GUIDOF!IEventProperty;
const GUID IID_IEventPublisher                      = GUIDOF!IEventPublisher;
const GUID IID_IExternalConnection                  = GUIDOF!IExternalConnection;
const GUID IID_IFastRundown                         = GUIDOF!IFastRundown;
const GUID IID_IFileBasedLogInit                    = GUIDOF!IFileBasedLogInit;
const GUID IID_IFont                                = GUIDOF!IFont;
const GUID IID_IFontDisp                            = GUIDOF!IFontDisp;
const GUID IID_IFontEventsDisp                      = GUIDOF!IFontEventsDisp;
const GUID IID_IForegroundTransfer                  = GUIDOF!IForegroundTransfer;
const GUID IID_IGetBindHandle                       = GUIDOF!IGetBindHandle;
const GUID IID_IGlobalInterfaceTable                = GUIDOF!IGlobalInterfaceTable;
const GUID IID_IGlobalOptions                       = GUIDOF!IGlobalOptions;
const GUID IID_IHttpNegotiate                       = GUIDOF!IHttpNegotiate;
const GUID IID_IHttpNegotiate2                      = GUIDOF!IHttpNegotiate2;
const GUID IID_IHttpNegotiate3                      = GUIDOF!IHttpNegotiate3;
const GUID IID_IHttpSecurity                        = GUIDOF!IHttpSecurity;
const GUID IID_IInitializeSpy                       = GUIDOF!IInitializeSpy;
const GUID IID_IInterfaceRelated                    = GUIDOF!IInterfaceRelated;
const GUID IID_IInternalUnknown                     = GUIDOF!IInternalUnknown;
const GUID IID_IInternet                            = GUIDOF!IInternet;
const GUID IID_IInternetBindInfo                    = GUIDOF!IInternetBindInfo;
const GUID IID_IInternetBindInfoEx                  = GUIDOF!IInternetBindInfoEx;
const GUID IID_IInternetHostSecurityManager         = GUIDOF!IInternetHostSecurityManager;
const GUID IID_IInternetPriority                    = GUIDOF!IInternetPriority;
const GUID IID_IInternetProtocol                    = GUIDOF!IInternetProtocol;
const GUID IID_IInternetProtocolEx                  = GUIDOF!IInternetProtocolEx;
const GUID IID_IInternetProtocolInfo                = GUIDOF!IInternetProtocolInfo;
const GUID IID_IInternetProtocolRoot                = GUIDOF!IInternetProtocolRoot;
const GUID IID_IInternetProtocolSink                = GUIDOF!IInternetProtocolSink;
const GUID IID_IInternetProtocolSinkStackable       = GUIDOF!IInternetProtocolSinkStackable;
const GUID IID_IInternetSecurityManager             = GUIDOF!IInternetSecurityManager;
const GUID IID_IInternetSecurityManagerEx           = GUIDOF!IInternetSecurityManagerEx;
const GUID IID_IInternetSecurityManagerEx2          = GUIDOF!IInternetSecurityManagerEx2;
const GUID IID_IInternetSecurityMgrSite             = GUIDOF!IInternetSecurityMgrSite;
const GUID IID_IInternetSession                     = GUIDOF!IInternetSession;
const GUID IID_IInternetThreadSwitch                = GUIDOF!IInternetThreadSwitch;
const GUID IID_IInternetZoneManager                 = GUIDOF!IInternetZoneManager;
const GUID IID_IInternetZoneManagerEx               = GUIDOF!IInternetZoneManagerEx;
const GUID IID_IInternetZoneManagerEx2              = GUIDOF!IInternetZoneManagerEx2;
const GUID IID_ILog                                 = GUIDOF!ILog;
const GUID IID_IMalloc                              = GUIDOF!IMalloc;
const GUID IID_IMallocSpy                           = GUIDOF!IMallocSpy;
const GUID IID_IMarshal                             = GUIDOF!IMarshal;
const GUID IID_IMarshal2                            = GUIDOF!IMarshal2;
const GUID IID_IMarshalingStream                    = GUIDOF!IMarshalingStream;
const GUID IID_IMessageDispatcher                   = GUIDOF!IMessageDispatcher;
const GUID IID_IMessageFilter                       = GUIDOF!IMessageFilter;
const GUID IID_IMoniker                             = GUIDOF!IMoniker;
const GUID IID_IMonikerProp                         = GUIDOF!IMonikerProp;
const GUID IID_IMultiQI                             = GUIDOF!IMultiQI;
const GUID IID_INoMarshal                           = GUIDOF!INoMarshal;
const GUID IID_IObjectWithSite                      = GUIDOF!IObjectWithSite;
const GUID IID_IOleAdviseHolder                     = GUIDOF!IOleAdviseHolder;
const GUID IID_IOleCache                            = GUIDOF!IOleCache;
const GUID IID_IOleCache2                           = GUIDOF!IOleCache2;
const GUID IID_IOleCacheControl                     = GUIDOF!IOleCacheControl;
const GUID IID_IOleClientSite                       = GUIDOF!IOleClientSite;
const GUID IID_IOleCommandTarget                    = GUIDOF!IOleCommandTarget;
const GUID IID_IOleContainer                        = GUIDOF!IOleContainer;
const GUID IID_IOleControl                          = GUIDOF!IOleControl;
const GUID IID_IOleControlSite                      = GUIDOF!IOleControlSite;
const GUID IID_IOleDocument                         = GUIDOF!IOleDocument;
const GUID IID_IOleDocumentSite                     = GUIDOF!IOleDocumentSite;
const GUID IID_IOleDocumentView                     = GUIDOF!IOleDocumentView;
const GUID IID_IOleInPlaceActiveObject              = GUIDOF!IOleInPlaceActiveObject;
const GUID IID_IOleInPlaceFrame                     = GUIDOF!IOleInPlaceFrame;
const GUID IID_IOleInPlaceObject                    = GUIDOF!IOleInPlaceObject;
const GUID IID_IOleInPlaceObjectWindowless          = GUIDOF!IOleInPlaceObjectWindowless;
const GUID IID_IOleInPlaceSite                      = GUIDOF!IOleInPlaceSite;
const GUID IID_IOleInPlaceSiteEx                    = GUIDOF!IOleInPlaceSiteEx;
const GUID IID_IOleInPlaceSiteWindowless            = GUIDOF!IOleInPlaceSiteWindowless;
const GUID IID_IOleInPlaceUIWindow                  = GUIDOF!IOleInPlaceUIWindow;
const GUID IID_IOleItemContainer                    = GUIDOF!IOleItemContainer;
const GUID IID_IOleLink                             = GUIDOF!IOleLink;
const GUID IID_IOleObject                           = GUIDOF!IOleObject;
const GUID IID_IOleParentUndoUnit                   = GUIDOF!IOleParentUndoUnit;
const GUID IID_IOleUndoManager                      = GUIDOF!IOleUndoManager;
const GUID IID_IOleUndoUnit                         = GUIDOF!IOleUndoUnit;
const GUID IID_IOleWindow                           = GUIDOF!IOleWindow;
const GUID IID_IOplockStorage                       = GUIDOF!IOplockStorage;
const GUID IID_IPSFactoryBuffer                     = GUIDOF!IPSFactoryBuffer;
const GUID IID_IParseDisplayName                    = GUIDOF!IParseDisplayName;
const GUID IID_IPerPropertyBrowsing                 = GUIDOF!IPerPropertyBrowsing;
const GUID IID_IPersist                             = GUIDOF!IPersist;
const GUID IID_IPersistFile                         = GUIDOF!IPersistFile;
const GUID IID_IPersistMemory                       = GUIDOF!IPersistMemory;
const GUID IID_IPersistMoniker                      = GUIDOF!IPersistMoniker;
const GUID IID_IPersistPropertyBag                  = GUIDOF!IPersistPropertyBag;
const GUID IID_IPersistPropertyBag2                 = GUIDOF!IPersistPropertyBag2;
const GUID IID_IPersistStorage                      = GUIDOF!IPersistStorage;
const GUID IID_IPersistStream                       = GUIDOF!IPersistStream;
const GUID IID_IPersistStreamInit                   = GUIDOF!IPersistStreamInit;
const GUID IID_IPicture                             = GUIDOF!IPicture;
const GUID IID_IPicture2                            = GUIDOF!IPicture2;
const GUID IID_IPictureDisp                         = GUIDOF!IPictureDisp;
const GUID IID_IPipeByte                            = GUIDOF!IPipeByte;
const GUID IID_IPipeDouble                          = GUIDOF!IPipeDouble;
const GUID IID_IPipeLong                            = GUIDOF!IPipeLong;
const GUID IID_IPointerInactive                     = GUIDOF!IPointerInactive;
const GUID IID_IPrint                               = GUIDOF!IPrint;
const GUID IID_IProcessInitControl                  = GUIDOF!IProcessInitControl;
const GUID IID_IProcessLock                         = GUIDOF!IProcessLock;
const GUID IID_IProgressNotify                      = GUIDOF!IProgressNotify;
const GUID IID_IPropertyBag2                        = GUIDOF!IPropertyBag2;
const GUID IID_IPropertyNotifySink                  = GUIDOF!IPropertyNotifySink;
const GUID IID_IPropertyPage                        = GUIDOF!IPropertyPage;
const GUID IID_IPropertyPage2                       = GUIDOF!IPropertyPage2;
const GUID IID_IPropertyPageSite                    = GUIDOF!IPropertyPageSite;
const GUID IID_IProtectFocus                        = GUIDOF!IProtectFocus;
const GUID IID_IProtectedModeMenuServices           = GUIDOF!IProtectedModeMenuServices;
const GUID IID_IProvideClassInfo                    = GUIDOF!IProvideClassInfo;
const GUID IID_IProvideClassInfo2                   = GUIDOF!IProvideClassInfo2;
const GUID IID_IProvideMultipleClassInfo            = GUIDOF!IProvideMultipleClassInfo;
const GUID IID_IQuickActivate                       = GUIDOF!IQuickActivate;
const GUID IID_IROTData                             = GUIDOF!IROTData;
const GUID IID_IReleaseMarshalBuffers               = GUIDOF!IReleaseMarshalBuffers;
const GUID IID_IRpcChannelBuffer                    = GUIDOF!IRpcChannelBuffer;
const GUID IID_IRpcChannelBuffer2                   = GUIDOF!IRpcChannelBuffer2;
const GUID IID_IRpcChannelBuffer3                   = GUIDOF!IRpcChannelBuffer3;
const GUID IID_IRpcHelper                           = GUIDOF!IRpcHelper;
const GUID IID_IRpcOptions                          = GUIDOF!IRpcOptions;
const GUID IID_IRpcProxyBuffer                      = GUIDOF!IRpcProxyBuffer;
const GUID IID_IRpcStubBuffer                       = GUIDOF!IRpcStubBuffer;
const GUID IID_IRpcSyntaxNegotiate                  = GUIDOF!IRpcSyntaxNegotiate;
const GUID IID_IRunnableObject                      = GUIDOF!IRunnableObject;
const GUID IID_IRunningObjectTable                  = GUIDOF!IRunningObjectTable;
const GUID IID_IServerSecurity                      = GUIDOF!IServerSecurity;
const GUID IID_ISimpleFrameSite                     = GUIDOF!ISimpleFrameSite;
const GUID IID_ISoftDistExt                         = GUIDOF!ISoftDistExt;
const GUID IID_ISpecifyPropertyPages                = GUIDOF!ISpecifyPropertyPages;
const GUID IID_IStdMarshalInfo                      = GUIDOF!IStdMarshalInfo;
const GUID IID_ISurrogate                           = GUIDOF!ISurrogate;
const GUID IID_ISurrogateService                    = GUIDOF!ISurrogateService;
const GUID IID_ISynchronize                         = GUIDOF!ISynchronize;
const GUID IID_ISynchronizeContainer                = GUIDOF!ISynchronizeContainer;
const GUID IID_ISynchronizeEvent                    = GUIDOF!ISynchronizeEvent;
const GUID IID_ISynchronizeHandle                   = GUIDOF!ISynchronizeHandle;
const GUID IID_ISynchronizeMutex                    = GUIDOF!ISynchronizeMutex;
const GUID IID_IThumbnailExtractor                  = GUIDOF!IThumbnailExtractor;
const GUID IID_ITimeAndNoticeControl                = GUIDOF!ITimeAndNoticeControl;
const GUID IID_IUnknown                             = GUIDOF!IUnknown;
const GUID IID_IUri                                 = GUIDOF!IUri;
const GUID IID_IUriBuilder                          = GUIDOF!IUriBuilder;
const GUID IID_IUriBuilderFactory                   = GUIDOF!IUriBuilderFactory;
const GUID IID_IUriContainer                        = GUIDOF!IUriContainer;
const GUID IID_IUrlMon                              = GUIDOF!IUrlMon;
const GUID IID_IViewObject                          = GUIDOF!IViewObject;
const GUID IID_IViewObject2                         = GUIDOF!IViewObject2;
const GUID IID_IViewObjectEx                        = GUIDOF!IViewObjectEx;
const GUID IID_IWaitMultiple                        = GUIDOF!IWaitMultiple;
const GUID IID_IWinInetCacheHints                   = GUIDOF!IWinInetCacheHints;
const GUID IID_IWinInetCacheHints2                  = GUIDOF!IWinInetCacheHints2;
const GUID IID_IWinInetFileStream                   = GUIDOF!IWinInetFileStream;
const GUID IID_IWinInetHttpInfo                     = GUIDOF!IWinInetHttpInfo;
const GUID IID_IWinInetHttpTimeouts                 = GUIDOF!IWinInetHttpTimeouts;
const GUID IID_IWinInetInfo                         = GUIDOF!IWinInetInfo;
const GUID IID_IWindowForBindingUI                  = GUIDOF!IWindowForBindingUI;
const GUID IID_IWrappedProtocol                     = GUIDOF!IWrappedProtocol;
const GUID IID_IZoneIdentifier                      = GUIDOF!IZoneIdentifier;
const GUID IID_IZoneIdentifier2                     = GUIDOF!IZoneIdentifier2;
const GUID IID_IZoomEvents                          = GUIDOF!IZoomEvents;
