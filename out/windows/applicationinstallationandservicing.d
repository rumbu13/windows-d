// Written in the D programming language.

module windows.applicationinstallationandservicing;

public import windows.core;
public import windows.automation : BSTR, IDispatch;
public import windows.com : HRESULT, IUnknown;
public import windows.deviceanddriverinstallation : SP_DEVINFO_DATA, SetupFileLogInfo;
public import windows.security : CERT_CONTEXT;
public import windows.structuredstorage : IStream;
public import windows.systemservices : BOOL, HANDLE, HINSTANCE, LARGE_INTEGER,
                                       ULARGE_INTEGER;
public import windows.windowsandmessaging : HWND;
public import windows.windowsprogramming : ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, FILETIME, HKEY;

extern(Windows):


// Enums


///The <b>ACTCTX_REQUESTED_RUN_LEVEL</b> enumeration describes the requested run level of the activation context.
alias ACTCTX_REQUESTED_RUN_LEVEL = int;
enum : int
{
    ///The application manifest does not specify a requested run level for the application.
    ACTCTX_RUN_LEVEL_UNSPECIFIED       = 0x00000000,
    ///The application manifest requests the least privilege level to run the application.
    ACTCTX_RUN_LEVEL_AS_INVOKER        = 0x00000001,
    ///The application manifest requests the highest privilege level to run the application.
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = 0x00000002,
    ///The application manifest requests the administrator privilege level to run the application.
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN     = 0x00000003,
    ACTCTX_RUN_LEVEL_NUMBERS           = 0x00000004,
}

///The <b>ACTCTX_COMPATIBILITY_ELEMENT_TYPE</b> enumeration describes the compatibility element in the application
///manifest.
alias ACTCTX_COMPATIBILITY_ELEMENT_TYPE = int;
enum : int
{
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN          = 0x00000000,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS               = 0x00000001,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION       = 0x00000002,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED = 0x00000003,
}

alias RESULTTYPES = int;
enum : int
{
    ieUnknown = 0x00000000,
    ieError   = 0x00000001,
    ieWarning = 0x00000002,
    ieInfo    = 0x00000003,
}

alias STATUSTYPES = int;
enum : int
{
    ieStatusGetCUB       = 0x00000000,
    ieStatusICECount     = 0x00000001,
    ieStatusMerge        = 0x00000002,
    ieStatusSummaryInfo  = 0x00000003,
    ieStatusCreateEngine = 0x00000004,
    ieStatusStarting     = 0x00000005,
    ieStatusRunICE       = 0x00000006,
    ieStatusShutdown     = 0x00000007,
    ieStatusSuccess      = 0x00000008,
    ieStatusFail         = 0x00000009,
    ieStatusCancel       = 0x0000000a,
}

alias msmErrorType = int;
enum : int
{
    msmErrorLanguageUnsupported = 0x00000001,
    msmErrorLanguageFailed      = 0x00000002,
    msmErrorExclusion           = 0x00000003,
    msmErrorTableMerge          = 0x00000004,
    msmErrorResequenceMerge     = 0x00000005,
    msmErrorFileCreate          = 0x00000006,
    msmErrorDirCreate           = 0x00000007,
    msmErrorFeatureRequired     = 0x00000008,
}

alias INSTALLMESSAGE = int;
enum : int
{
    INSTALLMESSAGE_FATALEXIT      = 0x00000000,
    INSTALLMESSAGE_ERROR          = 0x01000000,
    INSTALLMESSAGE_WARNING        = 0x02000000,
    INSTALLMESSAGE_USER           = 0x03000000,
    INSTALLMESSAGE_INFO           = 0x04000000,
    INSTALLMESSAGE_FILESINUSE     = 0x05000000,
    INSTALLMESSAGE_RESOLVESOURCE  = 0x06000000,
    INSTALLMESSAGE_OUTOFDISKSPACE = 0x07000000,
    INSTALLMESSAGE_ACTIONSTART    = 0x08000000,
    INSTALLMESSAGE_ACTIONDATA     = 0x09000000,
    INSTALLMESSAGE_PROGRESS       = 0x0a000000,
    INSTALLMESSAGE_COMMONDATA     = 0x0b000000,
    INSTALLMESSAGE_INITIALIZE     = 0x0c000000,
    INSTALLMESSAGE_TERMINATE      = 0x0d000000,
    INSTALLMESSAGE_SHOWDIALOG     = 0x0e000000,
    INSTALLMESSAGE_PERFORMANCE    = 0x0f000000,
    INSTALLMESSAGE_RMFILESINUSE   = 0x19000000,
    INSTALLMESSAGE_INSTALLSTART   = 0x1a000000,
    INSTALLMESSAGE_INSTALLEND     = 0x1b000000,
}

alias INSTALLUILEVEL = int;
enum : int
{
    INSTALLUILEVEL_NOCHANGE      = 0x00000000,
    INSTALLUILEVEL_DEFAULT       = 0x00000001,
    INSTALLUILEVEL_NONE          = 0x00000002,
    INSTALLUILEVEL_BASIC         = 0x00000003,
    INSTALLUILEVEL_REDUCED       = 0x00000004,
    INSTALLUILEVEL_FULL          = 0x00000005,
    INSTALLUILEVEL_ENDDIALOG     = 0x00000080,
    INSTALLUILEVEL_PROGRESSONLY  = 0x00000040,
    INSTALLUILEVEL_HIDECANCEL    = 0x00000020,
    INSTALLUILEVEL_SOURCERESONLY = 0x00000100,
    INSTALLUILEVEL_UACONLY       = 0x00000200,
}

alias INSTALLSTATE = int;
enum : int
{
    INSTALLSTATE_NOTUSED      = 0xfffffff9,
    INSTALLSTATE_BADCONFIG    = 0xfffffffa,
    INSTALLSTATE_INCOMPLETE   = 0xfffffffb,
    INSTALLSTATE_SOURCEABSENT = 0xfffffffc,
    INSTALLSTATE_MOREDATA     = 0xfffffffd,
    INSTALLSTATE_INVALIDARG   = 0xfffffffe,
    INSTALLSTATE_UNKNOWN      = 0xffffffff,
    INSTALLSTATE_BROKEN       = 0x00000000,
    INSTALLSTATE_ADVERTISED   = 0x00000001,
    INSTALLSTATE_REMOVED      = 0x00000001,
    INSTALLSTATE_ABSENT       = 0x00000002,
    INSTALLSTATE_LOCAL        = 0x00000003,
    INSTALLSTATE_SOURCE       = 0x00000004,
    INSTALLSTATE_DEFAULT      = 0x00000005,
}

alias USERINFOSTATE = int;
enum : int
{
    USERINFOSTATE_MOREDATA   = 0xfffffffd,
    USERINFOSTATE_INVALIDARG = 0xfffffffe,
    USERINFOSTATE_UNKNOWN    = 0xffffffff,
    USERINFOSTATE_ABSENT     = 0x00000000,
    USERINFOSTATE_PRESENT    = 0x00000001,
}

alias INSTALLLEVEL = int;
enum : int
{
    INSTALLLEVEL_DEFAULT = 0x00000000,
    INSTALLLEVEL_MINIMUM = 0x00000001,
    INSTALLLEVEL_MAXIMUM = 0x0000ffff,
}

alias REINSTALLMODE = int;
enum : int
{
    REINSTALLMODE_REPAIR           = 0x00000001,
    REINSTALLMODE_FILEMISSING      = 0x00000002,
    REINSTALLMODE_FILEOLDERVERSION = 0x00000004,
    REINSTALLMODE_FILEEQUALVERSION = 0x00000008,
    REINSTALLMODE_FILEEXACT        = 0x00000010,
    REINSTALLMODE_FILEVERIFY       = 0x00000020,
    REINSTALLMODE_FILEREPLACE      = 0x00000040,
    REINSTALLMODE_MACHINEDATA      = 0x00000080,
    REINSTALLMODE_USERDATA         = 0x00000100,
    REINSTALLMODE_SHORTCUT         = 0x00000200,
    REINSTALLMODE_PACKAGE          = 0x00000400,
}

alias tagINSTALLOGMODE = int;
enum : int
{
    INSTALLLOGMODE_FATALEXIT      = 0x00000001,
    INSTALLLOGMODE_ERROR          = 0x00000002,
    INSTALLLOGMODE_WARNING        = 0x00000004,
    INSTALLLOGMODE_USER           = 0x00000008,
    INSTALLLOGMODE_INFO           = 0x00000010,
    INSTALLLOGMODE_RESOLVESOURCE  = 0x00000040,
    INSTALLLOGMODE_OUTOFDISKSPACE = 0x00000080,
    INSTALLLOGMODE_ACTIONSTART    = 0x00000100,
    INSTALLLOGMODE_ACTIONDATA     = 0x00000200,
    INSTALLLOGMODE_COMMONDATA     = 0x00000800,
    INSTALLLOGMODE_PROPERTYDUMP   = 0x00000400,
    INSTALLLOGMODE_VERBOSE        = 0x00001000,
    INSTALLLOGMODE_EXTRADEBUG     = 0x00002000,
    INSTALLLOGMODE_LOGONLYONERROR = 0x00004000,
    INSTALLLOGMODE_LOGPERFORMANCE = 0x00008000,
    INSTALLLOGMODE_PROGRESS       = 0x00000400,
    INSTALLLOGMODE_INITIALIZE     = 0x00001000,
    INSTALLLOGMODE_TERMINATE      = 0x00002000,
    INSTALLLOGMODE_SHOWDIALOG     = 0x00004000,
    INSTALLLOGMODE_FILESINUSE     = 0x00000020,
    INSTALLLOGMODE_RMFILESINUSE   = 0x02000000,
    INSTALLLOGMODE_INSTALLSTART   = 0x04000000,
    INSTALLLOGMODE_INSTALLEND     = 0x08000000,
}

alias INSTALLLOGATTRIBUTES = int;
enum : int
{
    INSTALLLOGATTRIBUTES_APPEND        = 0x00000001,
    INSTALLLOGATTRIBUTES_FLUSHEACHLINE = 0x00000002,
}

alias INSTALLFEATUREATTRIBUTE = int;
enum : int
{
    INSTALLFEATUREATTRIBUTE_FAVORLOCAL             = 0x00000001,
    INSTALLFEATUREATTRIBUTE_FAVORSOURCE            = 0x00000002,
    INSTALLFEATUREATTRIBUTE_FOLLOWPARENT           = 0x00000004,
    INSTALLFEATUREATTRIBUTE_FAVORADVERTISE         = 0x00000008,
    INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE      = 0x00000010,
    INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE = 0x00000020,
}

alias INSTALLMODE = int;
enum : int
{
    INSTALLMODE_NODETECTION_ANY    = 0xfffffffc,
    INSTALLMODE_NOSOURCERESOLUTION = 0xfffffffd,
    INSTALLMODE_NODETECTION        = 0xfffffffe,
    INSTALLMODE_EXISTING           = 0xffffffff,
    INSTALLMODE_DEFAULT            = 0x00000000,
}

alias MSIPATCHSTATE = int;
enum : int
{
    MSIPATCHSTATE_INVALID    = 0x00000000,
    MSIPATCHSTATE_APPLIED    = 0x00000001,
    MSIPATCHSTATE_SUPERSEDED = 0x00000002,
    MSIPATCHSTATE_OBSOLETED  = 0x00000004,
    MSIPATCHSTATE_REGISTERED = 0x00000008,
    MSIPATCHSTATE_ALL        = 0x0000000f,
}

alias MSIINSTALLCONTEXT = int;
enum : int
{
    MSIINSTALLCONTEXT_FIRSTVISIBLE   = 0x00000000,
    MSIINSTALLCONTEXT_NONE           = 0x00000000,
    MSIINSTALLCONTEXT_USERMANAGED    = 0x00000001,
    MSIINSTALLCONTEXT_USERUNMANAGED  = 0x00000002,
    MSIINSTALLCONTEXT_MACHINE        = 0x00000004,
    MSIINSTALLCONTEXT_ALL            = 0x00000007,
    MSIINSTALLCONTEXT_ALLUSERMANAGED = 0x00000008,
}

alias MSIPATCHDATATYPE = int;
enum : int
{
    MSIPATCH_DATATYPE_PATCHFILE = 0x00000000,
    MSIPATCH_DATATYPE_XMLPATH   = 0x00000001,
    MSIPATCH_DATATYPE_XMLBLOB   = 0x00000002,
}

alias SCRIPTFLAGS = int;
enum : int
{
    SCRIPTFLAGS_CACHEINFO                = 0x00000001,
    SCRIPTFLAGS_SHORTCUTS                = 0x00000004,
    SCRIPTFLAGS_MACHINEASSIGN            = 0x00000008,
    SCRIPTFLAGS_REGDATA_CNFGINFO         = 0x00000020,
    SCRIPTFLAGS_VALIDATE_TRANSFORMS_LIST = 0x00000040,
    SCRIPTFLAGS_REGDATA_CLASSINFO        = 0x00000080,
    SCRIPTFLAGS_REGDATA_EXTENSIONINFO    = 0x00000100,
    SCRIPTFLAGS_REGDATA_APPINFO          = 0x00000180,
    SCRIPTFLAGS_REGDATA                  = 0x000001a0,
}

alias ADVERTISEFLAGS = int;
enum : int
{
    ADVERTISEFLAGS_MACHINEASSIGN = 0x00000000,
    ADVERTISEFLAGS_USERASSIGN    = 0x00000001,
}

alias INSTALLTYPE = int;
enum : int
{
    INSTALLTYPE_DEFAULT         = 0x00000000,
    INSTALLTYPE_NETWORK_IMAGE   = 0x00000001,
    INSTALLTYPE_SINGLE_INSTANCE = 0x00000002,
}

alias MSIARCHITECTUREFLAGS = int;
enum : int
{
    MSIARCHITECTUREFLAGS_X86   = 0x00000001,
    MSIARCHITECTUREFLAGS_IA64  = 0x00000002,
    MSIARCHITECTUREFLAGS_AMD64 = 0x00000004,
    MSIARCHITECTUREFLAGS_ARM   = 0x00000008,
}

alias MSIOPENPACKAGEFLAGS = int;
enum : int
{
    MSIOPENPACKAGEFLAGS_IGNOREMACHINESTATE = 0x00000001,
}

alias MSIADVERTISEOPTIONFLAGS = int;
enum : int
{
    MSIADVERTISEOPTIONFLAGS_INSTANCE = 0x00000001,
}

alias MSISOURCETYPE = int;
enum : int
{
    MSISOURCETYPE_UNKNOWN = 0x00000000,
    MSISOURCETYPE_NETWORK = 0x00000001,
    MSISOURCETYPE_URL     = 0x00000002,
    MSISOURCETYPE_MEDIA   = 0x00000004,
}

alias MSICODE = int;
enum : int
{
    MSICODE_PRODUCT = 0x00000000,
    MSICODE_PATCH   = 0x40000000,
}

alias MSITRANSACTION = int;
enum : int
{
    MSITRANSACTION_CHAIN_EMBEDDEDUI         = 0x00000001,
    MSITRANSACTION_JOIN_EXISTING_EMBEDDEDUI = 0x00000002,
}

alias MSITRANSACTIONSTATE = int;
enum : int
{
    MSITRANSACTIONSTATE_ROLLBACK = 0x00000000,
    MSITRANSACTIONSTATE_COMMIT   = 0x00000001,
}

alias MSIDBSTATE = int;
enum : int
{
    MSIDBSTATE_ERROR = 0xffffffff,
    MSIDBSTATE_READ  = 0x00000000,
    MSIDBSTATE_WRITE = 0x00000001,
}

alias MSIMODIFY = int;
enum : int
{
    MSIMODIFY_SEEK             = 0xffffffff,
    MSIMODIFY_REFRESH          = 0x00000000,
    MSIMODIFY_INSERT           = 0x00000001,
    MSIMODIFY_UPDATE           = 0x00000002,
    MSIMODIFY_ASSIGN           = 0x00000003,
    MSIMODIFY_REPLACE          = 0x00000004,
    MSIMODIFY_MERGE            = 0x00000005,
    MSIMODIFY_DELETE           = 0x00000006,
    MSIMODIFY_INSERT_TEMPORARY = 0x00000007,
    MSIMODIFY_VALIDATE         = 0x00000008,
    MSIMODIFY_VALIDATE_NEW     = 0x00000009,
    MSIMODIFY_VALIDATE_FIELD   = 0x0000000a,
    MSIMODIFY_VALIDATE_DELETE  = 0x0000000b,
}

alias MSICOLINFO = int;
enum : int
{
    MSICOLINFO_NAMES = 0x00000000,
    MSICOLINFO_TYPES = 0x00000001,
}

alias MSICONDITION = int;
enum : int
{
    MSICONDITION_FALSE = 0x00000000,
    MSICONDITION_TRUE  = 0x00000001,
    MSICONDITION_NONE  = 0x00000002,
    MSICONDITION_ERROR = 0x00000003,
}

alias MSICOSTTREE = int;
enum : int
{
    MSICOSTTREE_SELFONLY = 0x00000000,
    MSICOSTTREE_CHILDREN = 0x00000001,
    MSICOSTTREE_PARENTS  = 0x00000002,
    MSICOSTTREE_RESERVED = 0x00000003,
}

alias MSIDBERROR = int;
enum : int
{
    MSIDBERROR_INVALIDARG        = 0xfffffffd,
    MSIDBERROR_MOREDATA          = 0xfffffffe,
    MSIDBERROR_FUNCTIONERROR     = 0xffffffff,
    MSIDBERROR_NOERROR           = 0x00000000,
    MSIDBERROR_DUPLICATEKEY      = 0x00000001,
    MSIDBERROR_REQUIRED          = 0x00000002,
    MSIDBERROR_BADLINK           = 0x00000003,
    MSIDBERROR_OVERFLOW          = 0x00000004,
    MSIDBERROR_UNDERFLOW         = 0x00000005,
    MSIDBERROR_NOTINSET          = 0x00000006,
    MSIDBERROR_BADVERSION        = 0x00000007,
    MSIDBERROR_BADCASE           = 0x00000008,
    MSIDBERROR_BADGUID           = 0x00000009,
    MSIDBERROR_BADWILDCARD       = 0x0000000a,
    MSIDBERROR_BADIDENTIFIER     = 0x0000000b,
    MSIDBERROR_BADLANGUAGE       = 0x0000000c,
    MSIDBERROR_BADFILENAME       = 0x0000000d,
    MSIDBERROR_BADPATH           = 0x0000000e,
    MSIDBERROR_BADCONDITION      = 0x0000000f,
    MSIDBERROR_BADFORMATTED      = 0x00000010,
    MSIDBERROR_BADTEMPLATE       = 0x00000011,
    MSIDBERROR_BADDEFAULTDIR     = 0x00000012,
    MSIDBERROR_BADREGPATH        = 0x00000013,
    MSIDBERROR_BADCUSTOMSOURCE   = 0x00000014,
    MSIDBERROR_BADPROPERTY       = 0x00000015,
    MSIDBERROR_MISSINGDATA       = 0x00000016,
    MSIDBERROR_BADCATEGORY       = 0x00000017,
    MSIDBERROR_BADKEYTABLE       = 0x00000018,
    MSIDBERROR_BADMAXMINVALUES   = 0x00000019,
    MSIDBERROR_BADCABINET        = 0x0000001a,
    MSIDBERROR_BADSHORTCUT       = 0x0000001b,
    MSIDBERROR_STRINGOVERFLOW    = 0x0000001c,
    MSIDBERROR_BADLOCALIZEATTRIB = 0x0000001d,
}

alias MSIRUNMODE = int;
enum : int
{
    MSIRUNMODE_ADMIN            = 0x00000000,
    MSIRUNMODE_ADVERTISE        = 0x00000001,
    MSIRUNMODE_MAINTENANCE      = 0x00000002,
    MSIRUNMODE_ROLLBACKENABLED  = 0x00000003,
    MSIRUNMODE_LOGENABLED       = 0x00000004,
    MSIRUNMODE_OPERATIONS       = 0x00000005,
    MSIRUNMODE_REBOOTATEND      = 0x00000006,
    MSIRUNMODE_REBOOTNOW        = 0x00000007,
    MSIRUNMODE_CABINET          = 0x00000008,
    MSIRUNMODE_SOURCESHORTNAMES = 0x00000009,
    MSIRUNMODE_TARGETSHORTNAMES = 0x0000000a,
    MSIRUNMODE_RESERVED11       = 0x0000000b,
    MSIRUNMODE_WINDOWS9X        = 0x0000000c,
    MSIRUNMODE_ZAWENABLED       = 0x0000000d,
    MSIRUNMODE_RESERVED14       = 0x0000000e,
    MSIRUNMODE_RESERVED15       = 0x0000000f,
    MSIRUNMODE_SCHEDULED        = 0x00000010,
    MSIRUNMODE_ROLLBACK         = 0x00000011,
    MSIRUNMODE_COMMIT           = 0x00000012,
}

alias MSITRANSFORM_ERROR = int;
enum : int
{
    MSITRANSFORM_ERROR_ADDEXISTINGROW   = 0x00000001,
    MSITRANSFORM_ERROR_DELMISSINGROW    = 0x00000002,
    MSITRANSFORM_ERROR_ADDEXISTINGTABLE = 0x00000004,
    MSITRANSFORM_ERROR_DELMISSINGTABLE  = 0x00000008,
    MSITRANSFORM_ERROR_UPDATEMISSINGROW = 0x00000010,
    MSITRANSFORM_ERROR_CHANGECODEPAGE   = 0x00000020,
    MSITRANSFORM_ERROR_VIEWTRANSFORM    = 0x00000100,
}

alias MSITRANSFORM_VALIDATE = int;
enum : int
{
    MSITRANSFORM_VALIDATE_LANGUAGE                   = 0x00000001,
    MSITRANSFORM_VALIDATE_PRODUCT                    = 0x00000002,
    MSITRANSFORM_VALIDATE_PLATFORM                   = 0x00000004,
    MSITRANSFORM_VALIDATE_MAJORVERSION               = 0x00000008,
    MSITRANSFORM_VALIDATE_MINORVERSION               = 0x00000010,
    MSITRANSFORM_VALIDATE_UPDATEVERSION              = 0x00000020,
    MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION         = 0x00000040,
    MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION    = 0x00000080,
    MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION        = 0x00000100,
    MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION = 0x00000200,
    MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION      = 0x00000400,
    MSITRANSFORM_VALIDATE_UPGRADECODE                = 0x00000800,
}

///The values of the <b>ASM_NAME</b> enumeration are the property IDs for the name-value pairs included in a
///side-by-side assembly name.
alias ASM_NAME = int;
enum : int
{
    ///Property ID for the assembly's public key. The value is a byte array.
    ASM_NAME_PUBLIC_KEY            = 0x00000000,
    ///Property ID for the assembly's public key token. The value is a byte array.
    ASM_NAME_PUBLIC_KEY_TOKEN      = 0x00000001,
    ///Property ID for a reserved name-value pair. The value is a byte array.
    ASM_NAME_HASH_VALUE            = 0x00000002,
    ///Property ID for the assembly's simple name. The value is a string value.
    ASM_NAME_NAME                  = 0x00000003,
    ///Property ID for the assembly's major version. The value is a <b>WORD</b> value.
    ASM_NAME_MAJOR_VERSION         = 0x00000004,
    ///Property ID for the assembly's minor version. The value is a <b>WORD</b> value.
    ASM_NAME_MINOR_VERSION         = 0x00000005,
    ///Property ID for the assembly's build version. The value is a <b>WORD</b> value.
    ASM_NAME_BUILD_NUMBER          = 0x00000006,
    ///Property ID for the assembly's revision version. The value is a <b>WORD</b> value.
    ASM_NAME_REVISION_NUMBER       = 0x00000007,
    ///Property ID for the assembly's culture. The value is a string value.
    ASM_NAME_CULTURE               = 0x00000008,
    ///Property ID for a reserved name-value pair.
    ASM_NAME_PROCESSOR_ID_ARRAY    = 0x00000009,
    ///Property ID for a reserved name-value pair.
    ASM_NAME_OSINFO_ARRAY          = 0x0000000a,
    ///Property ID for a reserved name-value pair. The value is a <b>DWORD</b> value.
    ASM_NAME_HASH_ALGID            = 0x0000000b,
    ///Property ID for a reserved name-value pair.
    ASM_NAME_ALIAS                 = 0x0000000c,
    ///Property ID for a reserved name-value pair.
    ASM_NAME_CODEBASE_URL          = 0x0000000d,
    ///Property ID for a reserved name-value pair. The value is a <b>FILETIME</b> structure.
    ASM_NAME_CODEBASE_LASTMOD      = 0x0000000e,
    ///Property ID for the assembly as a simply named assembly that does not have a public key.
    ASM_NAME_NULL_PUBLIC_KEY       = 0x0000000f,
    ///Property ID for the assembly as a simply named assembly that does not have a public key token.
    ASM_NAME_NULL_PUBLIC_KEY_TOKEN = 0x00000010,
    ///Property ID for a reserved name-value pair. The value is a string value.
    ASM_NAME_CUSTOM                = 0x00000011,
    ///Property ID for a reserved name-value pair.
    ASM_NAME_NULL_CUSTOM           = 0x00000012,
    ///Property ID for a reserved name-value pair.
    ASM_NAME_MVID                  = 0x00000013,
    ASM_NAME_MAX_PARAMS            = 0x00000014,
}

alias __MIDL_IAssemblyName_0002 = int;
enum : int
{
    ASM_BINDF_FORCE_CACHE_INSTALL = 0x00000001,
    ASM_BINDF_RFS_INTEGRITY_CHECK = 0x00000002,
    ASM_BINDF_RFS_MODULE_CHECK    = 0x00000004,
    ASM_BINDF_BINPATH_PROBE_ONLY  = 0x00000008,
    ASM_BINDF_SHARED_BINPATH_HINT = 0x00000010,
    ASM_BINDF_PARENT_ASM_HINT     = 0x00000020,
}

///The values of the <b>ASM_DISPLAY_FLAGS</b> enumeration are used by the GetDisplayName method to specify which
///portions of the assembly's full name to include in the string representation of the assembly name.
alias ASM_DISPLAY_FLAGS = int;
enum : int
{
    ///Include the version number.
    ASM_DISPLAYF_VERSION               = 0x00000001,
    ///Include the culture.
    ASM_DISPLAYF_CULTURE               = 0x00000002,
    ///Include the public key token.
    ASM_DISPLAYF_PUBLIC_KEY_TOKEN      = 0x00000004,
    ///Include the public key.
    ASM_DISPLAYF_PUBLIC_KEY            = 0x00000008,
    ///Include the custom part of the assembly name.
    ASM_DISPLAYF_CUSTOM                = 0x00000010,
    ///Include the processor architecture.
    ASM_DISPLAYF_PROCESSORARCHITECTURE = 0x00000020,
    ASM_DISPLAYF_LANGUAGEID            = 0x00000040,
}

///The values of the <b>ASM_CMP_FLAGS</b> enumeration are used by the IsEqual method to specify which portions of two
///assembly names to compare.
alias ASM_CMP_FLAGS = int;
enum : int
{
    ///Compare the name portion of the assembly names.
    ASM_CMPF_NAME             = 0x00000001,
    ///Compare the major version portion of the assembly names.
    ASM_CMPF_MAJOR_VERSION    = 0x00000002,
    ///Compare the minor version portion of the assembly names.
    ASM_CMPF_MINOR_VERSION    = 0x00000004,
    ///Compare the build version portion of the assembly names.
    ASM_CMPF_BUILD_NUMBER     = 0x00000008,
    ///Compare the revision version portion of the assembly names.
    ASM_CMPF_REVISION_NUMBER  = 0x00000010,
    ///Compare the public key token portion of the assembly names.
    ASM_CMPF_PUBLIC_KEY_TOKEN = 0x00000020,
    ///Compare the culture portion of the assembly names.
    ASM_CMPF_CULTURE          = 0x00000040,
    ///Compare the custom portion of the assembly names.
    ASM_CMPF_CUSTOM           = 0x00000080,
    ///Compare all portions of the assembly names. This is equivalent to setting: ASM_CMPF_NAME | ASM_CMPF_MAJOR_VERSION
    ///| ASM_CMPF_MINOR_VERSION | ASM_CMPF_REVISION_NUMBER | ASM_CMPF_BUILD_NUMBER | ASM_CMPF_PUBLIC_KEY_TOKEN |
    ///ASM_CMPF_CULTURE | ASM_CMPF_CUSTOM
    ASM_CMPF_ALL              = 0x000000ff,
    ASM_CMPF_DEFAULT          = 0x00000100,
}

///The <b>CREATE_ASM_NAME_OBJ_FLAGS</b> enumeration is used by the CreateAssemblyNameObject function. If no value is
///specified, the <i>szAssemblyName</i> parameter of the CreateAssemblyNameObject function is the "Name" portion of the
///fully-specified assembly name.
alias CREATE_ASM_NAME_OBJ_FLAGS = int;
enum : int
{
    ///If this flag is specified, the <i>szAssemblyName</i> parameter of CreateAssemblyNameObject is a fully-specified
    ///side-by-side assembly name and is parsed to the individual properties.
    CANOF_PARSE_DISPLAY_NAME = 0x00000001,
    CANOF_SET_DEFAULT_VALUES = 0x00000002,
}

// Callbacks

///The <b>LPDISPLAYVAL</b> function specification defines a callback function prototype. The IValidate::SetDisplay
///method enables an authoring tool to receive ICE status messages through the registered callback function.
///Params:
///    pContext = A pointer to an application context passed to the SetDisplay method. This parameter can be used for error
///               checking.
///    uiType = Specifies the type of message sent by the ICE. This parameter can be one of the following values. <table> <tr>
///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ieUnknown"></a><a id="ieunknown"></a><a
///             id="IEUNKNOWN"></a><dl> <dt><b>ieUnknown</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Unknown ICE message.
///             </td> </tr> <tr> <td width="40%"><a id="ieError"></a><a id="ieerror"></a><a id="IEERROR"></a><dl>
///             <dt><b>ieError</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> ICE error message. </td> </tr> <tr> <td
///             width="40%"><a id="ieWarning"></a><a id="iewarning"></a><a id="IEWARNING"></a><dl> <dt><b>ieWarning</b></dt>
///             <dt>2</dt> </dl> </td> <td width="60%"> ICE warning message. </td> </tr> <tr> <td width="40%"><a
///             id="ieInfo"></a><a id="ieinfo"></a><a id="IEINFO"></a><dl> <dt><b>ieInfo</b></dt> <dt>3</dt> </dl> </td> <td
///             width="60%"> ICE information message. </td> </tr> </table>
///    szwVal = The name of the ICE reporting the message, or an error reported by evalcom2 during validation.
///    szwDescription = The message text.
///    szwLocation = The location of the error. This parameter can be <b>NULL</b> if the error does not refer to an actual database
///                  table or row. Specify the location of the error using the following format:
///                  Table\tColumn\tPrimaryKey1[\tPrimaryKey2\ . . .].
///Returns:
///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b><b>TRUE</b></b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Validation procedure should continue. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>FALSE</b></b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Validation
///    was canceled. The callback function return <b>FALSE</b> to stop validation. </td> </tr> </table>
///    
alias LPDISPLAYVAL = BOOL function(void* pContext, RESULTTYPES uiType, const(wchar)* szwVal, 
                                   const(wchar)* szwDescription, const(wchar)* szwLocation);
///The <b>LPEVALCOMCALLBACK</b> specification defines a callback function prototype. The IValidate::SetStatus method
///enables an authoring tool to receive information about the progress of validation through the registered callback
///function.
///Params:
///    iStatus = Specifies the status message sent by evalcom2. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///              width="40%"> <dl> <dt><b>NULL</b></dt> </dl> </td> <td width="60%"> The value of this param </td> </tr> <tr> <td
///              width="40%"><a id="ieStatusICECount"></a><a id="iestatusicecount"></a><a id="IESTATUSICECOUNT"></a><dl>
///              <dt><b>ieStatusICECount</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Number of ICEs that are being run. </td>
///              </tr> <tr> <td width="40%"><a id="ieStatusMerge"></a><a id="iestatusmerge"></a><a id="IESTATUSMERGE"></a><dl>
///              <dt><b>ieStatusMerge</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Merging the package or merge module with
///              the .cub file. </td> </tr> <tr> <td width="40%"><a id="ieStatusSummaryInfo"></a><a
///              id="iestatussummaryinfo"></a><a id="IESTATUSSUMMARYINFO"></a><dl> <dt><b>ieStatusSummaryInfo</b></dt> <dt>3</dt>
///              </dl> </td> <td width="60%"> Merging summary information streams. </td> </tr> <tr> <td width="40%"><a
///              id="ieStatusCreateEngine"></a><a id="iestatuscreateengine"></a><a id="IESTATUSCREATEENGINE"></a><dl>
///              <dt><b>ieStatusCreateEngine</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Preparing to run the ICEs. </td>
///              </tr> <tr> <td width="40%"><a id="ieStatusRunICE"></a><a id="iestatusrunice"></a><a id="IESTATUSRUNICE"></a><dl>
///              <dt><b>ieStatusRunICE</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Running an individual ICE. </td> </tr>
///              <tr> <td width="40%"><a id="ieStatusStarting"></a><a id="iestatusstarting"></a><a id="IESTATUSSTARTING"></a><dl>
///              <dt><b>ieStatusStarting</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> Starting validation. </td> </tr> <tr>
///              <td width="40%"><a id="ieStatusShutdown"></a><a id="iestatusshutdown"></a><a id="IESTATUSSHUTDOWN"></a><dl>
///              <dt><b>ieStatusShutdown</b></dt> <dt>7</dt> </dl> </td> <td width="60%"> Finish running the ICEs. </td> </tr>
///              <tr> <td width="40%"><a id="ieStatusSuccess"></a><a id="iestatussuccess"></a><a id="IESTATUSSUCCESS"></a><dl>
///              <dt><b>ieStatusSuccess</b></dt> <dt>8</dt> </dl> </td> <td width="60%"> Validation completed successfully. </td>
///              </tr> <tr> <td width="40%"><a id="ieStatusFail"></a><a id="iestatusfail"></a><a id="IESTATUSFAIL"></a><dl>
///              <dt><b>ieStatusFail</b></dt> <dt>9</dt> </dl> </td> <td width="60%"> Validation failed. </td> </tr> <tr> <td
///              width="40%"><a id="ieStatusCancel"></a><a id="iestatuscancel"></a><a id="IESTATUSCANCEL"></a><dl>
///              <dt><b>ieStatusCancel</b></dt> <dt>10</dt> </dl> </td> <td width="60%"> Validation was canceled. </td> </tr>
///              </table>
///    szData = A string value containing information appropriate to the status. The value of <i>szwData</i> should be the number
///             of ICEs that are being run if <i>iStatus</i> is <b>ieStatusICECount</b>. The value of <i>szwData</i> should be
///             the name of the ICE being run if <i>iStatus</i> is <b>ieStatusRunICE</b>. Otherwise, the value of <i>szwData</i>
///             should be <b>NULL</b>. The callback function should accept <b>NULL</b> as a possible value for this parameter.
///    pContext = Pointer to an application context passed to the SetStatus method. This parameter can be used for error checking.
///Returns:
///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b><b>TRUE</b></b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Validation procedure should continue. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>FALSE</b></b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Validation
///    was canceled. The callback function return <b>FALSE</b> to stop validation. </td> </tr> </table>
///    
alias LPEVALCOMCALLBACK = BOOL function(STATUSTYPES iStatus, const(wchar)* szData, void* pContext);
///The <b>INSTALLUI_HANDLER</b> function prototype defines a callback function that the installer calls for progress
///notification and error messages. For more information on the usage of this function prototype, a sample code snippet
///is available in Handling Progress Messages Using MsiSetExternalUI.
///Params:
///    pvContext = Pointer to an application context passed to the MsiSetExternalUI function. This parameter can be used for error
///                checking.
///    iMessageType = Specifies a combination of one message box style, one message box icon type, one default button, and one
///                   installation message type. This parameter must be one of the following. <table> <tr> <th>Message box
///                   StylesFlag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MB_ABORTRETRYIGNORE"></a><a
///                   id="mb_abortretryignore"></a><dl> <dt><b>MB_ABORTRETRYIGNORE</b></dt> </dl> </td> <td width="60%"> The message
///                   box contains the <b>Abort</b>, <b>Retry</b>, and <b>Ignore</b> buttons. </td> </tr> <tr> <td width="40%"><a
///                   id="MB_OK"></a><a id="mb_ok"></a><dl> <dt><b>MB_OK</b></dt> </dl> </td> <td width="60%"> The message box contains
///                   the <b>OK</b> button. This is the default. </td> </tr> <tr> <td width="40%"><a id="MB_OKCANCEL"></a><a
///                   id="mb_okcancel"></a><dl> <dt><b>MB_OKCANCEL</b></dt> </dl> </td> <td width="60%"> The message box contains the
///                   <b>OK</b> and <b>Cancel</b> buttons. </td> </tr> <tr> <td width="40%"><a id="MB_RETRYCANCEL"></a><a
///                   id="mb_retrycancel"></a><dl> <dt><b>MB_RETRYCANCEL</b></dt> </dl> </td> <td width="60%"> The message box contains
///                   the <b>Retry</b> and <b>Cancel</b> buttons. </td> </tr> <tr> <td width="40%"><a id="MB_YESNO"></a><a
///                   id="mb_yesno"></a><dl> <dt><b>MB_YESNO</b></dt> </dl> </td> <td width="60%"> The message box contains the
///                   <b>Yes</b> and <b>No</b> buttons. </td> </tr> <tr> <td width="40%"><a id="MB_YESNOCANCEL"></a><a
///                   id="mb_yesnocancel"></a><dl> <dt><b>MB_YESNOCANCEL</b></dt> </dl> </td> <td width="60%"> The message box contains
///                   the <b>Yes</b>, <b>No</b>, and <b>Cancel</b> buttons. </td> </tr> </table> <table> <tr> <th>Message box
///                   IconTypesFlag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MB_ICONEXCLAMATION__MB_ICONWARNING"></a><a
///                   id="mb_iconexclamation__mb_iconwarning"></a><dl> <dt><b>MB_ICONEXCLAMATION, MB_ICONWARNING</b></dt> </dl> </td>
///                   <td width="60%"> An exclamation point appears in the message box. </td> </tr> <tr> <td width="40%"><a
///                   id="MB_ICONINFORMATION__MB_ICONASTERISK"></a><a id="mb_iconinformation__mb_iconasterisk"></a><dl>
///                   <dt><b>MB_ICONINFORMATION, MB_ICONASTERISK</b></dt> </dl> </td> <td width="60%"> The information sign appears in
///                   the message box. </td> </tr> <tr> <td width="40%"><a id="MB_ICONQUESTION"></a><a id="mb_iconquestion"></a><dl>
///                   <dt><b>MB_ICONQUESTION</b></dt> </dl> </td> <td width="60%"> A question mark appears in the message box. </td>
///                   </tr> <tr> <td width="40%"><a id="MB_ICONSTOP__MB_ICONERROR__MB_ICONHAND"></a><a
///                   id="mb_iconstop__mb_iconerror__mb_iconhand"></a><dl> <dt><b>MB_ICONSTOP, MB_ICONERROR, MB_ICONHAND</b></dt> </dl>
///                   </td> <td width="60%"> A stop sign appears in the message box. </td> </tr> </table> <table> <tr> <th>Default
///                   ButtonsFlag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MB_DEFBUTTON1"></a><a
///                   id="mb_defbutton1"></a><dl> <dt><b>MB_DEFBUTTON1</b></dt> </dl> </td> <td width="60%"> The first button is the
///                   default button. </td> </tr> <tr> <td width="40%"><a id="MB_DEFBUTTON2"></a><a id="mb_defbutton2"></a><dl>
///                   <dt><b>MB_DEFBUTTON2</b></dt> </dl> </td> <td width="60%"> The second button is the default button. </td> </tr>
///                   <tr> <td width="40%"><a id="MB_DEFBUTTON3"></a><a id="mb_defbutton3"></a><dl> <dt><b>MB_DEFBUTTON3</b></dt> </dl>
///                   </td> <td width="60%"> The third button is the default button. </td> </tr> </table> <table> <tr> <th>Install
///                   message TypesFlag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_FATALEXIT"></a><a
///                   id="installmessage_fatalexit"></a><dl> <dt><b>INSTALLMESSAGE_FATALEXIT</b></dt> </dl> </td> <td width="60%">
///                   Premature termination </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_ERROR"></a><a
///                   id="installmessage_error"></a><dl> <dt><b>INSTALLMESSAGE_ERROR</b></dt> </dl> </td> <td width="60%"> Formatted
///                   error message </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_WARNING"></a><a
///                   id="installmessage_warning"></a><dl> <dt><b>INSTALLMESSAGE_WARNING</b></dt> </dl> </td> <td width="60%">
///                   Formatted warning message </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_USER"></a><a
///                   id="installmessage_user"></a><dl> <dt><b>INSTALLMESSAGE_USER</b></dt> </dl> </td> <td width="60%"> User request
///                   message. </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_INFO"></a><a id="installmessage_info"></a><dl>
///                   <dt><b>INSTALLMESSAGE_INFO</b></dt> </dl> </td> <td width="60%"> Informative message for log </td> </tr> <tr> <td
///                   width="40%"><a id="INSTALLMESSAGE_FILESINUSE"></a><a id="installmessage_filesinuse"></a><dl>
///                   <dt><b>INSTALLMESSAGE_FILESINUSE</b></dt> </dl> </td> <td width="60%"> List of files currently in use that must
///                   be closed before being replaced. </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_RESOLVESOURCE"></a><a
///                   id="installmessage_resolvesource"></a><dl> <dt><b>INSTALLMESSAGE_RESOLVESOURCE</b></dt> </dl> </td> <td
///                   width="60%"> Request to determine a valid source location </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_RMFILESINUSE"></a><a id="installmessage_rmfilesinuse"></a><dl>
///                   <dt><b>INSTALLMESSAGE_RMFILESINUSE</b></dt> </dl> </td> <td width="60%"> List of files currently in use that must
///                   be closed before being replaced. Available beginning with Windows Installer 4.0. For more information about this
///                   message see Using Restart Manager with an External UI. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_OUTOFDISKSPACE"></a><a id="installmessage_outofdiskspace"></a><dl>
///                   <dt><b>INSTALLMESSAGE_OUTOFDISKSPACE</b></dt> </dl> </td> <td width="60%"> Insufficient disk space message </td>
///                   </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_ACTIONSTART"></a><a id="installmessage_actionstart"></a><dl>
///                   <dt><b>INSTALLMESSAGE_ACTIONSTART</b></dt> </dl> </td> <td width="60%"> Start of action message. This message
///                   includes the action name and description. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_ACTIONDATA"></a><a id="installmessage_actiondata"></a><dl>
///                   <dt><b>INSTALLMESSAGE_ACTIONDATA</b></dt> </dl> </td> <td width="60%"> Formatted data associated with the
///                   individual action item. </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_PROGRESS"></a><a
///                   id="installmessage_progress"></a><dl> <dt><b>INSTALLMESSAGE_PROGRESS</b></dt> </dl> </td> <td width="60%">
///                   Progress gauge information. This message includes information on units so far and total number of units. </td>
///                   </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_COMMONDATA"></a><a id="installmessage_commondata"></a><dl>
///                   <dt><b>INSTALLMESSAGE_COMMONDATA</b></dt> </dl> </td> <td width="60%"> Formatted dialog information for user
///                   interface. </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_INITIALIZE"></a><a
///                   id="installmessage_initialize"></a><dl> <dt><b>INSTALLMESSAGE_INITIALIZE</b></dt> </dl> </td> <td width="60%">
///                   Sent prior to UI initialization, no string data </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_TERMINATE"></a><a id="installmessage_terminate"></a><dl>
///                   <dt><b>INSTALLMESSAGE_TERMINATE</b></dt> </dl> </td> <td width="60%"> Sent after UI termination, no string data
///                   </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_SHOWDIALOG"></a><a id="installmessage_showdialog"></a><dl>
///                   <dt><b>INSTALLMESSAGE_SHOWDIALOG</b></dt> </dl> </td> <td width="60%"> Sent prior to display of authored dialog
///                   or wizard </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_INSTALLSTART"></a><a
///                   id="installmessage_installstart"></a><dl> <dt><b>INSTALLMESSAGE_INSTALLSTART</b></dt> </dl> </td> <td
///                   width="60%"> Sent prior to installation of product. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_INSTALLEND"></a><a id="installmessage_installend"></a><dl>
///                   <dt><b>INSTALLMESSAGE_INSTALLEND</b></dt> </dl> </td> <td width="60%"> Sent after installation of product. </td>
///                   </tr> </table> <div> </div> The following defaults should be used if any of the preceding messages are missing:
///                   MB_OK, no icon, and MB_DEFBUTTON1. There is no default installation message type; a message type is always
///                   specified.
///    szMessage = Specifies the message text.
///Returns:
///    The following return values map to the buttons specified by the message box style: IDOK<div> </div>IDCANCEL<div>
///    </div>IDABORT<div> </div>IDRETRY<div> </div>IDIGNORE<div> </div>IDYES<div> </div>IDNO
///    
alias INSTALLUI_HANDLERA = int function(void* pvContext, uint iMessageType, const(char)* szMessage);
///The <b>INSTALLUI_HANDLER</b> function prototype defines a callback function that the installer calls for progress
///notification and error messages. For more information on the usage of this function prototype, a sample code snippet
///is available in Handling Progress Messages Using MsiSetExternalUI.
///Params:
///    pvContext = Pointer to an application context passed to the MsiSetExternalUI function. This parameter can be used for error
///                checking.
///    iMessageType = Specifies a combination of one message box style, one message box icon type, one default button, and one
///                   installation message type. This parameter must be one of the following. <table> <tr> <th>Message box
///                   StylesFlag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MB_ABORTRETRYIGNORE"></a><a
///                   id="mb_abortretryignore"></a><dl> <dt><b>MB_ABORTRETRYIGNORE</b></dt> </dl> </td> <td width="60%"> The message
///                   box contains the <b>Abort</b>, <b>Retry</b>, and <b>Ignore</b> buttons. </td> </tr> <tr> <td width="40%"><a
///                   id="MB_OK"></a><a id="mb_ok"></a><dl> <dt><b>MB_OK</b></dt> </dl> </td> <td width="60%"> The message box contains
///                   the <b>OK</b> button. This is the default. </td> </tr> <tr> <td width="40%"><a id="MB_OKCANCEL"></a><a
///                   id="mb_okcancel"></a><dl> <dt><b>MB_OKCANCEL</b></dt> </dl> </td> <td width="60%"> The message box contains the
///                   <b>OK</b> and <b>Cancel</b> buttons. </td> </tr> <tr> <td width="40%"><a id="MB_RETRYCANCEL"></a><a
///                   id="mb_retrycancel"></a><dl> <dt><b>MB_RETRYCANCEL</b></dt> </dl> </td> <td width="60%"> The message box contains
///                   the <b>Retry</b> and <b>Cancel</b> buttons. </td> </tr> <tr> <td width="40%"><a id="MB_YESNO"></a><a
///                   id="mb_yesno"></a><dl> <dt><b>MB_YESNO</b></dt> </dl> </td> <td width="60%"> The message box contains the
///                   <b>Yes</b> and <b>No</b> buttons. </td> </tr> <tr> <td width="40%"><a id="MB_YESNOCANCEL"></a><a
///                   id="mb_yesnocancel"></a><dl> <dt><b>MB_YESNOCANCEL</b></dt> </dl> </td> <td width="60%"> The message box contains
///                   the <b>Yes</b>, <b>No</b>, and <b>Cancel</b> buttons. </td> </tr> </table> <table> <tr> <th>Message box
///                   IconTypesFlag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MB_ICONEXCLAMATION__MB_ICONWARNING"></a><a
///                   id="mb_iconexclamation__mb_iconwarning"></a><dl> <dt><b>MB_ICONEXCLAMATION, MB_ICONWARNING</b></dt> </dl> </td>
///                   <td width="60%"> An exclamation point appears in the message box. </td> </tr> <tr> <td width="40%"><a
///                   id="MB_ICONINFORMATION__MB_ICONASTERISK"></a><a id="mb_iconinformation__mb_iconasterisk"></a><dl>
///                   <dt><b>MB_ICONINFORMATION, MB_ICONASTERISK</b></dt> </dl> </td> <td width="60%"> The information sign appears in
///                   the message box. </td> </tr> <tr> <td width="40%"><a id="MB_ICONQUESTION"></a><a id="mb_iconquestion"></a><dl>
///                   <dt><b>MB_ICONQUESTION</b></dt> </dl> </td> <td width="60%"> A question mark appears in the message box. </td>
///                   </tr> <tr> <td width="40%"><a id="MB_ICONSTOP__MB_ICONERROR__MB_ICONHAND"></a><a
///                   id="mb_iconstop__mb_iconerror__mb_iconhand"></a><dl> <dt><b>MB_ICONSTOP, MB_ICONERROR, MB_ICONHAND</b></dt> </dl>
///                   </td> <td width="60%"> A stop sign appears in the message box. </td> </tr> </table> <table> <tr> <th>Default
///                   ButtonsFlag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MB_DEFBUTTON1"></a><a
///                   id="mb_defbutton1"></a><dl> <dt><b>MB_DEFBUTTON1</b></dt> </dl> </td> <td width="60%"> The first button is the
///                   default button. </td> </tr> <tr> <td width="40%"><a id="MB_DEFBUTTON2"></a><a id="mb_defbutton2"></a><dl>
///                   <dt><b>MB_DEFBUTTON2</b></dt> </dl> </td> <td width="60%"> The second button is the default button. </td> </tr>
///                   <tr> <td width="40%"><a id="MB_DEFBUTTON3"></a><a id="mb_defbutton3"></a><dl> <dt><b>MB_DEFBUTTON3</b></dt> </dl>
///                   </td> <td width="60%"> The third button is the default button. </td> </tr> </table> <table> <tr> <th>Install
///                   message TypesFlag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_FATALEXIT"></a><a
///                   id="installmessage_fatalexit"></a><dl> <dt><b>INSTALLMESSAGE_FATALEXIT</b></dt> </dl> </td> <td width="60%">
///                   Premature termination </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_ERROR"></a><a
///                   id="installmessage_error"></a><dl> <dt><b>INSTALLMESSAGE_ERROR</b></dt> </dl> </td> <td width="60%"> Formatted
///                   error message </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_WARNING"></a><a
///                   id="installmessage_warning"></a><dl> <dt><b>INSTALLMESSAGE_WARNING</b></dt> </dl> </td> <td width="60%">
///                   Formatted warning message </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_USER"></a><a
///                   id="installmessage_user"></a><dl> <dt><b>INSTALLMESSAGE_USER</b></dt> </dl> </td> <td width="60%"> User request
///                   message. </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_INFO"></a><a id="installmessage_info"></a><dl>
///                   <dt><b>INSTALLMESSAGE_INFO</b></dt> </dl> </td> <td width="60%"> Informative message for log </td> </tr> <tr> <td
///                   width="40%"><a id="INSTALLMESSAGE_FILESINUSE"></a><a id="installmessage_filesinuse"></a><dl>
///                   <dt><b>INSTALLMESSAGE_FILESINUSE</b></dt> </dl> </td> <td width="60%"> List of files currently in use that must
///                   be closed before being replaced. </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_RESOLVESOURCE"></a><a
///                   id="installmessage_resolvesource"></a><dl> <dt><b>INSTALLMESSAGE_RESOLVESOURCE</b></dt> </dl> </td> <td
///                   width="60%"> Request to determine a valid source location </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_RMFILESINUSE"></a><a id="installmessage_rmfilesinuse"></a><dl>
///                   <dt><b>INSTALLMESSAGE_RMFILESINUSE</b></dt> </dl> </td> <td width="60%"> List of files currently in use that must
///                   be closed before being replaced. Available beginning with Windows Installer 4.0. For more information about this
///                   message see Using Restart Manager with an External UI. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_OUTOFDISKSPACE"></a><a id="installmessage_outofdiskspace"></a><dl>
///                   <dt><b>INSTALLMESSAGE_OUTOFDISKSPACE</b></dt> </dl> </td> <td width="60%"> Insufficient disk space message </td>
///                   </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_ACTIONSTART"></a><a id="installmessage_actionstart"></a><dl>
///                   <dt><b>INSTALLMESSAGE_ACTIONSTART</b></dt> </dl> </td> <td width="60%"> Start of action message. This message
///                   includes the action name and description. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_ACTIONDATA"></a><a id="installmessage_actiondata"></a><dl>
///                   <dt><b>INSTALLMESSAGE_ACTIONDATA</b></dt> </dl> </td> <td width="60%"> Formatted data associated with the
///                   individual action item. </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_PROGRESS"></a><a
///                   id="installmessage_progress"></a><dl> <dt><b>INSTALLMESSAGE_PROGRESS</b></dt> </dl> </td> <td width="60%">
///                   Progress gauge information. This message includes information on units so far and total number of units. </td>
///                   </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_COMMONDATA"></a><a id="installmessage_commondata"></a><dl>
///                   <dt><b>INSTALLMESSAGE_COMMONDATA</b></dt> </dl> </td> <td width="60%"> Formatted dialog information for user
///                   interface. </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_INITIALIZE"></a><a
///                   id="installmessage_initialize"></a><dl> <dt><b>INSTALLMESSAGE_INITIALIZE</b></dt> </dl> </td> <td width="60%">
///                   Sent prior to UI initialization, no string data </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_TERMINATE"></a><a id="installmessage_terminate"></a><dl>
///                   <dt><b>INSTALLMESSAGE_TERMINATE</b></dt> </dl> </td> <td width="60%"> Sent after UI termination, no string data
///                   </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_SHOWDIALOG"></a><a id="installmessage_showdialog"></a><dl>
///                   <dt><b>INSTALLMESSAGE_SHOWDIALOG</b></dt> </dl> </td> <td width="60%"> Sent prior to display of authored dialog
///                   or wizard </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_INSTALLSTART"></a><a
///                   id="installmessage_installstart"></a><dl> <dt><b>INSTALLMESSAGE_INSTALLSTART</b></dt> </dl> </td> <td
///                   width="60%"> Sent prior to installation of product. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_INSTALLEND"></a><a id="installmessage_installend"></a><dl>
///                   <dt><b>INSTALLMESSAGE_INSTALLEND</b></dt> </dl> </td> <td width="60%"> Sent after installation of product. </td>
///                   </tr> </table> <div> </div> The following defaults should be used if any of the preceding messages are missing:
///                   MB_OK, no icon, and MB_DEFBUTTON1. There is no default installation message type; a message type is always
///                   specified.
///    szMessage = Specifies the message text.
///Returns:
///    The following return values map to the buttons specified by the message box style: IDOK<div> </div>IDCANCEL<div>
///    </div>IDABORT<div> </div>IDRETRY<div> </div>IDIGNORE<div> </div>IDYES<div> </div>IDNO
///    
alias INSTALLUI_HANDLERW = int function(void* pvContext, uint iMessageType, const(wchar)* szMessage);
///The <b>INSTALLUI_HANDLER_RECORD</b> function prototype defines a callback function that the installer calls for
///progress notification and error messages. Call the <b>MsiSetExternalUIRecord</b> function to enable a record-base
///external user-interface (UI) handler. <b>Windows Installer 3.0 and Windows Installer 2.0: </b>Not supported.
///Available beginning with Windows Installer version 3.1 and later.
///Params:
///    pvContext = Pointer to an application context passed to the MsiSetExternalUIRecord function. This parameter can be used for
///                error checking.
///    iMessageType = Specifies a combination of one message box style, one message box icon type, one default button, and one
///                   installation message type. This parameter must be one of the following. <table> <tr> <th>Message box
///                   StylesFlag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MB_ABORTRETRYIGNORE"></a><a
///                   id="mb_abortretryignore"></a><dl> <dt><b>MB_ABORTRETRYIGNORE</b></dt> </dl> </td> <td width="60%"> The message
///                   box contains the <b>Abort</b>, <b>Retry</b>, and <b>Ignore</b> buttons. </td> </tr> <tr> <td width="40%"><a
///                   id="MB_OK"></a><a id="mb_ok"></a><dl> <dt><b>MB_OK</b></dt> </dl> </td> <td width="60%"> The message box contains
///                   the <b>OK</b> button. This is the default. </td> </tr> <tr> <td width="40%"><a id="MB_OKCANCEL"></a><a
///                   id="mb_okcancel"></a><dl> <dt><b>MB_OKCANCEL</b></dt> </dl> </td> <td width="60%"> The message box contains the
///                   <b>OK</b> and <b>Cancel</b> buttons. </td> </tr> <tr> <td width="40%"><a id="MB_RETRYCANCEL"></a><a
///                   id="mb_retrycancel"></a><dl> <dt><b>MB_RETRYCANCEL</b></dt> </dl> </td> <td width="60%"> The message box contains
///                   the <b>Retry</b> and <b>Cancel</b> buttons. </td> </tr> <tr> <td width="40%"><a id="MB_YESNO"></a><a
///                   id="mb_yesno"></a><dl> <dt><b>MB_YESNO</b></dt> </dl> </td> <td width="60%"> The message box contains the
///                   <b>Yes</b> and <b>No</b> buttons. </td> </tr> <tr> <td width="40%"><a id="MB_YESNOCANCEL"></a><a
///                   id="mb_yesnocancel"></a><dl> <dt><b>MB_YESNOCANCEL</b></dt> </dl> </td> <td width="60%"> The message box contains
///                   the <b>Yes</b>, <b>No</b>, and <b>Cancel</b> buttons. </td> </tr> </table> <table> <tr> <th>Message box
///                   IconTypesFlag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MB_ICONEXCLAMATION__MB_ICONWARNING"></a><a
///                   id="mb_iconexclamation__mb_iconwarning"></a><dl> <dt><b>MB_ICONEXCLAMATION, MB_ICONWARNING</b></dt> </dl> </td>
///                   <td width="60%"> An exclamation point appears in the message box. </td> </tr> <tr> <td width="40%"><a
///                   id="MB_ICONINFORMATION__MB_ICONASTERISK"></a><a id="mb_iconinformation__mb_iconasterisk"></a><dl>
///                   <dt><b>MB_ICONINFORMATION, MB_ICONASTERISK</b></dt> </dl> </td> <td width="60%"> The information sign appears in
///                   the message box. </td> </tr> <tr> <td width="40%"><a id="MB_ICONQUESTION"></a><a id="mb_iconquestion"></a><dl>
///                   <dt><b>MB_ICONQUESTION</b></dt> </dl> </td> <td width="60%"> A question mark appears in the message box. </td>
///                   </tr> <tr> <td width="40%"><a id="MB_ICONSTOP__MB_ICONERROR__MB_ICONHAND"></a><a
///                   id="mb_iconstop__mb_iconerror__mb_iconhand"></a><dl> <dt><b>MB_ICONSTOP, MB_ICONERROR, MB_ICONHAND</b></dt> </dl>
///                   </td> <td width="60%"> A stop sign appears in the message box. </td> </tr> </table> <table> <tr> <th>Default
///                   ButtonsFlag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MB_DEFBUTTON1"></a><a
///                   id="mb_defbutton1"></a><dl> <dt><b>MB_DEFBUTTON1</b></dt> </dl> </td> <td width="60%"> The first button is the
///                   default button. </td> </tr> <tr> <td width="40%"><a id="MB_DEFBUTTON2"></a><a id="mb_defbutton2"></a><dl>
///                   <dt><b>MB_DEFBUTTON2</b></dt> </dl> </td> <td width="60%"> The second button is the default button. </td> </tr>
///                   <tr> <td width="40%"><a id="MB_DEFBUTTON3"></a><a id="mb_defbutton3"></a><dl> <dt><b>MB_DEFBUTTON3</b></dt> </dl>
///                   </td> <td width="60%"> The third button is the default button. </td> </tr> </table> <table> <tr> <th>Install
///                   message TypesFlag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_FATALEXIT"></a><a
///                   id="installmessage_fatalexit"></a><dl> <dt><b>INSTALLMESSAGE_FATALEXIT</b></dt> </dl> </td> <td width="60%">
///                   Premature termination </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_ERROR"></a><a
///                   id="installmessage_error"></a><dl> <dt><b>INSTALLMESSAGE_ERROR</b></dt> </dl> </td> <td width="60%"> Formatted
///                   error message </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_WARNING"></a><a
///                   id="installmessage_warning"></a><dl> <dt><b>INSTALLMESSAGE_WARNING</b></dt> </dl> </td> <td width="60%">
///                   Formatted warning message </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_USER"></a><a
///                   id="installmessage_user"></a><dl> <dt><b>INSTALLMESSAGE_USER</b></dt> </dl> </td> <td width="60%"> User request
///                   message. </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_INFO"></a><a id="installmessage_info"></a><dl>
///                   <dt><b>INSTALLMESSAGE_INFO</b></dt> </dl> </td> <td width="60%"> Informative message for log </td> </tr> <tr> <td
///                   width="40%"><a id="INSTALLMESSAGE_FILESINUSE"></a><a id="installmessage_filesinuse"></a><dl>
///                   <dt><b>INSTALLMESSAGE_FILESINUSE</b></dt> </dl> </td> <td width="60%"> List of files currently in use that must
///                   be closed before being replaced </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_RESOLVESOURCE"></a><a
///                   id="installmessage_resolvesource"></a><dl> <dt><b>INSTALLMESSAGE_RESOLVESOURCE</b></dt> </dl> </td> <td
///                   width="60%"> Request to determine a valid source location </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_RMFILESINUSE"></a><a id="installmessage_rmfilesinuse"></a><dl>
///                   <dt><b>INSTALLMESSAGE_RMFILESINUSE</b></dt> </dl> </td> <td width="60%"> List of files currently in use that must
///                   be closed before being replaced. Available beginning with Windows Installer version 4.0. For more information
///                   about this message see Using Restart Manager with an External UI. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_OUTOFDISKSPACE"></a><a id="installmessage_outofdiskspace"></a><dl>
///                   <dt><b>INSTALLMESSAGE_OUTOFDISKSPACE</b></dt> </dl> </td> <td width="60%"> Insufficient disk space message </td>
///                   </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_ACTIONSTART"></a><a id="installmessage_actionstart"></a><dl>
///                   <dt><b>INSTALLMESSAGE_ACTIONSTART</b></dt> </dl> </td> <td width="60%"> Start of action message. This message
///                   includes the action name and description. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_ACTIONDATA"></a><a id="installmessage_actiondata"></a><dl>
///                   <dt><b>INSTALLMESSAGE_ACTIONDATA</b></dt> </dl> </td> <td width="60%"> Formatted data associated with the
///                   individual action item. </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_PROGRESS"></a><a
///                   id="installmessage_progress"></a><dl> <dt><b>INSTALLMESSAGE_PROGRESS</b></dt> </dl> </td> <td width="60%">
///                   Progress gauge information. This message includes information on units so far and total number of units. </td>
///                   </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_COMMONDATA"></a><a id="installmessage_commondata"></a><dl>
///                   <dt><b>INSTALLMESSAGE_COMMONDATA</b></dt> </dl> </td> <td width="60%"> Formatted dialog information for user
///                   interface. </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_INITIALIZE"></a><a
///                   id="installmessage_initialize"></a><dl> <dt><b>INSTALLMESSAGE_INITIALIZE</b></dt> </dl> </td> <td width="60%">
///                   Sent prior to UI initialization, no string data </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_TERMINATE"></a><a id="installmessage_terminate"></a><dl>
///                   <dt><b>INSTALLMESSAGE_TERMINATE</b></dt> </dl> </td> <td width="60%"> Sent after UI termination, no string data
///                   </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_SHOWDIALOG"></a><a id="installmessage_showdialog"></a><dl>
///                   <dt><b>INSTALLMESSAGE_SHOWDIALOG</b></dt> </dl> </td> <td width="60%"> Sent prior to display of authored dialog
///                   or wizard </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_INSTALLSTART"></a><a
///                   id="installmessage_installstart"></a><dl> <dt><b>INSTALLMESSAGE_INSTALLSTART</b></dt> </dl> </td> <td
///                   width="60%"> Sent prior to installation of product. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_INSTALLEND"></a><a id="installmessage_installend"></a><dl>
///                   <dt><b>INSTALLMESSAGE_INSTALLEND</b></dt> </dl> </td> <td width="60%"> Sent after installation of product. </td>
///                   </tr> </table> <div> </div> The following defaults should be used if any of the preceding messages are missing:
///                   MB_OK, no icon, and MB_DEFBUTTON1. There is no default installation message type; a message type is always
///                   specified.
///    hRecord = Specifies a handle to the record object. For information about record objects, see the <a
///              href="/windows/win32/msi/database-functions
///Returns:
///    The following return values map to the buttons specified by the message box style: IDOK<div> </div>IDCANCEL<div>
///    </div>IDABORT<div> </div>IDRETRY<div> </div>IDIGNORE<div> </div>IDYES<div> </div>IDNO
///    
alias INSTALLUI_HANDLER_RECORD = int function(void* pvContext, uint iMessageType, uint hRecord);
alias PINSTALLUI_HANDLER_RECORD = int function();
///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <i>FileCallback</i> callback function is used by a few setup functions. The
///<b>PSP_FILE_CALLBACK</b> type defines a pointer to this callback function. <i>FileCallback</i> is a placeholder for
///the application-defined function name. For more information, see Notifications, Creating a Custom Queue Callback
///Routine, and Creating a Cabinet Callback Routine.
///Params:
///    Context = The context information about the queue notification that is returned to the callback function.
///    Notification = The event that triggers the call to the callback function.
///    Param1 = The additional notification information. The value is dependent on the notification that is being returned.
///    Param2 = The additional notification information. The value is dependent on the notification that is being returned.
alias PSP_FILE_CALLBACK_A = uint function(void* Context, uint Notification, size_t Param1, size_t Param2);
///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <i>FileCallback</i> callback function is used by a few setup functions. The
///<b>PSP_FILE_CALLBACK</b> type defines a pointer to this callback function. <i>FileCallback</i> is a placeholder for
///the application-defined function name. For more information, see Notifications, Creating a Custom Queue Callback
///Routine, and Creating a Cabinet Callback Routine.
///Params:
///    Context = The context information about the queue notification that is returned to the callback function.
///    Notification = The event that triggers the call to the callback function.
///    Param1 = The additional notification information. The value is dependent on the notification that is being returned.
///    Param2 = The additional notification information. The value is dependent on the notification that is being returned.
alias PSP_FILE_CALLBACK_W = uint function(void* Context, uint Notification, size_t Param1, size_t Param2);

// Structs


///The <b>ACTIVATION_CONTEXT_QUERY_INDEX</b> structure is used by QueryActCtxW function.
struct ACTIVATION_CONTEXT_QUERY_INDEX
{
    ///One-based index of the assembly whose file table is to be queried.
    uint ulAssemblyIndex;
    ///Zero-based index of the file in the above assembly to be queried.
    uint ulFileIndexInAssembly;
}

///The <b>ASSEMBLY_FILE_DETAILED_INFORMATION</b> structure is used by the QueryActCtxW function.
struct ASSEMBLY_FILE_DETAILED_INFORMATION
{
    ///This value is always 0.
    uint          ulFlags;
    ///Length in bytes of the file name pointed to by <b>lpFileName</b>. The count does not include the terminating null
    ///character.
    uint          ulFilenameLength;
    ///Length in bytes of the path string pointed to by <b>lpFilePath</b> The count does not include the terminating
    ///null character.
    uint          ulPathLength;
    ///Null-terminated string that specifies the name of the file.
    const(wchar)* lpFileName;
    ///Null-terminated string that specifies the path to the file named in <b>lpFileName</b>.
    const(wchar)* lpFilePath;
}

///The <b>ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION</b> structure is used by the QueryActCtxW function.
struct ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
{
    ///This value is always 0.
    uint          ulFlags;
    ///Length of the encoded assembly identity in bytes.
    uint          ulEncodedAssemblyIdentityLength;
    ///This value always a constant.
    uint          ulManifestPathType;
    ///Length of the assembly manifest path in bytes.
    uint          ulManifestPathLength;
    ///The last time the manifest was written. This is in the form of a <b>FILETIME</b> data structure.
    LARGE_INTEGER liManifestLastWriteTime;
    ///This value always a constant.
    uint          ulPolicyPathType;
    ///Length of the publisher policy path in bytes.
    uint          ulPolicyPathLength;
    ///The last time the policy was written. This is in the form of a <b>FILETIME</b> data structure.
    LARGE_INTEGER liPolicyLastWriteTime;
    ///Metadata satellite roster index.
    uint          ulMetadataSatelliteRosterIndex;
    ///Major version of the assembly queried by QueryActCtxW. For more information, see Assembly Versions.
    uint          ulManifestVersionMajor;
    ///Minor version of the assembly queried by QueryActCtxW. For more information, see Assembly Versions.
    uint          ulManifestVersionMinor;
    ///Major version of any policy, if one exists.
    uint          ulPolicyVersionMajor;
    ///Minor version of any policy, if one exists.
    uint          ulPolicyVersionMinor;
    ///Length of the assembly directory name in bytes.
    uint          ulAssemblyDirectoryNameLength;
    ///Pointer to a null-terminated string that contains a textually-encoded format of the assembly's identity.
    const(wchar)* lpAssemblyEncodedAssemblyIdentity;
    ///Pointer to a null-terminated string that indicates the original path to this assembly's manifest.
    const(wchar)* lpAssemblyManifestPath;
    ///Pointer to a null-terminated string that indicates the path of whatever policy assembly was used to determine
    ///that this version of the assembly should be loaded. If this member is null, no policy was used to decide to load
    ///this version.
    const(wchar)* lpAssemblyPolicyPath;
    ///Pointer to a null-terminated string that indicates the folder from which this assembly was loaded.
    const(wchar)* lpAssemblyDirectoryName;
    uint          ulFileCount;
}

///The <b>ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION</b> structure is used by the QueryActCtxW function.
struct ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION
{
    ///This parameter is reserved for future use. This parameter currently returns 0.
    uint ulFlags;
    ///A ACTCTX_REQUESTED_RUN_LEVEL enumeration value that gives the requested run level of the activation context.
    ACTCTX_REQUESTED_RUN_LEVEL RunLevel;
    uint UiAccess;
}

///The <b>COMPATIBILITY_CONTEXT_ELEMENT</b> structure is used by the QueryActCtxW function as part of the
///ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION structure.
struct COMPATIBILITY_CONTEXT_ELEMENT
{
    ///This is a <b>GUID</b> that specifies a version of Windows. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"> <dl> <dt>{e2011457-1546-43c5-a5fe-008deee3d3f0}</dt> </dl> </td> <td width="60%"> Windows
    ///Vista </td> </tr> <tr> <td width="40%"> <dl> <dt>{35138b9a-5d96-4fbd-8e2d-a2440225f93a}</dt> </dl> </td> <td
    ///width="60%"> Windows 7 </td> </tr> </table>
    GUID  Id;
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
    ulong MaxVersionTested;
}

///The <b>ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION</b> structure is used by the QueryActCtxW function.
struct ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION
{
    ///The number of compatibility elements defined in the application manifest.
    uint ElementCount;
    ///This is an array of COMPATIBILITY_CONTEXT_ELEMENT structures. Each structure describes one compatibility element
    ///in the application manifest.
    COMPATIBILITY_CONTEXT_ELEMENT Elements;
}

///The <b>ACTIVATION_CONTEXT_DETAILED_INFORMATION</b> structure is used by the QueryActCtxW function.
struct ACTIVATION_CONTEXT_DETAILED_INFORMATION
{
    ///This value is always 0.
    uint          dwFlags;
    ///This value specifies the format of the returned information. On Windows XP and Windows Server 2003 this
    ///member is always 1.
    uint          ulFormatVersion;
    ///Number of assemblies in the activation context.
    uint          ulAssemblyCount;
    ///Specifies the kind of path from which this assembly's manifest was loaded. This member is always one of the
    ///following constants:
    uint          ulRootManifestPathType;
    ///Number of characters in the manifest path.
    uint          ulRootManifestPathChars;
    ///Specifies the kind of path from which this assembly's application configuration manifest was loaded. This member
    ///is always one of the following constants:
    uint          ulRootConfigurationPathType;
    ///Number of characters in any application configuration file path.
    uint          ulRootConfigurationPathChars;
    ///Specifies the kind of path from which this application manifest was loaded. This member is always one of the
    ///following constants:
    uint          ulAppDirPathType;
    ///Number of characters in the application directory.
    uint          ulAppDirPathChars;
    ///Path of the application manifest.
    const(wchar)* lpRootManifestPath;
    ///Path of the configuration file.
    const(wchar)* lpRootConfigurationPath;
    ///Path of the application directory.
    const(wchar)* lpAppDirPath;
}

struct PMSIHANDLE
{
    uint m_h;
}

///The <b>MSIPATCHSEQUENCEINFO</b> structure is used by the MsiDeterminePatchSequence and MsiDetermineApplicablePatches
///functions.
struct MSIPATCHSEQUENCEINFOA
{
    ///Pointer to the path of a patch file, an XML blob, or an XML file.
    const(char)*     szPatchData;
    ///Qualifies <b>szPatchData</b> as a patch file, an XML blob, or an XML file. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIPATCH_DATATYPE_PATCHFILE"></a><a
    ///id="msipatch_datatype_patchfile"></a><dl> <dt><b>MSIPATCH_DATATYPE_PATCHFILE</b></dt> <dt>0</dt> </dl> </td> <td
    ///width="60%"> The <b>szPatchData</b> member refers to a path of a patch file. </td> </tr> <tr> <td width="40%"><a
    ///id="MSIPATCH_DATATYPE_XMLPATH"></a><a id="msipatch_datatype_xmlpath"></a><dl>
    ///<dt><b>MSIPATCH_DATATYPE_XMLPATH</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The <b>szPatchData</b> member
    ///refers to a path of a XML file. </td> </tr> <tr> <td width="40%"><a id="MSIPATCH_DATATYPE_XMLBLOB"></a><a
    ///id="msipatch_datatype_xmlblob"></a><dl> <dt><b>MSIPATCH_DATATYPE_XMLBLOB</b></dt> <dt>2</dt> </dl> </td> <td
    ///width="60%"> The <b>szPatchData</b> member refers to an XML blob. </td> </tr> </table>
    MSIPATCHDATATYPE ePatchDataType;
    ///Set to an integer that indicates the sequence of the patch in the order of application. The sequence starts with
    ///0. If a patch is not applicable to the specified .msi file, or if the function fails, <b>dwOrder</b> is set to
    ///-1.
    uint             dwOrder;
    ///Set to ERROR_SUCCESS or the corresponding Win32 error code.
    uint             uStatus;
}

///The <b>MSIPATCHSEQUENCEINFO</b> structure is used by the MsiDeterminePatchSequence and MsiDetermineApplicablePatches
///functions.
struct MSIPATCHSEQUENCEINFOW
{
    ///Pointer to the path of a patch file, an XML blob, or an XML file.
    const(wchar)*    szPatchData;
    ///Qualifies <b>szPatchData</b> as a patch file, an XML blob, or an XML file. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIPATCH_DATATYPE_PATCHFILE"></a><a
    ///id="msipatch_datatype_patchfile"></a><dl> <dt><b>MSIPATCH_DATATYPE_PATCHFILE</b></dt> <dt>0</dt> </dl> </td> <td
    ///width="60%"> The <b>szPatchData</b> member refers to a path of a patch file. </td> </tr> <tr> <td width="40%"><a
    ///id="MSIPATCH_DATATYPE_XMLPATH"></a><a id="msipatch_datatype_xmlpath"></a><dl>
    ///<dt><b>MSIPATCH_DATATYPE_XMLPATH</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The <b>szPatchData</b> member
    ///refers to a path of a XML file. </td> </tr> <tr> <td width="40%"><a id="MSIPATCH_DATATYPE_XMLBLOB"></a><a
    ///id="msipatch_datatype_xmlblob"></a><dl> <dt><b>MSIPATCH_DATATYPE_XMLBLOB</b></dt> <dt>2</dt> </dl> </td> <td
    ///width="60%"> The <b>szPatchData</b> member refers to an XML blob. </td> </tr> </table>
    MSIPATCHDATATYPE ePatchDataType;
    ///Set to an integer that indicates the sequence of the patch in the order of application. The sequence starts with
    ///0. If a patch is not applicable to the specified .msi file, or if the function fails, <b>dwOrder</b> is set to
    ///-1.
    uint             dwOrder;
    ///Set to ERROR_SUCCESS or the corresponding Win32 error code.
    uint             uStatus;
}

///The <b>MSIFILEHASHINFO</b> structure contains the file hash information returned by MsiGetFileHash and used in the
///MsiFileHash table.
struct MSIFILEHASHINFO
{
    ///Specifies the size, in bytes, of this data structure. Set this member to <code>sizeof(MSIFILEHASHINFO)</code>
    ///before calling the MsiGetFileHash function.
    uint    dwFileHashInfoSize;
    ///The entire 128-bit file hash is contained in four 32-bit fields. The first field corresponds to the HashPart1
    ///column of the MsiHashFile table, the second field corresponds to the HashPart2 column, the third field
    ///corresponds to the HashPart3 column, and the fourth field corresponds to the HashPart4 column.
    uint[4] dwData;
}

///The <b>ASSEMBLY_INFO</b> structure contains information about an assembly in the side-by-side assembly store. The
///information is used by the QueryAssemblyInfo method.
struct ASSEMBLY_INFO
{
    ///The size of the structure in bytes.
    uint           cbAssemblyInfo;
    ///This member can contain the following values: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="ASSEMBLYINFO_FLAG_INSTALLED"></a><a id="assemblyinfo_flag_installed"></a><dl>
    ///<dt><b>ASSEMBLYINFO_FLAG_INSTALLED</b></dt> </dl> </td> <td width="60%"> Set this flag when using Windows Vista
    ///and later or Windows Server 2008 and later with the assembly installed in the side-by-side assembly store. </td>
    ///</tr> </table>
    uint           dwAssemblyFlags;
    ///The size of the files that comprise the assembly in kilobytes (KB).
    ULARGE_INTEGER uliAssemblySizeInKB;
    ///A pointer to a null-terminated string that contains the path to the manifest file.
    const(wchar)*  pszCurrentAssemblyPathBuf;
    uint           cchBuf;
}

///The <b>FUSION_INSTALL_REFERENCE</b> structure contains information about the application which references the
///side-by-side assembly. The assembly being referenced can be added to or removed from the side-by-side assembly store
///using the InstallAssembly and UninstallAssembly methods.
struct FUSION_INSTALL_REFERENCE
{
    ///The size of the structure in bytes.
    uint          cbSize;
    ///Reserved, this member must be zero.
    uint          dwFlags;
    ///The application that uses the side-by-side assembly. This parameter can have one of the following values: <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FUSION_REFCOUNT_MSI_GUID"></a><a
    ///id="fusion_refcount_msi_guid"></a><dl> <dt><b>FUSION_REFCOUNT_MSI_GUID</b></dt> </dl> </td> <td width="60%"> The
    ///assembly is referenced by an application that has been installed by using the Windows Installer. The
    ///<b>szIdentifier</b> member is set to MSI, and <b>szNonCannonicalData</b> is set to Windows Installer. Use this
    ///value for Windows side-by-side assemblies. </td> </tr> <tr> <td width="40%"><a
    ///id="FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID"></a><a id="fusion_refcount_uninstall_subkey_guid"></a><dl>
    ///<dt><b>FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID</b></dt> </dl> </td> <td width="60%"> The assembly is referenced by
    ///an application that appears in Add/Remove Programs. The <b>szIdentifier</b> member is the token used to register
    ///the application with Add/Remove programs. </td> </tr> <tr> <td width="40%"><a
    ///id="FUSION_REFCOUNT_FILEPATH_GUID"></a><a id="fusion_refcount_filepath_guid"></a><dl>
    ///<dt><b>FUSION_REFCOUNT_FILEPATH_GUID</b></dt> </dl> </td> <td width="60%"> The assembly is referenced by an
    ///application that is represented by a file in the file system. The <b>szIdentifier</b> parameter is the path to
    ///this file. </td> </tr> <tr> <td width="40%"><a id="FUSION_REFCOUNT_OPAQUE_STRING_GUID"></a><a
    ///id="fusion_refcount_opaque_string_guid"></a><dl> <dt><b>FUSION_REFCOUNT_OPAQUE_STRING_GUID</b></dt> </dl> </td>
    ///<td width="60%"> The assembly is referenced by an application that is only represented by an opaque string. The
    ///<b>szIdentifier</b> member is this opaque string. This value is required for the side-by-side store to check for
    ///the existence of opaque references. </td> </tr> <tr> <td width="40%"><a
    ///id="FUSION_REFCOUNT_OSINSTALL_GUID"></a><a id="fusion_refcount_osinstall_guid"></a><dl>
    ///<dt><b>FUSION_REFCOUNT_OSINSTALL_GUID</b></dt> </dl> </td> <td width="60%"> Reserved </td> </tr> </table>
    GUID          guidScheme;
    ///A pointer to a string value that identifies the application that references assembly. The meaning of this
    ///identifier depends on the <b>guidScheme</b> parameter.
    const(wchar)* szIdentifier;
    const(wchar)* szNonCannonicalData;
}

struct PROTECTED_FILE_DATA
{
    ushort[260] FileName;
    uint        FileNumber;
}

///The <b>ACTCTX</b> structure is used by the CreateActCtx function to create the activation context.
struct ACTCTXA
{
    ///The size, in bytes, of this structure. This is used to determine the version of this structure.
    uint         cbSize;
    ///Flags that indicate how the values included in this structure are to be used. Set any undefined bits in
    ///<b>dwFlags</b> to 0. If any undefined bits are not set to 0, the call to CreateActCtx that creates the activation
    ///context fails and returns an invalid parameter error code. <table> <tr> <th>Bit flag</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID"></a><a
    ///id="actctx_flag_processor_architecture_valid"></a><dl> <dt><b>ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID</b></dt>
    ///<dt>1</dt> </dl> </td> <td width="60%"> 0x001 </td> </tr> <tr> <td width="40%"><a
    ///id="ACTCTX_FLAG_LANGID_VALID"></a><a id="actctx_flag_langid_valid"></a><dl>
    ///<dt><b>ACTCTX_FLAG_LANGID_VALID</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> 0x002 </td> </tr> <tr> <td
    ///width="40%"><a id="ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID"></a><a
    ///id="actctx_flag_assembly_directory_valid"></a><dl> <dt><b>ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID</b></dt>
    ///<dt>4</dt> </dl> </td> <td width="60%"> 0x004 </td> </tr> <tr> <td width="40%"><a
    ///id="ACTCTX_FLAG_RESOURCE_NAME_VALID"></a><a id="actctx_flag_resource_name_valid"></a><dl>
    ///<dt><b>ACTCTX_FLAG_RESOURCE_NAME_VALID</b></dt> <dt>8</dt> </dl> </td> <td width="60%"> 0x008 </td> </tr> <tr>
    ///<td width="40%"><a id="ACTCTX_FLAG_SET_PROCESS_DEFAULT"></a><a id="actctx_flag_set_process_default"></a><dl>
    ///<dt><b>ACTCTX_FLAG_SET_PROCESS_DEFAULT</b></dt> <dt>16</dt> </dl> </td> <td width="60%"> 0x010 </td> </tr> <tr>
    ///<td width="40%"><a id="ACTCTX_FLAG_APPLICATION_NAME_VALID"></a><a
    ///id="actctx_flag_application_name_valid"></a><dl> <dt><b>ACTCTX_FLAG_APPLICATION_NAME_VALID</b></dt> <dt>32</dt>
    ///</dl> </td> <td width="60%"> 0x020 </td> </tr> <tr> <td width="40%"><a id="ACTCTX_FLAG_HMODULE_VALID"></a><a
    ///id="actctx_flag_hmodule_valid"></a><dl> <dt><b>ACTCTX_FLAG_HMODULE_VALID</b></dt> <dt>128</dt> </dl> </td> <td
    ///width="60%"> 0x080 </td> </tr> </table>
    uint         dwFlags;
    ///Null-terminated string specifying the path of the manifest file or PE image to be used to create the activation
    ///context. If this path refers to an EXE or DLL file, the <b>lpResourceName</b> member is required.
    const(char)* lpSource;
    ///Identifies the type of processor used. Specifies the system's processor architecture. This value can be one of
    ///the following values:
    ushort       wProcessorArchitecture;
    ///Specifies the language manifest that should be used. The default is the current user's current UI language. If
    ///the requested language cannot be found, an approximation is searched for using the following order: <ul> <li>The
    ///current user's specific language. For example, for US English (1033).</li> <li>The current user's primary
    ///language. For example, for English (9).</li> <li>The current system's specific language.</li> <li>The current
    ///system's primary language.</li> <li>A nonspecific worldwide language. Language neutral (0).</li> </ul>
    ushort       wLangId;
    ///The base directory in which to perform private assembly probing if assemblies in the activation context are not
    ///present in the system-wide store.
    const(char)* lpAssemblyDirectory;
    ///Pointer to a null-terminated string that contains the resource name to be loaded from the PE specified in
    ///<b>hModule</b> or <b>lpSource</b>. If the resource name is an integer, set this member using MAKEINTRESOURCE.
    ///This member is required if <b>lpSource</b> refers to an EXE or DLL.
    const(char)* lpResourceName;
    ///The name of the current application. If the value of this member is set to null, the name of the executable that
    ///launched the current process is used.
    const(char)* lpApplicationName;
    ///Use this member rather than <b>lpSource</b> if you have already loaded a DLL and wish to use it to create
    ///activation contexts rather than using a path in <b>lpSource</b>. See <b>lpResourceName</b> for the rules of
    ///looking up resources in this module.
    ptrdiff_t    hModule;
}

///The <b>ACTCTX</b> structure is used by the CreateActCtx function to create the activation context.
struct ACTCTXW
{
    ///The size, in bytes, of this structure. This is used to determine the version of this structure.
    uint          cbSize;
    ///Flags that indicate how the values included in this structure are to be used. Set any undefined bits in
    ///<b>dwFlags</b> to 0. If any undefined bits are not set to 0, the call to CreateActCtx that creates the activation
    ///context fails and returns an invalid parameter error code. <table> <tr> <th>Bit flag</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID"></a><a
    ///id="actctx_flag_processor_architecture_valid"></a><dl> <dt><b>ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID</b></dt>
    ///<dt>1</dt> </dl> </td> <td width="60%"> 0x001 </td> </tr> <tr> <td width="40%"><a
    ///id="ACTCTX_FLAG_LANGID_VALID"></a><a id="actctx_flag_langid_valid"></a><dl>
    ///<dt><b>ACTCTX_FLAG_LANGID_VALID</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> 0x002 </td> </tr> <tr> <td
    ///width="40%"><a id="ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID"></a><a
    ///id="actctx_flag_assembly_directory_valid"></a><dl> <dt><b>ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID</b></dt>
    ///<dt>4</dt> </dl> </td> <td width="60%"> 0x004 </td> </tr> <tr> <td width="40%"><a
    ///id="ACTCTX_FLAG_RESOURCE_NAME_VALID"></a><a id="actctx_flag_resource_name_valid"></a><dl>
    ///<dt><b>ACTCTX_FLAG_RESOURCE_NAME_VALID</b></dt> <dt>8</dt> </dl> </td> <td width="60%"> 0x008 </td> </tr> <tr>
    ///<td width="40%"><a id="ACTCTX_FLAG_SET_PROCESS_DEFAULT"></a><a id="actctx_flag_set_process_default"></a><dl>
    ///<dt><b>ACTCTX_FLAG_SET_PROCESS_DEFAULT</b></dt> <dt>16</dt> </dl> </td> <td width="60%"> 0x010 </td> </tr> <tr>
    ///<td width="40%"><a id="ACTCTX_FLAG_APPLICATION_NAME_VALID"></a><a
    ///id="actctx_flag_application_name_valid"></a><dl> <dt><b>ACTCTX_FLAG_APPLICATION_NAME_VALID</b></dt> <dt>32</dt>
    ///</dl> </td> <td width="60%"> 0x020 </td> </tr> <tr> <td width="40%"><a id="ACTCTX_FLAG_HMODULE_VALID"></a><a
    ///id="actctx_flag_hmodule_valid"></a><dl> <dt><b>ACTCTX_FLAG_HMODULE_VALID</b></dt> <dt>128</dt> </dl> </td> <td
    ///width="60%"> 0x080 </td> </tr> </table>
    uint          dwFlags;
    ///Null-terminated string specifying the path of the manifest file or PE image to be used to create the activation
    ///context. If this path refers to an EXE or DLL file, the <b>lpResourceName</b> member is required.
    const(wchar)* lpSource;
    ///Identifies the type of processor used. Specifies the system's processor architecture. This value can be one of
    ///the following values:
    ushort        wProcessorArchitecture;
    ///Specifies the language manifest that should be used. The default is the current user's current UI language. If
    ///the requested language cannot be found, an approximation is searched for using the following order: <ul> <li>The
    ///current user's specific language. For example, for US English (1033).</li> <li>The current user's primary
    ///language. For example, for English (9).</li> <li>The current system's specific language.</li> <li>The current
    ///system's primary language.</li> <li>A nonspecific worldwide language. Language neutral (0).</li> </ul>
    ushort        wLangId;
    ///The base directory in which to perform private assembly probing if assemblies in the activation context are not
    ///present in the system-wide store.
    const(wchar)* lpAssemblyDirectory;
    ///Pointer to a null-terminated string that contains the resource name to be loaded from the PE specified in
    ///<b>hModule</b> or <b>lpSource</b>. If the resource name is an integer, set this member using MAKEINTRESOURCE.
    ///This member is required if <b>lpSource</b> refers to an EXE or DLL.
    const(wchar)* lpResourceName;
    ///The name of the current application. If the value of this member is set to null, the name of the executable that
    ///launched the current process is used.
    const(wchar)* lpApplicationName;
    ///Use this member rather than <b>lpSource</b> if you have already loaded a DLL and wish to use it to create
    ///activation contexts rather than using a path in <b>lpSource</b>. See <b>lpResourceName</b> for the rules of
    ///looking up resources in this module.
    ptrdiff_t     hModule;
}

///The <b>ACTCTX_SECTION_KEYED_DATA</b> structure is used by the FindActCtxSectionString and FindActCtxSectionGuid
///functions to return the activation context information along with either the GUID or 32-bit integer-tagged activation
///context section.
struct ACTCTX_SECTION_KEYED_DATA
{
    ///The size, in bytes, of the activation context keyed data structure.
    uint   cbSize;
    ///Number that indicates the format of the data in the section where the key was found. Clients should verify that
    ///the data format version is as expected rather than trying to interpret the values of unfamiliar data formats.
    ///This number is only changed when major non-backward-compatible changes to the section data formats need to be
    ///made. The current format version is 1.
    uint   ulDataFormatVersion;
    ///Pointer to the redirection data found associated with the section identifier and key.
    void*  lpData;
    ///Number of bytes in the structure referred to by <b>lpData</b>. Note that the data structures grow over time; do
    ///not access members in the instance data that extend beyond <b>ulLength</b>.
    uint   ulLength;
    ///Returned pointer to a section-specific data structure which is global to the activation context section where the
    ///key was found. Its interpretation depends on the section identifier requested.
    void*  lpSectionGlobalData;
    ///Number of bytes in the section global data block referred to by <b>lpSectionGlobalData</b>. Note that the data
    ///structures grow over time and you may receive an old format activation context data block; do not access members
    ///in the section global data that extend beyond <b>ulSectionGlobalDataLength</b>.
    uint   ulSectionGlobalDataLength;
    ///Pointer to the base of the section where the key was found. Some instance data contains offsets relative to the
    ///section base address, in which case this pointer value is used.
    void*  lpSectionBase;
    ///Number of bytes for the entire section starting at <b>lpSectionBase</b>. May be used to verify that offset/length
    ///pairs, which are specified as relative to the section base are wholly contained in the section.
    uint   ulSectionTotalLength;
    ///Handle to the activation context where the key was found. First, the active activation context for the thread is
    ///searched, followed by the process-default activation context and then the system-compatible-default-activation
    ///context. This member indicates which activation context contained the section and key requested. This is only
    ///returned if the FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX flag is passed. Note that when this is returned, the
    ///caller must call ReleaseActCtx() on the activation context handle returned to release system resources when all
    ///other references to the activation context have been released.
    HANDLE hActCtx;
    ///Cardinal number of the assembly in the activation context that provided the redirection information found. This
    ///value can be presented to QueryActCtxW for more information about the contributing assembly.
    uint   ulAssemblyRosterIndex;
    uint   ulFlags;
    ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
}

///The <b>INFCONTEXT</b> structure stores context information that functions such as SetupGetLineText use to navigate
///INF files.
struct INFCONTEXT
{
align (1):
    ///Handle to the INF file returned by SetupOpenInfFile.
    void* Inf;
    ///Pointer to the current INF file. The <b>Inf</b> member may point to multiple files if they were appended to the
    ///open INF file using SetupOpenAppendInfFile.
    void* CurrentInf;
    ///Section in the current INF file.
    uint  Section;
    ///Line of the current section in the INF file. <div class="alert"><b>Note</b> The setup functions use this
    ///structure internally and it must not be accessed or modified by applications. It is included here for
    ///informational purposes only.</div> <div> </div>
    uint  Line;
}

///The <b>SP_INF_INFORMATION</b> structure stores information about an INF file, including the style, number of
///constituent INF files, and version data.
struct SP_INF_INFORMATION
{
align (1):
    ///Style of the INF file. This member can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="INF_STYLE_NONE"></a><a id="inf_style_none"></a><dl>
    ///<dt><b>INF_STYLE_NONE</b></dt> </dl> </td> <td width="60%"> Specifies that the style of the INF file is
    ///unrecognized or nonexistent. </td> </tr> <tr> <td width="40%"><a id="INF_STYLE_OLDNT"></a><a
    ///id="inf_style_oldnt"></a><dl> <dt><b>INF_STYLE_OLDNT</b></dt> </dl> </td> <td width="60%"> A legacy INF file
    ///format. </td> </tr> <tr> <td width="40%"><a id="INF_STYLE_WIN4"></a><a id="inf_style_win4"></a><dl>
    ///<dt><b>INF_STYLE_WIN4</b></dt> </dl> </td> <td width="60%"> A Windows INF file format. </td> </tr> </table>
    uint     InfStyle;
    ///Number of constituent INF files.
    uint     InfCount;
    ///Stores information from the <b>Version</b> section of an INF file in an array of <b>ANYSIZE_ARRAY</b> bytes.
    ubyte[1] VersionData;
}

///The <b>SP_ALTPLATFORM_INFO_V2</b> structure is used to pass information for an alternate platform to
///SetupQueryInfOriginalFileInformation. Setup uses the <b>SP_ALTPLATFORM_INFO_V2</b> structure if
///USE_SP_ALTPLATFORM_INFO_V1 is 0 or undefined and _WIN32_WINNT is set to 0x501. <b>FirstValidatedMajorVersion</b> and
///<b>FirstValidatedMinorVersion</b> are only available with <b>SP_ALTPLATFORM_INFO_V2</b> and for use with Windows
///Server 2008, Windows Vista, Windows Server 2003, or Windows XP. Setup uses the SP_ALTPLATFORM_INFO_V1 structure if
///USE_SP_ALTPLATFORM_INFO_V1 is set to 1 or if _WIN32_WINNT is less than or equal to 0x500.
///<b>FirstValidatedMajorVersion</b> and <b>FirstValidatedMinorVersion</b> are not available with
///<b>SP_ALTPLATFORM_INFO_V1</b>.
struct SP_ALTPLATFORM_INFO_V2
{
align (1):
    ///Size of this structure, in bytes.
    uint   cbSize;
    ///Operating system. This member must be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="VER_PLATFORM_WIN32_WINDOWS"></a><a id="ver_platform_win32_windows"></a><dl>
    ///<dt><b>VER_PLATFORM_WIN32_WINDOWS</b></dt> </dl> </td> <td width="60%"> Legacy operating systems. </td> </tr>
    ///<tr> <td width="40%"><a id="VER_PLATFORM_WIN32_NT"></a><a id="ver_platform_win32_nt"></a><dl>
    ///<dt><b>VER_PLATFORM_WIN32_NT</b></dt> </dl> </td> <td width="60%"> Windows Server 2008, Windows Vista, Windows
    ///Server 2003, Windows XP, or Windows 2000. </td> </tr> </table>
    uint   Platform;
    ///Major version of the operating system.
    uint   MajorVersion;
    ///Minor version of the operating system.
    uint   MinorVersion;
    ///Processor architecture. This must be PROCESSOR_ARCHITECTURE_INTEL, PROCESSOR_ARCHITECTURE_ALPHA,
    ///PROCESSOR_ARCHITECTURE_IA64, PROCESSOR_ARCHITECTURE_ALPHA64.
    ushort ProcessorArchitecture;
    union
    {
    align (1):
        ushort Reserved;
        ushort Flags;
    }
    ///Major version of the oldest previous operating system for which this package's digital signature is valid. For
    ///example, if the alternate platform is VER_PLATFORM_WIN32_NT, version 5.1, and you want a driver package signed
    ///with a 5.0 osattr to also be valid, set MajorVersion to 5, MinorVersion to 1, <b>FirstValidatedMajorVersion</b>
    ///to 5, and <b>FirstValidatedMinorVersion</b> 0. To validate packages signed for any previous operating system,
    ///specify 0 for these fields. To only validate against the target alternate platform, specify the same values as
    ///those in the MajorVersion and MinorVersion fields. Available with Windows XP or later only. The Flags member must
    ///be set to SP_ALTPLATFORM_FLAGS_VERSION_RANGE to use <b>FirstValidatedMajorVersion</b>.
    uint   FirstValidatedMajorVersion;
    ///Minor version of the oldest previous operating system for which this package's digital signature is valid. For
    ///information see <b>FirstValidatedMajorVersion</b>. Available with Windows Server 2003 or Windows XP. The
    ///<b>Flags</b> member must be set to SP_ALTPLATFORM_FLAGS_VERSION_RANGE to use <b>FirstValidatedMinorVersion</b>.
    uint   FirstValidatedMinorVersion;
}

///This structure is used to pass information for an alternate platform to SetupQueryInfOriginalFileInformation. Setup
///implicitly uses the <b>SP_ALTPLATFORM_INFO_V1</b> structure if USE_SP_ALTPLATFORM_INFO_V1 is set to 1 or if
///_WIN32_WINNT is less than or equal to 0x500. This version is for use with Windows 2000. Setup implicitly uses the
///SP_ALTPLATFORM_INFO_V2 structure if USE_SP_ALTPLATFORM_INFO_V1 is 0 or undefined and _WIN32_WINNT is set to 0x501.
struct SP_ALTPLATFORM_INFO_V1
{
align (1):
    ///Size of this structure, in bytes.
    uint   cbSize;
    ///Operating system. This must be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="VER_PLATFORM_WIN32_WINDOWS"></a><a id="ver_platform_win32_windows"></a><dl>
    ///<dt><b>VER_PLATFORM_WIN32_WINDOWS</b></dt> </dl> </td> <td width="60%"> Legacy operating systems. </td> </tr>
    ///<tr> <td width="40%"><a id="VER_PLATFORM_WIN32_NT"></a><a id="ver_platform_win32_nt"></a><dl>
    ///<dt><b>VER_PLATFORM_WIN32_NT</b></dt> </dl> </td> <td width="60%"> Windows Server 2008, Windows Vista, Windows
    ///Server 2003, Windows XP, or Windows 2000. </td> </tr> </table>
    uint   Platform;
    ///Major version of the operating system.
    uint   MajorVersion;
    ///Minor version of the operating system.
    uint   MinorVersion;
    ///Processor architecture. This must be PROCESSOR_ARCHITECTURE_INTEL, PROCESSOR_ARCHITECTURE_ALPHA,
    ///PROCESSOR_ARCHITECTURE_IA64, PROCESSOR_ARCHITECTURE_ALPHA64.
    ushort ProcessorArchitecture;
    ///Must be set to zero.
    ushort Reserved;
}

///The <b>SP_ORIGINAL_FILE_INFO</b> structure receives the original INF file name and catalog file information returned
///by SetupQueryInfOriginalFileInformation.
struct SP_ORIGINAL_FILE_INFO_A
{
align (1):
    ///Size of this structure, in bytes.
    uint      cbSize;
    ///Original file name of the INF file stored in array of size MAX_PATH.
    byte[260] OriginalInfName;
    ///Catalog name of the INF file stored in array of size MAX_PATH.
    byte[260] OriginalCatalogName;
}

///The <b>SP_ORIGINAL_FILE_INFO</b> structure receives the original INF file name and catalog file information returned
///by SetupQueryInfOriginalFileInformation.
struct SP_ORIGINAL_FILE_INFO_W
{
align (1):
    ///Size of this structure, in bytes.
    uint        cbSize;
    ///Original file name of the INF file stored in array of size MAX_PATH.
    ushort[260] OriginalInfName;
    ///Catalog name of the INF file stored in array of size MAX_PATH.
    ushort[260] OriginalCatalogName;
}

///The <b>FILEPATHS</b> structure stores source and target path information. The setup functions send the
///<b>FILEPATHS</b> structure as a parameter in several of the notifications sent to callback routines. For more
///information, see Notifications.
struct FILEPATHS_A
{
align (1):
    ///Path to the target file.
    const(char)* Target;
    ///Path to the source file. This member is not used when the <b>FILEPATHS</b> structure is used with a file delete
    ///operation.
    const(char)* Source;
    ///If an error occurs, this member is the system error code. If no error has occurred, it is NO_ERROR.
    uint         Win32Error;
    ///Additional information that depends on the notification sent with the <b>FILEPATHS</b> structure. For
    ///SPFILENOTIFY_COPYERROR notifications, <b>Flags</b> specifies dialog box behavior and can be one of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SP_COPY_NOBROWSE"></a><a
    ///id="sp_copy_nobrowse"></a><dl> <dt><b>SP_COPY_NOBROWSE</b></dt> </dl> </td> <td width="60%"> Do not offer the
    ///user the option to browse. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NOSKIP"></a><a
    ///id="sp_copy_noskip"></a><dl> <dt><b>SP_COPY_NOSKIP</b></dt> </dl> </td> <td width="60%"> Do not offer the user
    ///the option to skip the file. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_WARNIFSKIP"></a><a
    ///id="sp_copy_warnifskip"></a><dl> <dt><b>SP_COPY_WARNIFSKIP</b></dt> </dl> </td> <td width="60%"> Inform the user
    ///that skipping the file may affect the installation. </td> </tr> </table> For SPFILENOTIFY_FILEOPDELAYED
    ///notifications, <b>Flags</b> specifies the type of file operation delayed and can be one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILEOP_COPY"></a><a
    ///id="fileop_copy"></a><dl> <dt><b>FILEOP_COPY</b></dt> </dl> </td> <td width="60%"> A file copy operation was
    ///delayed. </td> </tr> <tr> <td width="40%"><a id="FILEOP_DELETE"></a><a id="fileop_delete"></a><dl>
    ///<dt><b>FILEOP_DELETE</b></dt> </dl> </td> <td width="60%"> A file delete operation was delayed. </td> </tr>
    ///</table>
    uint         Flags;
}

///The <b>FILEPATHS</b> structure stores source and target path information. The setup functions send the
///<b>FILEPATHS</b> structure as a parameter in several of the notifications sent to callback routines. For more
///information, see Notifications.
struct FILEPATHS_W
{
align (1):
    ///Path to the target file.
    const(wchar)* Target;
    ///Path to the source file. This member is not used when the <b>FILEPATHS</b> structure is used with a file delete
    ///operation.
    const(wchar)* Source;
    ///If an error occurs, this member is the system error code. If no error has occurred, it is NO_ERROR.
    uint          Win32Error;
    ///Additional information that depends on the notification sent with the <b>FILEPATHS</b> structure. For
    ///SPFILENOTIFY_COPYERROR notifications, <b>Flags</b> specifies dialog box behavior and can be one of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SP_COPY_NOBROWSE"></a><a
    ///id="sp_copy_nobrowse"></a><dl> <dt><b>SP_COPY_NOBROWSE</b></dt> </dl> </td> <td width="60%"> Do not offer the
    ///user the option to browse. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NOSKIP"></a><a
    ///id="sp_copy_noskip"></a><dl> <dt><b>SP_COPY_NOSKIP</b></dt> </dl> </td> <td width="60%"> Do not offer the user
    ///the option to skip the file. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_WARNIFSKIP"></a><a
    ///id="sp_copy_warnifskip"></a><dl> <dt><b>SP_COPY_WARNIFSKIP</b></dt> </dl> </td> <td width="60%"> Inform the user
    ///that skipping the file may affect the installation. </td> </tr> </table> For SPFILENOTIFY_FILEOPDELAYED
    ///notifications, <b>Flags</b> specifies the type of file operation delayed and can be one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILEOP_COPY"></a><a
    ///id="fileop_copy"></a><dl> <dt><b>FILEOP_COPY</b></dt> </dl> </td> <td width="60%"> A file copy operation was
    ///delayed. </td> </tr> <tr> <td width="40%"><a id="FILEOP_DELETE"></a><a id="fileop_delete"></a><dl>
    ///<dt><b>FILEOP_DELETE</b></dt> </dl> </td> <td width="60%"> A file delete operation was delayed. </td> </tr>
    ///</table>
    uint          Flags;
}

///The <b>FILEPATHS_SINGNERINFO</b> structure stores source and target path information, and also file signature
///information. The setup functions send <b>FILEPATHS_SIGNERINFO</b> as a parameter in several of the notifications sent
///to callback routines. For more information, see Notifications.
struct FILEPATHS_SIGNERINFO_A
{
align (1):
    ///Path to the target file.
    const(char)* Target;
    ///Path to the source file. This member is not used when the FILEPATHS structure is used with a file delete
    ///operation.
    const(char)* Source;
    ///If an error occurs, this member is the system error code. If no error has occurred, it is NO_ERROR.
    uint         Win32Error;
    ///Additional information that depends on the notification sent with the <b>FILEPATHS_SIGNERINFO</b> structure. For
    ///SPFILENOTIFY_COPYERROR notifications, <b>Flags</b> specifies dialog box behavior and can be one of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SP_COPY_NOBROWSE"></a><a
    ///id="sp_copy_nobrowse"></a><dl> <dt><b>SP_COPY_NOBROWSE</b></dt> </dl> </td> <td width="60%"> Do not offer the
    ///user the option to browse. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NOSKIP"></a><a
    ///id="sp_copy_noskip"></a><dl> <dt><b>SP_COPY_NOSKIP</b></dt> </dl> </td> <td width="60%"> Do not offer the user
    ///the option to skip the file. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_WARNIFSKIP"></a><a
    ///id="sp_copy_warnifskip"></a><dl> <dt><b>SP_COPY_WARNIFSKIP</b></dt> </dl> </td> <td width="60%"> Inform the user
    ///that skipping the file may affect the installation. </td> </tr> </table> For SPFILENOTIFY_FILEOPDELAYED
    ///notifications, <b>Flags</b> specifies the type of file operation delayed and can be one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILEOP_COPY"></a><a
    ///id="fileop_copy"></a><dl> <dt><b>FILEOP_COPY</b></dt> </dl> </td> <td width="60%"> A file copy operation was
    ///delayed. </td> </tr> <tr> <td width="40%"><a id="FILEOP_DELETE"></a><a id="fileop_delete"></a><dl>
    ///<dt><b>FILEOP_DELETE</b></dt> </dl> </td> <td width="60%"> A file delete operation was delayed. </td> </tr>
    ///</table>
    uint         Flags;
    ///Digital signer of the file.
    const(char)* DigitalSigner;
    ///Version of the file.
    const(char)* Version;
    ///Catalog file.
    const(char)* CatalogFile;
}

///The <b>FILEPATHS_SINGNERINFO</b> structure stores source and target path information, and also file signature
///information. The setup functions send <b>FILEPATHS_SIGNERINFO</b> as a parameter in several of the notifications sent
///to callback routines. For more information, see Notifications.
struct FILEPATHS_SIGNERINFO_W
{
align (1):
    ///Path to the target file.
    const(wchar)* Target;
    ///Path to the source file. This member is not used when the FILEPATHS structure is used with a file delete
    ///operation.
    const(wchar)* Source;
    ///If an error occurs, this member is the system error code. If no error has occurred, it is NO_ERROR.
    uint          Win32Error;
    ///Additional information that depends on the notification sent with the <b>FILEPATHS_SIGNERINFO</b> structure. For
    ///SPFILENOTIFY_COPYERROR notifications, <b>Flags</b> specifies dialog box behavior and can be one of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SP_COPY_NOBROWSE"></a><a
    ///id="sp_copy_nobrowse"></a><dl> <dt><b>SP_COPY_NOBROWSE</b></dt> </dl> </td> <td width="60%"> Do not offer the
    ///user the option to browse. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NOSKIP"></a><a
    ///id="sp_copy_noskip"></a><dl> <dt><b>SP_COPY_NOSKIP</b></dt> </dl> </td> <td width="60%"> Do not offer the user
    ///the option to skip the file. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_WARNIFSKIP"></a><a
    ///id="sp_copy_warnifskip"></a><dl> <dt><b>SP_COPY_WARNIFSKIP</b></dt> </dl> </td> <td width="60%"> Inform the user
    ///that skipping the file may affect the installation. </td> </tr> </table> For SPFILENOTIFY_FILEOPDELAYED
    ///notifications, <b>Flags</b> specifies the type of file operation delayed and can be one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILEOP_COPY"></a><a
    ///id="fileop_copy"></a><dl> <dt><b>FILEOP_COPY</b></dt> </dl> </td> <td width="60%"> A file copy operation was
    ///delayed. </td> </tr> <tr> <td width="40%"><a id="FILEOP_DELETE"></a><a id="fileop_delete"></a><dl>
    ///<dt><b>FILEOP_DELETE</b></dt> </dl> </td> <td width="60%"> A file delete operation was delayed. </td> </tr>
    ///</table>
    uint          Flags;
    ///Digital signer of the file.
    const(wchar)* DigitalSigner;
    ///Version of the file.
    const(wchar)* Version;
    ///Catalog file.
    const(wchar)* CatalogFile;
}

///The <b>SOURCE_MEDIA</b> structure is used with the SPFILENOTIFY_NEEDMEDIA notification to pass source media
///information.
struct SOURCE_MEDIA_A
{
align (1):
    ///This member is not currently used.
    const(char)* Reserved;
    ///Optional tag file that can be used to identify the source media.
    const(char)* Tagfile;
    ///Human-readable description of the source media.
    const(char)* Description;
    ///Path to the source that needs the new media.
    const(char)* SourcePath;
    ///Source file to be retrieved from the new media.
    const(char)* SourceFile;
    ///Copy style information that modifies how errors are handled. This member can be one or more of the following
    ///values.
    uint         Flags;
}

///The <b>SOURCE_MEDIA</b> structure is used with the SPFILENOTIFY_NEEDMEDIA notification to pass source media
///information.
struct SOURCE_MEDIA_W
{
align (1):
    ///This member is not currently used.
    const(wchar)* Reserved;
    ///Optional tag file that can be used to identify the source media.
    const(wchar)* Tagfile;
    ///Human-readable description of the source media.
    const(wchar)* Description;
    ///Path to the source that needs the new media.
    const(wchar)* SourcePath;
    ///Source file to be retrieved from the new media.
    const(wchar)* SourceFile;
    ///Copy style information that modifies how errors are handled. This member can be one or more of the following
    ///values.
    uint          Flags;
}

///The <b>CABINET_INFO</b> structure stores information about a cabinet file. The SetupIterateCabinet function specifies
///this structure as a parameter when it sends a SPFILENOTIFY_NEEDNEWCABINET notification to the cabinet callback
///routine.
struct CABINET_INFO_A
{
align (1):
    ///Path to the cabinet file.
    const(char)* CabinetPath;
    ///Name of the cabinet file.
    const(char)* CabinetFile;
    ///Name of the source media that contains the cabinet file.
    const(char)* DiskName;
    ///Identifier of the current set. This number is generated by the software that builds the cabinet.
    ushort       SetId;
    ///Number of the cabinet. This number is generated by the software that builds the cabinet and is generally a zero-
    ///or 1-based index indicating the ordinal of the position of the cabinet within a set.
    ushort       CabinetNumber;
}

///The <b>CABINET_INFO</b> structure stores information about a cabinet file. The SetupIterateCabinet function specifies
///this structure as a parameter when it sends a SPFILENOTIFY_NEEDNEWCABINET notification to the cabinet callback
///routine.
struct CABINET_INFO_W
{
align (1):
    ///Path to the cabinet file.
    const(wchar)* CabinetPath;
    ///Name of the cabinet file.
    const(wchar)* CabinetFile;
    ///Name of the source media that contains the cabinet file.
    const(wchar)* DiskName;
    ///Identifier of the current set. This number is generated by the software that builds the cabinet.
    ushort        SetId;
    ///Number of the cabinet. This number is generated by the software that builds the cabinet and is generally a zero-
    ///or 1-based index indicating the ordinal of the position of the cabinet within a set.
    ushort        CabinetNumber;
}

///The <b>FILE_IN_CABINET_INFO</b> structure provides information about a file found in the cabinet. The
///SetupIterateCabinet function sends this structure as one of the parameters when it sends a SPFILENOTIFY_FILEINCABINET
///notification to the cabinet callback routine.
struct FILE_IN_CABINET_INFO_A
{
align (1):
    ///File name as it exists within the cabinet file.
    const(char)* NameInCabinet;
    ///Uncompressed size of the file in the cabinet, in bytes.
    uint         FileSize;
    ///If an error occurs, this member is the system error code. If no error has occurred, it is NO_ERROR.
    uint         Win32Error;
    ///Date that the file was last saved.
    ushort       DosDate;
    ///MS-DOS time stamp of the file in the cabinet.
    ushort       DosTime;
    ///Attributes of the file in the cabinet.
    ushort       DosAttribs;
    ///Target path and file name.
    byte[260]    FullTargetName;
}

///The <b>FILE_IN_CABINET_INFO</b> structure provides information about a file found in the cabinet. The
///SetupIterateCabinet function sends this structure as one of the parameters when it sends a SPFILENOTIFY_FILEINCABINET
///notification to the cabinet callback routine.
struct FILE_IN_CABINET_INFO_W
{
align (1):
    ///File name as it exists within the cabinet file.
    const(wchar)* NameInCabinet;
    ///Uncompressed size of the file in the cabinet, in bytes.
    uint          FileSize;
    ///If an error occurs, this member is the system error code. If no error has occurred, it is NO_ERROR.
    uint          Win32Error;
    ///Date that the file was last saved.
    ushort        DosDate;
    ///MS-DOS time stamp of the file in the cabinet.
    ushort        DosTime;
    ///Attributes of the file in the cabinet.
    ushort        DosAttribs;
    ///Target path and file name.
    ushort[260]   FullTargetName;
}

///The <b>SP_REGISTER_CONTROL_STATUS</b> structure contains information about a file being registered or unregistered
///using the <b>RegisterDlls </b>INF directive to self-register DLLs on Windows 2000. When SetupInstallFromInfSection
///sends a SPFILENOTIFY_STARTREGISTRATION or SPFILENOTIFY_ENDREGISTRATION notification to the callback routine, the
///caller must provide a pointer to a <b>SP_REGISTER_CONTROL_STATUS</b> structure in the <i>MsgHandler</i> parameter.
struct SP_REGISTER_CONTROL_STATUSA
{
align (1):
    uint         cbSize;
    ///Fully qualified path of the file being registered or unregistered.
    const(char)* FileName;
    ///For an SPFILENOTIFY_STARTREGISTRATION notification, this member is not used and should be set to NO_ERROR. For a
    ///SPFILENOTIFY_ENDREGISTRATION notification, set to a system error code.
    uint         Win32Error;
    ///For a SPFILENOTIFY_STARTREGISTRATION notification, this member is not used and should be set to SPREG_SUCCESS.
    ///For a SPFILENOTIFY_ENDREGISTRATION notification, set to one of the following failure codes that indicate the
    ///result of registration. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="SPREG_SUCCESS"></a><a id="spreg_success"></a><dl> <dt><b>SPREG_SUCCESS</b></dt> </dl> </td> <td width="60%">
    ///The file was successfully registered or unregistered. <b>WinError</b> not used. </td> </tr> <tr> <td
    ///width="40%"><a id="SPREG_LOADLIBRARY"></a><a id="spreg_loadlibrary"></a><dl> <dt><b>SPREG_LOADLIBRARY</b></dt>
    ///</dl> </td> <td width="60%"> <b>LoadLibrary</b> failed for the file. <b>WinError</b> contains an extended error
    ///code from the component. </td> </tr> <tr> <td width="40%"><a id="SPREG_GETPROCADDR"></a><a
    ///id="spreg_getprocaddr"></a><dl> <dt><b>SPREG_GETPROCADDR</b></dt> </dl> </td> <td width="60%">
    ///<b>GetProcAddress</b> failed for the file. <b>WinError</b> contains an extended error code from the component.
    ///</td> </tr> <tr> <td width="40%"><a id="SPREG_REGSVR"></a><a id="spreg_regsvr"></a><dl>
    ///<dt><b>SPREG_REGSVR</b></dt> </dl> </td> <td width="60%"> <b>DLLRegisterServer</b> entry point returned failure.
    ///<b>WinError</b> contains an extended error code from the component. </td> </tr> <tr> <td width="40%"><a
    ///id="SPREG_DLLINSTALL"></a><a id="spreg_dllinstall"></a><dl> <dt><b>SPREG_DLLINSTALL</b></dt> </dl> </td> <td
    ///width="60%"> <b>DLLInstall</b> entry point returned failure. <b>WinError</b> contains an extended error code from
    ///the component. </td> </tr> <tr> <td width="40%"><a id="SPREG_TIMEOUT"></a><a id="spreg_timeout"></a><dl>
    ///<dt><b>SPREG_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The file registration or unregistration exceeded the
    ///specified timeout. <b>WinError</b> is set to ERROR_TIMEOUT. </td> </tr> <tr> <td width="40%"><a
    ///id="SPREG_UNKNOWN"></a><a id="spreg_unknown"></a><dl> <dt><b>SPREG_UNKNOWN</b></dt> </dl> </td> <td width="60%">
    ///File registration or unregistration failed for an unknown reason. <b>WinError</b> indicates an extended error
    ///code from the component. </td> </tr> </table>
    uint         FailureCode;
}

///The <b>SP_REGISTER_CONTROL_STATUS</b> structure contains information about a file being registered or unregistered
///using the <b>RegisterDlls </b>INF directive to self-register DLLs on Windows 2000. When SetupInstallFromInfSection
///sends a SPFILENOTIFY_STARTREGISTRATION or SPFILENOTIFY_ENDREGISTRATION notification to the callback routine, the
///caller must provide a pointer to a <b>SP_REGISTER_CONTROL_STATUS</b> structure in the <i>MsgHandler</i> parameter.
struct SP_REGISTER_CONTROL_STATUSW
{
align (1):
    uint          cbSize;
    ///Fully qualified path of the file being registered or unregistered.
    const(wchar)* FileName;
    ///For an SPFILENOTIFY_STARTREGISTRATION notification, this member is not used and should be set to NO_ERROR. For a
    ///SPFILENOTIFY_ENDREGISTRATION notification, set to a system error code.
    uint          Win32Error;
    ///For a SPFILENOTIFY_STARTREGISTRATION notification, this member is not used and should be set to SPREG_SUCCESS.
    ///For a SPFILENOTIFY_ENDREGISTRATION notification, set to one of the following failure codes that indicate the
    ///result of registration. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="SPREG_SUCCESS"></a><a id="spreg_success"></a><dl> <dt><b>SPREG_SUCCESS</b></dt> </dl> </td> <td width="60%">
    ///The file was successfully registered or unregistered. <b>WinError</b> not used. </td> </tr> <tr> <td
    ///width="40%"><a id="SPREG_LOADLIBRARY"></a><a id="spreg_loadlibrary"></a><dl> <dt><b>SPREG_LOADLIBRARY</b></dt>
    ///</dl> </td> <td width="60%"> <b>LoadLibrary</b> failed for the file. <b>WinError</b> contains an extended error
    ///code from the component. </td> </tr> <tr> <td width="40%"><a id="SPREG_GETPROCADDR"></a><a
    ///id="spreg_getprocaddr"></a><dl> <dt><b>SPREG_GETPROCADDR</b></dt> </dl> </td> <td width="60%">
    ///<b>GetProcAddress</b> failed for the file. <b>WinError</b> contains an extended error code from the component.
    ///</td> </tr> <tr> <td width="40%"><a id="SPREG_REGSVR"></a><a id="spreg_regsvr"></a><dl>
    ///<dt><b>SPREG_REGSVR</b></dt> </dl> </td> <td width="60%"> <b>DLLRegisterServer</b> entry point returned failure.
    ///<b>WinError</b> contains an extended error code from the component. </td> </tr> <tr> <td width="40%"><a
    ///id="SPREG_DLLINSTALL"></a><a id="spreg_dllinstall"></a><dl> <dt><b>SPREG_DLLINSTALL</b></dt> </dl> </td> <td
    ///width="60%"> <b>DLLInstall</b> entry point returned failure. <b>WinError</b> contains an extended error code from
    ///the component. </td> </tr> <tr> <td width="40%"><a id="SPREG_TIMEOUT"></a><a id="spreg_timeout"></a><dl>
    ///<dt><b>SPREG_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The file registration or unregistration exceeded the
    ///specified timeout. <b>WinError</b> is set to ERROR_TIMEOUT. </td> </tr> <tr> <td width="40%"><a
    ///id="SPREG_UNKNOWN"></a><a id="spreg_unknown"></a><dl> <dt><b>SPREG_UNKNOWN</b></dt> </dl> </td> <td width="60%">
    ///File registration or unregistration failed for an unknown reason. <b>WinError</b> indicates an extended error
    ///code from the component. </td> </tr> </table>
    uint          FailureCode;
}

///The <b>SP_FILE_COPY_PARAMS</b> structure describes a single file copy operation.
struct SP_FILE_COPY_PARAMS_A
{
align (1):
    ///Size of the structure, in bytes. Set to the value: <code>sizeof(SP_FILE_COPY_PARAMS)</code>.
    uint         cbSize;
    ///Handle to a setup file queue, as returned by SetupOpenFileQueue.
    void*        QueueHandle;
    ///Optional pointer to the root of the source for this copy, such as A:\.
    const(char)* SourceRootPath;
    ///Optional pointer to the path relative to <b>SourceRootPath</b> where the file can be found.
    const(char)* SourcePath;
    ///File name part of the file to be copied.
    const(char)* SourceFilename;
    ///Optional pointer to a description of the source media to be used during disk prompts.
    const(char)* SourceDescription;
    ///Optional pointer to a tag file whose presence at <b>SourceRootPath</b> indicates the presence of the source
    ///media. If not specified, the file itself will be used as the tag file if required.
    const(char)* SourceTagfile;
    ///Directory where the file is to be copied.
    const(char)* TargetDirectory;
    ///Optional pointer to the name of the target file. If not specified, the target file will have the same name as the
    ///source file.
    const(char)* TargetFilename;
    ///Flags that control the behavior of the file copy operation. These flags may be a combination of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="SP_COPY_DELETESOURCE"></a><a id="sp_copy_deletesource"></a><dl> <dt><b>SP_COPY_DELETESOURCE</b></dt> </dl>
    ///</td> <td width="60%"> Delete the source file upon successful copy. The caller is not notified if the deletion
    ///fails. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_REPLACEONLY"></a><a id="sp_copy_replaceonly"></a><dl>
    ///<dt><b>SP_COPY_REPLACEONLY</b></dt> </dl> </td> <td width="60%"> Copy the file only if doing so would overwrite a
    ///file at the destination path. The caller is not notified. </td> </tr> <tr> <td width="40%"><a
    ///id="SP_COPY_NEWER_OR_SAME"></a><a id="sp_copy_newer_or_same"></a><dl> <dt><b>SP_COPY_NEWER_OR_SAME</b></dt> </dl>
    ///</td> <td width="60%"> Examine each file being copied to see if its version resources indicate that it is either
    ///the same version or not newer than an existing copy on the target. The file version information used during
    ///version checks is that specified in the <b>dwFileVersionMS</b> and <b>dwFileVersionLS</b> members of a
    ///VS_FIXEDFILEINFO structure, as filled in by the version functions. If one of the files does not have version
    ///resources, or if they have identical version information, the source file is considered newer. If the source file
    ///is not equal in version or newer, and <i>CopyMsgHandler</i> is specified, the caller is notified and may cancel
    ///the copy. If <i>CopyMsgHandler</i> is not specified, the file is not copied. </td> </tr> <tr> <td width="40%"><a
    ///id="SP_COPY_NEWER_ONLY"></a><a id="sp_copy_newer_only"></a><dl> <dt><b>SP_COPY_NEWER_ONLY</b></dt> </dl> </td>
    ///<td width="60%"> Examine each file being copied to see if its version resources indicate that it is not newer
    ///than an existing copy on the target. If the source file is newer but not equal in version to the existing target,
    ///the file is copied. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NOOVERWRITE"></a><a
    ///id="sp_copy_nooverwrite"></a><dl> <dt><b>SP_COPY_NOOVERWRITE</b></dt> </dl> </td> <td width="60%"> Check whether
    ///the target file exists, and if so, notify the caller who may veto the copy. If <i>CopyMsgHandler</i> is not
    ///specified, the file is not overwritten. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NODECOMP"></a><a
    ///id="sp_copy_nodecomp"></a><dl> <dt><b>SP_COPY_NODECOMP</b></dt> </dl> </td> <td width="60%"> Do not decompress
    ///the file. When this flag is set, the target file is not given the uncompressed form of the source name (if
    ///appropriate). For example, copying f:\x86\cmd.ex_ to \\install\temp results in a target file of
    ///\\install\temp\cmd.ex_. If the SP_COPY_NODECOMP flag was not specified, the file would be decompressed and the
    ///target would be called \\install\temp\cmd.exe. The file name part of <i>DestinationName</i>, if specified, is
    ///stripped and replaced with the file name of the source file. When SP_COPY_NODECOMP is specified, no language or
    ///version information can be checked. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_LANGUAGEAWARE"></a><a
    ///id="sp_copy_languageaware"></a><dl> <dt><b>SP_COPY_LANGUAGEAWARE</b></dt> </dl> </td> <td width="60%"> Examine
    ///each file being copied to see if its language differs from the language of any existing file already on the
    ///target. If so, and <i>CopyMsgHandler</i> is specified, the caller is notified and may cancel the copy. If
    ///<i>CopyMsgHandler</i> is not specified, the file is not copied. </td> </tr> <tr> <td width="40%"><a
    ///id="SP_COPY_SOURCE_ABSOLUTE"></a><a id="sp_copy_source_absolute"></a><dl> <dt><b>SP_COPY_SOURCE_ABSOLUTE</b></dt>
    ///</dl> </td> <td width="60%"> <i>SourceFile</i> is a full source path. Do not look it up in the SourceDisksNames
    ///section of the INF file. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_SOURCEPATH_ABSOLUTE"></a><a
    ///id="sp_copy_sourcepath_absolute"></a><dl> <dt><b>SP_COPY_SOURCEPATH_ABSOLUTE</b></dt> </dl> </td> <td
    ///width="60%"> <i>SourcePathRoot</i> is the full path part of the source file. Ignore the relative source specified
    ///in the SourceDisksNames section of the INF file for the source media where the file is located. This flag is
    ///ignored if SP_COPY_SOURCE_ABSOLUTE is specified. </td> </tr> <tr> <td width="40%"><a
    ///id="SP_COPY_FORCE_IN_USE"></a><a id="sp_copy_force_in_use"></a><dl> <dt><b>SP_COPY_FORCE_IN_USE</b></dt> </dl>
    ///</td> <td width="60%"> If the target exists, behave as if it is in-use and queue the file for copying on the next
    ///system reboot. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_IN_USE_NEEDS_REBOOT"></a><a
    ///id="sp_copy_in_use_needs_reboot"></a><dl> <dt><b>SP_COPY_IN_USE_NEEDS_REBOOT</b></dt> </dl> </td> <td
    ///width="60%"> If the file was in-use during the copy operation, alert the user that the system needs to be
    ///rebooted. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NOSKIP"></a><a id="sp_copy_noskip"></a><dl>
    ///<dt><b>SP_COPY_NOSKIP</b></dt> </dl> </td> <td width="60%"> Do not give the user the option to skip a file. </td>
    ///</tr> <tr> <td width="40%"><a id="SP_COPY_FORCE_NOOVERWRITE"></a><a id="sp_copy_force_nooverwrite"></a><dl>
    ///<dt><b>SP_COPY_FORCE_NOOVERWRITE</b></dt> </dl> </td> <td width="60%"> Check whether the target file exists, and
    ///if so, the file is not overwritten. The caller is not notified. </td> </tr> <tr> <td width="40%"><a
    ///id="SP_COPY_FORCE_NEWER"></a><a id="sp_copy_force_newer"></a><dl> <dt><b>SP_COPY_FORCE_NEWER</b></dt> </dl> </td>
    ///<td width="60%"> Examine each file being copied to see if its version resources (or time stamps for non-image
    ///files) indicate that it is not newer than an existing copy on the target. If the file being copied is not newer,
    ///the file is not copied. The caller is not notified. </td> </tr> <tr> <td width="40%"><a
    ///id="SP_COPY_WARNIFSKIP"></a><a id="sp_copy_warnifskip"></a><dl> <dt><b>SP_COPY_WARNIFSKIP</b></dt> </dl> </td>
    ///<td width="60%"> If the user tries to skip a file, warn them that skipping a file may affect the installation.
    ///(Used for system-critical files.) </td> </tr> </table>
    uint         CopyStyle;
    ///Handle to the INF to use to obtain source information.
    void*        LayoutInf;
    ///An optional Security Descriptor String specifying the ACL to apply to the file.
    const(char)* SecurityDescriptor;
}

///The <b>SP_FILE_COPY_PARAMS</b> structure describes a single file copy operation.
struct SP_FILE_COPY_PARAMS_W
{
align (1):
    ///Size of the structure, in bytes. Set to the value: <code>sizeof(SP_FILE_COPY_PARAMS)</code>.
    uint          cbSize;
    ///Handle to a setup file queue, as returned by SetupOpenFileQueue.
    void*         QueueHandle;
    ///Optional pointer to the root of the source for this copy, such as A:\.
    const(wchar)* SourceRootPath;
    ///Optional pointer to the path relative to <b>SourceRootPath</b> where the file can be found.
    const(wchar)* SourcePath;
    ///File name part of the file to be copied.
    const(wchar)* SourceFilename;
    ///Optional pointer to a description of the source media to be used during disk prompts.
    const(wchar)* SourceDescription;
    ///Optional pointer to a tag file whose presence at <b>SourceRootPath</b> indicates the presence of the source
    ///media. If not specified, the file itself will be used as the tag file if required.
    const(wchar)* SourceTagfile;
    ///Directory where the file is to be copied.
    const(wchar)* TargetDirectory;
    ///Optional pointer to the name of the target file. If not specified, the target file will have the same name as the
    ///source file.
    const(wchar)* TargetFilename;
    ///Flags that control the behavior of the file copy operation. These flags may be a combination of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="SP_COPY_DELETESOURCE"></a><a id="sp_copy_deletesource"></a><dl> <dt><b>SP_COPY_DELETESOURCE</b></dt> </dl>
    ///</td> <td width="60%"> Delete the source file upon successful copy. The caller is not notified if the deletion
    ///fails. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_REPLACEONLY"></a><a id="sp_copy_replaceonly"></a><dl>
    ///<dt><b>SP_COPY_REPLACEONLY</b></dt> </dl> </td> <td width="60%"> Copy the file only if doing so would overwrite a
    ///file at the destination path. The caller is not notified. </td> </tr> <tr> <td width="40%"><a
    ///id="SP_COPY_NEWER_OR_SAME"></a><a id="sp_copy_newer_or_same"></a><dl> <dt><b>SP_COPY_NEWER_OR_SAME</b></dt> </dl>
    ///</td> <td width="60%"> Examine each file being copied to see if its version resources indicate that it is either
    ///the same version or not newer than an existing copy on the target. The file version information used during
    ///version checks is that specified in the <b>dwFileVersionMS</b> and <b>dwFileVersionLS</b> members of a
    ///VS_FIXEDFILEINFO structure, as filled in by the version functions. If one of the files does not have version
    ///resources, or if they have identical version information, the source file is considered newer. If the source file
    ///is not equal in version or newer, and <i>CopyMsgHandler</i> is specified, the caller is notified and may cancel
    ///the copy. If <i>CopyMsgHandler</i> is not specified, the file is not copied. </td> </tr> <tr> <td width="40%"><a
    ///id="SP_COPY_NEWER_ONLY"></a><a id="sp_copy_newer_only"></a><dl> <dt><b>SP_COPY_NEWER_ONLY</b></dt> </dl> </td>
    ///<td width="60%"> Examine each file being copied to see if its version resources indicate that it is not newer
    ///than an existing copy on the target. If the source file is newer but not equal in version to the existing target,
    ///the file is copied. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NOOVERWRITE"></a><a
    ///id="sp_copy_nooverwrite"></a><dl> <dt><b>SP_COPY_NOOVERWRITE</b></dt> </dl> </td> <td width="60%"> Check whether
    ///the target file exists, and if so, notify the caller who may veto the copy. If <i>CopyMsgHandler</i> is not
    ///specified, the file is not overwritten. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NODECOMP"></a><a
    ///id="sp_copy_nodecomp"></a><dl> <dt><b>SP_COPY_NODECOMP</b></dt> </dl> </td> <td width="60%"> Do not decompress
    ///the file. When this flag is set, the target file is not given the uncompressed form of the source name (if
    ///appropriate). For example, copying f:\x86\cmd.ex_ to \\install\temp results in a target file of
    ///\\install\temp\cmd.ex_. If the SP_COPY_NODECOMP flag was not specified, the file would be decompressed and the
    ///target would be called \\install\temp\cmd.exe. The file name part of <i>DestinationName</i>, if specified, is
    ///stripped and replaced with the file name of the source file. When SP_COPY_NODECOMP is specified, no language or
    ///version information can be checked. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_LANGUAGEAWARE"></a><a
    ///id="sp_copy_languageaware"></a><dl> <dt><b>SP_COPY_LANGUAGEAWARE</b></dt> </dl> </td> <td width="60%"> Examine
    ///each file being copied to see if its language differs from the language of any existing file already on the
    ///target. If so, and <i>CopyMsgHandler</i> is specified, the caller is notified and may cancel the copy. If
    ///<i>CopyMsgHandler</i> is not specified, the file is not copied. </td> </tr> <tr> <td width="40%"><a
    ///id="SP_COPY_SOURCE_ABSOLUTE"></a><a id="sp_copy_source_absolute"></a><dl> <dt><b>SP_COPY_SOURCE_ABSOLUTE</b></dt>
    ///</dl> </td> <td width="60%"> <i>SourceFile</i> is a full source path. Do not look it up in the SourceDisksNames
    ///section of the INF file. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_SOURCEPATH_ABSOLUTE"></a><a
    ///id="sp_copy_sourcepath_absolute"></a><dl> <dt><b>SP_COPY_SOURCEPATH_ABSOLUTE</b></dt> </dl> </td> <td
    ///width="60%"> <i>SourcePathRoot</i> is the full path part of the source file. Ignore the relative source specified
    ///in the SourceDisksNames section of the INF file for the source media where the file is located. This flag is
    ///ignored if SP_COPY_SOURCE_ABSOLUTE is specified. </td> </tr> <tr> <td width="40%"><a
    ///id="SP_COPY_FORCE_IN_USE"></a><a id="sp_copy_force_in_use"></a><dl> <dt><b>SP_COPY_FORCE_IN_USE</b></dt> </dl>
    ///</td> <td width="60%"> If the target exists, behave as if it is in-use and queue the file for copying on the next
    ///system reboot. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_IN_USE_NEEDS_REBOOT"></a><a
    ///id="sp_copy_in_use_needs_reboot"></a><dl> <dt><b>SP_COPY_IN_USE_NEEDS_REBOOT</b></dt> </dl> </td> <td
    ///width="60%"> If the file was in-use during the copy operation, alert the user that the system needs to be
    ///rebooted. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NOSKIP"></a><a id="sp_copy_noskip"></a><dl>
    ///<dt><b>SP_COPY_NOSKIP</b></dt> </dl> </td> <td width="60%"> Do not give the user the option to skip a file. </td>
    ///</tr> <tr> <td width="40%"><a id="SP_COPY_FORCE_NOOVERWRITE"></a><a id="sp_copy_force_nooverwrite"></a><dl>
    ///<dt><b>SP_COPY_FORCE_NOOVERWRITE</b></dt> </dl> </td> <td width="60%"> Check whether the target file exists, and
    ///if so, the file is not overwritten. The caller is not notified. </td> </tr> <tr> <td width="40%"><a
    ///id="SP_COPY_FORCE_NEWER"></a><a id="sp_copy_force_newer"></a><dl> <dt><b>SP_COPY_FORCE_NEWER</b></dt> </dl> </td>
    ///<td width="60%"> Examine each file being copied to see if its version resources (or time stamps for non-image
    ///files) indicate that it is not newer than an existing copy on the target. If the file being copied is not newer,
    ///the file is not copied. The caller is not notified. </td> </tr> <tr> <td width="40%"><a
    ///id="SP_COPY_WARNIFSKIP"></a><a id="sp_copy_warnifskip"></a><dl> <dt><b>SP_COPY_WARNIFSKIP</b></dt> </dl> </td>
    ///<td width="60%"> If the user tries to skip a file, warn them that skipping a file may affect the installation.
    ///(Used for system-critical files.) </td> </tr> </table>
    uint          CopyStyle;
    ///Handle to the INF to use to obtain source information.
    void*         LayoutInf;
    ///An optional Security Descriptor String specifying the ACL to apply to the file.
    const(wchar)* SecurityDescriptor;
}

///The <b>SP_INF_SIGNER_INFO</b> structure stores information about an INF file's digital signature.
struct SP_INF_SIGNER_INFO_V1_A
{
align (1):
    ///Size of this structure, in bytes.
    uint      cbSize;
    ///Path to the catalog file, stored in an array of maximum size MAX_PATH characters.
    byte[260] CatalogFile;
    ///Path to the digital signer of the file, stored in an array of maximum size MAX_PATH characters.
    byte[260] DigitalSigner;
    ///Version of the digital signer, stored in an array of size MAX_PATH characters.
    byte[260] DigitalSignerVersion;
}

///The <b>SP_INF_SIGNER_INFO</b> structure stores information about an INF file's digital signature.
struct SP_INF_SIGNER_INFO_V1_W
{
align (1):
    ///Size of this structure, in bytes.
    uint        cbSize;
    ///Path to the catalog file, stored in an array of maximum size MAX_PATH characters.
    ushort[260] CatalogFile;
    ///Path to the digital signer of the file, stored in an array of maximum size MAX_PATH characters.
    ushort[260] DigitalSigner;
    ///Version of the digital signer, stored in an array of size MAX_PATH characters.
    ushort[260] DigitalSignerVersion;
}

///The <b>SP_INF_SIGNER_INFO</b> structure stores information about an INF file's digital signature.
struct SP_INF_SIGNER_INFO_V2_A
{
align (1):
    ///Size of this structure, in bytes.
    uint      cbSize;
    ///Path to the catalog file, stored in an array of maximum size MAX_PATH characters.
    byte[260] CatalogFile;
    ///Path to the digital signer of the file, stored in an array of maximum size MAX_PATH characters.
    byte[260] DigitalSigner;
    ///Version of the digital signer, stored in an array of size MAX_PATH characters.
    byte[260] DigitalSignerVersion;
    uint      SignerScore;
}

///The <b>SP_INF_SIGNER_INFO</b> structure stores information about an INF file's digital signature.
struct SP_INF_SIGNER_INFO_V2_W
{
align (1):
    ///Size of this structure, in bytes.
    uint        cbSize;
    ///Path to the catalog file, stored in an array of maximum size MAX_PATH characters.
    ushort[260] CatalogFile;
    ///Path to the digital signer of the file, stored in an array of maximum size MAX_PATH characters.
    ushort[260] DigitalSigner;
    ///Version of the digital signer, stored in an array of size MAX_PATH characters.
    ushort[260] DigitalSignerVersion;
    uint        SignerScore;
}

// Functions

///The <b>MsiCloseHandle</b> function closes an open installation handle.
///Params:
///    hAny = Specifies any open installation handle.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> An invalid handle was passed to the function.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function
///    succeeded. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiCloseHandle(uint hAny);

///The <b>MsiCloseAllHandles</b> function closes all open installation handles allocated by the current thread. This is
///a diagnostic function and should not be used for cleanup.
///Returns:
///    This function returns 0 if all handles are closed. Otherwise, the function returns the number of handles open
///    prior to its call.
///    
@DllImport("msi")
uint MsiCloseAllHandles();

///The <b>MsiSetInternalUI</b> function enables the installer's internal user interface. Then this user interface is
///used for all subsequent calls to user-interface-generating installer functions in this process. For more information,
///see User Interface Levels.
///Params:
///    dwUILevel = Specifies the level of complexity of the user interface. This parameter can be one of the following values.
///                <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLUILEVEL_FULL"></a><a
///                id="installuilevel_full"></a><dl> <dt><b>INSTALLUILEVEL_FULL</b></dt> </dl> </td> <td width="60%"> Authored user
///                interface with wizards, progress, and errors. </td> </tr> <tr> <td width="40%"><a
///                id="INSTALLUILEVEL_REDUCED"></a><a id="installuilevel_reduced"></a><dl> <dt><b>INSTALLUILEVEL_REDUCED</b></dt>
///                </dl> </td> <td width="60%"> Authored user interface with wizard dialog boxes suppressed. </td> </tr> <tr> <td
///                width="40%"><a id="INSTALLUILEVEL_BASIC"></a><a id="installuilevel_basic"></a><dl>
///                <dt><b>INSTALLUILEVEL_BASIC</b></dt> </dl> </td> <td width="60%"> Simple progress and error handling. </td> </tr>
///                <tr> <td width="40%"><a id="INSTALLUILEVEL_DEFAULT"></a><a id="installuilevel_default"></a><dl>
///                <dt><b>INSTALLUILEVEL_DEFAULT</b></dt> </dl> </td> <td width="60%"> The installer chooses an appropriate user
///                interface level. </td> </tr> <tr> <td width="40%"><a id="INSTALLUILEVEL_NONE"></a><a
///                id="installuilevel_none"></a><dl> <dt><b>INSTALLUILEVEL_NONE</b></dt> </dl> </td> <td width="60%"> Completely
///                silent installation. </td> </tr> <tr> <td width="40%"><a id="INSTALLUILEVEL_ENDDIALOG"></a><a
///                id="installuilevel_enddialog"></a><dl> <dt><b>INSTALLUILEVEL_ENDDIALOG</b></dt> </dl> </td> <td width="60%"> If
///                combined with any above value, the installer displays a modal dialog box at the end of a successful installation
///                or if there has been an error. No dialog box is displayed if the user cancels. </td> </tr> <tr> <td
///                width="40%"><a id="INSTALLUILEVEL_PROGRESSONLY"></a><a id="installuilevel_progressonly"></a><dl>
///                <dt><b>INSTALLUILEVEL_PROGRESSONLY</b></dt> </dl> </td> <td width="60%"> If combined with the
///                <b>INSTALLUILEVEL_BASIC</b> value, the installer shows simple progress dialog boxes but does not display any
///                modal dialog boxes or error dialog boxes. </td> </tr> <tr> <td width="40%"><a id="INSTALLUILEVEL_NOCHANGE"></a><a
///                id="installuilevel_nochange"></a><dl> <dt><b>INSTALLUILEVEL_NOCHANGE</b></dt> </dl> </td> <td width="60%"> No
///                change in the UI level. However, if <i>phWnd</i> is not Null, the parent window can change. </td> </tr> <tr> <td
///                width="40%"><a id="INSTALLUILEVEL_HIDECANCEL"></a><a id="installuilevel_hidecancel"></a><dl>
///                <dt><b>INSTALLUILEVEL_HIDECANCEL</b></dt> </dl> </td> <td width="60%"> If combined with the
///                <b>INSTALLUILEVEL_BASIC</b> value, the installer shows simple progress dialog boxes but does not display a
///                <b>Cancel</b> button on the dialog. This prevents users from canceling the install. </td> </tr> <tr> <td
///                width="40%"><a id="INSTALLUILEVEL_SOURCERESONLY"></a><a id="installuilevel_sourceresonly"></a><dl>
///                <dt><b>INSTALLUILEVEL_SOURCERESONLY</b></dt> </dl> </td> <td width="60%"> If this value is combined with the
///                <b>INSTALLUILEVEL_NONE</b> value, the installer displays only the dialog boxes used for source resolution. No
///                other dialog boxes are shown. This value has no effect if the UI level is not <b>INSTALLUILEVEL_NONE</b>. It is
///                used with an external user interface designed to handle all of the UI except for source resolution. In this case,
///                the installer handles source resolution. </td> </tr> </table>
///    phWnd = Pointer to a window. This window becomes the owner of any user interface created. A pointer to the previous owner
///            of the user interface is returned. If this parameter is null, the owner of the user interface does not change.
///Returns:
///    The previous user interface level is returned. If an invalid <i>dwUILevel </i>is passed, then
///    <b>INSTALLUILEVEL_NOCHANGE</b> is returned.
///    
@DllImport("msi")
INSTALLUILEVEL MsiSetInternalUI(INSTALLUILEVEL dwUILevel, HWND* phWnd);

///The <b>MsiSetExternalUI</b> function enables an external user-interface handler. This external UI handler is called
///before the normal internal user-interface handler. The external UI handler has the option to suppress the internal UI
///by returning a non-zero value to indicate that it has handled the messages. For more information, see About the User
///Interface.
///Params:
///    puiHandler = Specifies a callback function that conforms to the INSTALLUI_HANDLER specification.
///    dwMessageFilter = Specifies which messages to handle using the external message handler. If the external handler returns a non-zero
///                      result, then that message will not be sent to the UI, instead the message will be logged if logging has been
///                      enabled. For more information, see the MsiEnableLog function. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                      <tr> <td width="40%"><a id="INSTALLLOGMODE_FILESINUSE"></a><a id="installlogmode_filesinuse"></a><dl>
///                      <dt><b>INSTALLLOGMODE_FILESINUSE</b></dt> </dl> </td> <td width="60%"> Files in use information. When this
///                      message is received, a FilesInUse Dialog should be displayed. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_FATALEXIT"></a><a id="installlogmode_fatalexit"></a><dl>
///                      <dt><b>INSTALLLOGMODE_FATALEXIT</b></dt> </dl> </td> <td width="60%"> Premature termination of installation.
///                      </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_ERROR"></a><a id="installlogmode_error"></a><dl>
///                      <dt><b>INSTALLLOGMODE_ERROR</b></dt> </dl> </td> <td width="60%"> The error messages are logged. </td> </tr> <tr>
///                      <td width="40%"><a id="INSTALLLOGMODE_WARNING"></a><a id="installlogmode_warning"></a><dl>
///                      <dt><b>INSTALLLOGMODE_WARNING</b></dt> </dl> </td> <td width="60%"> The warning messages are logged. </td> </tr>
///                      <tr> <td width="40%"><a id="INSTALLLOGMODE_USER"></a><a id="installlogmode_user"></a><dl>
///                      <dt><b>INSTALLLOGMODE_USER</b></dt> </dl> </td> <td width="60%"> The user requests are logged. </td> </tr> <tr>
///                      <td width="40%"><a id="INSTALLLOGMODE_INFO"></a><a id="installlogmode_info"></a><dl>
///                      <dt><b>INSTALLLOGMODE_INFO</b></dt> </dl> </td> <td width="60%"> The status messages that are not displayed are
///                      logged. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_RESOLVESOURCE"></a><a
///                      id="installlogmode_resolvesource"></a><dl> <dt><b>INSTALLLOGMODE_RESOLVESOURCE</b></dt> </dl> </td> <td
///                      width="60%"> Request to determine a valid source location. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_RMFILESINUSE"></a><a id="installlogmode_rmfilesinuse"></a><dl>
///                      <dt><b>INSTALLLOGMODE_RMFILESINUSE</b></dt> </dl> </td> <td width="60%"> Files in use information. When this
///                      message is received, a MsiRMFilesInUse Dialog should be displayed. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_OUTOFDISKSPACE"></a><a id="installlogmode_outofdiskspace"></a><dl>
///                      <dt><b>INSTALLLOGMODE_OUTOFDISKSPACE</b></dt> </dl> </td> <td width="60%"> There was insufficient disk space.
///                      </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_ACTIONSTART"></a><a
///                      id="installlogmode_actionstart"></a><dl> <dt><b>INSTALLLOGMODE_ACTIONSTART</b></dt> </dl> </td> <td width="60%">
///                      The start of new installation actions are logged. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_ACTIONDATA"></a><a id="installlogmode_actiondata"></a><dl>
///                      <dt><b>INSTALLLOGMODE_ACTIONDATA</b></dt> </dl> </td> <td width="60%"> The data record with the installation
///                      action is logged. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_COMMONDATA"></a><a
///                      id="installlogmode_commondata"></a><dl> <dt><b>INSTALLLOGMODE_COMMONDATA</b></dt> </dl> </td> <td width="60%">
///                      The parameters for user-interface initialization are logged. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_PROGRESS"></a><a id="installlogmode_progress"></a><dl> <dt><b>INSTALLLOGMODE_PROGRESS</b></dt>
///                      </dl> </td> <td width="60%"> Progress bar information. This message includes information on units so far and
///                      total number of units. For an explanation of the message format, see the MsiProcessMessage function. This message
///                      is only sent to an external user interface and is not logged. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_INITIALIZE"></a><a id="installlogmode_initialize"></a><dl>
///                      <dt><b>INSTALLLOGMODE_INITIALIZE</b></dt> </dl> </td> <td width="60%"> If this is not a quiet installation, then
///                      the basic UI has been initialized. If this is a full UI installation, the <i>full UI</i> is not yet initialized.
///                      This message is only sent to an external user interface and is not logged. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_TERMINATE"></a><a id="installlogmode_terminate"></a><dl>
///                      <dt><b>INSTALLLOGMODE_TERMINATE</b></dt> </dl> </td> <td width="60%"> If a full UI is being used, the <i>full
///                      UI</i> has ended. If this is not a quiet installation, the basic UI has not yet ended. This message is only sent
///                      to an external user interface and is not logged. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_SHOWDIALOG"></a><a id="installlogmode_showdialog"></a><dl>
///                      <dt><b>INSTALLLOGMODE_SHOWDIALOG</b></dt> </dl> </td> <td width="60%"> Sent prior to display of the full UI
///                      dialog. This message is only sent to an external user interface and is not logged. </td> </tr> <tr> <td
///                      width="40%"><a id="INSTALLLOGMODE_INSTALLSTART"></a><a id="installlogmode_installstart"></a><dl>
///                      <dt><b><b>INSTALLLOGMODE_INSTALLSTART</b></b></dt> </dl> </td> <td width="60%"> Installation of product begins.
///                      The message contains the product's ProductName and ProductCode. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_INSTALLEND"></a><a id="installlogmode_installend"></a><dl>
///                      <dt><b><b>INSTALLLOGMODE_INSTALLEND</b></b></dt> </dl> </td> <td width="60%"> Installation of product ends. The
///                      message contains the product's ProductName, ProductCode, and return value. </td> </tr> </table>
///    pvContext = Pointer to an application context that is passed to the callback function. This parameter can be used for error
///                checking.
///Returns:
///    The return value is the previously set external handler, or zero (0) if there was no previously set handler.
///    
@DllImport("msi")
INSTALLUI_HANDLERA MsiSetExternalUIA(INSTALLUI_HANDLERA puiHandler, uint dwMessageFilter, void* pvContext);

///The <b>MsiSetExternalUI</b> function enables an external user-interface handler. This external UI handler is called
///before the normal internal user-interface handler. The external UI handler has the option to suppress the internal UI
///by returning a non-zero value to indicate that it has handled the messages. For more information, see About the User
///Interface.
///Params:
///    puiHandler = Specifies a callback function that conforms to the INSTALLUI_HANDLER specification.
///    dwMessageFilter = Specifies which messages to handle using the external message handler. If the external handler returns a non-zero
///                      result, then that message will not be sent to the UI, instead the message will be logged if logging has been
///                      enabled. For more information, see the MsiEnableLog function. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                      <tr> <td width="40%"><a id="INSTALLLOGMODE_FILESINUSE"></a><a id="installlogmode_filesinuse"></a><dl>
///                      <dt><b>INSTALLLOGMODE_FILESINUSE</b></dt> </dl> </td> <td width="60%"> Files in use information. When this
///                      message is received, a FilesInUse Dialog should be displayed. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_FATALEXIT"></a><a id="installlogmode_fatalexit"></a><dl>
///                      <dt><b>INSTALLLOGMODE_FATALEXIT</b></dt> </dl> </td> <td width="60%"> Premature termination of installation.
///                      </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_ERROR"></a><a id="installlogmode_error"></a><dl>
///                      <dt><b>INSTALLLOGMODE_ERROR</b></dt> </dl> </td> <td width="60%"> The error messages are logged. </td> </tr> <tr>
///                      <td width="40%"><a id="INSTALLLOGMODE_WARNING"></a><a id="installlogmode_warning"></a><dl>
///                      <dt><b>INSTALLLOGMODE_WARNING</b></dt> </dl> </td> <td width="60%"> The warning messages are logged. </td> </tr>
///                      <tr> <td width="40%"><a id="INSTALLLOGMODE_USER"></a><a id="installlogmode_user"></a><dl>
///                      <dt><b>INSTALLLOGMODE_USER</b></dt> </dl> </td> <td width="60%"> The user requests are logged. </td> </tr> <tr>
///                      <td width="40%"><a id="INSTALLLOGMODE_INFO"></a><a id="installlogmode_info"></a><dl>
///                      <dt><b>INSTALLLOGMODE_INFO</b></dt> </dl> </td> <td width="60%"> The status messages that are not displayed are
///                      logged. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_RESOLVESOURCE"></a><a
///                      id="installlogmode_resolvesource"></a><dl> <dt><b>INSTALLLOGMODE_RESOLVESOURCE</b></dt> </dl> </td> <td
///                      width="60%"> Request to determine a valid source location. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_RMFILESINUSE"></a><a id="installlogmode_rmfilesinuse"></a><dl>
///                      <dt><b>INSTALLLOGMODE_RMFILESINUSE</b></dt> </dl> </td> <td width="60%"> Files in use information. When this
///                      message is received, a MsiRMFilesInUse Dialog should be displayed. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_OUTOFDISKSPACE"></a><a id="installlogmode_outofdiskspace"></a><dl>
///                      <dt><b>INSTALLLOGMODE_OUTOFDISKSPACE</b></dt> </dl> </td> <td width="60%"> There was insufficient disk space.
///                      </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_ACTIONSTART"></a><a
///                      id="installlogmode_actionstart"></a><dl> <dt><b>INSTALLLOGMODE_ACTIONSTART</b></dt> </dl> </td> <td width="60%">
///                      The start of new installation actions are logged. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_ACTIONDATA"></a><a id="installlogmode_actiondata"></a><dl>
///                      <dt><b>INSTALLLOGMODE_ACTIONDATA</b></dt> </dl> </td> <td width="60%"> The data record with the installation
///                      action is logged. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_COMMONDATA"></a><a
///                      id="installlogmode_commondata"></a><dl> <dt><b>INSTALLLOGMODE_COMMONDATA</b></dt> </dl> </td> <td width="60%">
///                      The parameters for user-interface initialization are logged. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_PROGRESS"></a><a id="installlogmode_progress"></a><dl> <dt><b>INSTALLLOGMODE_PROGRESS</b></dt>
///                      </dl> </td> <td width="60%"> Progress bar information. This message includes information on units so far and
///                      total number of units. For an explanation of the message format, see the MsiProcessMessage function. This message
///                      is only sent to an external user interface and is not logged. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_INITIALIZE"></a><a id="installlogmode_initialize"></a><dl>
///                      <dt><b>INSTALLLOGMODE_INITIALIZE</b></dt> </dl> </td> <td width="60%"> If this is not a quiet installation, then
///                      the basic UI has been initialized. If this is a full UI installation, the <i>full UI</i> is not yet initialized.
///                      This message is only sent to an external user interface and is not logged. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_TERMINATE"></a><a id="installlogmode_terminate"></a><dl>
///                      <dt><b>INSTALLLOGMODE_TERMINATE</b></dt> </dl> </td> <td width="60%"> If a full UI is being used, the <i>full
///                      UI</i> has ended. If this is not a quiet installation, the basic UI has not yet ended. This message is only sent
///                      to an external user interface and is not logged. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_SHOWDIALOG"></a><a id="installlogmode_showdialog"></a><dl>
///                      <dt><b>INSTALLLOGMODE_SHOWDIALOG</b></dt> </dl> </td> <td width="60%"> Sent prior to display of the full UI
///                      dialog. This message is only sent to an external user interface and is not logged. </td> </tr> <tr> <td
///                      width="40%"><a id="INSTALLLOGMODE_INSTALLSTART"></a><a id="installlogmode_installstart"></a><dl>
///                      <dt><b><b>INSTALLLOGMODE_INSTALLSTART</b></b></dt> </dl> </td> <td width="60%"> Installation of product begins.
///                      The message contains the product's ProductName and ProductCode. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_INSTALLEND"></a><a id="installlogmode_installend"></a><dl>
///                      <dt><b><b>INSTALLLOGMODE_INSTALLEND</b></b></dt> </dl> </td> <td width="60%"> Installation of product ends. The
///                      message contains the product's ProductName, ProductCode, and return value. </td> </tr> </table>
///    pvContext = Pointer to an application context that is passed to the callback function. This parameter can be used for error
///                checking.
///Returns:
///    The return value is the previously set external handler, or zero (0) if there was no previously set handler.
///    
@DllImport("msi")
INSTALLUI_HANDLERW MsiSetExternalUIW(INSTALLUI_HANDLERW puiHandler, uint dwMessageFilter, void* pvContext);

///The <b>MsiSetExternalUIRecord</b> function enables an external user-interface (UI) handler.
///Params:
///    puiHandler = Specifies a callback function that conforms to the INSTALLUI_HANDLER_RECORD specification. To disable the current
///                 external UI handler, call the function with this parameter set to a <b>NULL</b> value.
///    dwMessageFilter = Specifies which messages to handle using the external message handler. If the external handler returns a non-zero
///                      result, then that message is not sent to the UI, instead the message is logged if logging is enabled. For more
///                      information, see MsiEnableLog. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_FILESINUSE"></a><a id="installlogmode_filesinuse"></a><dl>
///                      <dt><b>INSTALLLOGMODE_FILESINUSE</b></dt> </dl> </td> <td width="60%"> Files in use information. When this
///                      message is received, a FilesInUse Dialog should be displayed. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_FATALEXIT"></a><a id="installlogmode_fatalexit"></a><dl>
///                      <dt><b>INSTALLLOGMODE_FATALEXIT</b></dt> </dl> </td> <td width="60%"> Premature termination of installation.
///                      </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_ERROR"></a><a id="installlogmode_error"></a><dl>
///                      <dt><b>INSTALLLOGMODE_ERROR</b></dt> </dl> </td> <td width="60%"> The error messages are logged. </td> </tr> <tr>
///                      <td width="40%"><a id="INSTALLLOGMODE_WARNING"></a><a id="installlogmode_warning"></a><dl>
///                      <dt><b>INSTALLLOGMODE_WARNING</b></dt> </dl> </td> <td width="60%"> The warning messages are logged. </td> </tr>
///                      <tr> <td width="40%"><a id="INSTALLLOGMODE_USER"></a><a id="installlogmode_user"></a><dl>
///                      <dt><b>INSTALLLOGMODE_USER</b></dt> </dl> </td> <td width="60%"> The user requests are logged. </td> </tr> <tr>
///                      <td width="40%"><a id="INSTALLLOGMODE_INFO"></a><a id="installlogmode_info"></a><dl>
///                      <dt><b>INSTALLLOGMODE_INFO</b></dt> </dl> </td> <td width="60%"> The status messages that are not displayed are
///                      logged. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_RESOLVESOURCE"></a><a
///                      id="installlogmode_resolvesource"></a><dl> <dt><b>INSTALLLOGMODE_RESOLVESOURCE</b></dt> </dl> </td> <td
///                      width="60%"> Request to determine a valid source location. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_RMFILESINUSE"></a><a id="installlogmode_rmfilesinuse"></a><dl>
///                      <dt><b>INSTALLLOGMODE_RMFILESINUSE</b></dt> </dl> </td> <td width="60%"> Files in use information. When this
///                      message is received, a MsiRMFilesInUse Dialog should be displayed. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_OUTOFDISKSPACE"></a><a id="installlogmode_outofdiskspace"></a><dl>
///                      <dt><b>INSTALLLOGMODE_OUTOFDISKSPACE</b></dt> </dl> </td> <td width="60%"> The is insufficient disk space. </td>
///                      </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_ACTIONSTART"></a><a id="installlogmode_actionstart"></a><dl>
///                      <dt><b>INSTALLLOGMODE_ACTIONSTART</b></dt> </dl> </td> <td width="60%"> The start of new installation actions are
///                      logged. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_ACTIONDATA"></a><a
///                      id="installlogmode_actiondata"></a><dl> <dt><b>INSTALLLOGMODE_ACTIONDATA</b></dt> </dl> </td> <td width="60%">
///                      The data record with the installation action is logged. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGMODE_COMMONDATA"></a><a id="installlogmode_commondata"></a><dl>
///                      <dt><b>INSTALLLOGMODE_COMMONDATA</b></dt> </dl> </td> <td width="60%"> The parameters for user-interface
///                      initialization are logged. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_PROGRESS"></a><a
///                      id="installlogmode_progress"></a><dl> <dt><b>INSTALLLOGMODE_PROGRESS</b></dt> </dl> </td> <td width="60%"> The
///                      Progress bar information. This message includes information about units so far and total number of units. This
///                      message is only sent to an external user interface and is not logged. For more information, see
///                      MsiProcessMessage. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_INITIALIZE"></a><a
///                      id="installlogmode_initialize"></a><dl> <dt><b>INSTALLLOGMODE_INITIALIZE</b></dt> </dl> </td> <td width="60%"> If
///                      this is not a quiet installation, then the basic UI is initialized. If this is a full UI installation, the Full
///                      UI is not yet initialized. This message is only sent to an external user interface and is not logged. </td> </tr>
///                      <tr> <td width="40%"><a id="INSTALLLOGMODE_TERMINATE"></a><a id="installlogmode_terminate"></a><dl>
///                      <dt><b>INSTALLLOGMODE_TERMINATE</b></dt> </dl> </td> <td width="60%"> If a full UI is being used, the full UI has
///                      ended. If this is not a quiet installation, the basic UI has not ended. This message is only sent to an external
///                      user interface and is not logged. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_SHOWDIALOG"></a><a
///                      id="installlogmode_showdialog"></a><dl> <dt><b>INSTALLLOGMODE_SHOWDIALOG</b></dt> </dl> </td> <td width="60%">
///                      Sent prior to display of the Full UI dialog. This message is only sent to an external user interface and is not
///                      logged. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_INSTALLSTART"></a><a
///                      id="installlogmode_installstart"></a><dl> <dt><b><b>INSTALLLOGMODE_INSTALLSTART</b></b></dt> </dl> </td> <td
///                      width="60%"> Installation of product begins. The message contains the product's ProductName and ProductCode.
///                      </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_INSTALLEND"></a><a id="installlogmode_installend"></a><dl>
///                      <dt><b><b>INSTALLLOGMODE_INSTALLEND</b></b></dt> </dl> </td> <td width="60%"> Installation of product ends. The
///                      message contains the product's ProductName, ProductCode, and return value. </td> </tr> </table>
///    pvContext = A pointer to an application context that is passed to the callback function. This parameter can be used for error
///                checking.
///    ppuiPrevHandler = Returns the pointer to the previously set callback function that conforms to the INSTALLUI_HANDLER_RECORD
///                      specification, or <b>NULL</b> if no callback is previously set.
///Returns:
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completes successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> This value
///    indicates that an attempt is made to call this function from a custom action. This function cannot be called from
///    a custom action. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSetExternalUIRecord(INSTALLUI_HANDLER_RECORD puiHandler, uint dwMessageFilter, void* pvContext, 
                            PINSTALLUI_HANDLER_RECORD ppuiPrevHandler);

///The <b>MsiEnableLog</b> function sets the log mode for all subsequent installations that are initiated in the calling
///process.
///Params:
///    dwLogMode = Specifies the log mode. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_FATALEXIT"></a><a
///                id="installlogmode_fatalexit"></a><dl> <dt><b>INSTALLLOGMODE_FATALEXIT</b></dt> </dl> </td> <td width="60%"> Logs
///                out of memory or fatal exit information. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_ERROR"></a><a
///                id="installlogmode_error"></a><dl> <dt><b>INSTALLLOGMODE_ERROR</b></dt> </dl> </td> <td width="60%"> Logs the
///                error messages. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_EXTRADEBUG"></a><a
///                id="installlogmode_extradebug"></a><dl> <dt><b>INSTALLLOGMODE_EXTRADEBUG</b></dt> </dl> </td> <td width="60%">
///                Sends extra debugging information, such as handle creation information, to the log file. <b>Windows 2000 and
///                Windows XP: </b>This feature is not supported. </td> </tr> <tr> <td width="40%"><a
///                id="INSTALLLOGMODE_WARNING"></a><a id="installlogmode_warning"></a><dl> <dt><b>INSTALLLOGMODE_WARNING</b></dt>
///                </dl> </td> <td width="60%"> Logs the warning messages. </td> </tr> <tr> <td width="40%"><a
///                id="INSTALLLOGMODE_USER"></a><a id="installlogmode_user"></a><dl> <dt><b>INSTALLLOGMODE_USER</b></dt> </dl> </td>
///                <td width="60%"> Logs the user requests. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_INFO"></a><a
///                id="installlogmode_info"></a><dl> <dt><b>INSTALLLOGMODE_INFO</b></dt> </dl> </td> <td width="60%"> Logs the
///                status messages that are not displayed. </td> </tr> <tr> <td width="40%"><a
///                id="INSTALLLOGMODE_RESOLVESOURCE"></a><a id="installlogmode_resolvesource"></a><dl>
///                <dt><b>INSTALLLOGMODE_RESOLVESOURCE</b></dt> </dl> </td> <td width="60%"> Request to determine a valid source
///                location. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_OUTOFDISKSPACE"></a><a
///                id="installlogmode_outofdiskspace"></a><dl> <dt><b>INSTALLLOGMODE_OUTOFDISKSPACE</b></dt> </dl> </td> <td
///                width="60%"> Indicates insufficient disk space. </td> </tr> <tr> <td width="40%"><a
///                id="INSTALLLOGMODE_ACTIONSTART"></a><a id="installlogmode_actionstart"></a><dl>
///                <dt><b>INSTALLLOGMODE_ACTIONSTART</b></dt> </dl> </td> <td width="60%"> Logs the start of new installation
///                actions. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_ACTIONDATA"></a><a
///                id="installlogmode_actiondata"></a><dl> <dt><b>INSTALLLOGMODE_ACTIONDATA</b></dt> </dl> </td> <td width="60%">
///                Logs the data record with the installation action. </td> </tr> <tr> <td width="40%"><a
///                id="INSTALLLOGMODE_COMMONDATA"></a><a id="installlogmode_commondata"></a><dl>
///                <dt><b>INSTALLLOGMODE_COMMONDATA</b></dt> </dl> </td> <td width="60%"> Logs the parameters for user-interface
///                initialization. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_PROPERTYDUMP"></a><a
///                id="installlogmode_propertydump"></a><dl> <dt><b>INSTALLLOGMODE_PROPERTYDUMP</b></dt> </dl> </td> <td
///                width="60%"> Logs the property values at termination. </td> </tr> <tr> <td width="40%"><a
///                id="INSTALLLOGMODE_VERBOSE"></a><a id="installlogmode_verbose"></a><dl> <dt><b>INSTALLLOGMODE_VERBOSE</b></dt>
///                </dl> </td> <td width="60%"> Logs the information in all the other log modes, except for
///                <b>INSTALLLOGMODE_EXTRADEBUG</b>. This sends large amounts of information to a log file not generally useful to
///                users. May be used for technical support. </td> </tr> <tr> <td width="40%"><a
///                id="INSTALLLOGMODE_LOGONLYONERROR"></a><a id="installlogmode_logonlyonerror"></a><dl>
///                <dt><b>INSTALLLOGMODE_LOGONLYONERROR</b></dt> </dl> </td> <td width="60%"> Logging information is collected but
///                is is less frequently saved to the log file. This can improve the performance of some installations, but may have
///                little benefit for large installations. The log file is removed when the installation succeeds. If the
///                installation fails, all logging information is saved to the log file. <b>Windows Installer 2.0: </b>This log mode
///                is not available. </td> </tr> </table>
///    szLogFile = Specifies the string that holds the full path to the log file. Entering a null disables logging, in which case
///                <i>dwlogmode</i> is ignored. If a path is supplied, then <i>dwlogmode</i> must not be zero.
///    dwLogAttributes = Specifies how frequently the log buffer is to be flushed. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                      <td width="40%"><a id="INSTALLLOGATTRIBUTES_APPEND"></a><a id="installlogattributes_append"></a><dl>
///                      <dt><b>INSTALLLOGATTRIBUTES_APPEND</b></dt> </dl> </td> <td width="60%"> If this value is set, the installer
///                      appends the existing log specified by <i>szLogFile</i>. If not set, any existing log specified by
///                      <i>szLogFile</i> is overwritten. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGATTRIBUTES_FLUSHEACHLINE"></a><a id="installlogattributes_flusheachline"></a><dl>
///                      <dt><b>INSTALLLOGATTRIBUTES_FLUSHEACHLINE</b></dt> </dl> </td> <td width="60%"> Forces the log buffer to be
///                      flushed after each line. If this value is not set, the installer flushes the log buffer after 20 lines by calling
///                      FlushFileBuffers. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid log mode was specified. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function
///    succeeded. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnableLogA(uint dwLogMode, const(char)* szLogFile, uint dwLogAttributes);

///The <b>MsiEnableLog</b> function sets the log mode for all subsequent installations that are initiated in the calling
///process.
///Params:
///    dwLogMode = Specifies the log mode. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_FATALEXIT"></a><a
///                id="installlogmode_fatalexit"></a><dl> <dt><b>INSTALLLOGMODE_FATALEXIT</b></dt> </dl> </td> <td width="60%"> Logs
///                out of memory or fatal exit information. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_ERROR"></a><a
///                id="installlogmode_error"></a><dl> <dt><b>INSTALLLOGMODE_ERROR</b></dt> </dl> </td> <td width="60%"> Logs the
///                error messages. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_EXTRADEBUG"></a><a
///                id="installlogmode_extradebug"></a><dl> <dt><b>INSTALLLOGMODE_EXTRADEBUG</b></dt> </dl> </td> <td width="60%">
///                Sends extra debugging information, such as handle creation information, to the log file. <b>Windows 2000 and
///                Windows XP: </b>This feature is not supported. </td> </tr> <tr> <td width="40%"><a
///                id="INSTALLLOGMODE_WARNING"></a><a id="installlogmode_warning"></a><dl> <dt><b>INSTALLLOGMODE_WARNING</b></dt>
///                </dl> </td> <td width="60%"> Logs the warning messages. </td> </tr> <tr> <td width="40%"><a
///                id="INSTALLLOGMODE_USER"></a><a id="installlogmode_user"></a><dl> <dt><b>INSTALLLOGMODE_USER</b></dt> </dl> </td>
///                <td width="60%"> Logs the user requests. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_INFO"></a><a
///                id="installlogmode_info"></a><dl> <dt><b>INSTALLLOGMODE_INFO</b></dt> </dl> </td> <td width="60%"> Logs the
///                status messages that are not displayed. </td> </tr> <tr> <td width="40%"><a
///                id="INSTALLLOGMODE_RESOLVESOURCE"></a><a id="installlogmode_resolvesource"></a><dl>
///                <dt><b>INSTALLLOGMODE_RESOLVESOURCE</b></dt> </dl> </td> <td width="60%"> Request to determine a valid source
///                location. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_OUTOFDISKSPACE"></a><a
///                id="installlogmode_outofdiskspace"></a><dl> <dt><b>INSTALLLOGMODE_OUTOFDISKSPACE</b></dt> </dl> </td> <td
///                width="60%"> Indicates insufficient disk space. </td> </tr> <tr> <td width="40%"><a
///                id="INSTALLLOGMODE_ACTIONSTART"></a><a id="installlogmode_actionstart"></a><dl>
///                <dt><b>INSTALLLOGMODE_ACTIONSTART</b></dt> </dl> </td> <td width="60%"> Logs the start of new installation
///                actions. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_ACTIONDATA"></a><a
///                id="installlogmode_actiondata"></a><dl> <dt><b>INSTALLLOGMODE_ACTIONDATA</b></dt> </dl> </td> <td width="60%">
///                Logs the data record with the installation action. </td> </tr> <tr> <td width="40%"><a
///                id="INSTALLLOGMODE_COMMONDATA"></a><a id="installlogmode_commondata"></a><dl>
///                <dt><b>INSTALLLOGMODE_COMMONDATA</b></dt> </dl> </td> <td width="60%"> Logs the parameters for user-interface
///                initialization. </td> </tr> <tr> <td width="40%"><a id="INSTALLLOGMODE_PROPERTYDUMP"></a><a
///                id="installlogmode_propertydump"></a><dl> <dt><b>INSTALLLOGMODE_PROPERTYDUMP</b></dt> </dl> </td> <td
///                width="60%"> Logs the property values at termination. </td> </tr> <tr> <td width="40%"><a
///                id="INSTALLLOGMODE_VERBOSE"></a><a id="installlogmode_verbose"></a><dl> <dt><b>INSTALLLOGMODE_VERBOSE</b></dt>
///                </dl> </td> <td width="60%"> Logs the information in all the other log modes, except for
///                <b>INSTALLLOGMODE_EXTRADEBUG</b>. This sends large amounts of information to a log file not generally useful to
///                users. May be used for technical support. </td> </tr> <tr> <td width="40%"><a
///                id="INSTALLLOGMODE_LOGONLYONERROR"></a><a id="installlogmode_logonlyonerror"></a><dl>
///                <dt><b>INSTALLLOGMODE_LOGONLYONERROR</b></dt> </dl> </td> <td width="60%"> Logging information is collected but
///                is is less frequently saved to the log file. This can improve the performance of some installations, but may have
///                little benefit for large installations. The log file is removed when the installation succeeds. If the
///                installation fails, all logging information is saved to the log file. <b>Windows Installer 2.0: </b>This log mode
///                is not available. </td> </tr> </table>
///    szLogFile = Specifies the string that holds the full path to the log file. Entering a null disables logging, in which case
///                <i>dwlogmode</i> is ignored. If a path is supplied, then <i>dwlogmode</i> must not be zero.
///    dwLogAttributes = Specifies how frequently the log buffer is to be flushed. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                      <td width="40%"><a id="INSTALLLOGATTRIBUTES_APPEND"></a><a id="installlogattributes_append"></a><dl>
///                      <dt><b>INSTALLLOGATTRIBUTES_APPEND</b></dt> </dl> </td> <td width="60%"> If this value is set, the installer
///                      appends the existing log specified by <i>szLogFile</i>. If not set, any existing log specified by
///                      <i>szLogFile</i> is overwritten. </td> </tr> <tr> <td width="40%"><a
///                      id="INSTALLLOGATTRIBUTES_FLUSHEACHLINE"></a><a id="installlogattributes_flusheachline"></a><dl>
///                      <dt><b>INSTALLLOGATTRIBUTES_FLUSHEACHLINE</b></dt> </dl> </td> <td width="60%"> Forces the log buffer to be
///                      flushed after each line. If this value is not set, the installer flushes the log buffer after 20 lines by calling
///                      FlushFileBuffers. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid log mode was specified. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function
///    succeeded. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnableLogW(uint dwLogMode, const(wchar)* szLogFile, uint dwLogAttributes);

///The <b>MsiQueryProductState</b> function returns the installed state for a product.
///Params:
///    szProduct = Specifies the product code that identifies the product to be queried.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_ABSENT</b></dt>
///    </dl> </td> <td width="60%"> The product is installed for a different user. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The product is advertised but not
///    installed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The product is installed for the current user. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_INVALIDARG</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td
///    width="60%"> The product is neither advertised or installed. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
INSTALLSTATE MsiQueryProductStateA(const(char)* szProduct);

///The <b>MsiQueryProductState</b> function returns the installed state for a product.
///Params:
///    szProduct = Specifies the product code that identifies the product to be queried.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_ABSENT</b></dt>
///    </dl> </td> <td width="60%"> The product is installed for a different user. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The product is advertised but not
///    installed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The product is installed for the current user. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_INVALIDARG</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td
///    width="60%"> The product is neither advertised or installed. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
INSTALLSTATE MsiQueryProductStateW(const(wchar)* szProduct);

///The <b>MsiGetProductInfo</b> function returns product information for published and installed products.
///Params:
///    szProduct = Specifies the product code for the product.
///    szAttribute = Specifies the property to be retrieved. The Required Properties are guaranteed to be available, but other
///                  properties are available only if that property is set. For more information, see Properties. The properties in
///                  the following list can be retrieved only from applications that are installed. <table> <tr> <th>Property</th>
///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_HELPLINK"></a><a
///                  id="installproperty_helplink"></a><dl> <dt><b>INSTALLPROPERTY_HELPLINK</b></dt> </dl> </td> <td width="60%">
///                  Support link. For more information, see the ARPHELPLINK property. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_HELPTELEPHONE"></a><a id="installproperty_helptelephone"></a><dl>
///                  <dt><b>INSTALLPROPERTY_HELPTELEPHONE</b></dt> </dl> </td> <td width="60%"> Support telephone. For more
///                  information, see the ARPHELPTELEPHONE property. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_INSTALLDATE"></a><a id="installproperty_installdate"></a><dl>
///                  <dt><b>INSTALLPROPERTY_INSTALLDATE</b></dt> </dl> </td> <td width="60%"> The last time this product received
///                  service. The value of this property is replaced each time a patch is applied or removed from the product or the
///                  /v Command-Line Option is used to repair the product. If the product has received no repairs or patches this
///                  property contains the time this product was installed on this computer. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_INSTALLEDLANGUAGE"></a><a id="installproperty_installedlanguage"></a><dl>
///                  <dt><b>INSTALLPROPERTY_INSTALLEDLANGUAGE</b></dt> </dl> </td> <td width="60%"> Installed language. <b>Windows
///                  Installer 4.5 and earlier: </b>Not supported. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_INSTALLEDPRODUCTNAME"></a><a id="installproperty_installedproductname"></a><dl>
///                  <dt><b>INSTALLPROPERTY_INSTALLEDPRODUCTNAME</b></dt> </dl> </td> <td width="60%"> Installed product name. For
///                  more information, see the ProductName property. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_INSTALLLOCATION"></a><a id="installproperty_installlocation"></a><dl>
///                  <dt><b>INSTALLPROPERTY_INSTALLLOCATION</b></dt> </dl> </td> <td width="60%"> Installation location. For more
///                  information, see the ARPINSTALLLOCATION property. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_INSTALLSOURCE"></a><a id="installproperty_installsource"></a><dl>
///                  <dt><b>INSTALLPROPERTY_INSTALLSOURCE</b></dt> </dl> </td> <td width="60%"> Installation source. For more
///                  information, see the SourceDir property. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_LOCALPACKAGE"></a><a id="installproperty_localpackage"></a><dl>
///                  <dt><b>INSTALLPROPERTY_LOCALPACKAGE</b></dt> </dl> </td> <td width="60%"> Local cached package. </td> </tr> <tr>
///                  <td width="40%"><a id="INSTALLPROPERTY_PUBLISHER"></a><a id="installproperty_publisher"></a><dl>
///                  <dt><b>INSTALLPROPERTY_PUBLISHER</b></dt> </dl> </td> <td width="60%"> Publisher. For more information, see the
///                  Manufacturer property. </td> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_URLINFOABOUT"></a><a
///                  id="installproperty_urlinfoabout"></a><dl> <dt><b>INSTALLPROPERTY_URLINFOABOUT</b></dt> </dl> </td> <td
///                  width="60%"> URL information. For more information, see the ARPURLINFOABOUT property. </td> </tr> <tr> <td
///                  width="40%"><a id="INSTALLPROPERTY_URLUPDATEINFO"></a><a id="installproperty_urlupdateinfo"></a><dl>
///                  <dt><b>INSTALLPROPERTY_URLUPDATEINFO</b></dt> </dl> </td> <td width="60%"> URL update information. For more
///                  information, see the ARPURLUPDATEINFO property. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_VERSIONMINOR"></a><a id="installproperty_versionminor"></a><dl>
///                  <dt><b>INSTALLPROPERTY_VERSIONMINOR</b></dt> </dl> </td> <td width="60%"> Minor product version derived from the
///                  ProductVersion property. </td> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_VERSIONMAJOR"></a><a
///                  id="installproperty_versionmajor"></a><dl> <dt><b>INSTALLPROPERTY_VERSIONMAJOR</b></dt> </dl> </td> <td
///                  width="60%"> Major product version derived from the ProductVersion property. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_VERSIONSTRING"></a><a id="installproperty_versionstring"></a><dl>
///                  <dt><b>INSTALLPROPERTY_VERSIONSTRING</b></dt> </dl> </td> <td width="60%"> Product version. For more information,
///                  see the ProductVersion property. </td> </tr> </table> To retrieve the product ID, registered owner, or registered
///                  company from applications that are installed, set <i>szProperty</i> to one of the following text string values.
///                  <table> <tr> <th>Value</th> <th>Description</th> </tr> <tr> <td>ProductID</td> <td>The product identifier for the
///                  product. For more information, see the ProductID property.</td> </tr> <tr> <td>RegCompany</td> <td>The company
///                  registered to use this product.</td> </tr> <tr> <td>RegOwner</td> <td>The owner registered to use this
///                  product.</td> </tr> </table> To retrieve the instance type of the product, set <i>szProperty</i> to the following
///                  value. This property is available for advertised or installed products. <table> <tr> <th>Value</th>
///                  <th>Description</th> </tr> <tr> <td>InstanceType</td> <td>A missing value or a value of 0 (zero) indicates a
///                  normal product installation. A value of 1 (one) indicates a product installed using a multiple instance transform
///                  and the MSINEWINSTANCE property. Available with the installer running Windows Server 2003 or Windows XP with SP1.
///                  For more information see, Installing Multiple Instances of Products and Patches.</td> </tr> </table> The
///                  advertised properties in the following list can be retrieved from applications that are advertised or installed.
///                  <table> <tr> <th>Property</th> <th>Description</th> </tr> <tr> <td>INSTALLPROPERTY_TRANSFORMS</td>
///                  <td>Transforms.</td> </tr> <tr> <td>INSTALLPROPERTY_LANGUAGE</td> <td>Product language.</td> </tr> <tr>
///                  <td>INSTALLPROPERTY_PRODUCTNAME</td> <td>Human readable product name. For more information, see the ProductName
///                  property.</td> </tr> <tr> <td>INSTALLPROPERTY_ASSIGNMENTTYPE</td> <td>Equals 0 (zero) if the product is
///                  advertised or installed per-user. Equals 1 (one) if the product is advertised or installed per-machine for all
///                  users. </td> </tr> <tr> <td>INSTALLPROPERTY_PACKAGECODE</td> <td>Identifier of the package this product was
///                  installed from. For more information, see Package Codes.</td> </tr> <tr> <td>INSTALLPROPERTY_VERSION</td>
///                  <td>Product version derived from the ProductVersion property.</td> </tr> <tr>
///                  <td>INSTALLPROPERTY_PRODUCTICON</td> <td>Primary icon for the package. For more information, see the
///                  ARPPRODUCTICON property.</td> </tr> <tr> <td>INSTALLPROPERTY_PACKAGENAME</td> <td>Name of the original
///                  installation package.</td> </tr> <tr> <td>INSTALLPROPERTY_AUTHORIZED_LUA_APP</td> <td>A value of one (1)
///                  indicates a product that can be serviced by non-administrators using User Account Control (UAC) Patching. A
///                  missing value or a value of 0 (zero) indicates that least-privilege patching is not enabled. Available in Windows
///                  Installer 3.0 or later.</td> </tr> </table>
///    lpValueBuf = Pointer to a buffer that receives the property value. This parameter can be null.
///    pcchValueBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpValueBuf</i>
///                   parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                   the buffer passed in is too small, the count returned does not include the terminating null character. If
///                   <i>lpValueBuf</i> is null, <i>pcchValueBuf</i> can be null. In this case, the function checks that the property
///                   is registered correctly with the product.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt>
///    </dl> </td> <td width="60%"> A buffer is too small to hold the requested data. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product is
///    unadvertised or uninstalled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PROPERTY</b></dt> </dl>
///    </td> <td width="60%"> The property is unrecognized. <div class="alert"><b>Note</b> The MsiGetProductInfo
///    function returns ERROR_UNKNOWN_PROPERTY if the application being queried is advertised and not installed.</div>
///    <div> </div> </td> </tr> </table>
///    
@DllImport("msi")
uint MsiGetProductInfoA(const(char)* szProduct, const(char)* szAttribute, const(char)* lpValueBuf, 
                        uint* pcchValueBuf);

///The <b>MsiGetProductInfo</b> function returns product information for published and installed products.
///Params:
///    szProduct = Specifies the product code for the product.
///    szAttribute = Specifies the property to be retrieved. The Required Properties are guaranteed to be available, but other
///                  properties are available only if that property is set. For more information, see Properties. The properties in
///                  the following list can be retrieved only from applications that are installed. <table> <tr> <th>Property</th>
///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_HELPLINK"></a><a
///                  id="installproperty_helplink"></a><dl> <dt><b>INSTALLPROPERTY_HELPLINK</b></dt> </dl> </td> <td width="60%">
///                  Support link. For more information, see the ARPHELPLINK property. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_HELPTELEPHONE"></a><a id="installproperty_helptelephone"></a><dl>
///                  <dt><b>INSTALLPROPERTY_HELPTELEPHONE</b></dt> </dl> </td> <td width="60%"> Support telephone. For more
///                  information, see the ARPHELPTELEPHONE property. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_INSTALLDATE"></a><a id="installproperty_installdate"></a><dl>
///                  <dt><b>INSTALLPROPERTY_INSTALLDATE</b></dt> </dl> </td> <td width="60%"> The last time this product received
///                  service. The value of this property is replaced each time a patch is applied or removed from the product or the
///                  /v Command-Line Option is used to repair the product. If the product has received no repairs or patches this
///                  property contains the time this product was installed on this computer. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_INSTALLEDLANGUAGE"></a><a id="installproperty_installedlanguage"></a><dl>
///                  <dt><b>INSTALLPROPERTY_INSTALLEDLANGUAGE</b></dt> </dl> </td> <td width="60%"> Installed language. <b>Windows
///                  Installer 4.5 and earlier: </b>Not supported. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_INSTALLEDPRODUCTNAME"></a><a id="installproperty_installedproductname"></a><dl>
///                  <dt><b>INSTALLPROPERTY_INSTALLEDPRODUCTNAME</b></dt> </dl> </td> <td width="60%"> Installed product name. For
///                  more information, see the ProductName property. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_INSTALLLOCATION"></a><a id="installproperty_installlocation"></a><dl>
///                  <dt><b>INSTALLPROPERTY_INSTALLLOCATION</b></dt> </dl> </td> <td width="60%"> Installation location. For more
///                  information, see the ARPINSTALLLOCATION property. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_INSTALLSOURCE"></a><a id="installproperty_installsource"></a><dl>
///                  <dt><b>INSTALLPROPERTY_INSTALLSOURCE</b></dt> </dl> </td> <td width="60%"> Installation source. For more
///                  information, see the SourceDir property. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_LOCALPACKAGE"></a><a id="installproperty_localpackage"></a><dl>
///                  <dt><b>INSTALLPROPERTY_LOCALPACKAGE</b></dt> </dl> </td> <td width="60%"> Local cached package. </td> </tr> <tr>
///                  <td width="40%"><a id="INSTALLPROPERTY_PUBLISHER"></a><a id="installproperty_publisher"></a><dl>
///                  <dt><b>INSTALLPROPERTY_PUBLISHER</b></dt> </dl> </td> <td width="60%"> Publisher. For more information, see the
///                  Manufacturer property. </td> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_URLINFOABOUT"></a><a
///                  id="installproperty_urlinfoabout"></a><dl> <dt><b>INSTALLPROPERTY_URLINFOABOUT</b></dt> </dl> </td> <td
///                  width="60%"> URL information. For more information, see the ARPURLINFOABOUT property. </td> </tr> <tr> <td
///                  width="40%"><a id="INSTALLPROPERTY_URLUPDATEINFO"></a><a id="installproperty_urlupdateinfo"></a><dl>
///                  <dt><b>INSTALLPROPERTY_URLUPDATEINFO</b></dt> </dl> </td> <td width="60%"> URL update information. For more
///                  information, see the ARPURLUPDATEINFO property. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_VERSIONMINOR"></a><a id="installproperty_versionminor"></a><dl>
///                  <dt><b>INSTALLPROPERTY_VERSIONMINOR</b></dt> </dl> </td> <td width="60%"> Minor product version derived from the
///                  ProductVersion property. </td> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_VERSIONMAJOR"></a><a
///                  id="installproperty_versionmajor"></a><dl> <dt><b>INSTALLPROPERTY_VERSIONMAJOR</b></dt> </dl> </td> <td
///                  width="60%"> Major product version derived from the ProductVersion property. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLPROPERTY_VERSIONSTRING"></a><a id="installproperty_versionstring"></a><dl>
///                  <dt><b>INSTALLPROPERTY_VERSIONSTRING</b></dt> </dl> </td> <td width="60%"> Product version. For more information,
///                  see the ProductVersion property. </td> </tr> </table> To retrieve the product ID, registered owner, or registered
///                  company from applications that are installed, set <i>szProperty</i> to one of the following text string values.
///                  <table> <tr> <th>Value</th> <th>Description</th> </tr> <tr> <td>ProductID</td> <td>The product identifier for the
///                  product. For more information, see the ProductID property.</td> </tr> <tr> <td>RegCompany</td> <td>The company
///                  registered to use this product.</td> </tr> <tr> <td>RegOwner</td> <td>The owner registered to use this
///                  product.</td> </tr> </table> To retrieve the instance type of the product, set <i>szProperty</i> to the following
///                  value. This property is available for advertised or installed products. <table> <tr> <th>Value</th>
///                  <th>Description</th> </tr> <tr> <td>InstanceType</td> <td>A missing value or a value of 0 (zero) indicates a
///                  normal product installation. A value of 1 (one) indicates a product installed using a multiple instance transform
///                  and the MSINEWINSTANCE property. Available with the installer running Windows Server 2003 or Windows XP with SP1.
///                  For more information see, Installing Multiple Instances of Products and Patches.</td> </tr> </table> The
///                  advertised properties in the following list can be retrieved from applications that are advertised or installed.
///                  <table> <tr> <th>Property</th> <th>Description</th> </tr> <tr> <td>INSTALLPROPERTY_TRANSFORMS</td>
///                  <td>Transforms.</td> </tr> <tr> <td>INSTALLPROPERTY_LANGUAGE</td> <td>Product language.</td> </tr> <tr>
///                  <td>INSTALLPROPERTY_PRODUCTNAME</td> <td>Human readable product name. For more information, see the ProductName
///                  property.</td> </tr> <tr> <td>INSTALLPROPERTY_ASSIGNMENTTYPE</td> <td>Equals 0 (zero) if the product is
///                  advertised or installed per-user. Equals 1 (one) if the product is advertised or installed per-machine for all
///                  users. </td> </tr> <tr> <td>INSTALLPROPERTY_PACKAGECODE</td> <td>Identifier of the package this product was
///                  installed from. For more information, see Package Codes.</td> </tr> <tr> <td>INSTALLPROPERTY_VERSION</td>
///                  <td>Product version derived from the ProductVersion property.</td> </tr> <tr>
///                  <td>INSTALLPROPERTY_PRODUCTICON</td> <td>Primary icon for the package. For more information, see the
///                  ARPPRODUCTICON property.</td> </tr> <tr> <td>INSTALLPROPERTY_PACKAGENAME</td> <td>Name of the original
///                  installation package.</td> </tr> <tr> <td>INSTALLPROPERTY_AUTHORIZED_LUA_APP</td> <td>A value of one (1)
///                  indicates a product that can be serviced by non-administrators using User Account Control (UAC) Patching. A
///                  missing value or a value of 0 (zero) indicates that least-privilege patching is not enabled. Available in Windows
///                  Installer 3.0 or later.</td> </tr> </table>
///    lpValueBuf = Pointer to a buffer that receives the property value. This parameter can be null.
///    pcchValueBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpValueBuf</i>
///                   parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                   the buffer passed in is too small, the count returned does not include the terminating null character. If
///                   <i>lpValueBuf</i> is null, <i>pcchValueBuf</i> can be null. In this case, the function checks that the property
///                   is registered correctly with the product.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt>
///    </dl> </td> <td width="60%"> A buffer is too small to hold the requested data. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product is
///    unadvertised or uninstalled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PROPERTY</b></dt> </dl>
///    </td> <td width="60%"> The property is unrecognized. <div class="alert"><b>Note</b> The MsiGetProductInfo
///    function returns ERROR_UNKNOWN_PROPERTY if the application being queried is advertised and not installed.</div>
///    <div> </div> </td> </tr> </table>
///    
@DllImport("msi")
uint MsiGetProductInfoW(const(wchar)* szProduct, const(wchar)* szAttribute, const(wchar)* lpValueBuf, 
                        uint* pcchValueBuf);

///The <b>MsiGetProductInfoEx</b> function returns product information for advertised and installed products. This
///function can retrieve information about an instance of a product that is installed under a user account other than
///the current user. The calling process must have administrative privileges for a user who is different from the
///current user. The <b>MsiGetProductInfoEx</b> function cannot query an instance of a product that is advertised under
///a per-user-unmanaged context for a user account other than the current user. This function is an extension of the
///MsiGetProductInfo function.
///Params:
///    szProductCode = The ProductCode GUID of the product instance that is being queried.
///    szUserSid = The security identifier (SID) of the account under which the instance of the product that is being queried
///                exists. A <b>NULL</b> specifies the current user SID. <table> <tr> <th>SID</th> <th>Meaning</th> </tr> <tr> <td
///                width="40%"><a id="NULL"></a><a id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> The
///                currently logged-on user. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a
///                id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> The enumeration for a specific user
///                in the system. An example of user SID is "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table>
///                <div class="alert"><b>Note</b> The special SID string "S-1-5-18" (system) cannot be used to enumerate products
///                installed as per-machine. If <i>dwContext</i> is "MSIINSTALLCONTEXT_MACHINE", <i>szUserSid</i> must be
///                <b>NULL</b>.</div> <div> </div>
///    dwContext = The installation context of the product instance that is being queried. <table> <tr> <th>Name</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERMANAGED"></a><a
///                id="msiinstallcontext_usermanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td
///                width="60%"> Retrieves the product property for the perusermanaged instance of the product. </td> </tr>
///                <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td width="60%"> Retrieves the product property for
///                the peruserunmanaged instance of the product. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> Retrieves the product property for the
///                per-machine instance of the product. </td> </tr> </table>
///    szProperty = Property being queried. The property to be retrieved. The properties in the following table can only be retrieved
///                 from applications that are already installed. All required properties are guaranteed to be available, but other
///                 properties are available only if the property is set. For more information, see Required Properties and
///                 Properties. <table> <tr> <th>Property</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_PRODUCTSTATE"></a><a id="installproperty_productstate"></a><dl>
///                 <dt><b>INSTALLPROPERTY_PRODUCTSTATE</b></dt> </dl> </td> <td width="60%"> The state of the product returned in
///                 string form as "1" for advertised and "5" for installed. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_HELPLINK"></a><a id="installproperty_helplink"></a><dl>
///                 <dt><b>INSTALLPROPERTY_HELPLINK</b></dt> </dl> </td> <td width="60%"> The support link. For more information, see
///                 the ARPHELPLINK property. </td> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_HELPTELEPHONE"></a><a
///                 id="installproperty_helptelephone"></a><dl> <dt><b>INSTALLPROPERTY_HELPTELEPHONE</b></dt> </dl> </td> <td
///                 width="60%"> The support telephone. For more information, see the ARPHELPTELEPHONE property. </td> </tr> <tr> <td
///                 width="40%"><a id="INSTALLPROPERTY_INSTALLDATE"></a><a id="installproperty_installdate"></a><dl>
///                 <dt><b>INSTALLPROPERTY_INSTALLDATE</b></dt> </dl> </td> <td width="60%"> The last time this product received
///                 service. The value of this property is replaced each time a patch is applied or removed from the product or the
///                 /v Command-Line Option is used to repair the product. If the product has received no repairs or patches this
///                 property contains the time this product was installed on this computer. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_INSTALLEDLANGUAGE"></a><a id="installproperty_installedlanguage"></a><dl>
///                 <dt><b>INSTALLPROPERTY_INSTALLEDLANGUAGE</b></dt> </dl> </td> <td width="60%"> Installed language. <b>Windows
///                 Installer 4.5 and earlier: </b>Not supported. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_INSTALLEDPRODUCTNAME"></a><a id="installproperty_installedproductname"></a><dl>
///                 <dt><b>INSTALLPROPERTY_INSTALLEDPRODUCTNAME</b></dt> </dl> </td> <td width="60%"> The installed product name. For
///                 more information, see the ProductName property. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_INSTALLLOCATION"></a><a id="installproperty_installlocation"></a><dl>
///                 <dt><b>INSTALLPROPERTY_INSTALLLOCATION</b></dt> </dl> </td> <td width="60%"> The installation location. For more
///                 information, see the ARPINSTALLLOCATION property. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_INSTALLSOURCE"></a><a id="installproperty_installsource"></a><dl>
///                 <dt><b>INSTALLPROPERTY_INSTALLSOURCE</b></dt> </dl> </td> <td width="60%"> The installation source. For more
///                 information, see the SourceDir property. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_LOCALPACKAGE"></a><a id="installproperty_localpackage"></a><dl>
///                 <dt><b>INSTALLPROPERTY_LOCALPACKAGE</b></dt> </dl> </td> <td width="60%"> The local cached package. </td> </tr>
///                 <tr> <td width="40%"><a id="INSTALLPROPERTY_PUBLISHER"></a><a id="installproperty_publisher"></a><dl>
///                 <dt><b>INSTALLPROPERTY_PUBLISHER</b></dt> </dl> </td> <td width="60%"> The publisher. For more information, see
///                 the Manufacturer property. </td> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_URLINFOABOUT"></a><a
///                 id="installproperty_urlinfoabout"></a><dl> <dt><b>INSTALLPROPERTY_URLINFOABOUT</b></dt> </dl> </td> <td
///                 width="60%"> URL information. For more information, see the ARPURLINFOABOUT property. </td> </tr> <tr> <td
///                 width="40%"><a id="INSTALLPROPERTY_URLUPDATEINFO"></a><a id="installproperty_urlupdateinfo"></a><dl>
///                 <dt><b>INSTALLPROPERTY_URLUPDATEINFO</b></dt> </dl> </td> <td width="60%"> The URL update information. For more
///                 information, see the ARPURLUPDATEINFO property. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_VERSIONMINOR"></a><a id="installproperty_versionminor"></a><dl>
///                 <dt><b>INSTALLPROPERTY_VERSIONMINOR</b></dt> </dl> </td> <td width="60%"> The minor product version that is
///                 derived from the ProductVersion property. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_VERSIONMAJOR"></a><a id="installproperty_versionmajor"></a><dl>
///                 <dt><b>INSTALLPROPERTY_VERSIONMAJOR</b></dt> </dl> </td> <td width="60%"> The major product version that is
///                 derived from the ProductVersion property. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_VERSIONSTRING"></a><a id="installproperty_versionstring"></a><dl>
///                 <dt><b>INSTALLPROPERTY_VERSIONSTRING</b></dt> </dl> </td> <td width="60%"> The product version. For more
///                 information, see the ProductVersion property. </td> </tr> </table> To retrieve the product ID, registered owner,
///                 or registered company from applications that are installed, set <i>szProperty</i> to one of the following text
///                 string values. <table> <tr> <th>Value</th> <th>Description</th> </tr> <tr> <td>ProductID</td> <td>The product
///                 identifier. For more information, see the ProductID property.</td> </tr> <tr> <td>RegCompany</td> <td>The company
///                 that is registered to use the product.</td> </tr> <tr> <td>RegOwner</td> <td>The owner who is registered to use
///                 the product.</td> </tr> </table> To retrieve the instance type of the product, set <i>szProperty</i> to the
///                 following value. This property is available for advertised or installed products. <table> <tr> <th>Value</th>
///                 <th>Description</th> </tr> <tr> <td>InstanceType</td> <td>A missing value or a value of 0 (zero) indicates a
///                 normal product installation. A value of one (1) indicates a product installed using a multiple instance transform
///                 and the MSINEWINSTANCE property. For more information, see Installing Multiple Instances of Products and
///                 Patches.</td> </tr> </table> The properties in the following table can be retrieved from applications that are
///                 advertised or installed. These properties cannot be retrieved for product instances that are installed under a
///                 per-user-unmanaged context for user accounts other than current user account. <table> <tr> <th>Property</th>
///                 <th>Description</th> </tr> <tr> <td><b>INSTALLPROPERTY_TRANSFORMS</b></td> <td>Transforms.</td> </tr> <tr>
///                 <td><b>INSTALLPROPERTY_LANGUAGE</b></td> <td>Product language.</td> </tr> <tr>
///                 <td><b>INSTALLPROPERTY_PRODUCTNAME</b></td> <td>Human readable product name. For more information, see the
///                 ProductName property.</td> </tr> <tr> <td><b>INSTALLPROPERTY_ASSIGNMENTTYPE</b></td> <td>Equals 0 (zero) if the
///                 product is advertised or installed per-user. Equals one (1) if the product is advertised or installed
///                 per-computer for all users. </td> </tr> <tr> <td><b>INSTALLPROPERTY_PACKAGECODE</b></td> <td>Identifier of the
///                 package that a product is installed from. For more information, see the Package Codes property.</td> </tr> <tr>
///                 <td><b>INSTALLPROPERTY_VERSION</b></td> <td>Product version derived from the ProductVersion property.</td> </tr>
///                 <tr> <td><b>INSTALLPROPERTY_PRODUCTICON</b></td> <td>Primary icon for the package. For more information, see the
///                 ARPPRODUCTICON property.</td> </tr> <tr> <td><b>INSTALLPROPERTY_PACKAGENAME</b></td> <td>Name of the original
///                 installation package.</td> </tr> <tr> <td><b>INSTALLPROPERTY_AUTHORIZED_LUA_APP</b></td> <td>A value of one (1)
///                 indicates a product that can be serviced by non-administrators using User Account Control (UAC) Patching. A
///                 missing value or a value of 0 (zero) indicates that least-privilege patching is not enabled. Available in Windows
///                 Installer 3.0 or later.</td> </tr> </table>
///    szValue = A pointer to a buffer that receives the property value. This buffer should be large enough to contain the
///              information. If the buffer is too small, the function returns <b>ERROR_MORE_DATA</b> and sets *<i>pcchValue</i>
///              to the number of <b>TCHAR</b> in the value, not including the terminating NULL character. If <i>lpValue</i> is
///              set to <b>NULL</b> and <i>pcchValue</i> is set to a valid pointer, the function returns <b>ERROR_SUCCESS</b> and
///              sets *<i>pcchValue</i> to the number of <b>TCHAR</b> in the value, not including the terminating NULL character.
///              The function can then be called again to retrieve the value, with <i>lpValue</i> buffer large enough to contain
///              *<i>pcchValue</i> + 1 characters. If <i>lpValue</i> and <i>pcchValue</i> are both set to <b>NULL</b>, the
///              function returns <b>ERROR_SUCCESS</b> if the value exists, without retrieving the value.
///    pcchValue = A pointer to a variable that specifies the number of <b>TCHAR</b> in the <i>lpValue</i> buffer. When the function
///                returns, this parameter is set to the size of the requested value whether or not the function copies the value
///                into the specified buffer. The size is returned as the number of <b>TCHAR</b> in the requested value, not
///                including the terminating null character. This parameter can be set to <b>NULL</b> only if <i>lpValue</i> is also
///                <b>NULL</b>. Otherwise, the function returns <b>ERROR_INVALID_PARAMETER</b>.
///Returns:
///    The <b>MsiGetProductInfoEx</b> function returns the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The calling process must have administrative privileges to get information for a product installed
///    for a user other than the current user. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter is passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl>
///    </td> <td width="60%"> A buffer is too small to hold the requested data. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product is
///    unadvertised or uninstalled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PROPERTY</b></dt> </dl>
///    </td> <td width="60%"> The property is unrecognized. <div class="alert"><b>Note</b> The MsiGetProductInfo
///    function returns <b>ERROR_UNKNOWN_PROPERTY</b> if the application being queried is advertised and not
///    installed.</div> <div> </div> </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl>
///    </td> <td width="60%"> An unexpected internal failure. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiGetProductInfoExA(const(char)* szProductCode, const(char)* szUserSid, MSIINSTALLCONTEXT dwContext, 
                          const(char)* szProperty, const(char)* szValue, uint* pcchValue);

///The <b>MsiGetProductInfoEx</b> function returns product information for advertised and installed products. This
///function can retrieve information about an instance of a product that is installed under a user account other than
///the current user. The calling process must have administrative privileges for a user who is different from the
///current user. The <b>MsiGetProductInfoEx</b> function cannot query an instance of a product that is advertised under
///a per-user-unmanaged context for a user account other than the current user. This function is an extension of the
///MsiGetProductInfo function.
///Params:
///    szProductCode = The ProductCode GUID of the product instance that is being queried.
///    szUserSid = The security identifier (SID) of the account under which the instance of the product that is being queried
///                exists. A <b>NULL</b> specifies the current user SID. <table> <tr> <th>SID</th> <th>Meaning</th> </tr> <tr> <td
///                width="40%"><a id="NULL"></a><a id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> The
///                currently logged-on user. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a
///                id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> The enumeration for a specific user
///                in the system. An example of user SID is "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table>
///                <div class="alert"><b>Note</b> The special SID string "S-1-5-18" (system) cannot be used to enumerate products
///                installed as per-machine. If <i>dwContext</i> is "MSIINSTALLCONTEXT_MACHINE", <i>szUserSid</i> must be
///                <b>NULL</b>.</div> <div> </div>
///    dwContext = The installation context of the product instance that is being queried. <table> <tr> <th>Name</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERMANAGED"></a><a
///                id="msiinstallcontext_usermanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td
///                width="60%"> Retrieves the product property for the perusermanaged instance of the product. </td> </tr>
///                <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td width="60%"> Retrieves the product property for
///                the peruserunmanaged instance of the product. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> Retrieves the product property for the
///                per-machine instance of the product. </td> </tr> </table>
///    szProperty = Property being queried. The property to be retrieved. The properties in the following table can only be retrieved
///                 from applications that are already installed. All required properties are guaranteed to be available, but other
///                 properties are available only if the property is set. For more information, see Required Properties and
///                 Properties. <table> <tr> <th>Property</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_PRODUCTSTATE"></a><a id="installproperty_productstate"></a><dl>
///                 <dt><b>INSTALLPROPERTY_PRODUCTSTATE</b></dt> </dl> </td> <td width="60%"> The state of the product returned in
///                 string form as "1" for advertised and "5" for installed. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_HELPLINK"></a><a id="installproperty_helplink"></a><dl>
///                 <dt><b>INSTALLPROPERTY_HELPLINK</b></dt> </dl> </td> <td width="60%"> The support link. For more information, see
///                 the ARPHELPLINK property. </td> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_HELPTELEPHONE"></a><a
///                 id="installproperty_helptelephone"></a><dl> <dt><b>INSTALLPROPERTY_HELPTELEPHONE</b></dt> </dl> </td> <td
///                 width="60%"> The support telephone. For more information, see the ARPHELPTELEPHONE property. </td> </tr> <tr> <td
///                 width="40%"><a id="INSTALLPROPERTY_INSTALLDATE"></a><a id="installproperty_installdate"></a><dl>
///                 <dt><b>INSTALLPROPERTY_INSTALLDATE</b></dt> </dl> </td> <td width="60%"> The last time this product received
///                 service. The value of this property is replaced each time a patch is applied or removed from the product or the
///                 /v Command-Line Option is used to repair the product. If the product has received no repairs or patches this
///                 property contains the time this product was installed on this computer. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_INSTALLEDLANGUAGE"></a><a id="installproperty_installedlanguage"></a><dl>
///                 <dt><b>INSTALLPROPERTY_INSTALLEDLANGUAGE</b></dt> </dl> </td> <td width="60%"> Installed language. <b>Windows
///                 Installer 4.5 and earlier: </b>Not supported. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_INSTALLEDPRODUCTNAME"></a><a id="installproperty_installedproductname"></a><dl>
///                 <dt><b>INSTALLPROPERTY_INSTALLEDPRODUCTNAME</b></dt> </dl> </td> <td width="60%"> The installed product name. For
///                 more information, see the ProductName property. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_INSTALLLOCATION"></a><a id="installproperty_installlocation"></a><dl>
///                 <dt><b>INSTALLPROPERTY_INSTALLLOCATION</b></dt> </dl> </td> <td width="60%"> The installation location. For more
///                 information, see the ARPINSTALLLOCATION property. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_INSTALLSOURCE"></a><a id="installproperty_installsource"></a><dl>
///                 <dt><b>INSTALLPROPERTY_INSTALLSOURCE</b></dt> </dl> </td> <td width="60%"> The installation source. For more
///                 information, see the SourceDir property. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_LOCALPACKAGE"></a><a id="installproperty_localpackage"></a><dl>
///                 <dt><b>INSTALLPROPERTY_LOCALPACKAGE</b></dt> </dl> </td> <td width="60%"> The local cached package. </td> </tr>
///                 <tr> <td width="40%"><a id="INSTALLPROPERTY_PUBLISHER"></a><a id="installproperty_publisher"></a><dl>
///                 <dt><b>INSTALLPROPERTY_PUBLISHER</b></dt> </dl> </td> <td width="60%"> The publisher. For more information, see
///                 the Manufacturer property. </td> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_URLINFOABOUT"></a><a
///                 id="installproperty_urlinfoabout"></a><dl> <dt><b>INSTALLPROPERTY_URLINFOABOUT</b></dt> </dl> </td> <td
///                 width="60%"> URL information. For more information, see the ARPURLINFOABOUT property. </td> </tr> <tr> <td
///                 width="40%"><a id="INSTALLPROPERTY_URLUPDATEINFO"></a><a id="installproperty_urlupdateinfo"></a><dl>
///                 <dt><b>INSTALLPROPERTY_URLUPDATEINFO</b></dt> </dl> </td> <td width="60%"> The URL update information. For more
///                 information, see the ARPURLUPDATEINFO property. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_VERSIONMINOR"></a><a id="installproperty_versionminor"></a><dl>
///                 <dt><b>INSTALLPROPERTY_VERSIONMINOR</b></dt> </dl> </td> <td width="60%"> The minor product version that is
///                 derived from the ProductVersion property. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_VERSIONMAJOR"></a><a id="installproperty_versionmajor"></a><dl>
///                 <dt><b>INSTALLPROPERTY_VERSIONMAJOR</b></dt> </dl> </td> <td width="60%"> The major product version that is
///                 derived from the ProductVersion property. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_VERSIONSTRING"></a><a id="installproperty_versionstring"></a><dl>
///                 <dt><b>INSTALLPROPERTY_VERSIONSTRING</b></dt> </dl> </td> <td width="60%"> The product version. For more
///                 information, see the ProductVersion property. </td> </tr> </table> To retrieve the product ID, registered owner,
///                 or registered company from applications that are installed, set <i>szProperty</i> to one of the following text
///                 string values. <table> <tr> <th>Value</th> <th>Description</th> </tr> <tr> <td>ProductID</td> <td>The product
///                 identifier. For more information, see the ProductID property.</td> </tr> <tr> <td>RegCompany</td> <td>The company
///                 that is registered to use the product.</td> </tr> <tr> <td>RegOwner</td> <td>The owner who is registered to use
///                 the product.</td> </tr> </table> To retrieve the instance type of the product, set <i>szProperty</i> to the
///                 following value. This property is available for advertised or installed products. <table> <tr> <th>Value</th>
///                 <th>Description</th> </tr> <tr> <td>InstanceType</td> <td>A missing value or a value of 0 (zero) indicates a
///                 normal product installation. A value of one (1) indicates a product installed using a multiple instance transform
///                 and the MSINEWINSTANCE property. For more information, see Installing Multiple Instances of Products and
///                 Patches.</td> </tr> </table> The properties in the following table can be retrieved from applications that are
///                 advertised or installed. These properties cannot be retrieved for product instances that are installed under a
///                 per-user-unmanaged context for user accounts other than current user account. <table> <tr> <th>Property</th>
///                 <th>Description</th> </tr> <tr> <td><b>INSTALLPROPERTY_TRANSFORMS</b></td> <td>Transforms.</td> </tr> <tr>
///                 <td><b>INSTALLPROPERTY_LANGUAGE</b></td> <td>Product language.</td> </tr> <tr>
///                 <td><b>INSTALLPROPERTY_PRODUCTNAME</b></td> <td>Human readable product name. For more information, see the
///                 ProductName property.</td> </tr> <tr> <td><b>INSTALLPROPERTY_ASSIGNMENTTYPE</b></td> <td>Equals 0 (zero) if the
///                 product is advertised or installed per-user. Equals one (1) if the product is advertised or installed
///                 per-computer for all users. </td> </tr> <tr> <td><b>INSTALLPROPERTY_PACKAGECODE</b></td> <td>Identifier of the
///                 package that a product is installed from. For more information, see the Package Codes property.</td> </tr> <tr>
///                 <td><b>INSTALLPROPERTY_VERSION</b></td> <td>Product version derived from the ProductVersion property.</td> </tr>
///                 <tr> <td><b>INSTALLPROPERTY_PRODUCTICON</b></td> <td>Primary icon for the package. For more information, see the
///                 ARPPRODUCTICON property.</td> </tr> <tr> <td><b>INSTALLPROPERTY_PACKAGENAME</b></td> <td>Name of the original
///                 installation package.</td> </tr> <tr> <td><b>INSTALLPROPERTY_AUTHORIZED_LUA_APP</b></td> <td>A value of one (1)
///                 indicates a product that can be serviced by non-administrators using User Account Control (UAC) Patching. A
///                 missing value or a value of 0 (zero) indicates that least-privilege patching is not enabled. Available in Windows
///                 Installer 3.0 or later.</td> </tr> </table>
///    szValue = A pointer to a buffer that receives the property value. This buffer should be large enough to contain the
///              information. If the buffer is too small, the function returns <b>ERROR_MORE_DATA</b> and sets *<i>pcchValue</i>
///              to the number of <b>TCHAR</b> in the value, not including the terminating NULL character. If <i>lpValue</i> is
///              set to <b>NULL</b> and <i>pcchValue</i> is set to a valid pointer, the function returns <b>ERROR_SUCCESS</b> and
///              sets *<i>pcchValue</i> to the number of <b>TCHAR</b> in the value, not including the terminating NULL character.
///              The function can then be called again to retrieve the value, with <i>lpValue</i> buffer large enough to contain
///              *<i>pcchValue</i> + 1 characters. If <i>lpValue</i> and <i>pcchValue</i> are both set to <b>NULL</b>, the
///              function returns <b>ERROR_SUCCESS</b> if the value exists, without retrieving the value.
///    pcchValue = A pointer to a variable that specifies the number of <b>TCHAR</b> in the <i>lpValue</i> buffer. When the function
///                returns, this parameter is set to the size of the requested value whether or not the function copies the value
///                into the specified buffer. The size is returned as the number of <b>TCHAR</b> in the requested value, not
///                including the terminating null character. This parameter can be set to <b>NULL</b> only if <i>lpValue</i> is also
///                <b>NULL</b>. Otherwise, the function returns <b>ERROR_INVALID_PARAMETER</b>.
///Returns:
///    The <b>MsiGetProductInfoEx</b> function returns the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The calling process must have administrative privileges to get information for a product installed
///    for a user other than the current user. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter is passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl>
///    </td> <td width="60%"> A buffer is too small to hold the requested data. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product is
///    unadvertised or uninstalled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PROPERTY</b></dt> </dl>
///    </td> <td width="60%"> The property is unrecognized. <div class="alert"><b>Note</b> The MsiGetProductInfo
///    function returns <b>ERROR_UNKNOWN_PROPERTY</b> if the application being queried is advertised and not
///    installed.</div> <div> </div> </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl>
///    </td> <td width="60%"> An unexpected internal failure. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiGetProductInfoExW(const(wchar)* szProductCode, const(wchar)* szUserSid, MSIINSTALLCONTEXT dwContext, 
                          const(wchar)* szProperty, const(wchar)* szValue, uint* pcchValue);

///The <b>MsiInstallProduct</b> function installs or uninstalls a product.
///Params:
///    szPackagePath = A null-terminated string that specifies the path to the location of the Windows Installer package. The string
///                    value can contain a URL (e.g. <code>http://packageLocation/package/package.msi</code>), a network path (e.g.
///                    \\packageLocation\package.msi), a file path (e.g. file://packageLocation/package.msi), or a local path (e.g.
///                    D:\packageLocation\package.msi).
///    szCommandLine = A null-terminated string that specifies the command line property settings. This should be a list of the format
///                    <i>Property=Setting Property=Setting</i>. For more information, see About Properties. To perform an
///                    administrative installation, include ACTION=ADMIN in <i>szCommandLine</i>. For more information, see the ACTION
///                    property.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completes successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An
///    error relating to an action</b></dt> </dl> </td> <td width="60%"> For more information, see Error Codes. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization Error</b></dt> </dl> </td> <td width="60%"> An error that
///    relates to initialization occurred. </td> </tr> </table> For more information, see Displayed Error Messages.
///    
@DllImport("msi")
uint MsiInstallProductA(const(char)* szPackagePath, const(char)* szCommandLine);

///The <b>MsiInstallProduct</b> function installs or uninstalls a product.
///Params:
///    szPackagePath = A null-terminated string that specifies the path to the location of the Windows Installer package. The string
///                    value can contain a URL (e.g. <code>http://packageLocation/package/package.msi</code>), a network path (e.g.
///                    \\packageLocation\package.msi), a file path (e.g. file://packageLocation/package.msi), or a local path (e.g.
///                    D:\packageLocation\package.msi).
///    szCommandLine = A null-terminated string that specifies the command line property settings. This should be a list of the format
///                    <i>Property=Setting Property=Setting</i>. For more information, see About Properties. To perform an
///                    administrative installation, include ACTION=ADMIN in <i>szCommandLine</i>. For more information, see the ACTION
///                    property.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completes successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An
///    error relating to an action</b></dt> </dl> </td> <td width="60%"> For more information, see Error Codes. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization Error</b></dt> </dl> </td> <td width="60%"> An error that
///    relates to initialization occurred. </td> </tr> </table> For more information, see Displayed Error Messages.
///    
@DllImport("msi")
uint MsiInstallProductW(const(wchar)* szPackagePath, const(wchar)* szCommandLine);

///The <b>MsiConfigureProduct</b> function installs or uninstalls a product.
///Params:
///    szProduct = Specifies the product code for the product to be configured.
///    iInstallLevel = Specifies how much of the product should be installed when installing the product to its default state. The
///                    <i>iInstallLevel</i> parameter is ignored, and all features are installed, if the <i>eInstallState</i> parameter
///                    is set to any other value than INSTALLSTATE_DEFAULT. This parameter can be one of the following values. <table>
///                    <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLLEVEL_DEFAULT"></a><a
///                    id="installlevel_default"></a><dl> <dt><b>INSTALLLEVEL_DEFAULT</b></dt> </dl> </td> <td width="60%"> The authored
///                    default features are installed. </td> </tr> <tr> <td width="40%"><a id="INSTALLLEVEL_MINIMUM"></a><a
///                    id="installlevel_minimum"></a><dl> <dt><b>INSTALLLEVEL_MINIMUM</b></dt> </dl> </td> <td width="60%"> Only the
///                    required features are installed. You can specify a value between INSTALLLEVEL_MINIMUM and INSTALLLEVEL_MAXIMUM to
///                    install a subset of available features. </td> </tr> <tr> <td width="40%"><a id="INSTALLLEVEL_MAXIMUM"></a><a
///                    id="installlevel_maximum"></a><dl> <dt><b>INSTALLLEVEL_MAXIMUM</b></dt> </dl> </td> <td width="60%"> All features
///                    are installed. You can specify a value between INSTALLLEVEL_MINIMUM and INSTALLLEVEL_MAXIMUM to install a subset
///                    of available features. </td> </tr> </table>
///    eInstallState = Specifies the installation state for the product. This parameter can be one of the following values. <table> <tr>
///                    <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a
///                    id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The product is
///                    to be installed with all features installed locally. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLSTATE_ABSENT"></a><a id="installstate_absent"></a><dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td>
///                    <td width="60%"> The product is uninstalled. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a
///                    id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The product is
///                    to be installed with all features installed to run from source. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLSTATE_DEFAULT"></a><a id="installstate_default"></a><dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl>
///                    </td> <td width="60%"> The product is to be installed with all features installed to the default states specified
///                    in the Feature Table. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ADVERTISED"></a><a
///                    id="installstate_advertised"></a><dl> <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The
///                    product is advertised. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function succeeds. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error that relates to an action</b></dt>
///    </dl> </td> <td width="60%"> For more information, see Error Codes. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>Initialization Error</b></dt> </dl> </td> <td width="60%"> An error that relates to initialization. </td>
///    </tr> </table>
///    
@DllImport("msi")
uint MsiConfigureProductA(const(char)* szProduct, int iInstallLevel, INSTALLSTATE eInstallState);

///The <b>MsiConfigureProduct</b> function installs or uninstalls a product.
///Params:
///    szProduct = Specifies the product code for the product to be configured.
///    iInstallLevel = Specifies how much of the product should be installed when installing the product to its default state. The
///                    <i>iInstallLevel</i> parameter is ignored, and all features are installed, if the <i>eInstallState</i> parameter
///                    is set to any other value than INSTALLSTATE_DEFAULT. This parameter can be one of the following values. <table>
///                    <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLLEVEL_DEFAULT"></a><a
///                    id="installlevel_default"></a><dl> <dt><b>INSTALLLEVEL_DEFAULT</b></dt> </dl> </td> <td width="60%"> The authored
///                    default features are installed. </td> </tr> <tr> <td width="40%"><a id="INSTALLLEVEL_MINIMUM"></a><a
///                    id="installlevel_minimum"></a><dl> <dt><b>INSTALLLEVEL_MINIMUM</b></dt> </dl> </td> <td width="60%"> Only the
///                    required features are installed. You can specify a value between INSTALLLEVEL_MINIMUM and INSTALLLEVEL_MAXIMUM to
///                    install a subset of available features. </td> </tr> <tr> <td width="40%"><a id="INSTALLLEVEL_MAXIMUM"></a><a
///                    id="installlevel_maximum"></a><dl> <dt><b>INSTALLLEVEL_MAXIMUM</b></dt> </dl> </td> <td width="60%"> All features
///                    are installed. You can specify a value between INSTALLLEVEL_MINIMUM and INSTALLLEVEL_MAXIMUM to install a subset
///                    of available features. </td> </tr> </table>
///    eInstallState = Specifies the installation state for the product. This parameter can be one of the following values. <table> <tr>
///                    <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a
///                    id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The product is
///                    to be installed with all features installed locally. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLSTATE_ABSENT"></a><a id="installstate_absent"></a><dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td>
///                    <td width="60%"> The product is uninstalled. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a
///                    id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The product is
///                    to be installed with all features installed to run from source. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLSTATE_DEFAULT"></a><a id="installstate_default"></a><dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl>
///                    </td> <td width="60%"> The product is to be installed with all features installed to the default states specified
///                    in the Feature Table. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ADVERTISED"></a><a
///                    id="installstate_advertised"></a><dl> <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The
///                    product is advertised. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function succeeds. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error that relates to an action</b></dt>
///    </dl> </td> <td width="60%"> For more information, see Error Codes. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>Initialization Error</b></dt> </dl> </td> <td width="60%"> An error that relates to initialization. </td>
///    </tr> </table>
///    
@DllImport("msi")
uint MsiConfigureProductW(const(wchar)* szProduct, int iInstallLevel, INSTALLSTATE eInstallState);

///The <b>MsiConfigureProductEx</b> function installs or uninstalls a product. A product command line can also be
///specified.
///Params:
///    szProduct = Specifies the product code for the product to be configured.
///    iInstallLevel = Specifies how much of the product should be installed when installing the product to its default state. The
///                    <i>iInstallLevel</i> parameters are ignored, and all features are installed, if the <i>eInstallState</i>
///                    parameter is set to any value other than <b>INSTALLSTATE_DEFAULT</b>. This parameter can be one of the following
///                    values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                    id="INSTALLLEVEL_DEFAULT"></a><a id="installlevel_default"></a><dl> <dt><b>INSTALLLEVEL_DEFAULT</b></dt> </dl>
///                    </td> <td width="60%"> The authored default features are installed. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLLEVEL_MINIMUM"></a><a id="installlevel_minimum"></a><dl> <dt><b>INSTALLLEVEL_MINIMUM</b></dt> </dl>
///                    </td> <td width="60%"> Only the required features are installed. You can specify a value between
///                    <b>INSTALLLEVEL_MINIMUM</b> and <b>INSTALLLEVEL_MAXIMUM</b> to install a subset of available features. </td>
///                    </tr> <tr> <td width="40%"><a id="INSTALLLEVEL_MAXIMUM"></a><a id="installlevel_maximum"></a><dl>
///                    <dt><b>INSTALLLEVEL_MAXIMUM</b></dt> </dl> </td> <td width="60%"> All features are installed. You can specify a
///                    value between <b>INSTALLLEVEL_MINIMUM</b> and <b>INSTALLLEVEL_MAXIMUM</b> to install a subset of available
///                    features. </td> </tr> </table>
///    eInstallState = Specifies the installation state for the product. This parameter can be one of the following values. <table> <tr>
///                    <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a
///                    id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The product is
///                    to be installed with all features installed locally. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLSTATE_ABSENT"></a><a id="installstate_absent"></a><dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td>
///                    <td width="60%"> The product is uninstalled. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a
///                    id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The product is
///                    to be installed with all features installed to run from source. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLSTATE_DEFAULT"></a><a id="installstate_default"></a><dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl>
///                    </td> <td width="60%"> The product is to be installed with all features installed to the default states specified
///                    in the Feature Table. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ADVERTISED"></a><a
///                    id="installstate_advertised"></a><dl> <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The
///                    product is advertised. </td> </tr> </table>
///    szCommandLine = Specifies the command-line property settings. This should be a list of the format <i>Property=Setting
///                    Property=Setting</i>. For more information, see About Properties.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error that relates to an action</b></dt>
///    </dl> </td> <td width="60%"> For more information, see Error Codes. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>Initialization Error</b></dt> </dl> </td> <td width="60%"> An error relating to initialization occurred.
///    </td> </tr> </table>
///    
@DllImport("msi")
uint MsiConfigureProductExA(const(char)* szProduct, int iInstallLevel, INSTALLSTATE eInstallState, 
                            const(char)* szCommandLine);

///The <b>MsiConfigureProductEx</b> function installs or uninstalls a product. A product command line can also be
///specified.
///Params:
///    szProduct = Specifies the product code for the product to be configured.
///    iInstallLevel = Specifies how much of the product should be installed when installing the product to its default state. The
///                    <i>iInstallLevel</i> parameters are ignored, and all features are installed, if the <i>eInstallState</i>
///                    parameter is set to any value other than <b>INSTALLSTATE_DEFAULT</b>. This parameter can be one of the following
///                    values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                    id="INSTALLLEVEL_DEFAULT"></a><a id="installlevel_default"></a><dl> <dt><b>INSTALLLEVEL_DEFAULT</b></dt> </dl>
///                    </td> <td width="60%"> The authored default features are installed. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLLEVEL_MINIMUM"></a><a id="installlevel_minimum"></a><dl> <dt><b>INSTALLLEVEL_MINIMUM</b></dt> </dl>
///                    </td> <td width="60%"> Only the required features are installed. You can specify a value between
///                    <b>INSTALLLEVEL_MINIMUM</b> and <b>INSTALLLEVEL_MAXIMUM</b> to install a subset of available features. </td>
///                    </tr> <tr> <td width="40%"><a id="INSTALLLEVEL_MAXIMUM"></a><a id="installlevel_maximum"></a><dl>
///                    <dt><b>INSTALLLEVEL_MAXIMUM</b></dt> </dl> </td> <td width="60%"> All features are installed. You can specify a
///                    value between <b>INSTALLLEVEL_MINIMUM</b> and <b>INSTALLLEVEL_MAXIMUM</b> to install a subset of available
///                    features. </td> </tr> </table>
///    eInstallState = Specifies the installation state for the product. This parameter can be one of the following values. <table> <tr>
///                    <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a
///                    id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The product is
///                    to be installed with all features installed locally. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLSTATE_ABSENT"></a><a id="installstate_absent"></a><dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td>
///                    <td width="60%"> The product is uninstalled. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a
///                    id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The product is
///                    to be installed with all features installed to run from source. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLSTATE_DEFAULT"></a><a id="installstate_default"></a><dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl>
///                    </td> <td width="60%"> The product is to be installed with all features installed to the default states specified
///                    in the Feature Table. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ADVERTISED"></a><a
///                    id="installstate_advertised"></a><dl> <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The
///                    product is advertised. </td> </tr> </table>
///    szCommandLine = Specifies the command-line property settings. This should be a list of the format <i>Property=Setting
///                    Property=Setting</i>. For more information, see About Properties.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error that relates to an action</b></dt>
///    </dl> </td> <td width="60%"> For more information, see Error Codes. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>Initialization Error</b></dt> </dl> </td> <td width="60%"> An error relating to initialization occurred.
///    </td> </tr> </table>
///    
@DllImport("msi")
uint MsiConfigureProductExW(const(wchar)* szProduct, int iInstallLevel, INSTALLSTATE eInstallState, 
                            const(wchar)* szCommandLine);

///The <b>MsiReinstallProduct</b> function reinstalls products.
///Params:
///    szProduct = Specifies the product code for the product to be reinstalled.
///    szReinstallMode = Specifies the reinstall mode. This parameter can be one or more of the following values. <table> <tr>
///                      <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_FILEMISSING"></a><a
///                      id="reinstallmode_filemissing"></a><dl> <dt><b>REINSTALLMODE_FILEMISSING</b></dt> </dl> </td> <td width="60%">
///                      Reinstall only if the file is missing. </td> </tr> <tr> <td width="40%"><a
///                      id="REINSTALLMODE_FILEOLDERVERSION"></a><a id="reinstallmode_fileolderversion"></a><dl>
///                      <dt><b>REINSTALLMODE_FILEOLDERVERSION</b></dt> </dl> </td> <td width="60%"> Reinstall if the file is missing or
///                      is an older version. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_FILEEQUALVERSION"></a><a
///                      id="reinstallmode_fileequalversion"></a><dl> <dt><b>REINSTALLMODE_FILEEQUALVERSION</b></dt> </dl> </td> <td
///                      width="60%"> Reinstall if the file is missing, or is an equal or older version. </td> </tr> <tr> <td
///                      width="40%"><a id="REINSTALLMODE_FILEEXACT"></a><a id="reinstallmode_fileexact"></a><dl>
///                      <dt><b>REINSTALLMODE_FILEEXACT</b></dt> </dl> </td> <td width="60%"> Reinstall if the file is missing or is a
///                      different version. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_FILEVERIFY"></a><a
///                      id="reinstallmode_fileverify"></a><dl> <dt><b>REINSTALLMODE_FILEVERIFY</b></dt> </dl> </td> <td width="60%">
///                      Verify the checksum values and reinstall the file if they are missing or corrupt. This flag only repairs files
///                      that have msidbFileAttributesChecksum in the Attributes column of the File table. </td> </tr> <tr> <td
///                      width="40%"><a id="REINSTALLMODE_FILEREPLACE"></a><a id="reinstallmode_filereplace"></a><dl>
///                      <dt><b>REINSTALLMODE_FILEREPLACE</b></dt> </dl> </td> <td width="60%"> Force all files to be reinstalled,
///                      regardless of checksum or version. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_USERDATA"></a><a
///                      id="reinstallmode_userdata"></a><dl> <dt><b>REINSTALLMODE_USERDATA</b></dt> </dl> </td> <td width="60%"> Rewrite
///                      all required registry entries from the Registry Table that go to the<b>HKEY_CURRENT_USER</b></p> or
///                      <b>HKEY_USERS</b></p> registry hive. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_MACHINEDATA"></a><a
///                      id="reinstallmode_machinedata"></a><dl> <dt><b>REINSTALLMODE_MACHINEDATA</b></dt> </dl> </td> <td width="60%">
///                      Rewrite all required registry entries from the Registry Table that go to the <b>HKEY_LOCAL_MACHINE</b></p>or
///                      <b>HKEY_CLASSES_ROOT</b></p> registry hive. Rewrite all information from the Class Table, Verb Table,
///                      PublishComponent Table, ProgID Table, MIMET Table, Icon Table, Extension Table, and AppID Table regardless of
///                      machine or user assignment. Reinstall all qualified components. When reinstalling an application, this option
///                      runs the RegisterTypeLibraries and InstallODBC actions. </td> </tr> <tr> <td width="40%"><a
///                      id="REINSTALLMODE_SHORTCUT"></a><a id="reinstallmode_shortcut"></a><dl> <dt><b>REINSTALLMODE_SHORTCUT</b></dt>
///                      </dl> </td> <td width="60%"> Reinstall all shortcuts and re-cache all icons overwriting any existing shortcuts
///                      and icons. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_PACKAGE"></a><a
///                      id="reinstallmode_package"></a><dl> <dt><b>REINSTALLMODE_PACKAGE</b></dt> </dl> </td> <td width="60%"> Use to run
///                      from the source package and re-cache the local package. Do not use for the first installation of an application
///                      or feature. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The installation failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was
///    passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt>
///    </dl> </td> <td width="60%"> The installation service could not be accessed. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_INSTALL_SUSPEND</b></dt> </dl> </td> <td width="60%"> The installation was suspended and is
///    incomplete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_USEREXIT</b></dt> </dl> </td> <td
///    width="60%"> The user canceled the installation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product code does
///    not identify a known product. </td> </tr> </table> For more information, see Displayed Error Messages.
///    
@DllImport("msi")
uint MsiReinstallProductA(const(char)* szProduct, uint szReinstallMode);

///The <b>MsiReinstallProduct</b> function reinstalls products.
///Params:
///    szProduct = Specifies the product code for the product to be reinstalled.
///    szReinstallMode = Specifies the reinstall mode. This parameter can be one or more of the following values. <table> <tr>
///                      <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_FILEMISSING"></a><a
///                      id="reinstallmode_filemissing"></a><dl> <dt><b>REINSTALLMODE_FILEMISSING</b></dt> </dl> </td> <td width="60%">
///                      Reinstall only if the file is missing. </td> </tr> <tr> <td width="40%"><a
///                      id="REINSTALLMODE_FILEOLDERVERSION"></a><a id="reinstallmode_fileolderversion"></a><dl>
///                      <dt><b>REINSTALLMODE_FILEOLDERVERSION</b></dt> </dl> </td> <td width="60%"> Reinstall if the file is missing or
///                      is an older version. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_FILEEQUALVERSION"></a><a
///                      id="reinstallmode_fileequalversion"></a><dl> <dt><b>REINSTALLMODE_FILEEQUALVERSION</b></dt> </dl> </td> <td
///                      width="60%"> Reinstall if the file is missing, or is an equal or older version. </td> </tr> <tr> <td
///                      width="40%"><a id="REINSTALLMODE_FILEEXACT"></a><a id="reinstallmode_fileexact"></a><dl>
///                      <dt><b>REINSTALLMODE_FILEEXACT</b></dt> </dl> </td> <td width="60%"> Reinstall if the file is missing or is a
///                      different version. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_FILEVERIFY"></a><a
///                      id="reinstallmode_fileverify"></a><dl> <dt><b>REINSTALLMODE_FILEVERIFY</b></dt> </dl> </td> <td width="60%">
///                      Verify the checksum values and reinstall the file if they are missing or corrupt. This flag only repairs files
///                      that have msidbFileAttributesChecksum in the Attributes column of the File table. </td> </tr> <tr> <td
///                      width="40%"><a id="REINSTALLMODE_FILEREPLACE"></a><a id="reinstallmode_filereplace"></a><dl>
///                      <dt><b>REINSTALLMODE_FILEREPLACE</b></dt> </dl> </td> <td width="60%"> Force all files to be reinstalled,
///                      regardless of checksum or version. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_USERDATA"></a><a
///                      id="reinstallmode_userdata"></a><dl> <dt><b>REINSTALLMODE_USERDATA</b></dt> </dl> </td> <td width="60%"> Rewrite
///                      all required registry entries from the Registry Table that go to the<b>HKEY_CURRENT_USER</b></p> or
///                      <b>HKEY_USERS</b></p> registry hive. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_MACHINEDATA"></a><a
///                      id="reinstallmode_machinedata"></a><dl> <dt><b>REINSTALLMODE_MACHINEDATA</b></dt> </dl> </td> <td width="60%">
///                      Rewrite all required registry entries from the Registry Table that go to the <b>HKEY_LOCAL_MACHINE</b></p>or
///                      <b>HKEY_CLASSES_ROOT</b></p> registry hive. Rewrite all information from the Class Table, Verb Table,
///                      PublishComponent Table, ProgID Table, MIMET Table, Icon Table, Extension Table, and AppID Table regardless of
///                      machine or user assignment. Reinstall all qualified components. When reinstalling an application, this option
///                      runs the RegisterTypeLibraries and InstallODBC actions. </td> </tr> <tr> <td width="40%"><a
///                      id="REINSTALLMODE_SHORTCUT"></a><a id="reinstallmode_shortcut"></a><dl> <dt><b>REINSTALLMODE_SHORTCUT</b></dt>
///                      </dl> </td> <td width="60%"> Reinstall all shortcuts and re-cache all icons overwriting any existing shortcuts
///                      and icons. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_PACKAGE"></a><a
///                      id="reinstallmode_package"></a><dl> <dt><b>REINSTALLMODE_PACKAGE</b></dt> </dl> </td> <td width="60%"> Use to run
///                      from the source package and re-cache the local package. Do not use for the first installation of an application
///                      or feature. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The installation failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was
///    passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt>
///    </dl> </td> <td width="60%"> The installation service could not be accessed. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_INSTALL_SUSPEND</b></dt> </dl> </td> <td width="60%"> The installation was suspended and is
///    incomplete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_USEREXIT</b></dt> </dl> </td> <td
///    width="60%"> The user canceled the installation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product code does
///    not identify a known product. </td> </tr> </table> For more information, see Displayed Error Messages.
///    
@DllImport("msi")
uint MsiReinstallProductW(const(wchar)* szProduct, uint szReinstallMode);

///The <b>MsiAdvertiseProductEx</b> function generates an advertise script or advertises a product to the computer. This
///function enables Windows Installer to write to a script the registry and shortcut information used to assign or
///publish a product. The script can be written to be consistent with a specified platform by using
///<b>MsiAdvertiseProductEx</b>. The <b>MsiAdvertiseProductEx</b> function provides the same functionality as
///MsiAdvertiseProduct.
///Params:
///    szPackagePath = The full path to the package of the product being advertised.
///    szScriptfilePath = The full path to the script file to be created with the advertised information. To advertise the product locally
///                       to the computer, set ADVERTISEFLAGS_MACHINEASSIGN or ADVERTISEFLAGS_USERASSIGN. <table> <tr> <th>Flag</th>
///                       <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ADVERTISEFLAGS_MACHINEASSIGN"></a><a
///                       id="advertiseflags_machineassign"></a><dl> <dt><b>ADVERTISEFLAGS_MACHINEASSIGN</b></dt> <dt>0</dt> </dl> </td>
///                       <td width="60%"> Set to advertise a per-computer installation of the product available to all users. </td> </tr>
///                       <tr> <td width="40%"><a id="ADVERTISEFLAGS_USERASSIGN"></a><a id="advertiseflags_userassign"></a><dl>
///                       <dt><b>ADVERTISEFLAGS_USERASSIGN</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Set to advertise a per-user
///                       installation of the product available to a particular user. </td> </tr> </table>
///    szTransforms = A semicolondelimited list of transforms to be applied. The list of transforms can be prefixed with the @ or |
///                   character to specify the secure caching of transforms. The @ prefix specifies secure-at-source transforms and the
///                   | prefix indicates secure full pathtransforms. For more information, see Secured Transforms. This parameter
///                   may be null.
///    lgidLanguage = The language to use if the source supports multiple languages.
///    dwPlatform = Bit flags that control for which platform the installer should create the script. This parameter is ignored if
///                 <i>szScriptfilePath</i> is null. If <i>dwPlatform</i> is zero (0), then the script is created based on the
///                 current platform. This is the same functionality as MsiAdvertiseProduct. If <i>dwPlatform</i> is 1 or 2, the
///                 installer creates script for the specified platform. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td
///                 width="40%"><a id="none"></a><a id="NONE"></a><dl> <dt><b>none</b></dt> <dt>0</dt> </dl> </td> <td width="60%">
///                 Creates a script for the current platform. </td> </tr> <tr> <td width="40%"><a
///                 id="MSIARCHITECTUREFLAGS_X86"></a><a id="msiarchitectureflags_x86"></a><dl>
///                 <dt><b>MSIARCHITECTUREFLAGS_X86</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Creates a script for the x86
///                 platform. </td> </tr> <tr> <td width="40%"><a id="MSIARCHITECTUREFLAGS_IA64"></a><a
///                 id="msiarchitectureflags_ia64"></a><dl> <dt><b>MSIARCHITECTUREFLAGS_IA64</b></dt> <dt>2</dt> </dl> </td> <td
///                 width="60%"> Creates a script for Itanium-based systems. </td> </tr> <tr> <td width="40%"><a
///                 id="MSIARCHITECTUREFLAGS_AMD64"></a><a id="msiarchitectureflags_amd64"></a><dl>
///                 <dt><b>MSIARCHITECTUREFLAGS_AMD64</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Creates a script for the x64
///                 platform. </td> </tr> </table>
///    dwOptions = Bit flags that specify extra advertisement options. Nonzero value is only available in Windows Installer versions
///                shipped with Windows Server 2003 and Windows XP with SP1 and later. <table> <tr> <th>Flag</th> <th>Meaning</th>
///                </tr> <tr> <td width="40%"><a id="MSIADVERTISEOPTIONS_INSTANCE"></a><a id="msiadvertiseoptions_instance"></a><dl>
///                <dt><b>MSIADVERTISEOPTIONS_INSTANCE</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Multiple instances through
///                product code changing transform support flag. Advertises a new instance of the product. Requires that the
///                <i>szTransforms</i> parameter includes the instance transform that changes the product code. For more
///                information, see Installing Multiple Instances of Products and Patches. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completes successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An
///    error that relates to an action</b></dt> </dl> </td> <td width="60%"> For more information, see Error Codes.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization Error</b></dt> </dl> </td> <td width="60%"> An
///    initialization error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> This error is returned if an attempt is
///    made to generate an advertise script on any platform other than Windows 2000 or Windows XP. Advertisement to the
///    local computer is supported on all platforms. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiAdvertiseProductExA(const(char)* szPackagePath, const(char)* szScriptfilePath, const(char)* szTransforms, 
                            ushort lgidLanguage, uint dwPlatform, uint dwOptions);

///The <b>MsiAdvertiseProductEx</b> function generates an advertise script or advertises a product to the computer. This
///function enables Windows Installer to write to a script the registry and shortcut information used to assign or
///publish a product. The script can be written to be consistent with a specified platform by using
///<b>MsiAdvertiseProductEx</b>. The <b>MsiAdvertiseProductEx</b> function provides the same functionality as
///MsiAdvertiseProduct.
///Params:
///    szPackagePath = The full path to the package of the product being advertised.
///    szScriptfilePath = The full path to the script file to be created with the advertised information. To advertise the product locally
///                       to the computer, set ADVERTISEFLAGS_MACHINEASSIGN or ADVERTISEFLAGS_USERASSIGN. <table> <tr> <th>Flag</th>
///                       <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ADVERTISEFLAGS_MACHINEASSIGN"></a><a
///                       id="advertiseflags_machineassign"></a><dl> <dt><b>ADVERTISEFLAGS_MACHINEASSIGN</b></dt> <dt>0</dt> </dl> </td>
///                       <td width="60%"> Set to advertise a per-computer installation of the product available to all users. </td> </tr>
///                       <tr> <td width="40%"><a id="ADVERTISEFLAGS_USERASSIGN"></a><a id="advertiseflags_userassign"></a><dl>
///                       <dt><b>ADVERTISEFLAGS_USERASSIGN</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Set to advertise a per-user
///                       installation of the product available to a particular user. </td> </tr> </table>
///    szTransforms = A semicolondelimited list of transforms to be applied. The list of transforms can be prefixed with the @ or |
///                   character to specify the secure caching of transforms. The @ prefix specifies secure-at-source transforms and the
///                   | prefix indicates secure full pathtransforms. For more information, see Secured Transforms. This parameter
///                   may be null.
///    lgidLanguage = The language to use if the source supports multiple languages.
///    dwPlatform = Bit flags that control for which platform the installer should create the script. This parameter is ignored if
///                 <i>szScriptfilePath</i> is null. If <i>dwPlatform</i> is zero (0), then the script is created based on the
///                 current platform. This is the same functionality as MsiAdvertiseProduct. If <i>dwPlatform</i> is 1 or 2, the
///                 installer creates script for the specified platform. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td
///                 width="40%"><a id="none"></a><a id="NONE"></a><dl> <dt><b>none</b></dt> <dt>0</dt> </dl> </td> <td width="60%">
///                 Creates a script for the current platform. </td> </tr> <tr> <td width="40%"><a
///                 id="MSIARCHITECTUREFLAGS_X86"></a><a id="msiarchitectureflags_x86"></a><dl>
///                 <dt><b>MSIARCHITECTUREFLAGS_X86</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Creates a script for the x86
///                 platform. </td> </tr> <tr> <td width="40%"><a id="MSIARCHITECTUREFLAGS_IA64"></a><a
///                 id="msiarchitectureflags_ia64"></a><dl> <dt><b>MSIARCHITECTUREFLAGS_IA64</b></dt> <dt>2</dt> </dl> </td> <td
///                 width="60%"> Creates a script for Itanium-based systems. </td> </tr> <tr> <td width="40%"><a
///                 id="MSIARCHITECTUREFLAGS_AMD64"></a><a id="msiarchitectureflags_amd64"></a><dl>
///                 <dt><b>MSIARCHITECTUREFLAGS_AMD64</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Creates a script for the x64
///                 platform. </td> </tr> </table>
///    dwOptions = Bit flags that specify extra advertisement options. Nonzero value is only available in Windows Installer versions
///                shipped with Windows Server 2003 and Windows XP with SP1 and later. <table> <tr> <th>Flag</th> <th>Meaning</th>
///                </tr> <tr> <td width="40%"><a id="MSIADVERTISEOPTIONS_INSTANCE"></a><a id="msiadvertiseoptions_instance"></a><dl>
///                <dt><b>MSIADVERTISEOPTIONS_INSTANCE</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Multiple instances through
///                product code changing transform support flag. Advertises a new instance of the product. Requires that the
///                <i>szTransforms</i> parameter includes the instance transform that changes the product code. For more
///                information, see Installing Multiple Instances of Products and Patches. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completes successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An
///    error that relates to an action</b></dt> </dl> </td> <td width="60%"> For more information, see Error Codes.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization Error</b></dt> </dl> </td> <td width="60%"> An
///    initialization error has occurred. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> This error is returned if an attempt is
///    made to generate an advertise script on any platform other than Windows 2000 or Windows XP. Advertisement to the
///    local computer is supported on all platforms. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiAdvertiseProductExW(const(wchar)* szPackagePath, const(wchar)* szScriptfilePath, 
                            const(wchar)* szTransforms, ushort lgidLanguage, uint dwPlatform, uint dwOptions);

///The <b>MsiAdvertiseProduct</b> function generates an advertise script or advertises a product to the computer. The
///<b>MsiAdvertiseProduct</b> function enables the installer to write to a script the registry and shortcut information
///used to assign or publish a product. The script can be written to be consistent with a specified platform by using
///MsiAdvertiseProductEx.
///Params:
///    szPackagePath = The full path to the package of the product being advertised.
///    szScriptfilePath = The full path to script file that will be created with the advertise information. To advertise the product
///                       locally to the computer, set ADVERTISEFLAGS_MACHINEASSIGN or ADVERTISEFLAGS_USERASSIGN. <table> <tr>
///                       <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ADVERTISEFLAGS_MACHINEASSIGN"></a><a
///                       id="advertiseflags_machineassign"></a><dl> <dt><b>ADVERTISEFLAGS_MACHINEASSIGN</b></dt> <dt>0</dt> </dl> </td>
///                       <td width="60%"> Set to advertise a per-machine installation of the product available to all users. </td> </tr>
///                       <tr> <td width="40%"><a id="ADVERTISEFLAGS_USERASSIGN"></a><a id="advertiseflags_userassign"></a><dl>
///                       <dt><b>ADVERTISEFLAGS_USERASSIGN</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Set to advertise a per-user
///                       installation of the product available to a particular user. </td> </tr> </table>
///    szTransforms = A semicolon-delimited list of transforms to be applied. The list of transforms can be prefixed with the @ or |
///                   character to specify the secure caching of transforms. The @ prefix specifies secure-at-source transforms and the
///                   | prefix indicates secure full path transforms. For more information, see Secured Transforms. This parameter may
///                   be null.
///    lgidLanguage = The installation language to use if the source supports multiple languages.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An
///    error relating to an action</b></dt> </dl> </td> <td width="60%"> See Error Codes. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>Initialization Error</b></dt> </dl> </td> <td width="60%"> An initialization error
///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td
///    width="60%"> This error is returned if an attempt is made to generate an advertise script on any platform other
///    than Windows 2000 or Windows XP. Advertisement to the local computer is supported on all platforms. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiAdvertiseProductA(const(char)* szPackagePath, const(char)* szScriptfilePath, const(char)* szTransforms, 
                          ushort lgidLanguage);

///The <b>MsiAdvertiseProduct</b> function generates an advertise script or advertises a product to the computer. The
///<b>MsiAdvertiseProduct</b> function enables the installer to write to a script the registry and shortcut information
///used to assign or publish a product. The script can be written to be consistent with a specified platform by using
///MsiAdvertiseProductEx.
///Params:
///    szPackagePath = The full path to the package of the product being advertised.
///    szScriptfilePath = The full path to script file that will be created with the advertise information. To advertise the product
///                       locally to the computer, set ADVERTISEFLAGS_MACHINEASSIGN or ADVERTISEFLAGS_USERASSIGN. <table> <tr>
///                       <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ADVERTISEFLAGS_MACHINEASSIGN"></a><a
///                       id="advertiseflags_machineassign"></a><dl> <dt><b>ADVERTISEFLAGS_MACHINEASSIGN</b></dt> <dt>0</dt> </dl> </td>
///                       <td width="60%"> Set to advertise a per-machine installation of the product available to all users. </td> </tr>
///                       <tr> <td width="40%"><a id="ADVERTISEFLAGS_USERASSIGN"></a><a id="advertiseflags_userassign"></a><dl>
///                       <dt><b>ADVERTISEFLAGS_USERASSIGN</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Set to advertise a per-user
///                       installation of the product available to a particular user. </td> </tr> </table>
///    szTransforms = A semicolon-delimited list of transforms to be applied. The list of transforms can be prefixed with the @ or |
///                   character to specify the secure caching of transforms. The @ prefix specifies secure-at-source transforms and the
///                   | prefix indicates secure full path transforms. For more information, see Secured Transforms. This parameter may
///                   be null.
///    lgidLanguage = The installation language to use if the source supports multiple languages.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An
///    error relating to an action</b></dt> </dl> </td> <td width="60%"> See Error Codes. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>Initialization Error</b></dt> </dl> </td> <td width="60%"> An initialization error
///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td
///    width="60%"> This error is returned if an attempt is made to generate an advertise script on any platform other
///    than Windows 2000 or Windows XP. Advertisement to the local computer is supported on all platforms. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiAdvertiseProductW(const(wchar)* szPackagePath, const(wchar)* szScriptfilePath, const(wchar)* szTransforms, 
                          ushort lgidLanguage);

///The <b>MsiProcessAdvertiseScript</b> function processes an advertise script file into the specified locations.
///Params:
///    szScriptFile = The full path to a script file generated by MsiAdvertiseProduct or MsiAdvertiseProductEx.
///    szIconFolder = An optional path to a folder in which advertised icon files and transform files are located. If this parameter is
///                   <b>NULL</b>, no icon or transform files are written.
///    hRegData = A registry key under which registry data is to be written. If this parameter is <b>NULL</b>, the installer writes
///               the registry data under the appropriate key, based on whether the advertisement is per-user or per-machine. If
///               this parameter is non-<b>NULL</b>, the script will write the registry data under the specified registry key
///               rather than the normal location. In this case, the application will not get advertised to the user.
///    fShortcuts = <b>TRUE</b> if shortcuts should be created. If a special folder is returned by SHGetSpecialFolderLocation it will
///                 hold the shortcuts.
///    fRemoveItems = <b>TRUE</b> if specified items are to be removed instead of created.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The calling process was not running under the
///    LocalSystem account. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error relating to an action</b></dt> </dl>
///    </td> <td width="60%"> See Error Codes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization
///    Error</b></dt> </dl> </td> <td width="60%"> An error relating to initialization occurred. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> This function is not
///    available for this platform. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiProcessAdvertiseScriptA(const(char)* szScriptFile, const(char)* szIconFolder, HKEY hRegData, 
                                BOOL fShortcuts, BOOL fRemoveItems);

///The <b>MsiProcessAdvertiseScript</b> function processes an advertise script file into the specified locations.
///Params:
///    szScriptFile = The full path to a script file generated by MsiAdvertiseProduct or MsiAdvertiseProductEx.
///    szIconFolder = An optional path to a folder in which advertised icon files and transform files are located. If this parameter is
///                   <b>NULL</b>, no icon or transform files are written.
///    hRegData = A registry key under which registry data is to be written. If this parameter is <b>NULL</b>, the installer writes
///               the registry data under the appropriate key, based on whether the advertisement is per-user or per-machine. If
///               this parameter is non-<b>NULL</b>, the script will write the registry data under the specified registry key
///               rather than the normal location. In this case, the application will not get advertised to the user.
///    fShortcuts = <b>TRUE</b> if shortcuts should be created. If a special folder is returned by SHGetSpecialFolderLocation it will
///                 hold the shortcuts.
///    fRemoveItems = <b>TRUE</b> if specified items are to be removed instead of created.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The calling process was not running under the
///    LocalSystem account. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error relating to an action</b></dt> </dl>
///    </td> <td width="60%"> See Error Codes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization
///    Error</b></dt> </dl> </td> <td width="60%"> An error relating to initialization occurred. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> This function is not
///    available for this platform. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiProcessAdvertiseScriptW(const(wchar)* szScriptFile, const(wchar)* szIconFolder, HKEY hRegData, 
                                BOOL fShortcuts, BOOL fRemoveItems);

///The <b>MsiAdvertiseScript</b> function copies an advertised script file into the specified locations.
///Params:
///    szScriptFile = The full path to a script file generated by MsiAdvertiseProduct or MsiAdvertiseProductEx.
///    dwFlags = The following bit flags from SCRIPTFLAGS control advertisement. The value of <i>dwFlags</i> can be a combination
///              of the following values. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="SCRIPTFLAGS_CACHEINFO"></a><a id="scriptflags_cacheinfo"></a><dl> <dt><b>SCRIPTFLAGS_CACHEINFO</b></dt>
///              <dt>0x001</dt> </dl> </td> <td width="60%"> Include this flag if the icons need to be created or removed. </td>
///              </tr> <tr> <td width="40%"><a id="SCRIPTFLAGS_SHORTCUTS"></a><a id="scriptflags_shortcuts"></a><dl>
///              <dt><b>SCRIPTFLAGS_SHORTCUTS</b></dt> <dt>0x004</dt> </dl> </td> <td width="60%"> Include this flag if the
///              shortcuts need to be created or removed. </td> </tr> <tr> <td width="40%"><a
///              id="SCRIPTFLAGS_MACHINEASSIGN"></a><a id="scriptflags_machineassign"></a><dl>
///              <dt><b>SCRIPTFLAGS_MACHINEASSIGN</b></dt> <dt>0x008</dt> </dl> </td> <td width="60%"> Include this flag if the
///              product to be assigned to a computer. </td> </tr> <tr> <td width="40%"><a
///              id="SCRIPTFLAGS_REGDATA_CNFGINFO"></a><a id="scriptflags_regdata_cnfginfo"></a><dl>
///              <dt><b>SCRIPTFLAGS_REGDATA_CNFGINFO</b></dt> <dt>0x020</dt> </dl> </td> <td width="60%"> Include this flag if the
///              configuration and management information in the registry data needs to be written or removed. </td> </tr> <tr>
///              <td width="40%"><a id="SCRIPTFLAGS_VALIDATE_TRANSFORMS_LIST"></a><a
///              id="scriptflags_validate_transforms_list"></a><dl> <dt><b>SCRIPTFLAGS_VALIDATE_TRANSFORMS_LIST</b></dt>
///              <dt>0x040</dt> </dl> </td> <td width="60%"> Include this flag to force validation of the transforms listed in the
///              script against previously registered transforms for this product. Note that transform conflicts are detected
///              using a string comparison that is case insensitive and are evaluated between per-user and per-machine
///              installations across all contexts. If the list of transforms in the script does not match the transforms
///              registered for the product, the function returns ERROR_INSTALL_TRANSFORM_FAILURE. </td> </tr> <tr> <td
///              width="40%"><a id="SCRIPTFLAGS_REGDATA_CLASSINFO"></a><a id="scriptflags_regdata_classinfo"></a><dl>
///              <dt><b>SCRIPTFLAGS_REGDATA_CLASSINFO</b></dt> <dt>0x080</dt> </dl> </td> <td width="60%"> Include this flag if
///              advertisement information in the registry related to COM classes needs to be written or removed. </td> </tr> <tr>
///              <td width="40%"><a id="SCRIPTFLAGS_REGDATA_EXTENSIONINFO"></a><a id="scriptflags_regdata_extensioninfo"></a><dl>
///              <dt><b>SCRIPTFLAGS_REGDATA_EXTENSIONINFO</b></dt> <dt>0x100</dt> </dl> </td> <td width="60%"> Include this flag
///              if advertisement information in the registry related to an extension needs to be written or removed. </td> </tr>
///              <tr> <td width="40%"><a id="SCRIPTFLAGS_REGDATA_APPINFO"></a><a id="scriptflags_regdata_appinfo"></a><dl>
///              <dt><b>SCRIPTFLAGS_REGDATA_APPINFO</b></dt> <dt>0x180</dt> </dl> </td> <td width="60%"> Include this flag if the
///              advertisement information in the registry needs to be written or removed. </td> </tr> <tr> <td width="40%"><a
///              id="SCRIPTFLAGS_REGDATA"></a><a id="scriptflags_regdata"></a><dl> <dt><b>SCRIPTFLAGS_REGDATA</b></dt>
///              <dt>0x1A0</dt> </dl> </td> <td width="60%"> Include this flag if the advertisement information in the registry
///              needs to be written or removed. </td> </tr> </table>
///    phRegData = A registry key under which temporary information about registry data is to be written. If this parameter is null,
///                the registry data is placed under the appropriate key, based on whether the advertisement is per-user or
///                per-machine. If this parameter is non-null, the script will write the registry data under the specified registry
///                key rather than the normal location. In this case, the application will not get advertised to the user. Note that
///                this registry key cannot be used when generating an advertisement of a product for a user or a computer because
///                the provider of the registry key generally deletes the key. The registry key is located outside of the normal
///                registry locations for shell, class, and .msi configuration information and it is not under
///                <b>HKEY_CLASSES_ROOT</b>. This registry key is only intended for getting temporary information about registry
///                data in a script.
///    fRemoveItems = TRUE if specified items are to be removed instead of being created.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The calling process was not running under the
///    LocalSystem account. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error relating to an action</b></dt> </dl>
///    </td> <td width="60%"> See Error Codes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization
///    Error</b></dt> </dl> </td> <td width="60%"> An error relating to initialization occurred. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> This function is only
///    available on Windows 2000 and Windows XP. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiAdvertiseScriptA(const(char)* szScriptFile, uint dwFlags, HKEY* phRegData, BOOL fRemoveItems);

///The <b>MsiAdvertiseScript</b> function copies an advertised script file into the specified locations.
///Params:
///    szScriptFile = The full path to a script file generated by MsiAdvertiseProduct or MsiAdvertiseProductEx.
///    dwFlags = The following bit flags from SCRIPTFLAGS control advertisement. The value of <i>dwFlags</i> can be a combination
///              of the following values. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="SCRIPTFLAGS_CACHEINFO"></a><a id="scriptflags_cacheinfo"></a><dl> <dt><b>SCRIPTFLAGS_CACHEINFO</b></dt>
///              <dt>0x001</dt> </dl> </td> <td width="60%"> Include this flag if the icons need to be created or removed. </td>
///              </tr> <tr> <td width="40%"><a id="SCRIPTFLAGS_SHORTCUTS"></a><a id="scriptflags_shortcuts"></a><dl>
///              <dt><b>SCRIPTFLAGS_SHORTCUTS</b></dt> <dt>0x004</dt> </dl> </td> <td width="60%"> Include this flag if the
///              shortcuts need to be created or removed. </td> </tr> <tr> <td width="40%"><a
///              id="SCRIPTFLAGS_MACHINEASSIGN"></a><a id="scriptflags_machineassign"></a><dl>
///              <dt><b>SCRIPTFLAGS_MACHINEASSIGN</b></dt> <dt>0x008</dt> </dl> </td> <td width="60%"> Include this flag if the
///              product to be assigned to a computer. </td> </tr> <tr> <td width="40%"><a
///              id="SCRIPTFLAGS_REGDATA_CNFGINFO"></a><a id="scriptflags_regdata_cnfginfo"></a><dl>
///              <dt><b>SCRIPTFLAGS_REGDATA_CNFGINFO</b></dt> <dt>0x020</dt> </dl> </td> <td width="60%"> Include this flag if the
///              configuration and management information in the registry data needs to be written or removed. </td> </tr> <tr>
///              <td width="40%"><a id="SCRIPTFLAGS_VALIDATE_TRANSFORMS_LIST"></a><a
///              id="scriptflags_validate_transforms_list"></a><dl> <dt><b>SCRIPTFLAGS_VALIDATE_TRANSFORMS_LIST</b></dt>
///              <dt>0x040</dt> </dl> </td> <td width="60%"> Include this flag to force validation of the transforms listed in the
///              script against previously registered transforms for this product. Note that transform conflicts are detected
///              using a string comparison that is case insensitive and are evaluated between per-user and per-machine
///              installations across all contexts. If the list of transforms in the script does not match the transforms
///              registered for the product, the function returns ERROR_INSTALL_TRANSFORM_FAILURE. </td> </tr> <tr> <td
///              width="40%"><a id="SCRIPTFLAGS_REGDATA_CLASSINFO"></a><a id="scriptflags_regdata_classinfo"></a><dl>
///              <dt><b>SCRIPTFLAGS_REGDATA_CLASSINFO</b></dt> <dt>0x080</dt> </dl> </td> <td width="60%"> Include this flag if
///              advertisement information in the registry related to COM classes needs to be written or removed. </td> </tr> <tr>
///              <td width="40%"><a id="SCRIPTFLAGS_REGDATA_EXTENSIONINFO"></a><a id="scriptflags_regdata_extensioninfo"></a><dl>
///              <dt><b>SCRIPTFLAGS_REGDATA_EXTENSIONINFO</b></dt> <dt>0x100</dt> </dl> </td> <td width="60%"> Include this flag
///              if advertisement information in the registry related to an extension needs to be written or removed. </td> </tr>
///              <tr> <td width="40%"><a id="SCRIPTFLAGS_REGDATA_APPINFO"></a><a id="scriptflags_regdata_appinfo"></a><dl>
///              <dt><b>SCRIPTFLAGS_REGDATA_APPINFO</b></dt> <dt>0x180</dt> </dl> </td> <td width="60%"> Include this flag if the
///              advertisement information in the registry needs to be written or removed. </td> </tr> <tr> <td width="40%"><a
///              id="SCRIPTFLAGS_REGDATA"></a><a id="scriptflags_regdata"></a><dl> <dt><b>SCRIPTFLAGS_REGDATA</b></dt>
///              <dt>0x1A0</dt> </dl> </td> <td width="60%"> Include this flag if the advertisement information in the registry
///              needs to be written or removed. </td> </tr> </table>
///    phRegData = A registry key under which temporary information about registry data is to be written. If this parameter is null,
///                the registry data is placed under the appropriate key, based on whether the advertisement is per-user or
///                per-machine. If this parameter is non-null, the script will write the registry data under the specified registry
///                key rather than the normal location. In this case, the application will not get advertised to the user. Note that
///                this registry key cannot be used when generating an advertisement of a product for a user or a computer because
///                the provider of the registry key generally deletes the key. The registry key is located outside of the normal
///                registry locations for shell, class, and .msi configuration information and it is not under
///                <b>HKEY_CLASSES_ROOT</b>. This registry key is only intended for getting temporary information about registry
///                data in a script.
///    fRemoveItems = TRUE if specified items are to be removed instead of being created.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The calling process was not running under the
///    LocalSystem account. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error relating to an action</b></dt> </dl>
///    </td> <td width="60%"> See Error Codes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization
///    Error</b></dt> </dl> </td> <td width="60%"> An error relating to initialization occurred. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> This function is only
///    available on Windows 2000 and Windows XP. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiAdvertiseScriptW(const(wchar)* szScriptFile, uint dwFlags, HKEY* phRegData, BOOL fRemoveItems);

///The <b>MsiGetProductInfoFromScript</b> function returns product information for a Windows Installer script file.
///Params:
///    szScriptFile = A null-terminated string specifying the full path to the script file. The script file is the advertise script
///                   that was created by calling MsiAdvertiseProduct or MsiAdvertiseProductEx.
///    lpProductBuf39 = Points to a buffer that receives the product code. The buffer must be 39 characters long. The first 38 characters
///                     are for the product code GUID, and the last character is for the terminating null character.
///    plgidLanguage = Points to a variable that receives the product language.
///    pdwVersion = Points to a buffer that receives the product version.
///    lpNameBuf = Points to a buffer that receives the product name. The buffer includes a terminating null character.
///    pcchNameBuf = Points to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpNameBuf</i>
///                  parameter. This size should include the terminating null character. When the function returns, this variable
///                  contains the length of the string stored in the buffer. The count returned does not include the terminating null
///                  character. If the buffer is not large enough, the function returns ERROR_MORE_DATA, and the variable contains the
///                  size of the string in characters, without counting the null character.
///    lpPackageBuf = Points to a buffer that receives the package name. The buffer includes the terminating null character.
///    pcchPackageBuf = Points to a variable that specifies the size, in characters, of the buffer pointed to by the
///                     <i>lpPackageNameBuf</i> parameter. This size should include the terminating null character. When the function
///                     returns, this variable contains the length of the string stored in the buffer. The count returned does not
///                     include the terminating null character. If the buffer is not large enough, the function returns ERROR_MORE_DATA,
///                     and the variable contains the size of the string in characters, without counting the null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid argument was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> A
///    buffer was too small to hold the entire value. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> Could not get script information. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> This function
///    is only available on Windows 2000 and Windows XP. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiGetProductInfoFromScriptA(const(char)* szScriptFile, const(char)* lpProductBuf39, ushort* plgidLanguage, 
                                  uint* pdwVersion, const(char)* lpNameBuf, uint* pcchNameBuf, 
                                  const(char)* lpPackageBuf, uint* pcchPackageBuf);

///The <b>MsiGetProductInfoFromScript</b> function returns product information for a Windows Installer script file.
///Params:
///    szScriptFile = A null-terminated string specifying the full path to the script file. The script file is the advertise script
///                   that was created by calling MsiAdvertiseProduct or MsiAdvertiseProductEx.
///    lpProductBuf39 = Points to a buffer that receives the product code. The buffer must be 39 characters long. The first 38 characters
///                     are for the product code GUID, and the last character is for the terminating null character.
///    plgidLanguage = Points to a variable that receives the product language.
///    pdwVersion = Points to a buffer that receives the product version.
///    lpNameBuf = Points to a buffer that receives the product name. The buffer includes a terminating null character.
///    pcchNameBuf = Points to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpNameBuf</i>
///                  parameter. This size should include the terminating null character. When the function returns, this variable
///                  contains the length of the string stored in the buffer. The count returned does not include the terminating null
///                  character. If the buffer is not large enough, the function returns ERROR_MORE_DATA, and the variable contains the
///                  size of the string in characters, without counting the null character.
///    lpPackageBuf = Points to a buffer that receives the package name. The buffer includes the terminating null character.
///    pcchPackageBuf = Points to a variable that specifies the size, in characters, of the buffer pointed to by the
///                     <i>lpPackageNameBuf</i> parameter. This size should include the terminating null character. When the function
///                     returns, this variable contains the length of the string stored in the buffer. The count returned does not
///                     include the terminating null character. If the buffer is not large enough, the function returns ERROR_MORE_DATA,
///                     and the variable contains the size of the string in characters, without counting the null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid argument was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> A
///    buffer was too small to hold the entire value. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> Could not get script information. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> This function
///    is only available on Windows 2000 and Windows XP. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiGetProductInfoFromScriptW(const(wchar)* szScriptFile, const(wchar)* lpProductBuf39, ushort* plgidLanguage, 
                                  uint* pdwVersion, const(wchar)* lpNameBuf, uint* pcchNameBuf, 
                                  const(wchar)* lpPackageBuf, uint* pcchPackageBuf);

///The <b>MsiGetProductCode</b> function returns the product code of an application by using the component code of an
///installed or advertised component of the application. During initialization, an application must determine under
///which product code it has been installed or advertised.
///Params:
///    szComponent = This parameter specifies the component code of a component that has been installed by the application. This will
///                  be typically the component code of the component containing the executable file of the application.
///    lpBuf39 = Pointer to a buffer that receives the product code. This buffer must be 39 characters long. The first 38
///              characters are for the GUID, and the last character is for the terminating null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The product
///    code could not be determined. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt>
///    </dl> </td> <td width="60%"> An invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The specified
///    component is unknown. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiGetProductCodeA(const(char)* szComponent, const(char)* lpBuf39);

///The <b>MsiGetProductCode</b> function returns the product code of an application by using the component code of an
///installed or advertised component of the application. During initialization, an application must determine under
///which product code it has been installed or advertised.
///Params:
///    szComponent = This parameter specifies the component code of a component that has been installed by the application. This will
///                  be typically the component code of the component containing the executable file of the application.
///    lpBuf39 = Pointer to a buffer that receives the product code. This buffer must be 39 characters long. The first 38
///              characters are for the GUID, and the last character is for the terminating null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The product
///    code could not be determined. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt>
///    </dl> </td> <td width="60%"> An invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The specified
///    component is unknown. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiGetProductCodeW(const(wchar)* szComponent, const(wchar)* lpBuf39);

///The <b>MsiGetUserInfo</b> function returns the registered user information for an installed product.
///Params:
///    szProduct = Specifies the product code for the product to be queried.
///    lpUserNameBuf = Pointer to a variable that receives the name of the user.
///    pcchUserNameBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the
///                      <i>lpUserNameBuf</i> parameter. This size should include the terminating null character.
///    lpOrgNameBuf = Pointer to a buffer that receives the organization name.
///    pcchOrgNameBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpOrgNameBuf</i>
///                     parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                     the buffer passed in is too small, the count returned does not include the terminating null character.
///    lpSerialBuf = Pointer to a buffer that receives the product ID.
///    pcchSerialBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpSerialBuf</i>
///                    parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                    the buffer passed in is too small, the count returned does not include the terminating null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>USERINFOSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> Some or all of the user information is absent.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>USERINFOSTATE_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One
///    of the function parameters was invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>USERINFOSTATE_MOREDATA</b></dt> </dl> </td> <td width="60%"> A buffer is too small to hold the requested
///    data. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>USERINFOSTATE_PRESENT</b></dt> </dl> </td> <td width="60%">
///    The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>USERINFOSTATE_UNKNOWN</b></dt>
///    </dl> </td> <td width="60%"> The product code does not identify a known product. </td> </tr> </table> <div>
///    </div>
///    
@DllImport("msi")
USERINFOSTATE MsiGetUserInfoA(const(char)* szProduct, const(char)* lpUserNameBuf, uint* pcchUserNameBuf, 
                              const(char)* lpOrgNameBuf, uint* pcchOrgNameBuf, const(char)* lpSerialBuf, 
                              uint* pcchSerialBuf);

///The <b>MsiGetUserInfo</b> function returns the registered user information for an installed product.
///Params:
///    szProduct = Specifies the product code for the product to be queried.
///    lpUserNameBuf = Pointer to a variable that receives the name of the user.
///    pcchUserNameBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the
///                      <i>lpUserNameBuf</i> parameter. This size should include the terminating null character.
///    lpOrgNameBuf = Pointer to a buffer that receives the organization name.
///    pcchOrgNameBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpOrgNameBuf</i>
///                     parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                     the buffer passed in is too small, the count returned does not include the terminating null character.
///    lpSerialBuf = Pointer to a buffer that receives the product ID.
///    pcchSerialBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpSerialBuf</i>
///                    parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                    the buffer passed in is too small, the count returned does not include the terminating null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>USERINFOSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> Some or all of the user information is absent.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>USERINFOSTATE_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One
///    of the function parameters was invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>USERINFOSTATE_MOREDATA</b></dt> </dl> </td> <td width="60%"> A buffer is too small to hold the requested
///    data. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>USERINFOSTATE_PRESENT</b></dt> </dl> </td> <td width="60%">
///    The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>USERINFOSTATE_UNKNOWN</b></dt>
///    </dl> </td> <td width="60%"> The product code does not identify a known product. </td> </tr> </table> <div>
///    </div>
///    
@DllImport("msi")
USERINFOSTATE MsiGetUserInfoW(const(wchar)* szProduct, const(wchar)* lpUserNameBuf, uint* pcchUserNameBuf, 
                              const(wchar)* lpOrgNameBuf, uint* pcchOrgNameBuf, const(wchar)* lpSerialBuf, 
                              uint* pcchSerialBuf);

///The <b>MsiCollectUserInfo</b> function obtains and stores the user information and product ID from an installation
///wizard.
///Params:
///    szProduct = Specifies the product code of the product for which the user information is collected.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error relating to an action</b></dt> </dl>
///    </td> <td width="60%"> See Error Codes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization
///    Error</b></dt> </dl> </td> <td width="60%"> An error relating to initialization occurred. </td> </tr> </table>
///    <div> </div>
///    
@DllImport("msi")
uint MsiCollectUserInfoA(const(char)* szProduct);

///The <b>MsiCollectUserInfo</b> function obtains and stores the user information and product ID from an installation
///wizard.
///Params:
///    szProduct = Specifies the product code of the product for which the user information is collected.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error relating to an action</b></dt> </dl>
///    </td> <td width="60%"> See Error Codes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization
///    Error</b></dt> </dl> </td> <td width="60%"> An error relating to initialization occurred. </td> </tr> </table>
///    <div> </div>
///    
@DllImport("msi")
uint MsiCollectUserInfoW(const(wchar)* szProduct);

///For each product listed by the patch package as eligible to receive the patch, the <b>MsiApplyPatch</b> function
///invokes an installation and sets the PATCH property to the path of the patch package.
///Params:
///    szPatchPackage = A null-terminated string specifying the full path to the patch package.
///    szInstallPackage = If <i>eInstallType</i> is set to INSTALLTYPE_NETWORK_IMAGE, this parameter is a null-terminated string that
///                       specifies a path to the product that is to be patched. The installer applies the patch to every eligible product
///                       listed in the patch package if <i>szInstallPackage</i> is set to null and <i>eInstallType</i> is set to
///                       INSTALLTYPE_DEFAULT. If <i>eInstallType</i> is INSTALLTYPE_SINGLE_INSTANCE, the installer applies the patch to
///                       the product specified by <i>szInstallPackage</i>. In this case, other eligible products listed in the patch
///                       package are ignored and the <i>szInstallPackage</i> parameter contains the null-terminated string representing
///                       the product code of the instance to patch. This type of installation requires the installer running Windows
///                       Server 2003 or Windows XP.
///    eInstallType = This parameter specifies the type of installation to patch. <table> <tr> <th>Type of installation</th>
///                   <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLTYPE_NETWORK_IMAGE"></a><a
///                   id="installtype_network_image"></a><dl> <dt><b>INSTALLTYPE_NETWORK_IMAGE</b></dt> </dl> </td> <td width="60%">
///                   Specifies an administrative installation. In this case, <i>szInstallPackage</i> must be set to a package path. A
///                   value of 1 for INSTALLTYPE_NETWORK_IMAGE sets this for an administrative installation. </td> </tr> <tr> <td
///                   width="40%"><a id="INSTALLTYPE_DEFAULT"></a><a id="installtype_default"></a><dl>
///                   <dt><b>INSTALLTYPE_DEFAULT</b></dt> </dl> </td> <td width="60%"> Searches system for products to patch. In this
///                   case, <i>szInstallPackage</i> must be 0. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLTYPE_SINGLE_INSTANCE"></a><a id="installtype_single_instance"></a><dl>
///                   <dt><b>INSTALLTYPE_SINGLE_INSTANCE</b></dt> </dl> </td> <td width="60%"> Patch the product specified by
///                   <i>szInstallPackage</i>. <i>szInstallPackage</i> is the product code of the instance to patch. This type of
///                   installation requires the installer running Windows Server 2003 or Windows XP with SP1. For more information see,
///                   Installing Multiple Instances of Products and Patches. </td> </tr> </table>
///    szCommandLine = A null-terminated string that specifies command line property settings. See About Properties and Setting Public
///                    Property Values on the Command Line. See the Remarks section.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATCH_PACKAGE_OPEN_FAILED</b></dt> </dl> </td> <td width="60%"> Patch package could not be opened.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_PACKAGE_INVALID</b></dt> </dl> </td> <td width="60%">
///    The patch package is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATCH_PACKAGE_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> The patch package is unsupported.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error relating to an action</b></dt> </dl> </td> <td
///    width="60%"> See Error Codes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization Error</b></dt> </dl>
///    </td> <td width="60%"> An initialization error occurred. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiApplyPatchA(const(char)* szPatchPackage, const(char)* szInstallPackage, INSTALLTYPE eInstallType, 
                    const(char)* szCommandLine);

///For each product listed by the patch package as eligible to receive the patch, the <b>MsiApplyPatch</b> function
///invokes an installation and sets the PATCH property to the path of the patch package.
///Params:
///    szPatchPackage = A null-terminated string specifying the full path to the patch package.
///    szInstallPackage = If <i>eInstallType</i> is set to INSTALLTYPE_NETWORK_IMAGE, this parameter is a null-terminated string that
///                       specifies a path to the product that is to be patched. The installer applies the patch to every eligible product
///                       listed in the patch package if <i>szInstallPackage</i> is set to null and <i>eInstallType</i> is set to
///                       INSTALLTYPE_DEFAULT. If <i>eInstallType</i> is INSTALLTYPE_SINGLE_INSTANCE, the installer applies the patch to
///                       the product specified by <i>szInstallPackage</i>. In this case, other eligible products listed in the patch
///                       package are ignored and the <i>szInstallPackage</i> parameter contains the null-terminated string representing
///                       the product code of the instance to patch. This type of installation requires the installer running Windows
///                       Server 2003 or Windows XP.
///    eInstallType = This parameter specifies the type of installation to patch. <table> <tr> <th>Type of installation</th>
///                   <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLTYPE_NETWORK_IMAGE"></a><a
///                   id="installtype_network_image"></a><dl> <dt><b>INSTALLTYPE_NETWORK_IMAGE</b></dt> </dl> </td> <td width="60%">
///                   Specifies an administrative installation. In this case, <i>szInstallPackage</i> must be set to a package path. A
///                   value of 1 for INSTALLTYPE_NETWORK_IMAGE sets this for an administrative installation. </td> </tr> <tr> <td
///                   width="40%"><a id="INSTALLTYPE_DEFAULT"></a><a id="installtype_default"></a><dl>
///                   <dt><b>INSTALLTYPE_DEFAULT</b></dt> </dl> </td> <td width="60%"> Searches system for products to patch. In this
///                   case, <i>szInstallPackage</i> must be 0. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLTYPE_SINGLE_INSTANCE"></a><a id="installtype_single_instance"></a><dl>
///                   <dt><b>INSTALLTYPE_SINGLE_INSTANCE</b></dt> </dl> </td> <td width="60%"> Patch the product specified by
///                   <i>szInstallPackage</i>. <i>szInstallPackage</i> is the product code of the instance to patch. This type of
///                   installation requires the installer running Windows Server 2003 or Windows XP with SP1. For more information see,
///                   Installing Multiple Instances of Products and Patches. </td> </tr> </table>
///    szCommandLine = A null-terminated string that specifies command line property settings. See About Properties and Setting Public
///                    Property Values on the Command Line. See the Remarks section.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATCH_PACKAGE_OPEN_FAILED</b></dt> </dl> </td> <td width="60%"> Patch package could not be opened.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_PACKAGE_INVALID</b></dt> </dl> </td> <td width="60%">
///    The patch package is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATCH_PACKAGE_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> The patch package is unsupported.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error relating to an action</b></dt> </dl> </td> <td
///    width="60%"> See Error Codes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization Error</b></dt> </dl>
///    </td> <td width="60%"> An initialization error occurred. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiApplyPatchW(const(wchar)* szPatchPackage, const(wchar)* szInstallPackage, INSTALLTYPE eInstallType, 
                    const(wchar)* szCommandLine);

///The <b>MsiGetPatchInfo</b> function returns information about a patch.
///Params:
///    szPatch = Specifies the patch code for the patch package.
///    szAttribute = Specifies the attribute to be retrieved. <table> <tr> <th>Attribute</th> <th>Meaning</th> </tr> <tr> <td
///                  width="40%"><a id="INSTALLPROPERTY_LOCALPACKAGE"></a><a id="installproperty_localpackage"></a><dl>
///                  <dt><b>INSTALLPROPERTY_LOCALPACKAGE</b></dt> </dl> </td> <td width="60%"> Local cached package. </td> </tr>
///                  </table>
///    lpValueBuf = Pointer to a buffer that receives the property value. This parameter can be null.
///    pcchValueBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpValueBuf</i>
///                   parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                   the buffer passed in is too small, the count returned does not include the terminating null character. If
///                   <i>lpValueBuf</i> is null, <i>pcchValueBuf</i> can be null.
///Returns:
///    The <b>MsiGetPatchInfo</b> function returns the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The
///    configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt>
///    </dl> </td> <td width="60%"> An invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> A buffer is too small to hold the requested
///    data. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt>
///    </dl> </td> <td width="60%"> The patch package is not installed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PROPERTY</b></dt> </dl> </td> <td width="60%"> The property is unrecognized. </td> </tr>
///    </table> <div> </div>
///    
@DllImport("msi")
uint MsiGetPatchInfoA(const(char)* szPatch, const(char)* szAttribute, const(char)* lpValueBuf, uint* pcchValueBuf);

///The <b>MsiGetPatchInfo</b> function returns information about a patch.
///Params:
///    szPatch = Specifies the patch code for the patch package.
///    szAttribute = Specifies the attribute to be retrieved. <table> <tr> <th>Attribute</th> <th>Meaning</th> </tr> <tr> <td
///                  width="40%"><a id="INSTALLPROPERTY_LOCALPACKAGE"></a><a id="installproperty_localpackage"></a><dl>
///                  <dt><b>INSTALLPROPERTY_LOCALPACKAGE</b></dt> </dl> </td> <td width="60%"> Local cached package. </td> </tr>
///                  </table>
///    lpValueBuf = Pointer to a buffer that receives the property value. This parameter can be null.
///    pcchValueBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpValueBuf</i>
///                   parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                   the buffer passed in is too small, the count returned does not include the terminating null character. If
///                   <i>lpValueBuf</i> is null, <i>pcchValueBuf</i> can be null.
///Returns:
///    The <b>MsiGetPatchInfo</b> function returns the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The
///    configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt>
///    </dl> </td> <td width="60%"> An invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> A buffer is too small to hold the requested
///    data. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt>
///    </dl> </td> <td width="60%"> The patch package is not installed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PROPERTY</b></dt> </dl> </td> <td width="60%"> The property is unrecognized. </td> </tr>
///    </table> <div> </div>
///    
@DllImport("msi")
uint MsiGetPatchInfoW(const(wchar)* szPatch, const(wchar)* szAttribute, const(wchar)* lpValueBuf, 
                      uint* pcchValueBuf);

///The <b>MsiEnumPatches</b> function enumerates all of the patches that have been applied to a product. The function
///returns the patch code GUID for each patch that has been applied to the product and returns a list of transforms from
///each patch that apply to the product. Note that patches may have many transforms only some of which are applicable to
///a particular product. The list of transforms are returned in the same format as the value of the TRANSFORMS property.
///<div class="alert"><b>Note</b> <i>pcchTransformsBuf</i> is not set to the number of characters copied to
///<i>lpTransformsBuf</i> upon a successful return of <b>MsiEnumPatches</b>.</div><div> </div>
///Params:
///    szProduct = Specifies the product code of the product for which patches are to be enumerated.
///    iPatchIndex = Specifies the index of the patch to retrieve. This parameter should be zero for the first call to the
///                  <b>MsiEnumPatches</b> function and then incremented for subsequent calls.
///    lpPatchBuf = Pointer to a buffer that receives the patch's GUID. This argument is required.
///    lpTransformsBuf = Pointer to a buffer that receives the list of transforms in the patch that are applicable to the product. This
///                      argument is required and cannot be Null.
///    pcchTransformsBuf = Set to the number of characters copied to <i>lpTransformsBuf</i> upon an unsuccessful return of the function. Not
///                        set for a successful return. On input, this is the full size of the buffer, including a space for a terminating
///                        null character. If the buffer passed in is too small, the count returned does not include the terminating null
///                        character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
///    </dl> </td> <td width="60%"> There are no patches to return. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was enumerated. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> A buffer is too small to hold the
///    requested data. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumPatchesA(const(char)* szProduct, uint iPatchIndex, const(char)* lpPatchBuf, 
                     const(char)* lpTransformsBuf, uint* pcchTransformsBuf);

///The <b>MsiEnumPatches</b> function enumerates all of the patches that have been applied to a product. The function
///returns the patch code GUID for each patch that has been applied to the product and returns a list of transforms from
///each patch that apply to the product. Note that patches may have many transforms only some of which are applicable to
///a particular product. The list of transforms are returned in the same format as the value of the TRANSFORMS property.
///<div class="alert"><b>Note</b> <i>pcchTransformsBuf</i> is not set to the number of characters copied to
///<i>lpTransformsBuf</i> upon a successful return of <b>MsiEnumPatches</b>.</div><div> </div>
///Params:
///    szProduct = Specifies the product code of the product for which patches are to be enumerated.
///    iPatchIndex = Specifies the index of the patch to retrieve. This parameter should be zero for the first call to the
///                  <b>MsiEnumPatches</b> function and then incremented for subsequent calls.
///    lpPatchBuf = Pointer to a buffer that receives the patch's GUID. This argument is required.
///    lpTransformsBuf = Pointer to a buffer that receives the list of transforms in the patch that are applicable to the product. This
///                      argument is required and cannot be Null.
///    pcchTransformsBuf = Set to the number of characters copied to <i>lpTransformsBuf</i> upon an unsuccessful return of the function. Not
///                        set for a successful return. On input, this is the full size of the buffer, including a space for a terminating
///                        null character. If the buffer passed in is too small, the count returned does not include the terminating null
///                        character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
///    </dl> </td> <td width="60%"> There are no patches to return. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was enumerated. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> A buffer is too small to hold the
///    requested data. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumPatchesW(const(wchar)* szProduct, uint iPatchIndex, const(wchar)* lpPatchBuf, 
                     const(wchar)* lpTransformsBuf, uint* pcchTransformsBuf);

///The <b>MsiRemovePatches</b> function removes one or more patches from a single product. To remove a patch from
///multiple products, <b>MsiRemovePatches</b> must be called for each product.
///Params:
///    szPatchList = A null-terminated string that represents the list of patches to remove. Each patch can be specified by the GUID
///                  of the patch or the full path to the patch package. The patches in the list are delimited by semicolons.
///    szProductCode = A null-terminated string that is the ProductCode (GUID) of the product from which the patches are removed. This
///                    parameter cannot be <b>NULL</b>.
///    eUninstallType = Value that indicates the type of patch removal to perform. This parameter must be
///                     <b>INSTALLTYPE_SINGLE_INSTANCE</b>. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                     id="INSTALLTYPE_SINGLE_INSTANCE"></a><a id="installtype_single_instance"></a><dl>
///                     <dt><b>INSTALLTYPE_SINGLE_INSTANCE</b></dt> </dl> </td> <td width="60%"> The patch is uninstalled for only the
///                     product specified by <i>szProduct</i>. </td> </tr> </table>
///    szPropertyList = A null-terminated string that specifies command-line property settings. For more information see About Properties
///                     and Setting Public Property Values on the Command Line. This parameter can be <b>NULL</b>.
///Returns:
///    The <b>MsiRemovePatches</b> function returns the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was included. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_PACKAGE_OPEN_FAILED</b></dt>
///    </dl> </td> <td width="60%"> The patch package could not be opened. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The patch was successfully removed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product specified by
///    <i>szProductList</i> is not installed either per-machine or per-user for the caller of MsiRemovePatches. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_PACKAGE_OPEN_FAILED</b></dt> </dl> </td> <td width="60%"> The
///    patch package could not be opened. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATCH_PACKAGE_INVALID</b></dt> </dl> </td> <td width="60%"> The patch package is invalid. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_PACKAGE_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> The
///    patch package cannot be processed by this version of the Windows Installer service. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_PATCH_REMOVAL_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> The patch package
///    is not removable. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td
///    width="60%"> The patch has not been applied to this product. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATCH_REMOVAL_DISALLOWED</b></dt> </dl> </td> <td width="60%"> Patch removal was disallowed by
///    policy. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiRemovePatchesA(const(char)* szPatchList, const(char)* szProductCode, INSTALLTYPE eUninstallType, 
                       const(char)* szPropertyList);

///The <b>MsiRemovePatches</b> function removes one or more patches from a single product. To remove a patch from
///multiple products, <b>MsiRemovePatches</b> must be called for each product.
///Params:
///    szPatchList = A null-terminated string that represents the list of patches to remove. Each patch can be specified by the GUID
///                  of the patch or the full path to the patch package. The patches in the list are delimited by semicolons.
///    szProductCode = A null-terminated string that is the ProductCode (GUID) of the product from which the patches are removed. This
///                    parameter cannot be <b>NULL</b>.
///    eUninstallType = Value that indicates the type of patch removal to perform. This parameter must be
///                     <b>INSTALLTYPE_SINGLE_INSTANCE</b>. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                     id="INSTALLTYPE_SINGLE_INSTANCE"></a><a id="installtype_single_instance"></a><dl>
///                     <dt><b>INSTALLTYPE_SINGLE_INSTANCE</b></dt> </dl> </td> <td width="60%"> The patch is uninstalled for only the
///                     product specified by <i>szProduct</i>. </td> </tr> </table>
///    szPropertyList = A null-terminated string that specifies command-line property settings. For more information see About Properties
///                     and Setting Public Property Values on the Command Line. This parameter can be <b>NULL</b>.
///Returns:
///    The <b>MsiRemovePatches</b> function returns the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was included. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_PACKAGE_OPEN_FAILED</b></dt>
///    </dl> </td> <td width="60%"> The patch package could not be opened. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The patch was successfully removed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product specified by
///    <i>szProductList</i> is not installed either per-machine or per-user for the caller of MsiRemovePatches. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_PACKAGE_OPEN_FAILED</b></dt> </dl> </td> <td width="60%"> The
///    patch package could not be opened. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATCH_PACKAGE_INVALID</b></dt> </dl> </td> <td width="60%"> The patch package is invalid. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_PACKAGE_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> The
///    patch package cannot be processed by this version of the Windows Installer service. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_PATCH_REMOVAL_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> The patch package
///    is not removable. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td
///    width="60%"> The patch has not been applied to this product. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATCH_REMOVAL_DISALLOWED</b></dt> </dl> </td> <td width="60%"> Patch removal was disallowed by
///    policy. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiRemovePatchesW(const(wchar)* szPatchList, const(wchar)* szProductCode, INSTALLTYPE eUninstallType, 
                       const(wchar)* szPropertyList);

///The <b>MsiExtractPatchXMLData</b> function extracts information from a patch that can be used to determine if the
///patch applies to a target system. The function returns an XML string that can be provided to
///MsiDeterminePatchSequence and MsiDetermineApplicablePatches instead of the full patch file. The returned information
///can be used to determine whether the patch is applicable.
///Params:
///    szPatchPath = The full path to the patch that is being queried. Pass in as a null-terminated string. This parameter cannot be
///                  <b>NULL</b>.
///    dwReserved = A reserved argument that must be 0 (zero).
///    szXMLData = A pointer to a buffer to hold the XML string that contains the extracted patch information. This buffer should be
///                large enough to contain the received information. If the buffer is too small, the function returns
///                ERROR_MORE_DATA and sets *<i>pcchXMLData</i> to the number of <b>TCHAR</b> in the value, not including the
///                terminating NULL character. If <i>szXMLData</i> is set to <b>NULL</b> and <i>pcchXMLData</i> is set to a valid
///                pointer, the function returns ERROR_SUCCESS and sets *<i>pcchXMLData</i> to the number of <b>TCHAR</b> in the
///                value, not including the terminating NULL character. The function can then be called again to retrieve the value,
///                with <i>szXMLData</i> buffer large enough to contain *<i>pcchXMLData</i> + 1 characters.
///    pcchXMLData = A pointer to a variable that specifies the number of <b>TCHAR</b> in the <i>szXMLData</i> buffer. When the
///                  function returns, this parameter is set to the size of the requested value whether or not the function copies the
///                  value into the specified buffer. The size is returned as the number of <b>TCHAR</b> in the requested value, not
///                  including the terminating null character. If this parameter is set to <b>NULL</b>, the function returns
///                  ERROR_INVALID_PARAMETER.
///Returns:
///    The <b>MsiExtractPatchXMLData</b> function can return the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> The function failed in a way that is not identified by any of the return values in this table. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt>
///    </dl> </td> <td width="60%"> The value does not fit in the provided buffer. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_PATCH_OPEN_FAILED</b></dt> </dl> </td> <td width="60%"> The patch file could not be opened.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function
///    was successful. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_PACKAGE_INVALID</b></dt> </dl> </td>
///    <td width="60%"> The patch file could not be opened. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> This error can be returned if MSXML 3.0
///    is not installed. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiExtractPatchXMLDataA(const(char)* szPatchPath, uint dwReserved, const(char)* szXMLData, uint* pcchXMLData);

///The <b>MsiExtractPatchXMLData</b> function extracts information from a patch that can be used to determine if the
///patch applies to a target system. The function returns an XML string that can be provided to
///MsiDeterminePatchSequence and MsiDetermineApplicablePatches instead of the full patch file. The returned information
///can be used to determine whether the patch is applicable.
///Params:
///    szPatchPath = The full path to the patch that is being queried. Pass in as a null-terminated string. This parameter cannot be
///                  <b>NULL</b>.
///    dwReserved = A reserved argument that must be 0 (zero).
///    szXMLData = A pointer to a buffer to hold the XML string that contains the extracted patch information. This buffer should be
///                large enough to contain the received information. If the buffer is too small, the function returns
///                ERROR_MORE_DATA and sets *<i>pcchXMLData</i> to the number of <b>TCHAR</b> in the value, not including the
///                terminating NULL character. If <i>szXMLData</i> is set to <b>NULL</b> and <i>pcchXMLData</i> is set to a valid
///                pointer, the function returns ERROR_SUCCESS and sets *<i>pcchXMLData</i> to the number of <b>TCHAR</b> in the
///                value, not including the terminating NULL character. The function can then be called again to retrieve the value,
///                with <i>szXMLData</i> buffer large enough to contain *<i>pcchXMLData</i> + 1 characters.
///    pcchXMLData = A pointer to a variable that specifies the number of <b>TCHAR</b> in the <i>szXMLData</i> buffer. When the
///                  function returns, this parameter is set to the size of the requested value whether or not the function copies the
///                  value into the specified buffer. The size is returned as the number of <b>TCHAR</b> in the requested value, not
///                  including the terminating null character. If this parameter is set to <b>NULL</b>, the function returns
///                  ERROR_INVALID_PARAMETER.
///Returns:
///    The <b>MsiExtractPatchXMLData</b> function can return the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> The function failed in a way that is not identified by any of the return values in this table. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt>
///    </dl> </td> <td width="60%"> The value does not fit in the provided buffer. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_PATCH_OPEN_FAILED</b></dt> </dl> </td> <td width="60%"> The patch file could not be opened.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function
///    was successful. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_PACKAGE_INVALID</b></dt> </dl> </td>
///    <td width="60%"> The patch file could not be opened. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> This error can be returned if MSXML 3.0
///    is not installed. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiExtractPatchXMLDataW(const(wchar)* szPatchPath, uint dwReserved, const(wchar)* szXMLData, 
                             uint* pcchXMLData);

///The <b>MsiGetPatchInfoEx</b> function queries for information about the application of a patch to a specified
///instance of a product.
///Params:
///    szPatchCode = A null-terminated string that contains the GUID of the patch. This parameter cannot be <b>NULL</b>.
///    szProductCode = A null-terminated string that contains the ProductCode GUID of the product instance. This parameter cannot be
///                    <b>NULL</b>.
///    szUserSid = A null-terminated string that specifies the security identifier (SID) under which the instance of the patch being
///                queried exists. Using a <b>NULL</b> value specifies the current user. <table> <tr> <th>SID</th> <th>Meaning</th>
///                </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td
///                width="60%"> Specifies the user that is logged on. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a
///                id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> Specifies the
///                enumeration for a specific user ID in the system. The following example identifies a possible user SID:
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div class="alert"><b>Note</b> The special
///                SID string "S-1-5-18" (system) cannot be used to enumerate products installed as per-machine. If <i>dwContext</i>
///                is <b>MSIINSTALLCONTEXT_MACHINE</b>, <i>szUserSid</i> must be <b>NULL</b>.</div> <div> </div>
///    dwContext = Restricts the enumeration to a per-user-unmanaged, per-user-managed, or per-machine context. This parameter can
///                be any one of the following values. <table> <tr> <th>Context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Query that is extended to
///                all peruser-managed installations for the users that <i>szUserSid</i> specifies. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Query that is extended to
///                all peruser-unmanaged installations for the users that <i>szUserSid</i> specifies. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Query that is extended to all
///                per-machine installations. </td> </tr> </table>
///    szProperty = A null-terminated string that specifies the property value to retrieve. The <i>szProperty</i> parameter can be
///                 one of the following: <table> <tr> <th>Name</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_LOCALPACKAGE"></a><a id="installproperty_localpackage"></a><dl>
///                 <dt><b>INSTALLPROPERTY_LOCALPACKAGE</b></dt> <dt>"LocalPackage"</dt> </dl> </td> <td width="60%"> Gets the cached
///                 patch file that the product uses. </td> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_TRANSFORMS"></a><a
///                 id="installproperty_transforms"></a><dl> <dt><b>INSTALLPROPERTY_TRANSFORMS</b></dt> <dt>"Transforms"</dt> </dl>
///                 </td> <td width="60%"> Gets the set of patch transforms that the last patch installation applied to the product.
///                 This value may not be available for per-user, non-managed applications if the user is not logged on. </td> </tr>
///                 <tr> <td width="40%"><a id="INSTALLPROPERTY_INSTALLDATE"></a><a id="installproperty_installdate"></a><dl>
///                 <dt><b>INSTALLPROPERTY_INSTALLDATE</b></dt> <dt>"InstallDate"</dt> </dl> </td> <td width="60%"> Gets the last
///                 time this product received service. The value of this property is replaced each time a patch is applied or
///                 removed from the product or the /v Command-Line Option is used to repair the product. If the product has received
///                 no repairs or patches this property contains the time this product was installed on this computer. </td> </tr>
///                 <tr> <td width="40%"><a id="INSTALLPROPERTY_UNINSTALLABLE"></a><a id="installproperty_uninstallable"></a><dl>
///                 <dt><b>INSTALLPROPERTY_UNINSTALLABLE</b></dt> <dt>"Uninstallable"</dt> </dl> </td> <td width="60%"> Returns "1"
///                 if the patch is marked as possible to uninstall from the product. In this case, the installer can still block the
///                 uninstallation if this patch is required by another patch that cannot be uninstalled. </td> </tr> <tr> <td
///                 width="40%"><a id="INSTALLPROPERTY_PATCHSTATE"></a><a id="installproperty_patchstate"></a><dl>
///                 <dt><b>INSTALLPROPERTY_PATCHSTATE</b></dt> <dt>"State"</dt> </dl> </td> <td width="60%"> Returns "1" if this
///                 patch is currently applied to the product. Returns "2" if this patch is superseded by another patch. Returns "4"
///                 if this patch is obsolete. These values correspond to the constants the <i>dwFilter</i> parameter of
///                 MsiEnumPatchesEx uses. </td> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_DISPLAYNAME"></a><a
///                 id="installproperty_displayname"></a><dl> <dt><b>INSTALLPROPERTY_DISPLAYNAME</b></dt> <dt>"DisplayName"</dt>
///                 </dl> </td> <td width="60%"> Get the registered display name for the patch. For patches that do not include the
///                 DisplayName property in the MsiPatchMetadata table, the returned display name is an empty string (""). </td>
///                 </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_MOREINFOURL"></a><a id="installproperty_moreinfourl"></a><dl>
///                 <dt><b>INSTALLPROPERTY_MOREINFOURL</b></dt> <dt>"MoreInfoURL"</dt> </dl> </td> <td width="60%"> Get the
///                 registered support information URL for the patch. For patches that do not include the MoreInfoURL property in the
///                 MsiPatchMetadata table, the returned support information URL is an empty string (""). </td> </tr> </table>
///    lpValue = This parameter is a pointer to a buffer that receives the property value. This buffer should be large enough to
///              contain the information. If the buffer is too small, the function returns <b>ERROR_MORE_DATA</b> and sets
///              *<i>pcchValue</i> to the number of <b>TCHAR</b> in the property value, not including the terminating <b>NULL</b>
///              character. If <i>lpValue</i> is set to <b>NULL</b> and <i>pcchValue</i> is set to a valid pointer, the function
///              returns <b>ERROR_SUCCESS</b> and sets *<i>pcchValue</i> to the number of <b>TCHAR</b> in the value, not including
///              the terminating <b>NULL</b> character. The function can then be called again to retrieve the value, with
///              <i>lpValue</i> buffer large enough to contain *<i>pcchValue</i> + 1 characters. If <i>lpValue</i> and
///              <i>pcchValue</i> are both set to <b>NULL</b>, the function returns <b>ERROR_SUCCESS</b> if the value exists,
///              without retrieving the value.
///    pcchValue = When calling the function, this parameter should be a pointer to a variable that specifies the number of
///                <b>TCHAR</b> in the <i>lpValue</i> buffer. When the function returns, this parameter is set to the size of the
///                requested value whether or not the function copies the value into the specified buffer. The size is returned as
///                the number of <b>TCHAR</b> in the requested value, not including the terminating null character. This parameter
///                can be set to <b>NULL</b> only if <i>lpValue</i> is also <b>NULL</b>. Otherwise, the function returns
///                <b>ERROR_INVALID_PARAMETER</b>.
///Returns:
///    The <b>MsiGetPatchInfoEx</b> function returns the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The function fails trying to access a resource with insufficient privileges. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is
///    corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> The function fails and the error is not identified in other error codes. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is
///    passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td
///    width="60%"> The value does not fit in the provided buffer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The patch is enumerated successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product that
///    <i>szProduct</i> specifies is not installed on the computer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PROPERTY</b></dt> </dl> </td> <td width="60%"> The property is unrecognized. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The patch is
///    unrecognized. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiGetPatchInfoExA(const(char)* szPatchCode, const(char)* szProductCode, const(char)* szUserSid, 
                        MSIINSTALLCONTEXT dwContext, const(char)* szProperty, const(char)* lpValue, uint* pcchValue);

///The <b>MsiGetPatchInfoEx</b> function queries for information about the application of a patch to a specified
///instance of a product.
///Params:
///    szPatchCode = A null-terminated string that contains the GUID of the patch. This parameter cannot be <b>NULL</b>.
///    szProductCode = A null-terminated string that contains the ProductCode GUID of the product instance. This parameter cannot be
///                    <b>NULL</b>.
///    szUserSid = A null-terminated string that specifies the security identifier (SID) under which the instance of the patch being
///                queried exists. Using a <b>NULL</b> value specifies the current user. <table> <tr> <th>SID</th> <th>Meaning</th>
///                </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td
///                width="60%"> Specifies the user that is logged on. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a
///                id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> Specifies the
///                enumeration for a specific user ID in the system. The following example identifies a possible user SID:
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div class="alert"><b>Note</b> The special
///                SID string "S-1-5-18" (system) cannot be used to enumerate products installed as per-machine. If <i>dwContext</i>
///                is <b>MSIINSTALLCONTEXT_MACHINE</b>, <i>szUserSid</i> must be <b>NULL</b>.</div> <div> </div>
///    dwContext = Restricts the enumeration to a per-user-unmanaged, per-user-managed, or per-machine context. This parameter can
///                be any one of the following values. <table> <tr> <th>Context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Query that is extended to
///                all peruser-managed installations for the users that <i>szUserSid</i> specifies. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Query that is extended to
///                all peruser-unmanaged installations for the users that <i>szUserSid</i> specifies. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Query that is extended to all
///                per-machine installations. </td> </tr> </table>
///    szProperty = A null-terminated string that specifies the property value to retrieve. The <i>szProperty</i> parameter can be
///                 one of the following: <table> <tr> <th>Name</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_LOCALPACKAGE"></a><a id="installproperty_localpackage"></a><dl>
///                 <dt><b>INSTALLPROPERTY_LOCALPACKAGE</b></dt> <dt>"LocalPackage"</dt> </dl> </td> <td width="60%"> Gets the cached
///                 patch file that the product uses. </td> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_TRANSFORMS"></a><a
///                 id="installproperty_transforms"></a><dl> <dt><b>INSTALLPROPERTY_TRANSFORMS</b></dt> <dt>"Transforms"</dt> </dl>
///                 </td> <td width="60%"> Gets the set of patch transforms that the last patch installation applied to the product.
///                 This value may not be available for per-user, non-managed applications if the user is not logged on. </td> </tr>
///                 <tr> <td width="40%"><a id="INSTALLPROPERTY_INSTALLDATE"></a><a id="installproperty_installdate"></a><dl>
///                 <dt><b>INSTALLPROPERTY_INSTALLDATE</b></dt> <dt>"InstallDate"</dt> </dl> </td> <td width="60%"> Gets the last
///                 time this product received service. The value of this property is replaced each time a patch is applied or
///                 removed from the product or the /v Command-Line Option is used to repair the product. If the product has received
///                 no repairs or patches this property contains the time this product was installed on this computer. </td> </tr>
///                 <tr> <td width="40%"><a id="INSTALLPROPERTY_UNINSTALLABLE"></a><a id="installproperty_uninstallable"></a><dl>
///                 <dt><b>INSTALLPROPERTY_UNINSTALLABLE</b></dt> <dt>"Uninstallable"</dt> </dl> </td> <td width="60%"> Returns "1"
///                 if the patch is marked as possible to uninstall from the product. In this case, the installer can still block the
///                 uninstallation if this patch is required by another patch that cannot be uninstalled. </td> </tr> <tr> <td
///                 width="40%"><a id="INSTALLPROPERTY_PATCHSTATE"></a><a id="installproperty_patchstate"></a><dl>
///                 <dt><b>INSTALLPROPERTY_PATCHSTATE</b></dt> <dt>"State"</dt> </dl> </td> <td width="60%"> Returns "1" if this
///                 patch is currently applied to the product. Returns "2" if this patch is superseded by another patch. Returns "4"
///                 if this patch is obsolete. These values correspond to the constants the <i>dwFilter</i> parameter of
///                 MsiEnumPatchesEx uses. </td> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_DISPLAYNAME"></a><a
///                 id="installproperty_displayname"></a><dl> <dt><b>INSTALLPROPERTY_DISPLAYNAME</b></dt> <dt>"DisplayName"</dt>
///                 </dl> </td> <td width="60%"> Get the registered display name for the patch. For patches that do not include the
///                 DisplayName property in the MsiPatchMetadata table, the returned display name is an empty string (""). </td>
///                 </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_MOREINFOURL"></a><a id="installproperty_moreinfourl"></a><dl>
///                 <dt><b>INSTALLPROPERTY_MOREINFOURL</b></dt> <dt>"MoreInfoURL"</dt> </dl> </td> <td width="60%"> Get the
///                 registered support information URL for the patch. For patches that do not include the MoreInfoURL property in the
///                 MsiPatchMetadata table, the returned support information URL is an empty string (""). </td> </tr> </table>
///    lpValue = This parameter is a pointer to a buffer that receives the property value. This buffer should be large enough to
///              contain the information. If the buffer is too small, the function returns <b>ERROR_MORE_DATA</b> and sets
///              *<i>pcchValue</i> to the number of <b>TCHAR</b> in the property value, not including the terminating <b>NULL</b>
///              character. If <i>lpValue</i> is set to <b>NULL</b> and <i>pcchValue</i> is set to a valid pointer, the function
///              returns <b>ERROR_SUCCESS</b> and sets *<i>pcchValue</i> to the number of <b>TCHAR</b> in the value, not including
///              the terminating <b>NULL</b> character. The function can then be called again to retrieve the value, with
///              <i>lpValue</i> buffer large enough to contain *<i>pcchValue</i> + 1 characters. If <i>lpValue</i> and
///              <i>pcchValue</i> are both set to <b>NULL</b>, the function returns <b>ERROR_SUCCESS</b> if the value exists,
///              without retrieving the value.
///    pcchValue = When calling the function, this parameter should be a pointer to a variable that specifies the number of
///                <b>TCHAR</b> in the <i>lpValue</i> buffer. When the function returns, this parameter is set to the size of the
///                requested value whether or not the function copies the value into the specified buffer. The size is returned as
///                the number of <b>TCHAR</b> in the requested value, not including the terminating null character. This parameter
///                can be set to <b>NULL</b> only if <i>lpValue</i> is also <b>NULL</b>. Otherwise, the function returns
///                <b>ERROR_INVALID_PARAMETER</b>.
///Returns:
///    The <b>MsiGetPatchInfoEx</b> function returns the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The function fails trying to access a resource with insufficient privileges. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is
///    corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> The function fails and the error is not identified in other error codes. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is
///    passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td
///    width="60%"> The value does not fit in the provided buffer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The patch is enumerated successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product that
///    <i>szProduct</i> specifies is not installed on the computer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PROPERTY</b></dt> </dl> </td> <td width="60%"> The property is unrecognized. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The patch is
///    unrecognized. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiGetPatchInfoExW(const(wchar)* szPatchCode, const(wchar)* szProductCode, const(wchar)* szUserSid, 
                        MSIINSTALLCONTEXT dwContext, const(wchar)* szProperty, const(wchar)* lpValue, 
                        uint* pcchValue);

///The <b>MsiApplyMultiplePatches</b> function applies one or more patches to products eligible to receive the patches.
///The <b>MsiApplyMultiplePatches</b> function sets the PATCH property with a list of patches delimited by semicolons
///and invokes the patching of the target products. Other properties can be set using a properties list.
///Params:
///    szPatchPackages = A semicolon-delimited list of the paths to patch files as a single string. For example:
///                      ""c:\sus\download\cache\Office\sp1.msp; c:\sus\download\cache\Office\QFE1.msp;
///                      c:\sus\download\cache\Office\QFEn.msp" "
///    szProductCode = This parameter is the ProductCode GUID of the product to be patched. The user or application calling
///                    <b>MsiApplyMultiplePatches</b> must have privileges to apply patches. When this parameter is <b>NULL</b>, the
///                    patches are applied to all eligible products. When this parameter is non-<b>NULL</b>, the patches are applied
///                    only to the specified product.
///    szPropertiesList = A null-terminated string that specifies commandline property settings used during the patching of products. If
///                       there are no commandline property settings, pass in a <b>NULL</b> pointer. An empty string is an invalid
///                       parameter. These properties are shared by all target products. For more information, see About Properties and
///                       Setting Public Property Values on the Command Line. <div class="alert"><b>Note</b> The properties list should not
///                       contain the PATCH property. If the <b>PATCH</b> property is set in the command line the value is ignored and is
///                       overwritten with the patches being applied.</div> <div> </div>
///Returns:
///    The <b>MsiApplyMultiplePatches</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> Some arguments passed in are incorrect or contradicting. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed and all products are
///    successfully patched. <b>ERROR_SUCCESS</b> is returned only if all the products eligible for the patches are
///    patched successfully. If none of the new patches are applicable, MsiApplyMultiplePatches returns
///    <b>ERROR_SUCCESS</b> and product state remains unchanged. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS_REBOOT_INITIATED</b></dt> </dl> </td> <td width="60%"> The restart initiated by the last
///    transaction terminated this call to MsiApplyMultiplePatches. All the target products may not have been patched.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS_REBOOT_REQUIRED</b></dt> </dl> </td> <td width="60%">
///    The restart required by the last transaction terminated this call to MsiApplyMultiplePatches. All target products
///    may not have been patched. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_PACKAGE_OPEN_FAILED</b></dt>
///    </dl> </td> <td width="60%"> One of the patch packages provide could not be opened. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_PATCH_PACKAGE_INVALID</b></dt> </dl> </td> <td width="60%"> One of the patch
///    packages provide is not a valid one. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATCH_PACKAGE_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> One of the patch packages is
///    unsupported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Any error in Winerror.h</b></dt> </dl> </td> <td
///    width="60%"> Implies possible partial completion or that one or more transactions failed. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiApplyMultiplePatchesA(const(char)* szPatchPackages, const(char)* szProductCode, 
                              const(char)* szPropertiesList);

///The <b>MsiApplyMultiplePatches</b> function applies one or more patches to products eligible to receive the patches.
///The <b>MsiApplyMultiplePatches</b> function sets the PATCH property with a list of patches delimited by semicolons
///and invokes the patching of the target products. Other properties can be set using a properties list.
///Params:
///    szPatchPackages = A semicolon-delimited list of the paths to patch files as a single string. For example:
///                      ""c:\sus\download\cache\Office\sp1.msp; c:\sus\download\cache\Office\QFE1.msp;
///                      c:\sus\download\cache\Office\QFEn.msp" "
///    szProductCode = This parameter is the ProductCode GUID of the product to be patched. The user or application calling
///                    <b>MsiApplyMultiplePatches</b> must have privileges to apply patches. When this parameter is <b>NULL</b>, the
///                    patches are applied to all eligible products. When this parameter is non-<b>NULL</b>, the patches are applied
///                    only to the specified product.
///    szPropertiesList = A null-terminated string that specifies commandline property settings used during the patching of products. If
///                       there are no commandline property settings, pass in a <b>NULL</b> pointer. An empty string is an invalid
///                       parameter. These properties are shared by all target products. For more information, see About Properties and
///                       Setting Public Property Values on the Command Line. <div class="alert"><b>Note</b> The properties list should not
///                       contain the PATCH property. If the <b>PATCH</b> property is set in the command line the value is ignored and is
///                       overwritten with the patches being applied.</div> <div> </div>
///Returns:
///    The <b>MsiApplyMultiplePatches</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> Some arguments passed in are incorrect or contradicting. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed and all products are
///    successfully patched. <b>ERROR_SUCCESS</b> is returned only if all the products eligible for the patches are
///    patched successfully. If none of the new patches are applicable, MsiApplyMultiplePatches returns
///    <b>ERROR_SUCCESS</b> and product state remains unchanged. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS_REBOOT_INITIATED</b></dt> </dl> </td> <td width="60%"> The restart initiated by the last
///    transaction terminated this call to MsiApplyMultiplePatches. All the target products may not have been patched.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS_REBOOT_REQUIRED</b></dt> </dl> </td> <td width="60%">
///    The restart required by the last transaction terminated this call to MsiApplyMultiplePatches. All target products
///    may not have been patched. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_PACKAGE_OPEN_FAILED</b></dt>
///    </dl> </td> <td width="60%"> One of the patch packages provide could not be opened. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_PATCH_PACKAGE_INVALID</b></dt> </dl> </td> <td width="60%"> One of the patch
///    packages provide is not a valid one. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_PATCH_PACKAGE_UNSUPPORTED</b></dt> </dl> </td> <td width="60%"> One of the patch packages is
///    unsupported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Any error in Winerror.h</b></dt> </dl> </td> <td
///    width="60%"> Implies possible partial completion or that one or more transactions failed. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiApplyMultiplePatchesW(const(wchar)* szPatchPackages, const(wchar)* szProductCode, 
                              const(wchar)* szPropertiesList);

///The <b>MsiDeterminePatchSequence</b> function takes a set of patch files, XML files, and XML blobs and determines the
///best sequence of application for the patches to a specified installed product. This function accounts for patches
///that have already been applied to the product and accounts for obsolete and superseded patches.
///Params:
///    szProductCode = The product that is the target for the set of patches. The value must be the ProductCode GUID for the product.
///    szUserSid = Null-terminated string that specifies a security identifier (SID) of a user. This parameter restricts the context
///                of enumeration for this user account. This parameter cannot be the special SID strings "S-1-1-0" (everyone) or
///                "S-1-5-18" (local system). For the machine context <i>dwContext</i> is set to<b> MSIINSTALLCONTEXT_MACHINE</b>
///                and <i>szUserSid</i> must be <b>NULL</b>. For the current user context <i>szUserSid</i> can be null and
///                <i>dwContext</i> can be set to <b>MSIINSTALLCONTEXT_USERMANAGED</b> or <b>MSIINSTALLCONTEXT_USERUNMANAGED</b>.
///    dwContext = Restricts the enumeration to a per-user-unmanaged, per-user-managed, or per-machine context. This parameter can
///                be any one of the following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> Patches are considered for all
///                per-user-managed installations of the product for the user specified by <i>szUserSid</i>. A null <i>szUserSid</i>
///                with this context means the current user. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td width="60%"> Patches are considered for all
///                per-user-unmanaged installations for the user specified by <i>szUserSid</i>. A null <i>szUserSid</i> with this
///                context means the current user. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a
///                id="msiinstallcontext_machine"></a><dl> <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%">
///                Patches are considered for the per-machine installation. When <i>dwContext</i> is set to
///                <b>MSIINSTALLCONTEXT_MACHINE</b> the <i>szUserSid</i> parameter must be null. </td> </tr> </table>
///    cPatchInfo = The number of patches in the array.
///    pPatchInfo = Pointer to an array of MSIPATCHSEQUENCEINFO structures.
///Returns:
///    The <b>MsiDeterminePatchSequence</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> The function failed in a manner not covered in the other error codes. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An argument is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_NO_SEQUENCE</b></dt> </dl> </td> <td width="60%"> No
///    valid sequence could be found for the set of patches. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_PACKAGE_OPEN_FAILED</b></dt> </dl> </td> <td width="60%"> An installation package referenced
///    by path cannot be opened. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td
///    width="60%"> The patches were successfully sorted. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The .msi file was not found. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_PATH_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The path to the .msi file
///    was not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PATCH_XML</b></dt> </dl> </td> <td
///    width="60%"> The XML patch data is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_PACKAGE_INVALID</b></dt> </dl> </td> <td width="60%"> The installation package was invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> A user
///    that is not an administrator attempted to call the function with a context of a different user. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data
///    for a registered patch or product is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The ProductCode GUID specified is not
///    registered. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_NOT_CALLED</b></dt> </dl> </td> <td
///    width="60%"> Windows Installer version 3.0 is required to determine the best patch sequence. The function was
///    called with <i>szProductCode</i> not yet installed with Windows Installer version 3.0. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> This error can be
///    returned if the function was called from a custom action or if MSXML 3.0 is not installed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The specified patch is
///    unknown. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiDeterminePatchSequenceA(const(char)* szProductCode, const(char)* szUserSid, MSIINSTALLCONTEXT dwContext, 
                                uint cPatchInfo, char* pPatchInfo);

///The <b>MsiDeterminePatchSequence</b> function takes a set of patch files, XML files, and XML blobs and determines the
///best sequence of application for the patches to a specified installed product. This function accounts for patches
///that have already been applied to the product and accounts for obsolete and superseded patches.
///Params:
///    szProductCode = The product that is the target for the set of patches. The value must be the ProductCode GUID for the product.
///    szUserSid = Null-terminated string that specifies a security identifier (SID) of a user. This parameter restricts the context
///                of enumeration for this user account. This parameter cannot be the special SID strings "S-1-1-0" (everyone) or
///                "S-1-5-18" (local system). For the machine context <i>dwContext</i> is set to<b> MSIINSTALLCONTEXT_MACHINE</b>
///                and <i>szUserSid</i> must be <b>NULL</b>. For the current user context <i>szUserSid</i> can be null and
///                <i>dwContext</i> can be set to <b>MSIINSTALLCONTEXT_USERMANAGED</b> or <b>MSIINSTALLCONTEXT_USERUNMANAGED</b>.
///    dwContext = Restricts the enumeration to a per-user-unmanaged, per-user-managed, or per-machine context. This parameter can
///                be any one of the following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> Patches are considered for all
///                per-user-managed installations of the product for the user specified by <i>szUserSid</i>. A null <i>szUserSid</i>
///                with this context means the current user. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td width="60%"> Patches are considered for all
///                per-user-unmanaged installations for the user specified by <i>szUserSid</i>. A null <i>szUserSid</i> with this
///                context means the current user. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a
///                id="msiinstallcontext_machine"></a><dl> <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%">
///                Patches are considered for the per-machine installation. When <i>dwContext</i> is set to
///                <b>MSIINSTALLCONTEXT_MACHINE</b> the <i>szUserSid</i> parameter must be null. </td> </tr> </table>
///    cPatchInfo = The number of patches in the array.
///    pPatchInfo = Pointer to an array of MSIPATCHSEQUENCEINFO structures.
///Returns:
///    The <b>MsiDeterminePatchSequence</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> The function failed in a manner not covered in the other error codes. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An argument is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_NO_SEQUENCE</b></dt> </dl> </td> <td width="60%"> No
///    valid sequence could be found for the set of patches. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_PACKAGE_OPEN_FAILED</b></dt> </dl> </td> <td width="60%"> An installation package referenced
///    by path cannot be opened. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td
///    width="60%"> The patches were successfully sorted. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The .msi file was not found. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_PATH_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The path to the .msi file
///    was not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PATCH_XML</b></dt> </dl> </td> <td
///    width="60%"> The XML patch data is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_PACKAGE_INVALID</b></dt> </dl> </td> <td width="60%"> The installation package was invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> A user
///    that is not an administrator attempted to call the function with a context of a different user. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data
///    for a registered patch or product is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The ProductCode GUID specified is not
///    registered. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_NOT_CALLED</b></dt> </dl> </td> <td
///    width="60%"> Windows Installer version 3.0 is required to determine the best patch sequence. The function was
///    called with <i>szProductCode</i> not yet installed with Windows Installer version 3.0. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> This error can be
///    returned if the function was called from a custom action or if MSXML 3.0 is not installed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The specified patch is
///    unknown. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiDeterminePatchSequenceW(const(wchar)* szProductCode, const(wchar)* szUserSid, MSIINSTALLCONTEXT dwContext, 
                                uint cPatchInfo, char* pPatchInfo);

///The <b>MsiDetermineApplicablePatches</b> function takes a set of patch files, XML files, and XML blobs and determines
///which patches apply to a specified Windows Installer package and in what sequence. The function can account for
///superseded or obsolete patches. This function does not account for products or patches that are installed on the
///system that are not specified in the set.
///Params:
///    szProductPackagePath = Full path to an .msi file. The function determines the patches that are applicable to this package and in what
///                           sequence.
///    cPatchInfo = Number of patches in the array. Must be greater than zero.
///    pPatchInfo = Pointer to an array of MSIPATCHSEQUENCEINFO structures.
///Returns:
///    The <b>MsiDetermineApplicablePatches</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> The function failed in a manner not covered in the other error codes. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An argument is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_NO_SEQUENCE</b></dt> </dl> </td> <td width="60%"> No
///    valid sequence could be found for the set of patches. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The patches were successfully sorted. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The .msi file was not
///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATH_NOT_FOUND</b></dt> </dl> </td> <td width="60%">
///    The path to the .msi file was not found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PATCH_XML</b></dt> </dl> </td> <td width="60%"> The XML patch data is invalid. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_PACKAGE_OPEN_FAILED</b></dt> </dl> </td> <td width="60%"> An
///    installation package referenced by path cannot be opened. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> This error can be returned if the
///    function was called from a custom action or if MSXML 3.0 is not installed. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiDetermineApplicablePatchesA(const(char)* szProductPackagePath, uint cPatchInfo, char* pPatchInfo);

///The <b>MsiDetermineApplicablePatches</b> function takes a set of patch files, XML files, and XML blobs and determines
///which patches apply to a specified Windows Installer package and in what sequence. The function can account for
///superseded or obsolete patches. This function does not account for products or patches that are installed on the
///system that are not specified in the set.
///Params:
///    szProductPackagePath = Full path to an .msi file. The function determines the patches that are applicable to this package and in what
///                           sequence.
///    cPatchInfo = Number of patches in the array. Must be greater than zero.
///    pPatchInfo = Pointer to an array of MSIPATCHSEQUENCEINFO structures.
///Returns:
///    The <b>MsiDetermineApplicablePatches</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> The function failed in a manner not covered in the other error codes. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An argument is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATCH_NO_SEQUENCE</b></dt> </dl> </td> <td width="60%"> No
///    valid sequence could be found for the set of patches. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The patches were successfully sorted. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The .msi file was not
///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATH_NOT_FOUND</b></dt> </dl> </td> <td width="60%">
///    The path to the .msi file was not found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PATCH_XML</b></dt> </dl> </td> <td width="60%"> The XML patch data is invalid. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_PACKAGE_OPEN_FAILED</b></dt> </dl> </td> <td width="60%"> An
///    installation package referenced by path cannot be opened. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> This error can be returned if the
///    function was called from a custom action or if MSXML 3.0 is not installed. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiDetermineApplicablePatchesW(const(wchar)* szProductPackagePath, uint cPatchInfo, char* pPatchInfo);

///The <b>MsiEnumPatchesEx</b> function enumerates all patches in a specific context or across all contexts. Patches
///already applied to products are enumerated. Patches that have been registered but not yet applied to products are
///also enumerated.
///Params:
///    szProductCode = A null-terminated string that specifies the ProductCode GUID of the product whose patches are enumerated. If
///                    non-<b>NULL</b>, patch enumeration is restricted to instances of this product under the user and context
///                    specified by <i>szUserSid</i> and <i>dwContext</i>. If <b>NULL</b>, the patches for all products under the
///                    specified context are enumerated.
///    szUserSid = A null-terminated string that specifies a security identifier (SID) that restricts the context of enumeration.
///                The special SID string "S-1-1-0" (Everyone) specifies enumeration across all users in the system. A SID value
///                other than "S-1-1-0" is considered a user SID and restricts enumeration to that user. When enumerating for a user
///                other than current user, any patches that were applied in a per-user-unmanaged context using a version less than
///                Windows Installer version 3.0, are not enumerated. This parameter can be set to <b>NULL</b> to specify the
///                current user. <table> <tr> <th>SID type</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a
///                id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> Specifies the currently logged-on
///                user. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl>
///                <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> An enumeration for a specific user in the system. An
///                example of user SID is "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> <tr> <td width="40%"><a
///                id="s-1-1-0"></a><a id="S-1-1-0"></a><dl> <dt><b>s-1-1-0</b></dt> </dl> </td> <td width="60%"> An enumeration
///                across all users in the system. </td> </tr> </table> <div class="alert"><b>Note</b> The special SID string
///                "S-1-5-18" (System) cannot be used to enumerate products or patches installed as per-machine. Setting the SID
///                value to "S-1-5-18" returns <b>ERROR_INVALID_PARAMETER</b>. When <i>dwContext</i> is set to
///                <b>MSIINSTALLCONTEXT_MACHINE</b> only, <i>szUserSid</i> must be <b>NULL</b>.</div> <div> </div>
///    dwContext = Restricts the enumeration to one or a combination of contexts. This parameter can be any one or a combination of
///                the following values. <table> <tr> <th>Context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The enumeration that is extended to
///                all per-user-managed installations for the users that <i>szUserSid</i> specifies. An invalid SID returns no
///                items. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> In this context, only patches installed with Windows Installer version 3.0 are enumerated for users
///                that are not the current user. For the current user, the function enumerates all installed and new patches. An
///                invalid SID for <i>szUserSid</i> returns no items. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> An enumeration that is extended to all
///                per-machine installations. When <i>dwContext</i> is set to <b>MSIINSTALLCONTEXT_MACHINE</b> only, the
///                <i>szUserSid</i> parameter must be <b>NULL</b>. </td> </tr> </table>
///    dwFilter = The filter for enumeration. This parameter can be one or a combination of the following parameters. <table> <tr>
///               <th>Filter</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIPATCHSTATE_APPLIED"></a><a
///               id="msipatchstate_applied"></a><dl> <dt><b>MSIPATCHSTATE_APPLIED</b></dt> <dt>1</dt> </dl> </td> <td width="60%">
///               The enumeration includes patches that have been applied. Enumeration does not include superseded or obsolete
///               patches. </td> </tr> <tr> <td width="40%"><a id="MSIPATCHSTATE_SUPERSEDED"></a><a
///               id="msipatchstate_superseded"></a><dl> <dt><b>MSIPATCHSTATE_SUPERSEDED</b></dt> <dt>2</dt> </dl> </td> <td
///               width="60%"> The enumeration includes patches that are marked as superseded. </td> </tr> <tr> <td width="40%"><a
///               id="MSIPATCHSTATE_OBSOLETED"></a><a id="msipatchstate_obsoleted"></a><dl> <dt><b>MSIPATCHSTATE_OBSOLETED</b></dt>
///               <dt>4</dt> </dl> </td> <td width="60%"> The enumeration includes patches that are marked as obsolete. </td> </tr>
///               <tr> <td width="40%"><a id="MSIPATCHSTATE_REGISTERED"></a><a id="msipatchstate_registered"></a><dl>
///               <dt><b>MSIPATCHSTATE_REGISTERED</b></dt> <dt>8</dt> </dl> </td> <td width="60%"> The enumeration includes patches
///               that are registered but not yet applied. The MsiSourceListAddSourceEx function can register new patches. <div
///               class="alert"><b>Note</b> Patches registered for users other than current user and applied in the
///               per-user-unmanaged context are not enumerated.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a
///               id="MSIPATCHSTATE_ALL"></a><a id="msipatchstate_all"></a><dl> <dt><b>MSIPATCHSTATE_ALL</b></dt> <dt>15</dt> </dl>
///               </td> <td width="60%"> The enumeration includes all applied, obsolete, superseded, and registered patches. </td>
///               </tr> </table>
///    dwIndex = The index of the patch to retrieve. This parameter must be zero for the first call to the <b>MsiEnumPatchesEx</b>
///              function and then incremented for subsequent calls. The <i>dwIndex</i> parameter should be incremented only if
///              the previous call returned ERROR_SUCCESS.
///    szPatchCode = An output buffer to contain the GUID of the patch being enumerated. The buffer should be large enough to hold the
///                  GUID. This parameter can be <b>NULL</b>.
///    szTargetProductCode = An output buffer to contain the ProductCode GUID of the product that receives this patch. The buffer should be
///                          large enough to hold the GUID. This parameter can be <b>NULL</b>.
///    pdwTargetProductContext = Returns the context of the patch being enumerated. The output value can be <b>MSIINSTALLCONTEXT_USERMANAGED</b>,
///                              <b>MSIINSTALLCONTEXT_USERUNMANAGED</b>, or <b>MSIINSTALLCONTEXT_MACHINE</b>. This parameter can be <b>NULL</b>.
///    szTargetUserSid = An output buffer that receives the string SID of the account under which this patch instance exists. This buffer
///                      returns an empty string for a per-machine context. This buffer should be large enough to contain the SID. If the
///                      buffer is too small, the function returns <b>ERROR_MORE_DATA</b> and sets *<i>pcchTargetUserSid</i> to the number
///                      of <b>TCHAR</b> in the value, not including the terminating NULL character. If the <i>szTargetUserSid</i> is set
///                      to <b>NULL</b> and <i>pcchTargetUserSid</i> is set to a valid pointer, the function returns <b>ERROR_SUCCESS</b>
///                      and sets *<i>pcchTargetUserSid</i> to the number of <b>TCHAR</b> in the value, not including the terminating
///                      <b>NULL</b> character. The function can then be called again to retrieve the value, with <i>szTargetUserSid</i>
///                      buffer large enough to contain *<i>pcchTargetUserSid</i> + 1 characters. If <i>szTargetUserSid</i> and
///                      <i>pcchTargetUserSid</i> are both set to <b>NULL</b>, the function returns <b>ERROR_SUCCESS</b> if the value
///                      exists, without retrieving the value.
///    pcchTargetUserSid = A pointer to a variable that specifies the number of <b>TCHAR</b> in the <i>szTargetUserSid</i> buffer. When the
///                        function returns, this parameter is set to the size of the requested value whether or not the function copies the
///                        value into the specified buffer. The size is returned as the number of <b>TCHAR</b> in the requested value, not
///                        including the terminating null character. This parameter can be set to <b>NULL</b> only if <i>szTargetUserSid</i>
///                        is also <b>NULL</b>, otherwise the function returns ERROR_INVALID_PARAMETER.
///Returns:
///    The <b>MsiEnumPatchesEx</b> function returns one of the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The function fails trying to access a resource with insufficient privileges. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is
///    corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> An invalid parameter is passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%"> There are no more patches to enumerate. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The patch is
///    successfully enumerated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td>
///    <td width="60%"> The product that <i>szProduct</i> specifies is not installed on the computer in the specified
///    contexts. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%">
///    This is returned when <i>pcchTargetUserSid</i> points to a buffer size less than required to copy the SID. In
///    this case, the user can fix the buffer and call MsiEnumPatchesEx again for the same index value. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiEnumPatchesExA(const(char)* szProductCode, const(char)* szUserSid, uint dwContext, uint dwFilter, 
                       uint dwIndex, char* szPatchCode, char* szTargetProductCode, 
                       MSIINSTALLCONTEXT* pdwTargetProductContext, const(char)* szTargetUserSid, 
                       uint* pcchTargetUserSid);

///The <b>MsiEnumPatchesEx</b> function enumerates all patches in a specific context or across all contexts. Patches
///already applied to products are enumerated. Patches that have been registered but not yet applied to products are
///also enumerated.
///Params:
///    szProductCode = A null-terminated string that specifies the ProductCode GUID of the product whose patches are enumerated. If
///                    non-<b>NULL</b>, patch enumeration is restricted to instances of this product under the user and context
///                    specified by <i>szUserSid</i> and <i>dwContext</i>. If <b>NULL</b>, the patches for all products under the
///                    specified context are enumerated.
///    szUserSid = A null-terminated string that specifies a security identifier (SID) that restricts the context of enumeration.
///                The special SID string "S-1-1-0" (Everyone) specifies enumeration across all users in the system. A SID value
///                other than "S-1-1-0" is considered a user SID and restricts enumeration to that user. When enumerating for a user
///                other than current user, any patches that were applied in a per-user-unmanaged context using a version less than
///                Windows Installer version 3.0, are not enumerated. This parameter can be set to <b>NULL</b> to specify the
///                current user. <table> <tr> <th>SID type</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a
///                id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> Specifies the currently logged-on
///                user. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl>
///                <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> An enumeration for a specific user in the system. An
///                example of user SID is "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> <tr> <td width="40%"><a
///                id="s-1-1-0"></a><a id="S-1-1-0"></a><dl> <dt><b>s-1-1-0</b></dt> </dl> </td> <td width="60%"> An enumeration
///                across all users in the system. </td> </tr> </table> <div class="alert"><b>Note</b> The special SID string
///                "S-1-5-18" (System) cannot be used to enumerate products or patches installed as per-machine. Setting the SID
///                value to "S-1-5-18" returns <b>ERROR_INVALID_PARAMETER</b>. When <i>dwContext</i> is set to
///                <b>MSIINSTALLCONTEXT_MACHINE</b> only, <i>szUserSid</i> must be <b>NULL</b>.</div> <div> </div>
///    dwContext = Restricts the enumeration to one or a combination of contexts. This parameter can be any one or a combination of
///                the following values. <table> <tr> <th>Context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The enumeration that is extended to
///                all per-user-managed installations for the users that <i>szUserSid</i> specifies. An invalid SID returns no
///                items. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> In this context, only patches installed with Windows Installer version 3.0 are enumerated for users
///                that are not the current user. For the current user, the function enumerates all installed and new patches. An
///                invalid SID for <i>szUserSid</i> returns no items. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> An enumeration that is extended to all
///                per-machine installations. When <i>dwContext</i> is set to <b>MSIINSTALLCONTEXT_MACHINE</b> only, the
///                <i>szUserSid</i> parameter must be <b>NULL</b>. </td> </tr> </table>
///    dwFilter = The filter for enumeration. This parameter can be one or a combination of the following parameters. <table> <tr>
///               <th>Filter</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIPATCHSTATE_APPLIED"></a><a
///               id="msipatchstate_applied"></a><dl> <dt><b>MSIPATCHSTATE_APPLIED</b></dt> <dt>1</dt> </dl> </td> <td width="60%">
///               The enumeration includes patches that have been applied. Enumeration does not include superseded or obsolete
///               patches. </td> </tr> <tr> <td width="40%"><a id="MSIPATCHSTATE_SUPERSEDED"></a><a
///               id="msipatchstate_superseded"></a><dl> <dt><b>MSIPATCHSTATE_SUPERSEDED</b></dt> <dt>2</dt> </dl> </td> <td
///               width="60%"> The enumeration includes patches that are marked as superseded. </td> </tr> <tr> <td width="40%"><a
///               id="MSIPATCHSTATE_OBSOLETED"></a><a id="msipatchstate_obsoleted"></a><dl> <dt><b>MSIPATCHSTATE_OBSOLETED</b></dt>
///               <dt>4</dt> </dl> </td> <td width="60%"> The enumeration includes patches that are marked as obsolete. </td> </tr>
///               <tr> <td width="40%"><a id="MSIPATCHSTATE_REGISTERED"></a><a id="msipatchstate_registered"></a><dl>
///               <dt><b>MSIPATCHSTATE_REGISTERED</b></dt> <dt>8</dt> </dl> </td> <td width="60%"> The enumeration includes patches
///               that are registered but not yet applied. The MsiSourceListAddSourceEx function can register new patches. <div
///               class="alert"><b>Note</b> Patches registered for users other than current user and applied in the
///               per-user-unmanaged context are not enumerated.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a
///               id="MSIPATCHSTATE_ALL"></a><a id="msipatchstate_all"></a><dl> <dt><b>MSIPATCHSTATE_ALL</b></dt> <dt>15</dt> </dl>
///               </td> <td width="60%"> The enumeration includes all applied, obsolete, superseded, and registered patches. </td>
///               </tr> </table>
///    dwIndex = The index of the patch to retrieve. This parameter must be zero for the first call to the <b>MsiEnumPatchesEx</b>
///              function and then incremented for subsequent calls. The <i>dwIndex</i> parameter should be incremented only if
///              the previous call returned ERROR_SUCCESS.
///    szPatchCode = An output buffer to contain the GUID of the patch being enumerated. The buffer should be large enough to hold the
///                  GUID. This parameter can be <b>NULL</b>.
///    szTargetProductCode = An output buffer to contain the ProductCode GUID of the product that receives this patch. The buffer should be
///                          large enough to hold the GUID. This parameter can be <b>NULL</b>.
///    pdwTargetProductContext = Returns the context of the patch being enumerated. The output value can be <b>MSIINSTALLCONTEXT_USERMANAGED</b>,
///                              <b>MSIINSTALLCONTEXT_USERUNMANAGED</b>, or <b>MSIINSTALLCONTEXT_MACHINE</b>. This parameter can be <b>NULL</b>.
///    szTargetUserSid = An output buffer that receives the string SID of the account under which this patch instance exists. This buffer
///                      returns an empty string for a per-machine context. This buffer should be large enough to contain the SID. If the
///                      buffer is too small, the function returns <b>ERROR_MORE_DATA</b> and sets *<i>pcchTargetUserSid</i> to the number
///                      of <b>TCHAR</b> in the value, not including the terminating NULL character. If the <i>szTargetUserSid</i> is set
///                      to <b>NULL</b> and <i>pcchTargetUserSid</i> is set to a valid pointer, the function returns <b>ERROR_SUCCESS</b>
///                      and sets *<i>pcchTargetUserSid</i> to the number of <b>TCHAR</b> in the value, not including the terminating
///                      <b>NULL</b> character. The function can then be called again to retrieve the value, with <i>szTargetUserSid</i>
///                      buffer large enough to contain *<i>pcchTargetUserSid</i> + 1 characters. If <i>szTargetUserSid</i> and
///                      <i>pcchTargetUserSid</i> are both set to <b>NULL</b>, the function returns <b>ERROR_SUCCESS</b> if the value
///                      exists, without retrieving the value.
///    pcchTargetUserSid = A pointer to a variable that specifies the number of <b>TCHAR</b> in the <i>szTargetUserSid</i> buffer. When the
///                        function returns, this parameter is set to the size of the requested value whether or not the function copies the
///                        value into the specified buffer. The size is returned as the number of <b>TCHAR</b> in the requested value, not
///                        including the terminating null character. This parameter can be set to <b>NULL</b> only if <i>szTargetUserSid</i>
///                        is also <b>NULL</b>, otherwise the function returns ERROR_INVALID_PARAMETER.
///Returns:
///    The <b>MsiEnumPatchesEx</b> function returns one of the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The function fails trying to access a resource with insufficient privileges. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is
///    corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> An invalid parameter is passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%"> There are no more patches to enumerate. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The patch is
///    successfully enumerated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td>
///    <td width="60%"> The product that <i>szProduct</i> specifies is not installed on the computer in the specified
///    contexts. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%">
///    This is returned when <i>pcchTargetUserSid</i> points to a buffer size less than required to copy the SID. In
///    this case, the user can fix the buffer and call MsiEnumPatchesEx again for the same index value. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiEnumPatchesExW(const(wchar)* szProductCode, const(wchar)* szUserSid, uint dwContext, uint dwFilter, 
                       uint dwIndex, char* szPatchCode, char* szTargetProductCode, 
                       MSIINSTALLCONTEXT* pdwTargetProductContext, const(wchar)* szTargetUserSid, 
                       uint* pcchTargetUserSid);

///The <b>MsiQueryFeatureState</b> function returns the installed state for a product feature.
///Params:
///    szProduct = Specifies the product code for the product that contains the feature of interest.
///    szFeature = Identifies the feature of interest.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_ABSENT</b></dt>
///    </dl> </td> <td width="60%"> The feature is not installed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The feature is advertised </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The feature is installed
///    locally. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%">
///    The feature is installed to run from source. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_INVALIDARG</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td
///    width="60%"> The product code or feature ID is unknown. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
INSTALLSTATE MsiQueryFeatureStateA(const(char)* szProduct, const(char)* szFeature);

///The <b>MsiQueryFeatureState</b> function returns the installed state for a product feature.
///Params:
///    szProduct = Specifies the product code for the product that contains the feature of interest.
///    szFeature = Identifies the feature of interest.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_ABSENT</b></dt>
///    </dl> </td> <td width="60%"> The feature is not installed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The feature is advertised </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The feature is installed
///    locally. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%">
///    The feature is installed to run from source. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_INVALIDARG</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td
///    width="60%"> The product code or feature ID is unknown. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
INSTALLSTATE MsiQueryFeatureStateW(const(wchar)* szProduct, const(wchar)* szFeature);

///The <b>MsiQueryFeatureStateEx</b> function returns the installed state for a product feature. This function can be
///used to query any feature of an instance of a product installed under the machine account or any context under the
///current user account or the per-user-managed context under any user account other than the current user. A user must
///have administrative privileges to get information for a product installed for a user other than the current user.
///Params:
///    szProductCode = ProductCode GUID of the product that contains the feature of interest.
///    szUserSid = Specifies the security identifier (SID) of the account, under which, the instance of the product being queried
///                exists. If <i>dwContext</i> is not <b>MSIINSTALLCONTEXT_MACHINE</b>, a null value specifies the current user.
///                <table> <tr> <th>Type of SID</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a
///                id="null"></a><dl> <dt><b>NULL</b></dt> </dl> </td> <td width="60%"> NULL denotes the currently logged on user.
///                </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User
///                SID</b></dt> </dl> </td> <td width="60%"> Specifies enumeration for a particular user in the system. An example
///                of user SID is "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div
///                class="alert"><b>Note</b> The special SID string s-1-5-18 (system) cannot be used to enumerate features of
///                products installed as per-machine. If <i>dwContext</i> is <b>MSIINSTALLCONTEXT_MACHINE</b>, <i>szUserSid</i> must
///                be null.</div> <div> </div>
///    dwContext = The installation context of the product instance being queried. <table> <tr> <th>Name</th> <th>Meaning</th> </tr>
///                <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> Retrieves the feature state for the
///                per-user-managed instance of the product. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td width="60%"> Retrieves the feature state for the
///                per-user-unmanaged instance of the product. <div class="alert"><b>Note</b> When the query is made on a product
///                installed under the per-user-unmanaged context for a user account other than the current user, the function
///                fails.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a
///                id="msiinstallcontext_machine"></a><dl> <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%">
///                Retrieves the feature state for the per-machine instance of the product. </td> </tr> </table>
///    szFeature = Specifies the feature being queried. Identifier of the feature as found in the <b>Feature</b> column of the
///                Feature table.
///    pdwState = Installation state of the feature for the specified product instance. This parameter can return one of the
///               following or null. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="INSTALLSTATE_ADVERTISED"></a><a id="installstate_advertised"></a><dl> <dt><b>INSTALLSTATE_ADVERTISED</b></dt>
///               </dl> </td> <td width="60%"> This feature is advertised. </td> </tr> <tr> <td width="40%"><a
///               id="INSTALLSTATE_LOCAL"></a><a id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td>
///               <td width="60%"> The feature is installed locally. </td> </tr> <tr> <td width="40%"><a
///               id="INSTALLSTATE_SOURCE"></a><a id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td>
///               <td width="60%"> The feature is installed to run from source. </td> </tr> </table>
///Returns:
///    The <b>MsiQueryFeatureStateEx</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> A user must have administrative privileges to get information for a product installed for a user
///    other than the current user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl>
///    </td> <td width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_FEATURE</b></dt>
///    </dl> </td> <td width="60%"> The feature ID does not identify a known feature. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product code does not identify a
///    known product. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> An unexpected internal failure. </td> </tr> </table> For more information, see Displayed Error
///    Messages.
///    
@DllImport("msi")
uint MsiQueryFeatureStateExA(const(char)* szProductCode, const(char)* szUserSid, MSIINSTALLCONTEXT dwContext, 
                             const(char)* szFeature, INSTALLSTATE* pdwState);

///The <b>MsiQueryFeatureStateEx</b> function returns the installed state for a product feature. This function can be
///used to query any feature of an instance of a product installed under the machine account or any context under the
///current user account or the per-user-managed context under any user account other than the current user. A user must
///have administrative privileges to get information for a product installed for a user other than the current user.
///Params:
///    szProductCode = ProductCode GUID of the product that contains the feature of interest.
///    szUserSid = Specifies the security identifier (SID) of the account, under which, the instance of the product being queried
///                exists. If <i>dwContext</i> is not <b>MSIINSTALLCONTEXT_MACHINE</b>, a null value specifies the current user.
///                <table> <tr> <th>Type of SID</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a
///                id="null"></a><dl> <dt><b>NULL</b></dt> </dl> </td> <td width="60%"> NULL denotes the currently logged on user.
///                </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User
///                SID</b></dt> </dl> </td> <td width="60%"> Specifies enumeration for a particular user in the system. An example
///                of user SID is "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div
///                class="alert"><b>Note</b> The special SID string s-1-5-18 (system) cannot be used to enumerate features of
///                products installed as per-machine. If <i>dwContext</i> is <b>MSIINSTALLCONTEXT_MACHINE</b>, <i>szUserSid</i> must
///                be null.</div> <div> </div>
///    dwContext = The installation context of the product instance being queried. <table> <tr> <th>Name</th> <th>Meaning</th> </tr>
///                <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> Retrieves the feature state for the
///                per-user-managed instance of the product. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td width="60%"> Retrieves the feature state for the
///                per-user-unmanaged instance of the product. <div class="alert"><b>Note</b> When the query is made on a product
///                installed under the per-user-unmanaged context for a user account other than the current user, the function
///                fails.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a
///                id="msiinstallcontext_machine"></a><dl> <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%">
///                Retrieves the feature state for the per-machine instance of the product. </td> </tr> </table>
///    szFeature = Specifies the feature being queried. Identifier of the feature as found in the <b>Feature</b> column of the
///                Feature table.
///    pdwState = Installation state of the feature for the specified product instance. This parameter can return one of the
///               following or null. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="INSTALLSTATE_ADVERTISED"></a><a id="installstate_advertised"></a><dl> <dt><b>INSTALLSTATE_ADVERTISED</b></dt>
///               </dl> </td> <td width="60%"> This feature is advertised. </td> </tr> <tr> <td width="40%"><a
///               id="INSTALLSTATE_LOCAL"></a><a id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td>
///               <td width="60%"> The feature is installed locally. </td> </tr> <tr> <td width="40%"><a
///               id="INSTALLSTATE_SOURCE"></a><a id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td>
///               <td width="60%"> The feature is installed to run from source. </td> </tr> </table>
///Returns:
///    The <b>MsiQueryFeatureStateEx</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> A user must have administrative privileges to get information for a product installed for a user
///    other than the current user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl>
///    </td> <td width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_FEATURE</b></dt>
///    </dl> </td> <td width="60%"> The feature ID does not identify a known feature. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product code does not identify a
///    known product. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> An unexpected internal failure. </td> </tr> </table> For more information, see Displayed Error
///    Messages.
///    
@DllImport("msi")
uint MsiQueryFeatureStateExW(const(wchar)* szProductCode, const(wchar)* szUserSid, MSIINSTALLCONTEXT dwContext, 
                             const(wchar)* szFeature, INSTALLSTATE* pdwState);

///The <b>MsiUseFeature</b> function increments the usage count for a particular feature and indicates the installation
///state for that feature. This function should be used to indicate an application's intent to use a feature.
///Params:
///    szProduct = Specifies the product code for the product that owns the feature to be used.
///    szFeature = Identifies the feature to be used.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_ABSENT</b></dt>
///    </dl> </td> <td width="60%"> The feature is not installed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The feature is advertised </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>INSTALLSTATE_BADCONFIG</b></dt> </dl> </td> <td width="60%"> The configuration data
///    is corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_INVALIDARG</b></dt> </dl> </td> <td
///    width="60%"> Invalid function argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_LOCAL</b></dt>
///    </dl> </td> <td width="60%"> The feature is locally installed and available for use. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The feature is installed from
///    the source and available for use. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt>
///    </dl> </td> <td width="60%"> The feature is not published. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
INSTALLSTATE MsiUseFeatureA(const(char)* szProduct, const(char)* szFeature);

///The <b>MsiUseFeature</b> function increments the usage count for a particular feature and indicates the installation
///state for that feature. This function should be used to indicate an application's intent to use a feature.
///Params:
///    szProduct = Specifies the product code for the product that owns the feature to be used.
///    szFeature = Identifies the feature to be used.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_ABSENT</b></dt>
///    </dl> </td> <td width="60%"> The feature is not installed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The feature is advertised </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>INSTALLSTATE_BADCONFIG</b></dt> </dl> </td> <td width="60%"> The configuration data
///    is corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_INVALIDARG</b></dt> </dl> </td> <td
///    width="60%"> Invalid function argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_LOCAL</b></dt>
///    </dl> </td> <td width="60%"> The feature is locally installed and available for use. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The feature is installed from
///    the source and available for use. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt>
///    </dl> </td> <td width="60%"> The feature is not published. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
INSTALLSTATE MsiUseFeatureW(const(wchar)* szProduct, const(wchar)* szFeature);

///The <b>MsiUseFeatureEx</b> function increments the usage count for a particular feature and indicates the
///installation state for that feature. This function should be used to indicate an application's intent to use a
///feature.
///Params:
///    szProduct = Specifies the product code for the product that owns the feature to be used.
///    szFeature = Identifies the feature to be used.
///    dwInstallMode = This parameter can have the following value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                    width="40%"><a id="INSTALLMODE_NODETECTION"></a><a id="installmode_nodetection"></a><dl>
///                    <dt><b>INSTALLMODE_NODETECTION</b></dt> </dl> </td> <td width="60%"> Return value indicates the installation
///                    state. </td> </tr> </table>
///    dwReserved = Reserved for future use. This value must be set to 0.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_ABSENT</b></dt>
///    </dl> </td> <td width="60%"> The feature is not installed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The feature is advertised </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The feature is locally
///    installed and available for use. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl>
///    </td> <td width="60%"> The feature is installed from the source and available for use. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> The feature is not published.
///    </td> </tr> </table>
///    
@DllImport("msi")
INSTALLSTATE MsiUseFeatureExA(const(char)* szProduct, const(char)* szFeature, uint dwInstallMode, uint dwReserved);

///The <b>MsiUseFeatureEx</b> function increments the usage count for a particular feature and indicates the
///installation state for that feature. This function should be used to indicate an application's intent to use a
///feature.
///Params:
///    szProduct = Specifies the product code for the product that owns the feature to be used.
///    szFeature = Identifies the feature to be used.
///    dwInstallMode = This parameter can have the following value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                    width="40%"><a id="INSTALLMODE_NODETECTION"></a><a id="installmode_nodetection"></a><dl>
///                    <dt><b>INSTALLMODE_NODETECTION</b></dt> </dl> </td> <td width="60%"> Return value indicates the installation
///                    state. </td> </tr> </table>
///    dwReserved = Reserved for future use. This value must be set to 0.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_ABSENT</b></dt>
///    </dl> </td> <td width="60%"> The feature is not installed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The feature is advertised </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The feature is locally
///    installed and available for use. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl>
///    </td> <td width="60%"> The feature is installed from the source and available for use. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> The feature is not published.
///    </td> </tr> </table>
///    
@DllImport("msi")
INSTALLSTATE MsiUseFeatureExW(const(wchar)* szProduct, const(wchar)* szFeature, uint dwInstallMode, 
                              uint dwReserved);

///The <b>MsiGetFeatureUsage</b> function returns the usage metrics for a product feature.
///Params:
///    szProduct = Specifies the product code for the product that contains the feature.
///    szFeature = Specifies the feature code for the feature for which metrics are to be returned.
///    pdwUseCount = Indicates the number of times the feature has been used.
///    pwDateUsed = Specifies the date that the feature was last used. The date is in the MS-DOS date format, as shown in the
///                 following table. <table> <tr> <th>Bits</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0  4</dt>
///                 </dl> </td> <td width="60%"> Day of the month (1-31) </td> </tr> <tr> <td width="40%"> <dl> <dt>5  8</dt>
///                 </dl> </td> <td width="60%"> Month (1 = January, 2 = February, and so on) </td> </tr> <tr> <td width="40%"> <dl>
///                 <dt>9  15</dt> </dl> </td> <td width="60%"> Year offset from 1980 (add 1980 to get actual year) </td> </tr>
///                 </table>
///Returns:
///    The <b>MsiGetFeatureUsage</b> function returns the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The
///    configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl>
///    </td> <td width="60%"> No usage information is available or the product or feature is invalid. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed
///    successfully. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiGetFeatureUsageA(const(char)* szProduct, const(char)* szFeature, uint* pdwUseCount, ushort* pwDateUsed);

///The <b>MsiGetFeatureUsage</b> function returns the usage metrics for a product feature.
///Params:
///    szProduct = Specifies the product code for the product that contains the feature.
///    szFeature = Specifies the feature code for the feature for which metrics are to be returned.
///    pdwUseCount = Indicates the number of times the feature has been used.
///    pwDateUsed = Specifies the date that the feature was last used. The date is in the MS-DOS date format, as shown in the
///                 following table. <table> <tr> <th>Bits</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0  4</dt>
///                 </dl> </td> <td width="60%"> Day of the month (1-31) </td> </tr> <tr> <td width="40%"> <dl> <dt>5  8</dt>
///                 </dl> </td> <td width="60%"> Month (1 = January, 2 = February, and so on) </td> </tr> <tr> <td width="40%"> <dl>
///                 <dt>9  15</dt> </dl> </td> <td width="60%"> Year offset from 1980 (add 1980 to get actual year) </td> </tr>
///                 </table>
///Returns:
///    The <b>MsiGetFeatureUsage</b> function returns the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The
///    configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl>
///    </td> <td width="60%"> No usage information is available or the product or feature is invalid. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed
///    successfully. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiGetFeatureUsageW(const(wchar)* szProduct, const(wchar)* szFeature, uint* pdwUseCount, ushort* pwDateUsed);

///The <b>MsiConfigureFeature</b> function configures the installed state for a product feature.
///Params:
///    szProduct = Specifies the product code for the product to be configured.
///    szFeature = Specifies the feature ID for the feature to be configured.
///    eInstallState = Specifies the installation state for the feature. This parameter must be one of the following values. <table>
///                    <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ADVERTISED"></a><a
///                    id="installstate_advertised"></a><dl> <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The
///                    feature is advertised </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a
///                    id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The feature is
///                    installed locally. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ABSENT"></a><a
///                    id="installstate_absent"></a><dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> The feature is
///                    uninstalled. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a
///                    id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The feature is
///                    installed to run from source. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_DEFAULT"></a><a
///                    id="installstate_default"></a><dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl> </td> <td width="60%"> The feature
///                    is installed to its default location. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function succeeds. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error relating to an action</b></dt> </dl>
///    </td> <td width="60%"> For more information, see Error Codes. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>Initialization Error</b></dt> </dl> </td> <td width="60%"> An error that relates to the initialization has
///    occurred. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiConfigureFeatureA(const(char)* szProduct, const(char)* szFeature, INSTALLSTATE eInstallState);

///The <b>MsiConfigureFeature</b> function configures the installed state for a product feature.
///Params:
///    szProduct = Specifies the product code for the product to be configured.
///    szFeature = Specifies the feature ID for the feature to be configured.
///    eInstallState = Specifies the installation state for the feature. This parameter must be one of the following values. <table>
///                    <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ADVERTISED"></a><a
///                    id="installstate_advertised"></a><dl> <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The
///                    feature is advertised </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a
///                    id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The feature is
///                    installed locally. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ABSENT"></a><a
///                    id="installstate_absent"></a><dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> The feature is
///                    uninstalled. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a
///                    id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The feature is
///                    installed to run from source. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_DEFAULT"></a><a
///                    id="installstate_default"></a><dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl> </td> <td width="60%"> The feature
///                    is installed to its default location. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function succeeds. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error relating to an action</b></dt> </dl>
///    </td> <td width="60%"> For more information, see Error Codes. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>Initialization Error</b></dt> </dl> </td> <td width="60%"> An error that relates to the initialization has
///    occurred. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiConfigureFeatureW(const(wchar)* szProduct, const(wchar)* szFeature, INSTALLSTATE eInstallState);

///The <b>MsiReinstallFeature</b> function reinstalls features.
///Params:
///    szProduct = Specifies the product code for the product that contains the feature to be reinstalled.
///    szFeature = Specifies the feature to be reinstalled. The parent feature or child feature of the specified feature is not
///                reinstalled. To reinstall the parent or child feature, you must call the <b>MsiReinstallFeature</b> function for
///                each separately or use the MsiReinstallProduct function.
///    dwReinstallMode = Specifies what to install. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///                      <th>Meaning</th> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_FILEMISSING"></a><a
///                      id="reinstallmode_filemissing"></a><dl> <dt><b>REINSTALLMODE_FILEMISSING</b></dt> </dl> </td> <td width="60%">
///                      Reinstall only if the file is missing. </td> </tr> <tr> <td width="40%"><a
///                      id="REINSTALLMODE_FILEOLDERVERSION"></a><a id="reinstallmode_fileolderversion"></a><dl>
///                      <dt><b>REINSTALLMODE_FILEOLDERVERSION</b></dt> </dl> </td> <td width="60%"> Reinstall if the file is missing or
///                      is an older version. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_FILEEQUALVERSION"></a><a
///                      id="reinstallmode_fileequalversion"></a><dl> <dt><b>REINSTALLMODE_FILEEQUALVERSION</b></dt> </dl> </td> <td
///                      width="60%"> Reinstall if the file is missing, or is an equal or older version. </td> </tr> <tr> <td
///                      width="40%"><a id="REINSTALLMODE_FILEEXACT"></a><a id="reinstallmode_fileexact"></a><dl>
///                      <dt><b>REINSTALLMODE_FILEEXACT</b></dt> </dl> </td> <td width="60%"> Reinstall if the file is missing or is a
///                      different version. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_FILEVERIFY"></a><a
///                      id="reinstallmode_fileverify"></a><dl> <dt><b>REINSTALLMODE_FILEVERIFY</b></dt> </dl> </td> <td width="60%">
///                      Verify the checksum values, and reinstall the file if they are missing or corrupt. This flag only repairs files
///                      that have msidbFileAttributesChecksum in the Attributes column of the File table. </td> </tr> <tr> <td
///                      width="40%"><a id="REINSTALLMODE_FILEREPLACE"></a><a id="reinstallmode_filereplace"></a><dl>
///                      <dt><b>REINSTALLMODE_FILEREPLACE</b></dt> </dl> </td> <td width="60%"> Force all files to be reinstalled,
///                      regardless of checksum or version. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_USERDATA"></a><a
///                      id="reinstallmode_userdata"></a><dl> <dt><b>REINSTALLMODE_USERDATA</b></dt> </dl> </td> <td width="60%"> Rewrite
///                      all required registry entries from the Registry Table that go to the<b>HKEY_CURRENT_USER</b></p> or
///                      <b>HKEY_USERS</b></p> registry hive. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_MACHINEDATA"></a><a
///                      id="reinstallmode_machinedata"></a><dl> <dt><b>REINSTALLMODE_MACHINEDATA</b></dt> </dl> </td> <td width="60%">
///                      Rewrite all required registry entries from the Registry Table that go to the <b>HKEY_LOCAL_MACHINE</b></p>or
///                      <b>HKEY_CLASSES_ROOT</b></p> registry hive. Rewrite all information from the Class Table, Verb Table,
///                      PublishComponent Table, ProgID Table, MIME Table, Icon Table, Extension Table, and AppID Table regardless of
///                      machine or user assignment. Reinstall all qualified components. When reinstalling an application, this option
///                      runs the RegisterTypeLibraries and InstallODBC actions. </td> </tr> <tr> <td width="40%"><a
///                      id="REINSTALLMODE_SHORTCUT"></a><a id="reinstallmode_shortcut"></a><dl> <dt><b>REINSTALLMODE_SHORTCUT</b></dt>
///                      </dl> </td> <td width="60%"> Reinstall all shortcuts and re-cache all icons overwriting any existing shortcuts
///                      and icons. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_PACKAGE"></a><a
///                      id="reinstallmode_package"></a><dl> <dt><b>REINSTALLMODE_PACKAGE</b></dt> </dl> </td> <td width="60%"> Use to run
///                      from the source package and re-cache the local package. Do not use for the first installation of an application
///                      or feature. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The installation failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was
///    passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt>
///    </dl> </td> <td width="60%"> The installation service could not be accessed. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_INSTALL_SUSPEND</b></dt> </dl> </td> <td width="60%"> The installation was suspended and is
///    incomplete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_USEREXIT</b></dt> </dl> </td> <td
///    width="60%"> The user canceled the installation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_FEATURE</b></dt> </dl> </td> <td width="60%"> The feature ID does not
///    identify a known feature. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl>
///    </td> <td width="60%"> The product code does not identify a known product. </td> </tr> </table> For more
///    information, see Displayed Error Messages.
///    
@DllImport("msi")
uint MsiReinstallFeatureA(const(char)* szProduct, const(char)* szFeature, uint dwReinstallMode);

///The <b>MsiReinstallFeature</b> function reinstalls features.
///Params:
///    szProduct = Specifies the product code for the product that contains the feature to be reinstalled.
///    szFeature = Specifies the feature to be reinstalled. The parent feature or child feature of the specified feature is not
///                reinstalled. To reinstall the parent or child feature, you must call the <b>MsiReinstallFeature</b> function for
///                each separately or use the MsiReinstallProduct function.
///    dwReinstallMode = Specifies what to install. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///                      <th>Meaning</th> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_FILEMISSING"></a><a
///                      id="reinstallmode_filemissing"></a><dl> <dt><b>REINSTALLMODE_FILEMISSING</b></dt> </dl> </td> <td width="60%">
///                      Reinstall only if the file is missing. </td> </tr> <tr> <td width="40%"><a
///                      id="REINSTALLMODE_FILEOLDERVERSION"></a><a id="reinstallmode_fileolderversion"></a><dl>
///                      <dt><b>REINSTALLMODE_FILEOLDERVERSION</b></dt> </dl> </td> <td width="60%"> Reinstall if the file is missing or
///                      is an older version. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_FILEEQUALVERSION"></a><a
///                      id="reinstallmode_fileequalversion"></a><dl> <dt><b>REINSTALLMODE_FILEEQUALVERSION</b></dt> </dl> </td> <td
///                      width="60%"> Reinstall if the file is missing, or is an equal or older version. </td> </tr> <tr> <td
///                      width="40%"><a id="REINSTALLMODE_FILEEXACT"></a><a id="reinstallmode_fileexact"></a><dl>
///                      <dt><b>REINSTALLMODE_FILEEXACT</b></dt> </dl> </td> <td width="60%"> Reinstall if the file is missing or is a
///                      different version. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_FILEVERIFY"></a><a
///                      id="reinstallmode_fileverify"></a><dl> <dt><b>REINSTALLMODE_FILEVERIFY</b></dt> </dl> </td> <td width="60%">
///                      Verify the checksum values, and reinstall the file if they are missing or corrupt. This flag only repairs files
///                      that have msidbFileAttributesChecksum in the Attributes column of the File table. </td> </tr> <tr> <td
///                      width="40%"><a id="REINSTALLMODE_FILEREPLACE"></a><a id="reinstallmode_filereplace"></a><dl>
///                      <dt><b>REINSTALLMODE_FILEREPLACE</b></dt> </dl> </td> <td width="60%"> Force all files to be reinstalled,
///                      regardless of checksum or version. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_USERDATA"></a><a
///                      id="reinstallmode_userdata"></a><dl> <dt><b>REINSTALLMODE_USERDATA</b></dt> </dl> </td> <td width="60%"> Rewrite
///                      all required registry entries from the Registry Table that go to the<b>HKEY_CURRENT_USER</b></p> or
///                      <b>HKEY_USERS</b></p> registry hive. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_MACHINEDATA"></a><a
///                      id="reinstallmode_machinedata"></a><dl> <dt><b>REINSTALLMODE_MACHINEDATA</b></dt> </dl> </td> <td width="60%">
///                      Rewrite all required registry entries from the Registry Table that go to the <b>HKEY_LOCAL_MACHINE</b></p>or
///                      <b>HKEY_CLASSES_ROOT</b></p> registry hive. Rewrite all information from the Class Table, Verb Table,
///                      PublishComponent Table, ProgID Table, MIME Table, Icon Table, Extension Table, and AppID Table regardless of
///                      machine or user assignment. Reinstall all qualified components. When reinstalling an application, this option
///                      runs the RegisterTypeLibraries and InstallODBC actions. </td> </tr> <tr> <td width="40%"><a
///                      id="REINSTALLMODE_SHORTCUT"></a><a id="reinstallmode_shortcut"></a><dl> <dt><b>REINSTALLMODE_SHORTCUT</b></dt>
///                      </dl> </td> <td width="60%"> Reinstall all shortcuts and re-cache all icons overwriting any existing shortcuts
///                      and icons. </td> </tr> <tr> <td width="40%"><a id="REINSTALLMODE_PACKAGE"></a><a
///                      id="reinstallmode_package"></a><dl> <dt><b>REINSTALLMODE_PACKAGE</b></dt> </dl> </td> <td width="60%"> Use to run
///                      from the source package and re-cache the local package. Do not use for the first installation of an application
///                      or feature. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The installation failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was
///    passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt>
///    </dl> </td> <td width="60%"> The installation service could not be accessed. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_INSTALL_SUSPEND</b></dt> </dl> </td> <td width="60%"> The installation was suspended and is
///    incomplete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_USEREXIT</b></dt> </dl> </td> <td
///    width="60%"> The user canceled the installation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_FEATURE</b></dt> </dl> </td> <td width="60%"> The feature ID does not
///    identify a known feature. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl>
///    </td> <td width="60%"> The product code does not identify a known product. </td> </tr> </table> For more
///    information, see Displayed Error Messages.
///    
@DllImport("msi")
uint MsiReinstallFeatureW(const(wchar)* szProduct, const(wchar)* szFeature, uint dwReinstallMode);

///The <b>MsiProvideComponent</b> function returns the full component path, performing any necessary installation. This
///function prompts for source if necessary and increments the usage count for the feature.
///Params:
///    szProduct = Specifies the product code for the product that contains the feature with the necessary component.
///    szFeature = Specifies the feature ID of the feature with the necessary component.
///    szComponent = Specifies the component code of the necessary component.
///    dwInstallMode = Defines the installation mode. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                    <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLMODE_DEFAULT"></a><a id="installmode_default"></a><dl>
///                    <dt><b>INSTALLMODE_DEFAULT</b></dt> </dl> </td> <td width="60%"> Provide the component and perform any
///                    installation necessary to provide the component. If the key file of a component in the requested feature, or a
///                    feature parent, is missing, reinstall the feature using MsiReinstallFeature with the following flag bits set:
///                    REINSTALLMODE_FILEMISSING, REINSTALLMODE_FILEOLDERVERSION, REINSTALLMODE_FILEVERIFY, REINSTALLMODE_MACHINEDATA,
///                    REINSTALLMODE_USERDATA and REINSTALLMODE_SHORTCUT. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_EXISTING"></a><a id="installmode_existing"></a><dl> <dt><b>INSTALLMODE_EXISTING</b></dt> </dl>
///                    </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return ERROR_FILE_NOT_FOUND.
///                    This mode verifies that the key file of the component exists. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_NODETECTION"></a><a id="installmode_nodetection"></a><dl> <dt><b>INSTALLMODE_NODETECTION</b></dt>
///                    </dl> </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return
///                    ERROR_FILE_NOT_FOUND. This mode only checks that the component is registered and does not verify that the key
///                    file of the component exists. </td> </tr> <tr> <td width="40%"><a
///                    id="combination_of_the_REINSTALLMODE_flags"></a><a id="combination_of_the_reinstallmode_flags"></a><a
///                    id="COMBINATION_OF_THE_REINSTALLMODE_FLAGS"></a><dl> <dt><b>combination of the REINSTALLMODE flags</b></dt> </dl>
///                    </td> <td width="60%"> Call MsiReinstallFeature to reinstall feature using this parameter for the
///                    <i>dwReinstallMode</i> parameter, and then provide the component. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_NOSOURCERESOLUTION"></a><a id="installmode_nosourceresolution"></a><dl>
///                    <dt><b>INSTALLMODE_NOSOURCERESOLUTION</b></dt> </dl> </td> <td width="60%"> Provide the component only if the
///                    feature's installation state is INSTALLSTATE_LOCAL. If the feature's installation state is INSTALLSTATE_SOURCE,
///                    return ERROR_INSTALL_SOURCE_ABSENT. Otherwise return ERROR_FILE_NOT_FOUND. This mode only checks that the
///                    component is registered and does not verify that the key file exists. </td> </tr> </table>
///    lpPathBuf = Pointer to a variable that receives the path to the component. This parameter can be null.
///    pcchPathBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpPathBuf</i>
///                  parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                  the buffer passed in is too small, the count returned does not include the terminating null character. If
///                  <i>lpPathBuf</i> is null, <i>pcchBuf</i> can be null.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The feature is
///    absent or broken. this error is returned for dwInstallMode = INSTALLMODE_EXISTING. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The installation failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_NOTUSED</b></dt> </dl> </td> <td width="60%"> The
///    component being requested is disabled on the computer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_FEATURE</b></dt>
///    </dl> </td> <td width="60%"> The feature ID does not identify a known feature. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product code does not identify a
///    known product. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td
///    width="60%"> An unrecognized product or a feature name was passed to the function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The buffer overflow is returned.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SOURCE_ABSENT</b></dt> </dl> </td> <td width="60%">
///    Unable to detect a source. </td> </tr> </table> For more information, see Displayed Error Messages.
///    
@DllImport("msi")
uint MsiProvideComponentA(const(char)* szProduct, const(char)* szFeature, const(char)* szComponent, 
                          uint dwInstallMode, const(char)* lpPathBuf, uint* pcchPathBuf);

///The <b>MsiProvideComponent</b> function returns the full component path, performing any necessary installation. This
///function prompts for source if necessary and increments the usage count for the feature.
///Params:
///    szProduct = Specifies the product code for the product that contains the feature with the necessary component.
///    szFeature = Specifies the feature ID of the feature with the necessary component.
///    szComponent = Specifies the component code of the necessary component.
///    dwInstallMode = Defines the installation mode. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                    <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLMODE_DEFAULT"></a><a id="installmode_default"></a><dl>
///                    <dt><b>INSTALLMODE_DEFAULT</b></dt> </dl> </td> <td width="60%"> Provide the component and perform any
///                    installation necessary to provide the component. If the key file of a component in the requested feature, or a
///                    feature parent, is missing, reinstall the feature using MsiReinstallFeature with the following flag bits set:
///                    REINSTALLMODE_FILEMISSING, REINSTALLMODE_FILEOLDERVERSION, REINSTALLMODE_FILEVERIFY, REINSTALLMODE_MACHINEDATA,
///                    REINSTALLMODE_USERDATA and REINSTALLMODE_SHORTCUT. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_EXISTING"></a><a id="installmode_existing"></a><dl> <dt><b>INSTALLMODE_EXISTING</b></dt> </dl>
///                    </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return ERROR_FILE_NOT_FOUND.
///                    This mode verifies that the key file of the component exists. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_NODETECTION"></a><a id="installmode_nodetection"></a><dl> <dt><b>INSTALLMODE_NODETECTION</b></dt>
///                    </dl> </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return
///                    ERROR_FILE_NOT_FOUND. This mode only checks that the component is registered and does not verify that the key
///                    file of the component exists. </td> </tr> <tr> <td width="40%"><a
///                    id="combination_of_the_REINSTALLMODE_flags"></a><a id="combination_of_the_reinstallmode_flags"></a><a
///                    id="COMBINATION_OF_THE_REINSTALLMODE_FLAGS"></a><dl> <dt><b>combination of the REINSTALLMODE flags</b></dt> </dl>
///                    </td> <td width="60%"> Call MsiReinstallFeature to reinstall feature using this parameter for the
///                    <i>dwReinstallMode</i> parameter, and then provide the component. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_NOSOURCERESOLUTION"></a><a id="installmode_nosourceresolution"></a><dl>
///                    <dt><b>INSTALLMODE_NOSOURCERESOLUTION</b></dt> </dl> </td> <td width="60%"> Provide the component only if the
///                    feature's installation state is INSTALLSTATE_LOCAL. If the feature's installation state is INSTALLSTATE_SOURCE,
///                    return ERROR_INSTALL_SOURCE_ABSENT. Otherwise return ERROR_FILE_NOT_FOUND. This mode only checks that the
///                    component is registered and does not verify that the key file exists. </td> </tr> </table>
///    lpPathBuf = Pointer to a variable that receives the path to the component. This parameter can be null.
///    pcchPathBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpPathBuf</i>
///                  parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                  the buffer passed in is too small, the count returned does not include the terminating null character. If
///                  <i>lpPathBuf</i> is null, <i>pcchBuf</i> can be null.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The feature is
///    absent or broken. this error is returned for dwInstallMode = INSTALLMODE_EXISTING. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The installation failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_NOTUSED</b></dt> </dl> </td> <td width="60%"> The
///    component being requested is disabled on the computer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_FEATURE</b></dt>
///    </dl> </td> <td width="60%"> The feature ID does not identify a known feature. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product code does not identify a
///    known product. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td
///    width="60%"> An unrecognized product or a feature name was passed to the function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The buffer overflow is returned.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SOURCE_ABSENT</b></dt> </dl> </td> <td width="60%">
///    Unable to detect a source. </td> </tr> </table> For more information, see Displayed Error Messages.
///    
@DllImport("msi")
uint MsiProvideComponentW(const(wchar)* szProduct, const(wchar)* szFeature, const(wchar)* szComponent, 
                          uint dwInstallMode, const(wchar)* lpPathBuf, uint* pcchPathBuf);

///The <b>MsiProvideQualifiedComponent</b> function returns the full component path for a qualified component and
///performs any necessary installation. This function prompts for source if necessary, and increments the usage count
///for the feature.
///Params:
///    szCategory = Specifies the component ID for the requested component. This may not be the GUID for the component itself, but
///                 rather a server that provides the correct functionality, as in the ComponentId column of the PublishComponent
///                 table.
///    szQualifier = Specifies a qualifier into a list of advertising components (from PublishComponent Table).
///    dwInstallMode = Defines the installation mode. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                    <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLMODE_DEFAULT"></a><a id="installmode_default"></a><dl>
///                    <dt><b>INSTALLMODE_DEFAULT</b></dt> </dl> </td> <td width="60%"> Provide the component and perform any
///                    installation necessary to provide the component. If the key file of a component in the requested feature, or a
///                    feature parent, is missing, reinstall the feature using MsiReinstallFeature with the following flag bits set:
///                    REINSTALLMODE_FILEMISSING, REINSTALLMODE_FILEOLDERVERSION, REINSTALLMODE_FILEVERIFY, REINSTALLMODE_MACHINEDATA,
///                    REINSTALLMODE_USERDATA, and REINSTALLMODE_SHORTCUT. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_EXISTING"></a><a id="installmode_existing"></a><dl> <dt><b>INSTALLMODE_EXISTING</b></dt> </dl>
///                    </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return ERROR_FILE_NOT_FOUND.
///                    This mode verifies that the key file of the component exists. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_NODETECTION"></a><a id="installmode_nodetection"></a><dl> <dt><b>INSTALLMODE_NODETECTION</b></dt>
///                    </dl> </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return
///                    ERROR_FILE_NOT_FOUND. This mode only checks that the component is registered and does not verify that the key
///                    file of the component exists. </td> </tr> <tr> <td width="40%"><a
///                    id="combination_of_the_REINSTALLMODE_flags"></a><a id="combination_of_the_reinstallmode_flags"></a><a
///                    id="COMBINATION_OF_THE_REINSTALLMODE_FLAGS"></a><dl> <dt><b>combination of the REINSTALLMODE flags</b></dt> </dl>
///                    </td> <td width="60%"> Call MsiReinstallFeature to reinstall the feature using this parameter for the
///                    <i>dwReinstallMode</i> parameter, and then provide the component. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_NOSOURCERESOLUTION"></a><a id="installmode_nosourceresolution"></a><dl>
///                    <dt><b>INSTALLMODE_NOSOURCERESOLUTION</b></dt> </dl> </td> <td width="60%"> Provide the component only if the
///                    feature's installation state is INSTALLSTATE_LOCAL. If the feature's installation state is INSTALLSTATE_SOURCE,
///                    return ERROR_INSTALL_SOURCE_ABSENT. Otherwise, it returns ERROR_FILE_NOT_FOUND. This mode only checks that the
///                    component is registered and does not verify that the key file exists. </td> </tr> </table>
///    lpPathBuf = Pointer to a variable that receives the path to the component. This parameter can be null.
///    pcchPathBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpPathBuf</i>
///                  parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                  the buffer passed in is too small, the count returned does not include the terminating null character. If
///                  <i>lpPathBuf</i> is null, <i>pcchBuf</i> can be null.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INDEX_ABSENT</b></dt>
///    </dl> </td> <td width="60%"> The component qualifier is invalid or absent. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The feature is absent or
///    broken. This error is returned for dwInstallMode = INSTALLMODE_EXISTING. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The specified component is unknown. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>An error relating to an action</b></dt> </dl> </td> <td width="60%"> See
///    Error Codes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization Error</b></dt> </dl> </td> <td
///    width="60%"> An error relating to initialization occurred. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiProvideQualifiedComponentA(const(char)* szCategory, const(char)* szQualifier, uint dwInstallMode, 
                                   const(char)* lpPathBuf, uint* pcchPathBuf);

///The <b>MsiProvideQualifiedComponent</b> function returns the full component path for a qualified component and
///performs any necessary installation. This function prompts for source if necessary, and increments the usage count
///for the feature.
///Params:
///    szCategory = Specifies the component ID for the requested component. This may not be the GUID for the component itself, but
///                 rather a server that provides the correct functionality, as in the ComponentId column of the PublishComponent
///                 table.
///    szQualifier = Specifies a qualifier into a list of advertising components (from PublishComponent Table).
///    dwInstallMode = Defines the installation mode. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                    <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLMODE_DEFAULT"></a><a id="installmode_default"></a><dl>
///                    <dt><b>INSTALLMODE_DEFAULT</b></dt> </dl> </td> <td width="60%"> Provide the component and perform any
///                    installation necessary to provide the component. If the key file of a component in the requested feature, or a
///                    feature parent, is missing, reinstall the feature using MsiReinstallFeature with the following flag bits set:
///                    REINSTALLMODE_FILEMISSING, REINSTALLMODE_FILEOLDERVERSION, REINSTALLMODE_FILEVERIFY, REINSTALLMODE_MACHINEDATA,
///                    REINSTALLMODE_USERDATA, and REINSTALLMODE_SHORTCUT. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_EXISTING"></a><a id="installmode_existing"></a><dl> <dt><b>INSTALLMODE_EXISTING</b></dt> </dl>
///                    </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return ERROR_FILE_NOT_FOUND.
///                    This mode verifies that the key file of the component exists. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_NODETECTION"></a><a id="installmode_nodetection"></a><dl> <dt><b>INSTALLMODE_NODETECTION</b></dt>
///                    </dl> </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return
///                    ERROR_FILE_NOT_FOUND. This mode only checks that the component is registered and does not verify that the key
///                    file of the component exists. </td> </tr> <tr> <td width="40%"><a
///                    id="combination_of_the_REINSTALLMODE_flags"></a><a id="combination_of_the_reinstallmode_flags"></a><a
///                    id="COMBINATION_OF_THE_REINSTALLMODE_FLAGS"></a><dl> <dt><b>combination of the REINSTALLMODE flags</b></dt> </dl>
///                    </td> <td width="60%"> Call MsiReinstallFeature to reinstall the feature using this parameter for the
///                    <i>dwReinstallMode</i> parameter, and then provide the component. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_NOSOURCERESOLUTION"></a><a id="installmode_nosourceresolution"></a><dl>
///                    <dt><b>INSTALLMODE_NOSOURCERESOLUTION</b></dt> </dl> </td> <td width="60%"> Provide the component only if the
///                    feature's installation state is INSTALLSTATE_LOCAL. If the feature's installation state is INSTALLSTATE_SOURCE,
///                    return ERROR_INSTALL_SOURCE_ABSENT. Otherwise, it returns ERROR_FILE_NOT_FOUND. This mode only checks that the
///                    component is registered and does not verify that the key file exists. </td> </tr> </table>
///    lpPathBuf = Pointer to a variable that receives the path to the component. This parameter can be null.
///    pcchPathBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpPathBuf</i>
///                  parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                  the buffer passed in is too small, the count returned does not include the terminating null character. If
///                  <i>lpPathBuf</i> is null, <i>pcchBuf</i> can be null.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INDEX_ABSENT</b></dt>
///    </dl> </td> <td width="60%"> The component qualifier is invalid or absent. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The feature is absent or
///    broken. This error is returned for dwInstallMode = INSTALLMODE_EXISTING. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The specified component is unknown. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>An error relating to an action</b></dt> </dl> </td> <td width="60%"> See
///    Error Codes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization Error</b></dt> </dl> </td> <td
///    width="60%"> An error relating to initialization occurred. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiProvideQualifiedComponentW(const(wchar)* szCategory, const(wchar)* szQualifier, uint dwInstallMode, 
                                   const(wchar)* lpPathBuf, uint* pcchPathBuf);

///The <b>MsiProvideQualifiedComponentEx</b> function returns the full component path for a qualified component that is
///published by a product and performs any necessary installation. This function prompts for source if necessary and
///increments the usage count for the feature.
///Params:
///    szCategory = Specifies the component ID that for the requested component. This may not be the GUID for the component itself
///                 but rather a server that provides the correct functionality, as in the ComponentId column of the PublishComponent
///                 table.
///    szQualifier = Specifies a qualifier into a list of advertising components (from PublishComponent Table).
///    dwInstallMode = Defines the installation mode. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                    <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLMODE_DEFAULT"></a><a id="installmode_default"></a><dl>
///                    <dt><b>INSTALLMODE_DEFAULT</b></dt> </dl> </td> <td width="60%"> Provide the component and perform any
///                    installation necessary to provide the component. If the key file of a component in the requested feature, or a
///                    feature parent, is missing, reinstall the feature using MsiReinstallFeature with the following flag bits set:
///                    REINSTALLMODE_FILEMISSING, REINSTALLMODE_FILEOLDERVERSION, REINSTALLMODE_FILEVERIFY, REINSTALLMODE_MACHINEDATA,
///                    REINSTALLMODE_USERDATA and REINSTALLMODE_SHORTCUT. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_EXISTING"></a><a id="installmode_existing"></a><dl> <dt><b>INSTALLMODE_EXISTING</b></dt> </dl>
///                    </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return ERROR_FILE_NOT_FOUND.
///                    This mode verifies that the key file of the component exists. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_NODETECTION"></a><a id="installmode_nodetection"></a><dl> <dt><b>INSTALLMODE_NODETECTION</b></dt>
///                    </dl> </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return
///                    ERROR_FILE_NOT_FOUND. This mode only checks that the component is registered and does not verify that the key
///                    file of the component exists. </td> </tr> <tr> <td width="40%"><a id="INSTALLMODE_EXISTING"></a><a
///                    id="installmode_existing"></a><dl> <dt><b>INSTALLMODE_EXISTING</b></dt> </dl> </td> <td width="60%"> Provide the
///                    component only if the feature exists, else return ERROR_FILE_NOT_FOUND. </td> </tr> <tr> <td width="40%"><a
///                    id="combination_of_the_REINSTALLMODE_flags"></a><a id="combination_of_the_reinstallmode_flags"></a><a
///                    id="COMBINATION_OF_THE_REINSTALLMODE_FLAGS"></a><dl> <dt><b>combination of the REINSTALLMODE flags</b></dt> </dl>
///                    </td> <td width="60%"> Call MsiReinstallFeature to reinstall feature using this parameter for the
///                    <i>dwReinstallMode</i> parameter, and then provide the component. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_NOSOURCERESOLUTION"></a><a id="installmode_nosourceresolution"></a><dl>
///                    <dt><b>INSTALLMODE_NOSOURCERESOLUTION</b></dt> </dl> </td> <td width="60%"> Provide the component only if the
///                    feature's installation state is INSTALLSTATE_LOCAL. If the feature's installation state is INSTALLSTATE_SOURCE,
///                    return ERROR_INSTALL_SOURCE_ABSENT. Otherwise return ERROR_FILE_NOT_FOUND. This mode only checks that the
///                    component is registered and does not verify that the key file exists. </td> </tr> </table>
///    szProduct = Specifies the product to match that has published the qualified component. If this is null, then this API works
///                the same as MsiProvideQualifiedComponent.
///    dwUnused1 = Reserved. Must be zero.
///    dwUnused2 = Reserved. Must be zero.
///    lpPathBuf = Pointer to a variable that receives the path to the component. This parameter can be null.
///    pcchPathBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpPathBuf</i>
///                  parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                  the buffer passed in is too small, the count returned does not include the terminating null character. If
///                  <i>lpPathBuf</i> is null, <i>pcchBuf</i> can be null.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INDEX_ABSENT</b></dt>
///    </dl> </td> <td width="60%"> Component qualifier invalid or not present. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The feature is absent or
///    broken. this error is returned for <i>dwInstallMode</i> = INSTALLMODE_EXISTING. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The specified component is unknown.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error relating to an action</b></dt> </dl> </td> <td
///    width="60%"> See Error Codes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization Error</b></dt> </dl>
///    </td> <td width="60%"> An error relating to initialization occurred. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiProvideQualifiedComponentExA(const(char)* szCategory, const(char)* szQualifier, uint dwInstallMode, 
                                     const(char)* szProduct, uint dwUnused1, uint dwUnused2, const(char)* lpPathBuf, 
                                     uint* pcchPathBuf);

///The <b>MsiProvideQualifiedComponentEx</b> function returns the full component path for a qualified component that is
///published by a product and performs any necessary installation. This function prompts for source if necessary and
///increments the usage count for the feature.
///Params:
///    szCategory = Specifies the component ID that for the requested component. This may not be the GUID for the component itself
///                 but rather a server that provides the correct functionality, as in the ComponentId column of the PublishComponent
///                 table.
///    szQualifier = Specifies a qualifier into a list of advertising components (from PublishComponent Table).
///    dwInstallMode = Defines the installation mode. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                    <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLMODE_DEFAULT"></a><a id="installmode_default"></a><dl>
///                    <dt><b>INSTALLMODE_DEFAULT</b></dt> </dl> </td> <td width="60%"> Provide the component and perform any
///                    installation necessary to provide the component. If the key file of a component in the requested feature, or a
///                    feature parent, is missing, reinstall the feature using MsiReinstallFeature with the following flag bits set:
///                    REINSTALLMODE_FILEMISSING, REINSTALLMODE_FILEOLDERVERSION, REINSTALLMODE_FILEVERIFY, REINSTALLMODE_MACHINEDATA,
///                    REINSTALLMODE_USERDATA and REINSTALLMODE_SHORTCUT. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_EXISTING"></a><a id="installmode_existing"></a><dl> <dt><b>INSTALLMODE_EXISTING</b></dt> </dl>
///                    </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return ERROR_FILE_NOT_FOUND.
///                    This mode verifies that the key file of the component exists. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_NODETECTION"></a><a id="installmode_nodetection"></a><dl> <dt><b>INSTALLMODE_NODETECTION</b></dt>
///                    </dl> </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return
///                    ERROR_FILE_NOT_FOUND. This mode only checks that the component is registered and does not verify that the key
///                    file of the component exists. </td> </tr> <tr> <td width="40%"><a id="INSTALLMODE_EXISTING"></a><a
///                    id="installmode_existing"></a><dl> <dt><b>INSTALLMODE_EXISTING</b></dt> </dl> </td> <td width="60%"> Provide the
///                    component only if the feature exists, else return ERROR_FILE_NOT_FOUND. </td> </tr> <tr> <td width="40%"><a
///                    id="combination_of_the_REINSTALLMODE_flags"></a><a id="combination_of_the_reinstallmode_flags"></a><a
///                    id="COMBINATION_OF_THE_REINSTALLMODE_FLAGS"></a><dl> <dt><b>combination of the REINSTALLMODE flags</b></dt> </dl>
///                    </td> <td width="60%"> Call MsiReinstallFeature to reinstall feature using this parameter for the
///                    <i>dwReinstallMode</i> parameter, and then provide the component. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_NOSOURCERESOLUTION"></a><a id="installmode_nosourceresolution"></a><dl>
///                    <dt><b>INSTALLMODE_NOSOURCERESOLUTION</b></dt> </dl> </td> <td width="60%"> Provide the component only if the
///                    feature's installation state is INSTALLSTATE_LOCAL. If the feature's installation state is INSTALLSTATE_SOURCE,
///                    return ERROR_INSTALL_SOURCE_ABSENT. Otherwise return ERROR_FILE_NOT_FOUND. This mode only checks that the
///                    component is registered and does not verify that the key file exists. </td> </tr> </table>
///    szProduct = Specifies the product to match that has published the qualified component. If this is null, then this API works
///                the same as MsiProvideQualifiedComponent.
///    dwUnused1 = Reserved. Must be zero.
///    dwUnused2 = Reserved. Must be zero.
///    lpPathBuf = Pointer to a variable that receives the path to the component. This parameter can be null.
///    pcchPathBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpPathBuf</i>
///                  parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                  the buffer passed in is too small, the count returned does not include the terminating null character. If
///                  <i>lpPathBuf</i> is null, <i>pcchBuf</i> can be null.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INDEX_ABSENT</b></dt>
///    </dl> </td> <td width="60%"> Component qualifier invalid or not present. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The feature is absent or
///    broken. this error is returned for <i>dwInstallMode</i> = INSTALLMODE_EXISTING. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The specified component is unknown.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>An error relating to an action</b></dt> </dl> </td> <td
///    width="60%"> See Error Codes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>Initialization Error</b></dt> </dl>
///    </td> <td width="60%"> An error relating to initialization occurred. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiProvideQualifiedComponentExW(const(wchar)* szCategory, const(wchar)* szQualifier, uint dwInstallMode, 
                                     const(wchar)* szProduct, uint dwUnused1, uint dwUnused2, 
                                     const(wchar)* lpPathBuf, uint* pcchPathBuf);

///The <b>MsiGetComponentPath</b> function returns the full path to an installed component. If the key path for the
///component is a registry key then the registry key is returned.
///Params:
///    szProduct = Specifies the product code for the client product.
///    szComponent = Specifies the component ID of the component to be located.
///    lpPathBuf = Pointer to a variable that receives the path to the component. This parameter can be null. If the component is a
///                registry key, the registry roots are represented numerically. If this is a registry subkey path, there is a
///                backslash at the end of the Key Path. If this is a registry value key path, there is no backslash at the end. For
///                example, a registry path on a 32-bit operating system of <b>HKEY_CURRENT_USER</b>&
///    pcchBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpPathBuf</i>
///              parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///              the buffer passed in is too small, the count returned does not include the terminating null character. If
///              <i>lpPathBuf</i> is null, <i>pcchBuf</i> can be null.
///Returns:
///    The <b>MsiGetComponentPath</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_NOTUSED</b></dt> </dl> </td> <td
///    width="60%"> The component being requested is disabled on the computer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> The component is not installed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>INSTALLSTATE_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the function
///    parameters is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td
///    width="60%"> The component is installed locally. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The component is installed to run from source.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_SOURCEABSENT</b></dt> </dl> </td> <td width="60%"> The
///    component source is inaccessible. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt>
///    </dl> </td> <td width="60%"> The product code or component ID is unknown. </td> </tr> </table>
///    
@DllImport("msi")
INSTALLSTATE MsiGetComponentPathA(const(char)* szProduct, const(char)* szComponent, const(char)* lpPathBuf, 
                                  uint* pcchBuf);

///The <b>MsiGetComponentPath</b> function returns the full path to an installed component. If the key path for the
///component is a registry key then the registry key is returned.
///Params:
///    szProduct = Specifies the product code for the client product.
///    szComponent = Specifies the component ID of the component to be located.
///    lpPathBuf = Pointer to a variable that receives the path to the component. This parameter can be null. If the component is a
///                registry key, the registry roots are represented numerically. If this is a registry subkey path, there is a
///                backslash at the end of the Key Path. If this is a registry value key path, there is no backslash at the end. For
///                example, a registry path on a 32-bit operating system of <b>HKEY_CURRENT_USER</b>&
///    pcchBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpPathBuf</i>
///              parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///              the buffer passed in is too small, the count returned does not include the terminating null character. If
///              <i>lpPathBuf</i> is null, <i>pcchBuf</i> can be null.
///Returns:
///    The <b>MsiGetComponentPath</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_NOTUSED</b></dt> </dl> </td> <td
///    width="60%"> The component being requested is disabled on the computer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> The component is not installed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>INSTALLSTATE_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the function
///    parameters is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td
///    width="60%"> The component is installed locally. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The component is installed to run from source.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_SOURCEABSENT</b></dt> </dl> </td> <td width="60%"> The
///    component source is inaccessible. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt>
///    </dl> </td> <td width="60%"> The product code or component ID is unknown. </td> </tr> </table>
///    
@DllImport("msi")
INSTALLSTATE MsiGetComponentPathW(const(wchar)* szProduct, const(wchar)* szComponent, const(wchar)* lpPathBuf, 
                                  uint* pcchBuf);

///The <b>MsiGetComponentPathEx</b> function returns the full path to an installed component. If the key path for the
///component is a registry key then the function returns the registry key. This function extends the existing
///MsiGetComponentPath function to enable searches for components across user accounts and installation contexts.
///Params:
///    szProductCode = A null-terminated string value that specifies an application's product code GUID. The function gets the path of
///                    installed components used by this application.
///    szComponentCode = A null-terminated string value that specifies a component code GUID. The function gets the path of an installed
///                      component having this component code.
///    szUserSid = A null-terminated string value that specifies the security identifier (SID) for a user in the system. The
///                function gets the paths of installed components of applications installed under the user accounts identified by
///                this SID. The special SID string s-1-1-0 (Everyone) specifies all users in the system. If this parameter is
///                <b>NULL</b>, the function gets the path of an installed component for the currently logged-on user only. <table>
///                <tr> <th>SID type</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl>
///                <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> Specifies the currently logged-on user. </td> </tr> <tr>
///                <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt>
///                </dl> </td> <td width="60%"> Specifies a particular user in the system. An example of an user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> <tr> <td width="40%"><a id="s-1-1-0"></a><a
///                id="S-1-1-0"></a><dl> <dt><b>s-1-1-0</b></dt> </dl> </td> <td width="60%"> Specifies all users in the system.
///                </td> </tr> </table> <div class="alert"><b>Note</b> The special SID string s-1-5-18 (System) cannot be used to
///                search applications installed in the per-machine installation context. Setting the SID value to s-1-5-18 returns
///                <b>ERROR_INVALID_PARAMETER</b>. When <i>dwContext</i> is set to MSIINSTALLCONTEXT_MACHINE only, <i>szUserSid</i>
///                must be <b>NULL</b>.</div> <div> </div>
///    dwContext = A flag that specifies the installation context. The function gets the paths of installed components of
///                applications installed in the specified installation context. This parameter can be a combination of the
///                following values. <table> <tr> <th>Context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Include applications
///                installed in the perusermanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Include applications
///                installed in the peruserunmanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Include applications installed
///                in the per-machine installation context. When <i>dwInstallContext</i> is set to <b>MSIINSTALLCONTEXT_MACHINE</b>
///                only, the <i>szUserSID</i> parameter must be <b>NULL</b>. </td> </tr> </table>
///    lpOutPathBuffer = A string value that receives the path to the component. This parameter can be <b>NULL</b>. If the component is a
///                      registry key, the registry roots are represented numerically. If this is a registry subkey path, there is a
///                      backslash at the end of the Key Path. If this is a registry value key path, there is no backslash at the end. For
///                      example, a registry path on a 32-bit operating system of <b>HKEY_CURRENT_USER</b>&
///    pcchOutPathBuffer = Pointer to a location that receives the size of the buffer, in <b>TCHAR</b>, pointed to by the <i>szPathBuf</i>
///                        parameter. The value in this location should be set to the count of <b>TCHAR</b> in the string including the
///                        terminating null character. If the size of the buffer is too small, this parameter receives the length of the
///                        string value without including the terminating null character in the count.
///Returns:
///    The <b>MsiGetComponentPathEx</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_NOTUSED</b></dt> </dl> </td> <td
///    width="60%"> The component being requested is disabled on the computer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_BADCONFIG</b></dt> </dl> </td> <td width="60%"> Configuration data is corrupt. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> The component is not
///    installed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_INVALIDARG</b></dt> </dl> </td> <td
///    width="60%"> One of the function parameters is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The component is installed locally. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The component is
///    installed to run from source. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_SOURCEABSENT</b></dt>
///    </dl> </td> <td width="60%"> The component source is inaccessible. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> The product code or component ID is unknown.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_BROKEN</b></dt> </dl> </td> <td width="60%"> The
///    component is corrupt or partially missing in some way and requires repair. </td> </tr> </table>
///    
@DllImport("msi")
INSTALLSTATE MsiGetComponentPathExA(const(char)* szProductCode, const(char)* szComponentCode, 
                                    const(char)* szUserSid, MSIINSTALLCONTEXT dwContext, 
                                    const(char)* lpOutPathBuffer, uint* pcchOutPathBuffer);

///The <b>MsiGetComponentPathEx</b> function returns the full path to an installed component. If the key path for the
///component is a registry key then the function returns the registry key. This function extends the existing
///MsiGetComponentPath function to enable searches for components across user accounts and installation contexts.
///Params:
///    szProductCode = A null-terminated string value that specifies an application's product code GUID. The function gets the path of
///                    installed components used by this application.
///    szComponentCode = A null-terminated string value that specifies a component code GUID. The function gets the path of an installed
///                      component having this component code.
///    szUserSid = A null-terminated string value that specifies the security identifier (SID) for a user in the system. The
///                function gets the paths of installed components of applications installed under the user accounts identified by
///                this SID. The special SID string s-1-1-0 (Everyone) specifies all users in the system. If this parameter is
///                <b>NULL</b>, the function gets the path of an installed component for the currently logged-on user only. <table>
///                <tr> <th>SID type</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl>
///                <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> Specifies the currently logged-on user. </td> </tr> <tr>
///                <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt>
///                </dl> </td> <td width="60%"> Specifies a particular user in the system. An example of an user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> <tr> <td width="40%"><a id="s-1-1-0"></a><a
///                id="S-1-1-0"></a><dl> <dt><b>s-1-1-0</b></dt> </dl> </td> <td width="60%"> Specifies all users in the system.
///                </td> </tr> </table> <div class="alert"><b>Note</b> The special SID string s-1-5-18 (System) cannot be used to
///                search applications installed in the per-machine installation context. Setting the SID value to s-1-5-18 returns
///                <b>ERROR_INVALID_PARAMETER</b>. When <i>dwContext</i> is set to MSIINSTALLCONTEXT_MACHINE only, <i>szUserSid</i>
///                must be <b>NULL</b>.</div> <div> </div>
///    dwContext = A flag that specifies the installation context. The function gets the paths of installed components of
///                applications installed in the specified installation context. This parameter can be a combination of the
///                following values. <table> <tr> <th>Context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Include applications
///                installed in the perusermanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Include applications
///                installed in the peruserunmanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Include applications installed
///                in the per-machine installation context. When <i>dwInstallContext</i> is set to <b>MSIINSTALLCONTEXT_MACHINE</b>
///                only, the <i>szUserSID</i> parameter must be <b>NULL</b>. </td> </tr> </table>
///    lpOutPathBuffer = A string value that receives the path to the component. This parameter can be <b>NULL</b>. If the component is a
///                      registry key, the registry roots are represented numerically. If this is a registry subkey path, there is a
///                      backslash at the end of the Key Path. If this is a registry value key path, there is no backslash at the end. For
///                      example, a registry path on a 32-bit operating system of <b>HKEY_CURRENT_USER</b>&
///    pcchOutPathBuffer = Pointer to a location that receives the size of the buffer, in <b>TCHAR</b>, pointed to by the <i>szPathBuf</i>
///                        parameter. The value in this location should be set to the count of <b>TCHAR</b> in the string including the
///                        terminating null character. If the size of the buffer is too small, this parameter receives the length of the
///                        string value without including the terminating null character in the count.
///Returns:
///    The <b>MsiGetComponentPathEx</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_NOTUSED</b></dt> </dl> </td> <td
///    width="60%"> The component being requested is disabled on the computer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_BADCONFIG</b></dt> </dl> </td> <td width="60%"> Configuration data is corrupt. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> The component is not
///    installed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_INVALIDARG</b></dt> </dl> </td> <td
///    width="60%"> One of the function parameters is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The component is installed locally. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The component is
///    installed to run from source. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_SOURCEABSENT</b></dt>
///    </dl> </td> <td width="60%"> The component source is inaccessible. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> The product code or component ID is unknown.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_BROKEN</b></dt> </dl> </td> <td width="60%"> The
///    component is corrupt or partially missing in some way and requires repair. </td> </tr> </table>
///    
@DllImport("msi")
INSTALLSTATE MsiGetComponentPathExW(const(wchar)* szProductCode, const(wchar)* szComponentCode, 
                                    const(wchar)* szUserSid, MSIINSTALLCONTEXT dwContext, 
                                    const(wchar)* lpOutPathBuffer, uint* pcchOutPathBuffer);

///The <b>MsiProvideAssembly</b> function returns the full path to a Windows Installer component that contains an
///assembly. The function prompts for a source and performs any necessary installation. <b>MsiProvideAssembly</b>
///increments the usage count for the feature.
///Params:
///    szAssemblyName = The assembly name as a string.
///    szAppContext = Set to null for global assemblies. For private assemblies, set <i>szAppContext</i> to the full path of the
///                   application configuration file or to the full path of the executable file of the application to which the
///                   assembly has been made private.
///    dwInstallMode = Defines the installation mode. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                    <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLMODE_DEFAULT"></a><a id="installmode_default"></a><dl>
///                    <dt><b>INSTALLMODE_DEFAULT</b></dt> </dl> </td> <td width="60%"> Provide the component and perform any
///                    installation necessary to provide the component. If the key file of a component in the requested feature, or a
///                    feature parent, is missing, reinstall the feature using MsiReinstallFeature with the following flag bits set:
///                    REINSTALLMODE_FILEMISSING, REINSTALLMODE_FILEOLDERVERSION, REINSTALLMODE_FILEVERIFY, REINSTALLMODE_MACHINEDATA,
///                    REINSTALLMODE_USERDATA and REINSTALLMODE_SHORTCUT. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_EXISTING"></a><a id="installmode_existing"></a><dl> <dt><b>INSTALLMODE_EXISTING</b></dt> </dl>
///                    </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return ERROR_FILE_NOT_FOUND.
///                    This mode verifies that the key file of the component exists. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_NODETECTION"></a><a id="installmode_nodetection"></a><dl> <dt><b>INSTALLMODE_NODETECTION</b></dt>
///                    </dl> </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return
///                    ERROR_FILE_NOT_FOUND. This mode only checks that the component is registered and does not verify that the key
///                    file of the component exists. </td> </tr> <tr> <td width="40%"><a id="INSTALLMODE_NOSOURCERESOLUTION"></a><a
///                    id="installmode_nosourceresolution"></a><dl> <dt><b>INSTALLMODE_NOSOURCERESOLUTION</b></dt> </dl> </td> <td
///                    width="60%"> Provide the component only if the feature's installation state is INSTALLSTATE_LOCAL. If the feature
///                    installation state is INSTALLSTATE_SOURCE, return ERROR_INSTALL_SOURCE_ABSENT. Otherwise return
///                    ERROR_FILE_NOT_FOUND. This mode only checks that the component is registered and does not verify that the key
///                    file exists. </td> </tr> <tr> <td width="40%"><a id="INSTALLMODE_NODETECTION_ANY"></a><a
///                    id="installmode_nodetection_any"></a><dl> <dt><b>INSTALLMODE_NODETECTION_ANY</b></dt> </dl> </td> <td
///                    width="60%"> Provide the component if a feature exists from any installed product. Otherwise return
///                    ERROR_FILE_NOT_FOUND. This mode only checks that the component is registered and does not verify that the key
///                    file of the component exists. This flag is similar to the INSTALLMODE_NODETECTION flag except that with this flag
///                    we check for any product that has installed the assembly as opposed to the last product as is the case with the
///                    INSTALLMODE_NODETECTION flag. This flag can only be used with <b>MsiProvideAssembly</b>. </td> </tr> <tr> <td
///                    width="40%"><a id="combination_of_the_REINSTALLMODE_flags"></a><a
///                    id="combination_of_the_reinstallmode_flags"></a><a id="COMBINATION_OF_THE_REINSTALLMODE_FLAGS"></a><dl>
///                    <dt><b>combination of the REINSTALLMODE flags</b></dt> </dl> </td> <td width="60%"> Call MsiReinstallFeature to
///                    reinstall feature using this parameter for the <i>dwReinstallMode</i> parameter, and then provide the component.
///                    </td> </tr> </table>
///    dwAssemblyInfo = Assembly information and assembly type. Set to one of the following values. <table> <tr> <th>Value</th>
///                     <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIASSEMBLYINFO_NETASSEMBLY"></a><a
///                     id="msiassemblyinfo_netassembly"></a><dl> <dt><b>MSIASSEMBLYINFO_NETASSEMBLY</b></dt> <dt>0</dt> </dl> </td> <td
///                     width="60%"> .NET Assembly </td> </tr> <tr> <td width="40%"><a id="MSIASSEMBLYINFO_WIN32ASSEMBLY"></a><a
///                     id="msiassemblyinfo_win32assembly"></a><dl> <dt><b>MSIASSEMBLYINFO_WIN32ASSEMBLY</b></dt> <dt>1</dt> </dl> </td>
///                     <td width="60%"> Win32 Assembly </td> </tr> </table>
///    lpPathBuf = Pointer to a variable that receives the path to the component. This parameter can be null.
///    pcchPathBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpPathBuf</i>
///                  parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                  the buffer passed in is too small, the count returned does not include the terminating null character. If
///                  <i>lpPathBuf</i> is null, <i>pcchPathBuf</i> can be null.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The feature is
///    absent or broken. This error is returned for dwInstallMode = INSTALLMODE_EXISTING. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The installation failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_NOTUSED</b></dt> </dl> </td> <td width="60%"> The
///    component being requested is disabled on the computer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_FEATURE</b></dt>
///    </dl> </td> <td width="60%"> The feature ID does not identify a known feature. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The component ID does not specify a
///    known component. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td
///    width="60%"> The product code does not identify a known product. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> An unrecognized product or a feature name was
///    passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td
///    width="60%"> The buffer overflow is returned. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> The system does not have enough memory to
///    complete the operation. Available with Windows Server 2003. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_SOURCE_ABSENT</b></dt> </dl> </td> <td width="60%"> Unable to detect a source. </td> </tr>
///    </table> For more information, see Displayed Error Messages.
///    
@DllImport("msi")
uint MsiProvideAssemblyA(const(char)* szAssemblyName, const(char)* szAppContext, uint dwInstallMode, 
                         uint dwAssemblyInfo, const(char)* lpPathBuf, uint* pcchPathBuf);

///The <b>MsiProvideAssembly</b> function returns the full path to a Windows Installer component that contains an
///assembly. The function prompts for a source and performs any necessary installation. <b>MsiProvideAssembly</b>
///increments the usage count for the feature.
///Params:
///    szAssemblyName = The assembly name as a string.
///    szAppContext = Set to null for global assemblies. For private assemblies, set <i>szAppContext</i> to the full path of the
///                   application configuration file or to the full path of the executable file of the application to which the
///                   assembly has been made private.
///    dwInstallMode = Defines the installation mode. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                    <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLMODE_DEFAULT"></a><a id="installmode_default"></a><dl>
///                    <dt><b>INSTALLMODE_DEFAULT</b></dt> </dl> </td> <td width="60%"> Provide the component and perform any
///                    installation necessary to provide the component. If the key file of a component in the requested feature, or a
///                    feature parent, is missing, reinstall the feature using MsiReinstallFeature with the following flag bits set:
///                    REINSTALLMODE_FILEMISSING, REINSTALLMODE_FILEOLDERVERSION, REINSTALLMODE_FILEVERIFY, REINSTALLMODE_MACHINEDATA,
///                    REINSTALLMODE_USERDATA and REINSTALLMODE_SHORTCUT. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_EXISTING"></a><a id="installmode_existing"></a><dl> <dt><b>INSTALLMODE_EXISTING</b></dt> </dl>
///                    </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return ERROR_FILE_NOT_FOUND.
///                    This mode verifies that the key file of the component exists. </td> </tr> <tr> <td width="40%"><a
///                    id="INSTALLMODE_NODETECTION"></a><a id="installmode_nodetection"></a><dl> <dt><b>INSTALLMODE_NODETECTION</b></dt>
///                    </dl> </td> <td width="60%"> Provide the component only if the feature exists. Otherwise return
///                    ERROR_FILE_NOT_FOUND. This mode only checks that the component is registered and does not verify that the key
///                    file of the component exists. </td> </tr> <tr> <td width="40%"><a id="INSTALLMODE_NOSOURCERESOLUTION"></a><a
///                    id="installmode_nosourceresolution"></a><dl> <dt><b>INSTALLMODE_NOSOURCERESOLUTION</b></dt> </dl> </td> <td
///                    width="60%"> Provide the component only if the feature's installation state is INSTALLSTATE_LOCAL. If the feature
///                    installation state is INSTALLSTATE_SOURCE, return ERROR_INSTALL_SOURCE_ABSENT. Otherwise return
///                    ERROR_FILE_NOT_FOUND. This mode only checks that the component is registered and does not verify that the key
///                    file exists. </td> </tr> <tr> <td width="40%"><a id="INSTALLMODE_NODETECTION_ANY"></a><a
///                    id="installmode_nodetection_any"></a><dl> <dt><b>INSTALLMODE_NODETECTION_ANY</b></dt> </dl> </td> <td
///                    width="60%"> Provide the component if a feature exists from any installed product. Otherwise return
///                    ERROR_FILE_NOT_FOUND. This mode only checks that the component is registered and does not verify that the key
///                    file of the component exists. This flag is similar to the INSTALLMODE_NODETECTION flag except that with this flag
///                    we check for any product that has installed the assembly as opposed to the last product as is the case with the
///                    INSTALLMODE_NODETECTION flag. This flag can only be used with <b>MsiProvideAssembly</b>. </td> </tr> <tr> <td
///                    width="40%"><a id="combination_of_the_REINSTALLMODE_flags"></a><a
///                    id="combination_of_the_reinstallmode_flags"></a><a id="COMBINATION_OF_THE_REINSTALLMODE_FLAGS"></a><dl>
///                    <dt><b>combination of the REINSTALLMODE flags</b></dt> </dl> </td> <td width="60%"> Call MsiReinstallFeature to
///                    reinstall feature using this parameter for the <i>dwReinstallMode</i> parameter, and then provide the component.
///                    </td> </tr> </table>
///    dwAssemblyInfo = Assembly information and assembly type. Set to one of the following values. <table> <tr> <th>Value</th>
///                     <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIASSEMBLYINFO_NETASSEMBLY"></a><a
///                     id="msiassemblyinfo_netassembly"></a><dl> <dt><b>MSIASSEMBLYINFO_NETASSEMBLY</b></dt> <dt>0</dt> </dl> </td> <td
///                     width="60%"> .NET Assembly </td> </tr> <tr> <td width="40%"><a id="MSIASSEMBLYINFO_WIN32ASSEMBLY"></a><a
///                     id="msiassemblyinfo_win32assembly"></a><dl> <dt><b>MSIASSEMBLYINFO_WIN32ASSEMBLY</b></dt> <dt>1</dt> </dl> </td>
///                     <td width="60%"> Win32 Assembly </td> </tr> </table>
///    lpPathBuf = Pointer to a variable that receives the path to the component. This parameter can be null.
///    pcchPathBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpPathBuf</i>
///                  parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                  the buffer passed in is too small, the count returned does not include the terminating null character. If
///                  <i>lpPathBuf</i> is null, <i>pcchPathBuf</i> can be null.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The feature is
///    absent or broken. This error is returned for dwInstallMode = INSTALLMODE_EXISTING. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The installation failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_NOTUSED</b></dt> </dl> </td> <td width="60%"> The
///    component being requested is disabled on the computer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_FEATURE</b></dt>
///    </dl> </td> <td width="60%"> The feature ID does not identify a known feature. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The component ID does not specify a
///    known component. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td
///    width="60%"> The product code does not identify a known product. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> An unrecognized product or a feature name was
///    passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td
///    width="60%"> The buffer overflow is returned. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> The system does not have enough memory to
///    complete the operation. Available with Windows Server 2003. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_SOURCE_ABSENT</b></dt> </dl> </td> <td width="60%"> Unable to detect a source. </td> </tr>
///    </table> For more information, see Displayed Error Messages.
///    
@DllImport("msi")
uint MsiProvideAssemblyW(const(wchar)* szAssemblyName, const(wchar)* szAppContext, uint dwInstallMode, 
                         uint dwAssemblyInfo, const(wchar)* lpPathBuf, uint* pcchPathBuf);

///The <b>MsiQueryComponentState</b> function returns the installed state for a component. This function can query for a
///component of an instance of a product that is installed under user accounts other than the current user provided the
///product is not advertised under the per-user-unmanaged context for a user account other than the current user. The
///calling process must have administrative privileges to get information for a product installed for a user other than
///the current user.
///Params:
///    szProductCode = Specifies the ProductCode GUID for the product that contains the component.
///    szUserSid = Specifies the security identifier (SID) of the account under which the instance of the product being queried
///                exists. If <i>dwContext</i> is not MSIINSTALLCONTEXT_MACHINE, null specifies the current user. <table> <tr>
///                <th>Type of SID</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl>
///                <dt><b>NULL</b></dt> </dl> </td> <td width="60%"> NULL denotes the currently logged on user. </td> </tr> <tr> <td
///                width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl>
///                </td> <td width="60%"> Specifies enumeration for a particular user in the system. An example of user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div class="alert"><b>Note</b> The special
///                SID string "S-1-5-18" (system) cannot be used to enumerate products installed as per-machine. If <i>dwContext</i>
///                is <b>MSIINSTALLCONTEXT_MACHINE</b>, <i>szUserSid</i> must be null.</div> <div> </div>
///    dwContext = The installation context of the product instance being queried. <table> <tr> <th>Name</th> <th>Meaning</th> </tr>
///                <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> Retrieves the component's state for
///                the perusermanaged instance of the product. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td width="60%"> Retrieves the component's state for
///                the perusernon-managed instance of the product. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> Retrieves the component's state for the
///                per-machine instance of the product. </td> </tr> </table>
///    szComponentCode = Specifies the component being queried. Component code GUID of the component as found in the ComponentID column of
///                      the Component table.
///    pdwState = Installation state of the component for the specified product instance. This parameter can return one of the
///               following or null values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="INSTALLSTATE_LOCAL"></a><a id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td>
///               <td width="60%"> The component is installed locally. </td> </tr> <tr> <td width="40%"><a
///               id="INSTALLSTATE_SOURCE"></a><a id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td>
///               <td width="60%"> The component is installed to run from the source. </td> </tr> </table>
///Returns:
///    The <b>MsiQueryComponentState</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The calling process must have administrative privileges to get information for a product installed
///    for a user other than the current user. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The component ID does not identify a known
///    component. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td
///    width="60%"> The product code does not identify a known product. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> Failures that cannot be ascribed to any
///    Windows error code. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td
///    width="60%"> Buffer too small to get the user SID. </td> </tr> </table> For more information, see Displayed Error
///    Messages.
///    
@DllImport("msi")
uint MsiQueryComponentStateA(const(char)* szProductCode, const(char)* szUserSid, MSIINSTALLCONTEXT dwContext, 
                             const(char)* szComponentCode, INSTALLSTATE* pdwState);

///The <b>MsiQueryComponentState</b> function returns the installed state for a component. This function can query for a
///component of an instance of a product that is installed under user accounts other than the current user provided the
///product is not advertised under the per-user-unmanaged context for a user account other than the current user. The
///calling process must have administrative privileges to get information for a product installed for a user other than
///the current user.
///Params:
///    szProductCode = Specifies the ProductCode GUID for the product that contains the component.
///    szUserSid = Specifies the security identifier (SID) of the account under which the instance of the product being queried
///                exists. If <i>dwContext</i> is not MSIINSTALLCONTEXT_MACHINE, null specifies the current user. <table> <tr>
///                <th>Type of SID</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl>
///                <dt><b>NULL</b></dt> </dl> </td> <td width="60%"> NULL denotes the currently logged on user. </td> </tr> <tr> <td
///                width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl>
///                </td> <td width="60%"> Specifies enumeration for a particular user in the system. An example of user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div class="alert"><b>Note</b> The special
///                SID string "S-1-5-18" (system) cannot be used to enumerate products installed as per-machine. If <i>dwContext</i>
///                is <b>MSIINSTALLCONTEXT_MACHINE</b>, <i>szUserSid</i> must be null.</div> <div> </div>
///    dwContext = The installation context of the product instance being queried. <table> <tr> <th>Name</th> <th>Meaning</th> </tr>
///                <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> Retrieves the component's state for
///                the perusermanaged instance of the product. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td width="60%"> Retrieves the component's state for
///                the perusernon-managed instance of the product. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> Retrieves the component's state for the
///                per-machine instance of the product. </td> </tr> </table>
///    szComponentCode = Specifies the component being queried. Component code GUID of the component as found in the ComponentID column of
///                      the Component table.
///    pdwState = Installation state of the component for the specified product instance. This parameter can return one of the
///               following or null values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="INSTALLSTATE_LOCAL"></a><a id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td>
///               <td width="60%"> The component is installed locally. </td> </tr> <tr> <td width="40%"><a
///               id="INSTALLSTATE_SOURCE"></a><a id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td>
///               <td width="60%"> The component is installed to run from the source. </td> </tr> </table>
///Returns:
///    The <b>MsiQueryComponentState</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The calling process must have administrative privileges to get information for a product installed
///    for a user other than the current user. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The component ID does not identify a known
///    component. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td
///    width="60%"> The product code does not identify a known product. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> Failures that cannot be ascribed to any
///    Windows error code. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td
///    width="60%"> Buffer too small to get the user SID. </td> </tr> </table> For more information, see Displayed Error
///    Messages.
///    
@DllImport("msi")
uint MsiQueryComponentStateW(const(wchar)* szProductCode, const(wchar)* szUserSid, MSIINSTALLCONTEXT dwContext, 
                             const(wchar)* szComponentCode, INSTALLSTATE* pdwState);

///The <b>MsiEnumProducts</b> function enumerates through all the products currently advertised or installed. Products
///that are installed in both the per-user and per-machine installation context and advertisements are enumerated.
///Params:
///    iProductIndex = Specifies the index of the product to retrieve. This parameter should be zero for the first call to the
///                    <b>MsiEnumProducts</b> function and then incremented for subsequent calls. Because products are not ordered, any
///                    new product has an arbitrary index. This means that the function can return products in any order.
///    lpProductBuf = Pointer to a buffer that receives the product code. This buffer must be 39 characters long. The first 38
///                   characters are for the GUID, and the last character is for the terminating null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
///    </dl> </td> <td width="60%"> There are no products to return. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> The system does not have enough memory to
///    complete the operation. Available with Windows Server 2003. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was enumerated. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumProductsA(uint iProductIndex, const(char)* lpProductBuf);

///The <b>MsiEnumProducts</b> function enumerates through all the products currently advertised or installed. Products
///that are installed in both the per-user and per-machine installation context and advertisements are enumerated.
///Params:
///    iProductIndex = Specifies the index of the product to retrieve. This parameter should be zero for the first call to the
///                    <b>MsiEnumProducts</b> function and then incremented for subsequent calls. Because products are not ordered, any
///                    new product has an arbitrary index. This means that the function can return products in any order.
///    lpProductBuf = Pointer to a buffer that receives the product code. This buffer must be 39 characters long. The first 38
///                   characters are for the GUID, and the last character is for the terminating null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
///    </dl> </td> <td width="60%"> There are no products to return. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> The system does not have enough memory to
///    complete the operation. Available with Windows Server 2003. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was enumerated. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumProductsW(uint iProductIndex, const(wchar)* lpProductBuf);

///The <b>MsiEnumProductsEx</b> function enumerates through one or all the instances of products that are currently
///advertised or installed in the specified contexts. This function supersedes MsiEnumProducts.
///Params:
///    szProductCode = ProductCode GUID of the product to be enumerated. Only instances of products within the scope of the context
///                    specified by the <i>szUserSid</i> and <i>dwContext</i> parameters are enumerated. This parameter can be set to
///                    <b>NULL</b> to enumerate all products in the specified context.
///    szUserSid = Null-terminated string that specifies a security identifier (SID) that restricts the context of enumeration. The
///                special SID string s-1-1-0 (Everyone) specifies enumeration across all users in the system. A SID value other
///                than s-1-1-0 is considered a user-SID and restricts enumeration to the current user or any user in the system.
///                This parameter can be set to <b>NULL</b> to restrict the enumeration scope to the current user. <table> <tr>
///                <th>SID type</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl>
///                <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> Specifies the currently logged-on user. </td> </tr> <tr>
///                <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt>
///                </dl> </td> <td width="60%"> Specifies enumeration for a particular user in the system. An example of user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> <tr> <td width="40%"><a id="s-1-1-0"></a><a
///                id="S-1-1-0"></a><dl> <dt><b>s-1-1-0</b></dt> </dl> </td> <td width="60%"> Specifies enumeration across all users
///                in the system. </td> </tr> </table> <div class="alert"><b>Note</b> The special SID string s-1-5-18 (System)
///                cannot be used to enumerate products or patches installed as per-machine. When <i>dwContext</i> is set to
///                MSIINSTALLCONTEXT_MACHINE only, <i>szUserSid</i> must be <b>NULL</b>.</div> <div> </div>
///    dwContext = Restricts the enumeration to a context. This parameter can be any one or a combination of the values shown in the
///                following table. <table> <tr> <th>Context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> Enumeration extended to all
///                perusermanaged installations for the users specified by <i>szUserSid</i>. An invalid SID returns no items.
///                </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> Enumeration extended to all peruserunmanaged installations for the users specified by
///                <i>szUserSid</i>. An invalid SID returns no items. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> Enumeration extended to all per-machine
///                installations. When <i>dwInstallContext</i> is set to MSIINSTALLCONTEXT_MACHINE only, the <i>szUserSID</i>
///                parameter must be <b>NULL</b>. </td> </tr> </table>
///    dwIndex = Specifies the index of the product to retrieve. This parameter must be zero for the first call to the
///              <b>MsiEnumProductsEx</b> function and then incremented for subsequent calls. The index should be incremented,
///              only if the previous call has returned ERROR_SUCCESS. Because products are not ordered, any new product has an
///              arbitrary index. This means that the function can return products in any order.
///    szInstalledProductCode = Null-terminated string of <b>TCHAR</b> that gives the ProductCode GUID of the product instance being enumerated.
///                             This parameter can be <b>NULL</b>.
///    pdwInstalledContext = Returns the context of the product instance being enumerated. The output value can be
///                          MSIINSTALLCONTEXT_USERMANAGED, MSIINSTALLCONTEXT_USERUNMANAGED, or MSIINSTALLCONTEXT_MACHINE. This parameter can
///                          be <b>NULL</b>.
///    szSid = An output buffer that receives the string SID of the account under which this product instance exists. This
///            buffer returns an empty string for an instance installed in a per-machine context. This buffer should be large
///            enough to contain the SID. If the buffer is too small, the function returns ERROR_MORE_DATA and sets
///            *<i>pcchSid</i> to the number of <b>TCHAR</b> in the SID, not including the terminating NULL character. If
///            <i>szSid</i> is set to <b>NULL</b> and <i>pcchSid</i> is set to a valid pointer, the function returns
///            ERROR_SUCCESS and sets *<i>pcchSid</i> to the number of <b>TCHAR</b> in the value, not including the terminating
///            <b>NULL</b>. The function can then be called again to retrieve the value, with the <i>szSid</i> buffer large
///            enough to contain *<i>pcchSid</i> + 1 characters. If <i>szSid</i> and <i>pcchSid</i> are both set to <b>NULL</b>,
///            the function returns ERROR_SUCCESS if the value exists, without retrieving the value.
///    pcchSid = When calling the function, this parameter should be a pointer to a variable that specifies the number of
///              <b>TCHAR</b> in the <i>szSid</i> buffer. When the function returns, this parameter is set to the size of the
///              requested value whether or not the function copies the value into the specified buffer. The size is returned as
///              the number of <b>TCHAR</b> in the requested value, not including the terminating null character. This parameter
///              can be set to <b>NULL</b> only if <i>szSid</i> is also <b>NULL</b>, otherwise the function returns
///              ERROR_INVALID_PARAMETER.
///Returns:
///    The <b>MsiEnumProductsEx</b> function returns one of the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> If the scope includes users other than the current user, you need administrator privileges. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The
///    configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt>
///    </dl> </td> <td width="60%"> An invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%"> There are no more products to enumerate.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A product is
///    enumerated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%">
///    The <i>szSid</i> parameter is too small to get the user SID. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product is not installed on the computer
///    in the specified context. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl>
///    </td> <td width="60%"> An unexpected internal failure. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumProductsExA(const(char)* szProductCode, const(char)* szUserSid, uint dwContext, uint dwIndex, 
                        char* szInstalledProductCode, MSIINSTALLCONTEXT* pdwInstalledContext, const(char)* szSid, 
                        uint* pcchSid);

///The <b>MsiEnumProductsEx</b> function enumerates through one or all the instances of products that are currently
///advertised or installed in the specified contexts. This function supersedes MsiEnumProducts.
///Params:
///    szProductCode = ProductCode GUID of the product to be enumerated. Only instances of products within the scope of the context
///                    specified by the <i>szUserSid</i> and <i>dwContext</i> parameters are enumerated. This parameter can be set to
///                    <b>NULL</b> to enumerate all products in the specified context.
///    szUserSid = Null-terminated string that specifies a security identifier (SID) that restricts the context of enumeration. The
///                special SID string s-1-1-0 (Everyone) specifies enumeration across all users in the system. A SID value other
///                than s-1-1-0 is considered a user-SID and restricts enumeration to the current user or any user in the system.
///                This parameter can be set to <b>NULL</b> to restrict the enumeration scope to the current user. <table> <tr>
///                <th>SID type</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl>
///                <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> Specifies the currently logged-on user. </td> </tr> <tr>
///                <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt>
///                </dl> </td> <td width="60%"> Specifies enumeration for a particular user in the system. An example of user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> <tr> <td width="40%"><a id="s-1-1-0"></a><a
///                id="S-1-1-0"></a><dl> <dt><b>s-1-1-0</b></dt> </dl> </td> <td width="60%"> Specifies enumeration across all users
///                in the system. </td> </tr> </table> <div class="alert"><b>Note</b> The special SID string s-1-5-18 (System)
///                cannot be used to enumerate products or patches installed as per-machine. When <i>dwContext</i> is set to
///                MSIINSTALLCONTEXT_MACHINE only, <i>szUserSid</i> must be <b>NULL</b>.</div> <div> </div>
///    dwContext = Restricts the enumeration to a context. This parameter can be any one or a combination of the values shown in the
///                following table. <table> <tr> <th>Context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> Enumeration extended to all
///                perusermanaged installations for the users specified by <i>szUserSid</i>. An invalid SID returns no items.
///                </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> Enumeration extended to all peruserunmanaged installations for the users specified by
///                <i>szUserSid</i>. An invalid SID returns no items. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> Enumeration extended to all per-machine
///                installations. When <i>dwInstallContext</i> is set to MSIINSTALLCONTEXT_MACHINE only, the <i>szUserSID</i>
///                parameter must be <b>NULL</b>. </td> </tr> </table>
///    dwIndex = Specifies the index of the product to retrieve. This parameter must be zero for the first call to the
///              <b>MsiEnumProductsEx</b> function and then incremented for subsequent calls. The index should be incremented,
///              only if the previous call has returned ERROR_SUCCESS. Because products are not ordered, any new product has an
///              arbitrary index. This means that the function can return products in any order.
///    szInstalledProductCode = Null-terminated string of <b>TCHAR</b> that gives the ProductCode GUID of the product instance being enumerated.
///                             This parameter can be <b>NULL</b>.
///    pdwInstalledContext = Returns the context of the product instance being enumerated. The output value can be
///                          MSIINSTALLCONTEXT_USERMANAGED, MSIINSTALLCONTEXT_USERUNMANAGED, or MSIINSTALLCONTEXT_MACHINE. This parameter can
///                          be <b>NULL</b>.
///    szSid = An output buffer that receives the string SID of the account under which this product instance exists. This
///            buffer returns an empty string for an instance installed in a per-machine context. This buffer should be large
///            enough to contain the SID. If the buffer is too small, the function returns ERROR_MORE_DATA and sets
///            *<i>pcchSid</i> to the number of <b>TCHAR</b> in the SID, not including the terminating NULL character. If
///            <i>szSid</i> is set to <b>NULL</b> and <i>pcchSid</i> is set to a valid pointer, the function returns
///            ERROR_SUCCESS and sets *<i>pcchSid</i> to the number of <b>TCHAR</b> in the value, not including the terminating
///            <b>NULL</b>. The function can then be called again to retrieve the value, with the <i>szSid</i> buffer large
///            enough to contain *<i>pcchSid</i> + 1 characters. If <i>szSid</i> and <i>pcchSid</i> are both set to <b>NULL</b>,
///            the function returns ERROR_SUCCESS if the value exists, without retrieving the value.
///    pcchSid = When calling the function, this parameter should be a pointer to a variable that specifies the number of
///              <b>TCHAR</b> in the <i>szSid</i> buffer. When the function returns, this parameter is set to the size of the
///              requested value whether or not the function copies the value into the specified buffer. The size is returned as
///              the number of <b>TCHAR</b> in the requested value, not including the terminating null character. This parameter
///              can be set to <b>NULL</b> only if <i>szSid</i> is also <b>NULL</b>, otherwise the function returns
///              ERROR_INVALID_PARAMETER.
///Returns:
///    The <b>MsiEnumProductsEx</b> function returns one of the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> If the scope includes users other than the current user, you need administrator privileges. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The
///    configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt>
///    </dl> </td> <td width="60%"> An invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%"> There are no more products to enumerate.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A product is
///    enumerated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%">
///    The <i>szSid</i> parameter is too small to get the user SID. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product is not installed on the computer
///    in the specified context. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl>
///    </td> <td width="60%"> An unexpected internal failure. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumProductsExW(const(wchar)* szProductCode, const(wchar)* szUserSid, uint dwContext, uint dwIndex, 
                        char* szInstalledProductCode, MSIINSTALLCONTEXT* pdwInstalledContext, const(wchar)* szSid, 
                        uint* pcchSid);

///The <b>MsiEnumRelatedProducts</b> function enumerates products with a specified upgrade code. This function lists the
///currently installed and advertised products that have the specified UpgradeCode property in their Property table.
///Params:
///    lpUpgradeCode = The null-terminated string specifying the upgrade code of related products that the installer is to enumerate.
///    dwReserved = This parameter is reserved and must be 0.
///    iProductIndex = The zero-based index into the registered products.
///    lpProductBuf = A buffer to receive the product code GUID. This buffer must be 39 characters long. The first 38 characters are
///                   for the GUID, and the last character is for the terminating null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
///    </dl> </td> <td width="60%"> There are no products to return. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> The system does not have enough memory to
///    complete the operation. Available starting with Windows Server 2003. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was enumerated. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumRelatedProductsA(const(char)* lpUpgradeCode, uint dwReserved, uint iProductIndex, 
                             const(char)* lpProductBuf);

///The <b>MsiEnumRelatedProducts</b> function enumerates products with a specified upgrade code. This function lists the
///currently installed and advertised products that have the specified UpgradeCode property in their Property table.
///Params:
///    lpUpgradeCode = The null-terminated string specifying the upgrade code of related products that the installer is to enumerate.
///    dwReserved = This parameter is reserved and must be 0.
///    iProductIndex = The zero-based index into the registered products.
///    lpProductBuf = A buffer to receive the product code GUID. This buffer must be 39 characters long. The first 38 characters are
///                   for the GUID, and the last character is for the terminating null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
///    </dl> </td> <td width="60%"> There are no products to return. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> The system does not have enough memory to
///    complete the operation. Available starting with Windows Server 2003. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was enumerated. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumRelatedProductsW(const(wchar)* lpUpgradeCode, uint dwReserved, uint iProductIndex, 
                             const(wchar)* lpProductBuf);

///The <b>MsiEnumFeatures</b> function enumerates the published features for a given product. This function retrieves
///one feature ID each time it is called.
///Params:
///    szProduct = Null-terminated string specifying the product code of the product whose features are to be enumerated.
///    iFeatureIndex = Specifies the index of the feature to retrieve. This parameter should be zero for the first call to the
///                    <b>MsiEnumFeatures</b> function and then incremented for subsequent calls. Because features are not ordered, any
///                    new feature has an arbitrary index. This means that the function can return features in any order.
///    lpFeatureBuf = Pointer to a buffer that receives the feature ID. The size of the buffer must hold a string value of length
///                   MAX_FEATURE_CHARS+1. The function returns <b>ERROR_MORE_DATA</b> if the length of the feature ID exceeds
///                   <b>MAX_FEATURE_CHARS</b>.
///    lpParentBuf = Pointer to a buffer that receives the feature ID of the parent of the feature. The size of the buffer must hold a
///                  string value of length MAX_FEATURE_CHARS+1. If the length of the feature ID of the parent feature exceeds
///                  <b>MAX_FEATURE_CHARS</b>, only the first <b>MAX_FEATURE_CHARS</b> characters get copied into the buffer.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt>
///    </dl> </td> <td width="60%"> A buffer is too small to hold the requested data. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%"> There are no features to return. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was
///    enumerated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td
///    width="60%"> The specified product is unknown. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiEnumFeaturesA(const(char)* szProduct, uint iFeatureIndex, const(char)* lpFeatureBuf, 
                      const(char)* lpParentBuf);

///The <b>MsiEnumFeatures</b> function enumerates the published features for a given product. This function retrieves
///one feature ID each time it is called.
///Params:
///    szProduct = Null-terminated string specifying the product code of the product whose features are to be enumerated.
///    iFeatureIndex = Specifies the index of the feature to retrieve. This parameter should be zero for the first call to the
///                    <b>MsiEnumFeatures</b> function and then incremented for subsequent calls. Because features are not ordered, any
///                    new feature has an arbitrary index. This means that the function can return features in any order.
///    lpFeatureBuf = Pointer to a buffer that receives the feature ID. The size of the buffer must hold a string value of length
///                   MAX_FEATURE_CHARS+1. The function returns <b>ERROR_MORE_DATA</b> if the length of the feature ID exceeds
///                   <b>MAX_FEATURE_CHARS</b>.
///    lpParentBuf = Pointer to a buffer that receives the feature ID of the parent of the feature. The size of the buffer must hold a
///                  string value of length MAX_FEATURE_CHARS+1. If the length of the feature ID of the parent feature exceeds
///                  <b>MAX_FEATURE_CHARS</b>, only the first <b>MAX_FEATURE_CHARS</b> characters get copied into the buffer.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt>
///    </dl> </td> <td width="60%"> A buffer is too small to hold the requested data. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%"> There are no features to return. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was
///    enumerated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td
///    width="60%"> The specified product is unknown. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiEnumFeaturesW(const(wchar)* szProduct, uint iFeatureIndex, const(wchar)* lpFeatureBuf, 
                      const(wchar)* lpParentBuf);

///The <b>MsiEnumComponents</b> function enumerates the installed components for all products. This function retrieves
///one component code each time it is called.
///Params:
///    iComponentIndex = Specifies the index of the component to retrieve. This parameter should be zero for the first call to the
///                      <b>MsiEnumComponents</b> function and then incremented for subsequent calls. Because components are not ordered,
///                      any new component has an arbitrary index. This means that the function can return components in any order.
///    lpComponentBuf = Pointer to a buffer that receives the component code. This buffer must be 39 characters long. The first 38
///                     characters are for the GUID, and the last character is for the terminating null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
///    </dl> </td> <td width="60%"> There are no components to return. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> The system does not have enough memory to
///    complete the operation. Available with Windows Server 2003. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was enumerated. </td> </tr> </table> <div>
///    </div>
///    
@DllImport("msi")
uint MsiEnumComponentsA(uint iComponentIndex, const(char)* lpComponentBuf);

///The <b>MsiEnumComponents</b> function enumerates the installed components for all products. This function retrieves
///one component code each time it is called.
///Params:
///    iComponentIndex = Specifies the index of the component to retrieve. This parameter should be zero for the first call to the
///                      <b>MsiEnumComponents</b> function and then incremented for subsequent calls. Because components are not ordered,
///                      any new component has an arbitrary index. This means that the function can return components in any order.
///    lpComponentBuf = Pointer to a buffer that receives the component code. This buffer must be 39 characters long. The first 38
///                     characters are for the GUID, and the last character is for the terminating null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
///    </dl> </td> <td width="60%"> There are no components to return. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> The system does not have enough memory to
///    complete the operation. Available with Windows Server 2003. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was enumerated. </td> </tr> </table> <div>
///    </div>
///    
@DllImport("msi")
uint MsiEnumComponentsW(uint iComponentIndex, const(wchar)* lpComponentBuf);

///The <b>MsiEnumComponentsEx</b> function enumerates installed components. The function retrieves the component code
///for one component each time it is called. The component code is the string GUID unique to the component, version, and
///language. <b>Windows Installer 4.5 or earlier: </b>Not supported. This function is available beginning with Windows
///Installer 5.0.
///Params:
///    szUserSid = A null-terminated string that contains a security identifier (SID.) The enumeration of installed components
///                extends to users identified by this SID. The special SID string s-1-1-0 (Everyone) specifies an enumeration of
///                all installed components across all products of all users in the system. A SID value other than s-1-1-0 specifies
///                a user SID for a particular user and restricts the enumeration to instances of applications installed by the
///                specified user. <table> <tr> <th>SID type</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a
///                id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> Specifies the currently logged-on
///                user. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl>
///                <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> An enumeration for a specific user in the system. An
///                example of an user SID is "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> <tr> <td width="40%"><a
///                id="s-1-1-0"></a><a id="S-1-1-0"></a><dl> <dt><b>s-1-1-0</b></dt> </dl> </td> <td width="60%"> Specifies all
///                users in the system. </td> </tr> </table> <div class="alert"><b>Note</b> <p class="note">The special SID string
///                s-1-5-18 (System) cannot be used to enumerate applications installed in the per-machine installation context.
///                Setting the SID value to s-1-5-18 returns ERROR_INVALID_PARAMETER. When <i>dwContext</i> is set to
///                MSIINSTALLCONTEXT_MACHINE only, <i>szUserSid</i> must be <b>NULL</b>. </div> <div> </div>
///    dwContext = A flag that restricts the enumeration of installed component to instances of products installed in the specified
///                installation context. The enumeration includes only product instances installed by the users specified by
///                <i>szUserSid</i>. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Include products that exist
///                in the perusermanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Include products that
///                exist in the peruserunmanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Include products that exist in
///                the per-machine installation context. When <i>dwInstallContext</i> is set to MSIINSTALLCONTEXT_MACHINE only, the
///                <i>szUserSID</i> parameter must be <b>NULL</b>. </td> </tr> </table>
///    dwIndex = Specifies the index of the component to retrieve. This parameter must be zero (0) for the first call to
///              <b>MsiEnumComponentsEx</b> function. For each subsequent call, the index must be incremented by 1. The index
///              should only be incremented if the previous call to the function returns ERROR_SUCCESS. Components are not ordered
///              and can be returned by the function in any order.
///    szInstalledComponentCode = An output buffer that receives the component code GUID for the installed component. The length of the buffer
///                               should be large enough to hold a null-terminated string value containing the component code. The first 38
///                               <b>TCHAR</b> characters receives the GUID for the component, and the 39th character receives a terminating NULL
///                               character.
///    pdwInstalledContext = A flag that gives the installation context the application that installed the component. <table> <tr>
///                          <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERMANAGED"></a><a
///                          id="msiinstallcontext_usermanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> <dt>1</dt> </dl> </td>
///                          <td width="60%"> The application is installed in the perusermanaged installation context. </td> </tr> <tr>
///                          <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                          <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The application is
///                          installed in the peruserunmanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                          id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                          <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> The application is installed in
///                          the per-machine installation installation context. </td> </tr> </table>
///    szSid = Receives the security identifier (SID) that identifies the user that installed the application that owns the
///            component. The location receives an empty string if this instance of the application is installed in a
///            per-machine installation context. The length of the buffer at this location should be large enough to hold a
///            null-terminated string value containing the SID. If the buffer is too small, the function returns
///            <b>ERROR_MORE_DATA</b> and the location pointed to by <i>pcchSid</i> receives the number of <b>TCHAR</b> in the
///            SID, not including the terminating NULL character. If <i>szSid</i> is set to <b>NULL</b> and <i>pcchSid</i> is a
///            valid pointer to a location in memory, the function returns <b>ERROR_SUCCESS</b> and the location receives the
///            number of <b>TCHAR</b> in the SID, not including the terminating null character. The function can then be called
///            again to retrieve the value, with the <i>szSid</i> buffer resized large enough to contain *pcchSid + 1
///            characters. <table> <tr> <th>SID type</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>Empty
///            string</dt> </dl> </td> <td width="60%"> The application is installed in a per-machine installation context.
///            </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User
///            SID</b></dt> </dl> </td> <td width="60%"> The SID for the user in the system that installed the application.
///            </td> </tr> </table>
///    pcchSid = Receives the number of <b>TCHAR</b> in the SID, not including the terminating null character. When the function
///              returns, this variable is set to the size of the requested SID whether or not the function can successfully copy
///              the SID and terminating null character into the buffer location pointed to by <i>szSid</i>. The size is returned
///              as the number of <b>TCHAR</b> in the requested value, not including the terminating null character. This
///              parameter can be set to <b>NULL</b> only if <i>szSid</i> is also <b>NULL</b>, otherwise the function returns
///              <b>ERROR_INVALID_PARAMETER</b>. If <i>szSid</i> and <i>pcchSid</i> are both set to <b>NULL</b>, the function
///              returns <b>ERROR_SUCCESS</b> if the SID exists, without retrieving the SID value.
///Returns:
///    The MsiEnumProductsEx function returns one of the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> Administrator privileges are required to enumerate components of applications installed by users
///    other than the current user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl>
///    </td> <td width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%">
///    There are no more components to enumerate. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt>
///    </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The provided buffer was too small to hold the entire
///    value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%">
///    The function failed. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumComponentsExA(const(char)* szUserSid, uint dwContext, uint dwIndex, char* szInstalledComponentCode, 
                          MSIINSTALLCONTEXT* pdwInstalledContext, const(char)* szSid, uint* pcchSid);

///The <b>MsiEnumComponentsEx</b> function enumerates installed components. The function retrieves the component code
///for one component each time it is called. The component code is the string GUID unique to the component, version, and
///language. <b>Windows Installer 4.5 or earlier: </b>Not supported. This function is available beginning with Windows
///Installer 5.0.
///Params:
///    szUserSid = A null-terminated string that contains a security identifier (SID.) The enumeration of installed components
///                extends to users identified by this SID. The special SID string s-1-1-0 (Everyone) specifies an enumeration of
///                all installed components across all products of all users in the system. A SID value other than s-1-1-0 specifies
///                a user SID for a particular user and restricts the enumeration to instances of applications installed by the
///                specified user. <table> <tr> <th>SID type</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a
///                id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> Specifies the currently logged-on
///                user. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl>
///                <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> An enumeration for a specific user in the system. An
///                example of an user SID is "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> <tr> <td width="40%"><a
///                id="s-1-1-0"></a><a id="S-1-1-0"></a><dl> <dt><b>s-1-1-0</b></dt> </dl> </td> <td width="60%"> Specifies all
///                users in the system. </td> </tr> </table> <div class="alert"><b>Note</b> <p class="note">The special SID string
///                s-1-5-18 (System) cannot be used to enumerate applications installed in the per-machine installation context.
///                Setting the SID value to s-1-5-18 returns ERROR_INVALID_PARAMETER. When <i>dwContext</i> is set to
///                MSIINSTALLCONTEXT_MACHINE only, <i>szUserSid</i> must be <b>NULL</b>. </div> <div> </div>
///    dwContext = A flag that restricts the enumeration of installed component to instances of products installed in the specified
///                installation context. The enumeration includes only product instances installed by the users specified by
///                <i>szUserSid</i>. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Include products that exist
///                in the perusermanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Include products that
///                exist in the peruserunmanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Include products that exist in
///                the per-machine installation context. When <i>dwInstallContext</i> is set to MSIINSTALLCONTEXT_MACHINE only, the
///                <i>szUserSID</i> parameter must be <b>NULL</b>. </td> </tr> </table>
///    dwIndex = Specifies the index of the component to retrieve. This parameter must be zero (0) for the first call to
///              <b>MsiEnumComponentsEx</b> function. For each subsequent call, the index must be incremented by 1. The index
///              should only be incremented if the previous call to the function returns ERROR_SUCCESS. Components are not ordered
///              and can be returned by the function in any order.
///    szInstalledComponentCode = An output buffer that receives the component code GUID for the installed component. The length of the buffer
///                               should be large enough to hold a null-terminated string value containing the component code. The first 38
///                               <b>TCHAR</b> characters receives the GUID for the component, and the 39th character receives a terminating NULL
///                               character.
///    pdwInstalledContext = A flag that gives the installation context the application that installed the component. <table> <tr>
///                          <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERMANAGED"></a><a
///                          id="msiinstallcontext_usermanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> <dt>1</dt> </dl> </td>
///                          <td width="60%"> The application is installed in the perusermanaged installation context. </td> </tr> <tr>
///                          <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                          <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The application is
///                          installed in the peruserunmanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                          id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                          <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> The application is installed in
///                          the per-machine installation installation context. </td> </tr> </table>
///    szSid = Receives the security identifier (SID) that identifies the user that installed the application that owns the
///            component. The location receives an empty string if this instance of the application is installed in a
///            per-machine installation context. The length of the buffer at this location should be large enough to hold a
///            null-terminated string value containing the SID. If the buffer is too small, the function returns
///            <b>ERROR_MORE_DATA</b> and the location pointed to by <i>pcchSid</i> receives the number of <b>TCHAR</b> in the
///            SID, not including the terminating NULL character. If <i>szSid</i> is set to <b>NULL</b> and <i>pcchSid</i> is a
///            valid pointer to a location in memory, the function returns <b>ERROR_SUCCESS</b> and the location receives the
///            number of <b>TCHAR</b> in the SID, not including the terminating null character. The function can then be called
///            again to retrieve the value, with the <i>szSid</i> buffer resized large enough to contain *pcchSid + 1
///            characters. <table> <tr> <th>SID type</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>Empty
///            string</dt> </dl> </td> <td width="60%"> The application is installed in a per-machine installation context.
///            </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User
///            SID</b></dt> </dl> </td> <td width="60%"> The SID for the user in the system that installed the application.
///            </td> </tr> </table>
///    pcchSid = Receives the number of <b>TCHAR</b> in the SID, not including the terminating null character. When the function
///              returns, this variable is set to the size of the requested SID whether or not the function can successfully copy
///              the SID and terminating null character into the buffer location pointed to by <i>szSid</i>. The size is returned
///              as the number of <b>TCHAR</b> in the requested value, not including the terminating null character. This
///              parameter can be set to <b>NULL</b> only if <i>szSid</i> is also <b>NULL</b>, otherwise the function returns
///              <b>ERROR_INVALID_PARAMETER</b>. If <i>szSid</i> and <i>pcchSid</i> are both set to <b>NULL</b>, the function
///              returns <b>ERROR_SUCCESS</b> if the SID exists, without retrieving the SID value.
///Returns:
///    The MsiEnumProductsEx function returns one of the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> Administrator privileges are required to enumerate components of applications installed by users
///    other than the current user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl>
///    </td> <td width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%">
///    There are no more components to enumerate. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt>
///    </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The provided buffer was too small to hold the entire
///    value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%">
///    The function failed. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumComponentsExW(const(wchar)* szUserSid, uint dwContext, uint dwIndex, char* szInstalledComponentCode, 
                          MSIINSTALLCONTEXT* pdwInstalledContext, const(wchar)* szSid, uint* pcchSid);

///The <b>MsiEnumClients</b> function enumerates the clients for a given installed component. The function retrieves one
///product code each time it is called.
///Params:
///    szComponent = Specifies the component whose clients are to be enumerated.
///    iProductIndex = Specifies the index of the client to retrieve. This parameter should be zero for the first call to the
///                    <b>MsiEnumClients</b> function and then incremented for subsequent calls. Because clients are not ordered, any
///                    new client has an arbitrary index. This means that the function can return clients in any order.
///    lpProductBuf = Pointer to a buffer that receives the product code. This buffer must be 39 characters long. The first 38
///                   characters are for the GUID, and the last character is for the terminating null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
///    </dl> </td> <td width="60%"> There are no clients to return. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> The system does not have enough memory to
///    complete the operation. Available with Windows Server 2003. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was enumerated. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The specified component is
///    unknown. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumClientsA(const(char)* szComponent, uint iProductIndex, const(char)* lpProductBuf);

///The <b>MsiEnumClients</b> function enumerates the clients for a given installed component. The function retrieves one
///product code each time it is called.
///Params:
///    szComponent = Specifies the component whose clients are to be enumerated.
///    iProductIndex = Specifies the index of the client to retrieve. This parameter should be zero for the first call to the
///                    <b>MsiEnumClients</b> function and then incremented for subsequent calls. Because clients are not ordered, any
///                    new client has an arbitrary index. This means that the function can return clients in any order.
///    lpProductBuf = Pointer to a buffer that receives the product code. This buffer must be 39 characters long. The first 38
///                   characters are for the GUID, and the last character is for the terminating null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
///    </dl> </td> <td width="60%"> There are no clients to return. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> The system does not have enough memory to
///    complete the operation. Available with Windows Server 2003. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was enumerated. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The specified component is
///    unknown. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumClientsW(const(wchar)* szComponent, uint iProductIndex, const(wchar)* lpProductBuf);

///The <b>MsiEnumClientsEx</b> function enumerates the installed applications that use a specified component. The
///function retrieves a product code for an application each time it is called. <b>Windows Installer 4.5 or earlier:
///</b>Not supported. This function is available beginning with Windows Installer 5.0.
///Params:
///    szComponent = The component code GUID that identifies the component. The function enumerates the applications that use this
///                  component.
///    szUserSid = A null-terminated string value that contains a security identifier (SID.) The enumeration of applications extends
///                to users identified by this SID. The special SID string s-1-1-0 (Everyone) enumerates all applications for all
///                users in the system. A SID value other than s-1-1-0 specifies a user SID for a particular user and enumerates the
///                instances of applications installed by the specified user. <table> <tr> <th>SID type</th> <th>Meaning</th> </tr>
///                <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td
///                width="60%"> Specifies the currently logged-on user. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a
///                id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> Specifies an
///                enumeration for a particular user. An example of an user SID is "S-1-3-64-2415071341-1358098788-3127455600-2561".
///                </td> </tr> <tr> <td width="40%"><a id="s-1-1-0"></a><a id="S-1-1-0"></a><dl> <dt><b>s-1-1-0</b></dt> </dl> </td>
///                <td width="60%"> Specifies an enumeration for all users in the system. </td> </tr> </table> <div
///                class="alert"><b>Note</b> The special SID string s-1-5-18 (System) cannot be used to enumerate applications that
///                exist in the per-machine installation context. Setting the SID value to s-1-5-18 returns
///                <b>ERROR_INVALID_PARAMETER</b>. When <i>dwContext</i> is set to <b>MSIINSTALLCONTEXT_MACHINE</b> only, the value
///                of <i>szUserSid</i> must be <b>NULL</b>. </div> <div> </div>
///    dwContext = A flag that extends the enumeration to instances of applications installed in the specified installation context.
///                The enumeration includes only instances of applications that are installed by the users identified by
///                <i>szUserSid</i>. This can be a combination of the following values. <table> <tr> <th>Context</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERMANAGED"></a><a
///                id="msiinstallcontext_usermanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> <dt>1</dt> </dl> </td>
///                <td width="60%"> Include applications installed in the perusermanaged installation context. </td> </tr>
///                <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Include applications
///                installed in the peruserunmanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Include applications installed
///                in the per-machine installation context. When <i>dwInstallContext</i> is set to <b>MSIINSTALLCONTEXT_MACHINE</b>
///                only, the value of the <i>szUserSID</i> parameter must be <b>NULL</b>. </td> </tr> </table>
///    dwProductIndex = Specifies the index of the application to retrieve. The value of this parameter must be zero (0) in the first
///                     call to the function. For each subsequent call, the index must be incremented by 1. The index should only be
///                     incremented if the previous call to the function returns <b>ERROR_SUCCESS</b>.
///    szProductBuf = A string value that receives the product code for the application. The length of the buffer at this location
///                   should be large enough to hold a null-terminated string value containing the product code. The first 38
///                   <b>TCHAR</b> characters receives the GUID for the component, and the 39th character receives a terminating NULL
///                   character.
///    pdwInstalledContext = A flag that gives the installation context of the application. This can be a combination of the following values.
///                          <table> <tr> <th>Context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                          id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                          <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The application is
///                          installed in the perusermanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                          id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                          <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The application is
///                          installed in the peruserunmanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                          id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                          <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> The application is in the
///                          per-machine installation installation context. </td> </tr> </table>
///    szSid = Receives the security identifier (SID) that identifies the user that installed the application. The location
///            receives an empty string value if this instance of the application exists in a per-machine installation context.
///            The length of the buffer should be large enough to hold a null-terminated string value containing the SID. If the
///            buffer is too small, the function returns <b>ERROR_MORE_DATA</b> and the location pointed to by <i>pcchSid</i>
///            receives the number of <b>TCHAR</b> in the SID, not including the terminating NULL character. If <i>szSid</i> is
///            set to <b>NULL</b> and <i>pcchSid</i> is a valid pointer to a location in memory, the function returns
///            <b>ERROR_SUCCESS</b> and the location receives the number of <b>TCHAR</b> in the SID, not including the
///            terminating null character. The function can then be called again to retrieve the value, with the <i>szSid</i>
///            buffer resized large enough to contain *pcchSid + 1 characters. <table> <tr> <th>SID type</th> <th>Meaning</th>
///            </tr> <tr> <td width="40%"> <dl> <dt>Empty string</dt> </dl> </td> <td width="60%"> The application is installed
///            in a per-machine installation context. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a
///            id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> The SID for the
///            user that installed the product. </td> </tr> </table>
///    pcchSid = Pointer to a location in memory that contains a variable that specifies the number of <b>TCHAR</b> in the SID,
///              not including the terminating null character. When the function returns, this variable is set to the size of the
///              requested SID whether or not the function can successfully copy the SID and terminating null character into the
///              buffer location pointed to by <i>szSid</i>. The size is returned as the number of TCHAR in the requested value,
///              not including the terminating null character. This parameter can be set to <b>NULL</b> only if <i>szSid</i> is
///              also <b>NULL</b>, otherwise the function returns <b>ERROR_INVALID_PARAMETER</b>. If <i>szSid</i> and
///              <i>pcchSid</i> are both set to <b>NULL</b>, the function returns <b>ERROR_SUCCESS</b> if the SID exists, without
///              retrieving the SID value.
///Returns:
///    The <b>MsiEnumClientsEx</b> function returns one of the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> Administrtator privileges are required to enumerate components of applications installed by users
///    other than the current user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl>
///    </td> <td width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%">
///    There are no more applications to enumerate. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt>
///    </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The provided buffer was too small to hold the entire
///    value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%">
///    The function failed. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumClientsExA(const(char)* szComponent, const(char)* szUserSid, uint dwContext, uint dwProductIndex, 
                       char* szProductBuf, MSIINSTALLCONTEXT* pdwInstalledContext, const(char)* szSid, uint* pcchSid);

///The <b>MsiEnumClientsEx</b> function enumerates the installed applications that use a specified component. The
///function retrieves a product code for an application each time it is called. <b>Windows Installer 4.5 or earlier:
///</b>Not supported. This function is available beginning with Windows Installer 5.0.
///Params:
///    szComponent = The component code GUID that identifies the component. The function enumerates the applications that use this
///                  component.
///    szUserSid = A null-terminated string value that contains a security identifier (SID.) The enumeration of applications extends
///                to users identified by this SID. The special SID string s-1-1-0 (Everyone) enumerates all applications for all
///                users in the system. A SID value other than s-1-1-0 specifies a user SID for a particular user and enumerates the
///                instances of applications installed by the specified user. <table> <tr> <th>SID type</th> <th>Meaning</th> </tr>
///                <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td
///                width="60%"> Specifies the currently logged-on user. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a
///                id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> Specifies an
///                enumeration for a particular user. An example of an user SID is "S-1-3-64-2415071341-1358098788-3127455600-2561".
///                </td> </tr> <tr> <td width="40%"><a id="s-1-1-0"></a><a id="S-1-1-0"></a><dl> <dt><b>s-1-1-0</b></dt> </dl> </td>
///                <td width="60%"> Specifies an enumeration for all users in the system. </td> </tr> </table> <div
///                class="alert"><b>Note</b> The special SID string s-1-5-18 (System) cannot be used to enumerate applications that
///                exist in the per-machine installation context. Setting the SID value to s-1-5-18 returns
///                <b>ERROR_INVALID_PARAMETER</b>. When <i>dwContext</i> is set to <b>MSIINSTALLCONTEXT_MACHINE</b> only, the value
///                of <i>szUserSid</i> must be <b>NULL</b>. </div> <div> </div>
///    dwContext = A flag that extends the enumeration to instances of applications installed in the specified installation context.
///                The enumeration includes only instances of applications that are installed by the users identified by
///                <i>szUserSid</i>. This can be a combination of the following values. <table> <tr> <th>Context</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERMANAGED"></a><a
///                id="msiinstallcontext_usermanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> <dt>1</dt> </dl> </td>
///                <td width="60%"> Include applications installed in the perusermanaged installation context. </td> </tr>
///                <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Include applications
///                installed in the peruserunmanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Include applications installed
///                in the per-machine installation context. When <i>dwInstallContext</i> is set to <b>MSIINSTALLCONTEXT_MACHINE</b>
///                only, the value of the <i>szUserSID</i> parameter must be <b>NULL</b>. </td> </tr> </table>
///    dwProductIndex = Specifies the index of the application to retrieve. The value of this parameter must be zero (0) in the first
///                     call to the function. For each subsequent call, the index must be incremented by 1. The index should only be
///                     incremented if the previous call to the function returns <b>ERROR_SUCCESS</b>.
///    szProductBuf = A string value that receives the product code for the application. The length of the buffer at this location
///                   should be large enough to hold a null-terminated string value containing the product code. The first 38
///                   <b>TCHAR</b> characters receives the GUID for the component, and the 39th character receives a terminating NULL
///                   character.
///    pdwInstalledContext = A flag that gives the installation context of the application. This can be a combination of the following values.
///                          <table> <tr> <th>Context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                          id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                          <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The application is
///                          installed in the perusermanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                          id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a id="msiinstallcontext_userunmanaged"></a><dl>
///                          <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The application is
///                          installed in the peruserunmanaged installation context. </td> </tr> <tr> <td width="40%"><a
///                          id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                          <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> The application is in the
///                          per-machine installation installation context. </td> </tr> </table>
///    szSid = Receives the security identifier (SID) that identifies the user that installed the application. The location
///            receives an empty string value if this instance of the application exists in a per-machine installation context.
///            The length of the buffer should be large enough to hold a null-terminated string value containing the SID. If the
///            buffer is too small, the function returns <b>ERROR_MORE_DATA</b> and the location pointed to by <i>pcchSid</i>
///            receives the number of <b>TCHAR</b> in the SID, not including the terminating NULL character. If <i>szSid</i> is
///            set to <b>NULL</b> and <i>pcchSid</i> is a valid pointer to a location in memory, the function returns
///            <b>ERROR_SUCCESS</b> and the location receives the number of <b>TCHAR</b> in the SID, not including the
///            terminating null character. The function can then be called again to retrieve the value, with the <i>szSid</i>
///            buffer resized large enough to contain *pcchSid + 1 characters. <table> <tr> <th>SID type</th> <th>Meaning</th>
///            </tr> <tr> <td width="40%"> <dl> <dt>Empty string</dt> </dl> </td> <td width="60%"> The application is installed
///            in a per-machine installation context. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a
///            id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> The SID for the
///            user that installed the product. </td> </tr> </table>
///    pcchSid = Pointer to a location in memory that contains a variable that specifies the number of <b>TCHAR</b> in the SID,
///              not including the terminating null character. When the function returns, this variable is set to the size of the
///              requested SID whether or not the function can successfully copy the SID and terminating null character into the
///              buffer location pointed to by <i>szSid</i>. The size is returned as the number of TCHAR in the requested value,
///              not including the terminating null character. This parameter can be set to <b>NULL</b> only if <i>szSid</i> is
///              also <b>NULL</b>, otherwise the function returns <b>ERROR_INVALID_PARAMETER</b>. If <i>szSid</i> and
///              <i>pcchSid</i> are both set to <b>NULL</b>, the function returns <b>ERROR_SUCCESS</b> if the SID exists, without
///              retrieving the SID value.
///Returns:
///    The <b>MsiEnumClientsEx</b> function returns one of the following values. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> Administrtator privileges are required to enumerate components of applications installed by users
///    other than the current user. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl>
///    </td> <td width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%">
///    There are no more applications to enumerate. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt>
///    </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The provided buffer was too small to hold the entire
///    value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%">
///    The function failed. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumClientsExW(const(wchar)* szComponent, const(wchar)* szUserSid, uint dwContext, uint dwProductIndex, 
                       char* szProductBuf, MSIINSTALLCONTEXT* pdwInstalledContext, const(wchar)* szSid, 
                       uint* pcchSid);

///The <b>MsiEnumComponentQualifiers</b> function enumerates the advertised qualifiers for the given component. This
///function retrieves one qualifier each time it is called.
///Params:
///    szComponent = Specifies component whose qualifiers are to be enumerated.
///    iIndex = Specifies the index of the qualifier to retrieve. This parameter should be zero for the first call to the
///             <b>MsiEnumComponentQualifiers</b> function and then incremented for subsequent calls. Because qualifiers are not
///             ordered, any new qualifier has an arbitrary index. This means that the function can return qualifiers in any
///             order.
///    lpQualifierBuf = Pointer to a buffer that receives the qualifier code.
///    pcchQualifierBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the
///                       <i>lpQualifierBuf</i> parameter. On input, this size should include the terminating null character. On return,
///                       the value does not include the null character.
///    lpApplicationDataBuf = Pointer to a buffer that receives the application registered data for the qualifier. This parameter can be null.
///    pcchApplicationDataBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the
///                             <i>lpApplicationDataBuf</i> parameter. On input, this size should include the terminating null character. On
///                             return, the value does not include the null character. This parameter can be null only if the
///                             <i>lpApplicationDataBuf </i>parameter is null.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt>
///    </dl> </td> <td width="60%"> A buffer is to small to hold the requested data. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%"> There are no qualifiers to return. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> The system
///    does not have enough memory to complete the operation. Available with Windows Server 2003. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was enumerated. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The specified
///    component is unknown. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumComponentQualifiersA(const(char)* szComponent, uint iIndex, const(char)* lpQualifierBuf, 
                                 uint* pcchQualifierBuf, const(char)* lpApplicationDataBuf, 
                                 uint* pcchApplicationDataBuf);

///The <b>MsiEnumComponentQualifiers</b> function enumerates the advertised qualifiers for the given component. This
///function retrieves one qualifier each time it is called.
///Params:
///    szComponent = Specifies component whose qualifiers are to be enumerated.
///    iIndex = Specifies the index of the qualifier to retrieve. This parameter should be zero for the first call to the
///             <b>MsiEnumComponentQualifiers</b> function and then incremented for subsequent calls. Because qualifiers are not
///             ordered, any new qualifier has an arbitrary index. This means that the function can return qualifiers in any
///             order.
///    lpQualifierBuf = Pointer to a buffer that receives the qualifier code.
///    pcchQualifierBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the
///                       <i>lpQualifierBuf</i> parameter. On input, this size should include the terminating null character. On return,
///                       the value does not include the null character.
///    lpApplicationDataBuf = Pointer to a buffer that receives the application registered data for the qualifier. This parameter can be null.
///    pcchApplicationDataBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the
///                             <i>lpApplicationDataBuf</i> parameter. On input, this size should include the terminating null character. On
///                             return, the value does not include the null character. This parameter can be null only if the
///                             <i>lpApplicationDataBuf </i>parameter is null.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt>
///    </dl> </td> <td width="60%"> A buffer is to small to hold the requested data. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%"> There are no qualifiers to return. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> The system
///    does not have enough memory to complete the operation. Available with Windows Server 2003. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was enumerated. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The specified
///    component is unknown. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEnumComponentQualifiersW(const(wchar)* szComponent, uint iIndex, const(wchar)* lpQualifierBuf, 
                                 uint* pcchQualifierBuf, const(wchar)* lpApplicationDataBuf, 
                                 uint* pcchApplicationDataBuf);

///The <b>MsiOpenProduct</b> function opens a product for use with the functions that access the product database. The
///MsiCloseHandle function must be called with the handle when the handle is no longer needed. <div
///class="alert"><b>Note</b> Initialize COM on the same thread before calling the MsiOpenPackage, MsiOpenPackageEx, or
///<b>MsiOpenProduct</b> function. </div><div> </div>
///Params:
///    szProduct = Specifies the product code of the product to be opened.
///    hProduct = Pointer to a variable that receives the product handle.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration information is corrupt.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The
///    product could not be opened. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SOURCE_ABSENT</b></dt>
///    </dl> </td> <td width="60%"> The source was unavailable. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt>
///    </dl> </td> <td width="60%"> The product code was unrecognized. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiOpenProductA(const(char)* szProduct, uint* hProduct);

///The <b>MsiOpenProduct</b> function opens a product for use with the functions that access the product database. The
///MsiCloseHandle function must be called with the handle when the handle is no longer needed. <div
///class="alert"><b>Note</b> Initialize COM on the same thread before calling the MsiOpenPackage, MsiOpenPackageEx, or
///<b>MsiOpenProduct</b> function. </div><div> </div>
///Params:
///    szProduct = Specifies the product code of the product to be opened.
///    hProduct = Pointer to a variable that receives the product handle.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration information is corrupt.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The
///    product could not be opened. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SOURCE_ABSENT</b></dt>
///    </dl> </td> <td width="60%"> The source was unavailable. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt>
///    </dl> </td> <td width="60%"> The product code was unrecognized. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiOpenProductW(const(wchar)* szProduct, uint* hProduct);

///The <b>MsiOpenPackage</b> function opens a package to use with the functions that access the product database. The
///MsiCloseHandle function must be called with the handle when the handle is not needed. <div class="alert"><b>Note</b>
///Initialize COM on the same thread before calling the <b>MsiOpenPackage</b>, MsiOpenPackageEx, or MsiOpenProduct
///function.</div> <div> </div>
///Params:
///    szPackagePath = The path to the package.
///    hProduct = A pointer to a variable that receives the product handle.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration information is corrupt.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The
///    product could not be opened. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_REMOTE_PROHIBITED</b></dt> </dl> </td> <td width="60%"> Windows Installer does not permit
///    installation from a remote desktop connection. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completes successfully. </td> </tr> </table> If this function fails, it may return a system error code.
///    For more information, see System Error Codes.
///    
@DllImport("msi")
uint MsiOpenPackageA(const(char)* szPackagePath, uint* hProduct);

///The <b>MsiOpenPackage</b> function opens a package to use with the functions that access the product database. The
///MsiCloseHandle function must be called with the handle when the handle is not needed. <div class="alert"><b>Note</b>
///Initialize COM on the same thread before calling the <b>MsiOpenPackage</b>, MsiOpenPackageEx, or MsiOpenProduct
///function.</div> <div> </div>
///Params:
///    szPackagePath = The path to the package.
///    hProduct = A pointer to a variable that receives the product handle.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration information is corrupt.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The
///    product could not be opened. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_REMOTE_PROHIBITED</b></dt> </dl> </td> <td width="60%"> Windows Installer does not permit
///    installation from a remote desktop connection. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completes successfully. </td> </tr> </table> If this function fails, it may return a system error code.
///    For more information, see System Error Codes.
///    
@DllImport("msi")
uint MsiOpenPackageW(const(wchar)* szPackagePath, uint* hProduct);

///The <b>MsiOpenPackageEx</b> function opens a package to use with functions that access the product database. The
///MsiCloseHandle function must be called with the handle when the handle is no longer needed.<div
///class="alert"><b>Note</b> Initialize COM on the same thread before calling the MsiOpenPackage,
///<b>MsiOpenPackageEx</b>, or MsiOpenProduct function.</div> <div> </div>
///Params:
///    szPackagePath = The path to the package.
///    dwOptions = The bit flags to indicate whether or not to ignore the computer state. Pass in 0 (zero) to use MsiOpenPackage
///                behavior. <table> <tr> <th>Constant</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIOPENPACKAGEFLAGS_IGNOREMACHINESTATE"></a><a id="msiopenpackageflags_ignoremachinestate"></a><dl>
///                <dt><b>MSIOPENPACKAGEFLAGS_IGNOREMACHINESTATE</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Ignore the
///                computer state when creating the product handle. </td> </tr> </table>
///    hProduct = A pointer to a variable that receives the product handle.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration information is corrupt.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The
///    product could not be opened. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_REMOTE_PROHIBITED</b></dt> </dl> </td> <td width="60%"> Windows Installer does not permit
///    installation from a remote desktop connection. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completes successfully. </td> </tr> </table> If this function fails, it may return a system error code.
///    For more information, see System Error Codes.
///    
@DllImport("msi")
uint MsiOpenPackageExA(const(char)* szPackagePath, uint dwOptions, uint* hProduct);

///The <b>MsiOpenPackageEx</b> function opens a package to use with functions that access the product database. The
///MsiCloseHandle function must be called with the handle when the handle is no longer needed.<div
///class="alert"><b>Note</b> Initialize COM on the same thread before calling the MsiOpenPackage,
///<b>MsiOpenPackageEx</b>, or MsiOpenProduct function.</div> <div> </div>
///Params:
///    szPackagePath = The path to the package.
///    dwOptions = The bit flags to indicate whether or not to ignore the computer state. Pass in 0 (zero) to use MsiOpenPackage
///                behavior. <table> <tr> <th>Constant</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIOPENPACKAGEFLAGS_IGNOREMACHINESTATE"></a><a id="msiopenpackageflags_ignoremachinestate"></a><dl>
///                <dt><b>MSIOPENPACKAGEFLAGS_IGNOREMACHINESTATE</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Ignore the
///                computer state when creating the product handle. </td> </tr> </table>
///    hProduct = A pointer to a variable that receives the product handle.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration information is corrupt.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The
///    product could not be opened. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_REMOTE_PROHIBITED</b></dt> </dl> </td> <td width="60%"> Windows Installer does not permit
///    installation from a remote desktop connection. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completes successfully. </td> </tr> </table> If this function fails, it may return a system error code.
///    For more information, see System Error Codes.
///    
@DllImport("msi")
uint MsiOpenPackageExW(const(wchar)* szPackagePath, uint dwOptions, uint* hProduct);

///The <b>MsiGetPatchFileList</b> function is provided a list of .msp files, delimited by semicolons, and retrieves the
///list of files that can be updated by the patches.
///Params:
///    szProductCode = A null-terminated string value containing the ProductCode (GUID) of the product which is the target of the
///                    patches. This parameter cannot be <b>NULL</b>.
///    szPatchPackages = A null-terminated string value that contains the list of Windows Installer patches (.msp files). Each patch can
///                      be specified by the full path to the patch package. The patches in the list are delimited by semicolons. At least
///                      one patch must be specified.
///    pcFiles = A pointer to a location that receives the number of files that will be updated on this system by this list of
///              patches specified by <i>szPatchList</i>. This parameter is required.
///    pphFileRecords = A pointer to a location that receives a pointer to an array of records. The first field (0-index) of each record
///                     contains the full file path of a file that can be updated when the list of patches in <i>szPatchList</i> are
///                     applied on this computer. This parameter is required.
///Returns:
///    The <b>MsiGetPatchFileList</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt>
///    </dl> </td> <td width="60%"> An invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> The function failed. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiGetPatchFileListA(const(char)* szProductCode, const(char)* szPatchPackages, uint* pcFiles, 
                          uint** pphFileRecords);

///The <b>MsiGetPatchFileList</b> function is provided a list of .msp files, delimited by semicolons, and retrieves the
///list of files that can be updated by the patches.
///Params:
///    szProductCode = A null-terminated string value containing the ProductCode (GUID) of the product which is the target of the
///                    patches. This parameter cannot be <b>NULL</b>.
///    szPatchPackages = A null-terminated string value that contains the list of Windows Installer patches (.msp files). Each patch can
///                      be specified by the full path to the patch package. The patches in the list are delimited by semicolons. At least
///                      one patch must be specified.
///    pcFiles = A pointer to a location that receives the number of files that will be updated on this system by this list of
///              patches specified by <i>szPatchList</i>. This parameter is required.
///    pphFileRecords = A pointer to a location that receives a pointer to an array of records. The first field (0-index) of each record
///                     contains the full file path of a file that can be updated when the list of patches in <i>szPatchList</i> are
///                     applied on this computer. This parameter is required.
///Returns:
///    The <b>MsiGetPatchFileList</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function completed successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt>
///    </dl> </td> <td width="60%"> An invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> The function failed. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiGetPatchFileListW(const(wchar)* szProductCode, const(wchar)* szPatchPackages, uint* pcFiles, 
                          uint** pphFileRecords);

///The <b>MsiGetProductProperty</b> function retrieves product properties. These properties are in the product database.
///Params:
///    hProduct = Handle to the product obtained from MsiOpenProduct.
///    szProperty = Specifies the property to retrieve. This is case-sensitive.
///    lpValueBuf = Pointer to a buffer that receives the property value. The value is truncated and null-terminated if
///                 <i>lpValueBuf</i> is too small. This parameter can be null.
///    pcchValueBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpValueBuf</i>
///                   parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                   the buffer passed in is too small, the count returned does not include the terminating null character. If
///                   <i>lpValueBuf</i> is null, <i>pcchValueBuf</i> can be null.
///Returns:
///    The <b>MsiGetProductProperty</b> function return the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> An invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> An invalid handle was passed to the function.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> A buffer is
///    too small to hold the entire property value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt>
///    </dl> </td> <td width="60%"> The function completed successfully. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiGetProductPropertyA(uint hProduct, const(char)* szProperty, const(char)* lpValueBuf, uint* pcchValueBuf);

///The <b>MsiGetProductProperty</b> function retrieves product properties. These properties are in the product database.
///Params:
///    hProduct = Handle to the product obtained from MsiOpenProduct.
///    szProperty = Specifies the property to retrieve. This is case-sensitive.
///    lpValueBuf = Pointer to a buffer that receives the property value. The value is truncated and null-terminated if
///                 <i>lpValueBuf</i> is too small. This parameter can be null.
///    pcchValueBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpValueBuf</i>
///                   parameter. On input, this is the full size of the buffer, including a space for a terminating null character. If
///                   the buffer passed in is too small, the count returned does not include the terminating null character. If
///                   <i>lpValueBuf</i> is null, <i>pcchValueBuf</i> can be null.
///Returns:
///    The <b>MsiGetProductProperty</b> function return the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> An invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> An invalid handle was passed to the function.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> A buffer is
///    too small to hold the entire property value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt>
///    </dl> </td> <td width="60%"> The function completed successfully. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiGetProductPropertyW(uint hProduct, const(wchar)* szProperty, const(wchar)* lpValueBuf, uint* pcchValueBuf);

///The <b>MsiVerifyPackage</b> function verifies that the given file is an installation package.
///Params:
///    szPackagePath = Specifies the path and file name of the package.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_PACKAGE_INVALID</b></dt> </dl> </td> <td width="60%"> The file is not a valid package. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_PACKAGE_OPEN_FAILED</b></dt> </dl> </td> <td width="60%">
///    The file could not be opened. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt>
///    </dl> </td> <td width="60%"> The parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The file is a package. </td> </tr> </table> <div>
///    </div>
///    
@DllImport("msi")
uint MsiVerifyPackageA(const(char)* szPackagePath);

///The <b>MsiVerifyPackage</b> function verifies that the given file is an installation package.
///Params:
///    szPackagePath = Specifies the path and file name of the package.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_PACKAGE_INVALID</b></dt> </dl> </td> <td width="60%"> The file is not a valid package. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_PACKAGE_OPEN_FAILED</b></dt> </dl> </td> <td width="60%">
///    The file could not be opened. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt>
///    </dl> </td> <td width="60%"> The parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The file is a package. </td> </tr> </table> <div>
///    </div>
///    
@DllImport("msi")
uint MsiVerifyPackageW(const(wchar)* szPackagePath);

///The <b>MsiGetFeatureInfo</b> function returns descriptive information for a feature.
///Params:
///    hProduct = Handle to the product that owns the feature. This handle is obtained from MsiOpenProduct.
///    szFeature = Feature code for the feature about which information should be returned.
///    lpAttributes = Pointer to a location containing one or more of the following Attribute flags.
///    lpTitleBuf = Pointer to a buffer to receive the localized name of the feature, which corresponds to the Title field in the
///                 Feature Table. This parameter is optional and can be null.
///    pcchTitleBuf = As input, the size of <i>lpTitleBuf</i>. As output, the number of characters returned in <i>lpTitleBuf</i>. On
///                   input, this is the full size of the buffer, and includes a space for a terminating null character. If the buffer
///                   that is passed in is too small, the count returned does not include the terminating null character.
///    lpHelpBuf = Pointer to a buffer to receive the localized description of the feature, which corresponds to the Description
///                field for the feature in the Feature table. This parameter is optional and can be null.
///    pcchHelpBuf = As input, the size of <i>lpHelpBuf</i>. As output, the number of characters returned in <i>lpHelpBuf</i>. On
///                  input, this is the full size of the buffer, and includes a space for a terminating null character. If the buffer
///                  passed in is too small, the count returned does not include the terminating null character.
///Returns:
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> The product handle is invalid. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One of the parameters
///    is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> A
///    buffer is too small to hold the requested data. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function returns successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_FEATURE</b></dt> </dl> </td> <td width="60%"> The feature is not
///    known. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiGetFeatureInfoA(uint hProduct, const(char)* szFeature, uint* lpAttributes, const(char)* lpTitleBuf, 
                        uint* pcchTitleBuf, const(char)* lpHelpBuf, uint* pcchHelpBuf);

///The <b>MsiGetFeatureInfo</b> function returns descriptive information for a feature.
///Params:
///    hProduct = Handle to the product that owns the feature. This handle is obtained from MsiOpenProduct.
///    szFeature = Feature code for the feature about which information should be returned.
///    lpAttributes = Pointer to a location containing one or more of the following Attribute flags.
///    lpTitleBuf = Pointer to a buffer to receive the localized name of the feature, which corresponds to the Title field in the
///                 Feature Table. This parameter is optional and can be null.
///    pcchTitleBuf = As input, the size of <i>lpTitleBuf</i>. As output, the number of characters returned in <i>lpTitleBuf</i>. On
///                   input, this is the full size of the buffer, and includes a space for a terminating null character. If the buffer
///                   that is passed in is too small, the count returned does not include the terminating null character.
///    lpHelpBuf = Pointer to a buffer to receive the localized description of the feature, which corresponds to the Description
///                field for the feature in the Feature table. This parameter is optional and can be null.
///    pcchHelpBuf = As input, the size of <i>lpHelpBuf</i>. As output, the number of characters returned in <i>lpHelpBuf</i>. On
///                  input, this is the full size of the buffer, and includes a space for a terminating null character. If the buffer
///                  passed in is too small, the count returned does not include the terminating null character.
///Returns:
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> The product handle is invalid. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One of the parameters
///    is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> A
///    buffer is too small to hold the requested data. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function returns successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_FEATURE</b></dt> </dl> </td> <td width="60%"> The feature is not
///    known. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiGetFeatureInfoW(uint hProduct, const(wchar)* szFeature, uint* lpAttributes, const(wchar)* lpTitleBuf, 
                        uint* pcchTitleBuf, const(wchar)* lpHelpBuf, uint* pcchHelpBuf);

///The <b>MsiInstallMissingComponent</b> function installs files that are unexpectedly missing.
///Params:
///    szProduct = Specifies the product code for the product that owns the component to be installed.
///    szComponent = Identifies the component to be installed.
///    eInstallState = Specifies the way the component should be installed. This parameter must be one of the following values. <table>
///                    <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a
///                    id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The component
///                    should be locally installed. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a
///                    id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The component
///                    should be installed to run from the source. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_DEFAULT"></a><a
///                    id="installstate_default"></a><dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl> </td> <td width="60%"> The
///                    component should be installed according to the installer defaults. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration information is corrupt.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The
///    installation failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SOURCE_ABSENT</b></dt> </dl>
///    </td> <td width="60%"> The source was unavailable. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_SUSPEND</b></dt> </dl> </td> <td width="60%"> The installation was suspended. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_USEREXIT</b></dt> </dl> </td> <td width="60%"> The user exited
///    the installation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> One of the parameters is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product code is
///    unrecognized. </td> </tr> </table> For more information about error messages, see Displayed Error Messages
///    
@DllImport("msi")
uint MsiInstallMissingComponentA(const(char)* szProduct, const(char)* szComponent, INSTALLSTATE eInstallState);

///The <b>MsiInstallMissingComponent</b> function installs files that are unexpectedly missing.
///Params:
///    szProduct = Specifies the product code for the product that owns the component to be installed.
///    szComponent = Identifies the component to be installed.
///    eInstallState = Specifies the way the component should be installed. This parameter must be one of the following values. <table>
///                    <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a
///                    id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The component
///                    should be locally installed. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a
///                    id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The component
///                    should be installed to run from the source. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_DEFAULT"></a><a
///                    id="installstate_default"></a><dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl> </td> <td width="60%"> The
///                    component should be installed according to the installer defaults. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration information is corrupt.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The
///    installation failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SOURCE_ABSENT</b></dt> </dl>
///    </td> <td width="60%"> The source was unavailable. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_SUSPEND</b></dt> </dl> </td> <td width="60%"> The installation was suspended. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_USEREXIT</b></dt> </dl> </td> <td width="60%"> The user exited
///    the installation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> One of the parameters is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function completed successfully. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product code is
///    unrecognized. </td> </tr> </table> For more information about error messages, see Displayed Error Messages
///    
@DllImport("msi")
uint MsiInstallMissingComponentW(const(wchar)* szProduct, const(wchar)* szComponent, INSTALLSTATE eInstallState);

///The <b>MsiInstallMissingFile</b> function installs files that are unexpectedly missing.
///Params:
///    szProduct = Specifies the product code for the product that owns the file to be installed.
///    szFile = Specifies the file to be installed.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration information is corrupt.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The
///    installation failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SOURCE_ABSENT</b></dt> </dl>
///    </td> <td width="60%"> The source was unavailable. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_SUSPEND</b></dt> </dl> </td> <td width="60%"> The installation was suspended. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_USEREXIT</b></dt> </dl> </td> <td width="60%"> The user exited
///    the installation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> A parameter was invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product code is unrecognized. </td> </tr>
///    </table> For more information about error messages, see Displayed Error Messages.
///    
@DllImport("msi")
uint MsiInstallMissingFileA(const(char)* szProduct, const(char)* szFile);

///The <b>MsiInstallMissingFile</b> function installs files that are unexpectedly missing.
///Params:
///    szProduct = Specifies the product code for the product that owns the file to be installed.
///    szFile = Specifies the file to be installed.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration information is corrupt.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> The
///    installation failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SOURCE_ABSENT</b></dt> </dl>
///    </td> <td width="60%"> The source was unavailable. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_SUSPEND</b></dt> </dl> </td> <td width="60%"> The installation was suspended. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_USEREXIT</b></dt> </dl> </td> <td width="60%"> The user exited
///    the installation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> A parameter was invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product code is unrecognized. </td> </tr>
///    </table> For more information about error messages, see Displayed Error Messages.
///    
@DllImport("msi")
uint MsiInstallMissingFileW(const(wchar)* szProduct, const(wchar)* szFile);

///The <b>MsiLocateComponent</b> function returns the full path to an installed component without a product code. This
///function attempts to determine the product using MsiGetProductCode, but is not guaranteed to find the correct product
///for the caller. MsiGetComponentPath should always be called when possible.
///Params:
///    szComponent = Specifies the component ID of the component to be located.
///    lpPathBuf = Pointer to a variable that receives the path to the component. The variable includes the terminating null
///                character.
///    pcchBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpPathBuf</i>
///              parameter. On input, this is the full size of the buffer, including a space for a terminating null character.
///              Upon success of the <b>MsiLocateComponent</b> function, the variable pointed to by <i>pcchBuf</i> contains the
///              count of characters not including the terminating null character. If the size of the buffer passed in is too
///              small, the function returns INSTALLSTATE_MOREDATA. If <i>lpPathBuf</i> is null, <i>pcchBuf</i> can be null.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_NOTUSED</b></dt> </dl> </td> <td width="60%"> The component being requested is disabled on
///    the computer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td
///    width="60%"> The component is not installed. See Remarks. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the function parameters is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The
///    component is installed locally. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_MOREDATA</b></dt>
///    </dl> </td> <td width="60%"> The buffer provided was too small. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The component is installed to run from source.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_SOURCEABSENT</b></dt> </dl> </td> <td width="60%"> The
///    component source is inaccessible. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt>
///    </dl> </td> <td width="60%"> The product code or component ID is unknown. See Remarks. </td> </tr> </table>
///    
@DllImport("msi")
INSTALLSTATE MsiLocateComponentA(const(char)* szComponent, const(char)* lpPathBuf, uint* pcchBuf);

///The <b>MsiLocateComponent</b> function returns the full path to an installed component without a product code. This
///function attempts to determine the product using MsiGetProductCode, but is not guaranteed to find the correct product
///for the caller. MsiGetComponentPath should always be called when possible.
///Params:
///    szComponent = Specifies the component ID of the component to be located.
///    lpPathBuf = Pointer to a variable that receives the path to the component. The variable includes the terminating null
///                character.
///    pcchBuf = Pointer to a variable that specifies the size, in characters, of the buffer pointed to by the <i>lpPathBuf</i>
///              parameter. On input, this is the full size of the buffer, including a space for a terminating null character.
///              Upon success of the <b>MsiLocateComponent</b> function, the variable pointed to by <i>pcchBuf</i> contains the
///              count of characters not including the terminating null character. If the size of the buffer passed in is too
///              small, the function returns INSTALLSTATE_MOREDATA. If <i>lpPathBuf</i> is null, <i>pcchBuf</i> can be null.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_NOTUSED</b></dt> </dl> </td> <td width="60%"> The component being requested is disabled on
///    the computer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td
///    width="60%"> The component is not installed. See Remarks. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the function parameters is invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The
///    component is installed locally. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_MOREDATA</b></dt>
///    </dl> </td> <td width="60%"> The buffer provided was too small. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The component is installed to run from source.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_SOURCEABSENT</b></dt> </dl> </td> <td width="60%"> The
///    component source is inaccessible. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt>
///    </dl> </td> <td width="60%"> The product code or component ID is unknown. See Remarks. </td> </tr> </table>
///    
@DllImport("msi")
INSTALLSTATE MsiLocateComponentW(const(wchar)* szComponent, const(wchar)* lpPathBuf, uint* pcchBuf);

///The <b>MsiSourceListClearAll</b> function removes all network sources from the source list of a patch or product in a
///specified context. For more information, see Source Resiliency.
///Params:
///    szProduct = The ProductCode of the product to modify.
///    szUserName = The user name for a per-user installation. The user name should always be in the format of DOMAIN\USERNAME (or
///                 MACHINENAME\USERNAME for a local user). An empty string or <b>NULL</b> for a per-machine installation.
///    dwReserved = Reserved for future use. This value must be set to 0.
///Returns:
///    The <b>MsiSourceListClearAll</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to clear the source list for this product. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is
///    corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_USERNAME</b></dt> </dl> </td> <td width="60%">
///    Could not resolve the user name. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt>
///    </dl> </td> <td width="60%"> The function did not succeed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td width="60%"> Could not access installer service.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An
///    invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The specified product is
///    unknown. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListClearAllA(const(char)* szProduct, const(char)* szUserName, uint dwReserved);

///The <b>MsiSourceListClearAll</b> function removes all network sources from the source list of a patch or product in a
///specified context. For more information, see Source Resiliency.
///Params:
///    szProduct = The ProductCode of the product to modify.
///    szUserName = The user name for a per-user installation. The user name should always be in the format of DOMAIN\USERNAME (or
///                 MACHINENAME\USERNAME for a local user). An empty string or <b>NULL</b> for a per-machine installation.
///    dwReserved = Reserved for future use. This value must be set to 0.
///Returns:
///    The <b>MsiSourceListClearAll</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to clear the source list for this product. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is
///    corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_USERNAME</b></dt> </dl> </td> <td width="60%">
///    Could not resolve the user name. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt>
///    </dl> </td> <td width="60%"> The function did not succeed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td width="60%"> Could not access installer service.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An
///    invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The specified product is
///    unknown. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListClearAllW(const(wchar)* szProduct, const(wchar)* szUserName, uint dwReserved);

///The <b>MsiSourceListAddSource</b> function adds to the list of valid network sources that contain the specified type
///of sources for a product or patch in a specified user context. The number of sources in the SOURCELIST property is
///unlimited.
///Params:
///    szProduct = The ProductCode of the product to modify.
///    szUserName = The user name for a per-user installation. On Windows 2000 or Windows XP, the user name should always be in the
///                 format of DOMAIN\USERNAME (or MACHINENAME\USERNAME for a local user). An empty string or <b>NULL</b> for a
///                 per-machine installation.
///    dwReserved = Reserved for future use. This value must be set to 0.
///    szSource = Pointer to the string specifying the source.
///Returns:
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The user does not have the ability to add a
///    source. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td
///    width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_USERNAME</b></dt> </dl> </td> <td width="60%"> Could not resolve the user name. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> The function did not
///    succeed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td
///    width="60%"> Could not access installer service. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    source was added. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td
///    width="60%"> The specified product is unknown. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListAddSourceA(const(char)* szProduct, const(char)* szUserName, uint dwReserved, 
                             const(char)* szSource);

///The <b>MsiSourceListAddSource</b> function adds to the list of valid network sources that contain the specified type
///of sources for a product or patch in a specified user context. The number of sources in the SOURCELIST property is
///unlimited.
///Params:
///    szProduct = The ProductCode of the product to modify.
///    szUserName = The user name for a per-user installation. On Windows 2000 or Windows XP, the user name should always be in the
///                 format of DOMAIN\USERNAME (or MACHINENAME\USERNAME for a local user). An empty string or <b>NULL</b> for a
///                 per-machine installation.
///    dwReserved = Reserved for future use. This value must be set to 0.
///    szSource = Pointer to the string specifying the source.
///Returns:
///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The user does not have the ability to add a
///    source. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td
///    width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_USERNAME</b></dt> </dl> </td> <td width="60%"> Could not resolve the user name. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> The function did not
///    succeed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td
///    width="60%"> Could not access installer service. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    source was added. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td
///    width="60%"> The specified product is unknown. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListAddSourceW(const(wchar)* szProduct, const(wchar)* szUserName, uint dwReserved, 
                             const(wchar)* szSource);

///The <b>MsiSourceListForceResolution</b> function forces the installer to search the source list for a valid product
///source the next time a source is required. For example, when the installer performs an installation or
///reinstallation, or when it requires the path for a component that is set to run from source.
///Params:
///    szProduct = The ProductCode of the product to modify.
///    szUserName = The user name for a per-user installation. The user name should always be in the format of DOMAIN\USERNAME (or
///                 MACHINENAME\USERNAME for a local user). An empty string or <b>NULL</b> for a per-machine installation.
///    dwReserved = Reserved for future use. This value must be set to 0.
///Returns:
///    The <b>MsiSourceListForceResolution</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The caller does not have sufficient access to force resolution for the product. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is
///    corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_USER_NAME</b></dt> </dl> </td> <td width="60%">
///    The specified user is not a valid user. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> The function could not complete. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td width="60%"> The
///    installation service could not be accessed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td
///    width="60%"> The specified product is unknown. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListForceResolutionA(const(char)* szProduct, const(char)* szUserName, uint dwReserved);

///The <b>MsiSourceListForceResolution</b> function forces the installer to search the source list for a valid product
///source the next time a source is required. For example, when the installer performs an installation or
///reinstallation, or when it requires the path for a component that is set to run from source.
///Params:
///    szProduct = The ProductCode of the product to modify.
///    szUserName = The user name for a per-user installation. The user name should always be in the format of DOMAIN\USERNAME (or
///                 MACHINENAME\USERNAME for a local user). An empty string or <b>NULL</b> for a per-machine installation.
///    dwReserved = Reserved for future use. This value must be set to 0.
///Returns:
///    The <b>MsiSourceListForceResolution</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The caller does not have sufficient access to force resolution for the product. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is
///    corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_USER_NAME</b></dt> </dl> </td> <td width="60%">
///    The specified user is not a valid user. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> The function could not complete. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td width="60%"> The
///    installation service could not be accessed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    function succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td
///    width="60%"> The specified product is unknown. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListForceResolutionW(const(wchar)* szProduct, const(wchar)* szUserName, uint dwReserved);

///The <b>MsiSourceListAddSourceEx</b> function adds or reorders the set of sources of a patch or product in a specified
///context. It can also create a source list for a patch that does not exist in the specified context.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns <b>ERROR_INVALID_PARAMETER</b>. This parameter cannot be
///                               <b>NULL</b>.
///    szUserSid = This parameter can be a string SID that specifies the user account that contains the product or patch. The SID is
///                not validated or resolved. An incorrect SID can return <b>ERROR_UNKNOWN_PRODUCT</b> or
///                <b>ERROR_UNKNOWN_PATCH</b>. When referencing a machine context, <i>szUserSID</i> must be <b>NULL</b> and
///                <i>dwContext</i> must be <b>MSIINSTALLCONTEXT_MACHINE</b>. <table> <tr> <th>Type of SID</th> <th>Meaning</th>
///                </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td
///                width="60%"> <b>NULL</b> denotes the currently logged on user. When referencing the current user account,
///                <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be <b>MSIINSTALLCONTEXT_USERMANAGED</b> or
///                <b>MSIINSTALLCONTEXT_USERUNMANAGED</b>. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a
///                id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> Specifies
///                enumeration for a particular user in the system. An example of a user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div class="alert"><b>Note</b> The special
///                SID string s-1-5-18 (system) cannot be used to enumerate products or patches installed as per-machine. Setting
///                the SID value to "S-1-5-18" returns <b>ERROR_INVALID_PARAMETER</b>.</div> <div> </div> <div
///                class="alert"><b>Note</b> The special SID string s-1-1-0 (everyone) should not be used. Setting the SID value to
///                "S-1-1-0" fails and returns <b>ERROR_INVALID_PARAM</b>.</div> <div> </div>
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value determines the interpretation of the <i>szProductCodeOrPatchCode</i> value and the
///                type of sources to clear. This parameter must be a combination of one of the following <b>MSISOURCETYPE_*</b>
///                constants and one of the following <b>MSICODE_*</b> constants. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr>
///                <tr> <td width="40%"><a id="MSISOURCETYPE_NETWORK"></a><a id="msisourcetype_network"></a><dl>
///                <dt><b>MSISOURCETYPE_NETWORK</b></dt> </dl> </td> <td width="60%"> The source is a network type. </td> </tr> <tr>
///                <td width="40%"><a id="MSISOURCETYPE_URL"></a><a id="msisourcetype_url"></a><dl>
///                <dt><b>MSISOURCETYPE_URL</b></dt> </dl> </td> <td width="60%"> The source is a URL type. </td> </tr> <tr> <td
///                width="40%"><a id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl> <dt><b>MSICODE_PRODUCT</b></dt> </dl>
///                </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a product code. </td> </tr> <tr> <td width="40%"><a
///                id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl> <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%">
///                <i>szProductCodeOrPatchCode</i> is a patch code. </td> </tr> </table>
///    szSource = Source to add or move. This parameter is expected to contain only the path without the filename. The filename is
///               already registered as "PackageName" and can be manipulated through MsiSourceListSetInfo. This argument is
///               required.
///    dwIndex = This parameter provides the new index for the source. All sources are indexed in the source list from 1 to
///              <i>N</i>, where <i>N</i> is the count of sources in the list. Every source in the list has a unique index. If
///              <b>MsiSourceListAddSourceEx</b> is called with a new source and <i>dwIndex</i> set to 0 (zero), the new source is
///              appended to the existing list. If <i>dwIndex</i> is set to 0 and the source already exists in the list, no update
///              is done on the list. If <b>MsiSourceListAddSourceEx</b> is called with a new source and <i>dwIndex</i> set to a
///              non-zero value less than count (<i>N</i>), the new source is placed at the specified index and the other sources
///              are re-indexed. If the source already exists, it is moved to the specified index and the other sources are
///              re-indexed. If <b>MsiSourceListAddSourceEx</b> is called with a new source and <i>dwIndex</i> set to a non-zero
///              value greater than the count of sources (<i>N</i>), the new source is appended to the existing list. If the
///              source already exists, it is moved to the end of the list and the other sources are re-indexed.
///Returns:
///    The <b>MsiSourceListAddSourceEx</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to add or move a source. Does not indicate whether the product or
///    patch was found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td
///    width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td width="60%"> Could not access the Windows Installer
///    service. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    source was inserted or updated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt>
///    </dl> </td> <td width="60%"> The specified product is unknown. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The specified patch is unknown. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> Unexpected internal
///    failure. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListAddSourceExA(const(char)* szProductCodeOrPatchCode, const(char)* szUserSid, 
                               MSIINSTALLCONTEXT dwContext, uint dwOptions, const(char)* szSource, uint dwIndex);

///The <b>MsiSourceListAddSourceEx</b> function adds or reorders the set of sources of a patch or product in a specified
///context. It can also create a source list for a patch that does not exist in the specified context.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns <b>ERROR_INVALID_PARAMETER</b>. This parameter cannot be
///                               <b>NULL</b>.
///    szUserSid = This parameter can be a string SID that specifies the user account that contains the product or patch. The SID is
///                not validated or resolved. An incorrect SID can return <b>ERROR_UNKNOWN_PRODUCT</b> or
///                <b>ERROR_UNKNOWN_PATCH</b>. When referencing a machine context, <i>szUserSID</i> must be <b>NULL</b> and
///                <i>dwContext</i> must be <b>MSIINSTALLCONTEXT_MACHINE</b>. <table> <tr> <th>Type of SID</th> <th>Meaning</th>
///                </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td
///                width="60%"> <b>NULL</b> denotes the currently logged on user. When referencing the current user account,
///                <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be <b>MSIINSTALLCONTEXT_USERMANAGED</b> or
///                <b>MSIINSTALLCONTEXT_USERUNMANAGED</b>. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a
///                id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> Specifies
///                enumeration for a particular user in the system. An example of a user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div class="alert"><b>Note</b> The special
///                SID string s-1-5-18 (system) cannot be used to enumerate products or patches installed as per-machine. Setting
///                the SID value to "S-1-5-18" returns <b>ERROR_INVALID_PARAMETER</b>.</div> <div> </div> <div
///                class="alert"><b>Note</b> The special SID string s-1-1-0 (everyone) should not be used. Setting the SID value to
///                "S-1-1-0" fails and returns <b>ERROR_INVALID_PARAM</b>.</div> <div> </div>
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value determines the interpretation of the <i>szProductCodeOrPatchCode</i> value and the
///                type of sources to clear. This parameter must be a combination of one of the following <b>MSISOURCETYPE_*</b>
///                constants and one of the following <b>MSICODE_*</b> constants. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr>
///                <tr> <td width="40%"><a id="MSISOURCETYPE_NETWORK"></a><a id="msisourcetype_network"></a><dl>
///                <dt><b>MSISOURCETYPE_NETWORK</b></dt> </dl> </td> <td width="60%"> The source is a network type. </td> </tr> <tr>
///                <td width="40%"><a id="MSISOURCETYPE_URL"></a><a id="msisourcetype_url"></a><dl>
///                <dt><b>MSISOURCETYPE_URL</b></dt> </dl> </td> <td width="60%"> The source is a URL type. </td> </tr> <tr> <td
///                width="40%"><a id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl> <dt><b>MSICODE_PRODUCT</b></dt> </dl>
///                </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a product code. </td> </tr> <tr> <td width="40%"><a
///                id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl> <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%">
///                <i>szProductCodeOrPatchCode</i> is a patch code. </td> </tr> </table>
///    szSource = Source to add or move. This parameter is expected to contain only the path without the filename. The filename is
///               already registered as "PackageName" and can be manipulated through MsiSourceListSetInfo. This argument is
///               required.
///    dwIndex = This parameter provides the new index for the source. All sources are indexed in the source list from 1 to
///              <i>N</i>, where <i>N</i> is the count of sources in the list. Every source in the list has a unique index. If
///              <b>MsiSourceListAddSourceEx</b> is called with a new source and <i>dwIndex</i> set to 0 (zero), the new source is
///              appended to the existing list. If <i>dwIndex</i> is set to 0 and the source already exists in the list, no update
///              is done on the list. If <b>MsiSourceListAddSourceEx</b> is called with a new source and <i>dwIndex</i> set to a
///              non-zero value less than count (<i>N</i>), the new source is placed at the specified index and the other sources
///              are re-indexed. If the source already exists, it is moved to the specified index and the other sources are
///              re-indexed. If <b>MsiSourceListAddSourceEx</b> is called with a new source and <i>dwIndex</i> set to a non-zero
///              value greater than the count of sources (<i>N</i>), the new source is appended to the existing list. If the
///              source already exists, it is moved to the end of the list and the other sources are re-indexed.
///Returns:
///    The <b>MsiSourceListAddSourceEx</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to add or move a source. Does not indicate whether the product or
///    patch was found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td
///    width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td width="60%"> Could not access the Windows Installer
///    service. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    source was inserted or updated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt>
///    </dl> </td> <td width="60%"> The specified product is unknown. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The specified patch is unknown. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> Unexpected internal
///    failure. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListAddSourceExW(const(wchar)* szProductCodeOrPatchCode, const(wchar)* szUserSid, 
                               MSIINSTALLCONTEXT dwContext, uint dwOptions, const(wchar)* szSource, uint dwIndex);

///The <b>MsiSourceListAddMediaDisk</b> function adds or updates a disk of the media source of a registered product or
///patch. If the disk specified already exists, it is updated with the new values. If the disk specified does not exist,
///a new disk entry is created with the new values.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns ERROR_INVALID_PARAMETER. This parameter cannot be <b>NULL</b>.
///    szUserSid = This parameter can be a string SID that specifies the user account that contains the product or patch. The SID is
///                not validated or resolved. An incorrect SID can return ERROR_UNKNOWN_PRODUCT or ERROR_UNKNOWN_PATCH. <table> <tr>
///                <th>Type of SID</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl>
///                <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> <b>NULL</b> denotes the currently logged on user. When
///                referencing the current user account, <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be
///                MSIINSTALLCONTEXT_USERMANAGED or MSIINSTALLCONTEXT_USERUNMANAGED. </td> </tr> <tr> <td width="40%"><a
///                id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td
///                width="60%"> Specifies enumeration for a particular user in the system. An example of user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div class="alert"><b>Note</b> The special
///                SID string s-1-5-18 (system) cannot be used to enumerate products or patches installed as per-machine. Setting
///                the SID value to s-1-5-18 returns ERROR_INVALID_PARAMETER. When <i>dwContext</i> is set to
///                MSIINSTALLCONTEXT_MACHINE only, <i>szUserSid</i> must be <b>NULL</b>. </div> <div> </div> <div
///                class="alert"><b>Note</b> The special SID string s-1-1-0 (everyone) should not be used. Setting the SID value to
///                s-1-1-0 fails and returns ERROR_INVALID_PARAM .</div> <div> </div>
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value specifies the meaning of <i>szProductCodeOrPatchCode</i>. <table> <tr> <th>Flag</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl>
///                <dt><b>MSICODE_PRODUCT</b></dt> </dl> </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a product code
///                GUID. </td> </tr> <tr> <td width="40%"><a id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl>
///                <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a patch code GUID.
///                </td> </tr> </table>
///    dwDiskId = This parameter provides the ID of the disk being added or updated.
///    szVolumeLabel = The <i>szVolumeLabel</i> provides the label of the disk being added or updated. An update overwrites the existing
///                    volume label in the registry. To change the disk prompt only, get the existing volume label from the registry and
///                    provide it in this call along with the new disk prompt. Passing a <b>NULL</b> or empty string for
///                    <i>szVolumeLabel</i> registers an empty string (0 bytes in length) as the volume label.
///    szDiskPrompt = On entry to <b>MsiSourceListAddMediaDisk</b>, <i>szDiskPrompt</i> provides the disk prompt of the disk being
///                   added or updated. An update overwrites the registered disk prompt. To change the volume label only, get the
///                   existing disk prompt that is registered and provide it when calling <b>MsiSourceListAddMediaDisk</b> along with
///                   the new volume label. Passing <b>NULL</b> or an empty string registers an empty string (0 bytes in length) as the
///                   disk prompt.
///Returns:
///    The <b>MsiSourceListAddMediaDisk</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to read the specified media source or the specified product or
///    patch. This does not indicate whether a media source, product or patch was found. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is
///    corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td
///    width="60%"> The Windows Installer service could not be accessed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    value was successfully reordered. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt>
///    </dl> </td> <td width="60%"> The patch was not found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product was not found. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> Unexpected internal
///    failure. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListAddMediaDiskA(const(char)* szProductCodeOrPatchCode, const(char)* szUserSid, 
                                MSIINSTALLCONTEXT dwContext, uint dwOptions, uint dwDiskId, 
                                const(char)* szVolumeLabel, const(char)* szDiskPrompt);

///The <b>MsiSourceListAddMediaDisk</b> function adds or updates a disk of the media source of a registered product or
///patch. If the disk specified already exists, it is updated with the new values. If the disk specified does not exist,
///a new disk entry is created with the new values.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns ERROR_INVALID_PARAMETER. This parameter cannot be <b>NULL</b>.
///    szUserSid = This parameter can be a string SID that specifies the user account that contains the product or patch. The SID is
///                not validated or resolved. An incorrect SID can return ERROR_UNKNOWN_PRODUCT or ERROR_UNKNOWN_PATCH. <table> <tr>
///                <th>Type of SID</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl>
///                <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> <b>NULL</b> denotes the currently logged on user. When
///                referencing the current user account, <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be
///                MSIINSTALLCONTEXT_USERMANAGED or MSIINSTALLCONTEXT_USERUNMANAGED. </td> </tr> <tr> <td width="40%"><a
///                id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td
///                width="60%"> Specifies enumeration for a particular user in the system. An example of user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div class="alert"><b>Note</b> The special
///                SID string s-1-5-18 (system) cannot be used to enumerate products or patches installed as per-machine. Setting
///                the SID value to s-1-5-18 returns ERROR_INVALID_PARAMETER. When <i>dwContext</i> is set to
///                MSIINSTALLCONTEXT_MACHINE only, <i>szUserSid</i> must be <b>NULL</b>. </div> <div> </div> <div
///                class="alert"><b>Note</b> The special SID string s-1-1-0 (everyone) should not be used. Setting the SID value to
///                s-1-1-0 fails and returns ERROR_INVALID_PARAM .</div> <div> </div>
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value specifies the meaning of <i>szProductCodeOrPatchCode</i>. <table> <tr> <th>Flag</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl>
///                <dt><b>MSICODE_PRODUCT</b></dt> </dl> </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a product code
///                GUID. </td> </tr> <tr> <td width="40%"><a id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl>
///                <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a patch code GUID.
///                </td> </tr> </table>
///    dwDiskId = This parameter provides the ID of the disk being added or updated.
///    szVolumeLabel = The <i>szVolumeLabel</i> provides the label of the disk being added or updated. An update overwrites the existing
///                    volume label in the registry. To change the disk prompt only, get the existing volume label from the registry and
///                    provide it in this call along with the new disk prompt. Passing a <b>NULL</b> or empty string for
///                    <i>szVolumeLabel</i> registers an empty string (0 bytes in length) as the volume label.
///    szDiskPrompt = On entry to <b>MsiSourceListAddMediaDisk</b>, <i>szDiskPrompt</i> provides the disk prompt of the disk being
///                   added or updated. An update overwrites the registered disk prompt. To change the volume label only, get the
///                   existing disk prompt that is registered and provide it when calling <b>MsiSourceListAddMediaDisk</b> along with
///                   the new volume label. Passing <b>NULL</b> or an empty string registers an empty string (0 bytes in length) as the
///                   disk prompt.
///Returns:
///    The <b>MsiSourceListAddMediaDisk</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to read the specified media source or the specified product or
///    patch. This does not indicate whether a media source, product or patch was found. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is
///    corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td
///    width="60%"> The Windows Installer service could not be accessed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    value was successfully reordered. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt>
///    </dl> </td> <td width="60%"> The patch was not found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product was not found. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> Unexpected internal
///    failure. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListAddMediaDiskW(const(wchar)* szProductCodeOrPatchCode, const(wchar)* szUserSid, 
                                MSIINSTALLCONTEXT dwContext, uint dwOptions, uint dwDiskId, 
                                const(wchar)* szVolumeLabel, const(wchar)* szDiskPrompt);

///The <b>MsiSourceListClearSource</b> function removes an existing source for a product or patch in a specified
///context. The patch registration is also removed if the sole source of the patch gets removed and if the patch is not
///installed by any client in the same context. Specifying that <b>MsiSourceListClearSource</b> remove the current
///source for this product or patch forces the installer to search the source list for a source the next time a source
///is required.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns <b>ERROR_INVALID_PARAMETER</b>. This parameter cannot be
///                               <b>NULL</b>.
///    szUserSid = This parameter can be a string SID that specifies the user account that contains the product or patch. The SID is
///                not validated or resolved. An incorrect SID can return <b>ERROR_UNKNOWN_PRODUCT</b> or
///                <b>ERROR_UNKNOWN_PATCH</b>. When referencing a machine context, <i>szUserSID</i> must be <b>NULL</b> and
///                <i>dwContext</i> must be <b>MSIINSTALLCONTEXT_MACHINE</b>. <table> <tr> <th>Type of SID</th> <th>Meaning</th>
///                </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td
///                width="60%"> <b>NULL</b> denotes the currently logged on user. When referencing the current user account,
///                <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be <b>MSIINSTALLCONTEXT_USERMANAGED</b> or
///                <b>MSIINSTALLCONTEXT_USERUNMANAGED</b>. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a
///                id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> Specifies
///                enumeration for a particular user in the system. An example of a user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div class="alert"><b>Note</b> The special
///                SID string "S-1-5-18" (system) cannot be used to enumerate products or patches installed as per-machine. Setting
///                the SID value to "S-1-5-18" returns <b>ERROR_INVALID_PARAMETER</b>.</div> <div> </div> <div
///                class="alert"><b>Note</b> The special SID string "S-1-1-0" (everyone) should not be used. Setting the SID value
///                to "S-1-1-0" fails and returns <b>ERROR_INVALID_PARAM</b>.</div> <div> </div>
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value determines the interpretation of the <i>szProductCodeOrPatchCode</i> value and the
///                type of sources to clear. This parameter must be a combination of one of the following <b>MSISOURCETYPE_*</b>
///                constants and one of the following <b>MSICODE_*</b> constants. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr>
///                <tr> <td width="40%"><a id="MSISOURCETYPE_NETWORK"></a><a id="msisourcetype_network"></a><dl>
///                <dt><b>MSISOURCETYPE_NETWORK</b></dt> </dl> </td> <td width="60%"> The source is a network type. </td> </tr> <tr>
///                <td width="40%"><a id="MSISOURCETYPE_URL"></a><a id="msisourcetype_url"></a><dl>
///                <dt><b>MSISOURCETYPE_URL</b></dt> </dl> </td> <td width="60%"> The source is a URL type. </td> </tr> <tr> <td
///                width="40%"><a id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl> <dt><b>MSICODE_PRODUCT</b></dt> </dl>
///                </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a product code. </td> </tr> <tr> <td width="40%"><a
///                id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl> <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%">
///                <i>szProductCodeOrPatchCode</i> is a patch code. </td> </tr> </table>
///    szSource = Source to remove. This parameter is expected to contain only the path without the filename. The filename is
///               already registered as "PackageName" and can be manipulated through MsiSourceListSetInfo. This argument is
///               required.
///Returns:
///    The <b>MsiSourceListClearSource</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to remove a source. Does not indicate whether the product or
///    patch was found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td
///    width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td width="60%"> Could not access the Windows Installer
///    service </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> An invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The source was removed or not found. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The specified patch is
///    unknown. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td
///    width="60%"> The specified product is unknown. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> Unexpected internal failure. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiSourceListClearSourceA(const(char)* szProductCodeOrPatchCode, const(char)* szUserSid, 
                               MSIINSTALLCONTEXT dwContext, uint dwOptions, const(char)* szSource);

///The <b>MsiSourceListClearSource</b> function removes an existing source for a product or patch in a specified
///context. The patch registration is also removed if the sole source of the patch gets removed and if the patch is not
///installed by any client in the same context. Specifying that <b>MsiSourceListClearSource</b> remove the current
///source for this product or patch forces the installer to search the source list for a source the next time a source
///is required.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns <b>ERROR_INVALID_PARAMETER</b>. This parameter cannot be
///                               <b>NULL</b>.
///    szUserSid = This parameter can be a string SID that specifies the user account that contains the product or patch. The SID is
///                not validated or resolved. An incorrect SID can return <b>ERROR_UNKNOWN_PRODUCT</b> or
///                <b>ERROR_UNKNOWN_PATCH</b>. When referencing a machine context, <i>szUserSID</i> must be <b>NULL</b> and
///                <i>dwContext</i> must be <b>MSIINSTALLCONTEXT_MACHINE</b>. <table> <tr> <th>Type of SID</th> <th>Meaning</th>
///                </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td
///                width="60%"> <b>NULL</b> denotes the currently logged on user. When referencing the current user account,
///                <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be <b>MSIINSTALLCONTEXT_USERMANAGED</b> or
///                <b>MSIINSTALLCONTEXT_USERUNMANAGED</b>. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a
///                id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> Specifies
///                enumeration for a particular user in the system. An example of a user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div class="alert"><b>Note</b> The special
///                SID string "S-1-5-18" (system) cannot be used to enumerate products or patches installed as per-machine. Setting
///                the SID value to "S-1-5-18" returns <b>ERROR_INVALID_PARAMETER</b>.</div> <div> </div> <div
///                class="alert"><b>Note</b> The special SID string "S-1-1-0" (everyone) should not be used. Setting the SID value
///                to "S-1-1-0" fails and returns <b>ERROR_INVALID_PARAM</b>.</div> <div> </div>
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value determines the interpretation of the <i>szProductCodeOrPatchCode</i> value and the
///                type of sources to clear. This parameter must be a combination of one of the following <b>MSISOURCETYPE_*</b>
///                constants and one of the following <b>MSICODE_*</b> constants. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr>
///                <tr> <td width="40%"><a id="MSISOURCETYPE_NETWORK"></a><a id="msisourcetype_network"></a><dl>
///                <dt><b>MSISOURCETYPE_NETWORK</b></dt> </dl> </td> <td width="60%"> The source is a network type. </td> </tr> <tr>
///                <td width="40%"><a id="MSISOURCETYPE_URL"></a><a id="msisourcetype_url"></a><dl>
///                <dt><b>MSISOURCETYPE_URL</b></dt> </dl> </td> <td width="60%"> The source is a URL type. </td> </tr> <tr> <td
///                width="40%"><a id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl> <dt><b>MSICODE_PRODUCT</b></dt> </dl>
///                </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a product code. </td> </tr> <tr> <td width="40%"><a
///                id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl> <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%">
///                <i>szProductCodeOrPatchCode</i> is a patch code. </td> </tr> </table>
///    szSource = Source to remove. This parameter is expected to contain only the path without the filename. The filename is
///               already registered as "PackageName" and can be manipulated through MsiSourceListSetInfo. This argument is
///               required.
///Returns:
///    The <b>MsiSourceListClearSource</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to remove a source. Does not indicate whether the product or
///    patch was found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td
///    width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td width="60%"> Could not access the Windows Installer
///    service </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> An invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The source was removed or not found. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The specified patch is
///    unknown. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td
///    width="60%"> The specified product is unknown. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> Unexpected internal failure. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiSourceListClearSourceW(const(wchar)* szProductCodeOrPatchCode, const(wchar)* szUserSid, 
                               MSIINSTALLCONTEXT dwContext, uint dwOptions, const(wchar)* szSource);

///The <b>MsiSourceListClearMediaDisk</b> function provides the ability to remove an existing registered disk under the
///media source for a product or patch in a specific context.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns ERROR_INVALID_PARAMETER. This parameter cannot be <b>NULL</b>.
///    szUserSid = This parameter can be a string SID that specifies the user account that contains the product or patch. The SID is
///                not validated or resolved. An incorrect SID can return ERROR_UNKNOWN_PRODUCT or ERROR_UNKNOWN_PATCH. <table> <tr>
///                <th>Type of SID</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl>
///                <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> <b>NULL</b> denotes the currently logged on user. When
///                referencing the current user account, <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be
///                MSIINSTALLCONTEXT_USERMANAGED or MSIINSTALLCONTEXT_USERUNMANAGED. </td> </tr> <tr> <td width="40%"><a
///                id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td
///                width="60%"> Specifies enumeration for a particular user in the system. An example of user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div class="alert"><b>Note</b> The special
///                SID string s-1-5-18 (system) cannot be used to enumerate products or patches installed as per-machine. Setting
///                the SID value to s-1-5-18 returns ERROR_INVALID_PARAMETER. When <i>dwContext</i> is set to
///                MSIINSTALLCONTEXT_MACHINE only, <i>szUserSid</i> must be <b>NULL</b>. </div> <div> </div> <div
///                class="alert"><b>Note</b> The special SID string s-1-1-0 (everyone) should not be used. Setting the SID value to
///                s-1-1-0 fails and returns ERROR_INVALID_PARAM.</div> <div> </div>
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value specifies the meaning of <i>szProductCodeOrPatchCode</i>. <table> <tr> <th>Flag</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl>
///                <dt><b>MSICODE_PRODUCT</b></dt> </dl> </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a product code
///                GUID. </td> </tr> <tr> <td width="40%"><a id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl>
///                <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a patch code GUID.
///                </td> </tr> </table>
///    dwDiskId = This parameter provides the ID of the disk being removed.
///Returns:
///    The <b>MsiSourceListClearMediaDisk</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to read the specified media source or the specified product or
///    patch. This does not indicate whether a media source, product or patch was found. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is
///    corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td
///    width="60%"> The Windows Installer service could not be accessed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    value was successfully removed or not found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The patch was not found. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product was not found.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%">
///    Unexpected internal failure. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListClearMediaDiskA(const(char)* szProductCodeOrPatchCode, const(char)* szUserSid, 
                                  MSIINSTALLCONTEXT dwContext, uint dwOptions, uint dwDiskId);

///The <b>MsiSourceListClearMediaDisk</b> function provides the ability to remove an existing registered disk under the
///media source for a product or patch in a specific context.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns ERROR_INVALID_PARAMETER. This parameter cannot be <b>NULL</b>.
///    szUserSid = This parameter can be a string SID that specifies the user account that contains the product or patch. The SID is
///                not validated or resolved. An incorrect SID can return ERROR_UNKNOWN_PRODUCT or ERROR_UNKNOWN_PATCH. <table> <tr>
///                <th>Type of SID</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl>
///                <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> <b>NULL</b> denotes the currently logged on user. When
///                referencing the current user account, <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be
///                MSIINSTALLCONTEXT_USERMANAGED or MSIINSTALLCONTEXT_USERUNMANAGED. </td> </tr> <tr> <td width="40%"><a
///                id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td
///                width="60%"> Specifies enumeration for a particular user in the system. An example of user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div class="alert"><b>Note</b> The special
///                SID string s-1-5-18 (system) cannot be used to enumerate products or patches installed as per-machine. Setting
///                the SID value to s-1-5-18 returns ERROR_INVALID_PARAMETER. When <i>dwContext</i> is set to
///                MSIINSTALLCONTEXT_MACHINE only, <i>szUserSid</i> must be <b>NULL</b>. </div> <div> </div> <div
///                class="alert"><b>Note</b> The special SID string s-1-1-0 (everyone) should not be used. Setting the SID value to
///                s-1-1-0 fails and returns ERROR_INVALID_PARAM.</div> <div> </div>
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value specifies the meaning of <i>szProductCodeOrPatchCode</i>. <table> <tr> <th>Flag</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl>
///                <dt><b>MSICODE_PRODUCT</b></dt> </dl> </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a product code
///                GUID. </td> </tr> <tr> <td width="40%"><a id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl>
///                <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a patch code GUID.
///                </td> </tr> </table>
///    dwDiskId = This parameter provides the ID of the disk being removed.
///Returns:
///    The <b>MsiSourceListClearMediaDisk</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to read the specified media source or the specified product or
///    patch. This does not indicate whether a media source, product or patch was found. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is
///    corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td
///    width="60%"> The Windows Installer service could not be accessed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    value was successfully removed or not found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The patch was not found. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product was not found.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%">
///    Unexpected internal failure. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListClearMediaDiskW(const(wchar)* szProductCodeOrPatchCode, const(wchar)* szUserSid, 
                                  MSIINSTALLCONTEXT dwContext, uint dwOptions, uint dwDiskId);

///The <b>MsiSourceListClearAllEx</b> function removes all the existing sources of a given source type for the specified
///product or patch instance. The patch registration is also removed if the sole source of the patch gets removed and if
///the patch is not installed as a new patch by any client in the same context. Specifying that
///<b>MsiSourceListClearAllEx</b> remove the current source for this product or patch forces the installer to search the
///source list for a source the next time a source is required.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns ERROR_INVALID_PARAMETER. This parameter cannot be <b>NULL</b>.
///    szUserSid = This parameter can be a string SID that specifies the user account that contains the product or patch. The SID is
///                not validated or resolved. An incorrect SID can return ERROR_UNKNOWN_PRODUCT or ERROR_UNKNOWN_PATCH. When
///                referencing a machine context, <i>szUserSID</i> must be <b>NULL</b> and <i>dwContext</i> must be
///                MSIINSTALLCONTEXT_MACHINE. Using the machine SID ("S-1-5-18") returns ERROR_INVALID PARAMETER. When referencing
///                the current user account, <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be
///                MSIINSTALLCONTEXT_USERMANAGED or MSIINSTALLCONTEXT_USERUNMANAGED.
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value determines the interpretation of the <i>szProductCodeOrPatchCode</i> value and the
///                type of sources to clear. This parameter must be a combination of one of the following MSISOURCETYPE_* constants
///                and one of the following MSICODE_* constants. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td
///                width="40%"><a id="_MSISOURCETYPE_MEDIA"></a><a id="_msisourcetype_media"></a><dl> <dt><b>
///                MSISOURCETYPE_MEDIA</b></dt> </dl> </td> <td width="60%"> The source is media. </td> </tr> <tr> <td
///                width="40%"><a id="MSISOURCETYPE_NETWORK"></a><a id="msisourcetype_network"></a><dl>
///                <dt><b>MSISOURCETYPE_NETWORK</b></dt> </dl> </td> <td width="60%"> The source is a network type. </td> </tr> <tr>
///                <td width="40%"><a id="MSISOURCETYPE_URL"></a><a id="msisourcetype_url"></a><dl>
///                <dt><b>MSISOURCETYPE_URL</b></dt> </dl> </td> <td width="60%"> The source is a URL type. </td> </tr> <tr> <td
///                width="40%"><a id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl> <dt><b>MSICODE_PATCH</b></dt> </dl> </td>
///                <td width="60%"> <i>szProductCodeOrPatchCode</i> is a patch code. </td> </tr> <tr> <td width="40%"><a
///                id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl> <dt><b>MSICODE_PRODUCT</b></dt> </dl> </td> <td
///                width="60%"> <i>szProductCodeOrPatchCode</i> is a product code. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt>
///    </dl> </td> <td width="60%"> The user does not have the ability to add or move a source. Does not indicate
///    whether the product or patch was found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td width="60%">
///    Cannot access the Windows Installer service. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> All
///    sources of the specified type were removed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The specified product is unknown. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The specified patch
///    is unknown. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> Unexpected internal failure. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListClearAllExA(const(char)* szProductCodeOrPatchCode, const(char)* szUserSid, 
                              MSIINSTALLCONTEXT dwContext, uint dwOptions);

///The <b>MsiSourceListClearAllEx</b> function removes all the existing sources of a given source type for the specified
///product or patch instance. The patch registration is also removed if the sole source of the patch gets removed and if
///the patch is not installed as a new patch by any client in the same context. Specifying that
///<b>MsiSourceListClearAllEx</b> remove the current source for this product or patch forces the installer to search the
///source list for a source the next time a source is required.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns ERROR_INVALID_PARAMETER. This parameter cannot be <b>NULL</b>.
///    szUserSid = This parameter can be a string SID that specifies the user account that contains the product or patch. The SID is
///                not validated or resolved. An incorrect SID can return ERROR_UNKNOWN_PRODUCT or ERROR_UNKNOWN_PATCH. When
///                referencing a machine context, <i>szUserSID</i> must be <b>NULL</b> and <i>dwContext</i> must be
///                MSIINSTALLCONTEXT_MACHINE. Using the machine SID ("S-1-5-18") returns ERROR_INVALID PARAMETER. When referencing
///                the current user account, <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be
///                MSIINSTALLCONTEXT_USERMANAGED or MSIINSTALLCONTEXT_USERUNMANAGED.
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value determines the interpretation of the <i>szProductCodeOrPatchCode</i> value and the
///                type of sources to clear. This parameter must be a combination of one of the following MSISOURCETYPE_* constants
///                and one of the following MSICODE_* constants. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td
///                width="40%"><a id="_MSISOURCETYPE_MEDIA"></a><a id="_msisourcetype_media"></a><dl> <dt><b>
///                MSISOURCETYPE_MEDIA</b></dt> </dl> </td> <td width="60%"> The source is media. </td> </tr> <tr> <td
///                width="40%"><a id="MSISOURCETYPE_NETWORK"></a><a id="msisourcetype_network"></a><dl>
///                <dt><b>MSISOURCETYPE_NETWORK</b></dt> </dl> </td> <td width="60%"> The source is a network type. </td> </tr> <tr>
///                <td width="40%"><a id="MSISOURCETYPE_URL"></a><a id="msisourcetype_url"></a><dl>
///                <dt><b>MSISOURCETYPE_URL</b></dt> </dl> </td> <td width="60%"> The source is a URL type. </td> </tr> <tr> <td
///                width="40%"><a id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl> <dt><b>MSICODE_PATCH</b></dt> </dl> </td>
///                <td width="60%"> <i>szProductCodeOrPatchCode</i> is a patch code. </td> </tr> <tr> <td width="40%"><a
///                id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl> <dt><b>MSICODE_PRODUCT</b></dt> </dl> </td> <td
///                width="60%"> <i>szProductCodeOrPatchCode</i> is a product code. </td> </tr> </table>
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt>
///    </dl> </td> <td width="60%"> The user does not have the ability to add or move a source. Does not indicate
///    whether the product or patch was found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td width="60%">
///    Cannot access the Windows Installer service. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> All
///    sources of the specified type were removed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The specified product is unknown. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The specified patch
///    is unknown. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> Unexpected internal failure. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListClearAllExW(const(wchar)* szProductCodeOrPatchCode, const(wchar)* szUserSid, 
                              MSIINSTALLCONTEXT dwContext, uint dwOptions);

///The <b>MsiSourceListForceResolutionEx</b> function removes the registration of the property called "LastUsedSource".
///This function does not affect the registered source list. Whenever the installer requires the source to reinstall a
///product or patch, it first tries the source registered as "LastUsedSource". If that fails, or if that registration is
///missing, the installer searches the other registered sources until it finds a valid source or until the list of
///sources is exhausted. Clearing the "LastUsedSource" registration forces the installer to do a source resolution
///against the registered sources the next time it requires the source.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns ERROR_INVALID_PARAMETER. This parameter cannot be <b>NULL</b>.
///    szUserSid = This parameter can be a string SID that specifies the user account that contains the product or patch. The SID is
///                not validated or resolved. An incorrect SID can return ERROR_UNKNOWN_PRODUCT or ERROR_UNKNOWN_PATCH. When
///                referencing a machine context, <i>szUserSID</i> must be <b>NULL</b> and <i>dwContext</i> must be
///                MSIINSTALLCONTEXT_MACHINE. Using the machine SID ("S-1-5-18") returns ERROR_INVALID PARAMETER. When referencing
///                the current user account, <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be
///                MSIINSTALLCONTEXT_USERMANAGED or MSIINSTALLCONTEXT_USERUNMANAGED.
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value determines the interpretation of the <i>szProductCodeOrPatchCode</i> value . <table>
///                <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSICODE_PRODUCT"></a><a
///                id="msicode_product"></a><dl> <dt><b>MSICODE_PRODUCT</b></dt> </dl> </td> <td width="60%">
///                <i>szProductCodeOrPatchCode</i> is a product code. </td> </tr> <tr> <td width="40%"><a id="MSICODE_PATCH"></a><a
///                id="msicode_patch"></a><dl> <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%">
///                <i>szProductCodeOrPatchCode</i> is a patch code. </td> </tr> </table>
///Returns:
///    The <b>MsiSourceListForceResolutionEx</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to modify the specified source list. Does not indicate whether
///    the product or patch was found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt>
///    </dl> </td> <td width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td width="60%"> Could not access the Windows Installer
///    service </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> An invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The "LastUsedSource" registration was cleared. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The patch was
///    not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td
///    width="60%"> The specified product or patch was not found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> Unexpected internal failure. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiSourceListForceResolutionExA(const(char)* szProductCodeOrPatchCode, const(char)* szUserSid, 
                                     MSIINSTALLCONTEXT dwContext, uint dwOptions);

///The <b>MsiSourceListForceResolutionEx</b> function removes the registration of the property called "LastUsedSource".
///This function does not affect the registered source list. Whenever the installer requires the source to reinstall a
///product or patch, it first tries the source registered as "LastUsedSource". If that fails, or if that registration is
///missing, the installer searches the other registered sources until it finds a valid source or until the list of
///sources is exhausted. Clearing the "LastUsedSource" registration forces the installer to do a source resolution
///against the registered sources the next time it requires the source.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns ERROR_INVALID_PARAMETER. This parameter cannot be <b>NULL</b>.
///    szUserSid = This parameter can be a string SID that specifies the user account that contains the product or patch. The SID is
///                not validated or resolved. An incorrect SID can return ERROR_UNKNOWN_PRODUCT or ERROR_UNKNOWN_PATCH. When
///                referencing a machine context, <i>szUserSID</i> must be <b>NULL</b> and <i>dwContext</i> must be
///                MSIINSTALLCONTEXT_MACHINE. Using the machine SID ("S-1-5-18") returns ERROR_INVALID PARAMETER. When referencing
///                the current user account, <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be
///                MSIINSTALLCONTEXT_USERMANAGED or MSIINSTALLCONTEXT_USERUNMANAGED.
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value determines the interpretation of the <i>szProductCodeOrPatchCode</i> value . <table>
///                <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSICODE_PRODUCT"></a><a
///                id="msicode_product"></a><dl> <dt><b>MSICODE_PRODUCT</b></dt> </dl> </td> <td width="60%">
///                <i>szProductCodeOrPatchCode</i> is a product code. </td> </tr> <tr> <td width="40%"><a id="MSICODE_PATCH"></a><a
///                id="msicode_patch"></a><dl> <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%">
///                <i>szProductCodeOrPatchCode</i> is a patch code. </td> </tr> </table>
///Returns:
///    The <b>MsiSourceListForceResolutionEx</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to modify the specified source list. Does not indicate whether
///    the product or patch was found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt>
///    </dl> </td> <td width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td width="60%"> Could not access the Windows Installer
///    service </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> An invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The "LastUsedSource" registration was cleared. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The patch was
///    not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td
///    width="60%"> The specified product or patch was not found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> Unexpected internal failure. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiSourceListForceResolutionExW(const(wchar)* szProductCodeOrPatchCode, const(wchar)* szUserSid, 
                                     MSIINSTALLCONTEXT dwContext, uint dwOptions);

///The <b>MsiSourceListSetInfo</b> function sets information about the source list for a product or patch in a specific
///context.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns <b>ERROR_INVALID_PARAMETER</b>. This parameter cannot be
///                               <b>NULL</b>.
///    szUserSid = This parameter can be a string SID that specifies the user account that contains the product or patch. The SID is
///                not validated or resolved. An incorrect SID can return <b>ERROR_UNKNOWN_PRODUCT</b> or
///                <b>ERROR_UNKNOWN_PATCH</b>. When referencing a machine context, <i>szUserSID</i> must be <b>NULL</b> and
///                <i>dwContext</i> must be <b>MSIINSTALLCONTEXT_MACHINE</b>. <table> <tr> <th>Type of SID</th> <th>Meaning</th>
///                </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td
///                width="60%"> <b>NULL</b> denotes the currently logged on user. When referencing the current user account,
///                <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be <b>MSIINSTALLCONTEXT_USERMANAGED</b> or
///                <b>MSIINSTALLCONTEXT_USERUNMANAGED</b>. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a
///                id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> Specifies
///                enumeration for a particular user in the system. An example of a user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div class="alert"><b>Note</b> The special
///                SID string "S-1-5-18" (system) cannot be used to enumerate products or patches installed as per-machine. Setting
///                the SID value to "S-1-5-18" returns "ERROR_INVALID_PARAMETER".</div> <div> </div> <div class="alert"><b>Note</b>
///                The special SID string "S-1-1-0" (everyone) should not be used. Setting the SID value to "S-1-1-0" fails and
///                returns <b>ERROR_INVALID_PARAM</b>.</div> <div> </div>
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value specifies the meaning of <i>szProductCodeOrPatchCode</i>. If the property being set is
///                "LastUsedSource", this parameter also specifies the type of source as network or URL. In this case, the
///                <i>dwOptions</i> parameter must be a combination of one of the following <b>MSISOURCETYPE_*</b> constants and one
///                of the following <b>MSICODE_*</b> constants. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td
///                width="40%"><a id="MSISOURCETYPE_NETWORK"></a><a id="msisourcetype_network"></a><dl>
///                <dt><b>MSISOURCETYPE_NETWORK</b></dt> </dl> </td> <td width="60%"> The source is a network type. </td> </tr> <tr>
///                <td width="40%"><a id="MSISOURCETYPE_URL"></a><a id="msisourcetype_url"></a><dl>
///                <dt><b>MSISOURCETYPE_URL</b></dt> </dl> </td> <td width="60%"> The source is a URL type. </td> </tr> <tr> <td
///                width="40%"><a id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl> <dt><b>MSICODE_PRODUCT</b></dt> </dl>
///                </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a product code GUID. </td> </tr> <tr> <td
///                width="40%"><a id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl> <dt><b>MSICODE_PATCH</b></dt> </dl> </td>
///                <td width="60%"> <i>szProductCodeOrPatchCode</i> is a patch code GUID. </td> </tr> </table>
///    szProperty = The parameter <i>szProperty</i> indicates the property value to set. Not all properties that can be retrieved
///                 through MsiSourceListGetInfo can be set via a call to <b>MsiSourceListSetInfo</b>. The <i>szProperty</i> value
///                 can be one of the following values. <table> <tr> <th>Name</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_MEDIAPACKAGEPATH"></a><a id="installproperty_mediapackagepath"></a><dl>
///                 <dt><b>INSTALLPROPERTY_MEDIAPACKAGEPATH</b></dt> <dt>"MediaPackagePath"</dt> </dl> </td> <td width="60%"> The
///                 path relative to the root of the installation media. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_DISKPROMPT"></a><a id="installproperty_diskprompt"></a><dl>
///                 <dt><b>INSTALLPROPERTY_DISKPROMPT</b></dt> <dt>"DiskPrompt"</dt> </dl> </td> <td width="60%"> The prompt template
///                 used when prompting the user for installation media. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_LASTUSEDSOURCE"></a><a id="installproperty_lastusedsource"></a><dl>
///                 <dt><b>INSTALLPROPERTY_LASTUSEDSOURCE</b></dt> <dt>"LastUsedSource"</dt> </dl> </td> <td width="60%"> The most
///                 recently used source location for the product. If the source is not registered, the function calls
///                 MsiSourceListAddSourceEx to register it. On successful registration, the function sets the source as the
///                 LastUsedSource. </td> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_PACKAGENAME"></a><a
///                 id="installproperty_packagename"></a><dl> <dt><b>INSTALLPROPERTY_PACKAGENAME</b></dt> <dt>"PackageName"</dt>
///                 </dl> </td> <td width="60%"> The name of the Windows Installer package or patch package on the source. </td>
///                 </tr> </table>
///    szValue = The new value of the property. No validation of the new value is performed. This value cannot be <b>NULL</b>. It
///              can be an empty string.
///Returns:
///    The <b>MsiSourceListSetInfo</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to set the source list for the specified product. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration
///    data is corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td>
///    <td width="60%"> The Windows Installer service could not be accessed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    property was set. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td
///    width="60%"> The patch was not found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product was not found. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PROPERTY</b></dt> </dl> </td> <td width="60%"> The source property was
///    not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> Unexpected internal failure. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListSetInfoA(const(char)* szProductCodeOrPatchCode, const(char)* szUserSid, 
                           MSIINSTALLCONTEXT dwContext, uint dwOptions, const(char)* szProperty, 
                           const(char)* szValue);

///The <b>MsiSourceListSetInfo</b> function sets information about the source list for a product or patch in a specific
///context.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns <b>ERROR_INVALID_PARAMETER</b>. This parameter cannot be
///                               <b>NULL</b>.
///    szUserSid = This parameter can be a string SID that specifies the user account that contains the product or patch. The SID is
///                not validated or resolved. An incorrect SID can return <b>ERROR_UNKNOWN_PRODUCT</b> or
///                <b>ERROR_UNKNOWN_PATCH</b>. When referencing a machine context, <i>szUserSID</i> must be <b>NULL</b> and
///                <i>dwContext</i> must be <b>MSIINSTALLCONTEXT_MACHINE</b>. <table> <tr> <th>Type of SID</th> <th>Meaning</th>
///                </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td
///                width="60%"> <b>NULL</b> denotes the currently logged on user. When referencing the current user account,
///                <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be <b>MSIINSTALLCONTEXT_USERMANAGED</b> or
///                <b>MSIINSTALLCONTEXT_USERUNMANAGED</b>. </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a
///                id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td width="60%"> Specifies
///                enumeration for a particular user in the system. An example of a user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div class="alert"><b>Note</b> The special
///                SID string "S-1-5-18" (system) cannot be used to enumerate products or patches installed as per-machine. Setting
///                the SID value to "S-1-5-18" returns "ERROR_INVALID_PARAMETER".</div> <div> </div> <div class="alert"><b>Note</b>
///                The special SID string "S-1-1-0" (everyone) should not be used. Setting the SID value to "S-1-1-0" fails and
///                returns <b>ERROR_INVALID_PARAM</b>.</div> <div> </div>
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value specifies the meaning of <i>szProductCodeOrPatchCode</i>. If the property being set is
///                "LastUsedSource", this parameter also specifies the type of source as network or URL. In this case, the
///                <i>dwOptions</i> parameter must be a combination of one of the following <b>MSISOURCETYPE_*</b> constants and one
///                of the following <b>MSICODE_*</b> constants. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td
///                width="40%"><a id="MSISOURCETYPE_NETWORK"></a><a id="msisourcetype_network"></a><dl>
///                <dt><b>MSISOURCETYPE_NETWORK</b></dt> </dl> </td> <td width="60%"> The source is a network type. </td> </tr> <tr>
///                <td width="40%"><a id="MSISOURCETYPE_URL"></a><a id="msisourcetype_url"></a><dl>
///                <dt><b>MSISOURCETYPE_URL</b></dt> </dl> </td> <td width="60%"> The source is a URL type. </td> </tr> <tr> <td
///                width="40%"><a id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl> <dt><b>MSICODE_PRODUCT</b></dt> </dl>
///                </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a product code GUID. </td> </tr> <tr> <td
///                width="40%"><a id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl> <dt><b>MSICODE_PATCH</b></dt> </dl> </td>
///                <td width="60%"> <i>szProductCodeOrPatchCode</i> is a patch code GUID. </td> </tr> </table>
///    szProperty = The parameter <i>szProperty</i> indicates the property value to set. Not all properties that can be retrieved
///                 through MsiSourceListGetInfo can be set via a call to <b>MsiSourceListSetInfo</b>. The <i>szProperty</i> value
///                 can be one of the following values. <table> <tr> <th>Name</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_MEDIAPACKAGEPATH"></a><a id="installproperty_mediapackagepath"></a><dl>
///                 <dt><b>INSTALLPROPERTY_MEDIAPACKAGEPATH</b></dt> <dt>"MediaPackagePath"</dt> </dl> </td> <td width="60%"> The
///                 path relative to the root of the installation media. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_DISKPROMPT"></a><a id="installproperty_diskprompt"></a><dl>
///                 <dt><b>INSTALLPROPERTY_DISKPROMPT</b></dt> <dt>"DiskPrompt"</dt> </dl> </td> <td width="60%"> The prompt template
///                 used when prompting the user for installation media. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_LASTUSEDSOURCE"></a><a id="installproperty_lastusedsource"></a><dl>
///                 <dt><b>INSTALLPROPERTY_LASTUSEDSOURCE</b></dt> <dt>"LastUsedSource"</dt> </dl> </td> <td width="60%"> The most
///                 recently used source location for the product. If the source is not registered, the function calls
///                 MsiSourceListAddSourceEx to register it. On successful registration, the function sets the source as the
///                 LastUsedSource. </td> </tr> <tr> <td width="40%"><a id="INSTALLPROPERTY_PACKAGENAME"></a><a
///                 id="installproperty_packagename"></a><dl> <dt><b>INSTALLPROPERTY_PACKAGENAME</b></dt> <dt>"PackageName"</dt>
///                 </dl> </td> <td width="60%"> The name of the Windows Installer package or patch package on the source. </td>
///                 </tr> </table>
///    szValue = The new value of the property. No validation of the new value is performed. This value cannot be <b>NULL</b>. It
///              can be an empty string.
///Returns:
///    The <b>MsiSourceListSetInfo</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to set the source list for the specified product. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration
///    data is corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td>
///    <td width="60%"> The Windows Installer service could not be accessed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The
///    property was set. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td
///    width="60%"> The patch was not found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product was not found. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PROPERTY</b></dt> </dl> </td> <td width="60%"> The source property was
///    not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> Unexpected internal failure. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiSourceListSetInfoW(const(wchar)* szProductCodeOrPatchCode, const(wchar)* szUserSid, 
                           MSIINSTALLCONTEXT dwContext, uint dwOptions, const(wchar)* szProperty, 
                           const(wchar)* szValue);

///The <b>MsiSourceListGetInfo</b> function retrieves information about the source list for a product or patch in a
///specific context.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns ERROR_INVALID_PARAMETER. This parameter cannot be <b>NULL</b>.
///    szUserSid = This parameter can be a string security identifier (SID) that specifies the user account that contains the
///                product or patch. The SID is not validated or resolved. An incorrect SID can return ERROR_UNKNOWN_PRODUCT or
///                ERROR_UNKNOWN_PATCH. When referencing a machine context, <i>szUserSID</i> must be <b>NULL</b> and
///                <i>dwContext</i> must be MSIINSTALLCONTEXT_MACHINE. <table> <tr> <th>Type of SID</th> <th>Meaning</th> </tr> <tr>
///                <td width="40%"><a id="NULL"></a><a id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%">
///                <b>NULL</b> denotes the currently logged on user. When referencing the current user account, <i>szUserSID</i> can
///                be <b>NULL</b> and <i>dwContext</i> can be MSIINSTALLCONTEXT_USERMANAGED or MSIINSTALLCONTEXT_USERUNMANAGED.
///                </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User
///                SID</b></dt> </dl> </td> <td width="60%"> Specifies enumeration for a specific user in the system. An example of
///                a user SID is "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div
///                class="alert"><b>Note</b> The special SID string s-1-5-18 (system) cannot be used to enumerate products or
///                patches installed as per-machine. Setting the SID value to s-1-5-18 returns ERROR_INVALID_PARAMETER.</div> <div>
///                </div> <div class="alert"><b>Note</b> The special SID string s-1-1-0 (everyone) should not be used. Setting the
///                SID value to s-1-1-0 fails and returns ERROR_INVALID_PARAM.</div> <div> </div>
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value specifies the meaning of <i>szProductCodeOrPatchCode</i>. <table> <tr> <th>Flag</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl>
///                <dt><b>MSICODE_PRODUCT</b></dt> </dl> </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a product code
///                GUID. </td> </tr> <tr> <td width="40%"><a id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl>
///                <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a patch code GUID.
///                </td> </tr> </table>
///    szProperty = A null-terminated string that specifies the property value to retrieve. The <i>szProperty</i> parameter can be
///                 one of the following values. <table> <tr> <th>Name</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_MEDIAPACKAGEPATH"></a><a id="installproperty_mediapackagepath"></a><dl>
///                 <dt><b>INSTALLPROPERTY_MEDIAPACKAGEPATH</b></dt> <dt>"MediaPackagePath"</dt> </dl> </td> <td width="60%"> The
///                 path relative to the root of the installation media. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_DISKPROMPT"></a><a id="installproperty_diskprompt"></a><dl>
///                 <dt><b>INSTALLPROPERTY_DISKPROMPT</b></dt> <dt>"DiskPrompt"</dt> </dl> </td> <td width="60%"> The prompt template
///                 that is used when prompting the user for installation media. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_LASTUSEDSOURCE"></a><a id="installproperty_lastusedsource"></a><dl>
///                 <dt><b>INSTALLPROPERTY_LASTUSEDSOURCE</b></dt> <dt>"LastUsedSource"</dt> </dl> </td> <td width="60%"> The most
///                 recently used source location for the product. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_LASTUSEDTYPE"></a><a id="installproperty_lastusedtype"></a><dl>
///                 <dt><b>INSTALLPROPERTY_LASTUSEDTYPE</b></dt> <dt>"LastUsedType"</dt> </dl> </td> <td width="60%"> An "n" if the
///                 last-used source is a network location. A "u" if the last used source is a URL location. An "m" if the last used
///                 source is media. An empty string ("") if there is no last used source. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_PACKAGENAME"></a><a id="installproperty_packagename"></a><dl>
///                 <dt><b>INSTALLPROPERTY_PACKAGENAME</b></dt> <dt>"PackageName"</dt> </dl> </td> <td width="60%"> The name of the
///                 Windows Installer package or patch package on the source. </td> </tr> </table>
///    szValue = An output buffer that receives the information. This buffer should be large enough to contain the information. If
///              the buffer is too small, the function returns ERROR_MORE_DATA and sets *<i>pcchValue</i> to the number of
///              <b>TCHAR</b> in the value, not including the terminating NULL character. If the <i>szValue</i> is set to
///              <b>NULL</b> and <i>pcchValue</i> is set to a valid pointer, the function returns ERROR_SUCCESS and sets
///              *<i>pcchValue</i> to the number of <b>TCHAR</b> in the value, not including the terminating NULL character. The
///              function can then be called again to retrieve the value, with <i>szValue</i> buffer large enough to contain
///              *<i>pcchValue</i> + 1 characters. If <i>szValue</i> and <i>pcchValue</i> are both set to <b>NULL</b>, the
///              function returns ERROR_SUCCESS if the value exists, without retrieving the value.
///    pcchValue = A pointer to a variable that specifies the number of <b>TCHAR</b> in the <i>szValue</i> buffer. When the function
///                returns, this parameter is set to the size of the requested value whether or not the function copies the value
///                into the specified buffer. The size is returned as the number of <b>TCHAR</b> in the requested value, not
///                including the terminating null character. This parameter can be set to <b>NULL</b> only if <i>szValue</i> is also
///                <b>NULL</b>, otherwise the function returns ERROR_INVALID_PARAMETER.
///Returns:
///    The <b>MsiSourceListGetInfo</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to read the specified source list. This does not indicate whether
///    a product or patch is found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl>
///    </td> <td width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The
///    provided buffer is not sufficient to contain the requested data. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The property is retrieved successfully. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The patch is not
///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%">
///    The product is not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PROPERTY</b></dt> </dl>
///    </td> <td width="60%"> The source property is not found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> An unexpected internal failure. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiSourceListGetInfoA(const(char)* szProductCodeOrPatchCode, const(char)* szUserSid, 
                           MSIINSTALLCONTEXT dwContext, uint dwOptions, const(char)* szProperty, 
                           const(char)* szValue, uint* pcchValue);

///The <b>MsiSourceListGetInfo</b> function retrieves information about the source list for a product or patch in a
///specific context.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns ERROR_INVALID_PARAMETER. This parameter cannot be <b>NULL</b>.
///    szUserSid = This parameter can be a string security identifier (SID) that specifies the user account that contains the
///                product or patch. The SID is not validated or resolved. An incorrect SID can return ERROR_UNKNOWN_PRODUCT or
///                ERROR_UNKNOWN_PATCH. When referencing a machine context, <i>szUserSID</i> must be <b>NULL</b> and
///                <i>dwContext</i> must be MSIINSTALLCONTEXT_MACHINE. <table> <tr> <th>Type of SID</th> <th>Meaning</th> </tr> <tr>
///                <td width="40%"><a id="NULL"></a><a id="null"></a><dl> <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%">
///                <b>NULL</b> denotes the currently logged on user. When referencing the current user account, <i>szUserSID</i> can
///                be <b>NULL</b> and <i>dwContext</i> can be MSIINSTALLCONTEXT_USERMANAGED or MSIINSTALLCONTEXT_USERUNMANAGED.
///                </td> </tr> <tr> <td width="40%"><a id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User
///                SID</b></dt> </dl> </td> <td width="60%"> Specifies enumeration for a specific user in the system. An example of
///                a user SID is "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> </table> <div
///                class="alert"><b>Note</b> The special SID string s-1-5-18 (system) cannot be used to enumerate products or
///                patches installed as per-machine. Setting the SID value to s-1-5-18 returns ERROR_INVALID_PARAMETER.</div> <div>
///                </div> <div class="alert"><b>Note</b> The special SID string s-1-1-0 (everyone) should not be used. Setting the
///                SID value to s-1-1-0 fails and returns ERROR_INVALID_PARAM.</div> <div> </div>
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value specifies the meaning of <i>szProductCodeOrPatchCode</i>. <table> <tr> <th>Flag</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl>
///                <dt><b>MSICODE_PRODUCT</b></dt> </dl> </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a product code
///                GUID. </td> </tr> <tr> <td width="40%"><a id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl>
///                <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a patch code GUID.
///                </td> </tr> </table>
///    szProperty = A null-terminated string that specifies the property value to retrieve. The <i>szProperty</i> parameter can be
///                 one of the following values. <table> <tr> <th>Name</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_MEDIAPACKAGEPATH"></a><a id="installproperty_mediapackagepath"></a><dl>
///                 <dt><b>INSTALLPROPERTY_MEDIAPACKAGEPATH</b></dt> <dt>"MediaPackagePath"</dt> </dl> </td> <td width="60%"> The
///                 path relative to the root of the installation media. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_DISKPROMPT"></a><a id="installproperty_diskprompt"></a><dl>
///                 <dt><b>INSTALLPROPERTY_DISKPROMPT</b></dt> <dt>"DiskPrompt"</dt> </dl> </td> <td width="60%"> The prompt template
///                 that is used when prompting the user for installation media. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_LASTUSEDSOURCE"></a><a id="installproperty_lastusedsource"></a><dl>
///                 <dt><b>INSTALLPROPERTY_LASTUSEDSOURCE</b></dt> <dt>"LastUsedSource"</dt> </dl> </td> <td width="60%"> The most
///                 recently used source location for the product. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_LASTUSEDTYPE"></a><a id="installproperty_lastusedtype"></a><dl>
///                 <dt><b>INSTALLPROPERTY_LASTUSEDTYPE</b></dt> <dt>"LastUsedType"</dt> </dl> </td> <td width="60%"> An "n" if the
///                 last-used source is a network location. A "u" if the last used source is a URL location. An "m" if the last used
///                 source is media. An empty string ("") if there is no last used source. </td> </tr> <tr> <td width="40%"><a
///                 id="INSTALLPROPERTY_PACKAGENAME"></a><a id="installproperty_packagename"></a><dl>
///                 <dt><b>INSTALLPROPERTY_PACKAGENAME</b></dt> <dt>"PackageName"</dt> </dl> </td> <td width="60%"> The name of the
///                 Windows Installer package or patch package on the source. </td> </tr> </table>
///    szValue = An output buffer that receives the information. This buffer should be large enough to contain the information. If
///              the buffer is too small, the function returns ERROR_MORE_DATA and sets *<i>pcchValue</i> to the number of
///              <b>TCHAR</b> in the value, not including the terminating NULL character. If the <i>szValue</i> is set to
///              <b>NULL</b> and <i>pcchValue</i> is set to a valid pointer, the function returns ERROR_SUCCESS and sets
///              *<i>pcchValue</i> to the number of <b>TCHAR</b> in the value, not including the terminating NULL character. The
///              function can then be called again to retrieve the value, with <i>szValue</i> buffer large enough to contain
///              *<i>pcchValue</i> + 1 characters. If <i>szValue</i> and <i>pcchValue</i> are both set to <b>NULL</b>, the
///              function returns ERROR_SUCCESS if the value exists, without retrieving the value.
///    pcchValue = A pointer to a variable that specifies the number of <b>TCHAR</b> in the <i>szValue</i> buffer. When the function
///                returns, this parameter is set to the size of the requested value whether or not the function copies the value
///                into the specified buffer. The size is returned as the number of <b>TCHAR</b> in the requested value, not
///                including the terminating null character. This parameter can be set to <b>NULL</b> only if <i>szValue</i> is also
///                <b>NULL</b>, otherwise the function returns ERROR_INVALID_PARAMETER.
///Returns:
///    The <b>MsiSourceListGetInfo</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to read the specified source list. This does not indicate whether
///    a product or patch is found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl>
///    </td> <td width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The
///    provided buffer is not sufficient to contain the requested data. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The property is retrieved successfully. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The patch is not
///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%">
///    The product is not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PROPERTY</b></dt> </dl>
///    </td> <td width="60%"> The source property is not found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> An unexpected internal failure. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiSourceListGetInfoW(const(wchar)* szProductCodeOrPatchCode, const(wchar)* szUserSid, 
                           MSIINSTALLCONTEXT dwContext, uint dwOptions, const(wchar)* szProperty, 
                           const(wchar)* szValue, uint* pcchValue);

///The <b>MsiSourceListEnumSources</b> function enumerates the sources in the source list of a specified patch or
///product.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns ERROR_INVALID_PARAMETER. This parameter cannot be <b>NULL</b>.
///    szUserSid = A string SID that specifies the user account that contains the product or patch. The SID is not validated or
///                resolved. An incorrect SID can return ERROR_UNKNOWN_PRODUCT or ERROR_UNKNOWN_PATCH. When referencing a machine
///                context, <i>szUserSID</i> must be <b>NULL</b> and <i>dwContext</i> must be MSIINSTALLCONTEXT_MACHINE. <table>
///                <tr> <th>Type of SID</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl>
///                <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> A <b>NULL</b> indicates the current user who is logged
///                on. When referencing the current user account, <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be
///                MSIINSTALLCONTEXT_USERMANAGED or MSIINSTALLCONTEXT_USERUNMANAGED. </td> </tr> <tr> <td width="40%"><a
///                id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td
///                width="60%"> An enumeration for a specific user in the system. An example of a user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> <tr> <td width="40%"><a id="s-1-1-0"></a><a
///                id="S-1-1-0"></a><dl> <dt><b>s-1-1-0</b></dt> </dl> </td> <td width="60%"> The special SID string s-1-1-0
///                (everyone) specifies enumeration across all users in the system. </td> </tr> </table> <div
///                class="alert"><b>Note</b> The special SID string s-1-5-18 (system) cannot be used to enumerate products or
///                patches installed as per-machine. Setting the SID value to s-1-5-18 returns ERROR_INVALID_PARAMETER.</div> <div>
///                </div>
///    dwContext = The context of the product or patch instance. This parameter can contain one of the following values. <table>
///                <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value determines the interpretation of the <i>szProductCodeOrPatchCode</i> value and the
///                type of sources to clear. This parameter must be a combination of one of the following MSISOURCETYPE_* constants
///                and one of the following MSICODE_* constants. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td
///                width="40%"><a id="MSISOURCETYPE_NETWORK"></a><a id="msisourcetype_network"></a><dl>
///                <dt><b>MSISOURCETYPE_NETWORK</b></dt> </dl> </td> <td width="60%"> The source is a network type. </td> </tr> <tr>
///                <td width="40%"><a id="MSISOURCETYPE_URL"></a><a id="msisourcetype_url"></a><dl>
///                <dt><b>MSISOURCETYPE_URL</b></dt> </dl> </td> <td width="60%"> The source is a URL type. </td> </tr> <tr> <td
///                width="40%"><a id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl> <dt><b>MSICODE_PRODUCT</b></dt> </dl>
///                </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a product code. </td> </tr> <tr> <td width="40%"><a
///                id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl> <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%">
///                <i>szProductCodeOrPatchCode</i> is a patch code. </td> </tr> </table>
///    dwIndex = The index of the source to retrieve. This parameter must be 0 (zero) for the first call to the
///              <b>MsiSourceListEnumSources</b> function, and then incremented for subsequent calls until the function returns
///              ERROR_NO_MORE_ITEMS. The index should be incremented only if the previous call returned ERROR_SUCCESS.
///    szSource = A pointer to a buffer that receives the path to the source that is being enumerated. This buffer should be large
///               enough to contain the received value. If the buffer is too small, the function returns ERROR_MORE_DATA and sets
///               *<i>pcchSource</i> to the number of <b>TCHAR</b> in the value, not including the terminating NULL character. If
///               <i>szSource</i> is set to <b>NULL</b> and <i>pcchSource</i> is set to a valid pointer, the function returns
///               ERROR_SUCCESS and sets *<i>pcchSource</i> to the number of <b>TCHAR</b> in the value, not including the
///               terminating NULL character. The function can then be called again to retrieve the value, with <i>szSource</i>
///               buffer large enough to contain *<i>pcchSource</i> + 1 characters. If <i>szSource</i> and <i>pcchSource</i> are
///               both set to <b>NULL</b>, the function returns ERROR_SUCCESS if the value exists, without retrieving the value.
///    pcchSource = A pointer to a variable that specifies the number of <b>TCHAR</b> in the <i>szSource</i> buffer. When the
///                 function returns, this parameter is set to the size of the requested value whether or not the function copies the
///                 value into the specified buffer. The size is returned as the number of <b>TCHAR</b> in the requested value, not
///                 including the terminating null character. This parameter can be set to <b>NULL</b> only if <i>szSource</i> is
///                 also <b>NULL</b>, otherwise the function returns ERROR_INVALID_PARAMETER.
///Returns:
///    The <b>MsiSourceListEnumSources</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to read the specified source list. This does not indicate whether
///    a product or patch is found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl>
///    </td> <td width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The
///    provided buffer is not sufficient to contain the requested data. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%"> There are no more sources in the specified list
///    to enumerate. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A
///    source is enumerated successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt>
///    </dl> </td> <td width="60%"> The patch specified is not installed on the computer in the specified contexts.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The
///    product specified is not installed on the computer in the specified contexts. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> Unexpected internal failure. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiSourceListEnumSourcesA(const(char)* szProductCodeOrPatchCode, const(char)* szUserSid, 
                               MSIINSTALLCONTEXT dwContext, uint dwOptions, uint dwIndex, const(char)* szSource, 
                               uint* pcchSource);

///The <b>MsiSourceListEnumSources</b> function enumerates the sources in the source list of a specified patch or
///product.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns ERROR_INVALID_PARAMETER. This parameter cannot be <b>NULL</b>.
///    szUserSid = A string SID that specifies the user account that contains the product or patch. The SID is not validated or
///                resolved. An incorrect SID can return ERROR_UNKNOWN_PRODUCT or ERROR_UNKNOWN_PATCH. When referencing a machine
///                context, <i>szUserSID</i> must be <b>NULL</b> and <i>dwContext</i> must be MSIINSTALLCONTEXT_MACHINE. <table>
///                <tr> <th>Type of SID</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl>
///                <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> A <b>NULL</b> indicates the current user who is logged
///                on. When referencing the current user account, <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be
///                MSIINSTALLCONTEXT_USERMANAGED or MSIINSTALLCONTEXT_USERUNMANAGED. </td> </tr> <tr> <td width="40%"><a
///                id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td
///                width="60%"> An enumeration for a specific user in the system. An example of a user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> <tr> <td width="40%"><a id="s-1-1-0"></a><a
///                id="S-1-1-0"></a><dl> <dt><b>s-1-1-0</b></dt> </dl> </td> <td width="60%"> The special SID string s-1-1-0
///                (everyone) specifies enumeration across all users in the system. </td> </tr> </table> <div
///                class="alert"><b>Note</b> The special SID string s-1-5-18 (system) cannot be used to enumerate products or
///                patches installed as per-machine. Setting the SID value to s-1-5-18 returns ERROR_INVALID_PARAMETER.</div> <div>
///                </div>
///    dwContext = The context of the product or patch instance. This parameter can contain one of the following values. <table>
///                <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value determines the interpretation of the <i>szProductCodeOrPatchCode</i> value and the
///                type of sources to clear. This parameter must be a combination of one of the following MSISOURCETYPE_* constants
///                and one of the following MSICODE_* constants. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td
///                width="40%"><a id="MSISOURCETYPE_NETWORK"></a><a id="msisourcetype_network"></a><dl>
///                <dt><b>MSISOURCETYPE_NETWORK</b></dt> </dl> </td> <td width="60%"> The source is a network type. </td> </tr> <tr>
///                <td width="40%"><a id="MSISOURCETYPE_URL"></a><a id="msisourcetype_url"></a><dl>
///                <dt><b>MSISOURCETYPE_URL</b></dt> </dl> </td> <td width="60%"> The source is a URL type. </td> </tr> <tr> <td
///                width="40%"><a id="MSICODE_PRODUCT"></a><a id="msicode_product"></a><dl> <dt><b>MSICODE_PRODUCT</b></dt> </dl>
///                </td> <td width="60%"> <i>szProductCodeOrPatchCode</i> is a product code. </td> </tr> <tr> <td width="40%"><a
///                id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl> <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%">
///                <i>szProductCodeOrPatchCode</i> is a patch code. </td> </tr> </table>
///    dwIndex = The index of the source to retrieve. This parameter must be 0 (zero) for the first call to the
///              <b>MsiSourceListEnumSources</b> function, and then incremented for subsequent calls until the function returns
///              ERROR_NO_MORE_ITEMS. The index should be incremented only if the previous call returned ERROR_SUCCESS.
///    szSource = A pointer to a buffer that receives the path to the source that is being enumerated. This buffer should be large
///               enough to contain the received value. If the buffer is too small, the function returns ERROR_MORE_DATA and sets
///               *<i>pcchSource</i> to the number of <b>TCHAR</b> in the value, not including the terminating NULL character. If
///               <i>szSource</i> is set to <b>NULL</b> and <i>pcchSource</i> is set to a valid pointer, the function returns
///               ERROR_SUCCESS and sets *<i>pcchSource</i> to the number of <b>TCHAR</b> in the value, not including the
///               terminating NULL character. The function can then be called again to retrieve the value, with <i>szSource</i>
///               buffer large enough to contain *<i>pcchSource</i> + 1 characters. If <i>szSource</i> and <i>pcchSource</i> are
///               both set to <b>NULL</b>, the function returns ERROR_SUCCESS if the value exists, without retrieving the value.
///    pcchSource = A pointer to a variable that specifies the number of <b>TCHAR</b> in the <i>szSource</i> buffer. When the
///                 function returns, this parameter is set to the size of the requested value whether or not the function copies the
///                 value into the specified buffer. The size is returned as the number of <b>TCHAR</b> in the requested value, not
///                 including the terminating null character. This parameter can be set to <b>NULL</b> only if <i>szSource</i> is
///                 also <b>NULL</b>, otherwise the function returns ERROR_INVALID_PARAMETER.
///Returns:
///    The <b>MsiSourceListEnumSources</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to read the specified source list. This does not indicate whether
///    a product or patch is found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl>
///    </td> <td width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The
///    provided buffer is not sufficient to contain the requested data. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%"> There are no more sources in the specified list
///    to enumerate. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A
///    source is enumerated successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PATCH</b></dt>
///    </dl> </td> <td width="60%"> The patch specified is not installed on the computer in the specified contexts.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The
///    product specified is not installed on the computer in the specified contexts. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> Unexpected internal failure. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiSourceListEnumSourcesW(const(wchar)* szProductCodeOrPatchCode, const(wchar)* szUserSid, 
                               MSIINSTALLCONTEXT dwContext, uint dwOptions, uint dwIndex, const(wchar)* szSource, 
                               uint* pcchSource);

///The <b>MsiSourceListEnumMediaDisks</b> function enumerates the list of disks registered for the media source for a
///patch or product.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns ERROR_INVALID_PARAMETER. This parameter cannot be <b>NULL</b>.
///    szUserSid = A string SID that specifies the user account that contains the product or patch. The SID is not validated or
///                resolved. An incorrect SID can return ERROR_UNKNOWN_PRODUCT or ERROR_UNKNOWN_PATCH. When referencing a machine
///                context, <i>szUserSID</i> must be <b>NULL</b> and <i>dwContext</i> must be MSIINSTALLCONTEXT_MACHINE. <table>
///                <tr> <th>Type of SID</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl>
///                <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> A <b>NULL</b> denotes the currently logged on user. When
///                referencing the current user account, <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be
///                MSIINSTALLCONTEXT_USERMANAGED or MSIINSTALLCONTEXT_USERUNMANAGED. </td> </tr> <tr> <td width="40%"><a
///                id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td
///                width="60%"> An enumeration for a specific user in the system. An example of a user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> <tr> <td width="40%"><a id="s-1-1-0"></a><a
///                id="S-1-1-0"></a><dl> <dt><b>s-1-1-0</b></dt> </dl> </td> <td width="60%"> The special SID string s-1-1-0
///                (everyone) specifies enumeration across all users in the system. </td> </tr> </table> <div
///                class="alert"><b>Note</b> The special SID string s-1-5-18 (system) cannot be used to enumerate products or
///                patches installed as per-machine. Setting the SID value to s-1-5-18 returns ERROR_INVALID_PARAMETER.</div> <div>
///                </div>
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value that specifies the meaning of <i>szProductCodeOrPatchCode</i>. <table> <tr>
///                <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSICODE_PRODUCT"></a><a
///                id="msicode_product"></a><dl> <dt><b>MSICODE_PRODUCT</b></dt> </dl> </td> <td width="60%">
///                <i>szProductCodeOrPatchCode</i> is a product code GUID. </td> </tr> <tr> <td width="40%"><a
///                id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl> <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%">
///                <i>szProductCodeOrPatchCode</i> is a patch code GUID. </td> </tr> </table>
///    dwIndex = The index of the source to retrieve. This parameter must be 0 (zero) for the first call to the
///              <b>MsiSourceListEnumMediaDisks</b> function, and then incremented for subsequent calls until the function returns
///              ERROR_NO_MORE_ITEMS.
///    pdwDiskId = On entry to <b>MsiSourceListEnumMediaDisks</b> this parameter provides a pointer to a <b>DWORD</b> to receive the
///                ID of the disk that is being enumerated. This parameter is optional.
///    szVolumeLabel = An output buffer that receives the volume label of the disk that is being enumerated. This buffer should be large
///                    enough to contain the information. If the buffer is too small, the function returns ERROR_MORE_DATA and sets
///                    *<i>pcchVolumeLabel</i> to the number of <b>TCHAR</b> in the value, not including the terminating NULL character.
///                    If <i>szVolumeLabel</i> and <i>pcchVolumeLabel</i> are both set to <b>NULL</b>, the function returns
///                    ERROR_SUCCESS if the value exists, without retrieving the value.
///    pcchVolumeLabel = A pointer to a variable that specifies the number of <b>TCHAR</b> in the <i>szVolumeLabel</i> buffer. When the
///                      function returns, this parameter is the number of <b>TCHAR</b> in the received value, not including the
///                      terminating null character. This parameter can be set to <b>NULL</b> only if <i>szVolumeLabel</i> is also
///                      <b>NULL</b>, otherwise the function returns ERROR_INVALID_PARAMETER.
///    szDiskPrompt = An output buffer that receives the disk prompt of the disk that is being enumerated. This buffer should be large
///                   enough to contain the information. If the buffer is too small, the function returns ERROR_MORE_DATA and sets
///                   *<i>pcchDiskPrompt</i> to the number of <b>TCHAR</b> in the value, not including the terminating NULL character.
///                   If the <i>szDiskPrompt</i> is set to <b>NULL</b> and <i>pcchDiskPrompt</i> is set to a valid pointer, the
///                   function returns ERROR_SUCCESS and sets *<i>pcchDiskPrompt</i> to the number of <b>TCHAR</b> in the value, not
///                   including the terminating NULL character. The function can then be called again to retrieve the value, with
///                   <i>szDiskPrompt</i> buffer large enough to contain *<i>pcchDiskPrompt</i> + 1 characters. If <i>szDiskPrompt</i>
///                   and <i>pcchDiskPrompt</i> are both set to <b>NULL</b>, the function returns ERROR_SUCCESS if the value exists,
///                   without retrieving the value.
///    pcchDiskPrompt = A pointer to a variable that specifies the number of <b>TCHAR</b> in the <i>szDiskPrompt</i> buffer. When the
///                     function returns, this parameter is set to the size of the requested value whether or not the function copies the
///                     value into the specified buffer. The size is returned as the number of <b>TCHAR</b> in the requested value, not
///                     including the terminating null character. This parameter can be set to <b>NULL</b> only if <i>szDiskPrompt</i> is
///                     also <b>NULL</b>, otherwise the function returns ERROR_INVALID_PARAMETER.
///Returns:
///    The <b>MsiSourceListEnumMediaDisks</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to read the specified media source or the specified product or
///    patch. This does not indicate whether a media source, product, or patch is found. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is
///    corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> An invalid parameter is passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%"> There are no more disks registered for this
///    product or patch. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td
///    width="60%"> The value is enumerated successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The patch is not found. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product is not found.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The buffer
///    that is provided is too small to contain the requested information. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> Unexpected internal failure. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiSourceListEnumMediaDisksA(const(char)* szProductCodeOrPatchCode, const(char)* szUserSid, 
                                  MSIINSTALLCONTEXT dwContext, uint dwOptions, uint dwIndex, uint* pdwDiskId, 
                                  const(char)* szVolumeLabel, uint* pcchVolumeLabel, const(char)* szDiskPrompt, 
                                  uint* pcchDiskPrompt);

///The <b>MsiSourceListEnumMediaDisks</b> function enumerates the list of disks registered for the media source for a
///patch or product.
///Params:
///    szProductCodeOrPatchCode = The ProductCode or patch GUID of the product or patch. Use a null-terminated string. If the string is longer than
///                               39 characters, the function fails and returns ERROR_INVALID_PARAMETER. This parameter cannot be <b>NULL</b>.
///    szUserSid = A string SID that specifies the user account that contains the product or patch. The SID is not validated or
///                resolved. An incorrect SID can return ERROR_UNKNOWN_PRODUCT or ERROR_UNKNOWN_PATCH. When referencing a machine
///                context, <i>szUserSID</i> must be <b>NULL</b> and <i>dwContext</i> must be MSIINSTALLCONTEXT_MACHINE. <table>
///                <tr> <th>Type of SID</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NULL"></a><a id="null"></a><dl>
///                <dt><b><b>NULL</b></b></dt> </dl> </td> <td width="60%"> A <b>NULL</b> denotes the currently logged on user. When
///                referencing the current user account, <i>szUserSID</i> can be <b>NULL</b> and <i>dwContext</i> can be
///                MSIINSTALLCONTEXT_USERMANAGED or MSIINSTALLCONTEXT_USERUNMANAGED. </td> </tr> <tr> <td width="40%"><a
///                id="User_SID"></a><a id="user_sid"></a><a id="USER_SID"></a><dl> <dt><b>User SID</b></dt> </dl> </td> <td
///                width="60%"> An enumeration for a specific user in the system. An example of a user SID is
///                "S-1-3-64-2415071341-1358098788-3127455600-2561". </td> </tr> <tr> <td width="40%"><a id="s-1-1-0"></a><a
///                id="S-1-1-0"></a><dl> <dt><b>s-1-1-0</b></dt> </dl> </td> <td width="60%"> The special SID string s-1-1-0
///                (everyone) specifies enumeration across all users in the system. </td> </tr> </table> <div
///                class="alert"><b>Note</b> The special SID string s-1-5-18 (system) cannot be used to enumerate products or
///                patches installed as per-machine. Setting the SID value to s-1-5-18 returns ERROR_INVALID_PARAMETER.</div> <div>
///                </div>
///    dwContext = This parameter specifies the context of the product or patch instance. This parameter can contain one of the
///                following values. <table> <tr> <th>Type of context</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSIINSTALLCONTEXT_USERMANAGED"></a><a id="msiinstallcontext_usermanaged"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_USERMANAGED</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists
///                in the per-user-managed context. </td> </tr> <tr> <td width="40%"><a id="MSIINSTALLCONTEXT_USERUNMANAGED"></a><a
///                id="msiinstallcontext_userunmanaged"></a><dl> <dt><b>MSIINSTALLCONTEXT_USERUNMANAGED</b></dt> </dl> </td> <td
///                width="60%"> The product or patch instance exists in the per-user-unmanaged context. </td> </tr> <tr> <td
///                width="40%"><a id="MSIINSTALLCONTEXT_MACHINE"></a><a id="msiinstallcontext_machine"></a><dl>
///                <dt><b>MSIINSTALLCONTEXT_MACHINE</b></dt> </dl> </td> <td width="60%"> The product or patch instance exists in
///                the per-machine context. </td> </tr> </table>
///    dwOptions = The <i>dwOptions</i> value that specifies the meaning of <i>szProductCodeOrPatchCode</i>. <table> <tr>
///                <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSICODE_PRODUCT"></a><a
///                id="msicode_product"></a><dl> <dt><b>MSICODE_PRODUCT</b></dt> </dl> </td> <td width="60%">
///                <i>szProductCodeOrPatchCode</i> is a product code GUID. </td> </tr> <tr> <td width="40%"><a
///                id="MSICODE_PATCH"></a><a id="msicode_patch"></a><dl> <dt><b>MSICODE_PATCH</b></dt> </dl> </td> <td width="60%">
///                <i>szProductCodeOrPatchCode</i> is a patch code GUID. </td> </tr> </table>
///    dwIndex = The index of the source to retrieve. This parameter must be 0 (zero) for the first call to the
///              <b>MsiSourceListEnumMediaDisks</b> function, and then incremented for subsequent calls until the function returns
///              ERROR_NO_MORE_ITEMS.
///    pdwDiskId = On entry to <b>MsiSourceListEnumMediaDisks</b> this parameter provides a pointer to a <b>DWORD</b> to receive the
///                ID of the disk that is being enumerated. This parameter is optional.
///    szVolumeLabel = An output buffer that receives the volume label of the disk that is being enumerated. This buffer should be large
///                    enough to contain the information. If the buffer is too small, the function returns ERROR_MORE_DATA and sets
///                    *<i>pcchVolumeLabel</i> to the number of <b>TCHAR</b> in the value, not including the terminating NULL character.
///                    If <i>szVolumeLabel</i> and <i>pcchVolumeLabel</i> are both set to <b>NULL</b>, the function returns
///                    ERROR_SUCCESS if the value exists, without retrieving the value.
///    pcchVolumeLabel = A pointer to a variable that specifies the number of <b>TCHAR</b> in the <i>szVolumeLabel</i> buffer. When the
///                      function returns, this parameter is the number of <b>TCHAR</b> in the received value, not including the
///                      terminating null character. This parameter can be set to <b>NULL</b> only if <i>szVolumeLabel</i> is also
///                      <b>NULL</b>, otherwise the function returns ERROR_INVALID_PARAMETER.
///    szDiskPrompt = An output buffer that receives the disk prompt of the disk that is being enumerated. This buffer should be large
///                   enough to contain the information. If the buffer is too small, the function returns ERROR_MORE_DATA and sets
///                   *<i>pcchDiskPrompt</i> to the number of <b>TCHAR</b> in the value, not including the terminating NULL character.
///                   If the <i>szDiskPrompt</i> is set to <b>NULL</b> and <i>pcchDiskPrompt</i> is set to a valid pointer, the
///                   function returns ERROR_SUCCESS and sets *<i>pcchDiskPrompt</i> to the number of <b>TCHAR</b> in the value, not
///                   including the terminating NULL character. The function can then be called again to retrieve the value, with
///                   <i>szDiskPrompt</i> buffer large enough to contain *<i>pcchDiskPrompt</i> + 1 characters. If <i>szDiskPrompt</i>
///                   and <i>pcchDiskPrompt</i> are both set to <b>NULL</b>, the function returns ERROR_SUCCESS if the value exists,
///                   without retrieving the value.
///    pcchDiskPrompt = A pointer to a variable that specifies the number of <b>TCHAR</b> in the <i>szDiskPrompt</i> buffer. When the
///                     function returns, this parameter is set to the size of the requested value whether or not the function copies the
///                     value into the specified buffer. The size is returned as the number of <b>TCHAR</b> in the requested value, not
///                     including the terminating null character. This parameter can be set to <b>NULL</b> only if <i>szDiskPrompt</i> is
///                     also <b>NULL</b>, otherwise the function returns ERROR_INVALID_PARAMETER.
///Returns:
///    The <b>MsiSourceListEnumMediaDisks</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user does not have the ability to read the specified media source or the specified product or
///    patch. This does not indicate whether a media source, product, or patch is found. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration data is
///    corrupt. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> An invalid parameter is passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_MORE_ITEMS</b></dt> </dl> </td> <td width="60%"> There are no more disks registered for this
///    product or patch. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td
///    width="60%"> The value is enumerated successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PATCH</b></dt> </dl> </td> <td width="60%"> The patch is not found. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product is not found.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td width="60%"> The buffer
///    that is provided is too small to contain the requested information. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> Unexpected internal failure. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiSourceListEnumMediaDisksW(const(wchar)* szProductCodeOrPatchCode, const(wchar)* szUserSid, 
                                  MSIINSTALLCONTEXT dwContext, uint dwOptions, uint dwIndex, uint* pdwDiskId, 
                                  const(wchar)* szVolumeLabel, uint* pcchVolumeLabel, const(wchar)* szDiskPrompt, 
                                  uint* pcchDiskPrompt);

///The <b>MsiGetFileVersion</b> returns the version string and language string in the format that the installer expects
///to find them in the database. If you want only version information, set <i>lpLangBuf</i> and <i>pcchLangBuf</i> to 0
///(zero). If you just want language information, set <i>lpVersionBuf</i> and <i>pcchVersionBuf</i> to 0 (zero).
///Params:
///    szFilePath = Specifies the path to the file.
///    lpVersionBuf = Returns the file version. Set to 0 for language information only.
///    pcchVersionBuf = In and out buffer count as the number of <b>TCHAR</b>. Set to 0 (zero) for language information only. On input,
///                     this is the full size of the buffer, including a space for a terminating null character. If the buffer passed in
///                     is too small, the count returned does not include the terminating null character.
///    lpLangBuf = Returns the file language. Set to 0 (zero) for version information only.
///    pcchLangBuf = In and out buffer count as the number of <b>TCHAR</b>. Set to 0 (zero) for version information only. On input,
///                  this is the full size of the buffer, including a space for a terminating null character. If the buffer passed in
///                  is too small, the count returned does not include the terminating null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> Successful completion. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> File does not exist. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> File cannot be opened to get
///    version information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FILE_INVALID</b></dt> </dl> </td> <td
///    width="60%"> File does not contain version information. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_DATA</b></dt> </dl> </td> <td width="60%"> The version information is invalid. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unexpected error. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiGetFileVersionA(const(char)* szFilePath, const(char)* lpVersionBuf, uint* pcchVersionBuf, 
                        const(char)* lpLangBuf, uint* pcchLangBuf);

///The <b>MsiGetFileVersion</b> returns the version string and language string in the format that the installer expects
///to find them in the database. If you want only version information, set <i>lpLangBuf</i> and <i>pcchLangBuf</i> to 0
///(zero). If you just want language information, set <i>lpVersionBuf</i> and <i>pcchVersionBuf</i> to 0 (zero).
///Params:
///    szFilePath = Specifies the path to the file.
///    lpVersionBuf = Returns the file version. Set to 0 for language information only.
///    pcchVersionBuf = In and out buffer count as the number of <b>TCHAR</b>. Set to 0 (zero) for language information only. On input,
///                     this is the full size of the buffer, including a space for a terminating null character. If the buffer passed in
///                     is too small, the count returned does not include the terminating null character.
///    lpLangBuf = Returns the file language. Set to 0 (zero) for version information only.
///    pcchLangBuf = In and out buffer count as the number of <b>TCHAR</b>. Set to 0 (zero) for version information only. On input,
///                  this is the full size of the buffer, including a space for a terminating null character. If the buffer passed in
///                  is too small, the count returned does not include the terminating null character.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> Successful completion. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> File does not exist. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> File cannot be opened to get
///    version information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FILE_INVALID</b></dt> </dl> </td> <td
///    width="60%"> File does not contain version information. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_DATA</b></dt> </dl> </td> <td width="60%"> The version information is invalid. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unexpected error. </td> </tr>
///    </table>
///    
@DllImport("msi")
uint MsiGetFileVersionW(const(wchar)* szFilePath, const(wchar)* lpVersionBuf, uint* pcchVersionBuf, 
                        const(wchar)* lpLangBuf, uint* pcchLangBuf);

///The <b>MsiGetFileHash</b> function takes the path to a file and returns a 128-bit hash of that file. Authoring tools
///may use <b>MsiGetFileHash</b> to obtain the file hash needed to populate the MsiFileHash table. Windows Installer
///uses file hashing as a means to detect and eliminate unnecessary file copying. A file hash stored in the MsiFileHash
///table may be compared to a hash of an existing file on the user's computer.
///Params:
///    szFilePath = Path to file that is to be hashed.
///    dwOptions = The value in this column must be 0. This parameter is reserved for future use.
///    pHash = Pointer to the returned file hash information.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The file does not exist. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The file could not be opened
///    to get version information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
///    width="60%"> Unexpected error has occurred. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiGetFileHashA(const(char)* szFilePath, uint dwOptions, MSIFILEHASHINFO* pHash);

///The <b>MsiGetFileHash</b> function takes the path to a file and returns a 128-bit hash of that file. Authoring tools
///may use <b>MsiGetFileHash</b> to obtain the file hash needed to populate the MsiFileHash table. Windows Installer
///uses file hashing as a means to detect and eliminate unnecessary file copying. A file hash stored in the MsiFileHash
///table may be compared to a hash of an existing file on the user's computer.
///Params:
///    szFilePath = Path to file that is to be hashed.
///    dwOptions = The value in this column must be 0. This parameter is reserved for future use.
///    pHash = Pointer to the returned file hash information.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl>
///    </td> <td width="60%"> The function completed successfully. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The file does not exist. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The file could not be opened
///    to get version information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
///    width="60%"> Unexpected error has occurred. </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiGetFileHashW(const(wchar)* szFilePath, uint dwOptions, MSIFILEHASHINFO* pHash);

///The <b>MsiGetFileSignatureInformation</b> function takes the path to a file that has been digitally signed and
///returns the file's signer certificate and hash. <b>MsiGetFileSignatureInformation</b> may be called to obtain the
///signer certificate and hash needed to populate the MsiDigitalCertificate, MsiPatchCertificate, and
///MsiDigitalSignature tables. <b>Windows Installer 3.0 and later: </b>Beginning with Windows Installer 3.0, the Windows
///Installer can verify the digital signatures of patches (.msp files) by using the MsiPatchCertificate and
///MsiDigitalCertificate tables. For more information see Guidelines for Authoring Secure Installations and User Account
///Control (UAC) Patching. <b>Windows Installer 2.0: </b>Digital signatures of patches is not supported. Windows
///Installer 2.0 uses digital signatures as a means to detect corrupted resources, and can only verify the digital
///signatures of external cabinets, and only by the use of the MsiDigitalSignature and MsiDigitalCertificate tables.
///Params:
///    szSignedObjectPath = Pointer to a null-terminated string specifying the full path to the file that contains the digital signature.
///    dwFlags = Special error case flags. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="MSI_INVALID_HASH_IS_FATAL"></a><a id="msi_invalid_hash_is_fatal"></a><dl>
///              <dt><b>MSI_INVALID_HASH_IS_FATAL</b></dt> <dt>0x1</dt> </dl> </td> <td width="60%"> Without this flag set, and
///              when requesting only the certificate context, an invalid hash in the digital signature does not cause
///              <b>MsiGetFileSignatureInformation</b> to return a fatal error. To return a fatal error for an invalid hash, set
///              the MSI_INVALID_HASH_IS_FATAL flag. </td> </tr> </table>
///    ppcCertContext = Returned signer certificate context
///    pbHashData = Returned hash buffer. This parameter can be <b>NULL</b> if the hash data is not being requested.
///    pcbHashData = Pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pbHashData</i>
///                  parameter. This parameter cannot be <b>NULL</b> if <i>pbHashData</i> is non-<b>NULL</b>. If ERROR_MORE_DATA is
///                  returned, <i>pbHashData</i> gives the size of the buffer required to hold the hash data. If ERROR_SUCCESS is
///                  returned, it gives the number of bytes written to the hash buffer. The <i>pcbHashData</i> parameter is ignored if
///                  <i>pbHashData</i> is <b>NULL</b>.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS/S_OK</b></dt>
///    </dl> </td> <td width="60%"> Successful completion. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> Invalid parameter was specified. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> WinVerifyTrust is
///    not available on the system. <b>MsiGetFileSignatureInformation</b> requires the presence of the Wintrust.dll file
///    on the system. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td
///    width="60%"> A buffer is too small to hold the requested data. If ERROR_MORE_DATA is returned, <i>pcbHashData</i>
///    gives the size of the buffer required to hold the hash data. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>TRUST_E_NOSIGNATURE</b></dt> </dl> </td> <td width="60%"> File is not signed </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>TRUST_E_BAD_DIGEST</b></dt> </dl> </td> <td width="60%"> The file's current hash is
///    invalid according to the hash stored in the file's digital signature. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>CERT_E_REVOKED</b></dt> </dl> </td> <td width="60%"> The file's signer certificate has been revoked. The
///    file's digital signature is compromised. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>TRUST_E_SUBJECT_NOT_TRUSTED</b></dt> </dl> </td> <td width="60%"> The subject failed the specified
///    verification action. Most trust providers return a more detailed error code that describes the reason for the
///    failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TRUST_E_PROVIDER_UNKNOWN</b></dt> </dl> </td> <td
///    width="60%"> The trust provider is not recognized on this system. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>TRUST_E_ACTION_UNKNOWN</b></dt> </dl> </td> <td width="60%"> The trust provider does not support the
///    specified action. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TRUST_E_SUBJECT_FORM_UNKNOWN</b></dt> </dl> </td>
///    <td width="60%"> The trust provider does not support the form specified for the subject. </td> </tr> </table>
///    <div> </div> <b>MsiGetFileSignatureInformation</b> also returns all the Win32 error values mapped to their
///    equivalent <b>HRESULT</b> data type by <b>HRESULT_FROM_WIN32</b>.
///    
@DllImport("msi")
HRESULT MsiGetFileSignatureInformationA(const(char)* szSignedObjectPath, uint dwFlags, 
                                        CERT_CONTEXT** ppcCertContext, char* pbHashData, uint* pcbHashData);

///The <b>MsiGetFileSignatureInformation</b> function takes the path to a file that has been digitally signed and
///returns the file's signer certificate and hash. <b>MsiGetFileSignatureInformation</b> may be called to obtain the
///signer certificate and hash needed to populate the MsiDigitalCertificate, MsiPatchCertificate, and
///MsiDigitalSignature tables. <b>Windows Installer 3.0 and later: </b>Beginning with Windows Installer 3.0, the Windows
///Installer can verify the digital signatures of patches (.msp files) by using the MsiPatchCertificate and
///MsiDigitalCertificate tables. For more information see Guidelines for Authoring Secure Installations and User Account
///Control (UAC) Patching. <b>Windows Installer 2.0: </b>Digital signatures of patches is not supported. Windows
///Installer 2.0 uses digital signatures as a means to detect corrupted resources, and can only verify the digital
///signatures of external cabinets, and only by the use of the MsiDigitalSignature and MsiDigitalCertificate tables.
///Params:
///    szSignedObjectPath = Pointer to a null-terminated string specifying the full path to the file that contains the digital signature.
///    dwFlags = Special error case flags. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="MSI_INVALID_HASH_IS_FATAL"></a><a id="msi_invalid_hash_is_fatal"></a><dl>
///              <dt><b>MSI_INVALID_HASH_IS_FATAL</b></dt> <dt>0x1</dt> </dl> </td> <td width="60%"> Without this flag set, and
///              when requesting only the certificate context, an invalid hash in the digital signature does not cause
///              <b>MsiGetFileSignatureInformation</b> to return a fatal error. To return a fatal error for an invalid hash, set
///              the MSI_INVALID_HASH_IS_FATAL flag. </td> </tr> </table>
///    ppcCertContext = Returned signer certificate context
///    pbHashData = Returned hash buffer. This parameter can be <b>NULL</b> if the hash data is not being requested.
///    pcbHashData = Pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pbHashData</i>
///                  parameter. This parameter cannot be <b>NULL</b> if <i>pbHashData</i> is non-<b>NULL</b>. If ERROR_MORE_DATA is
///                  returned, <i>pbHashData</i> gives the size of the buffer required to hold the hash data. If ERROR_SUCCESS is
///                  returned, it gives the number of bytes written to the hash buffer. The <i>pcbHashData</i> parameter is ignored if
///                  <i>pbHashData</i> is <b>NULL</b>.
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS/S_OK</b></dt>
///    </dl> </td> <td width="60%"> Successful completion. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> Invalid parameter was specified. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> WinVerifyTrust is
///    not available on the system. <b>MsiGetFileSignatureInformation</b> requires the presence of the Wintrust.dll file
///    on the system. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td
///    width="60%"> A buffer is too small to hold the requested data. If ERROR_MORE_DATA is returned, <i>pcbHashData</i>
///    gives the size of the buffer required to hold the hash data. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>TRUST_E_NOSIGNATURE</b></dt> </dl> </td> <td width="60%"> File is not signed </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>TRUST_E_BAD_DIGEST</b></dt> </dl> </td> <td width="60%"> The file's current hash is
///    invalid according to the hash stored in the file's digital signature. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>CERT_E_REVOKED</b></dt> </dl> </td> <td width="60%"> The file's signer certificate has been revoked. The
///    file's digital signature is compromised. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>TRUST_E_SUBJECT_NOT_TRUSTED</b></dt> </dl> </td> <td width="60%"> The subject failed the specified
///    verification action. Most trust providers return a more detailed error code that describes the reason for the
///    failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TRUST_E_PROVIDER_UNKNOWN</b></dt> </dl> </td> <td
///    width="60%"> The trust provider is not recognized on this system. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>TRUST_E_ACTION_UNKNOWN</b></dt> </dl> </td> <td width="60%"> The trust provider does not support the
///    specified action. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TRUST_E_SUBJECT_FORM_UNKNOWN</b></dt> </dl> </td>
///    <td width="60%"> The trust provider does not support the form specified for the subject. </td> </tr> </table>
///    <div> </div> <b>MsiGetFileSignatureInformation</b> also returns all the Win32 error values mapped to their
///    equivalent <b>HRESULT</b> data type by <b>HRESULT_FROM_WIN32</b>.
///    
@DllImport("msi")
HRESULT MsiGetFileSignatureInformationW(const(wchar)* szSignedObjectPath, uint dwFlags, 
                                        CERT_CONTEXT** ppcCertContext, char* pbHashData, uint* pcbHashData);

///The <b>MsiGetShortcutTarget</b> function examines a shortcut and returns its product, feature name, and component if
///available.
///Params:
///    szShortcutPath = A null-terminated string specifying the full path to a shortcut.
///    szProductCode = A GUID for the product code of the shortcut. This string buffer must be 39 characters long. The first 38
///                    characters are for the GUID, and the last character is for the terminating null character. This parameter can be
///                    null.
///    szFeatureId = The feature name of the shortcut. The string buffer must be MAX_FEATURE_CHARS+1 characters long. This parameter
///                  can be null.
///    szComponentCode = A GUID of the component code. This string buffer must be 39 characters long. The first 38 characters are for the
///                      GUID, and the last character is for the terminating null character. This parameter can be null.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiGetShortcutTargetA(const(char)* szShortcutPath, const(char)* szProductCode, const(char)* szFeatureId, 
                           const(char)* szComponentCode);

///The <b>MsiGetShortcutTarget</b> function examines a shortcut and returns its product, feature name, and component if
///available.
///Params:
///    szShortcutPath = A null-terminated string specifying the full path to a shortcut.
///    szProductCode = A GUID for the product code of the shortcut. This string buffer must be 39 characters long. The first 38
///                    characters are for the GUID, and the last character is for the terminating null character. This parameter can be
///                    null.
///    szFeatureId = The feature name of the shortcut. The string buffer must be MAX_FEATURE_CHARS+1 characters long. This parameter
///                  can be null.
///    szComponentCode = A GUID of the component code. This string buffer must be 39 characters long. The first 38 characters are for the
///                      GUID, and the last character is for the terminating null character. This parameter can be null.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiGetShortcutTargetW(const(wchar)* szShortcutPath, const(wchar)* szProductCode, const(wchar)* szFeatureId, 
                           const(wchar)* szComponentCode);

///The <b>MsiIsProductElevated</b> function returns whether or not the product is managed. Only applications that
///require elevated privileges for installation and being installed through advertisement are considered managed, which
///means that an application installed per-machine is always considered managed. An application that is installed
///per-user is only considered managed if it is advertised by a local system process that is impersonating the user. For
///more information, see Advertising a Per-User Application to be Installed with Elevated Privileges.
///<b>MsiIsProductElevated</b> verifies that the local system owns the product registry data. The function does not
///refer to account policies such as AlwaysInstallElevated.
///Params:
///    szProduct = The full product code GUID of the product. This parameter is required and cannot be <b>NULL</b> or empty.
///    pfElevated = A pointer to a BOOL for the result. This parameter cannot be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is ERROR_SUCCESS, and <i>pfElevated</i> is set to <b>TRUE</b> if the
///    product is a managed application. If the function fails, the return value is one of the error codes identified in
///    the following table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product is not currently known. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    argument is passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration information for the
///    product is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> The function failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> The function is not available for a
///    specific platform. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiIsProductElevatedA(const(char)* szProduct, int* pfElevated);

///The <b>MsiIsProductElevated</b> function returns whether or not the product is managed. Only applications that
///require elevated privileges for installation and being installed through advertisement are considered managed, which
///means that an application installed per-machine is always considered managed. An application that is installed
///per-user is only considered managed if it is advertised by a local system process that is impersonating the user. For
///more information, see Advertising a Per-User Application to be Installed with Elevated Privileges.
///<b>MsiIsProductElevated</b> verifies that the local system owns the product registry data. The function does not
///refer to account policies such as AlwaysInstallElevated.
///Params:
///    szProduct = The full product code GUID of the product. This parameter is required and cannot be <b>NULL</b> or empty.
///    pfElevated = A pointer to a BOOL for the result. This parameter cannot be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is ERROR_SUCCESS, and <i>pfElevated</i> is set to <b>TRUE</b> if the
///    product is a managed application. If the function fails, the return value is one of the error codes identified in
///    the following table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_UNKNOWN_PRODUCT</b></dt> </dl> </td> <td width="60%"> The product is not currently known. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    argument is passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BAD_CONFIGURATION</b></dt> </dl> </td> <td width="60%"> The configuration information for the
///    product is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> The function failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt> </dl> </td> <td width="60%"> The function is not available for a
///    specific platform. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiIsProductElevatedW(const(wchar)* szProduct, int* pfElevated);

///The <b>MsiNotifySidChange</b> function notifies and updates the Windows Installer internal information with changes
///to user SIDs.
///Params:
///    pOldSid = Null-terminated string that specifies the string value of the previous security identifier(SID).
///    pNewSid = Null-terminated string that specifies the string value of the new security identifier(SID).
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. This error returned if any of the parameters is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory was
///    available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> Internal failure during execution. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiNotifySidChangeA(const(char)* pOldSid, const(char)* pNewSid);

///The <b>MsiNotifySidChange</b> function notifies and updates the Windows Installer internal information with changes
///to user SIDs.
///Params:
///    pOldSid = Null-terminated string that specifies the string value of the previous security identifier(SID).
///    pNewSid = Null-terminated string that specifies the string value of the new security identifier(SID).
///Returns:
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. This error returned if any of the parameters is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory was
///    available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> Internal failure during execution. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiNotifySidChangeW(const(wchar)* pOldSid, const(wchar)* pNewSid);

///The <b>MsiBeginTransaction</b> function starts transaction processing of a multiple-package installation and returns
///an identifier for the transaction. The MsiEndTransaction function ends the transaction. <b>Windows Installer 4.0 and
///earlier: </b>Not supported. This function is available beginning with Windows Installer 4.5.
///Params:
///    szName = Name of the multiple-package installation.
///    dwTransactionAttributes = Attributes of the multiple-package installation. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                              width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> When 0 or no value is set it Windows Installer closes
///                              the UI from the previous installation. </td> </tr> <tr> <td width="40%"> <dl>
///                              <dt>MSITRANSACTION_CHAIN_EMBEDDEDUI</dt> </dl> </td> <td width="60%"> Set this attribute to request that the
///                              Windows Installer not shutdown the embedded UI until the transaction is complete. </td> </tr> </table>
///    phTransactionHandle = Transaction ID is a <b>MSIHANDLE</b> value that identifies the transaction. Only one process can own a
///                          transaction at a time.
///    phChangeOfOwnerEvent = This parameter returns a handle to an event that is set when the MsiJoinTransaction function changes the owner of
///                           the transaction to a new owner. The current owner can use this to determine when ownership of the transaction has
///                           changed. Leaving a transaction without an owner will roll back the transaction.
///Returns:
///    The <b>MsiBeginTransaction</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td
///    width="60%"> The installation service could not be accessed. This function requires the Windows Installer
///    service. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_ALREADY_RUNNING</b></dt> </dl> </td> <td
///    width="60%"> Only one transaction can be open on a system at a time. The function returns this error if called
///    while another transaction is running. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ROLLBACK_DISABLED</b></dt> </dl> </td> <td
///    width="60%"> Rollback Installations have been disabled by the DISABLEROLLBACK property or DisableRollback policy.
///    </td> </tr> </table>
///    
@DllImport("msi")
uint MsiBeginTransactionA(const(char)* szName, uint dwTransactionAttributes, uint* phTransactionHandle, 
                          HANDLE* phChangeOfOwnerEvent);

///The <b>MsiBeginTransaction</b> function starts transaction processing of a multiple-package installation and returns
///an identifier for the transaction. The MsiEndTransaction function ends the transaction. <b>Windows Installer 4.0 and
///earlier: </b>Not supported. This function is available beginning with Windows Installer 4.5.
///Params:
///    szName = Name of the multiple-package installation.
///    dwTransactionAttributes = Attributes of the multiple-package installation. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                              width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> When 0 or no value is set it Windows Installer closes
///                              the UI from the previous installation. </td> </tr> <tr> <td width="40%"> <dl>
///                              <dt>MSITRANSACTION_CHAIN_EMBEDDEDUI</dt> </dl> </td> <td width="60%"> Set this attribute to request that the
///                              Windows Installer not shutdown the embedded UI until the transaction is complete. </td> </tr> </table>
///    phTransactionHandle = Transaction ID is a <b>MSIHANDLE</b> value that identifies the transaction. Only one process can own a
///                          transaction at a time.
///    phChangeOfOwnerEvent = This parameter returns a handle to an event that is set when the MsiJoinTransaction function changes the owner of
///                           the transaction to a new owner. The current owner can use this to determine when ownership of the transaction has
///                           changed. Leaving a transaction without an owner will roll back the transaction.
///Returns:
///    The <b>MsiBeginTransaction</b> function returns the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_SERVICE_FAILURE</b></dt> </dl> </td> <td
///    width="60%"> The installation service could not be accessed. This function requires the Windows Installer
///    service. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_ALREADY_RUNNING</b></dt> </dl> </td> <td
///    width="60%"> Only one transaction can be open on a system at a time. The function returns this error if called
///    while another transaction is running. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter is passed to the
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ROLLBACK_DISABLED</b></dt> </dl> </td> <td
///    width="60%"> Rollback Installations have been disabled by the DISABLEROLLBACK property or DisableRollback policy.
///    </td> </tr> </table>
///    
@DllImport("msi")
uint MsiBeginTransactionW(const(wchar)* szName, uint dwTransactionAttributes, uint* phTransactionHandle, 
                          HANDLE* phChangeOfOwnerEvent);

///The <b>MsiEndTransaction</b> function can commit or roll back all the installations belonging to the transaction
///opened by the MsiBeginTransaction function. This function should be called by the current owner of the transaction.
///<b>Windows Installer 4.0 and earlier: </b>Not supported. This function is available beginning with Windows Installer
///4.5.
///Params:
///    dwTransactionState = The value of this parameter determines whether the installer commits or rolls back all the installations
///                         belonging to the transaction. The value can be one of the following. <table> <tr> <th>Value</th> <th>Meaning</th>
///                         </tr> <tr> <td width="40%"> <dl> <dt>MSITRANSACTIONSTATE_ROLLBACK</dt> </dl> </td> <td width="60%"> Performs a
///                         Rollback Installation to undo changes to the system belonging to the transaction opened by the
///                         MsiBeginTransaction function. </td> </tr> <tr> <td width="40%"> <dl> <dt>MSITRANSACTIONSTATE_COMMIT</dt> </dl>
///                         </td> <td width="60%"> Commits all changes to the system belonging to the transaction. Runs any Commit Custom
///                         Actions and commits to the system any changes to Win32 or common language runtime assemblies. Deletes the
///                         rollback script, and after using this option, the transaction's changes can no longer be undone with a Rollback
///                         Installation. </td> </tr> </table>
///Returns:
///    The <b>MsiEndTransaction</b> function returns the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> A transaction
///    can be ended only by the current owner. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_FAILURE</b></dt> </dl> </td> <td width="60%"> An installation belonging to the transaction
///    could not be completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSTALL_ALREADY_RUNNING</b></dt>
///    </dl> </td> <td width="60%"> An installation belonging to the transaction is still in progress. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_ROLLBACK_DISABLED</b></dt> </dl> </td> <td width="60%"> An installation
///    belonging to the transaction did not complete. During the installation, the DisableRollback action disabled
///    rollback installations of the package. The installer rolls back the installation up to the point where rollback
///    was disabled, and the function returns this error. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiEndTransaction(uint dwTransactionState);

///The <b>MsiJoinTransaction</b> function requests that the Windows Installer make the current process the owner of the
///transaction installing the multiple-package installation. <b>Windows Installer 4.0 and earlier: </b>Not supported.
///This function is available beginning with Windows Installer 4.5.
///Params:
///    hTransactionHandle = The transaction ID, which identifies the transaction and is the identifier returned by the MsiBeginTransaction
///                         function.
///    dwTransactionAttributes = Attributes of the multiple-package installation. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                              width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> When 0 or no value is set, Windows Installer closes the
///                              UI from the previous installation. </td> </tr> <tr> <td width="40%"> <dl>
///                              <dt>MSITRANSACTION_CHAIN_EMBEDDEDUI</dt> </dl> </td> <td width="60%"> Set this attribute to request that the
///                              Windows Installer not shutdown the embedded UI until the transaction is complete. </td> </tr> <tr> <td
///                              width="40%"> <dl> <dt>MSITRANSACTION_JOIN_EXISTING_EMBEDDEDUI</dt> </dl> </td> <td width="60%"> Set this
///                              attribute to request that the Windows Installer transfer the embedded UI from the original installation. If the
///                              original installation has no embedded UI, setting this attribute does nothing. </td> </tr> </table>
///    phChangeOfOwnerEvent = This parameter returns a handle to an event that is set when the <b>MsiJoinTransaction</b> function changes the
///                           owner of the transaction to a new owner. The current owner can use this to determine when ownership of the
///                           transaction has changed. Leaving a transaction without an owner will roll back the transaction.
///Returns:
///    The <b>MsiJoinTransaction</b> function can return the following values. <table> <tr> <th>Value</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td
///    width="60%"> The user that owns the transaction and the user that joins the transaction are not the same. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> A parameter
///    that is not valid is passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSTALL_ALREADY_RUNNING</b></dt> </dl> </td> <td width="60%"> The owner cannot be changed while an
///    active installation is in progress. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_HANDLE_STATE</b></dt> </dl> </td> <td width="60%"> The transaction ID provided is not valid.
///    </td> </tr> </table>
///    
@DllImport("msi")
uint MsiJoinTransaction(uint hTransactionHandle, uint dwTransactionAttributes, HANDLE* phChangeOfOwnerEvent);

///The <b>MsiDatabaseOpenView</b> function prepares a database query and creates a view object. This function returns a
///handle that should be closed using MsiCloseHandle.
///Params:
///    hDatabase = Handle to the database to which you want to open a view object. You can get the handle as described in Obtaining
///                a Database Handle.
///    szQuery = Specifies a SQL query string for querying the database. For correct syntax, see SQL Syntax.
///    phView = Pointer to a handle for the returned view.
///Returns:
///    The <b>MsiDatabaseOpenView</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiDatabaseOpenViewA(uint hDatabase, const(char)* szQuery, uint* phView);

///The <b>MsiDatabaseOpenView</b> function prepares a database query and creates a view object. This function returns a
///handle that should be closed using MsiCloseHandle.
///Params:
///    hDatabase = Handle to the database to which you want to open a view object. You can get the handle as described in Obtaining
///                a Database Handle.
///    szQuery = Specifies a SQL query string for querying the database. For correct syntax, see SQL Syntax.
///    phView = Pointer to a handle for the returned view.
///Returns:
///    The <b>MsiDatabaseOpenView</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiDatabaseOpenViewW(uint hDatabase, const(wchar)* szQuery, uint* phView);

///The <b>MsiViewGetError</b> function returns the error that occurred in the MsiViewModify function.
///Params:
///    hView = Handle to the view.
///    szColumnNameBuffer = Pointer to the buffer that receives the null-terminated column name. Do not attempt to determine the size of the
///                         buffer by passing in a null (value=0) for <i>szColumnName</i>. You can get the size of the buffer by passing in
///                         an empty string (for example ""). The function then returns MSIDBERROR_MOREDATA and <i>pcchBuf</i> contains the
///                         required buffer size in TCHARs, not including the terminating null character. On return of MSIDBERROR_NOERROR,
///                         <i>pcchBuf</i> contains the number of TCHARs written to the buffer, not including the terminating null character.
///                         This parameter is an empty string if there are no errors.
///    pcchBuf = Pointer to the variable that specifies the size, in TCHARs, of the buffer pointed to by the variable
///              <i>szColumnNameBuffer</i>. When the function returns MSIDBERROR_NOERROR, this variable contains the size of the
///              data copied to <i>szColumnNameBuffer</i>, not including the terminating null character. If
///              <i>szColumnNameBuffer</i> is not large enough, the function returns MSIDBERROR_MOREDATA and stores the required
///              size, not including the terminating null character, in the variable pointed to by <i>pcchBuf</i>.
///Returns:
///    This function returns one of the following values. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>MSIDBERROR_INVALIDARG</b></dt> </dl> </td> <td width="60%"> An argument was invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_MOREDATA</b></dt> </dl> </td> <td width="60%"> The
///    buffer was too small to receive data. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_FUNCTIONERROR</b></dt> </dl> </td> <td width="60%"> The function failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>MSIDBERROR_NOERROR</b></dt> </dl> </td> <td width="60%"> The function completed
///    successfully with no errors. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_DUPLICATEKEY</b></dt> </dl>
///    </td> <td width="60%"> The new record duplicates primary keys of the existing record in a table. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>MSIDBERROR_REQUIRED</b></dt> </dl> </td> <td width="60%"> There are no null values
///    allowed; or the column is about to be deleted, but is referenced by another row. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>MSIDBERROR_BADLINK</b></dt> </dl> </td> <td width="60%"> The corresponding record in a
///    foreign table was not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_OVERFLOW</b></dt> </dl>
///    </td> <td width="60%"> The data is greater than the maximum value allowed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_UNDERFLOW</b></dt> </dl> </td> <td width="60%"> The data is less than the minimum value
///    allowed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_NOTINSET</b></dt> </dl> </td> <td width="60%">
///    The data is not a member of the values permitted in the set. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADVERSION</b></dt> </dl> </td> <td width="60%"> An invalid version string was supplied. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADCASE</b></dt> </dl> </td> <td width="60%"> The case was
///    invalid. The case must be all uppercase or all lowercase. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADGUID</b></dt> </dl> </td> <td width="60%"> An invalid GUID was supplied. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>MSIDBERROR_BADWILDCARD</b></dt> </dl> </td> <td width="60%"> An invalid wildcard
///    file name was supplied, or the use of wildcards was invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADIDENTIFIER</b></dt> </dl> </td> <td width="60%"> An invalid identifier was supplied. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADLANGUAGE</b></dt> </dl> </td> <td width="60%"> Invalid
///    language IDs were supplied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADFILENAME</b></dt> </dl>
///    </td> <td width="60%"> An invalid file name was supplied. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADPATH</b></dt> </dl> </td> <td width="60%"> An invalid path was supplied. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>MSIDBERROR_BADCONDITION</b></dt> </dl> </td> <td width="60%"> An invalid conditional
///    statement was supplied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADFORMATTED</b></dt> </dl>
///    </td> <td width="60%"> An invalid format string was supplied. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADTEMPLATE</b></dt> </dl> </td> <td width="60%"> An invalid template string was supplied.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADDEFAULTDIR</b></dt> </dl> </td> <td width="60%"> An
///    invalid string was supplied in the DefaultDir column of the Directory table. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>MSIDBERROR_BADREGPATH</b></dt> </dl> </td> <td width="60%"> An invalid registry path string was
///    supplied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADCUSTOMSOURCE</b></dt> </dl> </td> <td
///    width="60%"> An invalid string was supplied in the CustomSource column of the CustomAction table. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADPROPERTY</b></dt> </dl> </td> <td width="60%"> An invalid
///    property string was supplied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_MISSINGDATA</b></dt> </dl>
///    </td> <td width="60%"> The _Validation table is missing a reference to a column. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>MSIDBERROR_BADCATEGORY</b></dt> </dl> </td> <td width="60%"> The category column of the
///    _Validation table for the column is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADCABINET</b></dt> </dl> </td> <td width="60%"> An invalid cabinet name was supplied. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADKEYTABLE</b></dt> </dl> </td> <td width="60%"> The table in
///    the Keytable column of the _Validation table was not found or loaded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADMAXMINVALUES</b></dt> </dl> </td> <td width="60%"> The value in the MaxValue column of the
///    _Validation table is less than the value in the MinValue column. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADSHORTCUT</b></dt> </dl> </td> <td width="60%"> An invalid shortcut target name was supplied.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_STRINGOVERFLOW</b></dt> </dl> </td> <td width="60%"> The
///    string is too long for the length specified by the column definition. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADLOCALIZEATTRIB</b></dt> </dl> </td> <td width="60%"> An invalid localization attribute was
///    supplied. (Primary keys cannot be localized.) </td> </tr> </table> <div> </div> Note that in low memory
///    situations, this function can raise a STATUS_NO_MEMORY exception.
///    
@DllImport("msi")
MSIDBERROR MsiViewGetErrorA(uint hView, const(char)* szColumnNameBuffer, uint* pcchBuf);

///The <b>MsiViewGetError</b> function returns the error that occurred in the MsiViewModify function.
///Params:
///    hView = Handle to the view.
///    szColumnNameBuffer = Pointer to the buffer that receives the null-terminated column name. Do not attempt to determine the size of the
///                         buffer by passing in a null (value=0) for <i>szColumnName</i>. You can get the size of the buffer by passing in
///                         an empty string (for example ""). The function then returns MSIDBERROR_MOREDATA and <i>pcchBuf</i> contains the
///                         required buffer size in TCHARs, not including the terminating null character. On return of MSIDBERROR_NOERROR,
///                         <i>pcchBuf</i> contains the number of TCHARs written to the buffer, not including the terminating null character.
///                         This parameter is an empty string if there are no errors.
///    pcchBuf = Pointer to the variable that specifies the size, in TCHARs, of the buffer pointed to by the variable
///              <i>szColumnNameBuffer</i>. When the function returns MSIDBERROR_NOERROR, this variable contains the size of the
///              data copied to <i>szColumnNameBuffer</i>, not including the terminating null character. If
///              <i>szColumnNameBuffer</i> is not large enough, the function returns MSIDBERROR_MOREDATA and stores the required
///              size, not including the terminating null character, in the variable pointed to by <i>pcchBuf</i>.
///Returns:
///    This function returns one of the following values. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>MSIDBERROR_INVALIDARG</b></dt> </dl> </td> <td width="60%"> An argument was invalid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_MOREDATA</b></dt> </dl> </td> <td width="60%"> The
///    buffer was too small to receive data. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_FUNCTIONERROR</b></dt> </dl> </td> <td width="60%"> The function failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>MSIDBERROR_NOERROR</b></dt> </dl> </td> <td width="60%"> The function completed
///    successfully with no errors. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_DUPLICATEKEY</b></dt> </dl>
///    </td> <td width="60%"> The new record duplicates primary keys of the existing record in a table. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>MSIDBERROR_REQUIRED</b></dt> </dl> </td> <td width="60%"> There are no null values
///    allowed; or the column is about to be deleted, but is referenced by another row. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>MSIDBERROR_BADLINK</b></dt> </dl> </td> <td width="60%"> The corresponding record in a
///    foreign table was not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_OVERFLOW</b></dt> </dl>
///    </td> <td width="60%"> The data is greater than the maximum value allowed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_UNDERFLOW</b></dt> </dl> </td> <td width="60%"> The data is less than the minimum value
///    allowed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_NOTINSET</b></dt> </dl> </td> <td width="60%">
///    The data is not a member of the values permitted in the set. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADVERSION</b></dt> </dl> </td> <td width="60%"> An invalid version string was supplied. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADCASE</b></dt> </dl> </td> <td width="60%"> The case was
///    invalid. The case must be all uppercase or all lowercase. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADGUID</b></dt> </dl> </td> <td width="60%"> An invalid GUID was supplied. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>MSIDBERROR_BADWILDCARD</b></dt> </dl> </td> <td width="60%"> An invalid wildcard
///    file name was supplied, or the use of wildcards was invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADIDENTIFIER</b></dt> </dl> </td> <td width="60%"> An invalid identifier was supplied. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADLANGUAGE</b></dt> </dl> </td> <td width="60%"> Invalid
///    language IDs were supplied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADFILENAME</b></dt> </dl>
///    </td> <td width="60%"> An invalid file name was supplied. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADPATH</b></dt> </dl> </td> <td width="60%"> An invalid path was supplied. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>MSIDBERROR_BADCONDITION</b></dt> </dl> </td> <td width="60%"> An invalid conditional
///    statement was supplied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADFORMATTED</b></dt> </dl>
///    </td> <td width="60%"> An invalid format string was supplied. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADTEMPLATE</b></dt> </dl> </td> <td width="60%"> An invalid template string was supplied.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADDEFAULTDIR</b></dt> </dl> </td> <td width="60%"> An
///    invalid string was supplied in the DefaultDir column of the Directory table. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>MSIDBERROR_BADREGPATH</b></dt> </dl> </td> <td width="60%"> An invalid registry path string was
///    supplied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADCUSTOMSOURCE</b></dt> </dl> </td> <td
///    width="60%"> An invalid string was supplied in the CustomSource column of the CustomAction table. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADPROPERTY</b></dt> </dl> </td> <td width="60%"> An invalid
///    property string was supplied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_MISSINGDATA</b></dt> </dl>
///    </td> <td width="60%"> The _Validation table is missing a reference to a column. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>MSIDBERROR_BADCATEGORY</b></dt> </dl> </td> <td width="60%"> The category column of the
///    _Validation table for the column is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADCABINET</b></dt> </dl> </td> <td width="60%"> An invalid cabinet name was supplied. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_BADKEYTABLE</b></dt> </dl> </td> <td width="60%"> The table in
///    the Keytable column of the _Validation table was not found or loaded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADMAXMINVALUES</b></dt> </dl> </td> <td width="60%"> The value in the MaxValue column of the
///    _Validation table is less than the value in the MinValue column. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADSHORTCUT</b></dt> </dl> </td> <td width="60%"> An invalid shortcut target name was supplied.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>MSIDBERROR_STRINGOVERFLOW</b></dt> </dl> </td> <td width="60%"> The
///    string is too long for the length specified by the column definition. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>MSIDBERROR_BADLOCALIZEATTRIB</b></dt> </dl> </td> <td width="60%"> An invalid localization attribute was
///    supplied. (Primary keys cannot be localized.) </td> </tr> </table> <div> </div> Note that in low memory
///    situations, this function can raise a STATUS_NO_MEMORY exception.
///    
@DllImport("msi")
MSIDBERROR MsiViewGetErrorW(uint hView, const(wchar)* szColumnNameBuffer, uint* pcchBuf);

///The <b>MsiViewExecute</b> function executes a SQL view query and supplies any required parameters. The query uses the
///question mark token to represent parameters as described in SQL Syntax. The values of these parameters are passed in
///as the corresponding fields of a parameter record.
///Params:
///    hView = Handle to the view upon which to execute the query.
///    hRecord = Handle to a record that supplies the parameters. This parameter contains values to replace the parameter tokens
///              in the SQL query. It is optional, so <i>hRecord</i> can be zero. For a reference on syntax, see SQL Syntax.
///Returns:
///    Note that in low memory situations, this function can raise a STATUS_NO_MEMORY exception.
///    
@DllImport("msi")
uint MsiViewExecute(uint hView, uint hRecord);

///The <b>MsiViewFetch</b> function fetches the next sequential record from the view. This function returns a handle
///that should be closed using MsiCloseHandle.
///Params:
///    hView = Handle to the view to fetch from.
///    phRecord = Pointer to the handle for the fetched record.
///Returns:
///    Note that in low memory situations, this function can raise a STATUS_NO_MEMORY exception.
///    
@DllImport("msi")
uint MsiViewFetch(uint hView, uint* phRecord);

///The <b>MsiViewModify</b> function updates a fetched record.
///Params:
///    hView = Handle to a view.
///    eModifyMode = Specifies the modify mode. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIMODIFY_SEEK"></a><a id="msimodify_seek"></a><dl>
///                  <dt><b>MSIMODIFY_SEEK</b></dt> <dt>-1</dt> </dl> </td> <td width="60%"> Refreshes the information in the supplied
///                  record without changing the position in the result set and without affecting subsequent fetch operations. The
///                  record may then be used for subsequent Update, Delete, and Refresh. All primary key columns of the table must be
///                  in the query and the record must have at least as many fields as the query. Seek cannot be used with multi-table
///                  queries. This mode cannot be used with a view containing joins. See also the remarks. </td> </tr> <tr> <td
///                  width="40%"><a id="MSIMODIFY_REFRESH"></a><a id="msimodify_refresh"></a><dl> <dt><b>MSIMODIFY_REFRESH</b></dt>
///                  <dt>0</dt> </dl> </td> <td width="60%"> Refreshes the information in the record. Must first call MsiViewFetch
///                  with the same record. Fails for a deleted row. Works with read-write and read-only records. </td> </tr> <tr> <td
///                  width="40%"><a id="MSIMODIFY_INSERT"></a><a id="msimodify_insert"></a><dl> <dt><b>MSIMODIFY_INSERT</b></dt>
///                  <dt>1</dt> </dl> </td> <td width="60%"> Inserts a record. Fails if a row with the same primary keys exists. Fails
///                  with a read-only database. This mode cannot be used with a view containing joins. </td> </tr> <tr> <td
///                  width="40%"><a id="MSIMODIFY_UPDATE"></a><a id="msimodify_update"></a><dl> <dt><b>MSIMODIFY_UPDATE</b></dt>
///                  <dt>2</dt> </dl> </td> <td width="60%"> Updates an existing record. Nonprimary keys only. Must first call
///                  MsiViewFetch. Fails with a deleted record. Works only with read-write records. </td> </tr> <tr> <td
///                  width="40%"><a id="MSIMODIFY_ASSIGN"></a><a id="msimodify_assign"></a><dl> <dt><b>MSIMODIFY_ASSIGN</b></dt>
///                  <dt>3</dt> </dl> </td> <td width="60%"> Writes current data in the cursor to a table row. Updates record if the
///                  primary keys match an existing row and inserts if they do not match. Fails with a read-only database. This mode
///                  cannot be used with a view containing joins. </td> </tr> <tr> <td width="40%"><a id="MSIMODIFY_REPLACE"></a><a
///                  id="msimodify_replace"></a><dl> <dt><b>MSIMODIFY_REPLACE</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Updates
///                  or deletes and inserts a record into a table. Must first call MsiViewFetch with the same record. Updates record
///                  if the primary keys are unchanged. Deletes old row and inserts new if primary keys have changed. Fails with a
///                  read-only database. This mode cannot be used with a view containing joins. </td> </tr> <tr> <td width="40%"><a
///                  id="MSIMODIFY_MERGE"></a><a id="msimodify_merge"></a><dl> <dt><b>MSIMODIFY_MERGE</b></dt> <dt>5</dt> </dl> </td>
///                  <td width="60%"> Inserts or validates a record in a table. Inserts if primary keys do not match any row and
///                  validates if there is a match. Fails if the record does not match the data in the table. Fails if there is a
///                  record with a duplicate key that is not identical. Works only with read-write records. This mode cannot be used
///                  with a view containing joins. </td> </tr> <tr> <td width="40%"><a id="MSIMODIFY_DELETE"></a><a
///                  id="msimodify_delete"></a><dl> <dt><b>MSIMODIFY_DELETE</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> Remove a
///                  row from the table. You must first call the MsiViewFetch function with the same record. Fails if the row has been
///                  deleted. Works only with read-write records. This mode cannot be used with a view containing joins. </td> </tr>
///                  <tr> <td width="40%"><a id="MSIMODIFY_INSERT_TEMPORARY"></a><a id="msimodify_insert_temporary"></a><dl>
///                  <dt><b>MSIMODIFY_INSERT_TEMPORARY</b></dt> <dt>7</dt> </dl> </td> <td width="60%"> Inserts a temporary record.
///                  The information is not persistent. Fails if a row with the same primary key exists. Works only with read-write
///                  records. This mode cannot be used with a view containing joins. </td> </tr> <tr> <td width="40%"><a
///                  id="MSIMODIFY_VALIDATE"></a><a id="msimodify_validate"></a><dl> <dt><b>MSIMODIFY_VALIDATE</b></dt> <dt>8</dt>
///                  </dl> </td> <td width="60%"> Validates a record. Does not validate across joins. You must first call the
///                  MsiViewFetch function with the same record. Obtain validation errors with MsiViewGetError. Works with read-write
///                  and read-only records. This mode cannot be used with a view containing joins. </td> </tr> <tr> <td width="40%"><a
///                  id="MSIMODIFY_VALIDATE_NEW"></a><a id="msimodify_validate_new"></a><dl> <dt><b>MSIMODIFY_VALIDATE_NEW</b></dt>
///                  <dt>9</dt> </dl> </td> <td width="60%"> Validate a new record. Does not validate across joins. Checks for
///                  duplicate keys. Obtain validation errors by calling MsiViewGetError. Works with read-write and read-only records.
///                  This mode cannot be used with a view containing joins. </td> </tr> <tr> <td width="40%"><a
///                  id="MSIMODIFY_VALIDATE_FIELD"></a><a id="msimodify_validate_field"></a><dl>
///                  <dt><b>MSIMODIFY_VALIDATE_FIELD</b></dt> <dt>10</dt> </dl> </td> <td width="60%"> Validates fields of a fetched
///                  or new record. Can validate one or more fields of an incomplete record. Obtain validation errors by calling
///                  MsiViewGetError. Works with read-write and read-only records. This mode cannot be used with a view containing
///                  joins. </td> </tr> <tr> <td width="40%"><a id="MSIMODIFY_VALIDATE_DELETE"></a><a
///                  id="msimodify_validate_delete"></a><dl> <dt><b>MSIMODIFY_VALIDATE_DELETE</b></dt> <dt>11</dt> </dl> </td> <td
///                  width="60%"> Validates a record that will be deleted later. You must first call MsiViewFetch. Fails if another
///                  row refers to the primary keys of this row. Validation does not check for the existence of the primary keys of
///                  this row in properties or strings. Does not check if a column is a foreign key to multiple tables. Obtain
///                  validation errors by calling MsiViewGetError. Works with read-write and read-only records. This mode cannot be
///                  used with a view that contains joins. </td> </tr> </table>
///    hRecord = Handle to the record to modify.
///Returns:
///    The <b>MsiViewModify</b> function returns the following values: Note that in low memory situations, this function
///    can raise a STATUS_NO_MEMORY exception.
///    
@DllImport("msi")
uint MsiViewModify(uint hView, MSIMODIFY eModifyMode, uint hRecord);

///The <b>MsiViewGetColumnInfo</b> function returns a record containing column names or definitions. This function
///returns a handle that should be closed using MsiCloseHandle.
///Params:
///    hView = Handle to the view from which to obtain column information.
///    eColumnInfo = Specifies a flag indicating what type of information is needed. This parameter must be one of the following
///                  values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSICOLINFO_NAMES"></a><a
///                  id="msicolinfo_names"></a><dl> <dt><b>MSICOLINFO_NAMES</b></dt> </dl> </td> <td width="60%"> Column names are
///                  returned. </td> </tr> <tr> <td width="40%"><a id="MSICOLINFO_TYPES"></a><a id="msicolinfo_types"></a><dl>
///                  <dt><b>MSICOLINFO_TYPES</b></dt> </dl> </td> <td width="60%"> Definitions are returned. </td> </tr> </table>
///    phRecord = Pointer to a handle to receive the column information data record.
///Returns:
///    Note that in low memory situations, this function can raise a STATUS_NO_MEMORY exception.
///    
@DllImport("msi")
uint MsiViewGetColumnInfo(uint hView, MSICOLINFO eColumnInfo, uint* phRecord);

///The <b>MsiViewClose</b> function releases the result set for an executed view.
///Params:
///    hView = Handle to a view that is set to release.
///Returns:
///    Note that in low memory situations, this function can raise a STATUS_NO_MEMORY exception.
///    
@DllImport("msi")
uint MsiViewClose(uint hView);

///The <b>MsiDatabaseGetPrimaryKeys</b> function returns a record containing the names of all the primary key columns
///for a specified table. This function returns a handle that should be closed using MsiCloseHandle.
///Params:
///    hDatabase = Handle to the database. See Obtaining a Database Handle.
///    szTableName = Specifies the name of the table from which to obtain primary key names.
///    phRecord = Pointer to the handle of the record that holds the primary key names.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiDatabaseGetPrimaryKeysA(uint hDatabase, const(char)* szTableName, uint* phRecord);

///The <b>MsiDatabaseGetPrimaryKeys</b> function returns a record containing the names of all the primary key columns
///for a specified table. This function returns a handle that should be closed using MsiCloseHandle.
///Params:
///    hDatabase = Handle to the database. See Obtaining a Database Handle.
///    szTableName = Specifies the name of the table from which to obtain primary key names.
///    phRecord = Pointer to the handle of the record that holds the primary key names.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiDatabaseGetPrimaryKeysW(uint hDatabase, const(wchar)* szTableName, uint* phRecord);

///The <b>MsiDatabaseIsTablePersistent</b> function returns an enumeration that describes the state of a specific table.
///Params:
///    hDatabase = Handle to the database that belongs to the relevant table. For more information, see Obtaining a Database Handle.
///    szTableName = Specifies the name of the relevant table.
///Returns:
///    This function returns MSICONDITION.
///    
@DllImport("msi")
MSICONDITION MsiDatabaseIsTablePersistentA(uint hDatabase, const(char)* szTableName);

///The <b>MsiDatabaseIsTablePersistent</b> function returns an enumeration that describes the state of a specific table.
///Params:
///    hDatabase = Handle to the database that belongs to the relevant table. For more information, see Obtaining a Database Handle.
///    szTableName = Specifies the name of the relevant table.
///Returns:
///    This function returns MSICONDITION.
///    
@DllImport("msi")
MSICONDITION MsiDatabaseIsTablePersistentW(uint hDatabase, const(wchar)* szTableName);

///The <b>MsiGetSummaryInformation</b> function obtains a handle to the _SummaryInformation stream for an installer
///database. This function returns a handle that should be closed using MsiCloseHandle.
///Params:
///    hDatabase = Handle to the database.
///    szDatabasePath = Specifies the path to the database.
///    uiUpdateCount = Specifies the maximum number of updated values.
///    phSummaryInfo = Pointer to the location from which to receive the summary information handle.
///Returns:
///    The <b>MsiGetSummaryInformation</b> function returns the following values:
///    
@DllImport("msi")
uint MsiGetSummaryInformationA(uint hDatabase, const(char)* szDatabasePath, uint uiUpdateCount, 
                               uint* phSummaryInfo);

///The <b>MsiGetSummaryInformation</b> function obtains a handle to the _SummaryInformation stream for an installer
///database. This function returns a handle that should be closed using MsiCloseHandle.
///Params:
///    hDatabase = Handle to the database.
///    szDatabasePath = Specifies the path to the database.
///    uiUpdateCount = Specifies the maximum number of updated values.
///    phSummaryInfo = Pointer to the location from which to receive the summary information handle.
///Returns:
///    The <b>MsiGetSummaryInformation</b> function returns the following values:
///    
@DllImport("msi")
uint MsiGetSummaryInformationW(uint hDatabase, const(wchar)* szDatabasePath, uint uiUpdateCount, 
                               uint* phSummaryInfo);

///The <b>MsiSummaryInfoGetPropertyCount</b> function returns the number of existing properties in the summary
///information stream.
///Params:
///    hSummaryInfo = Handle to summary information.
///    puiPropertyCount = Location to receive the total property count.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiSummaryInfoGetPropertyCount(uint hSummaryInfo, uint* puiPropertyCount);

///The <b>MsiSummaryInfoSetProperty</b> function sets a single summary information property. <div
///class="alert"><b>Note</b> The meaning of the property value depends on whether the summary information stream is for
///an installation database (.msi file), transform (.mst file) or patch (.msp file). See Summary Property Descriptions
///and Summary Information Stream Property Set for more information about summary information properties.</div> <div>
///</div>
///Params:
///    hSummaryInfo = Handle to summary information.
///    uiProperty = Specifies the property ID of the summary property being set. This parameter can be a property ID listed in the
///                 Summary Information Stream Property Set. This function does not set values for PID_DICTIONARY OR PID_THUMBNAIL
///                 property.
///    uiDataType = Specifies the type of property to set. This parameter can be a type listed in the Summary Information Stream
///                 Property Set.
///    iValue = Specifies the integer value.
///    pftValue = Specifies the file-time value.
///    szValue = Specifies the text value.
///Returns:
///    The <b>MsiSummaryInfoSetProperty</b> function returns the following values:
///    
@DllImport("msi")
uint MsiSummaryInfoSetPropertyA(uint hSummaryInfo, uint uiProperty, uint uiDataType, int iValue, 
                                FILETIME* pftValue, const(char)* szValue);

///The <b>MsiSummaryInfoSetProperty</b> function sets a single summary information property. <div
///class="alert"><b>Note</b> The meaning of the property value depends on whether the summary information stream is for
///an installation database (.msi file), transform (.mst file) or patch (.msp file). See Summary Property Descriptions
///and Summary Information Stream Property Set for more information about summary information properties.</div> <div>
///</div>
///Params:
///    hSummaryInfo = Handle to summary information.
///    uiProperty = Specifies the property ID of the summary property being set. This parameter can be a property ID listed in the
///                 Summary Information Stream Property Set. This function does not set values for PID_DICTIONARY OR PID_THUMBNAIL
///                 property.
///    uiDataType = Specifies the type of property to set. This parameter can be a type listed in the Summary Information Stream
///                 Property Set.
///    iValue = Specifies the integer value.
///    pftValue = Specifies the file-time value.
///    szValue = Specifies the text value.
///Returns:
///    The <b>MsiSummaryInfoSetProperty</b> function returns the following values:
///    
@DllImport("msi")
uint MsiSummaryInfoSetPropertyW(uint hSummaryInfo, uint uiProperty, uint uiDataType, int iValue, 
                                FILETIME* pftValue, const(wchar)* szValue);

///The <b>MsiSummaryInfoGetProperty</b> function gets a single property from the summary information stream. <div
///class="alert"><b>Note</b> The meaning of the property value depends on whether the summary information stream is for
///an installation database (.msi file), transform (.mst file) or patch (.msp file). See Summary Property Descriptions
///and Summary Information Stream Property Set for more information about summary information properties.</div> <div>
///</div>
///Params:
///    hSummaryInfo = Handle to summary information.
///    uiProperty = Specifies the property ID of the summary property. This parameter can be a property ID listed in the Summary
///                 Information Stream Property Set. This function does not return values for PID_DICTIONARY OR PID_THUMBNAIL
///                 property.
///    puiDataType = Receives the returned property type. This parameter can be a type listed in the Summary Information Stream
///                  Property Set.
///    piValue = Receives the returned integer property data.
///    pftValue = Pointer to a file value.
///    szValueBuf = Pointer to the buffer that receives the null terminated summary information property value. Do not attempt to
///                 determine the size of the buffer by passing in a null (value=0) for <i>szValueBuf</i>. You can get the size of
///                 the buffer by passing in an empty string (for example ""). The function then returns ERROR_MORE_DATA and
///                 <i>pcchValueBuf</i> contains the required buffer size in <b>TCHARs</b>, not including the terminating null
///                 character. On return of ERROR_SUCCESS, <i>pcchValueBuf</i> contains the number of <b>TCHARs</b> written to the
///                 buffer, not including the terminating null character. This parameter is an empty string if there are no errors.
///    pcchValueBuf = Pointer to the variable that specifies the size, in <b>TCHARs</b>, of the buffer pointed to by the variable
///                   <i>szValueBuf</i>. When the function returns ERROR_SUCCESS, this variable contains the size of the data copied to
///                   <i>szValueBuf</i>, not including the terminating null character. If <i>szValueBuf</i> is not large enough, the
///                   function returns ERROR_MORE_DATA and stores the required size, not including the terminating null character, in
///                   the variable pointed to by <i>pcchValueBuf</i>.
///Returns:
///    The <b>MsiSummaryInfoGetProperty</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiSummaryInfoGetPropertyA(uint hSummaryInfo, uint uiProperty, uint* puiDataType, int* piValue, 
                                FILETIME* pftValue, const(char)* szValueBuf, uint* pcchValueBuf);

///The <b>MsiSummaryInfoGetProperty</b> function gets a single property from the summary information stream. <div
///class="alert"><b>Note</b> The meaning of the property value depends on whether the summary information stream is for
///an installation database (.msi file), transform (.mst file) or patch (.msp file). See Summary Property Descriptions
///and Summary Information Stream Property Set for more information about summary information properties.</div> <div>
///</div>
///Params:
///    hSummaryInfo = Handle to summary information.
///    uiProperty = Specifies the property ID of the summary property. This parameter can be a property ID listed in the Summary
///                 Information Stream Property Set. This function does not return values for PID_DICTIONARY OR PID_THUMBNAIL
///                 property.
///    puiDataType = Receives the returned property type. This parameter can be a type listed in the Summary Information Stream
///                  Property Set.
///    piValue = Receives the returned integer property data.
///    pftValue = Pointer to a file value.
///    szValueBuf = Pointer to the buffer that receives the null terminated summary information property value. Do not attempt to
///                 determine the size of the buffer by passing in a null (value=0) for <i>szValueBuf</i>. You can get the size of
///                 the buffer by passing in an empty string (for example ""). The function then returns ERROR_MORE_DATA and
///                 <i>pcchValueBuf</i> contains the required buffer size in <b>TCHARs</b>, not including the terminating null
///                 character. On return of ERROR_SUCCESS, <i>pcchValueBuf</i> contains the number of <b>TCHARs</b> written to the
///                 buffer, not including the terminating null character. This parameter is an empty string if there are no errors.
///    pcchValueBuf = Pointer to the variable that specifies the size, in <b>TCHARs</b>, of the buffer pointed to by the variable
///                   <i>szValueBuf</i>. When the function returns ERROR_SUCCESS, this variable contains the size of the data copied to
///                   <i>szValueBuf</i>, not including the terminating null character. If <i>szValueBuf</i> is not large enough, the
///                   function returns ERROR_MORE_DATA and stores the required size, not including the terminating null character, in
///                   the variable pointed to by <i>pcchValueBuf</i>.
///Returns:
///    The <b>MsiSummaryInfoGetProperty</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiSummaryInfoGetPropertyW(uint hSummaryInfo, uint uiProperty, uint* puiDataType, int* piValue, 
                                FILETIME* pftValue, const(wchar)* szValueBuf, uint* pcchValueBuf);

///The <b>MsiSummaryInfoPersist</b> function writes changed summary information back to the summary information stream.
///Params:
///    hSummaryInfo = Handle to summary information.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiSummaryInfoPersist(uint hSummaryInfo);

///The <b>MsiOpenDatabase</b> function opens a database file for data access. This function returns a handle that should
///be closed using MsiCloseHandle.
///Params:
///    szDatabasePath = Specifies the full path or relative path to the database file.
///    szPersist = Receives the full path to the file or the persistence mode. You can use the <i>szPersist</i> parameter to direct
///                the persistent output to a new file or to specify one of the following predefined persistence modes. <table> <tr>
///                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIDBOPEN_CREATEDIRECT"></a><a
///                id="msidbopen_createdirect"></a><dl> <dt><b>MSIDBOPEN_CREATEDIRECT</b></dt> </dl> </td> <td width="60%"> Create a
///                new database, direct mode read/write. </td> </tr> <tr> <td width="40%"><a id="MSIDBOPEN_CREATE"></a><a
///                id="msidbopen_create"></a><dl> <dt><b>MSIDBOPEN_CREATE</b></dt> </dl> </td> <td width="60%"> Create a new
///                database, transact mode read/write. </td> </tr> <tr> <td width="40%"><a id="MSIDBOPEN_DIRECT"></a><a
///                id="msidbopen_direct"></a><dl> <dt><b>MSIDBOPEN_DIRECT</b></dt> </dl> </td> <td width="60%"> Open a database
///                direct read/write without transaction. </td> </tr> <tr> <td width="40%"><a id="MSIDBOPEN_READONLY"></a><a
///                id="msidbopen_readonly"></a><dl> <dt><b>MSIDBOPEN_READONLY</b></dt> </dl> </td> <td width="60%"> Open a database
///                read-only, no persistent changes. </td> </tr> <tr> <td width="40%"><a id="MSIDBOPEN_TRANSACT"></a><a
///                id="msidbopen_transact"></a><dl> <dt><b>MSIDBOPEN_TRANSACT</b></dt> </dl> </td> <td width="60%"> Open a database
///                read/write in transaction mode. </td> </tr> <tr> <td width="40%"><a id="MSIDBOPEN_PATCHFILE"></a><a
///                id="msidbopen_patchfile"></a><dl> <dt><b>MSIDBOPEN_PATCHFILE</b></dt> </dl> </td> <td width="60%"> Add this flag
///                to indicate a patch file. </td> </tr> </table>
///    phDatabase = Pointer to the location of the returned database handle.
///Returns:
///    The <b>MsiOpenDatabase</b> function returns the following values:
///    
@DllImport("msi")
uint MsiOpenDatabaseA(const(char)* szDatabasePath, const(char)* szPersist, uint* phDatabase);

///The <b>MsiOpenDatabase</b> function opens a database file for data access. This function returns a handle that should
///be closed using MsiCloseHandle.
///Params:
///    szDatabasePath = Specifies the full path or relative path to the database file.
///    szPersist = Receives the full path to the file or the persistence mode. You can use the <i>szPersist</i> parameter to direct
///                the persistent output to a new file or to specify one of the following predefined persistence modes. <table> <tr>
///                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIDBOPEN_CREATEDIRECT"></a><a
///                id="msidbopen_createdirect"></a><dl> <dt><b>MSIDBOPEN_CREATEDIRECT</b></dt> </dl> </td> <td width="60%"> Create a
///                new database, direct mode read/write. </td> </tr> <tr> <td width="40%"><a id="MSIDBOPEN_CREATE"></a><a
///                id="msidbopen_create"></a><dl> <dt><b>MSIDBOPEN_CREATE</b></dt> </dl> </td> <td width="60%"> Create a new
///                database, transact mode read/write. </td> </tr> <tr> <td width="40%"><a id="MSIDBOPEN_DIRECT"></a><a
///                id="msidbopen_direct"></a><dl> <dt><b>MSIDBOPEN_DIRECT</b></dt> </dl> </td> <td width="60%"> Open a database
///                direct read/write without transaction. </td> </tr> <tr> <td width="40%"><a id="MSIDBOPEN_READONLY"></a><a
///                id="msidbopen_readonly"></a><dl> <dt><b>MSIDBOPEN_READONLY</b></dt> </dl> </td> <td width="60%"> Open a database
///                read-only, no persistent changes. </td> </tr> <tr> <td width="40%"><a id="MSIDBOPEN_TRANSACT"></a><a
///                id="msidbopen_transact"></a><dl> <dt><b>MSIDBOPEN_TRANSACT</b></dt> </dl> </td> <td width="60%"> Open a database
///                read/write in transaction mode. </td> </tr> <tr> <td width="40%"><a id="MSIDBOPEN_PATCHFILE"></a><a
///                id="msidbopen_patchfile"></a><dl> <dt><b>MSIDBOPEN_PATCHFILE</b></dt> </dl> </td> <td width="60%"> Add this flag
///                to indicate a patch file. </td> </tr> </table>
///    phDatabase = Pointer to the location of the returned database handle.
///Returns:
///    The <b>MsiOpenDatabase</b> function returns the following values:
///    
@DllImport("msi")
uint MsiOpenDatabaseW(const(wchar)* szDatabasePath, const(wchar)* szPersist, uint* phDatabase);

///The <b>MsiDatabaseImport</b> function imports an installer text archive file into an open database table.
///Params:
///    hDatabase = Handle to the database obtained from MsiOpenDatabase.
///    szFolderPath = Specifies the path to the folder that contains archive files.
///    szFileName = Specifies the name of the file to import.
///Returns:
///    The <b>MsiDatabaseImport</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiDatabaseImportA(uint hDatabase, const(char)* szFolderPath, const(char)* szFileName);

///The <b>MsiDatabaseImport</b> function imports an installer text archive file into an open database table.
///Params:
///    hDatabase = Handle to the database obtained from MsiOpenDatabase.
///    szFolderPath = Specifies the path to the folder that contains archive files.
///    szFileName = Specifies the name of the file to import.
///Returns:
///    The <b>MsiDatabaseImport</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiDatabaseImportW(uint hDatabase, const(wchar)* szFolderPath, const(wchar)* szFileName);

///The <b>MsiDatabaseExport</b> function exports a Microsoft Installer table from an open database to a Text Archive
///File.
///Params:
///    hDatabase = The handle to a database from MsiOpenDatabase.
///    szTableName = The name of the table to export.
///    szFolderPath = The name of the folder that contains archive files.
///    szFileName = The name of the exported table archive file.
///Returns:
///    The <b>MsiDatabaseExport</b> function returns one of the following values: <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_PATHNAME</b></dt> </dl> </td> <td
///    width="60%"> An invalid path is passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> The function fails. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> An invalid or inactive handle
///    is supplied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> An invalid parameter is passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function succeeds. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiDatabaseExportA(uint hDatabase, const(char)* szTableName, const(char)* szFolderPath, 
                        const(char)* szFileName);

///The <b>MsiDatabaseExport</b> function exports a Microsoft Installer table from an open database to a Text Archive
///File.
///Params:
///    hDatabase = The handle to a database from MsiOpenDatabase.
///    szTableName = The name of the table to export.
///    szFolderPath = The name of the folder that contains archive files.
///    szFileName = The name of the exported table archive file.
///Returns:
///    The <b>MsiDatabaseExport</b> function returns one of the following values: <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_PATHNAME</b></dt> </dl> </td> <td
///    width="60%"> An invalid path is passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td width="60%"> The function fails. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> An invalid or inactive handle
///    is supplied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> An invalid parameter is passed to the function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> The function succeeds. </td> </tr> </table>
///    
@DllImport("msi")
uint MsiDatabaseExportW(uint hDatabase, const(wchar)* szTableName, const(wchar)* szFolderPath, 
                        const(wchar)* szFileName);

///The <b>MsiDatabaseMerge</b> function merges two databases together, which allows duplicate rows.
///Params:
///    hDatabase = The handle to the database obtained from MsiOpenDatabase.
///    hDatabaseMerge = The handle to the database obtained from MsiOpenDatabase to merge into the base database.
///    szTableName = The name of the table to receive merge conflict information.
///Returns:
///    The <b>MsiDatabaseMerge</b> function returns one of the following values: <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> Row merge conflicts were reported. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> An invalid or inactive handle was supplied.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_TABLE</b></dt> </dl> </td> <td width="60%"> An
///    invalid table was supplied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td
///    width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_DATATYPE_MISMATCH</b></dt> </dl> </td> <td width="60%"> Schema difference between the two databases.
///    </td> </tr> </table>
///    
@DllImport("msi")
uint MsiDatabaseMergeA(uint hDatabase, uint hDatabaseMerge, const(char)* szTableName);

///The <b>MsiDatabaseMerge</b> function merges two databases together, which allows duplicate rows.
///Params:
///    hDatabase = The handle to the database obtained from MsiOpenDatabase.
///    hDatabaseMerge = The handle to the database obtained from MsiOpenDatabase to merge into the base database.
///    szTableName = The name of the table to receive merge conflict information.
///Returns:
///    The <b>MsiDatabaseMerge</b> function returns one of the following values: <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED</b></dt> </dl> </td> <td
///    width="60%"> Row merge conflicts were reported. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> An invalid or inactive handle was supplied.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_TABLE</b></dt> </dl> </td> <td width="60%"> An
///    invalid table was supplied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td
///    width="60%"> The function succeeded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_DATATYPE_MISMATCH</b></dt> </dl> </td> <td width="60%"> Schema difference between the two databases.
///    </td> </tr> </table>
///    
@DllImport("msi")
uint MsiDatabaseMergeW(uint hDatabase, uint hDatabaseMerge, const(wchar)* szTableName);

///The <b>MsiDatabaseGenerateTransform</b> function generates a transform file of differences between two databases. A
///transform is a way of recording changes to a database without altering the original database. You can also use
///<b>MsiDatabaseGenerateTransform</b> to test whether two databases are identical without creating a transform.
///Params:
///    hDatabase = Handle to the database obtained from MsiOpenDatabase that includes the changes.
///    hDatabaseReference = Handle to the database obtained from MsiOpenDatabase that does not include the changes.
///    szTransformFile = A null-terminated string that specifies the name of the transform file being generated. This parameter can be
///                      null. If <i>szTransformFile</i> is null, you can use <b>MsiDatabaseGenerateTransform</b> to test whether two
///                      databases are identical without creating a transform. If the databases are identical, the function returns
///                      ERROR_NO_DATA. If the databases are different the function returns NOERROR.
///    iReserved1 = This is a reserved argument and must be set to 0.
///    iReserved2 = This is a reserved argument and must be set to 0.
///Returns:
///    The <b>MsiDatabaseGenerateTransform</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiDatabaseGenerateTransformA(uint hDatabase, uint hDatabaseReference, const(char)* szTransformFile, 
                                   int iReserved1, int iReserved2);

///The <b>MsiDatabaseGenerateTransform</b> function generates a transform file of differences between two databases. A
///transform is a way of recording changes to a database without altering the original database. You can also use
///<b>MsiDatabaseGenerateTransform</b> to test whether two databases are identical without creating a transform.
///Params:
///    hDatabase = Handle to the database obtained from MsiOpenDatabase that includes the changes.
///    hDatabaseReference = Handle to the database obtained from MsiOpenDatabase that does not include the changes.
///    szTransformFile = A null-terminated string that specifies the name of the transform file being generated. This parameter can be
///                      null. If <i>szTransformFile</i> is null, you can use <b>MsiDatabaseGenerateTransform</b> to test whether two
///                      databases are identical without creating a transform. If the databases are identical, the function returns
///                      ERROR_NO_DATA. If the databases are different the function returns NOERROR.
///    iReserved1 = This is a reserved argument and must be set to 0.
///    iReserved2 = This is a reserved argument and must be set to 0.
///Returns:
///    The <b>MsiDatabaseGenerateTransform</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiDatabaseGenerateTransformW(uint hDatabase, uint hDatabaseReference, const(wchar)* szTransformFile, 
                                   int iReserved1, int iReserved2);

///The <b>MsiDatabaseApplyTransform</b> function applies a transform to a database.
///Params:
///    hDatabase = Handle to the database obtained from MsiOpenDatabase to the transform.
///    szTransformFile = Specifies the name of the transform file to apply.
///    iErrorConditions = Error conditions that should be suppressed. This parameter is a bit field that can contain the following bits.
///                       <table> <tr> <th>Error condition</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                       id="MSITRANSFORM_ERROR_ADDEXISTINGROW"></a><a id="msitransform_error_addexistingrow"></a><dl>
///                       <dt><b>MSITRANSFORM_ERROR_ADDEXISTINGROW</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> Adding a row that
///                       already exists. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_ERROR_DELMISSINGROW"></a><a
///                       id="msitransform_error_delmissingrow"></a><dl> <dt><b>MSITRANSFORM_ERROR_DELMISSINGROW</b></dt> <dt>0x0002</dt>
///                       </dl> </td> <td width="60%"> Deleting a row that does not exist. </td> </tr> <tr> <td width="40%"><a
///                       id="MSITRANSFORM_ERROR_ADDEXISTINGTABLE"></a><a id="msitransform_error_addexistingtable"></a><dl>
///                       <dt><b>MSITRANSFORM_ERROR_ADDEXISTINGTABLE</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> Adding a table
///                       that already exists. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_ERROR_DELMISSINGTABLE"></a><a
///                       id="msitransform_error_delmissingtable"></a><dl> <dt><b>MSITRANSFORM_ERROR_DELMISSINGTABLE</b></dt>
///                       <dt>0x0008</dt> </dl> </td> <td width="60%"> Deleting a table that does not exist. </td> </tr> <tr> <td
///                       width="40%"><a id="MSITRANSFORM_ERROR_UPDATEMISSINGROW"></a><a id="msitransform_error_updatemissingrow"></a><dl>
///                       <dt><b>MSITRANSFORM_ERROR_UPDATEMISSINGROW</b></dt> <dt>0x0010</dt> </dl> </td> <td width="60%"> Updating a row
///                       that does not exist. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_ERROR_CHANGECODEPAGE"></a><a
///                       id="msitransform_error_changecodepage"></a><dl> <dt><b>MSITRANSFORM_ERROR_CHANGECODEPAGE</b></dt> <dt>0x0020</dt>
///                       </dl> </td> <td width="60%"> Transform and database code pages do not match and neither has a neutral code page.
///                       </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_ERROR_VIEWTRANSFORM"></a><a
///                       id="msitransform_error_viewtransform"></a><dl> <dt><b>MSITRANSFORM_ERROR_VIEWTRANSFORM</b></dt> <dt>0x0100</dt>
///                       </dl> </td> <td width="60%"> Create the temporary _TransformView table. </td> </tr> </table>
///Returns:
///    The <b>MsiDatabaseApplyTransform</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiDatabaseApplyTransformA(uint hDatabase, const(char)* szTransformFile, int iErrorConditions);

///The <b>MsiDatabaseApplyTransform</b> function applies a transform to a database.
///Params:
///    hDatabase = Handle to the database obtained from MsiOpenDatabase to the transform.
///    szTransformFile = Specifies the name of the transform file to apply.
///    iErrorConditions = Error conditions that should be suppressed. This parameter is a bit field that can contain the following bits.
///                       <table> <tr> <th>Error condition</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                       id="MSITRANSFORM_ERROR_ADDEXISTINGROW"></a><a id="msitransform_error_addexistingrow"></a><dl>
///                       <dt><b>MSITRANSFORM_ERROR_ADDEXISTINGROW</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> Adding a row that
///                       already exists. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_ERROR_DELMISSINGROW"></a><a
///                       id="msitransform_error_delmissingrow"></a><dl> <dt><b>MSITRANSFORM_ERROR_DELMISSINGROW</b></dt> <dt>0x0002</dt>
///                       </dl> </td> <td width="60%"> Deleting a row that does not exist. </td> </tr> <tr> <td width="40%"><a
///                       id="MSITRANSFORM_ERROR_ADDEXISTINGTABLE"></a><a id="msitransform_error_addexistingtable"></a><dl>
///                       <dt><b>MSITRANSFORM_ERROR_ADDEXISTINGTABLE</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> Adding a table
///                       that already exists. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_ERROR_DELMISSINGTABLE"></a><a
///                       id="msitransform_error_delmissingtable"></a><dl> <dt><b>MSITRANSFORM_ERROR_DELMISSINGTABLE</b></dt>
///                       <dt>0x0008</dt> </dl> </td> <td width="60%"> Deleting a table that does not exist. </td> </tr> <tr> <td
///                       width="40%"><a id="MSITRANSFORM_ERROR_UPDATEMISSINGROW"></a><a id="msitransform_error_updatemissingrow"></a><dl>
///                       <dt><b>MSITRANSFORM_ERROR_UPDATEMISSINGROW</b></dt> <dt>0x0010</dt> </dl> </td> <td width="60%"> Updating a row
///                       that does not exist. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_ERROR_CHANGECODEPAGE"></a><a
///                       id="msitransform_error_changecodepage"></a><dl> <dt><b>MSITRANSFORM_ERROR_CHANGECODEPAGE</b></dt> <dt>0x0020</dt>
///                       </dl> </td> <td width="60%"> Transform and database code pages do not match and neither has a neutral code page.
///                       </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_ERROR_VIEWTRANSFORM"></a><a
///                       id="msitransform_error_viewtransform"></a><dl> <dt><b>MSITRANSFORM_ERROR_VIEWTRANSFORM</b></dt> <dt>0x0100</dt>
///                       </dl> </td> <td width="60%"> Create the temporary _TransformView table. </td> </tr> </table>
///Returns:
///    The <b>MsiDatabaseApplyTransform</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiDatabaseApplyTransformW(uint hDatabase, const(wchar)* szTransformFile, int iErrorConditions);

///The <b>MsiCreateTransformSummaryInfo</b> function creates summary information of an existing transform to include
///validation and error conditions. Execution of this function sets the error record, which is accessible by using
///MsiGetLastErrorRecord.
///Params:
///    hDatabase = The handle to the database that contains the new database summary information.
///    hDatabaseReference = The handle to the database that contains the original summary information.
///    szTransformFile = The name of the transform to which the summary information is added.
///    iErrorConditions = The error conditions that should be suppressed when the transform is applied. Use one or more of the following
///                       values. <table> <tr> <th>Error condition</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="none"></a><a
///                       id="NONE"></a><dl> <dt><b>none</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> None of the following
///                       conditions. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_ERROR_ADDEXISTINGROW"></a><a
///                       id="msitransform_error_addexistingrow"></a><dl> <dt><b>MSITRANSFORM_ERROR_ADDEXISTINGROW</b></dt>
///                       <dt>0x00000001</dt> </dl> </td> <td width="60%"> Adding a row that exists. </td> </tr> <tr> <td width="40%"><a
///                       id="MSITRANSFORM_ERROR_DELMISSINGROW"></a><a id="msitransform_error_delmissingrow"></a><dl>
///                       <dt><b>MSITRANSFORM_ERROR_DELMISSINGROW</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Deleting a row
///                       that does not exist. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_ERROR_ADDEXISTINGTABLE"></a><a
///                       id="msitransform_error_addexistingtable"></a><dl> <dt><b>MSITRANSFORM_ERROR_ADDEXISTINGTABLE</b></dt>
///                       <dt>0x00000004</dt> </dl> </td> <td width="60%"> Adding a table that exists. </td> </tr> <tr> <td width="40%"><a
///                       id="MSITRANSFORM_ERROR_DELMISSINGTABLE"></a><a id="msitransform_error_delmissingtable"></a><dl>
///                       <dt><b>MSITRANSFORM_ERROR_DELMISSINGTABLE</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> Deleting a
///                       table that does not exist. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_ERROR_UPDATEMISSINGROW"></a><a
///                       id="msitransform_error_updatemissingrow"></a><dl> <dt><b>MSITRANSFORM_ERROR_UPDATEMISSINGROW</b></dt>
///                       <dt>0x00000010</dt> </dl> </td> <td width="60%"> Updating a row that does not exist. </td> </tr> <tr> <td
///                       width="40%"><a id="MSITRANSFORM_ERROR_CHANGECODEPAGE"></a><a id="msitransform_error_changecodepage"></a><dl>
///                       <dt><b>MSITRANSFORM_ERROR_CHANGECODEPAGE</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> Transform and
///                       database code pages do not match, and their code pages are neutral. </td> </tr> </table>
///    iValidation = Specifies the properties to be validated to verify that the transform can be applied to the database. This
///                  parameter can be one or more of the following values. <table> <tr> <th>Validation flag</th> <th>Meaning</th>
///                  </tr> <tr> <td width="40%"><a id="none"></a><a id="NONE"></a><dl> <dt><b>none</b></dt> <dt>0x00000000</dt> </dl>
///                  </td> <td width="60%"> Do not validate properties. </td> </tr> <tr> <td width="40%"><a
///                  id="MSITRANSFORM_VALIDATE_LANGUAGE"></a><a id="msitransform_validate_language"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_LANGUAGE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Default language
///                  must match base database. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_VALIDATE_PRODUCT"></a><a
///                  id="msitransform_validate_product"></a><dl> <dt><b>MSITRANSFORM_VALIDATE_PRODUCT</b></dt> <dt>0x00000002</dt>
///                  </dl> </td> <td width="60%"> Product must match base database. </td> </tr> </table> Validate product version
///                  flags. <table> <tr> <th>Validation flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="MSITRANSFORM_VALIDATE_MAJORVERSION"></a><a id="msitransform_validate_majorversion"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_MAJORVERSION</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> Check major
///                  version only. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_VALIDATE_MINORVERSION"></a><a
///                  id="msitransform_validate_minorversion"></a><dl> <dt><b>MSITRANSFORM_VALIDATE_MINORVERSION</b></dt>
///                  <dt>0x00000010</dt> </dl> </td> <td width="60%"> Check major and minor versions only. </td> </tr> <tr> <td
///                  width="40%"><a id="MSITRANSFORM_VALIDATE_UPDATEVERSION"></a><a id="msitransform_validate_updateversion"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_UPDATEVERSION</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> Check major,
///                  minor, and update versions. </td> </tr> </table> Product version relationship flags. In the following table the
///                  installed version is the version of the package that is being transformed, and the base version is the version of
///                  the package that is used to create the transform. <table> <tr> <th>Validation flag</th> <th>Meaning</th> </tr>
///                  <tr> <td width="40%"><a id="MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION"></a><a
///                  id="msitransform_validate_newlessbaseversion"></a><dl> <dt><b>MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION</b></dt>
///                  <dt>0x00000040</dt> </dl> </td> <td width="60%"> Installed version &lt; base version. </td> </tr> <tr> <td
///                  width="40%"><a id="MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION"></a><a
///                  id="msitransform_validate_newlessequalbaseversion"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%">
///                  Installed version &lt;= base version. </td> </tr> <tr> <td width="40%"><a
///                  id="MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION"></a><a id="msitransform_validate_newequalbaseversion"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%">
///                  Installed version = base version. </td> </tr> <tr> <td width="40%"><a
///                  id="MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION"></a><a
///                  id="msitransform_validate_newgreaterequalbaseversion"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%">
///                  Installed version &gt;= base version. </td> </tr> <tr> <td width="40%"><a
///                  id="MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION"></a><a id="msitransform_validate_newgreaterbaseversion"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION</b></dt> <dt>0x00000400</dt> </dl> </td> <td width="60%">
///                  Installed version &gt; base version. </td> </tr> </table> Upgrade code validation flags. <table> <tr>
///                  <th>Validation flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="MSITRANSFORM_VALIDATE_UPGRADECODE"></a><a id="msitransform_validate_upgradecode"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_UPGRADECODE</b></dt> <dt>0x00000800</dt> </dl> </td> <td width="60%"> UpgradeCode
///                  must match base database. </td> </tr> </table>
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiCreateTransformSummaryInfoA(uint hDatabase, uint hDatabaseReference, const(char)* szTransformFile, 
                                    int iErrorConditions, int iValidation);

///The <b>MsiCreateTransformSummaryInfo</b> function creates summary information of an existing transform to include
///validation and error conditions. Execution of this function sets the error record, which is accessible by using
///MsiGetLastErrorRecord.
///Params:
///    hDatabase = The handle to the database that contains the new database summary information.
///    hDatabaseReference = The handle to the database that contains the original summary information.
///    szTransformFile = The name of the transform to which the summary information is added.
///    iErrorConditions = The error conditions that should be suppressed when the transform is applied. Use one or more of the following
///                       values. <table> <tr> <th>Error condition</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="none"></a><a
///                       id="NONE"></a><dl> <dt><b>none</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> None of the following
///                       conditions. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_ERROR_ADDEXISTINGROW"></a><a
///                       id="msitransform_error_addexistingrow"></a><dl> <dt><b>MSITRANSFORM_ERROR_ADDEXISTINGROW</b></dt>
///                       <dt>0x00000001</dt> </dl> </td> <td width="60%"> Adding a row that exists. </td> </tr> <tr> <td width="40%"><a
///                       id="MSITRANSFORM_ERROR_DELMISSINGROW"></a><a id="msitransform_error_delmissingrow"></a><dl>
///                       <dt><b>MSITRANSFORM_ERROR_DELMISSINGROW</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Deleting a row
///                       that does not exist. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_ERROR_ADDEXISTINGTABLE"></a><a
///                       id="msitransform_error_addexistingtable"></a><dl> <dt><b>MSITRANSFORM_ERROR_ADDEXISTINGTABLE</b></dt>
///                       <dt>0x00000004</dt> </dl> </td> <td width="60%"> Adding a table that exists. </td> </tr> <tr> <td width="40%"><a
///                       id="MSITRANSFORM_ERROR_DELMISSINGTABLE"></a><a id="msitransform_error_delmissingtable"></a><dl>
///                       <dt><b>MSITRANSFORM_ERROR_DELMISSINGTABLE</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> Deleting a
///                       table that does not exist. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_ERROR_UPDATEMISSINGROW"></a><a
///                       id="msitransform_error_updatemissingrow"></a><dl> <dt><b>MSITRANSFORM_ERROR_UPDATEMISSINGROW</b></dt>
///                       <dt>0x00000010</dt> </dl> </td> <td width="60%"> Updating a row that does not exist. </td> </tr> <tr> <td
///                       width="40%"><a id="MSITRANSFORM_ERROR_CHANGECODEPAGE"></a><a id="msitransform_error_changecodepage"></a><dl>
///                       <dt><b>MSITRANSFORM_ERROR_CHANGECODEPAGE</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> Transform and
///                       database code pages do not match, and their code pages are neutral. </td> </tr> </table>
///    iValidation = Specifies the properties to be validated to verify that the transform can be applied to the database. This
///                  parameter can be one or more of the following values. <table> <tr> <th>Validation flag</th> <th>Meaning</th>
///                  </tr> <tr> <td width="40%"><a id="none"></a><a id="NONE"></a><dl> <dt><b>none</b></dt> <dt>0x00000000</dt> </dl>
///                  </td> <td width="60%"> Do not validate properties. </td> </tr> <tr> <td width="40%"><a
///                  id="MSITRANSFORM_VALIDATE_LANGUAGE"></a><a id="msitransform_validate_language"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_LANGUAGE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Default language
///                  must match base database. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_VALIDATE_PRODUCT"></a><a
///                  id="msitransform_validate_product"></a><dl> <dt><b>MSITRANSFORM_VALIDATE_PRODUCT</b></dt> <dt>0x00000002</dt>
///                  </dl> </td> <td width="60%"> Product must match base database. </td> </tr> </table> Validate product version
///                  flags. <table> <tr> <th>Validation flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="MSITRANSFORM_VALIDATE_MAJORVERSION"></a><a id="msitransform_validate_majorversion"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_MAJORVERSION</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> Check major
///                  version only. </td> </tr> <tr> <td width="40%"><a id="MSITRANSFORM_VALIDATE_MINORVERSION"></a><a
///                  id="msitransform_validate_minorversion"></a><dl> <dt><b>MSITRANSFORM_VALIDATE_MINORVERSION</b></dt>
///                  <dt>0x00000010</dt> </dl> </td> <td width="60%"> Check major and minor versions only. </td> </tr> <tr> <td
///                  width="40%"><a id="MSITRANSFORM_VALIDATE_UPDATEVERSION"></a><a id="msitransform_validate_updateversion"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_UPDATEVERSION</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> Check major,
///                  minor, and update versions. </td> </tr> </table> Product version relationship flags. In the following table the
///                  installed version is the version of the package that is being transformed, and the base version is the version of
///                  the package that is used to create the transform. <table> <tr> <th>Validation flag</th> <th>Meaning</th> </tr>
///                  <tr> <td width="40%"><a id="MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION"></a><a
///                  id="msitransform_validate_newlessbaseversion"></a><dl> <dt><b>MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION</b></dt>
///                  <dt>0x00000040</dt> </dl> </td> <td width="60%"> Installed version &lt; base version. </td> </tr> <tr> <td
///                  width="40%"><a id="MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION"></a><a
///                  id="msitransform_validate_newlessequalbaseversion"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%">
///                  Installed version &lt;= base version. </td> </tr> <tr> <td width="40%"><a
///                  id="MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION"></a><a id="msitransform_validate_newequalbaseversion"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%">
///                  Installed version = base version. </td> </tr> <tr> <td width="40%"><a
///                  id="MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION"></a><a
///                  id="msitransform_validate_newgreaterequalbaseversion"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%">
///                  Installed version &gt;= base version. </td> </tr> <tr> <td width="40%"><a
///                  id="MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION"></a><a id="msitransform_validate_newgreaterbaseversion"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION</b></dt> <dt>0x00000400</dt> </dl> </td> <td width="60%">
///                  Installed version &gt; base version. </td> </tr> </table> Upgrade code validation flags. <table> <tr>
///                  <th>Validation flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="MSITRANSFORM_VALIDATE_UPGRADECODE"></a><a id="msitransform_validate_upgradecode"></a><dl>
///                  <dt><b>MSITRANSFORM_VALIDATE_UPGRADECODE</b></dt> <dt>0x00000800</dt> </dl> </td> <td width="60%"> UpgradeCode
///                  must match base database. </td> </tr> </table>
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiCreateTransformSummaryInfoW(uint hDatabase, uint hDatabaseReference, const(wchar)* szTransformFile, 
                                    int iErrorConditions, int iValidation);

///The <b>MsiDatabaseCommit</b> function commits changes to a database.
///Params:
///    hDatabase = Handle to the database obtained from MsiOpenDatabase.
///Returns:
///    The <b>MsiDatabaseCommit</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiDatabaseCommit(uint hDatabase);

///The <b>MsiGetDatabaseState</b> function returns the state of the database.
///Params:
///    hDatabase = Handle to the database obtained from MsiOpenDatabase.
///Returns:
///    This function returns MSIDBSTATE.
///    
@DllImport("msi")
MSIDBSTATE MsiGetDatabaseState(uint hDatabase);

///The <b>MsiCreateRecord</b> function creates a new record object with the specified number of fields. This function
///returns a handle that should be closed using MsiCloseHandle.
///Params:
///    cParams = Specifies the number of fields the record will have. The maximum number of fields in a record is limited to
///              65535.
///Returns:
///    If the function succeeds, the return value is handle to a new record object. If the function fails, the return
///    value is null.
///    
@DllImport("msi")
uint MsiCreateRecord(uint cParams);

///The <b>MsiRecordIsNull</b> function reports a null record field.
///Params:
///    hRecord = Handle to a record.
///    iField = Specifies the field to check.
///Returns:
///    This function returns BOOL.
///    
@DllImport("msi")
BOOL MsiRecordIsNull(uint hRecord, uint iField);

///The <b>MsiRecordDataSize</b> function returns the length of a record field. The count does not include the
///terminating null character.
///Params:
///    hRecord = Handle to the record.
///    iField = Specifies a field of the record.
///Returns:
///    The <b>MsiRecordDataSize</b> function returns 0 if the field is null, nonexistent, or an internal object pointer.
///    The function also returns 0 if the handle is not a valid record handle. If the data is in integer format, the
///    function returns sizeof(int). If the data is in string format, the function returns the character count (not
///    including the null character). If the data is in stream format, the function returns the byte count.
///    
@DllImport("msi")
uint MsiRecordDataSize(uint hRecord, uint iField);

///The <b>MsiRecordSetInteger</b> function sets a record field to an integer field.
///Params:
///    hRecord = Handle to the record.
///    iField = Specifies the field of the record to set.
///    iValue = Specifies the value to which to set the field.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiRecordSetInteger(uint hRecord, uint iField, int iValue);

///The <b>MsiRecordSetString</b> function copies a string into the designated field.
///Params:
///    hRecord = Handle to the record.
///    iField = Specifies the field of the record to set.
///    szValue = Specifies the string value of the field.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiRecordSetStringA(uint hRecord, uint iField, const(char)* szValue);

///The <b>MsiRecordSetString</b> function copies a string into the designated field.
///Params:
///    hRecord = Handle to the record.
///    iField = Specifies the field of the record to set.
///    szValue = Specifies the string value of the field.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiRecordSetStringW(uint hRecord, uint iField, const(wchar)* szValue);

///The <b>MsiRecordGetInteger</b> function returns the integer value from a record field.
///Params:
///    hRecord = Handle to a record.
///    iField = Specifies the field of the record from which to obtain the value.
///Returns:
///    If the function succeeds, the return value is the integer value of the field.
///    
@DllImport("msi")
int MsiRecordGetInteger(uint hRecord, uint iField);

///The <b>MsiRecordGetString</b> function returns the string value of a record field.
///Params:
///    hRecord = Handle to the record.
///    iField = Specifies the field requested.
///    szValueBuf = Pointer to the buffer that receives the null terminated string containing the value of the record field. Do not
///                 attempt to determine the size of the buffer by passing in a null (value=0) for <i>szValueBuf</i>. You can get the
///                 size of the buffer by passing in an empty string (for example ""). The function then returns
///                 <b>ERROR_MORE_DATA</b> and <i>pcchValueBuf</i> contains the required buffer size in TCHARs, not including the
///                 terminating null character. On return of <b>ERROR_SUCCESS</b>, <i>pcchValueBuf</i> contains the number of
///                 <b>TCHARs</b> written to the buffer, not including the terminating null character.
///    pcchValueBuf = Pointer to the variable that specifies the size, in <b>TCHAR</b>s, of the buffer pointed to by the variable
///                   <i>szValueBuf</i>. When the function returns <b>ERROR_SUCCESS</b>, this variable contains the size of the data
///                   copied to <i>szValueBuf</i>, not including the terminating null character. If <i>szValueBuf</i> is not large
///                   enough, the function returns <b>ERROR_MORE_DATA</b> and stores the required size, not including the terminating
///                   null character, in the variable pointed to by <i>pcchValueBuf</i>.
///Returns:
///    The <b>MsiRecordGetString</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiRecordGetStringA(uint hRecord, uint iField, const(char)* szValueBuf, uint* pcchValueBuf);

///The <b>MsiRecordGetString</b> function returns the string value of a record field.
///Params:
///    hRecord = Handle to the record.
///    iField = Specifies the field requested.
///    szValueBuf = Pointer to the buffer that receives the null terminated string containing the value of the record field. Do not
///                 attempt to determine the size of the buffer by passing in a null (value=0) for <i>szValueBuf</i>. You can get the
///                 size of the buffer by passing in an empty string (for example ""). The function then returns
///                 <b>ERROR_MORE_DATA</b> and <i>pcchValueBuf</i> contains the required buffer size in TCHARs, not including the
///                 terminating null character. On return of <b>ERROR_SUCCESS</b>, <i>pcchValueBuf</i> contains the number of
///                 <b>TCHARs</b> written to the buffer, not including the terminating null character.
///    pcchValueBuf = Pointer to the variable that specifies the size, in <b>TCHAR</b>s, of the buffer pointed to by the variable
///                   <i>szValueBuf</i>. When the function returns <b>ERROR_SUCCESS</b>, this variable contains the size of the data
///                   copied to <i>szValueBuf</i>, not including the terminating null character. If <i>szValueBuf</i> is not large
///                   enough, the function returns <b>ERROR_MORE_DATA</b> and stores the required size, not including the terminating
///                   null character, in the variable pointed to by <i>pcchValueBuf</i>.
///Returns:
///    The <b>MsiRecordGetString</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiRecordGetStringW(uint hRecord, uint iField, const(wchar)* szValueBuf, uint* pcchValueBuf);

///The <b>MsiRecordGetFieldCount</b> function returns the number of fields in a record.
///Params:
///    hRecord = Handle to a record.
///Returns:
///    If the function succeeds, the return value is the number of fields in the record.
///    
@DllImport("msi")
uint MsiRecordGetFieldCount(uint hRecord);

///The <b>MsiRecordSetStream</b> function sets a record stream field from a file. Stream data cannot be inserted into
///temporary fields.
///Params:
///    hRecord = Handle to the record.
///    iField = Specifies the field of the record to set.
///    szFilePath = Specifies the path to the file containing the stream.
///Returns:
///    The <b>MsiRecordSetStream</b> function returns the following values:
///    
@DllImport("msi")
uint MsiRecordSetStreamA(uint hRecord, uint iField, const(char)* szFilePath);

///The <b>MsiRecordSetStream</b> function sets a record stream field from a file. Stream data cannot be inserted into
///temporary fields.
///Params:
///    hRecord = Handle to the record.
///    iField = Specifies the field of the record to set.
///    szFilePath = Specifies the path to the file containing the stream.
///Returns:
///    The <b>MsiRecordSetStream</b> function returns the following values:
///    
@DllImport("msi")
uint MsiRecordSetStreamW(uint hRecord, uint iField, const(wchar)* szFilePath);

///The <b>MsiRecordReadStream</b> function reads bytes from a record stream field into a buffer.
///Params:
///    hRecord = Handle to the record.
///    iField = Specifies the field of the record.
///    szDataBuf = A buffer to receive the stream field. You should ensure the destination buffer is the same size or larger than
///                the source buffer. See the Remarks section.
///    pcbDataBuf = Specifies the in and out buffer count. On input, this is the full size of the buffer. On output, this is the
///                 number of bytes that were actually written to the buffer. See the Remarks section.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiRecordReadStream(uint hRecord, uint iField, char* szDataBuf, uint* pcbDataBuf);

///The <b>MsiRecordClearData</b> function sets all fields in a record to null.
///Params:
///    hRecord = Handle to the record.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiRecordClearData(uint hRecord);

///The <b>MsiGetActiveDatabase</b> function returns the active database for the installation. This function returns a
///read-only handle that should be closed using MsiCloseHandle.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///Returns:
///    If the function succeeds, it returns a read-only handle to the database currently in use by the installer. If the
///    function fails, the function returns zero, 0.
///    
@DllImport("msi")
uint MsiGetActiveDatabase(uint hInstall);

///The <b>MsiSetProperty</b> function sets the value for an installation property.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szName = Specifies the name of the property.
///    szValue = Specifies the value of the property.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiSetPropertyA(uint hInstall, const(char)* szName, const(char)* szValue);

///The <b>MsiSetProperty</b> function sets the value for an installation property.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szName = Specifies the name of the property.
///    szValue = Specifies the value of the property.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiSetPropertyW(uint hInstall, const(wchar)* szName, const(wchar)* szValue);

///The <b>MsiGetProperty</b> function gets the value for an installer property.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szName = A null-terminated string that specifies the name of the property.
///    szValueBuf = Pointer to the buffer that receives the null terminated string containing the value of the property. Do not
///                 attempt to determine the size of the buffer by passing in a null (value=0) for <i>szValueBuf</i>. You can get the
///                 size of the buffer by passing in an empty string (for example ""). The function will then return ERROR_MORE_DATA
///                 and <i>pchValueBuf </i>will contain the required buffer size in TCHARs, not including the terminating null
///                 character. On return of ERROR_SUCCESS, <i>pcchValueBuf </i>contains the number of TCHARs written to the buffer,
///                 not including the terminating null character.
///    pcchValueBuf = Pointer to the variable that specifies the size, in TCHARs, of the buffer pointed to by the variable
///                   <i>szValueBuf</i>. When the function returns ERROR_SUCCESS, this variable contains the size of the data copied to
///                   <i>szValueBuf</i>, not including the terminating null character. If <i>szValueBuf </i>is not large enough, the
///                   function returns ERROR_MORE_DATA and stores the required size, not including the terminating null character, in
///                   the variable pointed to by <i>pchValueBuf</i>.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiGetPropertyA(uint hInstall, const(char)* szName, const(char)* szValueBuf, uint* pcchValueBuf);

///The <b>MsiGetProperty</b> function gets the value for an installer property.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szName = A null-terminated string that specifies the name of the property.
///    szValueBuf = Pointer to the buffer that receives the null terminated string containing the value of the property. Do not
///                 attempt to determine the size of the buffer by passing in a null (value=0) for <i>szValueBuf</i>. You can get the
///                 size of the buffer by passing in an empty string (for example ""). The function will then return ERROR_MORE_DATA
///                 and <i>pchValueBuf </i>will contain the required buffer size in TCHARs, not including the terminating null
///                 character. On return of ERROR_SUCCESS, <i>pcchValueBuf </i>contains the number of TCHARs written to the buffer,
///                 not including the terminating null character.
///    pcchValueBuf = Pointer to the variable that specifies the size, in TCHARs, of the buffer pointed to by the variable
///                   <i>szValueBuf</i>. When the function returns ERROR_SUCCESS, this variable contains the size of the data copied to
///                   <i>szValueBuf</i>, not including the terminating null character. If <i>szValueBuf </i>is not large enough, the
///                   function returns ERROR_MORE_DATA and stores the required size, not including the terminating null character, in
///                   the variable pointed to by <i>pchValueBuf</i>.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiGetPropertyW(uint hInstall, const(wchar)* szName, const(wchar)* szValueBuf, uint* pcchValueBuf);

///The <b>MsiGetLanguage</b> function returns the numeric language of the installation that is currently running.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///Returns:
///    If the function succeeds, the return value is the numeric LANGID for the install. If the function fails, the
///    return value can be the following value.
///    
@DllImport("msi")
ushort MsiGetLanguage(uint hInstall);

///The <b>MsiGetMode</b> function is used to determine whether the installer is currently running in a specified mode,
///as listed in the table. The function returns a Boolean value of <b>TRUE</b> or <b>FALSE</b>, indicating whether the
///specific property passed into the function is currently set (<b>TRUE</b>) or not set (<b>FALSE</b>).
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    eRunMode = Specifies the run mode. This parameter must have one of the following values. <table> <tr> <th>Value</th>
///               <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIRUNMODE_ADMIN"></a><a id="msirunmode_admin"></a><dl>
///               <dt><b>MSIRUNMODE_ADMIN</b></dt> </dl> </td> <td width="60%"> The administrative mode is installing, or the
///               product is installing. </td> </tr> <tr> <td width="40%"><a id="MSIRUNMODE_ADVERTISE"></a><a
///               id="msirunmode_advertise"></a><dl> <dt><b>MSIRUNMODE_ADVERTISE</b></dt> </dl> </td> <td width="60%"> The
///               advertisements are installing or the product is installing or updating. </td> </tr> <tr> <td width="40%"><a
///               id="MSIRUNMODE_MAINTENANCE"></a><a id="msirunmode_maintenance"></a><dl> <dt><b>MSIRUNMODE_MAINTENANCE</b></dt>
///               </dl> </td> <td width="60%"> An existing installation is being modified or there is a new installation. </td>
///               </tr> <tr> <td width="40%"><a id="MSIRUNMODE_ROLLBACKENABLED"></a><a id="msirunmode_rollbackenabled"></a><dl>
///               <dt><b>MSIRUNMODE_ROLLBACKENABLED</b></dt> </dl> </td> <td width="60%"> Rollback is enabled. </td> </tr> <tr> <td
///               width="40%"><a id="MSIRUNMODE_LOGENABLED"></a><a id="msirunmode_logenabled"></a><dl>
///               <dt><b>MSIRUNMODE_LOGENABLED</b></dt> </dl> </td> <td width="60%"> The log file is active. It was enabled prior
///               to the installation session. </td> </tr> <tr> <td width="40%"><a id="MSIRUNMODE_OPERATIONS"></a><a
///               id="msirunmode_operations"></a><dl> <dt><b>MSIRUNMODE_OPERATIONS</b></dt> </dl> </td> <td width="60%"> Execute
///               operations are in the determination phase. </td> </tr> <tr> <td width="40%"><a id="MSIRUNMODE_REBOOTATEND"></a><a
///               id="msirunmode_rebootatend"></a><dl> <dt><b>MSIRUNMODE_REBOOTATEND</b></dt> </dl> </td> <td width="60%"> A reboot
///               is necessary after a successful installation (settable). </td> </tr> <tr> <td width="40%"><a
///               id="MSIRUNMODE_REBOOTNOW"></a><a id="msirunmode_rebootnow"></a><dl> <dt><b>MSIRUNMODE_REBOOTNOW</b></dt> </dl>
///               </td> <td width="60%"> A reboot is necessary to continue the installation (settable). </td> </tr> <tr> <td
///               width="40%"><a id="MSIRUNMODE_CABINET"></a><a id="msirunmode_cabinet"></a><dl> <dt><b>MSIRUNMODE_CABINET</b></dt>
///               </dl> </td> <td width="60%"> Files from cabinets and Media table files are installing. </td> </tr> <tr> <td
///               width="40%"><a id="MSIRUNMODE_SOURCESHORTNAMES"></a><a id="msirunmode_sourceshortnames"></a><dl>
///               <dt><b>MSIRUNMODE_SOURCESHORTNAMES</b></dt> </dl> </td> <td width="60%"> The source LongFileNames is suppressed
///               through the PID_MSISOURCE summary property. </td> </tr> <tr> <td width="40%"><a
///               id="MSIRUNMODE_TARGETSHORTNAMES"></a><a id="msirunmode_targetshortnames"></a><dl>
///               <dt><b>MSIRUNMODE_TARGETSHORTNAMES</b></dt> </dl> </td> <td width="60%"> The target LongFileNames is suppressed
///               through the SHORTFILENAMES property. </td> </tr> <tr> <td width="40%"><a id="MSIRUNMODE_RESERVED11"></a><a
///               id="msirunmode_reserved11"></a><dl> <dt><b>MSIRUNMODE_RESERVED11</b></dt> </dl> </td> <td width="60%"> Reserved
///               for future use. </td> </tr> <tr> <td width="40%"><a id="MSIRUNMODE_WINDOWS9X"></a><a
///               id="msirunmode_windows9x"></a><dl> <dt><b>MSIRUNMODE_WINDOWS9X</b></dt> </dl> </td> <td width="60%"> The
///               operating system is a 9x version. </td> </tr> <tr> <td width="40%"><a id="MSIRUNMODE_ZAWENABLED"></a><a
///               id="msirunmode_zawenabled"></a><dl> <dt><b>MSIRUNMODE_ZAWENABLED</b></dt> </dl> </td> <td width="60%"> The
///               operating system supports demand installation. </td> </tr> <tr> <td width="40%"><a
///               id="MSIRUNMODE_RESERVED14"></a><a id="msirunmode_reserved14"></a><dl> <dt><b>MSIRUNMODE_RESERVED14</b></dt> </dl>
///               </td> <td width="60%"> Reserved for future use. </td> </tr> <tr> <td width="40%"><a
///               id="MSIRUNMODE_RESERVED15"></a><a id="msirunmode_reserved15"></a><dl> <dt><b>MSIRUNMODE_RESERVED15</b></dt> </dl>
///               </td> <td width="60%"> Reserved for future use. </td> </tr> <tr> <td width="40%"><a
///               id="MSIRUNMODE_SCHEDULED"></a><a id="msirunmode_scheduled"></a><dl> <dt><b>MSIRUNMODE_SCHEDULED</b></dt> </dl>
///               </td> <td width="60%"> A custom action called from install script execution. </td> </tr> <tr> <td width="40%"><a
///               id="MSIRUNMODE_ROLLBACK"></a><a id="msirunmode_rollback"></a><dl> <dt><b>MSIRUNMODE_ROLLBACK</b></dt> </dl> </td>
///               <td width="60%"> A custom action called from rollback execution script. </td> </tr> <tr> <td width="40%"><a
///               id="MSIRUNMODE_COMMIT"></a><a id="msirunmode_commit"></a><dl> <dt><b>MSIRUNMODE_COMMIT</b></dt> </dl> </td> <td
///               width="60%"> A custom action called from commit execution script. </td> </tr> </table>
///Returns:
///    <b>TRUE</b> indicates the specific property passed into the function is currently set. <b>FALSE</b> indicates the
///    specific property passed into the function is currently not set.
///    
@DllImport("msi")
BOOL MsiGetMode(uint hInstall, MSIRUNMODE eRunMode);

///The <b>MsiSetMode</b> function sets an internal engine Boolean state.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    eRunMode = Specifies the run mode. This parameter must be one of the following values. While there are many values for this
///               parameter, as described in MsiGetMode, only one of the following values can be set. <table> <tr> <th>Value</th>
///               <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MSIRUNMODE_REBOOTATEND"></a><a
///               id="msirunmode_rebootatend"></a><dl> <dt><b>MSIRUNMODE_REBOOTATEND</b></dt> </dl> </td> <td width="60%"> A reboot
///               is necessary after a successful installation. </td> </tr> <tr> <td width="40%"><a
///               id="MSIRUNMODE_REBOOTNOW"></a><a id="msirunmode_rebootnow"></a><dl> <dt><b>MSIRUNMODE_REBOOTNOW</b></dt> </dl>
///               </td> <td width="60%"> A reboot is necessary to continue installation. </td> </tr> </table>
///    fState = Specifies the state to set to <b>TRUE</b> or <b>FALSE</b>.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiSetMode(uint hInstall, MSIRUNMODE eRunMode, BOOL fState);

///The <b>MsiFormatRecord</b> function formats record field data and properties using a format string.
///Params:
///    hInstall = Handle to the installation. This may be omitted, in which case only the record field parameters are processed and
///               properties are not available for substitution.
///    hRecord = Handle to the record to format. The template string must be stored in record field 0 followed by referenced data
///              parameters.
///    szResultBuf = Pointer to the buffer that receives the null terminated formatted string. Do not attempt to determine the size of
///                  the buffer by passing in a null (value=0) for <i>szResultBuf</i>. You can get the size of the buffer by passing
///                  in an empty string (for example ""). The function then returns <b>ERROR_MORE_DATA</b> and <i>pcchResultBuf</i>
///                  contains the required buffer size in <b>TCHAR</b>s, not including the terminating null character. On return of
///                  <b>ERROR_SUCCESS</b>, <i>pcchResultBuf</i> contains the number of <b>TCHAR</b>s written to the buffer, not
///                  including the terminating null character.
///    pcchResultBuf = Pointer to the variable that specifies the size, in <b>TCHAR</b>s, of the buffer pointed to by the variable
///                    <i>szResultBuf</i>. When the function returns <b>ERROR_SUCCESS</b>, this variable contains the size of the data
///                    copied to <i>szResultBuf</i>, not including the terminating null character. If <i>szResultBuf</i> is not large
///                    enough, the function returns <b>ERROR_MORE_DATA</b> and stores the required size, not including the terminating
///                    null character, in the variable pointed to by <i>pcchResultBuf</i>.
///Returns:
///    The <b>MsiFormatRecord</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiFormatRecordA(uint hInstall, uint hRecord, const(char)* szResultBuf, uint* pcchResultBuf);

///The <b>MsiFormatRecord</b> function formats record field data and properties using a format string.
///Params:
///    hInstall = Handle to the installation. This may be omitted, in which case only the record field parameters are processed and
///               properties are not available for substitution.
///    hRecord = Handle to the record to format. The template string must be stored in record field 0 followed by referenced data
///              parameters.
///    szResultBuf = Pointer to the buffer that receives the null terminated formatted string. Do not attempt to determine the size of
///                  the buffer by passing in a null (value=0) for <i>szResultBuf</i>. You can get the size of the buffer by passing
///                  in an empty string (for example ""). The function then returns <b>ERROR_MORE_DATA</b> and <i>pcchResultBuf</i>
///                  contains the required buffer size in <b>TCHAR</b>s, not including the terminating null character. On return of
///                  <b>ERROR_SUCCESS</b>, <i>pcchResultBuf</i> contains the number of <b>TCHAR</b>s written to the buffer, not
///                  including the terminating null character.
///    pcchResultBuf = Pointer to the variable that specifies the size, in <b>TCHAR</b>s, of the buffer pointed to by the variable
///                    <i>szResultBuf</i>. When the function returns <b>ERROR_SUCCESS</b>, this variable contains the size of the data
///                    copied to <i>szResultBuf</i>, not including the terminating null character. If <i>szResultBuf</i> is not large
///                    enough, the function returns <b>ERROR_MORE_DATA</b> and stores the required size, not including the terminating
///                    null character, in the variable pointed to by <i>pcchResultBuf</i>.
///Returns:
///    The <b>MsiFormatRecord</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiFormatRecordW(uint hInstall, uint hRecord, const(wchar)* szResultBuf, uint* pcchResultBuf);

///The <b>MsiDoAction</b> function executes a built-in action, custom action, or user-interface wizard action.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szAction = Specifies the action to execute.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiDoActionA(uint hInstall, const(char)* szAction);

///The <b>MsiDoAction</b> function executes a built-in action, custom action, or user-interface wizard action.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szAction = Specifies the action to execute.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiDoActionW(uint hInstall, const(wchar)* szAction);

///The <b>MsiSequence</b> function executes another action sequence, as described in the specified table.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szTable = Specifies the name of the table containing the action sequence.
///    iSequenceMode = This parameter is currently unimplemented. It is reserved for future use and must be 0.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiSequenceA(uint hInstall, const(char)* szTable, int iSequenceMode);

///The <b>MsiSequence</b> function executes another action sequence, as described in the specified table.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szTable = Specifies the name of the table containing the action sequence.
///    iSequenceMode = This parameter is currently unimplemented. It is reserved for future use and must be 0.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiSequenceW(uint hInstall, const(wchar)* szTable, int iSequenceMode);

///The <b>MsiProcessMessage</b> function sends an error record to the installer for processing.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    eMessageType = The <i>eMessage</i> parameter must be a value specifying one of the following message types. To display a message
///                   box with push buttons or icons, use OR-operators to add INSTALLMESSAGE_ERROR, INSTALLMESSAGE_WARNING, or
///                   INSTALLMESSAGE_USER to the standard message box styles used by the MessageBox and MessageBoxEx functions. For
///                   more information, see the Remarks below. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                   width="40%"><a id="INSTALLMESSAGE_FATALEXIT"></a><a id="installmessage_fatalexit"></a><dl>
///                   <dt><b>INSTALLMESSAGE_FATALEXIT</b></dt> </dl> </td> <td width="60%"> Premature termination, possibly fatal out
///                   of memory. </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_ERROR"></a><a
///                   id="installmessage_error"></a><dl> <dt><b>INSTALLMESSAGE_ERROR</b></dt> </dl> </td> <td width="60%"> Formatted
///                   error message,<div> </div>[1] is message number in Error table. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_WARNING"></a><a id="installmessage_warning"></a><dl> <dt><b>INSTALLMESSAGE_WARNING</b></dt>
///                   </dl> </td> <td width="60%"> Formatted warning message,<div> </div>[1] is message number in Error table. </td>
///                   </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_USER"></a><a id="installmessage_user"></a><dl>
///                   <dt><b>INSTALLMESSAGE_USER</b></dt> </dl> </td> <td width="60%"> User request message,<div> </div>[1] is message
///                   number in Error table. </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_INFO"></a><a
///                   id="installmessage_info"></a><dl> <dt><b>INSTALLMESSAGE_INFO</b></dt> </dl> </td> <td width="60%"> Informative
///                   message for log,<div> </div>not to be displayed. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_FILESINUSE"></a><a id="installmessage_filesinuse"></a><dl>
///                   <dt><b>INSTALLMESSAGE_FILESINUSE</b></dt> </dl> </td> <td width="60%"> List of files currently in use that must
///                   be closed before being replaced. </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_RESOLVESOURCE"></a><a
///                   id="installmessage_resolvesource"></a><dl> <dt><b>INSTALLMESSAGE_RESOLVESOURCE</b></dt> </dl> </td> <td
///                   width="60%"> Request to determine a valid source location. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_RMFILESINUSE"></a><a id="installmessage_rmfilesinuse"></a><dl>
///                   <dt><b>INSTALLMESSAGE_RMFILESINUSE</b></dt> </dl> </td> <td width="60%"> List of files currently in use that must
///                   be closed before being replaced. Available beginning with Windows Installer version 4.0. For more information
///                   about this message see Using Restart Manager with an External UI. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_OUTOFDISKSPACE"></a><a id="installmessage_outofdiskspace"></a><dl>
///                   <dt><b>INSTALLMESSAGE_OUTOFDISKSPACE</b></dt> </dl> </td> <td width="60%"> Insufficient disk space message. </td>
///                   </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_ACTIONSTART"></a><a id="installmessage_actionstart"></a><dl>
///                   <dt><b>INSTALLMESSAGE_ACTIONSTART</b></dt> </dl> </td> <td width="60%"> Progress: start of action,<div> </div>[1]
///                   action name,<div> </div>[2] description,<div> </div>[3] template for ACTIONDATA messages. </td> </tr> <tr> <td
///                   width="40%"><a id="INSTALLMESSAGE_ACTIONDATA"></a><a id="installmessage_actiondata"></a><dl>
///                   <dt><b>INSTALLMESSAGE_ACTIONDATA</b></dt> </dl> </td> <td width="60%"> Action data. Record fields correspond to
///                   the template of ACTIONSTART message. </td> </tr> <tr> <td width="40%"><a id="INSTALLMESSAGE_PROGRESS"></a><a
///                   id="installmessage_progress"></a><dl> <dt><b>INSTALLMESSAGE_PROGRESS</b></dt> </dl> </td> <td width="60%">
///                   Progress bar information. See the description of record fields below. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLMESSAGE_COMMONDATA"></a><a id="installmessage_commondata"></a><dl>
///                   <dt><b>INSTALLMESSAGE_COMMONDATA</b></dt> </dl> </td> <td width="60%"> To enable the Cancel button set [1] to 2
///                   and [2] to 1. To disable the Cancel button set [1] to 2 and [2] to 0 </td> </tr> </table>
///    hRecord = Handle to a record containing message format and data.
///Returns:
///    This function returns int.
///    
@DllImport("msi")
int MsiProcessMessage(uint hInstall, INSTALLMESSAGE eMessageType, uint hRecord);

///The <b>MsiEvaluateCondition</b> function evaluates a conditional expression containing property names and values.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szCondition = Specifies the conditional expression. This parameter must not be <b>NULL</b>. For the syntax of conditional
///                  expressions see Conditional Statement Syntax.
///Returns:
///    This function returns MSICONDITION.
///    
@DllImport("msi")
MSICONDITION MsiEvaluateConditionA(uint hInstall, const(char)* szCondition);

///The <b>MsiEvaluateCondition</b> function evaluates a conditional expression containing property names and values.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szCondition = Specifies the conditional expression. This parameter must not be <b>NULL</b>. For the syntax of conditional
///                  expressions see Conditional Statement Syntax.
///Returns:
///    This function returns MSICONDITION.
///    
@DllImport("msi")
MSICONDITION MsiEvaluateConditionW(uint hInstall, const(wchar)* szCondition);

///The <b>MsiGetFeatureState</b> function gets the requested state of a feature.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFeature = Specifies the feature name within the product.
///    piInstalled = Specifies the returned current installed state. This parameter must not be null. This parameter can be one of the
///                  following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_BADCONFIG"></a><a id="installstate_badconfig"></a><dl> <dt><b>INSTALLSTATE_BADCONFIG</b></dt>
///                  </dl> </td> <td width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_INCOMPLETE"></a><a id="installstate_incomplete"></a><dl> <dt><b>INSTALLSTATE_INCOMPLETE</b></dt>
///                  </dl> </td> <td width="60%"> The installation is suspended or in progress. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_SOURCEABSENT"></a><a id="installstate_sourceabsent"></a><dl>
///                  <dt><b>INSTALLSTATE_SOURCEABSENT</b></dt> </dl> </td> <td width="60%"> The feature must run from the source, and
///                  the source is unavailable. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_MOREDATA"></a><a
///                  id="installstate_moredata"></a><dl> <dt><b>INSTALLSTATE_MOREDATA</b></dt> </dl> </td> <td width="60%"> The return
///                  buffer is full. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_INVALIDARG"></a><a
///                  id="installstate_invalidarg"></a><dl> <dt><b>INSTALLSTATE_INVALIDARG</b></dt> </dl> </td> <td width="60%"> An
///                  invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_UNKNOWN"></a><a id="installstate_unknown"></a><dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl>
///                  </td> <td width="60%"> An unrecognized product or feature was specified. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_BROKEN"></a><a id="installstate_broken"></a><dl> <dt><b>INSTALLSTATE_BROKEN</b></dt> </dl> </td>
///                  <td width="60%"> The feature is broken. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ADVERTISED"></a><a
///                  id="installstate_advertised"></a><dl> <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The
///                  advertised feature. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ABSENT"></a><a
///                  id="installstate_absent"></a><dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> The feature
///                  was uninstalled. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a
///                  id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The feature was
///                  installed on the local drive. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a
///                  id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The feature
///                  must run from the source, CD-ROM, or network. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_DEFAULT"></a><a id="installstate_default"></a><dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl>
///                  </td> <td width="60%"> The feature is installed in the default location: local or source. </td> </tr> </table>
///    piAction = Receives the action taken during the installation session. This parameter must not be null. For return values,
///               see <i>piInstalled</i>.
///Returns:
///    The <b>MsiGetFeatureState</b> function returns the following values:
///    
@DllImport("msi")
uint MsiGetFeatureStateA(uint hInstall, const(char)* szFeature, INSTALLSTATE* piInstalled, INSTALLSTATE* piAction);

///The <b>MsiGetFeatureState</b> function gets the requested state of a feature.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFeature = Specifies the feature name within the product.
///    piInstalled = Specifies the returned current installed state. This parameter must not be null. This parameter can be one of the
///                  following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_BADCONFIG"></a><a id="installstate_badconfig"></a><dl> <dt><b>INSTALLSTATE_BADCONFIG</b></dt>
///                  </dl> </td> <td width="60%"> The configuration data is corrupt. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_INCOMPLETE"></a><a id="installstate_incomplete"></a><dl> <dt><b>INSTALLSTATE_INCOMPLETE</b></dt>
///                  </dl> </td> <td width="60%"> The installation is suspended or in progress. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_SOURCEABSENT"></a><a id="installstate_sourceabsent"></a><dl>
///                  <dt><b>INSTALLSTATE_SOURCEABSENT</b></dt> </dl> </td> <td width="60%"> The feature must run from the source, and
///                  the source is unavailable. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_MOREDATA"></a><a
///                  id="installstate_moredata"></a><dl> <dt><b>INSTALLSTATE_MOREDATA</b></dt> </dl> </td> <td width="60%"> The return
///                  buffer is full. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_INVALIDARG"></a><a
///                  id="installstate_invalidarg"></a><dl> <dt><b>INSTALLSTATE_INVALIDARG</b></dt> </dl> </td> <td width="60%"> An
///                  invalid parameter was passed to the function. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_UNKNOWN"></a><a id="installstate_unknown"></a><dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl>
///                  </td> <td width="60%"> An unrecognized product or feature was specified. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_BROKEN"></a><a id="installstate_broken"></a><dl> <dt><b>INSTALLSTATE_BROKEN</b></dt> </dl> </td>
///                  <td width="60%"> The feature is broken. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ADVERTISED"></a><a
///                  id="installstate_advertised"></a><dl> <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The
///                  advertised feature. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ABSENT"></a><a
///                  id="installstate_absent"></a><dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> The feature
///                  was uninstalled. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a
///                  id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The feature was
///                  installed on the local drive. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a
///                  id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The feature
///                  must run from the source, CD-ROM, or network. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_DEFAULT"></a><a id="installstate_default"></a><dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl>
///                  </td> <td width="60%"> The feature is installed in the default location: local or source. </td> </tr> </table>
///    piAction = Receives the action taken during the installation session. This parameter must not be null. For return values,
///               see <i>piInstalled</i>.
///Returns:
///    The <b>MsiGetFeatureState</b> function returns the following values:
///    
@DllImport("msi")
uint MsiGetFeatureStateW(uint hInstall, const(wchar)* szFeature, INSTALLSTATE* piInstalled, INSTALLSTATE* piAction);

///The <b>MsiSetFeatureState</b> function sets a feature to a specified state.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFeature = Specifies the name of the feature.
///    iState = Specifies the state to set. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ABSENT"></a><a id="installstate_absent"></a><dl>
///             <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> The feature is not installed. </td> </tr> <tr>
///             <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a id="installstate_local"></a><dl>
///             <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The feature is installed on the local drive.
///             </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a id="installstate_source"></a><dl>
///             <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The feature is run from the source, CD, or
///             network. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ADVERTISED"></a><a
///             id="installstate_advertised"></a><dl> <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The
///             feature is advertised. </td> </tr> </table>
///Returns:
///    The <b>MsiSetFeatureState</b> function returns the following values:
///    
@DllImport("msi")
uint MsiSetFeatureStateA(uint hInstall, const(char)* szFeature, INSTALLSTATE iState);

///The <b>MsiSetFeatureState</b> function sets a feature to a specified state.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFeature = Specifies the name of the feature.
///    iState = Specifies the state to set. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ABSENT"></a><a id="installstate_absent"></a><dl>
///             <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> The feature is not installed. </td> </tr> <tr>
///             <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a id="installstate_local"></a><dl>
///             <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The feature is installed on the local drive.
///             </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a id="installstate_source"></a><dl>
///             <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The feature is run from the source, CD, or
///             network. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ADVERTISED"></a><a
///             id="installstate_advertised"></a><dl> <dt><b>INSTALLSTATE_ADVERTISED</b></dt> </dl> </td> <td width="60%"> The
///             feature is advertised. </td> </tr> </table>
///Returns:
///    The <b>MsiSetFeatureState</b> function returns the following values:
///    
@DllImport("msi")
uint MsiSetFeatureStateW(uint hInstall, const(wchar)* szFeature, INSTALLSTATE iState);

///The <b>MsiSetFeatureAttributes</b> function can modify the default attributes of a feature at runtime. Note that the
///default attributes of features are authored in the Attributes column of the Feature table.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFeature = Specifies the feature name within the product.
///    dwAttributes = Feature attributes specified at run time as a set of bit flags: <table> <tr> <th>Constant</th> <th>Meaning</th>
///                   </tr> <tr> <td width="40%"><a id="INSTALLFEATUREATTRIBUTE_FAVORLOCAL"></a><a
///                   id="installfeatureattribute_favorlocal"></a><dl> <dt><b>INSTALLFEATUREATTRIBUTE_FAVORLOCAL</b></dt> <dt>1</dt>
///                   </dl> </td> <td width="60%"> Modifies default feature attributes to msidbFeatureAttributesFavorLocal at run time.
///                   See Attributes column of the Feature table for a description. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLFEATUREATTRIBUTE_FAVORSOURCE"></a><a id="installfeatureattribute_favorsource"></a><dl>
///                   <dt><b>INSTALLFEATUREATTRIBUTE_FAVORSOURCE</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Modifies default
///                   feature attributes to msidbFeatureAttributesFavorSource at run time. See Attributes column of the Feature table
///                   for a description. </td> </tr> <tr> <td width="40%"><a id="INSTALLFEATUREATTRIBUTE_FOLLOWPARENT"></a><a
///                   id="installfeatureattribute_followparent"></a><dl> <dt><b>INSTALLFEATUREATTRIBUTE_FOLLOWPARENT</b></dt>
///                   <dt>4</dt> </dl> </td> <td width="60%"> Modifies default feature attributes to msidbFeatureAttributesFollowParent
///                   at run time. Note that this is not a valid attribute to be set for top-level features. See Attributes column of
///                   the Feature table for a description. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLFEATUREATTRIBUTE_FAVORADVERTISE"></a><a id="installfeatureattribute_favoradvertise"></a><dl>
///                   <dt><b>INSTALLFEATUREATTRIBUTE_FAVORADVERTISE</b></dt> <dt>8</dt> </dl> </td> <td width="60%"> Modifies default
///                   feature attributes to msidbFeatureAttributesFavorAdvertise at run time. See Attributes column of the Feature
///                   table for a description. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE"></a><a id="installfeatureattribute_disallowadvertise"></a><dl>
///                   <dt><b>INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE</b></dt> <dt>16</dt> </dl> </td> <td width="60%"> Modifies
///                   default feature attributes to msidbFeatureAttributesDisallowAdvertise at run time. See Attributes column of the
///                   Feature table for a description. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE"></a><a
///                   id="installfeatureattribute_nounsupportedadvertise"></a><dl>
///                   <dt><b>INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE</b></dt> <dt>32</dt> </dl> </td> <td width="60%"> Modifies
///                   default feature attributes to msidbFeatureAttributesNoUnsupportedAdvertise at run time. See Attributes column of
///                   the Feature table for a description. </td> </tr> </table>
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiSetFeatureAttributesA(uint hInstall, const(char)* szFeature, uint dwAttributes);

///The <b>MsiSetFeatureAttributes</b> function can modify the default attributes of a feature at runtime. Note that the
///default attributes of features are authored in the Attributes column of the Feature table.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFeature = Specifies the feature name within the product.
///    dwAttributes = Feature attributes specified at run time as a set of bit flags: <table> <tr> <th>Constant</th> <th>Meaning</th>
///                   </tr> <tr> <td width="40%"><a id="INSTALLFEATUREATTRIBUTE_FAVORLOCAL"></a><a
///                   id="installfeatureattribute_favorlocal"></a><dl> <dt><b>INSTALLFEATUREATTRIBUTE_FAVORLOCAL</b></dt> <dt>1</dt>
///                   </dl> </td> <td width="60%"> Modifies default feature attributes to msidbFeatureAttributesFavorLocal at run time.
///                   See Attributes column of the Feature table for a description. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLFEATUREATTRIBUTE_FAVORSOURCE"></a><a id="installfeatureattribute_favorsource"></a><dl>
///                   <dt><b>INSTALLFEATUREATTRIBUTE_FAVORSOURCE</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Modifies default
///                   feature attributes to msidbFeatureAttributesFavorSource at run time. See Attributes column of the Feature table
///                   for a description. </td> </tr> <tr> <td width="40%"><a id="INSTALLFEATUREATTRIBUTE_FOLLOWPARENT"></a><a
///                   id="installfeatureattribute_followparent"></a><dl> <dt><b>INSTALLFEATUREATTRIBUTE_FOLLOWPARENT</b></dt>
///                   <dt>4</dt> </dl> </td> <td width="60%"> Modifies default feature attributes to msidbFeatureAttributesFollowParent
///                   at run time. Note that this is not a valid attribute to be set for top-level features. See Attributes column of
///                   the Feature table for a description. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLFEATUREATTRIBUTE_FAVORADVERTISE"></a><a id="installfeatureattribute_favoradvertise"></a><dl>
///                   <dt><b>INSTALLFEATUREATTRIBUTE_FAVORADVERTISE</b></dt> <dt>8</dt> </dl> </td> <td width="60%"> Modifies default
///                   feature attributes to msidbFeatureAttributesFavorAdvertise at run time. See Attributes column of the Feature
///                   table for a description. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE"></a><a id="installfeatureattribute_disallowadvertise"></a><dl>
///                   <dt><b>INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE</b></dt> <dt>16</dt> </dl> </td> <td width="60%"> Modifies
///                   default feature attributes to msidbFeatureAttributesDisallowAdvertise at run time. See Attributes column of the
///                   Feature table for a description. </td> </tr> <tr> <td width="40%"><a
///                   id="INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE"></a><a
///                   id="installfeatureattribute_nounsupportedadvertise"></a><dl>
///                   <dt><b>INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE</b></dt> <dt>32</dt> </dl> </td> <td width="60%"> Modifies
///                   default feature attributes to msidbFeatureAttributesNoUnsupportedAdvertise at run time. See Attributes column of
///                   the Feature table for a description. </td> </tr> </table>
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiSetFeatureAttributesW(uint hInstall, const(wchar)* szFeature, uint dwAttributes);

///The <b>MsiGetComponentState</b> function obtains the state of a component.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szComponent = A null-terminated string that specifies the component name within the product.
///    piInstalled = Receives the current installed state. This parameter must not be null. This parameter can be one of the following
///                  values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_ABSENT"></a><a id="installstate_absent"></a><dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td>
///                  <td width="60%"> The component is not installed. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_DEFAULT"></a><a id="installstate_default"></a><dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl>
///                  </td> <td width="60%"> The component is installed in the default location: local or source. </td> </tr> <tr> <td
///                  width="40%"><a id="INSTALLSTATE_LOCAL"></a><a id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt>
///                  </dl> </td> <td width="60%"> The component is installed on the local drive. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_REMOVED"></a><a id="installstate_removed"></a><dl> <dt><b>INSTALLSTATE_REMOVED</b></dt> </dl>
///                  </td> <td width="60%"> The component is being removed. In action state and not settable. </td> </tr> <tr> <td
///                  width="40%"><a id="INSTALLSTATE_SOURCE"></a><a id="installstate_source"></a><dl>
///                  <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The component runs from the source, CD-ROM, or
///                  network. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_UNKNOWN"></a><a id="installstate_unknown"></a><dl>
///                  <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> An unrecognized product or feature name was
///                  passed to the function. </td> </tr> </table>
///    piAction = Receives the action taken during the installation. This parameter must not be null. For return values, see
///               <i>piInstalled</i>.
///Returns:
///    The <b>MsiGetComponentState</b> function returns the following values:
///    
@DllImport("msi")
uint MsiGetComponentStateA(uint hInstall, const(char)* szComponent, INSTALLSTATE* piInstalled, 
                           INSTALLSTATE* piAction);

///The <b>MsiGetComponentState</b> function obtains the state of a component.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szComponent = A null-terminated string that specifies the component name within the product.
///    piInstalled = Receives the current installed state. This parameter must not be null. This parameter can be one of the following
///                  values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_ABSENT"></a><a id="installstate_absent"></a><dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td>
///                  <td width="60%"> The component is not installed. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_DEFAULT"></a><a id="installstate_default"></a><dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl>
///                  </td> <td width="60%"> The component is installed in the default location: local or source. </td> </tr> <tr> <td
///                  width="40%"><a id="INSTALLSTATE_LOCAL"></a><a id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt>
///                  </dl> </td> <td width="60%"> The component is installed on the local drive. </td> </tr> <tr> <td width="40%"><a
///                  id="INSTALLSTATE_REMOVED"></a><a id="installstate_removed"></a><dl> <dt><b>INSTALLSTATE_REMOVED</b></dt> </dl>
///                  </td> <td width="60%"> The component is being removed. In action state and not settable. </td> </tr> <tr> <td
///                  width="40%"><a id="INSTALLSTATE_SOURCE"></a><a id="installstate_source"></a><dl>
///                  <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The component runs from the source, CD-ROM, or
///                  network. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_UNKNOWN"></a><a id="installstate_unknown"></a><dl>
///                  <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> An unrecognized product or feature name was
///                  passed to the function. </td> </tr> </table>
///    piAction = Receives the action taken during the installation. This parameter must not be null. For return values, see
///               <i>piInstalled</i>.
///Returns:
///    The <b>MsiGetComponentState</b> function returns the following values:
///    
@DllImport("msi")
uint MsiGetComponentStateW(uint hInstall, const(wchar)* szComponent, INSTALLSTATE* piInstalled, 
                           INSTALLSTATE* piAction);

///The <b>MsiSetComponentState</b> function sets a component to the requested state.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szComponent = Specifies the name of the component.
///    iState = Specifies the state to set. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ABSENT"></a><a id="installstate_absent"></a><dl>
///             <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> The component was uninstalled. </td> </tr> <tr>
///             <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a id="installstate_local"></a><dl>
///             <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The component was installed on the local drive.
///             </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a id="installstate_source"></a><dl>
///             <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The component will run from source, CD, or
///             network. </td> </tr> </table>
///Returns:
///    The <b>MsiSetComponentState</b> function returns the following values:
///    
@DllImport("msi")
uint MsiSetComponentStateA(uint hInstall, const(char)* szComponent, INSTALLSTATE iState);

///The <b>MsiSetComponentState</b> function sets a component to the requested state.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szComponent = Specifies the name of the component.
///    iState = Specifies the state to set. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ABSENT"></a><a id="installstate_absent"></a><dl>
///             <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> The component was uninstalled. </td> </tr> <tr>
///             <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a id="installstate_local"></a><dl>
///             <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The component was installed on the local drive.
///             </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a id="installstate_source"></a><dl>
///             <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The component will run from source, CD, or
///             network. </td> </tr> </table>
///Returns:
///    The <b>MsiSetComponentState</b> function returns the following values:
///    
@DllImport("msi")
uint MsiSetComponentStateW(uint hInstall, const(wchar)* szComponent, INSTALLSTATE iState);

///The <b>MsiGetFeatureCost</b> function returns the disk space required by a feature and its selected children and
///parent features.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFeature = Specifies the name of the feature.
///    iCostTree = Specifies the value the function uses to determine disk space requirements. This parameter can be one of the
///                following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSICOSTTREE_CHILDREN"></a><a id="msicosttree_children"></a><dl> <dt><b>MSICOSTTREE_CHILDREN</b></dt> </dl>
///                </td> <td width="60%"> The children of the indicated feature are included in the cost. </td> </tr> <tr> <td
///                width="40%"><a id="MSICOSTTREE_PARENTS"></a><a id="msicosttree_parents"></a><dl>
///                <dt><b>MSICOSTTREE_PARENTS</b></dt> </dl> </td> <td width="60%"> The parent features of the indicated feature are
///                included in the cost. </td> </tr> <tr> <td width="40%"><a id="MSICOSTTREE_SELFONLY"></a><a
///                id="msicosttree_selfonly"></a><dl> <dt><b>MSICOSTTREE_SELFONLY</b></dt> </dl> </td> <td width="60%"> The feature
///                only is included in the cost. </td> </tr> </table>
///    iState = Specifies the installation state. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_UNKNOWN"></a><a
///             id="installstate_unknown"></a><dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> The product
///             or feature is unrecognized. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ABSENT"></a><a
///             id="installstate_absent"></a><dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> The product or
///             feature is uninstalled. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a
///             id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The product or
///             feature is installed on the local drive. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a
///             id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The product or
///             feature is installed to run from source, CD, or network. </td> </tr> <tr> <td width="40%"><a
///             id="INSTALLSTATE_DEFAULT"></a><a id="installstate_default"></a><dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl>
///             </td> <td width="60%"> The product or feature will be installed to use the default location: local or source.
///             </td> </tr> </table>
///    piCost = Receives the disk space requirements in units of 512 bytes. This parameter must not be null.
///Returns:
///    The <b>MsiGetFeatureCost</b> function returns the following values:
///    
@DllImport("msi")
uint MsiGetFeatureCostA(uint hInstall, const(char)* szFeature, MSICOSTTREE iCostTree, INSTALLSTATE iState, 
                        int* piCost);

///The <b>MsiGetFeatureCost</b> function returns the disk space required by a feature and its selected children and
///parent features.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFeature = Specifies the name of the feature.
///    iCostTree = Specifies the value the function uses to determine disk space requirements. This parameter can be one of the
///                following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="MSICOSTTREE_CHILDREN"></a><a id="msicosttree_children"></a><dl> <dt><b>MSICOSTTREE_CHILDREN</b></dt> </dl>
///                </td> <td width="60%"> The children of the indicated feature are included in the cost. </td> </tr> <tr> <td
///                width="40%"><a id="MSICOSTTREE_PARENTS"></a><a id="msicosttree_parents"></a><dl>
///                <dt><b>MSICOSTTREE_PARENTS</b></dt> </dl> </td> <td width="60%"> The parent features of the indicated feature are
///                included in the cost. </td> </tr> <tr> <td width="40%"><a id="MSICOSTTREE_SELFONLY"></a><a
///                id="msicosttree_selfonly"></a><dl> <dt><b>MSICOSTTREE_SELFONLY</b></dt> </dl> </td> <td width="60%"> The feature
///                only is included in the cost. </td> </tr> </table>
///    iState = Specifies the installation state. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_UNKNOWN"></a><a
///             id="installstate_unknown"></a><dl> <dt><b>INSTALLSTATE_UNKNOWN</b></dt> </dl> </td> <td width="60%"> The product
///             or feature is unrecognized. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_ABSENT"></a><a
///             id="installstate_absent"></a><dl> <dt><b>INSTALLSTATE_ABSENT</b></dt> </dl> </td> <td width="60%"> The product or
///             feature is uninstalled. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_LOCAL"></a><a
///             id="installstate_local"></a><dl> <dt><b>INSTALLSTATE_LOCAL</b></dt> </dl> </td> <td width="60%"> The product or
///             feature is installed on the local drive. </td> </tr> <tr> <td width="40%"><a id="INSTALLSTATE_SOURCE"></a><a
///             id="installstate_source"></a><dl> <dt><b>INSTALLSTATE_SOURCE</b></dt> </dl> </td> <td width="60%"> The product or
///             feature is installed to run from source, CD, or network. </td> </tr> <tr> <td width="40%"><a
///             id="INSTALLSTATE_DEFAULT"></a><a id="installstate_default"></a><dl> <dt><b>INSTALLSTATE_DEFAULT</b></dt> </dl>
///             </td> <td width="60%"> The product or feature will be installed to use the default location: local or source.
///             </td> </tr> </table>
///    piCost = Receives the disk space requirements in units of 512 bytes. This parameter must not be null.
///Returns:
///    The <b>MsiGetFeatureCost</b> function returns the following values:
///    
@DllImport("msi")
uint MsiGetFeatureCostW(uint hInstall, const(wchar)* szFeature, MSICOSTTREE iCostTree, INSTALLSTATE iState, 
                        int* piCost);

///The <b>MsiEnumComponentCosts</b> function enumerates the disk-space per drive required to install a component. This
///information is needed to display the disk-space cost required for all drives in the user interface. The returned
///disk-space costs are expressed in multiples of 512 bytes. <b>MsiEnumComponentCosts</b> should only be run after the
///installer has completed file costing and after the CostFinalize action. For more information, see File Costing.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szComponent = A null-terminated string specifying the component's name as it is listed in the Component column of the Component
///                  table. This parameter can be null. If <i>szComponent</i> is null or an empty string, <b>MsiEnumComponentCosts</b>
///                  enumerates the total disk-space per drive used during the installation. In this case, <i>iState</i> is ignored.
///                  The costs of the installer include those costs for caching the database in the secure folder as well as the cost
///                  to create the installation script. Note that the total disk-space used during the installation may be larger than
///                  the space used after the component is installed.
///    dwIndex = 0-based index for drives. This parameter should be zero for the first call to the <b>MsiEnumComponentCosts</b>
///              function and then incremented for subsequent calls.
///    iState = Requested component state to be enumerated. If <i>szComponent</i> is passed as Null or an empty string, the
///             installer ignores the <i>iState</i> parameter.
///    szDriveBuf = Buffer that holds the drive name including the null terminator. This is an empty string in case of an error.
///    pcchDriveBuf = Pointer to a variable that specifies the size, in TCHARs, of the buffer pointed to by the <i>lpDriveBuf</i>
///                   parameter. This size should include the terminating null character. If the buffer provided is too small, the
///                   variable pointed to by <i>pcchDriveBuf</i> contains the count of characters not including the null terminator.
///    piCost = Cost of the component per drive expressed in multiples of 512 bytes. This value is 0 if an error has occurred.
///             The value returned in <i>piCost</i> is final disk-space used by the component after installation. If
///             <i>szComponent</i> is passed as Null or an empty string, the installer sets the value at <i>piCost</i> to 0.
///    piTempCost = The component cost per drive for the duration of the installation, or 0 if an error occurred. The value in
///                 *<i>piTempCost</i> represents the temporary space requirements for the duration of the installation. This
///                 temporary space requirement is space needed only for the duration of the installation. This does not affect the
///                 final disk space requirement.
///Returns:
///    <table> <tr> <th>Return Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_HANDLE_STATE</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
///    </dl> </td> <td width="60%"> There are no more drives to return. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was enumerated. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The component is missing.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_NOT_CALLED</b></dt> </dl> </td> <td width="60%">
///    Costing is not complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td
///    width="60%"> Buffer not large enough for the drive name. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> The supplied handle is invalid or inactive.
///    </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiEnumComponentCostsA(uint hInstall, const(char)* szComponent, uint dwIndex, INSTALLSTATE iState, 
                            const(char)* szDriveBuf, uint* pcchDriveBuf, int* piCost, int* piTempCost);

///The <b>MsiEnumComponentCosts</b> function enumerates the disk-space per drive required to install a component. This
///information is needed to display the disk-space cost required for all drives in the user interface. The returned
///disk-space costs are expressed in multiples of 512 bytes. <b>MsiEnumComponentCosts</b> should only be run after the
///installer has completed file costing and after the CostFinalize action. For more information, see File Costing.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szComponent = A null-terminated string specifying the component's name as it is listed in the Component column of the Component
///                  table. This parameter can be null. If <i>szComponent</i> is null or an empty string, <b>MsiEnumComponentCosts</b>
///                  enumerates the total disk-space per drive used during the installation. In this case, <i>iState</i> is ignored.
///                  The costs of the installer include those costs for caching the database in the secure folder as well as the cost
///                  to create the installation script. Note that the total disk-space used during the installation may be larger than
///                  the space used after the component is installed.
///    dwIndex = 0-based index for drives. This parameter should be zero for the first call to the <b>MsiEnumComponentCosts</b>
///              function and then incremented for subsequent calls.
///    iState = Requested component state to be enumerated. If <i>szComponent</i> is passed as Null or an empty string, the
///             installer ignores the <i>iState</i> parameter.
///    szDriveBuf = Buffer that holds the drive name including the null terminator. This is an empty string in case of an error.
///    pcchDriveBuf = Pointer to a variable that specifies the size, in TCHARs, of the buffer pointed to by the <i>lpDriveBuf</i>
///                   parameter. This size should include the terminating null character. If the buffer provided is too small, the
///                   variable pointed to by <i>pcchDriveBuf</i> contains the count of characters not including the null terminator.
///    piCost = Cost of the component per drive expressed in multiples of 512 bytes. This value is 0 if an error has occurred.
///             The value returned in <i>piCost</i> is final disk-space used by the component after installation. If
///             <i>szComponent</i> is passed as Null or an empty string, the installer sets the value at <i>piCost</i> to 0.
///    piTempCost = The component cost per drive for the duration of the installation, or 0 if an error occurred. The value in
///                 *<i>piTempCost</i> represents the temporary space requirements for the duration of the installation. This
///                 temporary space requirement is space needed only for the duration of the installation. This does not affect the
///                 final disk space requirement.
///Returns:
///    <table> <tr> <th>Return Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_HANDLE_STATE</b></dt> </dl> </td> <td width="60%"> The configuration data is corrupt. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid
///    parameter was passed to the function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
///    </dl> </td> <td width="60%"> There are no more drives to return. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> </dl> </td> <td width="60%"> A value was enumerated. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_UNKNOWN_COMPONENT</b></dt> </dl> </td> <td width="60%"> The component is missing.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_NOT_CALLED</b></dt> </dl> </td> <td width="60%">
///    Costing is not complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_MORE_DATA</b></dt> </dl> </td> <td
///    width="60%"> Buffer not large enough for the drive name. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> The supplied handle is invalid or inactive.
///    </td> </tr> </table> <div> </div>
///    
@DllImport("msi")
uint MsiEnumComponentCostsW(uint hInstall, const(wchar)* szComponent, uint dwIndex, INSTALLSTATE iState, 
                            const(wchar)* szDriveBuf, uint* pcchDriveBuf, int* piCost, int* piTempCost);

///The <b>MsiSetInstallLevel</b> function sets the installation level for a full product installation.
///Params:
///    hInstall = Handle to the installation that is provided to a DLL custom action or obtained by using MsiOpenPackage,
///               MsiOpenPackageEx, or MsiOpenProduct.
///    iInstallLevel = The installation level.
///Returns:
///    The <b>MsiSetInstallLevel</b> function returns one of the following values:
///    
@DllImport("msi")
uint MsiSetInstallLevel(uint hInstall, int iInstallLevel);

///The <b>MsiGetFeatureValidStates</b> function returns a valid installation state.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFeature = Specifies the feature name.
///    lpInstallStates = Receives the location to hold the valid installation states. For each valid installation state, the installer
///                      sets <i>pInstallState</i> to a combination of the following values. This parameter should not be null. <table>
///                      <tr> <th>Decimal Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="2"></a><dl> <dt><b>2</b></dt>
///                      <dt>INSTALLSTATE_ADVERTISED</dt> </dl> </td> <td width="60%"> The feature can be advertised. </td> </tr> <tr> <td
///                      width="40%"><a id="4"></a><dl> <dt><b>4</b></dt> <dt>INSTALLSTATE_ABSENT</dt> </dl> </td> <td width="60%"> The
///                      feature can be absent. </td> </tr> <tr> <td width="40%"><a id="8"></a><dl> <dt><b>8</b></dt>
///                      <dt>INSTALLSTATE_LOCAL</dt> </dl> </td> <td width="60%"> The feature can be installed on the local drive. </td>
///                      </tr> <tr> <td width="40%"><a id="16"></a><dl> <dt><b>16</b></dt> <dt>INSTALLSTATE_SOURCE</dt> </dl> </td> <td
///                      width="60%"> The feature can be configured to run from source, CD-ROM, or network. </td> </tr> <tr> <td
///                      width="40%"><a id="32"></a><dl> <dt><b>32</b></dt> <dt>INSTALLSTATE_DEFAULT</dt> </dl> </td> <td width="60%"> The
///                      feature can be configured to use the default location: local or source. </td> </tr> </table>
///Returns:
///    The <b>MsiGetFeatureValidStates</b> function returns the following values:
///    
@DllImport("msi")
uint MsiGetFeatureValidStatesA(uint hInstall, const(char)* szFeature, uint* lpInstallStates);

///The <b>MsiGetFeatureValidStates</b> function returns a valid installation state.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFeature = Specifies the feature name.
///    lpInstallStates = Receives the location to hold the valid installation states. For each valid installation state, the installer
///                      sets <i>pInstallState</i> to a combination of the following values. This parameter should not be null. <table>
///                      <tr> <th>Decimal Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="2"></a><dl> <dt><b>2</b></dt>
///                      <dt>INSTALLSTATE_ADVERTISED</dt> </dl> </td> <td width="60%"> The feature can be advertised. </td> </tr> <tr> <td
///                      width="40%"><a id="4"></a><dl> <dt><b>4</b></dt> <dt>INSTALLSTATE_ABSENT</dt> </dl> </td> <td width="60%"> The
///                      feature can be absent. </td> </tr> <tr> <td width="40%"><a id="8"></a><dl> <dt><b>8</b></dt>
///                      <dt>INSTALLSTATE_LOCAL</dt> </dl> </td> <td width="60%"> The feature can be installed on the local drive. </td>
///                      </tr> <tr> <td width="40%"><a id="16"></a><dl> <dt><b>16</b></dt> <dt>INSTALLSTATE_SOURCE</dt> </dl> </td> <td
///                      width="60%"> The feature can be configured to run from source, CD-ROM, or network. </td> </tr> <tr> <td
///                      width="40%"><a id="32"></a><dl> <dt><b>32</b></dt> <dt>INSTALLSTATE_DEFAULT</dt> </dl> </td> <td width="60%"> The
///                      feature can be configured to use the default location: local or source. </td> </tr> </table>
///Returns:
///    The <b>MsiGetFeatureValidStates</b> function returns the following values:
///    
@DllImport("msi")
uint MsiGetFeatureValidStatesW(uint hInstall, const(wchar)* szFeature, uint* lpInstallStates);

///The <b>MsiGetSourcePath</b> function returns the full source path for a folder in the Directory table.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFolder = A null-terminated string that specifies a record of the Directory table. If the directory is a root directory,
///               this can be a value from the DefaultDir column. Otherwise it must be a value from the Directory column.
///    szPathBuf = Pointer to the buffer that receives the null terminated full source path. Do not attempt to determine the size of
///                the buffer by passing in a null (value=0) for <i>szPathBuf</i>. You can get the size of the buffer by passing in
///                an empty string (for example ""). The function then returns ERROR_MORE_DATA and <i>pcchPathBuf</i> contains the
///                required buffer size in TCHARs, not including the terminating null character. On return of ERROR_SUCCESS,
///                <i>pcchPathBuf</i> contains the number of TCHARs written to the buffer, not including the terminating null
///                character.
///    pcchPathBuf = Pointer to the variable that specifies the size, in TCHARs, of the buffer pointed to by the variable
///                  <i>szPathBuf</i>. When the function returns ERROR_SUCCESS, this variable contains the size of the data copied to
///                  <i>szPathBuf</i>, not including the terminating null character. If <i>szPathBuf</i> is not large enough, the
///                  function returns ERROR_MORE_DATA and stores the required size, not including the terminating null character, in
///                  the variable pointed to by <i>pcchPathBuf</i>.
///Returns:
///    The <b>MsiGetSourcePath</b> function returns the following values:
///    
@DllImport("msi")
uint MsiGetSourcePathA(uint hInstall, const(char)* szFolder, const(char)* szPathBuf, uint* pcchPathBuf);

///The <b>MsiGetSourcePath</b> function returns the full source path for a folder in the Directory table.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFolder = A null-terminated string that specifies a record of the Directory table. If the directory is a root directory,
///               this can be a value from the DefaultDir column. Otherwise it must be a value from the Directory column.
///    szPathBuf = Pointer to the buffer that receives the null terminated full source path. Do not attempt to determine the size of
///                the buffer by passing in a null (value=0) for <i>szPathBuf</i>. You can get the size of the buffer by passing in
///                an empty string (for example ""). The function then returns ERROR_MORE_DATA and <i>pcchPathBuf</i> contains the
///                required buffer size in TCHARs, not including the terminating null character. On return of ERROR_SUCCESS,
///                <i>pcchPathBuf</i> contains the number of TCHARs written to the buffer, not including the terminating null
///                character.
///    pcchPathBuf = Pointer to the variable that specifies the size, in TCHARs, of the buffer pointed to by the variable
///                  <i>szPathBuf</i>. When the function returns ERROR_SUCCESS, this variable contains the size of the data copied to
///                  <i>szPathBuf</i>, not including the terminating null character. If <i>szPathBuf</i> is not large enough, the
///                  function returns ERROR_MORE_DATA and stores the required size, not including the terminating null character, in
///                  the variable pointed to by <i>pcchPathBuf</i>.
///Returns:
///    The <b>MsiGetSourcePath</b> function returns the following values:
///    
@DllImport("msi")
uint MsiGetSourcePathW(uint hInstall, const(wchar)* szFolder, const(wchar)* szPathBuf, uint* pcchPathBuf);

///The <b>MsiGetTargetPath</b> function returns the full target path for a folder in the Directory table.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFolder = A null-terminated string that specifies a record of the Directory table. If the directory is a root directory,
///               this can be a value from the DefaultDir column. Otherwise it must be a value from the Directory column.
///    szPathBuf = Pointer to the buffer that receives the null terminated full target path. Do not attempt to determine the size of
///                the buffer by passing in a null (value=0) for <i>szPathBuf</i>. You can get the size of the buffer by passing in
///                an empty string (for example ""). The function then returns ERROR_MORE_DATA and <i>pcchPathBuf</i> contains the
///                required buffer size in TCHARs, not including the terminating null character. On return of ERROR_SUCCESS,
///                <i>pcchPathBuf</i> contains the number of TCHARs written to the buffer, not including the terminating null
///                character.
///    pcchPathBuf = Pointer to the variable that specifies the size, in <b>TCHARs</b>, of the buffer pointed to by the variable
///                  <i>szPathBuf</i> When the function returns ERROR_SUCCESS, this variable contains the size of the data copied to
///                  <i>szPathBuf</i>, not including the terminating null character. If <i>szPathBuf</i> is not large enough, the
///                  function returns ERROR_MORE_DATA and stores the required size, not including the terminating null character, in
///                  the variable pointed to by <i>pcchPathBuf</i>.
///Returns:
///    The <b>MsiGetTargetPath</b> function returns the following values:
///    
@DllImport("msi")
uint MsiGetTargetPathA(uint hInstall, const(char)* szFolder, const(char)* szPathBuf, uint* pcchPathBuf);

///The <b>MsiGetTargetPath</b> function returns the full target path for a folder in the Directory table.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFolder = A null-terminated string that specifies a record of the Directory table. If the directory is a root directory,
///               this can be a value from the DefaultDir column. Otherwise it must be a value from the Directory column.
///    szPathBuf = Pointer to the buffer that receives the null terminated full target path. Do not attempt to determine the size of
///                the buffer by passing in a null (value=0) for <i>szPathBuf</i>. You can get the size of the buffer by passing in
///                an empty string (for example ""). The function then returns ERROR_MORE_DATA and <i>pcchPathBuf</i> contains the
///                required buffer size in TCHARs, not including the terminating null character. On return of ERROR_SUCCESS,
///                <i>pcchPathBuf</i> contains the number of TCHARs written to the buffer, not including the terminating null
///                character.
///    pcchPathBuf = Pointer to the variable that specifies the size, in <b>TCHARs</b>, of the buffer pointed to by the variable
///                  <i>szPathBuf</i> When the function returns ERROR_SUCCESS, this variable contains the size of the data copied to
///                  <i>szPathBuf</i>, not including the terminating null character. If <i>szPathBuf</i> is not large enough, the
///                  function returns ERROR_MORE_DATA and stores the required size, not including the terminating null character, in
///                  the variable pointed to by <i>pcchPathBuf</i>.
///Returns:
///    The <b>MsiGetTargetPath</b> function returns the following values:
///    
@DllImport("msi")
uint MsiGetTargetPathW(uint hInstall, const(wchar)* szFolder, const(wchar)* szPathBuf, uint* pcchPathBuf);

///The <b>MsiSetTargetPath</b> function sets the full target path for a folder in the Directory table.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFolder = Specifies the folder identifier. This is a primary key in the Directory table.
///    szFolderPath = Specifies the full path for the folder, ending in a directory separator.
///Returns:
///    The <b>MsiSetTargetPath</b> function returns the following values:
///    
@DllImport("msi")
uint MsiSetTargetPathA(uint hInstall, const(char)* szFolder, const(char)* szFolderPath);

///The <b>MsiSetTargetPath</b> function sets the full target path for a folder in the Directory table.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///    szFolder = Specifies the folder identifier. This is a primary key in the Directory table.
///    szFolderPath = Specifies the full path for the folder, ending in a directory separator.
///Returns:
///    The <b>MsiSetTargetPath</b> function returns the following values:
///    
@DllImport("msi")
uint MsiSetTargetPathW(uint hInstall, const(wchar)* szFolder, const(wchar)* szFolderPath);

///The <b>MsiVerifyDiskSpace</b> function checks to see if sufficient disk space is present for the current
///installation.
///Params:
///    hInstall = Handle to the installation provided to a DLL custom action or obtained through MsiOpenPackage, MsiOpenPackageEx,
///               or MsiOpenProduct.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiVerifyDiskSpace(uint hInstall);

///The <b>MsiEnableUIPreview</b> function enables preview mode of the user interface to facilitate authoring of
///user-interface dialog boxes. This function returns a handle that should be closed using MsiCloseHandle.
///Params:
///    hDatabase = Handle to the database.
///    phPreview = Pointer to a returned handle for user-interface preview capability.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiEnableUIPreview(uint hDatabase, uint* phPreview);

///The <b>MsiPreviewDialog</b> function displays a dialog box as modeless and inactive.
///Params:
///    hPreview = Handle to the preview.
///    szDialogName = Specifies the name of the dialog box to preview.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiPreviewDialogA(uint hPreview, const(char)* szDialogName);

///The <b>MsiPreviewDialog</b> function displays a dialog box as modeless and inactive.
///Params:
///    hPreview = Handle to the preview.
///    szDialogName = Specifies the name of the dialog box to preview.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiPreviewDialogW(uint hPreview, const(wchar)* szDialogName);

///The <b>MsiPreviewBillboard</b> function displays a billboard with the host control in the displayed dialog box.
///Params:
///    hPreview = Handle to the preview.
///    szControlName = Specifies the name of the host control.
///    szBillboard = Specifies the name of the billboard to display.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiPreviewBillboardA(uint hPreview, const(char)* szControlName, const(char)* szBillboard);

///The <b>MsiPreviewBillboard</b> function displays a billboard with the host control in the displayed dialog box.
///Params:
///    hPreview = Handle to the preview.
///    szControlName = Specifies the name of the host control.
///    szBillboard = Specifies the name of the billboard to display.
///Returns:
///    This function returns UINT.
///    
@DllImport("msi")
uint MsiPreviewBillboardW(uint hPreview, const(wchar)* szControlName, const(wchar)* szBillboard);

///The <b>MsiGetLastErrorRecord</b> function returns the error record that was last returned for the calling process.
///This function returns a handle that should be closed using MsiCloseHandle.
///Returns:
///    A handle to the error record. If the last function was successful, <b>MsiGetLastErrorRecord</b> returns a null
///    <b>MSIHANDLE</b>.
///    
@DllImport("msi")
uint MsiGetLastErrorRecord();

///<p class="CCE_Message">[This function is available for use in the operating systems specified in the Requirements
///section. Support for this function was removed in Windows Vista and Windows Server 2008. Use the supported functions
///listed in WRP Functions instead.] Retrieves the complete list of protected files. Applications should not replace
///these files.
///Params:
///    RpcHandle = This parameter must be <b>NULL</b>.
///    ProtFileData = The list of protected files. The format of this structure is as follows. <pre class="syntax"
///                   xml:space="preserve"><code>typedef struct _PROTECTED_FILE_DATA { WCHAR FileName[MAX_PATH]; DWORD FileNumber; }
///                   PROTECTED_FILE_DATA, *PPROTECTED_FILE_DATA;</code></pre> Before calling this function the first time, set the
///                   <b>FileNumber</b> member to zero.
///Returns:
///    If the function succeeds, the return value is nonzero. If there are no more protected files to enumerate, the
///    return value is zero and GetLastError returns ERROR_NO_MORE_FILES. If the function fails, <b>GetLastError</b>
///    will return a different error code.
///    
@DllImport("sfc")
BOOL SfcGetNextProtectedFile(HANDLE RpcHandle, PROTECTED_FILE_DATA* ProtFileData);

///Determines whether the specified file is protected. Applications should avoid replacing protected system files.
///Params:
///    RpcHandle = This parameter must be <b>NULL</b>.
///    ProtFileName = The name of the file.
///Returns:
///    If the file is protected, the return value is a nonzero value. If the file is not protected, the return value is
///    zero.
///    
@DllImport("sfc")
BOOL SfcIsFileProtected(HANDLE RpcHandle, const(wchar)* ProtFileName);

///Determines whether the specified registry key is protected. Applications should avoid replacing protected registry
///keys.
///Params:
///    KeyHandle = A handle to the root registry key. This must be a handle to one of the following predefined keys. <p
///                class="indent">HKEY_CLASSES_ROOT <p class="indent">HKEY_CURRENT_USER <p class="indent">HKEY_LOCAL_MACHINE <p
///                class="indent">HKEY_USERS
///    SubKeyName = A <b>null</b>-terminated string value containing the name of the subkey. This key must a subkey of the key
///                 identified by the <i>hKey</i> parameter. For more information about key names, see Structure of the Registry. If
///                 this parameter is <b>NULL</b>, the function only checks whether the root registry key is protected.
///    KeySam = A constant that specifies the alternate registry view that should be used by applications that run on 64-bit
///             Windows. This flag is ignored on the x86 platform. For more information, see Accessing an Alternate Registry
///             View. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x0000</dt> </dl> </td>
///             <td width="60%"> Use the 32-bit registry key from 32-bit applications and use the 64-bit registry key from 64-bit
///             applications. </td> </tr> <tr> <td width="40%"><a id="KEY_WOW64_64KEY"></a><a id="key_wow64_64key"></a><dl>
///             <dt><b>KEY_WOW64_64KEY</b></dt> <dt>0x0100</dt> </dl> </td> <td width="60%"> Use the 64-bit registry key from
///             either a 32-bit or 64-bit application. </td> </tr> <tr> <td width="40%"><a id="KEY_WOW64_32KEY"></a><a
///             id="key_wow64_32key"></a><dl> <dt><b>KEY_WOW64_32KEY</b></dt> <dt>0x0200</dt> </dl> </td> <td width="60%"> Use
///             the 32-bit registry key from either a 32-bit or 64-bit application. </td> </tr> </table>
///Returns:
///    If the key is protected, the return value is a nonzero value. If the key is not protected, the return value is
///    zero.
///    
@DllImport("sfc")
BOOL SfcIsKeyProtected(HKEY KeyHandle, const(wchar)* SubKeyName, uint KeySam);

@DllImport("sfc")
BOOL SfpVerifyFile(const(char)* pszFileName, const(char)* pszError, uint dwErrSize);

///The <b>CreateActCtx</b> function creates an activation context.
///Params:
///    pActCtx = Pointer to an ACTCTX structure that contains information about the activation context to be created.
///Returns:
///    If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns
///    INVALID_HANDLE_VALUE. This function sets errors that can be retrieved by calling GetLastError. For an example,
///    see Retrieving the Last-Error Code. For a complete list of error codes, see System Error Codes.
///    
@DllImport("KERNEL32")
HANDLE CreateActCtxA(ACTCTXA* pActCtx);

///The <b>CreateActCtx</b> function creates an activation context.
///Params:
///    pActCtx = Pointer to an ACTCTX structure that contains information about the activation context to be created.
///Returns:
///    If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns
///    INVALID_HANDLE_VALUE. This function sets errors that can be retrieved by calling GetLastError. For an example,
///    see Retrieving the Last-Error Code. For a complete list of error codes, see System Error Codes.
///    
@DllImport("KERNEL32")
HANDLE CreateActCtxW(ACTCTXW* pActCtx);

///The <b>AddRefActCtx</b> function increments the reference count of the specified activation context.
///Params:
///    hActCtx = Handle to an ACTCTX structure that contains information on the activation context for which the reference count
///              is to be incremented.
@DllImport("KERNEL32")
void AddRefActCtx(HANDLE hActCtx);

///The <b>ReleaseActCtx</b> function decrements the reference count of the specified activation context.
///Params:
///    hActCtx = Handle to the ACTCTX structure that contains information on the activation context for which the reference count
///              is to be decremented.
///Returns:
///    This function does not return a value. On successful completion, the activation context reference count is
///    decremented. The recipient of the reference-counted object must decrement the reference count when the object is
///    no longer required.
///    
@DllImport("KERNEL32")
void ReleaseActCtx(HANDLE hActCtx);

///The <b>ZombifyActCtx</b> function deactivates the specified activation context, but does not deallocate it.
///Params:
///    hActCtx = Handle to the activation context that is to be deactivated.
///Returns:
///    If the function succeeds, it returns <b>TRUE</b>. If a <b>null</b> handle is passed in the <i>hActCtx</i>
///    parameter, NULL_INVALID_PARAMETER will be returned. Otherwise, it returns <b>FALSE</b>. This function sets errors
///    that can be retrieved by calling GetLastError. For an example, see Retrieving the Last-Error Code. For a complete
///    list of error codes, see System Error Codes.
///    
@DllImport("KERNEL32")
BOOL ZombifyActCtx(HANDLE hActCtx);

///The <b>ActivateActCtx</b> function activates the specified activation context. It does this by pushing the specified
///activation context to the top of the activation stack. The specified activation context is thus associated with the
///current thread and any appropriate side-by-side API functions.
///Params:
///    hActCtx = Handle to an ACTCTX structure that contains information on the activation context that is to be made active.
///    lpCookie = Pointer to a <b>ULONG_PTR</b> that functions as a cookie, uniquely identifying a specific, activated activation
///               context.
///Returns:
///    If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>. This function sets errors
///    that can be retrieved by calling GetLastError. For an example, see Retrieving the Last-Error Code. For a complete
///    list of error codes, see System Error Codes.
///    
@DllImport("KERNEL32")
BOOL ActivateActCtx(HANDLE hActCtx, size_t* lpCookie);

///The <b>DeactivateActCtx</b> function deactivates the activation context corresponding to the specified cookie.
///Params:
///    dwFlags = Flags that indicate how the deactivation is to occur. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///              width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td width="60%"> If this value is set and the cookie
///              specified in the <i>ulCookie</i> parameter is in the top frame of the activation stack, the activation context is
///              popped from the stack and thereby deactivated. If this value is set and the cookie specified in the
///              <i>ulCookie</i> parameter is not in the top frame of the activation stack, this function searches down the stack
///              for the cookie. If the cookie is found, a STATUS_SXS_EARLY_DEACTIVATION exception is thrown. If the cookie is not
///              found, a STATUS_SXS_INVALID_DEACTIVATION exception is thrown. This value should be specified in most cases. </td>
///              </tr> <tr> <td width="40%"><a id="DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION"></a><a
///              id="deactivate_actctx_flag_force_early_deactivation"></a><dl>
///              <dt><b>DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION</b></dt> </dl> </td> <td width="60%"> If this value is set
///              and the cookie specified in the <i>ulCookie</i> parameter is in the top frame of the activation stack, the
///              function returns an ERROR_INVALID_PARAMETER error code. Call GetLastError to obtain this code. If this value is
///              set and the cookie is not on the activation stack, a STATUS_SXS_INVALID_DEACTIVATION exception will be thrown. If
///              this value is set and the cookie is in a lower frame of the activation stack, all of the frames down to and
///              including the frame the cookie is in is popped from the stack. </td> </tr> </table>
///    ulCookie = The ULONG_PTR that was passed into the call to ActivateActCtx. This value is used as a cookie to identify a
///               specific activated activation context.
///Returns:
///    If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>. This function sets errors
///    that can be retrieved by calling GetLastError. For an example, see Retrieving the Last-Error Code. For a complete
///    list of error codes, see System Error Codes.
///    
@DllImport("KERNEL32")
BOOL DeactivateActCtx(uint dwFlags, size_t ulCookie);

///The <b>GetCurrentActCtx</b> function returns the handle to the active activation context of the calling thread.
///Params:
///    lphActCtx = Pointer to the returned ACTCTX structure that contains information on the active activation context.
///Returns:
///    If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>. This function sets errors
///    that can be retrieved by calling GetLastError. For an example, see Retrieving the Last-Error Code. For a complete
///    list of error codes, see System Error Codes.
///    
@DllImport("KERNEL32")
BOOL GetCurrentActCtx(HANDLE* lphActCtx);

///The <b>FindActCtxSectionString</b> function retrieves information on a specific string in the current activation
///context and returns a ACTCTX_SECTION_KEYED_DATA structure.
///Params:
///    dwFlags = Flags that determine how this function is to operate. Only the following flag is currently defined. <table> <tr>
///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX"></a><a
///              id="find_actctx_section_key_return_hactctx"></a><dl> <dt><b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b></dt> </dl>
///              </td> <td width="60%"> This function returns the activation context handle where the redirection data was found
///              in the <b>hActCtx</b> member of the ACTCTX_SECTION_KEYED_DATA structure. The caller must use ReleaseActCtx to
///              release this activation context. </td> </tr> </table>
///    lpExtensionGuid = Reserved; must be null.
///    ulSectionId = Identifier of the string section of the activation context in which to search for the specific string. The
///                  following are valid string section identifiers: <ul> <li>ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION</li>
///                  <li>ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION</li> <li>ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION</li>
///                  <li>ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION</li> </ul>
///    lpStringToFind = Pointer to a null-terminated string to be used as the search criteria.
///    ReturnedData = Pointer to an ACTCTX_SECTION_KEYED_DATA structure to be filled out with the requested string information.
///Returns:
///    If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>. This function sets errors
///    that can be retrieved by calling GetLastError. For an example, see Retrieving the Last-Error Code. For a complete
///    list of error codes, see System Error Codes.
///    
@DllImport("KERNEL32")
BOOL FindActCtxSectionStringA(uint dwFlags, const(GUID)* lpExtensionGuid, uint ulSectionId, 
                              const(char)* lpStringToFind, ACTCTX_SECTION_KEYED_DATA* ReturnedData);

///The <b>FindActCtxSectionString</b> function retrieves information on a specific string in the current activation
///context and returns a ACTCTX_SECTION_KEYED_DATA structure.
///Params:
///    dwFlags = Flags that determine how this function is to operate. Only the following flag is currently defined. <table> <tr>
///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX"></a><a
///              id="find_actctx_section_key_return_hactctx"></a><dl> <dt><b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b></dt> </dl>
///              </td> <td width="60%"> This function returns the activation context handle where the redirection data was found
///              in the <b>hActCtx</b> member of the ACTCTX_SECTION_KEYED_DATA structure. The caller must use ReleaseActCtx to
///              release this activation context. </td> </tr> </table>
///    lpExtensionGuid = Reserved; must be null.
///    ulSectionId = Identifier of the string section of the activation context in which to search for the specific string. The
///                  following are valid string section identifiers: <ul> <li>ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION</li>
///                  <li>ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION</li> <li>ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION</li>
///                  <li>ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION</li> </ul>
///    lpStringToFind = Pointer to a null-terminated string to be used as the search criteria.
///    ReturnedData = Pointer to an ACTCTX_SECTION_KEYED_DATA structure to be filled out with the requested string information.
///Returns:
///    If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>. This function sets errors
///    that can be retrieved by calling GetLastError. For an example, see Retrieving the Last-Error Code. For a complete
///    list of error codes, see System Error Codes.
///    
@DllImport("KERNEL32")
BOOL FindActCtxSectionStringW(uint dwFlags, const(GUID)* lpExtensionGuid, uint ulSectionId, 
                              const(wchar)* lpStringToFind, ACTCTX_SECTION_KEYED_DATA* ReturnedData);

///The <b>FindActCtxSectionGuid</b> function retrieves information on a specific GUID in the current activation context
///and returns a ACTCTX_SECTION_KEYED_DATA structure.
///Params:
///    dwFlags = Flags that determine how this function is to operate. Only the following flag is currently defined. <table> <tr>
///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX"></a><a
///              id="find_actctx_section_key_return_hactctx"></a><dl> <dt><b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b></dt> </dl>
///              </td> <td width="60%"> This function returns the activation context handle where the redirection data was found
///              in the <b>hActCtx</b> member of the ACTCTX_SECTION_KEYED_DATA structure. The caller must use ReleaseActCtx to
///              release this activation context. </td> </tr> </table>
///    lpExtensionGuid = Reserved; must be null.
///    ulSectionId = Identifier of the section of the activation context in which to search for the specified GUID. The following are
///                  valid GUID section identifiers: <ul> <li>ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION</li>
///                  <li>ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION</li>
///                  <li>ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION</li> </ul> The following is a valid GUID section
///                  identifier beginning with Windows Server 2003 and Windows XP with SP1: <ul>
///                  <li>ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES</li> </ul>
///    lpGuidToFind = Pointer to a GUID to be used as the search criteria.
///    ReturnedData = Pointer to an ACTCTX_SECTION_KEYED_DATA structure to be filled out with the requested GUID information.
///Returns:
///    If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>. This function sets errors
///    that can be retrieved by calling GetLastError. For an example, see Retrieving the Last-Error Code. For a complete
///    list of error codes, see System Error Codes.
///    
@DllImport("KERNEL32")
BOOL FindActCtxSectionGuid(uint dwFlags, const(GUID)* lpExtensionGuid, uint ulSectionId, const(GUID)* lpGuidToFind, 
                           ACTCTX_SECTION_KEYED_DATA* ReturnedData);

///The <b>QueryActCtxW</b> function queries the activation context.
///Params:
///    dwFlags = This parameter should be set to one of the following flag bits. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr>
///              <tr> <td width="40%"><a id="QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX"></a><a
///              id="query_actctx_flag_use_active_actctx"></a><dl> <dt><b>QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX</b></dt> </dl> </td>
///              <td width="60%"> <b>QueryActCtxW</b> queries the activation context active on the thread instead of the context
///              specified by <i>hActCtx</i>. This is usually the last activation context passed to ActivateActCtx. If
///              <b>ActivateActCtx</b> has not been called, the active activation context can be the activation context used by
///              the executable of the current process. In other cases, the operating system determines the active activation
///              context. For example, when the callback function to a new thread is called, the active activation context may be
///              the context that was active when you created the thread by calling CreateThread. </td> </tr> <tr> <td
///              width="40%"><a id="QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE"></a><a id="query_actctx_flag_actctx_is_hmodule"></a><dl>
///              <dt><b>QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE</b></dt> </dl> </td> <td width="60%"> <b>QueryActCtxW</b> interprets
///              <i>hActCtx</i> as an <b>HMODULE</b> data type and queries an activation context that is associated with a DLL or
///              EXE. When a DLL or EXE is loaded, the loader checks for a manifest stored in a resource. If the loader finds an
///              RT_MANIFEST resource with a resource identifier set to ISOLATIONAWARE_MANIFEST_ RESOURCE_ID, the loader
///              associates the resulting activation context with the DLL or EXE. This is the activation context that
///              <b>QueryActCtxW</b> queries when the QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE flag has been set. </td> </tr> <tr> <td
///              width="40%"><a id="QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS"></a><a id="query_actctx_flag_actctx_is_address"></a><dl>
///              <dt><b>QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS</b></dt> </dl> </td> <td width="60%"> <b>QueryActCtxW</b> interprets
///              <i>hActCtx</i> as an address within a DLL or EXE and queries an activation context that has been associated with
///              the DLL or EXE. This can be any address within the DLL or EXE. For example, the address of any function within a
///              DLL or EXE or the address of any static data, such as a constant string. When a DLL or EXE is loaded, the loader
///              checks for a manifest stored in a resource in the same way as QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE. </td> </tr>
///              </table>
///    hActCtx = Handle to the activation context that is being queried.
///    pvSubInstance = Index of the assembly, or assembly and file combination, in the activation context. The meaning of the
///                    <i>pvSubInstance</i> depends on the option specified by the value of the <i>ulInfoClass</i> parameter. This
///                    parameter may be null. <table> <tr> <th>ulInfoClass Option</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                    id="AssemblyDetailedInformationInActivationContext"></a><a
///                    id="assemblydetailedinformationinactivationcontext"></a><a
///                    id="ASSEMBLYDETAILEDINFORMATIONINACTIVATIONCONTEXT"></a><dl>
///                    <dt><b>AssemblyDetailedInformationInActivationContext</b></dt> </dl> </td> <td width="60%"> Pointer to a
///                    <b>DWORD</b> that specifies the index of the assembly within the activation context. This is the activation
///                    context that <b>QueryActCtxW</b> queries. </td> </tr> <tr> <td width="40%"><a
///                    id="FileInformationInAssemblyOfAssemblyInActivationContext"></a><a
///                    id="fileinformationinassemblyofassemblyinactivationcontext"></a><a
///                    id="FILEINFORMATIONINASSEMBLYOFASSEMBLYINACTIVATIONCONTEXT"></a><dl>
///                    <dt><b>FileInformationInAssemblyOfAssemblyInActivationContext</b></dt> </dl> </td> <td width="60%"> Pointer to an
///                    ACTIVATION_CONTEXT_QUERY_INDEX structure. If <b>QueryActCtxW</b> is called with this option and the function
///                    succeeds, the returned buffer contains information for a file in the assembly. This information is in the form of
///                    the ASSEMBLY_FILE_DETAILED_INFORMATION structure. </td> </tr> </table>
///    ulInfoClass = This parameter can have only the values shown in the following table. <table> <tr> <th>Option</th>
///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ActivationContextBasicInformation"></a><a
///                  id="activationcontextbasicinformation"></a><a id="ACTIVATIONCONTEXTBASICINFORMATION"></a><dl>
///                  <dt><b>ActivationContextBasicInformation</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Not available. </td>
///                  </tr> <tr> <td width="40%"><a id="ActivationContextDetailedInformation"></a><a
///                  id="activationcontextdetailedinformation"></a><a id="ACTIVATIONCONTEXTDETAILEDINFORMATION"></a><dl>
///                  <dt><b>ActivationContextDetailedInformation</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> If
///                  <b>QueryActCtxW</b> is called with this option and the function succeeds, the returned buffer contains detailed
///                  information about the activation context. This information is in the form of the
///                  ACTIVATION_CONTEXT_DETAILED_INFORMATION structure. </td> </tr> <tr> <td width="40%"><a
///                  id="AssemblyDetailedInformationInActivationContext"></a><a
///                  id="assemblydetailedinformationinactivationcontext"></a><a
///                  id="ASSEMBLYDETAILEDINFORMATIONINACTIVATIONCONTEXT"></a><dl>
///                  <dt><b>AssemblyDetailedInformationInActivationContext</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> If
///                  <b>QueryActCtxW</b> is called with this option and the function succeeds, the buffer contains information about
///                  the assembly that has the index specified in <i>pvSubInstance</i>. This information is in the form of the
///                  ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION structure. </td> </tr> <tr> <td width="40%"><a
///                  id="FileInformationInAssemblyOfAssemblyInActivationContext"></a><a
///                  id="fileinformationinassemblyofassemblyinactivationcontext"></a><a
///                  id="FILEINFORMATIONINASSEMBLYOFASSEMBLYINACTIVATIONCONTEXT"></a><dl>
///                  <dt><b>FileInformationInAssemblyOfAssemblyInActivationContext</b></dt> <dt>4</dt> </dl> </td> <td width="60%">
///                  Information about a file in one of the assemblies in Activation Context. The <i>pvSubInstance</i> parameter must
///                  point to an ACTIVATION_CONTEXT_QUERY_INDEX structure. If <b>QueryActCtxW</b> is called with this option and the
///                  function succeeds, the returned buffer contains information for a file in the assembly. This information is in
///                  the form of the ASSEMBLY_FILE_DETAILED_INFORMATION structure. </td> </tr> <tr> <td width="40%"><a
///                  id="RunlevelInformationInActivationContext"></a><a id="runlevelinformationinactivationcontext"></a><a
///                  id="RUNLEVELINFORMATIONINACTIVATIONCONTEXT"></a><dl> <dt><b>RunlevelInformationInActivationContext</b></dt>
///                  <dt>5</dt> </dl> </td> <td width="60%"> If <b>QueryActCtxW</b> is called with this option and the function
///                  succeeds, the buffer contains information about requested run level of the activation context. This information
///                  is in the form of the ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION structure. <b>Windows Server 2003 and Windows XP:
///                  </b>This value is not available. </td> </tr> <tr> <td width="40%"><a
///                  id="CompatibilityInformationInActivationContext"></a><a id="compatibilityinformationinactivationcontext"></a><a
///                  id="COMPATIBILITYINFORMATIONINACTIVATIONCONTEXT"></a><dl>
///                  <dt><b>CompatibilityInformationInActivationContext</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> If
///                  <b>QueryActCtxW</b> is called with this option and the function succeeds, the buffer contains information about
///                  requested compatibility context. This information is in the form of the
///                  ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION structure. <b>Windows Server 2008 and earlier, and Windows Vista and
///                  earlier: </b>This value is not available. This option is available beginning with Windows Server 2008 R2 and
///                  Windows 7. </td> </tr> </table>
///    pvBuffer = Pointer to a buffer that holds the returned information. This parameter is optional. If <i>pvBuffer</i> is
///               <b>null</b>, then <i>cbBuffer</i> must be zero. If the size of the buffer pointed to by <i>pvBuffer</i> is too
///               small, <b>QueryActCtxW</b> returns ERROR_INSUFFICIENT_BUFFER and no data is written into the buffer. See the
///               Remarks section for the method you can use to determine the required size of the buffer.
///    cbBuffer = Size of the buffer in bytes pointed to by <i>pvBuffer</i>. This parameter is optional.
///    pcbWrittenOrRequired = Number of bytes written or required. The parameter <i>pcbWrittenOrRequired</i> can only be <b>NULL</b> when
///                           <i>pvBuffer</i> is <b>NULL</b>. If <i>pcbWrittenOrRequired</i> is non-<b>NULL</b>, it is filled with the number
///                           of bytes required to store the returned buffer.
///Returns:
///    If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>. This function sets errors
///    that can be retrieved by calling GetLastError. For an example, see Retrieving the Last-Error Code. For a complete
///    list of error codes, see System Error Codes.
///    
@DllImport("KERNEL32")
BOOL QueryActCtxW(uint dwFlags, HANDLE hActCtx, void* pvSubInstance, uint ulInfoClass, char* pvBuffer, 
                  size_t cbBuffer, size_t* pcbWrittenOrRequired);

///The <b>QueryActCtxSettingsW</b> function specifies the activation context, and the namespace and name of the
///attribute that is to be queried.
///Params:
///    dwFlags = This value must be 0.
///    hActCtx = A handle to the activation context that is being queried.
///    settingsNameSpace = A pointer to a string that contains the value <b>"http://schemas.microsoft.com/SMI/2005/WindowsSettings"</b> or
///                        <b>NULL</b>. These values are equivalent. <b>Windows 8 and Windows Server 2012: </b>A pointer to a string that
///                        contains the value <b>"http://schemas.microsoft.com/SMI/2011/WindowsSettings"</b> is also a valid parameter. A
///                        <b>NULL</b> is still equivalent to the previous value.
///    settingName = The name of the attribute to be queried.
///    pvBuffer = A pointer to the buffer that receives the query result.
///    dwBuffer = The size of the buffer in characters that receives the query result.
///    pdwWrittenOrRequired = A pointer to a value which is the number of characters written to the buffer specified by <i>pvBuffer</i> or that
///                           is required to hold the query result.
@DllImport("KERNEL32")
BOOL QueryActCtxSettingsW(uint dwFlags, HANDLE hActCtx, const(wchar)* settingsNameSpace, const(wchar)* settingName, 
                          const(wchar)* pvBuffer, size_t dwBuffer, size_t* pdwWrittenOrRequired);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetUpGetInfInformation</b> function returns the SP_INF_INFORMATION structure
///for the specified INF file to a buffer.
///Params:
///    InfSpec = Handle or a file name for an INF file, depending on the value of <i>SearchControl</i>.
///    SearchControl = This parameter can be one of the following constants.
///    ReturnBuffer = If not <b>NULL</b>, points to a buffer in which this function returns the SP_INF_INFORMATION structure. You can
///                   call the function one time to get the required buffer size, allocate the necessary memory, and then call the
///                   function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient
///                   buffer size. For more information, see the Remarks section of this topic.
///    ReturnBufferSize = Size of <i>ReturnBuffer</i>, in bytes.
///    RequiredSize = If not <b>NULL</b>, points to a variable in which this function returns the required size, in bytes, for the
///                   buffer pointed to by <i>ReturnBuffer</i>. If <i>ReturnBuffer</i> is specified and the size needed is larger than
///                   <i>ReturnBufferSize</i>, the function fails and a call to GetLastError returns ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError. If the INF file cannot be located, the function
///    returns <b>FALSE</b> and a subsequent call to GetLastError returns ERROR_FILE_NOT_FOUND.
///    
@DllImport("SETUPAPI")
BOOL SetupGetInfInformationA(void* InfSpec, uint SearchControl, char* ReturnBuffer, uint ReturnBufferSize, 
                             uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetUpGetInfInformation</b> function returns the SP_INF_INFORMATION structure
///for the specified INF file to a buffer.
///Params:
///    InfSpec = Handle or a file name for an INF file, depending on the value of <i>SearchControl</i>.
///    SearchControl = This parameter can be one of the following constants.
///    ReturnBuffer = If not <b>NULL</b>, points to a buffer in which this function returns the SP_INF_INFORMATION structure. You can
///                   call the function one time to get the required buffer size, allocate the necessary memory, and then call the
///                   function a second time to retrieve the data. Using this technique, you can avoid errors due to an insufficient
///                   buffer size. For more information, see the Remarks section of this topic.
///    ReturnBufferSize = Size of <i>ReturnBuffer</i>, in bytes.
///    RequiredSize = If not <b>NULL</b>, points to a variable in which this function returns the required size, in bytes, for the
///                   buffer pointed to by <i>ReturnBuffer</i>. If <i>ReturnBuffer</i> is specified and the size needed is larger than
///                   <i>ReturnBufferSize</i>, the function fails and a call to GetLastError returns ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError. If the INF file cannot be located, the function
///    returns <b>FALSE</b> and a subsequent call to GetLastError returns ERROR_FILE_NOT_FOUND.
///    
@DllImport("SETUPAPI")
BOOL SetupGetInfInformationW(void* InfSpec, uint SearchControl, char* ReturnBuffer, uint ReturnBufferSize, 
                             uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueryInfFileInformation</b> function returns an INF filename from an
///SP_INF_INFORMATION structure to a buffer.
///Params:
///    InfInformation = Pointer to an SP_INF_INFORMATION structure returned from a call to the SetupGetInfInformation function.
///    InfIndex = Index of the constituent INF filename to retrieve. This index can be in the range [0,
///               <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including,
///               <i>InfInformation.InfCount</i> are valid.
///    ReturnBuffer = If not <b>NULL</b>, <i>ReturnBuffer</i> is a pointer to a buffer in which this function returns the full INF
///                   filename. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the
///                   size of the destination buffer. You can call the function once to get the required buffer size, allocate the
///                   necessary memory, and then call the function a second time to retrieve the data. See the Remarks section. Using
///                   this technique, you can avoid errors due to an insufficient buffer size. This parameter can be <b>NULL</b>.
///    ReturnBufferSize = Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b>
///                       terminator.
///    RequiredSize = If not <b>NULL</b>, pointer to a variable that receives the required size for the <i>ReturnBuffer</i> buffer, in
///                   characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size is
///                   larger than <i>ReturnBufferSize</i>, the function fails and a call to GetLastError returns
///                   ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueryInfFileInformationA(SP_INF_INFORMATION* InfInformation, uint InfIndex, const(char)* ReturnBuffer, 
                                   uint ReturnBufferSize, uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueryInfFileInformation</b> function returns an INF filename from an
///SP_INF_INFORMATION structure to a buffer.
///Params:
///    InfInformation = Pointer to an SP_INF_INFORMATION structure returned from a call to the SetupGetInfInformation function.
///    InfIndex = Index of the constituent INF filename to retrieve. This index can be in the range [0,
///               <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including,
///               <i>InfInformation.InfCount</i> are valid.
///    ReturnBuffer = If not <b>NULL</b>, <i>ReturnBuffer</i> is a pointer to a buffer in which this function returns the full INF
///                   filename. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the
///                   size of the destination buffer. You can call the function once to get the required buffer size, allocate the
///                   necessary memory, and then call the function a second time to retrieve the data. See the Remarks section. Using
///                   this technique, you can avoid errors due to an insufficient buffer size. This parameter can be <b>NULL</b>.
///    ReturnBufferSize = Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b>
///                       terminator.
///    RequiredSize = If not <b>NULL</b>, pointer to a variable that receives the required size for the <i>ReturnBuffer</i> buffer, in
///                   characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size is
///                   larger than <i>ReturnBufferSize</i>, the function fails and a call to GetLastError returns
///                   ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueryInfFileInformationW(SP_INF_INFORMATION* InfInformation, uint InfIndex, const(wchar)* ReturnBuffer, 
                                   uint ReturnBufferSize, uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueryInfOriginalFileInformation</b> function returns the original name of
///an OEM INF file.
///Params:
///    InfInformation = Pointer to an SP_INF_INFORMATION structure returned from a call to the SetupGetInfInformation function.
///    InfIndex = Index of the constituent INF file name to retrieve. This index can be in the range [0,
///               <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including,
///               <i>InfInformation.InfCount</i> are valid.
///    AlternatePlatformInfo = Optional pointer to an SP_ALTPLATFORM_INFO_V1 or SP_ALTPLATFORM_INFO_V2 structure used to pass information for an
///                            alternate platform to <b>SetupQueryInfOriginalFileInformation</b>.
///    OriginalFileInfo = Pointer to an SP_ORIGINAL_FILE_INFO structure that receives the original INF file name and catalog file
///                       information returned by <b>SetupQueryInfOriginalFileInformation</b>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueryInfOriginalFileInformationA(SP_INF_INFORMATION* InfInformation, uint InfIndex, 
                                           SP_ALTPLATFORM_INFO_V2* AlternatePlatformInfo, 
                                           SP_ORIGINAL_FILE_INFO_A* OriginalFileInfo);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueryInfOriginalFileInformation</b> function returns the original name of
///an OEM INF file.
///Params:
///    InfInformation = Pointer to an SP_INF_INFORMATION structure returned from a call to the SetupGetInfInformation function.
///    InfIndex = Index of the constituent INF file name to retrieve. This index can be in the range [0,
///               <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including,
///               <i>InfInformation.InfCount</i> are valid.
///    AlternatePlatformInfo = Optional pointer to an SP_ALTPLATFORM_INFO_V1 or SP_ALTPLATFORM_INFO_V2 structure used to pass information for an
///                            alternate platform to <b>SetupQueryInfOriginalFileInformation</b>.
///    OriginalFileInfo = Pointer to an SP_ORIGINAL_FILE_INFO structure that receives the original INF file name and catalog file
///                       information returned by <b>SetupQueryInfOriginalFileInformation</b>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueryInfOriginalFileInformationW(SP_INF_INFORMATION* InfInformation, uint InfIndex, 
                                           SP_ALTPLATFORM_INFO_V2* AlternatePlatformInfo, 
                                           SP_ORIGINAL_FILE_INFO_W* OriginalFileInfo);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueryInfVersionInformation</b> function returns INF file version
///information from an SP_INF_INFORMATION structure to a buffer.
///Params:
///    InfInformation = Pointer to an SP_INF_INFORMATION structure previously returned from a call to the SetupGetInfInformation
///                     function.
///    InfIndex = Index of the constituent INF file to retrieve version information from. This index can be in the range [0,
///               <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including,
///               <i>InfInformation.InfCount</i> are valid.
///    Key = Optional pointer to a <b>null</b>-terminated string containing the key name whose associated string is to be
///          retrieved. If this parameter is <b>NULL</b>, all resource keys are copied to the supplied buffer. Each string is
///          <b>null</b>-terminated, with an extra <b>null</b> at the end of the list.
///    ReturnBuffer = If not <b>NULL</b>, <i>ReturnBuffer</i> points to a call-supplied character buffer in which this function returns
///                   the INF file style. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not
///                   exceed the size of the destination buffer. You can call the function once to get the required buffer size,
///                   allocate the necessary memory, and then call the function a second time to retrieve the data. Using this
///                   technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can
///                   be <b>NULL</b>.
///    ReturnBufferSize = Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This number includes the
///                       <b>null</b> terminator.
///    RequiredSize = If not <b>NULL</b>, pointer to a variable that receives the size required for the buffer pointed to by the
///                   <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator. If
///                   <i>ReturnBuffer</i> is specified and the actual size is larger than the value specified by
///                   <i>ReturnBufferSize</i>, the function fails and a call to GetLastError returns ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueryInfVersionInformationA(SP_INF_INFORMATION* InfInformation, uint InfIndex, const(char)* Key, 
                                      const(char)* ReturnBuffer, uint ReturnBufferSize, uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueryInfVersionInformation</b> function returns INF file version
///information from an SP_INF_INFORMATION structure to a buffer.
///Params:
///    InfInformation = Pointer to an SP_INF_INFORMATION structure previously returned from a call to the SetupGetInfInformation
///                     function.
///    InfIndex = Index of the constituent INF file to retrieve version information from. This index can be in the range [0,
///               <i>InfInformation.InfCount</i>). Meaning that the values zero through, but not including,
///               <i>InfInformation.InfCount</i> are valid.
///    Key = Optional pointer to a <b>null</b>-terminated string containing the key name whose associated string is to be
///          retrieved. If this parameter is <b>NULL</b>, all resource keys are copied to the supplied buffer. Each string is
///          <b>null</b>-terminated, with an extra <b>null</b> at the end of the list.
///    ReturnBuffer = If not <b>NULL</b>, <i>ReturnBuffer</i> points to a call-supplied character buffer in which this function returns
///                   the INF file style. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not
///                   exceed the size of the destination buffer. You can call the function once to get the required buffer size,
///                   allocate the necessary memory, and then call the function a second time to retrieve the data. Using this
///                   technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can
///                   be <b>NULL</b>.
///    ReturnBufferSize = Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This number includes the
///                       <b>null</b> terminator.
///    RequiredSize = If not <b>NULL</b>, pointer to a variable that receives the size required for the buffer pointed to by the
///                   <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator. If
///                   <i>ReturnBuffer</i> is specified and the actual size is larger than the value specified by
///                   <i>ReturnBufferSize</i>, the function fails and a call to GetLastError returns ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueryInfVersionInformationW(SP_INF_INFORMATION* InfInformation, uint InfIndex, const(wchar)* Key, 
                                      const(wchar)* ReturnBuffer, uint ReturnBufferSize, uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetInfFileList</b> function returns a list of INF files located in a
///caller-specified directory to a call-supplied buffer.
///Params:
///    DirectoryPath = Optional pointer to a <b>null</b>-terminated string containing the path of the directory in which to search. If
///                    this value is <b>NULL</b>, the %windir%\inf directory is used.
///    InfStyle = Type of INF file to search for. May be a combination of the following flags.
///    ReturnBuffer = If not <b>NULL</b>, points to a buffer in which this function returns the list of all INF files of the desired
///                   styles that were found in the specified subdirectory. File names are <b>null</b>-terminated, with an extra
///                   <b>null</b> at the end of the list. The <b>null</b>-terminated string should not exceed the size of the
///                   destination buffer. You can call the function once to get the required buffer size, allocate the necessary
///                   memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors
///                   due to an insufficient buffer size. The filenames do not include the path. See the Remarks section.
///    ReturnBufferSize = Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b>
///                       terminator. If <i>ReturnBuffer</i> is not specified, <i>ReturnBufferSize</i> is ignored.
///    RequiredSize = If not <b>NULL</b>, points to a variable in which this function returns the required size for the buffer pointed
///                   to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If
///                   <i>ReturnBuffer</i> is specified and the size needed is larger than <i>ReturnBufferSize</i>, the function fails
///                   and a call to GetLastError returns ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetInfFileListA(const(char)* DirectoryPath, uint InfStyle, const(char)* ReturnBuffer, 
                          uint ReturnBufferSize, uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetInfFileList</b> function returns a list of INF files located in a
///caller-specified directory to a call-supplied buffer.
///Params:
///    DirectoryPath = Optional pointer to a <b>null</b>-terminated string containing the path of the directory in which to search. If
///                    this value is <b>NULL</b>, the %windir%\inf directory is used.
///    InfStyle = Type of INF file to search for. May be a combination of the following flags.
///    ReturnBuffer = If not <b>NULL</b>, points to a buffer in which this function returns the list of all INF files of the desired
///                   styles that were found in the specified subdirectory. File names are <b>null</b>-terminated, with an extra
///                   <b>null</b> at the end of the list. The <b>null</b>-terminated string should not exceed the size of the
///                   destination buffer. You can call the function once to get the required buffer size, allocate the necessary
///                   memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors
///                   due to an insufficient buffer size. The filenames do not include the path. See the Remarks section.
///    ReturnBufferSize = Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b>
///                       terminator. If <i>ReturnBuffer</i> is not specified, <i>ReturnBufferSize</i> is ignored.
///    RequiredSize = If not <b>NULL</b>, points to a variable in which this function returns the required size for the buffer pointed
///                   to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If
///                   <i>ReturnBuffer</i> is specified and the size needed is larger than <i>ReturnBufferSize</i>, the function fails
///                   and a call to GetLastError returns ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetInfFileListW(const(wchar)* DirectoryPath, uint InfStyle, const(wchar)* ReturnBuffer, 
                          uint ReturnBufferSize, uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupOpenInfFile</b> function opens an INF file and returns a handle to it.
///Params:
///    FileName = Pointer to a null-terminated string containing the name (and optional path) of the INF file to be opened. If the
///               filename does not contain path separator characters, it is searched for, first in the %windir%\inf directory, and
///               then in the %windir%\system32 directory. If the filename contains path separator characters, it is assumed to be
///               a full path specification and no further processing is performed on it.
///    InfClass = Optional pointer to a null-terminated string containing the class of INF file desired. This string must match the
///               Class value of the <b>Version</b> section (for example, Class=Net). If there is no entry in the Class value, but
///               there is an entry for ClassGUID in the <b>Version</b> section, the corresponding class name for that GUID is
///               retrieved and used for the comparison.
///    InfStyle = Style of INF file to open or search for. This parameter can be a combination of the following flags.
///    ErrorLine = Optional pointer to a variable to which this function returns the (1-based) line number where an error occurred
///                during loading of the INF file. This value is generally reliable only if GetLastError does not return
///                ERROR_NOT_ENOUGH_MEMORY. If an out-of-memory condition does occur, <i>ErrorLine</i> may be 0.
///Returns:
///    The function returns a handle to the opened INF file if it is successful. Otherwise, the return value is
///    INVALID_HANDLE_VALUE. Extended error information can be retrieved by a call to GetLastError.
///    
@DllImport("SETUPAPI")
void* SetupOpenInfFileW(const(wchar)* FileName, const(wchar)* InfClass, uint InfStyle, uint* ErrorLine);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupOpenInfFile</b> function opens an INF file and returns a handle to it.
///Params:
///    FileName = Pointer to a null-terminated string containing the name (and optional path) of the INF file to be opened. If the
///               filename does not contain path separator characters, it is searched for, first in the %windir%\inf directory, and
///               then in the %windir%\system32 directory. If the filename contains path separator characters, it is assumed to be
///               a full path specification and no further processing is performed on it.
///    InfClass = Optional pointer to a null-terminated string containing the class of INF file desired. This string must match the
///               Class value of the <b>Version</b> section (for example, Class=Net). If there is no entry in the Class value, but
///               there is an entry for ClassGUID in the <b>Version</b> section, the corresponding class name for that GUID is
///               retrieved and used for the comparison.
///    InfStyle = Style of INF file to open or search for. This parameter can be a combination of the following flags.
///    ErrorLine = Optional pointer to a variable to which this function returns the (1-based) line number where an error occurred
///                during loading of the INF file. This value is generally reliable only if GetLastError does not return
///                ERROR_NOT_ENOUGH_MEMORY. If an out-of-memory condition does occur, <i>ErrorLine</i> may be 0.
///Returns:
///    The function returns a handle to the opened INF file if it is successful. Otherwise, the return value is
///    INVALID_HANDLE_VALUE. Extended error information can be retrieved by a call to GetLastError.
///    
@DllImport("SETUPAPI")
void* SetupOpenInfFileA(const(char)* FileName, const(char)* InfClass, uint InfStyle, uint* ErrorLine);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupOpenMasterInf</b> function opens the master INF file that contains file
///and layout information for files shipped with Windows.
///Returns:
///    If <b>SetupOpenMasterInf</b> is successful, it returns a handle to the opened INF file that contains file/layout
///    information for files shipped with Windows. Otherwise, the return value is INVALID_HANDLE_VALUE. To get extended
///    error information, call GetLastError.
///    
@DllImport("SETUPAPI")
void* SetupOpenMasterInf();

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupOpenAppendInfFile</b> function appends the information in an INF file to
///an INF file previously opened by SetupOpenInfFile.
///Params:
///    FileName = If not <b>NULL</b>, <i>FileName</i> points to a <b>null</b>-terminated string containing the name (and optionally
///               the path) of the INF file to be opened. If the filename does not contain path separator characters, it is
///               searched for, first in the %windir%\inf directory, and then in the %windir%\system32 directory. If the filename
///               contains path separator characters, it is assumed to be a full path specification and no further processing is
///               performed on it. If <i>FileName</i> is <b>NULL</b>, the INF filename is retrieved from the LayoutFile value of
///               the <b>Version</b> section in the existing INF file. The same search logic is applied to the filename retrieved
///               from the LayoutFile key.
///    InfHandle = Existing INF handle to which this INF file will be appended.
///    ErrorLine = Optional pointer to a variable to which this function returns the (1-based) line number where an error occurred
///                during loading of the INF file. This value is generally reliable only if GetLastError does not return
///                ERROR_NOT_ENOUGH_MEMORY. If an out-of-memory condition does occur, <i>ErrorLine</i> may be 0.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError. If <i>FileName</i> was not specified and there was no
///    LayoutFile value in the <b>Version</b> section of the existing INF File, GetLastError returns ERROR_INVALID_DATA.
///    
@DllImport("SETUPAPI")
BOOL SetupOpenAppendInfFileW(const(wchar)* FileName, void* InfHandle, uint* ErrorLine);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupOpenAppendInfFile</b> function appends the information in an INF file to
///an INF file previously opened by SetupOpenInfFile.
///Params:
///    FileName = If not <b>NULL</b>, <i>FileName</i> points to a <b>null</b>-terminated string containing the name (and optionally
///               the path) of the INF file to be opened. If the filename does not contain path separator characters, it is
///               searched for, first in the %windir%\inf directory, and then in the %windir%\system32 directory. If the filename
///               contains path separator characters, it is assumed to be a full path specification and no further processing is
///               performed on it. If <i>FileName</i> is <b>NULL</b>, the INF filename is retrieved from the LayoutFile value of
///               the <b>Version</b> section in the existing INF file. The same search logic is applied to the filename retrieved
///               from the LayoutFile key.
///    InfHandle = Existing INF handle to which this INF file will be appended.
///    ErrorLine = Optional pointer to a variable to which this function returns the (1-based) line number where an error occurred
///                during loading of the INF file. This value is generally reliable only if GetLastError does not return
///                ERROR_NOT_ENOUGH_MEMORY. If an out-of-memory condition does occur, <i>ErrorLine</i> may be 0.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError. If <i>FileName</i> was not specified and there was no
///    LayoutFile value in the <b>Version</b> section of the existing INF File, GetLastError returns ERROR_INVALID_DATA.
///    
@DllImport("SETUPAPI")
BOOL SetupOpenAppendInfFileA(const(char)* FileName, void* InfHandle, uint* ErrorLine);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupCloseInfFile</b> function closes the INF file opened by a call to
///SetupOpenInfFile. This function closes any INF files appended to it by calling SetupOpenAppendInfFile.
///Params:
///    InfHandle = Handle to the INF file to be closed.
///Returns:
///    This function does not return a value.
///    
@DllImport("SETUPAPI")
void SetupCloseInfFile(void* InfHandle);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupFindFirstLine</b> function locates a line in the specified section of an
///INF file. If the <i>Key</i> parameter is <b>NULL</b>, <b>SetupFindFirstLine</b> returns the first line of the
///section.
///Params:
///    InfHandle = Handle to the INF file to query.
///    Section = Pointer to a <b>null</b>-terminated string specifying the section of the INF files to search in.
///    Key = Optional pointer to a <b>null</b>-terminated string specifying the key to search for within the section. The
///          <b>null</b>-terminated string should not exceed the size of the destination buffer. This parameter can be
///          <b>NULL</b>. If <i>Key</i> is <b>NULL</b>, the first line in the section is returned.
///    Context = Pointer to a structure that receives the context information used internally by the INF handle. Applications must
///              not overwrite values in this structure.
///Returns:
///    If the function could not find a line, the return value is zero. To get extended error information, call
///    GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupFindFirstLineA(void* InfHandle, const(char)* Section, const(char)* Key, INFCONTEXT* Context);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupFindFirstLine</b> function locates a line in the specified section of an
///INF file. If the <i>Key</i> parameter is <b>NULL</b>, <b>SetupFindFirstLine</b> returns the first line of the
///section.
///Params:
///    InfHandle = Handle to the INF file to query.
///    Section = Pointer to a <b>null</b>-terminated string specifying the section of the INF files to search in.
///    Key = Optional pointer to a <b>null</b>-terminated string specifying the key to search for within the section. The
///          <b>null</b>-terminated string should not exceed the size of the destination buffer. This parameter can be
///          <b>NULL</b>. If <i>Key</i> is <b>NULL</b>, the first line in the section is returned.
///    Context = Pointer to a structure that receives the context information used internally by the INF handle. Applications must
///              not overwrite values in this structure.
///Returns:
///    If the function could not find a line, the return value is zero. To get extended error information, call
///    GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupFindFirstLineW(void* InfHandle, const(wchar)* Section, const(wchar)* Key, INFCONTEXT* Context);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupFindNextLine</b> returns the location of the next line in an INF file
///section relative to <i>ContextIn.Line</i>.
///Params:
///    ContextIn = Pointer to the INF file context retrieved by a call to the SetupFindFirstLine function.
///    ContextOut = Pointer to a variable in which this function returns the context of the found line. <i>ContextOut</i> can point
///                 to <i>ContextIn</i> if the caller wishes.
///Returns:
///    If this function finds the next line, the return value is a nonzero value. Otherwise, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupFindNextLine(INFCONTEXT* ContextIn, INFCONTEXT* ContextOut);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupFindNextMatchLine</b> function returns the location of the next line in
///an INF file relative to <i>ContextIn.Line</i> that matches a specified key.
///Params:
///    ContextIn = Pointer to an INF file context, as retrieved by a call to the SetupFindFirstLine function.
///    Key = If this optional parameter is specified, it supplies a key to match. This parameter should be a null-terminated
///          string. This parameter can be Null. If <i>Key</i> is not specified, the <b>SetupFindNextMatchLine</b> function is
///          equivalent to the SetupFindNextLine function.
///    ContextOut = Pointer to a variable in which this function returns the context of the found line. <i>ContextOut</i> can point
///                 to <i>ContextIn</i> if the caller wishes.
///Returns:
///    The function returns a nonzero value if it finds a matching line. Otherwise, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupFindNextMatchLineA(INFCONTEXT* ContextIn, const(char)* Key, INFCONTEXT* ContextOut);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupFindNextMatchLine</b> function returns the location of the next line in
///an INF file relative to <i>ContextIn.Line</i> that matches a specified key.
///Params:
///    ContextIn = Pointer to an INF file context, as retrieved by a call to the SetupFindFirstLine function.
///    Key = If this optional parameter is specified, it supplies a key to match. This parameter should be a null-terminated
///          string. This parameter can be Null. If <i>Key</i> is not specified, the <b>SetupFindNextMatchLine</b> function is
///          equivalent to the SetupFindNextLine function.
///    ContextOut = Pointer to a variable in which this function returns the context of the found line. <i>ContextOut</i> can point
///                 to <i>ContextIn</i> if the caller wishes.
///Returns:
///    The function returns a nonzero value if it finds a matching line. Otherwise, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupFindNextMatchLineW(INFCONTEXT* ContextIn, const(wchar)* Key, INFCONTEXT* ContextOut);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetLineByIndex</b> function locates a line by its index value in the
///specified section in the INF file.
///Params:
///    InfHandle = Handle to the INF file.
///    Section = Pointer to a null-terminated string specifying the section of the INF file to search.
///    Index = Index of the line to be located. The total number of lines in a particular section can be found with a call to
///            SetupGetLineCount.
///    Context = Pointer to a variable that receives the context information for the found line.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetLineByIndexA(void* InfHandle, const(char)* Section, uint Index, INFCONTEXT* Context);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetLineByIndex</b> function locates a line by its index value in the
///specified section in the INF file.
///Params:
///    InfHandle = Handle to the INF file.
///    Section = Pointer to a null-terminated string specifying the section of the INF file to search.
///    Index = Index of the line to be located. The total number of lines in a particular section can be found with a call to
///            SetupGetLineCount.
///    Context = Pointer to a variable that receives the context information for the found line.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetLineByIndexW(void* InfHandle, const(wchar)* Section, uint Index, INFCONTEXT* Context);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetLineCount</b> function returns the number of lines in a specified
///section of an INF file.
///Params:
///    InfHandle = Handle to the INF file.
///    Section = Pointer to a null-terminated string that specifies the section in which you want to count the lines.
///Returns:
///    If <i>InfHandle</i> references multiple INF files that have been appended using SetupOpenAppendInfFile, this
///    function returns the sum of the lines in all of the INF files containing the specified section. A return value of
///    0 specifies an empty section. If the section does not exist, the function returns 1. To get extended error
///    information, call GetLastError.
///    
@DllImport("SETUPAPI")
int SetupGetLineCountA(void* InfHandle, const(char)* Section);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetLineCount</b> function returns the number of lines in a specified
///section of an INF file.
///Params:
///    InfHandle = Handle to the INF file.
///    Section = Pointer to a null-terminated string that specifies the section in which you want to count the lines.
///Returns:
///    If <i>InfHandle</i> references multiple INF files that have been appended using SetupOpenAppendInfFile, this
///    function returns the sum of the lines in all of the INF files containing the specified section. A return value of
///    0 specifies an empty section. If the section does not exist, the function returns 1. To get extended error
///    information, call GetLastError.
///    
@DllImport("SETUPAPI")
int SetupGetLineCountW(void* InfHandle, const(wchar)* Section);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetLineText</b> function returns the contents of a line in an INF file in
///a compact form. The line to retrieve can be specified by an INFCONTEXT structure returned from a SetupFindLineXXX
///function, or by explicitly passing in the INF handle, section, and key of the desired line.
///Params:
///    Context = Context for a line in an INF file whose text is to be retrieved. This parameter can be <b>NULL</b>. If
///              <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must all be specified.
///    InfHandle = Handle to the INF file to query. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i>
///                is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must all be
///                specified.
///    Section = Pointer to a <b>null</b>-terminated string that specifies the section that contains the key name of the line
///              whose text is to be retrieved. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i>
///              is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must be
///              specified.
///    Key = Pointer to a <b>null</b>-terminated string that contains the key name whose associated string is to be retrieved.
///          This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i> is <b>NULL</b>. If
///          <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must be specified.
///    ReturnBuffer = If not <b>NULL</b>, <i>ReturnBuffer</i> points to a buffer in which this function returns the contents of the
///                   line. The <b>null</b>-terminated string must not exceed the size of the destination buffer. You can call the
///                   function once to get the required buffer size, allocate the necessary memory, and then call the function a second
///                   time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the
///                   Remarks section. This parameter can be <b>NULL</b>.
///    ReturnBufferSize = Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b>
///                       terminator.
///    RequiredSize = If not <b>NULL</b>, points to a variable in which this function returns the required size for the buffer pointed
///                   to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If
///                   <i>ReturnBuffer</i> is specified and the size required is larger than the value specified in the
///                   <i>ReturnBufferSize</i> parameter, the function fails and does not store data in the buffer.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetLineTextA(INFCONTEXT* Context, void* InfHandle, const(char)* Section, const(char)* Key, 
                       const(char)* ReturnBuffer, uint ReturnBufferSize, uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetLineText</b> function returns the contents of a line in an INF file in
///a compact form. The line to retrieve can be specified by an INFCONTEXT structure returned from a SetupFindLineXXX
///function, or by explicitly passing in the INF handle, section, and key of the desired line.
///Params:
///    Context = Context for a line in an INF file whose text is to be retrieved. This parameter can be <b>NULL</b>. If
///              <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must all be specified.
///    InfHandle = Handle to the INF file to query. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i>
///                is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must all be
///                specified.
///    Section = Pointer to a <b>null</b>-terminated string that specifies the section that contains the key name of the line
///              whose text is to be retrieved. This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i>
///              is <b>NULL</b>. If <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must be
///              specified.
///    Key = Pointer to a <b>null</b>-terminated string that contains the key name whose associated string is to be retrieved.
///          This parameter can be <b>NULL</b>. This parameter is used only if <i>Context</i> is <b>NULL</b>. If
///          <i>Context</i> is <b>NULL</b>, <i>InfHandle</i>, <i>Section</i>, and <i>Key</i> must be specified.
///    ReturnBuffer = If not <b>NULL</b>, <i>ReturnBuffer</i> points to a buffer in which this function returns the contents of the
///                   line. The <b>null</b>-terminated string must not exceed the size of the destination buffer. You can call the
///                   function once to get the required buffer size, allocate the necessary memory, and then call the function a second
///                   time to retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the
///                   Remarks section. This parameter can be <b>NULL</b>.
///    ReturnBufferSize = Size of the buffer pointed to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b>
///                       terminator.
///    RequiredSize = If not <b>NULL</b>, points to a variable in which this function returns the required size for the buffer pointed
///                   to by the <i>ReturnBuffer</i> parameter, in characters. This includes the <b>null</b> terminator. If
///                   <i>ReturnBuffer</i> is specified and the size required is larger than the value specified in the
///                   <i>ReturnBufferSize</i> parameter, the function fails and does not store data in the buffer.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetLineTextW(INFCONTEXT* Context, void* InfHandle, const(wchar)* Section, const(wchar)* Key, 
                       const(wchar)* ReturnBuffer, uint ReturnBufferSize, uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetFieldCount</b> function retrieves the number of fields in the
///specified line in an INF file.
///Params:
///    Context = Pointer to the context for a line in an INF file.
///Returns:
///    This function returns the number of fields on the line. If <i>Context</i> is invalid, 0 is returned. To get
///    extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupGetFieldCount(INFCONTEXT* Context);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetStringField</b> function retrieves a string from the specified field
///of a line in an INF file.
///Params:
///    Context = Pointer to the context for a line in an INF file.
///    FieldIndex = The 1-based index of the field within the specified line from which the string should be retrieved. Use a
///                 <i>FieldIndex</i> of 0 to retrieve a string key, if present.
///    ReturnBuffer = Optional pointer to a buffer that receives the <b>null</b>-terminated string. You should ensure the destination
///                   buffer is the same size or larger than the source buffer. This parameter can be <b>NULL</b>. See the Remarks
///                   section.
///    ReturnBufferSize = Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
///    RequiredSize = Optional pointer to a variable that receives the required size for the buffer pointed to by the
///                   <i>ReturnBuffer</i> parameter, in characters. If <i>ReturnBuffer</i> is specified and the actual size needed is
///                   larger than the value specified by <i>ReturnBufferSize</i>, the function fails and does not store the string in
///                   the buffer. In this case, a call to GetLastError returns ERROR_INSUFFICIENT_BUFFER. For the Unicode version of
///                   this function, the required size is in characters. This includes the <b>null</b> terminator.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetStringFieldA(INFCONTEXT* Context, uint FieldIndex, const(char)* ReturnBuffer, uint ReturnBufferSize, 
                          uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetStringField</b> function retrieves a string from the specified field
///of a line in an INF file.
///Params:
///    Context = Pointer to the context for a line in an INF file.
///    FieldIndex = The 1-based index of the field within the specified line from which the string should be retrieved. Use a
///                 <i>FieldIndex</i> of 0 to retrieve a string key, if present.
///    ReturnBuffer = Optional pointer to a buffer that receives the <b>null</b>-terminated string. You should ensure the destination
///                   buffer is the same size or larger than the source buffer. This parameter can be <b>NULL</b>. See the Remarks
///                   section.
///    ReturnBufferSize = Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
///    RequiredSize = Optional pointer to a variable that receives the required size for the buffer pointed to by the
///                   <i>ReturnBuffer</i> parameter, in characters. If <i>ReturnBuffer</i> is specified and the actual size needed is
///                   larger than the value specified by <i>ReturnBufferSize</i>, the function fails and does not store the string in
///                   the buffer. In this case, a call to GetLastError returns ERROR_INSUFFICIENT_BUFFER. For the Unicode version of
///                   this function, the required size is in characters. This includes the <b>null</b> terminator.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetStringFieldW(INFCONTEXT* Context, uint FieldIndex, const(wchar)* ReturnBuffer, uint ReturnBufferSize, 
                          uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetIntField</b> function retrieves an integer value from the specified
///field of a line in an INF file.
///Params:
///    Context = Pointer to the context for a line in an INF file.
///    FieldIndex = The 1-based index of the field within the specified line from which the integer should be retrieved. A
///                 <i>FieldIndex</i> of 0 can be used to retrieve an integer key (For example, consider the following INF line, 431
///                 = 1, 2, 4. The value 431 would be put into the variable pointed at by <i>IntegerValue</i> if
///                 <b>SetupGetIntField</b> was called with a <i>FieldIndex</i> of 0).
///    IntegerValue = Pointer to a variable that receives the integer. If the field is not an integer, the function fails and a call to
///                   GetLastError returns ERROR_INVALID_DATA.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetIntField(INFCONTEXT* Context, uint FieldIndex, int* IntegerValue);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetMultiSzField</b> function retrieves multiple strings stored in a line
///of an INF file, from the specified field to the end of the line.
///Params:
///    Context = Pointer to the context for a line in an INF file.
///    FieldIndex = The 1-based index of the starting field within the specified line from which the strings should be retrieved. The
///                 string list is built from each field starting at this point to the end of the line. A <i>FieldIndex</i> of zero
///                 is not valid with this function.
///    ReturnBuffer = Optional pointer to a character buffer that receives the strings. Each string is <b>null</b>-terminated, with an
///                   extra <b>null</b> at the end of the string list. The <b>null</b>-terminated string should not exceed the size of
///                   the destination buffer. You can call the function once to get the required buffer size, allocate the necessary
///                   memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors
///                   due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
///    ReturnBufferSize = Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
///    RequiredSize = Optional pointer to a variable that receives the size required for the buffer pointed to by <i>ReturnBuffer</i>,
///                   in characters. This includes the <b>null</b> terminator. If the size needed is larger than the value specified by
///                   <i>ReturnBufferSize</i>, the function fails and a call to GetLastError returns ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetMultiSzFieldA(INFCONTEXT* Context, uint FieldIndex, const(char)* ReturnBuffer, uint ReturnBufferSize, 
                           uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetMultiSzField</b> function retrieves multiple strings stored in a line
///of an INF file, from the specified field to the end of the line.
///Params:
///    Context = Pointer to the context for a line in an INF file.
///    FieldIndex = The 1-based index of the starting field within the specified line from which the strings should be retrieved. The
///                 string list is built from each field starting at this point to the end of the line. A <i>FieldIndex</i> of zero
///                 is not valid with this function.
///    ReturnBuffer = Optional pointer to a character buffer that receives the strings. Each string is <b>null</b>-terminated, with an
///                   extra <b>null</b> at the end of the string list. The <b>null</b>-terminated string should not exceed the size of
///                   the destination buffer. You can call the function once to get the required buffer size, allocate the necessary
///                   memory, and then call the function a second time to retrieve the data. Using this technique, you can avoid errors
///                   due to an insufficient buffer size. See the Remarks section. This parameter can be <b>NULL</b>.
///    ReturnBufferSize = Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
///    RequiredSize = Optional pointer to a variable that receives the size required for the buffer pointed to by <i>ReturnBuffer</i>,
///                   in characters. This includes the <b>null</b> terminator. If the size needed is larger than the value specified by
///                   <i>ReturnBufferSize</i>, the function fails and a call to GetLastError returns ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetMultiSzFieldW(INFCONTEXT* Context, uint FieldIndex, const(wchar)* ReturnBuffer, uint ReturnBufferSize, 
                           uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetBinaryField</b> function retrieves binary data from a line in an INF
///file section, from the specified field to the end of the line.
///Params:
///    Context = INF context for the line.
///    FieldIndex = The 1-based index of the starting field within the specified line from which the binary data should be retrieved.
///                 The binary data is built from each field, starting at this point to the end of the line. Each field corresponds
///                 to 1 byte and is in hexadecimal notation. A <i>FieldIndex</i> of zero is not valid with this function.
///    ReturnBuffer = Optional pointer to a buffer that receives the binary data. You should ensure the destination buffer is the same
///                   size or larger than the source buffer. You can call the function once to get the required buffer size, allocate
///                   the necessary memory, and then call the function a second time to retrieve the data. Using this technique, you
///                   can avoid errors due to an insufficient buffer size. See the Remarks section.
///    ReturnBufferSize = Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This number includes the <b>null</b>
///                       terminator.
///    RequiredSize = Optional pointer to a variable that receives the required size for the buffer pointed to <i>ReturnBuffer</i>, in
///                   characters. This number includes the <b>null</b> terminator. If the size needed is larger than the value
///                   specified by <i>ReturnBufferSize</i>, the function fails and a call to GetLastError returns
///                   ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError. GetLastError returns ERROR_INVALID_DATA if a field that
///    <b>SetupGetBinaryField</b> retrieves is not a valid hexadecimal number in the range 0-FF.
///    
@DllImport("SETUPAPI")
BOOL SetupGetBinaryField(INFCONTEXT* Context, uint FieldIndex, char* ReturnBuffer, uint ReturnBufferSize, 
                         uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetFileCompressionInfo</b> function examines a physical file to determine
///if it is compressed and gets its full path, size, and the size of the uncompressed target file. Note that this
///function is obsolete and has been replaced by SetupGetFileCompressionInfoEx. Do not use
///<b>SetupGetFileCompressionInfo</b>, instead always use <b>SetupGetFileCompressionInfoEx</b>.
///Params:
///    SourceFileName = File name of the file about which information is required. If the file is not found on the source media exactly
///                     as named, the file is searched for with up to two alternate "compressed-form" names. For example, if the file is
///                     F:\x86\cmd.exe and it is not found, F:\mpis\cmd.ex_ is searched for and, if that is not found, a search is done
///                     for F:\x86\cmd.ex$. You should use a null-terminated string.
///    ActualSourceFileName = Pointer to a variable that receives the full path of the file that it has been able to locate. The caller can
///                           free the pointer with a call to <b>LocalFree</b>. The path is valid only if the function returns NO_ERROR. Note
///                           that if the version of SetupAPI.dll is less than 5.0.2195, then the caller needs to use the exported function
///                           <b>MyFree</b> from SetupAPI to free the memory allocated by this function, rather then using <b>LocalFree</b>.
///                           See the Remarks section.
///    SourceFileSize = Pointer to a variable in which this function returns the size of the file in its current form which is the
///                     current size of the file named by <i>ActualSourceFileName</i>. The size is determined by examining the source
///                     file; it is not retrieved from an INF file. The source file size is valid only if the function returns NO_ERROR.
///    TargetFileSize = Pointer to a variable in which this function returns the size the file will occupy when it is uncompressed or
///                     copied. If the file is not compressed, this value will be the same as <i>SourceFileSize</i>. The size is
///                     determined by examining the file; it is not retrieved from an INF file. The target file size is valid only if the
///                     function returns NO_ERROR.
///    CompressionType = Pointer to a variable in which this function returns a value indicating the type of compression used on
///                      <i>ActualSourceFileName</i>. The compression type is valid only if the function returns NO_ERROR. The value can
///                      be one of the following flags.
///Returns:
///    The function returns a system error code that indicates the outcome of the file search. The error code can be one
///    of the following values. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupGetFileCompressionInfoA(const(char)* SourceFileName, byte** ActualSourceFileName, uint* SourceFileSize, 
                                  uint* TargetFileSize, uint* CompressionType);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetFileCompressionInfo</b> function examines a physical file to determine
///if it is compressed and gets its full path, size, and the size of the uncompressed target file. Note that this
///function is obsolete and has been replaced by SetupGetFileCompressionInfoEx. Do not use
///<b>SetupGetFileCompressionInfo</b>, instead always use <b>SetupGetFileCompressionInfoEx</b>.
///Params:
///    SourceFileName = File name of the file about which information is required. If the file is not found on the source media exactly
///                     as named, the file is searched for with up to two alternate "compressed-form" names. For example, if the file is
///                     F:\x86\cmd.exe and it is not found, F:\mpis\cmd.ex_ is searched for and, if that is not found, a search is done
///                     for F:\x86\cmd.ex$. You should use a null-terminated string.
///    ActualSourceFileName = Pointer to a variable that receives the full path of the file that it has been able to locate. The caller can
///                           free the pointer with a call to <b>LocalFree</b>. The path is valid only if the function returns NO_ERROR. Note
///                           that if the version of SetupAPI.dll is less than 5.0.2195, then the caller needs to use the exported function
///                           <b>MyFree</b> from SetupAPI to free the memory allocated by this function, rather then using <b>LocalFree</b>.
///                           See the Remarks section.
///    SourceFileSize = Pointer to a variable in which this function returns the size of the file in its current form which is the
///                     current size of the file named by <i>ActualSourceFileName</i>. The size is determined by examining the source
///                     file; it is not retrieved from an INF file. The source file size is valid only if the function returns NO_ERROR.
///    TargetFileSize = Pointer to a variable in which this function returns the size the file will occupy when it is uncompressed or
///                     copied. If the file is not compressed, this value will be the same as <i>SourceFileSize</i>. The size is
///                     determined by examining the file; it is not retrieved from an INF file. The target file size is valid only if the
///                     function returns NO_ERROR.
///    CompressionType = Pointer to a variable in which this function returns a value indicating the type of compression used on
///                      <i>ActualSourceFileName</i>. The compression type is valid only if the function returns NO_ERROR. The value can
///                      be one of the following flags.
///Returns:
///    The function returns a system error code that indicates the outcome of the file search. The error code can be one
///    of the following values. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupGetFileCompressionInfoW(const(wchar)* SourceFileName, ushort** ActualSourceFileName, 
                                  uint* SourceFileSize, uint* TargetFileSize, uint* CompressionType);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetFileCompressionInfoEx</b> function examines a potentially compressed
///file and gets the type of compression, the file's full path (including file name), the compressed size, and the size
///of the uncompressed target file. The caller of the function passes in the name of the file to be examined and
///pointers to locations for the buffer and buffer size to receive the returned file name and path. To determine the
///size of the buffer for the returned path and file name, you can call <b>SetupGetFileCompressionInfoEx</b> with
///<i>ActualSourceFileNameBuffer</i> specified <b>Null</b> and <i>ActualSourceFileNameLen</i> containing 0. The function
///succeeds and on return fills in <i>RequiredBufferLen</i>.
///Params:
///    SourceFileName = File name of the potentially compressed file to be examined. If the file is not found on the source media exactly
///                     as named, Setup searches for up to two alternate names. For example; if Setup does not find F:\x86\cmd.exe, it
///                     searches for F:\mpis\cmd.ex_ and if that name is not found, it searches for F:\x86\cmd.ex$.
///    ActualSourceFileNameBuffer = Pointer to a buffer that receives the actual file name and path if this parameter is not <b>NULL</b>. This is
///                                 valid only if the function returns NO_ERROR.
///    ActualSourceFileNameBufferLen = Size of the buffer specified by <i>ActualSourceFileNameBuffer</i>, in characters. You would typically use a
///                                    buffer size of MAX_PATH. If <i>ActualSourceFileNameLen</i> is too small, the function fails with
///                                    ERROR_INSUFFICIENT_BUFFER. <i>ActualSourceFileNameLen</i> must contain zero if <i>ActualSourceFileNameBuffer</i>
///                                    is <b>NULL</b>.
///    RequiredBufferLen = Size of the file name and full path including the terminating <b>NULL</b>, if this parameter is not <b>NULL</b>.
///                        If <i>ActualSourceFileNameBuffer</i> is <b>NULL</b> and <i>ActualSourceFileNameLen</i> is zero, the function
///                        succeeds but fills in <i>RequiredBufferLen</i>. This parameter is valid only if the function returns NO_ERROR or
///                        ERROR_INSUFFICIENT_BUFFER.
///    SourceFileSize = Pointer to a variable in which this function returns the size of the file in its current form, which is the
///                     current size of the file named by <i>ActualSourceFileNameBuffer</i>. The size is determined by examining the
///                     source file; it is not retrieved from an INF file. The source file size is valid only if the function returns
///                     NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
///    TargetFileSize = Pointer to a variable in which this function returns the size that the file will occupy when it is uncompressed
///                     or copied. If the file is not compressed, this value will be the same as <i>SourceFileSize</i>. The size is
///                     determined by examining the file; it is not retrieved from an INF file. The target file size is valid only if the
///                     function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
///    CompressionType = Pointer to a variable in which this function returns a value indicating the type of compression used on
///                      <i>ActualSourceFileName</i>. The compression type is valid only if the function returns NO_ERROR or
///                      ERROR_INSUFFICIENT_BUFFER. This parameter value can be one of the following flags.
///Returns:
///    If the function succeeds, the return value is <b>TRUE</b> (nonzero). If the function fails, the return value is
///    <b>FALSE</b> (zero). The function can also return one of the following system error codes. To get extended error
///    information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetFileCompressionInfoExA(const(char)* SourceFileName, const(char)* ActualSourceFileNameBuffer, 
                                    uint ActualSourceFileNameBufferLen, uint* RequiredBufferLen, 
                                    uint* SourceFileSize, uint* TargetFileSize, uint* CompressionType);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetFileCompressionInfoEx</b> function examines a potentially compressed
///file and gets the type of compression, the file's full path (including file name), the compressed size, and the size
///of the uncompressed target file. The caller of the function passes in the name of the file to be examined and
///pointers to locations for the buffer and buffer size to receive the returned file name and path. To determine the
///size of the buffer for the returned path and file name, you can call <b>SetupGetFileCompressionInfoEx</b> with
///<i>ActualSourceFileNameBuffer</i> specified <b>Null</b> and <i>ActualSourceFileNameLen</i> containing 0. The function
///succeeds and on return fills in <i>RequiredBufferLen</i>.
///Params:
///    SourceFileName = File name of the potentially compressed file to be examined. If the file is not found on the source media exactly
///                     as named, Setup searches for up to two alternate names. For example; if Setup does not find F:\x86\cmd.exe, it
///                     searches for F:\mpis\cmd.ex_ and if that name is not found, it searches for F:\x86\cmd.ex$.
///    ActualSourceFileNameBuffer = Pointer to a buffer that receives the actual file name and path if this parameter is not <b>NULL</b>. This is
///                                 valid only if the function returns NO_ERROR.
///    ActualSourceFileNameBufferLen = Size of the buffer specified by <i>ActualSourceFileNameBuffer</i>, in characters. You would typically use a
///                                    buffer size of MAX_PATH. If <i>ActualSourceFileNameLen</i> is too small, the function fails with
///                                    ERROR_INSUFFICIENT_BUFFER. <i>ActualSourceFileNameLen</i> must contain zero if <i>ActualSourceFileNameBuffer</i>
///                                    is <b>NULL</b>.
///    RequiredBufferLen = Size of the file name and full path including the terminating <b>NULL</b>, if this parameter is not <b>NULL</b>.
///                        If <i>ActualSourceFileNameBuffer</i> is <b>NULL</b> and <i>ActualSourceFileNameLen</i> is zero, the function
///                        succeeds but fills in <i>RequiredBufferLen</i>. This parameter is valid only if the function returns NO_ERROR or
///                        ERROR_INSUFFICIENT_BUFFER.
///    SourceFileSize = Pointer to a variable in which this function returns the size of the file in its current form, which is the
///                     current size of the file named by <i>ActualSourceFileNameBuffer</i>. The size is determined by examining the
///                     source file; it is not retrieved from an INF file. The source file size is valid only if the function returns
///                     NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
///    TargetFileSize = Pointer to a variable in which this function returns the size that the file will occupy when it is uncompressed
///                     or copied. If the file is not compressed, this value will be the same as <i>SourceFileSize</i>. The size is
///                     determined by examining the file; it is not retrieved from an INF file. The target file size is valid only if the
///                     function returns NO_ERROR or ERROR_INSUFFICIENT_BUFFER.
///    CompressionType = Pointer to a variable in which this function returns a value indicating the type of compression used on
///                      <i>ActualSourceFileName</i>. The compression type is valid only if the function returns NO_ERROR or
///                      ERROR_INSUFFICIENT_BUFFER. This parameter value can be one of the following flags.
///Returns:
///    If the function succeeds, the return value is <b>TRUE</b> (nonzero). If the function fails, the return value is
///    <b>FALSE</b> (zero). The function can also return one of the following system error codes. To get extended error
///    information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetFileCompressionInfoExW(const(wchar)* SourceFileName, const(wchar)* ActualSourceFileNameBuffer, 
                                    uint ActualSourceFileNameBufferLen, uint* RequiredBufferLen, 
                                    uint* SourceFileSize, uint* TargetFileSize, uint* CompressionType);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupDecompressOrCopyFile</b> function copies a file, decompressing it if
///necessary. If a file is copied, the caller of this function is required have privileges to write into the target
///directory.
///Params:
///    SourceFileName = File name of the file to be copied. You should use a <b>null</b>-terminated string. This parameter can be
///                     <b>NULL</b>. If <i>CompressionType</i> is not specified and the <b>SetupDecompressOrCopyFile</b> function does
///                     not find the file specified in <i>SourceFileName</i>, the function searches for the file with up to two
///                     alternate, "compressed-form" names. For example, if the file is F:\x86\cmd.exe and it is not found, the function
///                     searches for F:\x86\cmd.ex_ and, if that is not found, F:\x86\cmd.ex$ is searched for. If <i>CompressionType</i>
///                     is specified, no additional processing is performed on the filename; the file must exist exactly as specified or
///                     the function fails.
///    TargetFileName = Exact name of the target file that will be created by decompressing or copying the source file. You should use a
///                     <b>null</b>-terminated string.
///    CompressionType = Optional pointer to the compression type used on the source file. You can determine the compression type by
///                      calling SetupGetFileCompressionInfo. If this value is FILE_COMPRESSION_NONE, the file is copied (not
///                      decompressed) regardless of any compression in use on the source. If <i>CompressionType</i> is not specified,
///                      this routine determines the compression type automatically.
///Returns:
///    The <b>SetupDecompressOrCopyFile</b> function returns a system error code that indicates the outcome of the
///    operation. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupDecompressOrCopyFileA(const(char)* SourceFileName, const(char)* TargetFileName, uint* CompressionType);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupDecompressOrCopyFile</b> function copies a file, decompressing it if
///necessary. If a file is copied, the caller of this function is required have privileges to write into the target
///directory.
///Params:
///    SourceFileName = File name of the file to be copied. You should use a <b>null</b>-terminated string. This parameter can be
///                     <b>NULL</b>. If <i>CompressionType</i> is not specified and the <b>SetupDecompressOrCopyFile</b> function does
///                     not find the file specified in <i>SourceFileName</i>, the function searches for the file with up to two
///                     alternate, "compressed-form" names. For example, if the file is F:\x86\cmd.exe and it is not found, the function
///                     searches for F:\x86\cmd.ex_ and, if that is not found, F:\x86\cmd.ex$ is searched for. If <i>CompressionType</i>
///                     is specified, no additional processing is performed on the filename; the file must exist exactly as specified or
///                     the function fails.
///    TargetFileName = Exact name of the target file that will be created by decompressing or copying the source file. You should use a
///                     <b>null</b>-terminated string.
///    CompressionType = Optional pointer to the compression type used on the source file. You can determine the compression type by
///                      calling SetupGetFileCompressionInfo. If this value is FILE_COMPRESSION_NONE, the file is copied (not
///                      decompressed) regardless of any compression in use on the source. If <i>CompressionType</i> is not specified,
///                      this routine determines the compression type automatically.
///Returns:
///    The <b>SetupDecompressOrCopyFile</b> function returns a system error code that indicates the outcome of the
///    operation. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupDecompressOrCopyFileW(const(wchar)* SourceFileName, const(wchar)* TargetFileName, uint* CompressionType);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetSourceFileLocation</b> function retrieves the location of a source
///file listed in an INF file.
///Params:
///    InfHandle = Handle to the INF file that contains the <b>SourceDisksNames</b> and <b>SourceDisksFiles</b> sections. If
///                platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and
///                <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
///    InfContext = Optional pointer to the context of a line in a <b>Copy Files</b> section for which the full source path is to be
///                 retrieved. If this parameter is <b>NULL</b>, <i>FileName</i> is searched for in the <b>SourceDisksFiles</b>
///                 section of the INF file specified by <i>InfHandle</i>.
///    FileName = Optional pointer to a <b>null</b>-terminated string containing the filename (no path) for which to return the
///               full source location. This parameter can be <b>NULL</b>, but either <i>FileName</i> or <i>InfContext</i> must be
///               specified.
///    SourceId = Pointer to a variable that receives the source identifier of the media where the file is located from the
///               <b>SourceDisksNames</b> section of the INF file.
///    ReturnBuffer = Optional pointer to a buffer to receive the relative source path. The source path does not include the filename
///                   itself, nor does it include a drive letter/network share name. The path does not start or end with a backslash
///                   (\), so the empty string specifies the root directory. You should use a <b>null</b>-terminated string buffer. The
///                   <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function
///                   once to get the required buffer size, allocate the necessary memory, and then call the function a second time to
///                   retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks
///                   section. This parameter can be <b>NULL</b>.
///    ReturnBufferSize = Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This number includes the <b>null</b>
///                       terminator.
///    RequiredSize = Optional pointer to a variable that receives the required size for the buffer pointed to by the
///                   <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator. If the required
///                   size is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and GetLastError returns
///                   ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetSourceFileLocationA(void* InfHandle, INFCONTEXT* InfContext, const(char)* FileName, uint* SourceId, 
                                 const(char)* ReturnBuffer, uint ReturnBufferSize, uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetSourceFileLocation</b> function retrieves the location of a source
///file listed in an INF file.
///Params:
///    InfHandle = Handle to the INF file that contains the <b>SourceDisksNames</b> and <b>SourceDisksFiles</b> sections. If
///                platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and
///                <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
///    InfContext = Optional pointer to the context of a line in a <b>Copy Files</b> section for which the full source path is to be
///                 retrieved. If this parameter is <b>NULL</b>, <i>FileName</i> is searched for in the <b>SourceDisksFiles</b>
///                 section of the INF file specified by <i>InfHandle</i>.
///    FileName = Optional pointer to a <b>null</b>-terminated string containing the filename (no path) for which to return the
///               full source location. This parameter can be <b>NULL</b>, but either <i>FileName</i> or <i>InfContext</i> must be
///               specified.
///    SourceId = Pointer to a variable that receives the source identifier of the media where the file is located from the
///               <b>SourceDisksNames</b> section of the INF file.
///    ReturnBuffer = Optional pointer to a buffer to receive the relative source path. The source path does not include the filename
///                   itself, nor does it include a drive letter/network share name. The path does not start or end with a backslash
///                   (\), so the empty string specifies the root directory. You should use a <b>null</b>-terminated string buffer. The
///                   <b>null</b>-terminated string should not exceed the size of the destination buffer. You can call the function
///                   once to get the required buffer size, allocate the necessary memory, and then call the function a second time to
///                   retrieve the data. Using this technique, you can avoid errors due to an insufficient buffer size. See the Remarks
///                   section. This parameter can be <b>NULL</b>.
///    ReturnBufferSize = Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This number includes the <b>null</b>
///                       terminator.
///    RequiredSize = Optional pointer to a variable that receives the required size for the buffer pointed to by the
///                   <i>ReturnBuffer</i> parameter, in characters. This number includes the <b>null</b> terminator. If the required
///                   size is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and GetLastError returns
///                   ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetSourceFileLocationW(void* InfHandle, INFCONTEXT* InfContext, const(wchar)* FileName, uint* SourceId, 
                                 const(wchar)* ReturnBuffer, uint ReturnBufferSize, uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetSourceFileSize</b> function reads the uncompressed size of a source
///file listed in an INF file.
///Params:
///    InfHandle = Handle to the loaded INF file that contains the <b>SourceDisksNames</b> and <b>SourceDisksFiles</b> sections. If
///                platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and
///                <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
///    InfContext = Optional pointer to a context for a line in a <b>Copy Files</b> section for which the size is to be retrieved. If
///                 <i>InfContext</i> is <b>NULL</b>, the <i>FileName</i> parameter is used.
///    FileName = Optional pointer to a <b>null</b>-terminated string containing the filename (no path) for which to return the
///               size. If this parameter is <b>NULL</b> as well as <i>InfContext</i>, then the <i>Section</i> parameter is used.
///    Section = Optional pointer to a <b>null</b>-terminated string containing the name of a <b>Copy Files</b> section. If this
///              parameter is specified, the total size of all files listed in the section is computed.
///    FileSize = Pointer to a variable that receives the size, in bytes, of the specified file(s).
///    RoundingFactor = Optional value for rounding file sizes. All file sizes are rounded up to a multiple of this number before being
///                     added to the total size. Rounding is useful for more exact determinations of the space that a file will occupy on
///                     a given volume, because it allows the caller to have file sizes rounded up to a multiple of the cluster size.
///                     Rounding does not occur unless <i>RoundingFactor</i> is specified.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetSourceFileSizeA(void* InfHandle, INFCONTEXT* InfContext, const(char)* FileName, const(char)* Section, 
                             uint* FileSize, uint RoundingFactor);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetSourceFileSize</b> function reads the uncompressed size of a source
///file listed in an INF file.
///Params:
///    InfHandle = Handle to the loaded INF file that contains the <b>SourceDisksNames</b> and <b>SourceDisksFiles</b> sections. If
///                platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and
///                <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
///    InfContext = Optional pointer to a context for a line in a <b>Copy Files</b> section for which the size is to be retrieved. If
///                 <i>InfContext</i> is <b>NULL</b>, the <i>FileName</i> parameter is used.
///    FileName = Optional pointer to a <b>null</b>-terminated string containing the filename (no path) for which to return the
///               size. If this parameter is <b>NULL</b> as well as <i>InfContext</i>, then the <i>Section</i> parameter is used.
///    Section = Optional pointer to a <b>null</b>-terminated string containing the name of a <b>Copy Files</b> section. If this
///              parameter is specified, the total size of all files listed in the section is computed.
///    FileSize = Pointer to a variable that receives the size, in bytes, of the specified file(s).
///    RoundingFactor = Optional value for rounding file sizes. All file sizes are rounded up to a multiple of this number before being
///                     added to the total size. Rounding is useful for more exact determinations of the space that a file will occupy on
///                     a given volume, because it allows the caller to have file sizes rounded up to a multiple of the cluster size.
///                     Rounding does not occur unless <i>RoundingFactor</i> is specified.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetSourceFileSizeW(void* InfHandle, INFCONTEXT* InfContext, const(wchar)* FileName, 
                             const(wchar)* Section, uint* FileSize, uint RoundingFactor);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetTargetPath</b> function determines the target directory for a file
///list section. The file list section can be a <b>Copy Files</b> section, a <b>Delete Files</b> section, or a <b>Rename
///Files</b> section. All the files in the section must be in a single directory that is listed in a
///<b>DestinationDirs</b> section of the INF file.
///Params:
///    InfHandle = Handle to the load INF file that contains a <b>DestinationDirs</b> section.
///    InfContext = Optional pointer to an INF context that specifies a line in a file list section whose destination directory is to
///                 be retrieved. If <i>InfContext</i> is <b>NULL</b>, then the <i>Section</i> parameter is used.
///    Section = Optional parameter that specifies the name of a section of the INF file whose handle is <i>InfHandle</i>.
///              <b>SetupGetTargetPath</b> retrieves the target directory for this section. The <i>Section</i> parameter is
///              ignored if <i>InfContext</i> is specified. If neither <i>InfContext</i> nor <i>Section</i> is specified, the
///              function retrieves the default target path from the INF file. You should use a <b>null</b>-terminated string.
///    ReturnBuffer = Optional pointer to buffer to receive the fully qualified target path. The path is guaranteed not to end with \.
///                   You should use a <b>null</b>-terminated string. You can call the function once to get the required buffer size,
///                   allocate the necessary memory, and then call the function a second time to retrieve the data. Using this
///                   technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can
///                   be <b>NULL</b>.
///    ReturnBufferSize = Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
///    RequiredSize = Optional pointer to a variable that receives the required size for the buffer pointed to by <i>ReturnBuffer</i>,
///                   in characters. This includes the <b>null</b> terminator. If the actual size needed is larger than the value
///                   specified by <i>ReturnBufferSize</i>, the function fails and a call to GetLastError returns
///                   ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetTargetPathA(void* InfHandle, INFCONTEXT* InfContext, const(char)* Section, const(char)* ReturnBuffer, 
                         uint ReturnBufferSize, uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetTargetPath</b> function determines the target directory for a file
///list section. The file list section can be a <b>Copy Files</b> section, a <b>Delete Files</b> section, or a <b>Rename
///Files</b> section. All the files in the section must be in a single directory that is listed in a
///<b>DestinationDirs</b> section of the INF file.
///Params:
///    InfHandle = Handle to the load INF file that contains a <b>DestinationDirs</b> section.
///    InfContext = Optional pointer to an INF context that specifies a line in a file list section whose destination directory is to
///                 be retrieved. If <i>InfContext</i> is <b>NULL</b>, then the <i>Section</i> parameter is used.
///    Section = Optional parameter that specifies the name of a section of the INF file whose handle is <i>InfHandle</i>.
///              <b>SetupGetTargetPath</b> retrieves the target directory for this section. The <i>Section</i> parameter is
///              ignored if <i>InfContext</i> is specified. If neither <i>InfContext</i> nor <i>Section</i> is specified, the
///              function retrieves the default target path from the INF file. You should use a <b>null</b>-terminated string.
///    ReturnBuffer = Optional pointer to buffer to receive the fully qualified target path. The path is guaranteed not to end with \.
///                   You should use a <b>null</b>-terminated string. You can call the function once to get the required buffer size,
///                   allocate the necessary memory, and then call the function a second time to retrieve the data. Using this
///                   technique, you can avoid errors due to an insufficient buffer size. See the Remarks section. This parameter can
///                   be <b>NULL</b>.
///    ReturnBufferSize = Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
///    RequiredSize = Optional pointer to a variable that receives the required size for the buffer pointed to by <i>ReturnBuffer</i>,
///                   in characters. This includes the <b>null</b> terminator. If the actual size needed is larger than the value
///                   specified by <i>ReturnBufferSize</i>, the function fails and a call to GetLastError returns
///                   ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetTargetPathW(void* InfHandle, INFCONTEXT* InfContext, const(wchar)* Section, 
                         const(wchar)* ReturnBuffer, uint ReturnBufferSize, uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupSetSourceList</b> function allows the caller to set the list of
///installation sources for either the current user or the system (common to all users).
///Params:
///    Flags = Specifies the type of list. This parameter can be a combination of the following values.
///    SourceList = Pointer to an array of strings to use as the source list, as specified by the <i>Flags</i> parameter.
///    SourceCount = Number of elements in the array pointed to by <i>SourceList</i>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupSetSourceListA(uint Flags, char* SourceList, uint SourceCount);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupSetSourceList</b> function allows the caller to set the list of
///installation sources for either the current user or the system (common to all users).
///Params:
///    Flags = Specifies the type of list. This parameter can be a combination of the following values.
///    SourceList = Pointer to an array of strings to use as the source list, as specified by the <i>Flags</i> parameter.
///    SourceCount = Number of elements in the array pointed to by <i>SourceList</i>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupSetSourceListW(uint Flags, char* SourceList, uint SourceCount);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupCancelTemporarySourceList</b> function cancels any temporary list and
///no-browse behavior and reestablishes standard list behavior.
///Returns:
///    If a temporary list was in effect, the return value is a nonzero value. Otherwise, the return value is zero. To
///    get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupCancelTemporarySourceList();

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupAddToSourceList</b> function appends a value to the list of installation
///sources for either the current user or the system. If the value already exists, it is removed first, so that
///duplicate entries are not created. A caller of this function is required have administrative privileges, otherwise
///the function fails.
///Params:
///    Flags = List to which the source will be appended. This parameter can be any combination of the following values.
///    Source = Pointer to the source to be added to the list. You should use a null-terminated string.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupAddToSourceListA(uint Flags, const(char)* Source);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupAddToSourceList</b> function appends a value to the list of installation
///sources for either the current user or the system. If the value already exists, it is removed first, so that
///duplicate entries are not created. A caller of this function is required have administrative privileges, otherwise
///the function fails.
///Params:
///    Flags = List to which the source will be appended. This parameter can be any combination of the following values.
///    Source = Pointer to the source to be added to the list. You should use a null-terminated string.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupAddToSourceListW(uint Flags, const(wchar)* Source);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupRemoveFromSourceList</b> function removes a value from the list of
///installation sources for either the current user or the system. The system and user lists are merged at run time. A
///caller of this function is required have administrative privileges, otherwise the function fails.
///Params:
///    Flags = Specifies which source to remove from the list. This parameter can be any combination of the following values.
///    Source = Pointer to a null-terminated string that specifies the source to remove from the list.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupRemoveFromSourceListA(uint Flags, const(char)* Source);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupRemoveFromSourceList</b> function removes a value from the list of
///installation sources for either the current user or the system. The system and user lists are merged at run time. A
///caller of this function is required have administrative privileges, otherwise the function fails.
///Params:
///    Flags = Specifies which source to remove from the list. This parameter can be any combination of the following values.
///    Source = Pointer to a null-terminated string that specifies the source to remove from the list.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupRemoveFromSourceListW(uint Flags, const(wchar)* Source);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQuerySourceList</b> function queries the current list of installation
///sources. The list is built from the system and user-specific lists, and potentially overridden by a temporary list
///(see SetupSetSourceList).
///Params:
///    Flags = Specifies which list to query. This parameter can be any combination of the following values.
///    List = Pointer to a variable in which this function returns a pointer to an array of sources. Use a null-terminated
///           string. The caller must free this array with a call to SetupFreeSourceList.
///    Count = Pointer to a variable in which this function returns the number of sources in the list.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQuerySourceListA(uint Flags, byte*** List, uint* Count);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQuerySourceList</b> function queries the current list of installation
///sources. The list is built from the system and user-specific lists, and potentially overridden by a temporary list
///(see SetupSetSourceList).
///Params:
///    Flags = Specifies which list to query. This parameter can be any combination of the following values.
///    List = Pointer to a variable in which this function returns a pointer to an array of sources. Use a null-terminated
///           string. The caller must free this array with a call to SetupFreeSourceList.
///    Count = Pointer to a variable in which this function returns the number of sources in the list.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQuerySourceListW(uint Flags, ushort*** List, uint* Count);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupFreeSourceList</b> function frees the system resources allocated to a
///source list.
///Params:
///    List = Pointer to an array of sources from SetupQuerySourceList. The <b>null</b>-terminated string should not exceed the
///           size of the destination buffer. When the function returns, this pointer is set to <b>NULL</b>.
///    Count = Number of sources in the list.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupFreeSourceListA(char* List, uint Count);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupFreeSourceList</b> function frees the system resources allocated to a
///source list.
///Params:
///    List = Pointer to an array of sources from SetupQuerySourceList. The <b>null</b>-terminated string should not exceed the
///           size of the destination buffer. When the function returns, this pointer is set to <b>NULL</b>.
///    Count = Number of sources in the list.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupFreeSourceListW(char* List, uint Count);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupPromptForDisk</b> function displays a dialog box that prompts the user
///for a disk.
///Params:
///    hwndParent = Handle to the parent window for this dialog box.
///    DialogTitle = Optional pointer to a <b>null</b>-terminated string specifying the dialog title. If this parameter is
///                  <b>NULL</b>, the default of ""%s--Files Needed"" (localized) is used. The "%s" is replaced with the text
///                  retrieved from the parent window. If no text is retrieved from the parent window, the title is "Files Needed".
///    DiskName = Optional pointer to a <b>null</b>-terminated string specifying the name of the disk to insert. If this parameter
///               is <b>NULL</b>, the default "(Unknown)" (localized) is used.
///    PathToSource = Optional pointer to a <b>null</b>-terminated string specifying the path part of the expected location of the
///                   file, for example, F:\x86. If not specified, the path where <b>SetupPromptForDisk</b> most recently located a
///                   file is used. If that list is empty, a system default is used.
///    FileSought = Pointer to a <b>null</b>-terminated string specifying the name of the file needed (filename part only). The
///                 filename is displayed if the user clicks on the <b>Browse</b> button. This routine looks for the file using its
///                 compressed form names; therefore, you can pass cmd.exe and not worry that the file actually exists as cmd.ex_ on
///                 the source media.
///    TagFile = Optional pointer to a <b>null</b>-terminated string specifying a tag file (filename part only) that identifies
///              the presence of a particular removable media volume. If the currently selected path would place the file on
///              removable media and a tag file is specified, <b>SetupPromptForDisk</b> looks for the tag file at the root of the
///              drive to determine whether to continue. For example, if <i>PathToSource</i> is A:\x86, the tagfile is disk1.tag,
///              and the user types B:\x86 into the edit control of the prompt dialog box, the routine looks for B:\disk1.tag to
///              determine whether to continue. If the tag file is not found, the function looks for the tagfile using
///              <i>PathToSource</i>. If a tag file is not specified, removable media works just like non-removable media and
///              <i>FileSought</i> is looked for before continuing.
///    DiskPromptStyle = Specifies the behavior of the dialog box. This parameter can be a combination of the following flags.
///    PathBuffer = Optional pointer to a buffer that, upon return, receives the path (no filename) of the location specified by the
///                 user through the dialog box. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string
///                 should not exceed the size of the destination buffer. You can call the function once to get the required buffer
///                 size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this
///                 technique, you can avoid errors due to an insufficient buffer size. See the Remarks section.
///    PathBufferSize = Size of the buffer pointed to by <i>PathBuffer</i>, in characters. It should be at least MAX_PATH long. This
///                     includes the <b>null</b> terminator.
///    PathRequiredSize = Optional pointer to a variable that receives the required size for <i>PathBuffer</i>, in characters. This
///                       includes the <b>null</b> terminator.
///Returns:
///    The function returns one of the following values. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupPromptForDiskA(HWND hwndParent, const(char)* DialogTitle, const(char)* DiskName, 
                         const(char)* PathToSource, const(char)* FileSought, const(char)* TagFile, 
                         uint DiskPromptStyle, const(char)* PathBuffer, uint PathBufferSize, uint* PathRequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupPromptForDisk</b> function displays a dialog box that prompts the user
///for a disk.
///Params:
///    hwndParent = Handle to the parent window for this dialog box.
///    DialogTitle = Optional pointer to a <b>null</b>-terminated string specifying the dialog title. If this parameter is
///                  <b>NULL</b>, the default of ""%s--Files Needed"" (localized) is used. The "%s" is replaced with the text
///                  retrieved from the parent window. If no text is retrieved from the parent window, the title is "Files Needed".
///    DiskName = Optional pointer to a <b>null</b>-terminated string specifying the name of the disk to insert. If this parameter
///               is <b>NULL</b>, the default "(Unknown)" (localized) is used.
///    PathToSource = Optional pointer to a <b>null</b>-terminated string specifying the path part of the expected location of the
///                   file, for example, F:\x86. If not specified, the path where <b>SetupPromptForDisk</b> most recently located a
///                   file is used. If that list is empty, a system default is used.
///    FileSought = Pointer to a <b>null</b>-terminated string specifying the name of the file needed (filename part only). The
///                 filename is displayed if the user clicks on the <b>Browse</b> button. This routine looks for the file using its
///                 compressed form names; therefore, you can pass cmd.exe and not worry that the file actually exists as cmd.ex_ on
///                 the source media.
///    TagFile = Optional pointer to a <b>null</b>-terminated string specifying a tag file (filename part only) that identifies
///              the presence of a particular removable media volume. If the currently selected path would place the file on
///              removable media and a tag file is specified, <b>SetupPromptForDisk</b> looks for the tag file at the root of the
///              drive to determine whether to continue. For example, if <i>PathToSource</i> is A:\x86, the tagfile is disk1.tag,
///              and the user types B:\x86 into the edit control of the prompt dialog box, the routine looks for B:\disk1.tag to
///              determine whether to continue. If the tag file is not found, the function looks for the tagfile using
///              <i>PathToSource</i>. If a tag file is not specified, removable media works just like non-removable media and
///              <i>FileSought</i> is looked for before continuing.
///    DiskPromptStyle = Specifies the behavior of the dialog box. This parameter can be a combination of the following flags.
///    PathBuffer = Optional pointer to a buffer that, upon return, receives the path (no filename) of the location specified by the
///                 user through the dialog box. You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string
///                 should not exceed the size of the destination buffer. You can call the function once to get the required buffer
///                 size, allocate the necessary memory, and then call the function a second time to retrieve the data. Using this
///                 technique, you can avoid errors due to an insufficient buffer size. See the Remarks section.
///    PathBufferSize = Size of the buffer pointed to by <i>PathBuffer</i>, in characters. It should be at least MAX_PATH long. This
///                     includes the <b>null</b> terminator.
///    PathRequiredSize = Optional pointer to a variable that receives the required size for <i>PathBuffer</i>, in characters. This
///                       includes the <b>null</b> terminator.
///Returns:
///    The function returns one of the following values. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupPromptForDiskW(HWND hwndParent, const(wchar)* DialogTitle, const(wchar)* DiskName, 
                         const(wchar)* PathToSource, const(wchar)* FileSought, const(wchar)* TagFile, 
                         uint DiskPromptStyle, const(wchar)* PathBuffer, uint PathBufferSize, uint* PathRequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupCopyError</b> function generates a dialog box to notify a user of a copy
///file error.
///Params:
///    hwndParent = The handle to the parent window for this dialog box.
///    DialogTitle = An optional pointer to a <b>null</b>-terminated string that specifies the dialog box title. This parameter can be
///                  <b>NULL</b>. If this parameter is <b>NULL</b>, the default title of "Copy Error" (localized to the system
///                  language) is used.
///    DiskName = An optional pointer to a <b>null</b>-terminated string that specifies the name of the disk to insert. This
///               parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the default name "(Unknown)" (localized to the
///               system language) is used.
///    PathToSource = A pointer to the path component of the source file where an operation fails, for example, F:\x86. Use a
///                   <b>null</b>-terminated string.
///    SourceFile = A pointer to a <b>null</b>-terminated string that specifies the filename part of the file where an operation
///                 fails. Use a <b>null</b>-terminated string. This filename is displayed if the user clicks on the <b>Details</b>
///                 or <b>Browse</b> buttons. The <b>SetupCopyError</b> function looks for the file that uses its compressed form
///                 names. Therefore, you can pass cmd.exe and not worry that the file actually exists as cmd.ex_ on the source
///                 media.
///    TargetPathFile = An optional pointer to a <b>null</b>-terminated string that specifies the full path of the target file for rename
///                     and copy operations. Use a <b>null</b>-terminated string. This parameter can be <b>NULL</b>. If TargetPathFile is
///                     not specified, "(Unknown)" (localized to the system language) is used.
///    Win32ErrorCode = If an error occurs, this member is the System Error Code. If an error does not occur, it is NO_ERROR.
///    Style = The flags that control display formatting and behavior of a dialog box. This parameter can be one of the
///            following flags.
///    PathBuffer = An optional pointer to a variable in which this function returns the path (not including the filename) of the
///                 location that a user specifies in the dialog box. You should use a null-terminated string. The
///                 <b>null</b>-terminated string should not exceed the size of the destination buffer. To avoid insufficient buffer
///                 errors, <i>PathBuffer</i> should be at least MAX_PATH. For more information, see the Remarks section of this
///                 topic.
///    PathBufferSize = The size of the buffer that <i>PathBuffer</i> points to, in characters. The buffer size should be at least
///                     MAX_PATH characters, including the <b>null</b> terminator.
///    PathRequiredSize = An optional pointer to a variable in which this function returns the required buffer size, in characters,
///                       including the <b>null</b> terminator.
///Returns:
///    The function returns one of the following values. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupCopyErrorA(HWND hwndParent, const(char)* DialogTitle, const(char)* DiskName, const(char)* PathToSource, 
                     const(char)* SourceFile, const(char)* TargetPathFile, uint Win32ErrorCode, uint Style, 
                     const(char)* PathBuffer, uint PathBufferSize, uint* PathRequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupCopyError</b> function generates a dialog box to notify a user of a copy
///file error.
///Params:
///    hwndParent = The handle to the parent window for this dialog box.
///    DialogTitle = An optional pointer to a <b>null</b>-terminated string that specifies the dialog box title. This parameter can be
///                  <b>NULL</b>. If this parameter is <b>NULL</b>, the default title of "Copy Error" (localized to the system
///                  language) is used.
///    DiskName = An optional pointer to a <b>null</b>-terminated string that specifies the name of the disk to insert. This
///               parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the default name "(Unknown)" (localized to the
///               system language) is used.
///    PathToSource = A pointer to the path component of the source file where an operation fails, for example, F:\x86. Use a
///                   <b>null</b>-terminated string.
///    SourceFile = A pointer to a <b>null</b>-terminated string that specifies the filename part of the file where an operation
///                 fails. Use a <b>null</b>-terminated string. This filename is displayed if the user clicks on the <b>Details</b>
///                 or <b>Browse</b> buttons. The <b>SetupCopyError</b> function looks for the file that uses its compressed form
///                 names. Therefore, you can pass cmd.exe and not worry that the file actually exists as cmd.ex_ on the source
///                 media.
///    TargetPathFile = An optional pointer to a <b>null</b>-terminated string that specifies the full path of the target file for rename
///                     and copy operations. Use a <b>null</b>-terminated string. This parameter can be <b>NULL</b>. If TargetPathFile is
///                     not specified, "(Unknown)" (localized to the system language) is used.
///    Win32ErrorCode = If an error occurs, this member is the System Error Code. If an error does not occur, it is NO_ERROR.
///    Style = The flags that control display formatting and behavior of a dialog box. This parameter can be one of the
///            following flags.
///    PathBuffer = An optional pointer to a variable in which this function returns the path (not including the filename) of the
///                 location that a user specifies in the dialog box. You should use a null-terminated string. The
///                 <b>null</b>-terminated string should not exceed the size of the destination buffer. To avoid insufficient buffer
///                 errors, <i>PathBuffer</i> should be at least MAX_PATH. For more information, see the Remarks section of this
///                 topic.
///    PathBufferSize = The size of the buffer that <i>PathBuffer</i> points to, in characters. The buffer size should be at least
///                     MAX_PATH characters, including the <b>null</b> terminator.
///    PathRequiredSize = An optional pointer to a variable in which this function returns the required buffer size, in characters,
///                       including the <b>null</b> terminator.
///Returns:
///    The function returns one of the following values. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupCopyErrorW(HWND hwndParent, const(wchar)* DialogTitle, const(wchar)* DiskName, 
                     const(wchar)* PathToSource, const(wchar)* SourceFile, const(wchar)* TargetPathFile, 
                     uint Win32ErrorCode, uint Style, const(wchar)* PathBuffer, uint PathBufferSize, 
                     uint* PathRequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>RenameError</b> function generates a dialog box that informs the user of a
///file renaming error.
///Params:
///    hwndParent = Handle to the parent window for this dialog box.
///    DialogTitle = Pointer to a <b>null</b>-terminated string that specifies the error dialog box title. This parameter may be
///                  <b>NULL</b>. If this parameter is <b>NULL</b>, the default title of "Rename Error" (localized) is used.
///    SourceFile = Pointer to a <b>null</b>-terminated string that specifies the full path of the source file on which the operation
///                 failed.
///    TargetFile = Pointer to a <b>null</b>-terminated string that specifies the full path of the target file on which the operation
///                 failed.
///    Win32ErrorCode = The system error code encountered during the file operation.
///    Style = Specifies display formatting and behavior of the dialog box. This parameter can be one of the following flags.
///Returns:
///    This function returns one of the following values. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupRenameErrorA(HWND hwndParent, const(char)* DialogTitle, const(char)* SourceFile, const(char)* TargetFile, 
                       uint Win32ErrorCode, uint Style);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>RenameError</b> function generates a dialog box that informs the user of a
///file renaming error.
///Params:
///    hwndParent = Handle to the parent window for this dialog box.
///    DialogTitle = Pointer to a <b>null</b>-terminated string that specifies the error dialog box title. This parameter may be
///                  <b>NULL</b>. If this parameter is <b>NULL</b>, the default title of "Rename Error" (localized) is used.
///    SourceFile = Pointer to a <b>null</b>-terminated string that specifies the full path of the source file on which the operation
///                 failed.
///    TargetFile = Pointer to a <b>null</b>-terminated string that specifies the full path of the target file on which the operation
///                 failed.
///    Win32ErrorCode = The system error code encountered during the file operation.
///    Style = Specifies display formatting and behavior of the dialog box. This parameter can be one of the following flags.
///Returns:
///    This function returns one of the following values. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupRenameErrorW(HWND hwndParent, const(wchar)* DialogTitle, const(wchar)* SourceFile, 
                       const(wchar)* TargetFile, uint Win32ErrorCode, uint Style);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupDeleteError</b> function generates a dialog box that informs the user of
///a delete error.
///Params:
///    hwndParent = Handle to the parent window for this dialog box.
///    DialogTitle = Optional pointer to a <b>null</b>-terminated string specifying the error dialog box title. If this parameter is
///                  <b>NULL</b>, the default title of "Delete Error" (localized) is used.
///    File = Pointer to a <b>null</b>-terminated string specifying the full path of the file on which the delete operation
///           failed.
///    Win32ErrorCode = The system error code encountered during the file operation.
///    Style = Flags that control display formatting and behavior of the dialog box. This parameter can be one of the following
///            flags.
///Returns:
///    This function returns one of the following values. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupDeleteErrorA(HWND hwndParent, const(char)* DialogTitle, const(char)* File, uint Win32ErrorCode, 
                       uint Style);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupDeleteError</b> function generates a dialog box that informs the user of
///a delete error.
///Params:
///    hwndParent = Handle to the parent window for this dialog box.
///    DialogTitle = Optional pointer to a <b>null</b>-terminated string specifying the error dialog box title. If this parameter is
///                  <b>NULL</b>, the default title of "Delete Error" (localized) is used.
///    File = Pointer to a <b>null</b>-terminated string specifying the full path of the file on which the delete operation
///           failed.
///    Win32ErrorCode = The system error code encountered during the file operation.
///    Style = Flags that control display formatting and behavior of the dialog box. This parameter can be one of the following
///            flags.
///Returns:
///    This function returns one of the following values. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupDeleteErrorW(HWND hwndParent, const(wchar)* DialogTitle, const(wchar)* File, uint Win32ErrorCode, 
                       uint Style);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupBackupError</b> function generates a dialog box that informs the user of
///a backup error.
///Params:
///    hwndParent = Handle to the parent window for this dialog box.
///    DialogTitle = Optional pointer to a <b>null</b>-terminated string specifying the error dialog box title. If this parameter is
///                  <b>NULL</b>, the default title of "Backup Error" (localized) is used.
///    SourceFile = Pointer to a <b>null</b>-terminated string specifying the full path of the source file that is being backed up.
///    TargetFile = Optional pointer to a <b>null</b>-terminated string specifying the full path of the backup name of the file. This
///                 parameter can be <b>NULL</b>.
///    Win32ErrorCode = If an error occurs, this member is the system error code. If no error has occurred, it is NO_ERROR.
///    Style = Flags that control display formatting and behavior of the dialog box. This parameter can be one of the following
///            flags.
///Returns:
///    This function returns one of the following values. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupBackupErrorA(HWND hwndParent, const(char)* DialogTitle, const(char)* SourceFile, const(char)* TargetFile, 
                       uint Win32ErrorCode, uint Style);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupBackupError</b> function generates a dialog box that informs the user of
///a backup error.
///Params:
///    hwndParent = Handle to the parent window for this dialog box.
///    DialogTitle = Optional pointer to a <b>null</b>-terminated string specifying the error dialog box title. If this parameter is
///                  <b>NULL</b>, the default title of "Backup Error" (localized) is used.
///    SourceFile = Pointer to a <b>null</b>-terminated string specifying the full path of the source file that is being backed up.
///    TargetFile = Optional pointer to a <b>null</b>-terminated string specifying the full path of the backup name of the file. This
///                 parameter can be <b>NULL</b>.
///    Win32ErrorCode = If an error occurs, this member is the system error code. If no error has occurred, it is NO_ERROR.
///    Style = Flags that control display formatting and behavior of the dialog box. This parameter can be one of the following
///            flags.
///Returns:
///    This function returns one of the following values. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupBackupErrorW(HWND hwndParent, const(wchar)* DialogTitle, const(wchar)* SourceFile, 
                       const(wchar)* TargetFile, uint Win32ErrorCode, uint Style);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupSetDirectoryId</b> function associates a directory identifier in an INF
///file with a specific directory.
///Params:
///    InfHandle = A handle for a loaded INF file.
///    Id = A directory identifier (DIRID) to use for an association. This parameter can be <b>NULL</b>. This DIRID must be
///         greater than or equal to DIRID_USER. If an association already exists for this DIRID, it is overwritten. If
///         <i>Id</i> is <b>NULL</b>, the <i>Directory</i> parameter is ignored, and the current set of user-defined DIRIDs
///         is deleted.
///    Directory = A pointer to a <b>null</b>-terminated string that specifies the directory path to associate with <i>Id</i>. This
///                parameter can be <b>NULL</b>. If <i>Directory</i> is <b>NULL</b>, any directory associated with <i>Id</i> is
///                unassociated. No error results if <i>Id</i> is not currently associated with a directory.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupSetDirectoryIdA(void* InfHandle, uint Id, const(char)* Directory);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupSetDirectoryId</b> function associates a directory identifier in an INF
///file with a specific directory.
///Params:
///    InfHandle = A handle for a loaded INF file.
///    Id = A directory identifier (DIRID) to use for an association. This parameter can be <b>NULL</b>. This DIRID must be
///         greater than or equal to DIRID_USER. If an association already exists for this DIRID, it is overwritten. If
///         <i>Id</i> is <b>NULL</b>, the <i>Directory</i> parameter is ignored, and the current set of user-defined DIRIDs
///         is deleted.
///    Directory = A pointer to a <b>null</b>-terminated string that specifies the directory path to associate with <i>Id</i>. This
///                parameter can be <b>NULL</b>. If <i>Directory</i> is <b>NULL</b>, any directory associated with <i>Id</i> is
///                unassociated. No error results if <i>Id</i> is not currently associated with a directory.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupSetDirectoryIdW(void* InfHandle, uint Id, const(wchar)* Directory);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupSetDirectoryIdEx</b> function associates a directory identifier in an INF
///file with a specific directory.
///Params:
///    InfHandle = A handle for a loaded INF file.
///    Id = A directory identifier (DIRID) to use for an association. This parameter can be <b>NULL</b>. This DIRID must be
///         greater than or equal to DIRID_USER. If an association already exists for this DIRID, it is overwritten. If
///         <i>Id</i> is zero, the <i>Directory</i> parameter is ignored, and the current set of user-defined DIRIDs is
///         deleted.
///    Directory = A pointer to a <b>null</b>-terminated string that specifies the directory path to associate with <i>Id</i>. This
///                parameter can be <b>NULL</b>. If <i>Directory</i> is <b>NULL</b>, any directory associated with <i>Id</i> is
///                unassociated. No error results if <i>Id</i> is not currently associated with a directory.
///    Flags = This parameter can be set to <b>SETDIRID_NOT_FULL_PATH</b> (1) to indicate that the <i>Directory</i> does not
///            specify a full path.
///    Reserved1 = If the value of this parameter is not zero the function returns ERROR_INVALID_PARAMETER.
///    Reserved2 = If the value of this parameter is not zero the function returns ERROR_INVALID_PARAMETER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupSetDirectoryIdExA(void* InfHandle, uint Id, const(char)* Directory, uint Flags, uint Reserved1, 
                            void* Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupSetDirectoryIdEx</b> function associates a directory identifier in an INF
///file with a specific directory.
///Params:
///    InfHandle = A handle for a loaded INF file.
///    Id = A directory identifier (DIRID) to use for an association. This parameter can be <b>NULL</b>. This DIRID must be
///         greater than or equal to DIRID_USER. If an association already exists for this DIRID, it is overwritten. If
///         <i>Id</i> is zero, the <i>Directory</i> parameter is ignored, and the current set of user-defined DIRIDs is
///         deleted.
///    Directory = A pointer to a <b>null</b>-terminated string that specifies the directory path to associate with <i>Id</i>. This
///                parameter can be <b>NULL</b>. If <i>Directory</i> is <b>NULL</b>, any directory associated with <i>Id</i> is
///                unassociated. No error results if <i>Id</i> is not currently associated with a directory.
///    Flags = This parameter can be set to <b>SETDIRID_NOT_FULL_PATH</b> (1) to indicate that the <i>Directory</i> does not
///            specify a full path.
///    Reserved1 = If the value of this parameter is not zero the function returns ERROR_INVALID_PARAMETER.
///    Reserved2 = If the value of this parameter is not zero the function returns ERROR_INVALID_PARAMETER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupSetDirectoryIdExW(void* InfHandle, uint Id, const(wchar)* Directory, uint Flags, uint Reserved1, 
                            void* Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetSourceInfo</b> function retrieves the path, tag file, or media
///description for a source listed in an INF file.
///Params:
///    InfHandle = Handle to an open INF file that contains a <b>SourceDisksNames</b> section. If platform-specific sections exist
///                for the user's system (for example, <b>SourceDisksNames.x86</b>), the platform-specific section will be used.
///    SourceId = Identifier for a source media. This value is used to search by key in the <b>SourceDisksNames</b> section.
///    InfoDesired = Indicates what information is desired. Only one value may be specified per function call, and they cannot be
///                  combined. The following types of information can be retrieved from a <b>SourceDisksNames</b> section.
///    ReturnBuffer = Optional pointer to a buffer to receive the retrieved information. Path returns are guaranteed not to end with \.
///                   You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of
///                   the destination buffer. You can call the function once to get the required buffer size, allocate the necessary
///                   memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this
///                   technique, you can avoid errors due to an insufficient buffer size. This parameter can be <b>NULL</b>.
///    ReturnBufferSize = Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
///    RequiredSize = Optional pointer to a variable that receives the required size for the buffer specified by <i>ReturnBuffer</i>,
///                   in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size
///                   needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to
///                   GetLastError returns ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetSourceInfoA(void* InfHandle, uint SourceId, uint InfoDesired, const(char)* ReturnBuffer, 
                         uint ReturnBufferSize, uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetSourceInfo</b> function retrieves the path, tag file, or media
///description for a source listed in an INF file.
///Params:
///    InfHandle = Handle to an open INF file that contains a <b>SourceDisksNames</b> section. If platform-specific sections exist
///                for the user's system (for example, <b>SourceDisksNames.x86</b>), the platform-specific section will be used.
///    SourceId = Identifier for a source media. This value is used to search by key in the <b>SourceDisksNames</b> section.
///    InfoDesired = Indicates what information is desired. Only one value may be specified per function call, and they cannot be
///                  combined. The following types of information can be retrieved from a <b>SourceDisksNames</b> section.
///    ReturnBuffer = Optional pointer to a buffer to receive the retrieved information. Path returns are guaranteed not to end with \.
///                   You should use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of
///                   the destination buffer. You can call the function once to get the required buffer size, allocate the necessary
///                   memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this
///                   technique, you can avoid errors due to an insufficient buffer size. This parameter can be <b>NULL</b>.
///    ReturnBufferSize = Size of the buffer pointed to by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator.
///    RequiredSize = Optional pointer to a variable that receives the required size for the buffer specified by <i>ReturnBuffer</i>,
///                   in characters. This includes the <b>null</b> terminator. If <i>ReturnBuffer</i> is specified and the actual size
///                   needed is larger than the value specified by <i>ReturnBufferSize</i>, the function fails and a call to
///                   GetLastError returns ERROR_INSUFFICIENT_BUFFER.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetSourceInfoW(void* InfHandle, uint SourceId, uint InfoDesired, const(wchar)* ReturnBuffer, 
                         uint ReturnBufferSize, uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInstallFile</b> function installs a file as specified either by an
///INFCONTEXT returned by SetupFindXXXLine or explicitly by the file name and path. If a file is copied, the caller of
///this function must have write privileges into the target directory.
///Params:
///    InfHandle = Optional pointer to the handle to an INF file that contains SourceDisksNames and SourceDisksFiles sections. If
///                platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and
///                SourceDisksFiles.x86), the platform-specific section will be used. If <i>InfContext</i> is null and
///                <i>CopyStyle</i> includes SP_COPY_SOURCE_ABSOLUTE or SP_COPY_SOURCEPATH_ABSOLUTE, <i>InfHandle</i> is ignored.
///    InfContext = Optional pointer to the context of a line in a Copy Files section in an INF file. The routine looks up this file
///                 in the SourceDisksFiles section of <i>InfHandle</i> to get file copy information. If <i>InfHandle</i> is not
///                 specified, <i>SourceFile</i> must be.
///    SourceFile = Optional pointer to the file name (no path) of the file to copy. The file is looked up in the SourceDisksFiles
///                 section. The <i>SourceFile</i> parameter must be specified if <i>InfContext</i> is not. <i>SourceFile</i> is
///                 ignored if <i>InfContext</i> is specified.
///    SourcePathRoot = Optional pointer to the root path for the file to be copied (for example, A:\ or F:\). Paths in the
///                     SourceDisksNames section are appended to this path. The <i>SourcePathRoot</i> parameter is ignored if
///                     <i>CopyStyle</i> includes the SP_COPY_SOURCE_ABSOLUTE flag.
///    DestinationName = Optional pointer to the file name only (no path) of the target file. This parameter can be null to indicate that
///                      the target file should have the same name as the source file. If <i>InfContext</i> is not specified,
///                      <i>DestinationName</i> supplies the full path and file name for the target.
///    CopyStyle = Flags that control the behavior of the file copy operation. These flags may be a combination of the following
///                values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_DELETESOURCE"></a><a id="sp_copy_deletesource"></a><dl> <dt><b>SP_COPY_DELETESOURCE</b></dt> </dl>
///                </td> <td width="60%"> Deletes the source file upon successful copy. The caller is not notified if the delete
///                operation fails. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_REPLACEONLY"></a><a
///                id="sp_copy_replaceonly"></a><dl> <dt><b>SP_COPY_REPLACEONLY</b></dt> </dl> </td> <td width="60%"> Copies the
///                file only if doing so would overwrite a file at the destination path. If the target does not exist, the function
///                returns <b>FALSE</b> and GetLastError returns NO_ERROR. </td> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_NEWER_OR_SAME"></a><a id="sp_copy_newer_or_same"></a><dl> <dt><b>SP_COPY_NEWER_OR_SAME</b></dt> </dl>
///                </td> <td width="60%"> Examines each file being copied to see if its version resources indicate that it is either
///                the same version or not newer than an existing copy on the target. The file version information used during
///                version checks is that specified in the <b>dwFileVersionMS</b> and <b>dwFileVersionLS</b> members of a
///                VS_FIXEDFILEINFO structure, as filled in by the version functions. If one of the files does not have version
///                resources, or if they have identical version information, the source file is considered newer. If the source file
///                is not newer or equal in version, and <i>CopyMsgHandler</i> is specified, the caller is notified and may cancel
///                the copy operation. If <i>CopyMsgHandler</i> is not specified, the file is not copied. </td> </tr> <tr> <td
///                width="40%"><a id="SP_COPY_NEWER_ONLY"></a><a id="sp_copy_newer_only"></a><dl> <dt><b>SP_COPY_NEWER_ONLY</b></dt>
///                </dl> </td> <td width="60%"> Examine each file being copied to see if its version resources indicate that it is
///                not newer than an existing copy on the target. If the source file is newer but not equal in version to the
///                existing target, the file is copied. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NOOVERWRITE"></a><a
///                id="sp_copy_nooverwrite"></a><dl> <dt><b>SP_COPY_NOOVERWRITE</b></dt> </dl> </td> <td width="60%"> Check whether
///                the target file exists, and, if so, notify the caller who may veto the copy. If <i>CopyMsgHandler</i> is not
///                specified, the file is not overwritten. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NODECOMP"></a><a
///                id="sp_copy_nodecomp"></a><dl> <dt><b>SP_COPY_NODECOMP</b></dt> </dl> </td> <td width="60%"> Do not decompress
///                the file. When this flag is set, the target file is not given the uncompressed form of the source name (if
///                appropriate). For example, copying F:<i>\x86\cmd.ex_</i> to &
///    CopyMsgHandler = Optional pointer to a callback function to be notified of various conditions that may arise during the file copy
///                     operation.
///    Context = Optional pointer to a caller-defined value that is passed as the first parameter of the callback function.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError. If GetLastError returns NO_ERROR, the file copy operation
///    was not completed. The file may not have been copied because the file copy operation was unnecessary or because
///    the file callback function returned <b>FALSE</b>.
///    
@DllImport("SETUPAPI")
BOOL SetupInstallFileA(void* InfHandle, INFCONTEXT* InfContext, const(char)* SourceFile, 
                       const(char)* SourcePathRoot, const(char)* DestinationName, uint CopyStyle, 
                       PSP_FILE_CALLBACK_A CopyMsgHandler, void* Context);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInstallFile</b> function installs a file as specified either by an
///INFCONTEXT returned by SetupFindXXXLine or explicitly by the file name and path. If a file is copied, the caller of
///this function must have write privileges into the target directory.
///Params:
///    InfHandle = Optional pointer to the handle to an INF file that contains SourceDisksNames and SourceDisksFiles sections. If
///                platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and
///                SourceDisksFiles.x86), the platform-specific section will be used. If <i>InfContext</i> is null and
///                <i>CopyStyle</i> includes SP_COPY_SOURCE_ABSOLUTE or SP_COPY_SOURCEPATH_ABSOLUTE, <i>InfHandle</i> is ignored.
///    InfContext = Optional pointer to the context of a line in a Copy Files section in an INF file. The routine looks up this file
///                 in the SourceDisksFiles section of <i>InfHandle</i> to get file copy information. If <i>InfHandle</i> is not
///                 specified, <i>SourceFile</i> must be.
///    SourceFile = Optional pointer to the file name (no path) of the file to copy. The file is looked up in the SourceDisksFiles
///                 section. The <i>SourceFile</i> parameter must be specified if <i>InfContext</i> is not. <i>SourceFile</i> is
///                 ignored if <i>InfContext</i> is specified.
///    SourcePathRoot = Optional pointer to the root path for the file to be copied (for example, A:\ or F:\). Paths in the
///                     SourceDisksNames section are appended to this path. The <i>SourcePathRoot</i> parameter is ignored if
///                     <i>CopyStyle</i> includes the SP_COPY_SOURCE_ABSOLUTE flag.
///    DestinationName = Optional pointer to the file name only (no path) of the target file. This parameter can be null to indicate that
///                      the target file should have the same name as the source file. If <i>InfContext</i> is not specified,
///                      <i>DestinationName</i> supplies the full path and file name for the target.
///    CopyStyle = Flags that control the behavior of the file copy operation. These flags may be a combination of the following
///                values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_DELETESOURCE"></a><a id="sp_copy_deletesource"></a><dl> <dt><b>SP_COPY_DELETESOURCE</b></dt> </dl>
///                </td> <td width="60%"> Deletes the source file upon successful copy. The caller is not notified if the delete
///                operation fails. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_REPLACEONLY"></a><a
///                id="sp_copy_replaceonly"></a><dl> <dt><b>SP_COPY_REPLACEONLY</b></dt> </dl> </td> <td width="60%"> Copies the
///                file only if doing so would overwrite a file at the destination path. If the target does not exist, the function
///                returns <b>FALSE</b> and GetLastError returns NO_ERROR. </td> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_NEWER_OR_SAME"></a><a id="sp_copy_newer_or_same"></a><dl> <dt><b>SP_COPY_NEWER_OR_SAME</b></dt> </dl>
///                </td> <td width="60%"> Examines each file being copied to see if its version resources indicate that it is either
///                the same version or not newer than an existing copy on the target. The file version information used during
///                version checks is that specified in the <b>dwFileVersionMS</b> and <b>dwFileVersionLS</b> members of a
///                VS_FIXEDFILEINFO structure, as filled in by the version functions. If one of the files does not have version
///                resources, or if they have identical version information, the source file is considered newer. If the source file
///                is not newer or equal in version, and <i>CopyMsgHandler</i> is specified, the caller is notified and may cancel
///                the copy operation. If <i>CopyMsgHandler</i> is not specified, the file is not copied. </td> </tr> <tr> <td
///                width="40%"><a id="SP_COPY_NEWER_ONLY"></a><a id="sp_copy_newer_only"></a><dl> <dt><b>SP_COPY_NEWER_ONLY</b></dt>
///                </dl> </td> <td width="60%"> Examine each file being copied to see if its version resources indicate that it is
///                not newer than an existing copy on the target. If the source file is newer but not equal in version to the
///                existing target, the file is copied. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NOOVERWRITE"></a><a
///                id="sp_copy_nooverwrite"></a><dl> <dt><b>SP_COPY_NOOVERWRITE</b></dt> </dl> </td> <td width="60%"> Check whether
///                the target file exists, and, if so, notify the caller who may veto the copy. If <i>CopyMsgHandler</i> is not
///                specified, the file is not overwritten. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NODECOMP"></a><a
///                id="sp_copy_nodecomp"></a><dl> <dt><b>SP_COPY_NODECOMP</b></dt> </dl> </td> <td width="60%"> Do not decompress
///                the file. When this flag is set, the target file is not given the uncompressed form of the source name (if
///                appropriate). For example, copying F:<i>\x86\cmd.ex_</i> to &
///    CopyMsgHandler = Optional pointer to a callback function to be notified of various conditions that may arise during the file copy
///                     operation.
///    Context = Optional pointer to a caller-defined value that is passed as the first parameter of the callback function.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError. If GetLastError returns NO_ERROR, the file copy operation
///    was not completed. The file may not have been copied because the file copy operation was unnecessary or because
///    the file callback function returned <b>FALSE</b>.
///    
@DllImport("SETUPAPI")
BOOL SetupInstallFileW(void* InfHandle, INFCONTEXT* InfContext, const(wchar)* SourceFile, 
                       const(wchar)* SourcePathRoot, const(wchar)* DestinationName, uint CopyStyle, 
                       PSP_FILE_CALLBACK_W CopyMsgHandler, void* Context);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInstallFileEx</b> function installs a file as specified either by an
///INFCONTEXT returned by SetupFindXXXLine or explicitly by the filename and path information. This function is the same
///as SetupInstallFile, except that a <b>BOOL</b> is returned that indicates whether the file was in use. If a file is
///copied, the caller of this function is required to have privileges to write into the target directory.
///Params:
///    InfHandle = Optional pointer to the handle to an INF file that contains the SourceDisksNames and SourceDisksFiles sections.
///                If platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and
///                SourceDisksFiles.x86), the platform-specific section are used. If <i>InfContext</i> is not specified and
///                <i>CopyStyle</i> includes SP_COPY_SOURCE_ABSOLUTE or SP_COPY_SOURCEPATH_ABSOLUTE, <i>InfHandle</i> is ignored.
///    InfContext = Optional pointer to context for a line in a Copy Files section in an INF file. The routine looks this file up in
///                 the SourceDisksFiles section of <i>InfHandle</i> to get file copy information. If <i>InfContext</i> is not
///                 specified, <i>SourceFile</i> must be.
///    SourceFile = Optional pointer to the filename (no path) of the file to copy. The file is looked up in the SourceDisksFiles
///                 section. The <i>SourceFile</i> parameter must be specified if <i>InfContext</i> is not. However,
///                 <i>SourceFile</i> is ignored if <i>InfContext</i> is specified.
///    SourcePathRoot = Optional pointer to the root path for the file to be copied (for example, A:\ or F:\). Paths in the
///                     SourceDisksNames section are appended to this path. The <i>SourcePathRoot</i> parameter is ignored if
///                     <i>CopyStyle</i> includes the SP_COPY_SOURCE_ABSOLUTE flag.
///    DestinationName = Optional pointer to a new name for the copied file. If <i>InfContext</i> is specified, <i>DestinationName</i>
///                      supplies the filename only (no path) of the target file. This parameter can be <b>NULL</b> to indicate that the
///                      target file should have the same name as the source file. If <i>InfContext</i> is not specified,
///                      <i>DestinationName</i> supplies the full target path and filename for the target.
///    CopyStyle = Flags that control the behavior of the file copy operation. These flags can be a combination of the following
///                values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_DELETESOURCE"></a><a id="sp_copy_deletesource"></a><dl> <dt><b>SP_COPY_DELETESOURCE</b></dt> </dl>
///                </td> <td width="60%"> Delete the source file upon successful copy. The caller is not notified if the delete
///                fails. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_REPLACEONLY"></a><a id="sp_copy_replaceonly"></a><dl>
///                <dt><b>SP_COPY_REPLACEONLY</b></dt> </dl> </td> <td width="60%"> Copy the file only if doing so overwrites a file
///                at the destination path. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NEWER_OR_SAME"></a><a
///                id="sp_copy_newer_or_same"></a><dl> <dt><b>SP_COPY_NEWER_OR_SAME</b></dt> </dl> </td> <td width="60%"> Examine
///                each file being copied to see if its version resources indicate that it is either the same version or not newer
///                than an existing copy on the target. The file version information used during version checks is that specified in
///                the <b>dwFileVersionMS</b> and <b>dwFileVersionLS</b> members of a VS_FIXEDFILEINFO structure, as filled in by
///                the version functions. If one of the files does not have version resources, or if they have identical version
///                information, the source file is considered newer. If the source file is not newer or equal in version, and
///                <i>CopyMsgHandler</i> is specified, the caller is notified and may cancel the copy. If <i>CopyMsgHandler</i> is
///                not specified, the file is not copied. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NEWER_ONLY"></a><a
///                id="sp_copy_newer_only"></a><dl> <dt><b>SP_COPY_NEWER_ONLY</b></dt> </dl> </td> <td width="60%"> Examine each
///                file being copied to see if its version resources indicate that it is not newer than an existing copy on the
///                target. If the source file is newer but not equal in version to the existing target, the file is copied. </td>
///                </tr> <tr> <td width="40%"><a id="SP_COPY_NOOVERWRITE"></a><a id="sp_copy_nooverwrite"></a><dl>
///                <dt><b>SP_COPY_NOOVERWRITE</b></dt> </dl> </td> <td width="60%"> Check whether the target file exists, and if so,
///                notify the caller who may veto the copy. If <i>CopyMsgHandler</i> is not specified, the file is not overwritten.
///                </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NODECOMP"></a><a id="sp_copy_nodecomp"></a><dl>
///                <dt><b>SP_COPY_NODECOMP</b></dt> </dl> </td> <td width="60%"> Do not decompress the file. When this flag is set,
///                the target file is not given the uncompressed form of the source name (if appropriate). For example, copying
///                "f:\x86\cmd.ex_" to "\\install\temp" results in a target file of "\\install\temp\cmd.ex_". If the
///                SP_COPY_NODECOMP flag was not specified, the file would be decompressed and the target would be called
///                "\\install\temp\cmd.exe". The filename part of <i>DestinationName</i>, if specified, is stripped and replaced
///                with the filename of the source file. When SP_COPY_NODECOMP is specified, no language or version information can
///                be checked. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_LANGUAGEAWARE"></a><a
///                id="sp_copy_languageaware"></a><dl> <dt><b>SP_COPY_LANGUAGEAWARE</b></dt> </dl> </td> <td width="60%"> Examine
///                each file being copied to see if its language differs from the language of any existing file already on the
///                target. If so, and <i>CopyMsgHandler</i> is specified, the caller is notified and may cancel the copy. If
///                <i>CopyMsgHandler</i> is not specified, the file is not copied. </td> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_SOURCE_ABSOLUTE"></a><a id="sp_copy_source_absolute"></a><dl> <dt><b>SP_COPY_SOURCE_ABSOLUTE</b></dt>
///                </dl> </td> <td width="60%"> <i>SourceFile</i> is a full source path. Do not look it up in the SourceDisksNames
///                section of the INF file. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_SOURCEPATH_ABSOLUTE"></a><a
///                id="sp_copy_sourcepath_absolute"></a><dl> <dt><b>SP_COPY_SOURCEPATH_ABSOLUTE</b></dt> </dl> </td> <td
///                width="60%"> <i>SourcePathRoot</i> is the full path part of the source file. Ignore the relative source specified
///                in the SourceDisksNames section of the INF file for the source media where the file is located. This flag is
///                ignored if SP_COPY_SOURCE_ABSOLUTE is specified. </td> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_FORCE_IN_USE"></a><a id="sp_copy_force_in_use"></a><dl> <dt><b>SP_COPY_FORCE_IN_USE</b></dt> </dl>
///                </td> <td width="60%"> If the target exists, behave as if it is in use and queue the file for copying on the next
///                system reboot. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_IN_USE_NEEDS_REBOOT"></a><a
///                id="sp_copy_in_use_needs_reboot"></a><dl> <dt><b>SP_COPY_IN_USE_NEEDS_REBOOT</b></dt> </dl> </td> <td
///                width="60%"> If the file was in use during the copy operation, alert the user that the system requires a reboot.
///                </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NOSKIP"></a><a id="sp_copy_noskip"></a><dl>
///                <dt><b>SP_COPY_NOSKIP</b></dt> </dl> </td> <td width="60%"> Do not give the user the option to skip a file. </td>
///                </tr> <tr> <td width="40%"><a id="SP_COPY_FORCE_NOOVERWRITE"></a><a id="sp_copy_force_nooverwrite"></a><dl>
///                <dt><b>SP_COPY_FORCE_NOOVERWRITE</b></dt> </dl> </td> <td width="60%"> Check whether the target file exists, and
///                if so, the file is not overwritten. The caller is not notified. </td> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_FORCE_NEWER"></a><a id="sp_copy_force_newer"></a><dl> <dt><b>SP_COPY_FORCE_NEWER</b></dt> </dl> </td>
///                <td width="60%"> Examine each file being copied to see if its version resources (or time stamps for non-image
///                files) indicate that it is not newer than an existing copy on the target. If the file being copied is not newer,
///                the file is not copied. The caller is not notified. </td> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_WARNIFSKIP"></a><a id="sp_copy_warnifskip"></a><dl> <dt><b>SP_COPY_WARNIFSKIP</b></dt> </dl> </td>
///                <td width="60%"> If the user tries to skip a file, warn them that skipping a file may affect the installation.
///                (Used for system-critical files.) </td> </tr> </table>
///    CopyMsgHandler = Optional pointer to a callback function to be notified of various conditions that may arise during the file copy.
///    Context = Pointer to a caller-defined value that is passed as the first parameter of the callback function.
///    FileWasInUse = Pointer to a variable in which this function returns a flag that indicates whether the file was in use. This
///                   parameter is required.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError. If GetLastError returns NO_ERROR, the file copy operation
///    was not completed. The file may not have been copied because the file copy operation was unnecessary or because
///    the file callback function returned <b>FALSE</b>.
///    
@DllImport("SETUPAPI")
BOOL SetupInstallFileExA(void* InfHandle, INFCONTEXT* InfContext, const(char)* SourceFile, 
                         const(char)* SourcePathRoot, const(char)* DestinationName, uint CopyStyle, 
                         PSP_FILE_CALLBACK_A CopyMsgHandler, void* Context, int* FileWasInUse);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInstallFileEx</b> function installs a file as specified either by an
///INFCONTEXT returned by SetupFindXXXLine or explicitly by the filename and path information. This function is the same
///as SetupInstallFile, except that a <b>BOOL</b> is returned that indicates whether the file was in use. If a file is
///copied, the caller of this function is required to have privileges to write into the target directory.
///Params:
///    InfHandle = Optional pointer to the handle to an INF file that contains the SourceDisksNames and SourceDisksFiles sections.
///                If platform-specific sections exist for the user's system (for example, SourceDisksNames.x86 and
///                SourceDisksFiles.x86), the platform-specific section are used. If <i>InfContext</i> is not specified and
///                <i>CopyStyle</i> includes SP_COPY_SOURCE_ABSOLUTE or SP_COPY_SOURCEPATH_ABSOLUTE, <i>InfHandle</i> is ignored.
///    InfContext = Optional pointer to context for a line in a Copy Files section in an INF file. The routine looks this file up in
///                 the SourceDisksFiles section of <i>InfHandle</i> to get file copy information. If <i>InfContext</i> is not
///                 specified, <i>SourceFile</i> must be.
///    SourceFile = Optional pointer to the filename (no path) of the file to copy. The file is looked up in the SourceDisksFiles
///                 section. The <i>SourceFile</i> parameter must be specified if <i>InfContext</i> is not. However,
///                 <i>SourceFile</i> is ignored if <i>InfContext</i> is specified.
///    SourcePathRoot = Optional pointer to the root path for the file to be copied (for example, A:\ or F:\). Paths in the
///                     SourceDisksNames section are appended to this path. The <i>SourcePathRoot</i> parameter is ignored if
///                     <i>CopyStyle</i> includes the SP_COPY_SOURCE_ABSOLUTE flag.
///    DestinationName = Optional pointer to a new name for the copied file. If <i>InfContext</i> is specified, <i>DestinationName</i>
///                      supplies the filename only (no path) of the target file. This parameter can be <b>NULL</b> to indicate that the
///                      target file should have the same name as the source file. If <i>InfContext</i> is not specified,
///                      <i>DestinationName</i> supplies the full target path and filename for the target.
///    CopyStyle = Flags that control the behavior of the file copy operation. These flags can be a combination of the following
///                values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_DELETESOURCE"></a><a id="sp_copy_deletesource"></a><dl> <dt><b>SP_COPY_DELETESOURCE</b></dt> </dl>
///                </td> <td width="60%"> Delete the source file upon successful copy. The caller is not notified if the delete
///                fails. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_REPLACEONLY"></a><a id="sp_copy_replaceonly"></a><dl>
///                <dt><b>SP_COPY_REPLACEONLY</b></dt> </dl> </td> <td width="60%"> Copy the file only if doing so overwrites a file
///                at the destination path. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NEWER_OR_SAME"></a><a
///                id="sp_copy_newer_or_same"></a><dl> <dt><b>SP_COPY_NEWER_OR_SAME</b></dt> </dl> </td> <td width="60%"> Examine
///                each file being copied to see if its version resources indicate that it is either the same version or not newer
///                than an existing copy on the target. The file version information used during version checks is that specified in
///                the <b>dwFileVersionMS</b> and <b>dwFileVersionLS</b> members of a VS_FIXEDFILEINFO structure, as filled in by
///                the version functions. If one of the files does not have version resources, or if they have identical version
///                information, the source file is considered newer. If the source file is not newer or equal in version, and
///                <i>CopyMsgHandler</i> is specified, the caller is notified and may cancel the copy. If <i>CopyMsgHandler</i> is
///                not specified, the file is not copied. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NEWER_ONLY"></a><a
///                id="sp_copy_newer_only"></a><dl> <dt><b>SP_COPY_NEWER_ONLY</b></dt> </dl> </td> <td width="60%"> Examine each
///                file being copied to see if its version resources indicate that it is not newer than an existing copy on the
///                target. If the source file is newer but not equal in version to the existing target, the file is copied. </td>
///                </tr> <tr> <td width="40%"><a id="SP_COPY_NOOVERWRITE"></a><a id="sp_copy_nooverwrite"></a><dl>
///                <dt><b>SP_COPY_NOOVERWRITE</b></dt> </dl> </td> <td width="60%"> Check whether the target file exists, and if so,
///                notify the caller who may veto the copy. If <i>CopyMsgHandler</i> is not specified, the file is not overwritten.
///                </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NODECOMP"></a><a id="sp_copy_nodecomp"></a><dl>
///                <dt><b>SP_COPY_NODECOMP</b></dt> </dl> </td> <td width="60%"> Do not decompress the file. When this flag is set,
///                the target file is not given the uncompressed form of the source name (if appropriate). For example, copying
///                "f:\x86\cmd.ex_" to "\\install\temp" results in a target file of "\\install\temp\cmd.ex_". If the
///                SP_COPY_NODECOMP flag was not specified, the file would be decompressed and the target would be called
///                "\\install\temp\cmd.exe". The filename part of <i>DestinationName</i>, if specified, is stripped and replaced
///                with the filename of the source file. When SP_COPY_NODECOMP is specified, no language or version information can
///                be checked. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_LANGUAGEAWARE"></a><a
///                id="sp_copy_languageaware"></a><dl> <dt><b>SP_COPY_LANGUAGEAWARE</b></dt> </dl> </td> <td width="60%"> Examine
///                each file being copied to see if its language differs from the language of any existing file already on the
///                target. If so, and <i>CopyMsgHandler</i> is specified, the caller is notified and may cancel the copy. If
///                <i>CopyMsgHandler</i> is not specified, the file is not copied. </td> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_SOURCE_ABSOLUTE"></a><a id="sp_copy_source_absolute"></a><dl> <dt><b>SP_COPY_SOURCE_ABSOLUTE</b></dt>
///                </dl> </td> <td width="60%"> <i>SourceFile</i> is a full source path. Do not look it up in the SourceDisksNames
///                section of the INF file. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_SOURCEPATH_ABSOLUTE"></a><a
///                id="sp_copy_sourcepath_absolute"></a><dl> <dt><b>SP_COPY_SOURCEPATH_ABSOLUTE</b></dt> </dl> </td> <td
///                width="60%"> <i>SourcePathRoot</i> is the full path part of the source file. Ignore the relative source specified
///                in the SourceDisksNames section of the INF file for the source media where the file is located. This flag is
///                ignored if SP_COPY_SOURCE_ABSOLUTE is specified. </td> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_FORCE_IN_USE"></a><a id="sp_copy_force_in_use"></a><dl> <dt><b>SP_COPY_FORCE_IN_USE</b></dt> </dl>
///                </td> <td width="60%"> If the target exists, behave as if it is in use and queue the file for copying on the next
///                system reboot. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_IN_USE_NEEDS_REBOOT"></a><a
///                id="sp_copy_in_use_needs_reboot"></a><dl> <dt><b>SP_COPY_IN_USE_NEEDS_REBOOT</b></dt> </dl> </td> <td
///                width="60%"> If the file was in use during the copy operation, alert the user that the system requires a reboot.
///                </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NOSKIP"></a><a id="sp_copy_noskip"></a><dl>
///                <dt><b>SP_COPY_NOSKIP</b></dt> </dl> </td> <td width="60%"> Do not give the user the option to skip a file. </td>
///                </tr> <tr> <td width="40%"><a id="SP_COPY_FORCE_NOOVERWRITE"></a><a id="sp_copy_force_nooverwrite"></a><dl>
///                <dt><b>SP_COPY_FORCE_NOOVERWRITE</b></dt> </dl> </td> <td width="60%"> Check whether the target file exists, and
///                if so, the file is not overwritten. The caller is not notified. </td> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_FORCE_NEWER"></a><a id="sp_copy_force_newer"></a><dl> <dt><b>SP_COPY_FORCE_NEWER</b></dt> </dl> </td>
///                <td width="60%"> Examine each file being copied to see if its version resources (or time stamps for non-image
///                files) indicate that it is not newer than an existing copy on the target. If the file being copied is not newer,
///                the file is not copied. The caller is not notified. </td> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_WARNIFSKIP"></a><a id="sp_copy_warnifskip"></a><dl> <dt><b>SP_COPY_WARNIFSKIP</b></dt> </dl> </td>
///                <td width="60%"> If the user tries to skip a file, warn them that skipping a file may affect the installation.
///                (Used for system-critical files.) </td> </tr> </table>
///    CopyMsgHandler = Optional pointer to a callback function to be notified of various conditions that may arise during the file copy.
///    Context = Pointer to a caller-defined value that is passed as the first parameter of the callback function.
///    FileWasInUse = Pointer to a variable in which this function returns a flag that indicates whether the file was in use. This
///                   parameter is required.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError. If GetLastError returns NO_ERROR, the file copy operation
///    was not completed. The file may not have been copied because the file copy operation was unnecessary or because
///    the file callback function returned <b>FALSE</b>.
///    
@DllImport("SETUPAPI")
BOOL SetupInstallFileExW(void* InfHandle, INFCONTEXT* InfContext, const(wchar)* SourceFile, 
                         const(wchar)* SourcePathRoot, const(wchar)* DestinationName, uint CopyStyle, 
                         PSP_FILE_CALLBACK_W CopyMsgHandler, void* Context, int* FileWasInUse);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupOpenFileQueue</b> function creates a setup file queue.
///Returns:
///    If the function succeeds, it returns a handle to a setup file queue. If there is not enough memory to create the
///    queue, the function returns INVALID_HANDLE_VALUE. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
void* SetupOpenFileQueue();

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupCloseFileQueue</b> function destroys a setup file queue.
///Params:
///    QueueHandle = Handle to an open setup file queue.
///Returns:
///    This function does not return a value.
///    
@DllImport("SETUPAPI")
BOOL SetupCloseFileQueue(void* QueueHandle);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupSetFileQueueAlternatePlatform</b> function associates the file queue with
///a target platform that is different from the platform running the function. This is done to enable for non-native
///signature verification.
///Params:
///    QueueHandle = Handle to an open setup file queue.
///    AlternatePlatformInfo = Optional pointer to an SP_ALTPLATFORM_INFO structure passing information about the alternate platform. On Windows
///                            2000, the <b>cbSize</b> member of this structure must be set to sizeof(SP_ALTPLATFORM_INFO_V1). On Windows Server
///                            2003 or Windows XP, the <b>cbSize</b> member of this structure must be set to sizeof(SP_ALTPLATFORM_INFO_V2).
///    AlternateDefaultCatalogFile = Pointer to a <b>null</b>-terminated string that specifies a catalog that validates any INF files. This parameter
///                                  may be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupSetFileQueueAlternatePlatformA(void* QueueHandle, SP_ALTPLATFORM_INFO_V2* AlternatePlatformInfo, 
                                         const(char)* AlternateDefaultCatalogFile);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupSetFileQueueAlternatePlatform</b> function associates the file queue with
///a target platform that is different from the platform running the function. This is done to enable for non-native
///signature verification.
///Params:
///    QueueHandle = Handle to an open setup file queue.
///    AlternatePlatformInfo = Optional pointer to an SP_ALTPLATFORM_INFO structure passing information about the alternate platform. On Windows
///                            2000, the <b>cbSize</b> member of this structure must be set to sizeof(SP_ALTPLATFORM_INFO_V1). On Windows Server
///                            2003 or Windows XP, the <b>cbSize</b> member of this structure must be set to sizeof(SP_ALTPLATFORM_INFO_V2).
///    AlternateDefaultCatalogFile = Pointer to a <b>null</b>-terminated string that specifies a catalog that validates any INF files. This parameter
///                                  may be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupSetFileQueueAlternatePlatformW(void* QueueHandle, SP_ALTPLATFORM_INFO_V2* AlternatePlatformInfo, 
                                         const(wchar)* AlternateDefaultCatalogFile);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupSetPlatformPathOverride</b> function is used to set a platform path
///override for a target machine when working with INFs from a different machine. As such, it can refer to a different
///platform than it is currently running on. For dealing with media sources, it can refer to platforms that are no
///longer supported, such as Alpha, MIPS, and PPC. It removes the platform path override if none is specified.
///Params:
///    Override = Pointer to a <b>null</b>-terminated string that contains the replacement platform information. For example,
///               "alpha" or "x86". This parameter may be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError. If GetLastError returns ERROR_NOT_ENOUGH_MEMORY,
///    <b>SetupSetPlatformPathOverride</b> was unable to store the <i>Override</i> string.
///    
@DllImport("SETUPAPI")
BOOL SetupSetPlatformPathOverrideA(const(char)* Override);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupSetPlatformPathOverride</b> function is used to set a platform path
///override for a target machine when working with INFs from a different machine. As such, it can refer to a different
///platform than it is currently running on. For dealing with media sources, it can refer to platforms that are no
///longer supported, such as Alpha, MIPS, and PPC. It removes the platform path override if none is specified.
///Params:
///    Override = Pointer to a <b>null</b>-terminated string that contains the replacement platform information. For example,
///               "alpha" or "x86". This parameter may be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError. If GetLastError returns ERROR_NOT_ENOUGH_MEMORY,
///    <b>SetupSetPlatformPathOverride</b> was unable to store the <i>Override</i> string.
///    
@DllImport("SETUPAPI")
BOOL SetupSetPlatformPathOverrideW(const(wchar)* Override);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueCopy</b> function adds a single file copy operation to a setup file
///queue.
///Params:
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    SourceRootPath = Pointer to a <b>null</b>-terminated string that specifies the root of the source for this copy, such as A:\.
///    SourcePath = Pointer to a <b>null</b>-terminated string that specifies the path relative to <i>SourceRootPath</i> where the
///                 file can be found. This parameter may be <b>NULL</b>.
///    SourceFilename = Pointer to a <b>null</b>-terminated string that specifies the file name part of the file to be copied.
///    SourceDescription = Pointer to a <b>null</b>-terminated string that specifies a description of the source media to be used during
///                        disk prompts. This parameter can be <b>NULL</b>.
///    SourceTagfile = Pointer to a <b>null</b>-terminated string that specifies a tag file whose presence at <i>SourceRootPath</i>
///                    indicates the presence of the source media. This parameter may be <b>NULL</b>. If not specified, the file itself
///                    will be used as the tag file if required.
///    TargetDirectory = Pointer to a <b>null</b>-terminated string that specifies the directory where the file is to be copied.
///    TargetFilename = Pointer to a <b>null</b>-terminated string that specifies the name of the target file. This parameter may be
///                     <b>NULL</b>. If not specified, the target file will have the same name as the source file.
///    CopyStyle = Specifies the behavior of the file copy operation. This parameter may be a combination of the following values.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueCopyA(void* QueueHandle, const(char)* SourceRootPath, const(char)* SourcePath, 
                     const(char)* SourceFilename, const(char)* SourceDescription, const(char)* SourceTagfile, 
                     const(char)* TargetDirectory, const(char)* TargetFilename, uint CopyStyle);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueCopy</b> function adds a single file copy operation to a setup file
///queue.
///Params:
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    SourceRootPath = Pointer to a <b>null</b>-terminated string that specifies the root of the source for this copy, such as A:\.
///    SourcePath = Pointer to a <b>null</b>-terminated string that specifies the path relative to <i>SourceRootPath</i> where the
///                 file can be found. This parameter may be <b>NULL</b>.
///    SourceFilename = Pointer to a <b>null</b>-terminated string that specifies the file name part of the file to be copied.
///    SourceDescription = Pointer to a <b>null</b>-terminated string that specifies a description of the source media to be used during
///                        disk prompts. This parameter can be <b>NULL</b>.
///    SourceTagfile = Pointer to a <b>null</b>-terminated string that specifies a tag file whose presence at <i>SourceRootPath</i>
///                    indicates the presence of the source media. This parameter may be <b>NULL</b>. If not specified, the file itself
///                    will be used as the tag file if required.
///    TargetDirectory = Pointer to a <b>null</b>-terminated string that specifies the directory where the file is to be copied.
///    TargetFilename = Pointer to a <b>null</b>-terminated string that specifies the name of the target file. This parameter may be
///                     <b>NULL</b>. If not specified, the target file will have the same name as the source file.
///    CopyStyle = Specifies the behavior of the file copy operation. This parameter may be a combination of the following values.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueCopyW(void* QueueHandle, const(wchar)* SourceRootPath, const(wchar)* SourcePath, 
                     const(wchar)* SourceFilename, const(wchar)* SourceDescription, const(wchar)* SourceTagfile, 
                     const(wchar)* TargetDirectory, const(wchar)* TargetFilename, uint CopyStyle);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueCopyIndirect</b> function is an extended form of SetupQueueCopy
///passing additional parameters as a structure (SP_FILE_COPY_PARAMS). Other than this, the behavior is identical.
///Params:
///    CopyParams = Pointer to a SP_FILE_COPY_PARAMS structure that describes the file copy operation.
///Returns:
///    If the function succeeds, the return value is an nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueCopyIndirectA(SP_FILE_COPY_PARAMS_A* CopyParams);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueCopyIndirect</b> function is an extended form of SetupQueueCopy
///passing additional parameters as a structure (SP_FILE_COPY_PARAMS). Other than this, the behavior is identical.
///Params:
///    CopyParams = Pointer to a SP_FILE_COPY_PARAMS structure that describes the file copy operation.
///Returns:
///    If the function succeeds, the return value is an nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueCopyIndirectW(SP_FILE_COPY_PARAMS_W* CopyParams);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueDefaultCopy</b> function adds a single file to a setup file queue
///for copying, using the default source media and destination as specified in an INF file.
///Params:
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    InfHandle = Handle to an open INF file that contains the <b>SourceDisksFiles</b> and <b>SourceDisksNames</b> sections. If
///                platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and
///                <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
///    SourceRootPath = Pointer to a null-terminated string that specifies the root directory of the source for this copy such as A:\.
///    SourceFilename = Pointer to a null-terminated string that specifies the file name of the file to be copied.
///    TargetFilename = Pointer to a null-terminated string that specifies the file name of the target file.
///    CopyStyle = Flags that control the behavior of the file copy operation. These flags may be a combination of the following
///                values.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueDefaultCopyA(void* QueueHandle, void* InfHandle, const(char)* SourceRootPath, 
                            const(char)* SourceFilename, const(char)* TargetFilename, uint CopyStyle);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueDefaultCopy</b> function adds a single file to a setup file queue
///for copying, using the default source media and destination as specified in an INF file.
///Params:
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    InfHandle = Handle to an open INF file that contains the <b>SourceDisksFiles</b> and <b>SourceDisksNames</b> sections. If
///                platform-specific sections exist for the user's system (for example, <b>SourceDisksNames.x86</b> and
///                <b>SourceDisksFiles.x86</b>), the platform-specific section will be used.
///    SourceRootPath = Pointer to a null-terminated string that specifies the root directory of the source for this copy such as A:\.
///    SourceFilename = Pointer to a null-terminated string that specifies the file name of the file to be copied.
///    TargetFilename = Pointer to a null-terminated string that specifies the file name of the target file.
///    CopyStyle = Flags that control the behavior of the file copy operation. These flags may be a combination of the following
///                values.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueDefaultCopyW(void* QueueHandle, void* InfHandle, const(wchar)* SourceRootPath, 
                            const(wchar)* SourceFilename, const(wchar)* TargetFilename, uint CopyStyle);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueCopySection</b> function places all the files in a section of an INF
///file in a setup queue for copying. The section must be in the correct <b>Copy Files</b> format and the INF file must
///contain <b>SourceDisksFiles</b> and <b>SourceDisksNames</b> sections (or have had the INF files containing those
///sections appended).
///Params:
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    SourceRootPath = Pointer to a null-terminated string that specifies the root of the source for this copy, such as A:\.
///    InfHandle = Handle to an open INF file that contains the <b>SourceDisksFiles</b> and <b>SourceDisksNames</b> sections. If
///                <i>ListInfHandle</i> is not specified, <i>InfHandle</i> contains the section names. If platform-specific sections
///                exist for the user's system (for example, SourceDisksNames.x86 and SourceDisksFiles.x86), the platform-specific
///                section will be used.
///    ListInfHandle = Optional handle to an open INF file that contains the section to queue for copying. If <i>ListInfHandle</i> is
///                    not specified, <i>InfHandle</i> is assumed to contain the section.
///    Section = Pointer to a null-terminated string that specifies the name of the section to be queued for copy.
///    CopyStyle = Flags that control the behavior of the file copy operation. These flags may be a combination of the following
///                values.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueCopySectionA(void* QueueHandle, const(char)* SourceRootPath, void* InfHandle, void* ListInfHandle, 
                            const(char)* Section, uint CopyStyle);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueCopySection</b> function places all the files in a section of an INF
///file in a setup queue for copying. The section must be in the correct <b>Copy Files</b> format and the INF file must
///contain <b>SourceDisksFiles</b> and <b>SourceDisksNames</b> sections (or have had the INF files containing those
///sections appended).
///Params:
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    SourceRootPath = Pointer to a null-terminated string that specifies the root of the source for this copy, such as A:\.
///    InfHandle = Handle to an open INF file that contains the <b>SourceDisksFiles</b> and <b>SourceDisksNames</b> sections. If
///                <i>ListInfHandle</i> is not specified, <i>InfHandle</i> contains the section names. If platform-specific sections
///                exist for the user's system (for example, SourceDisksNames.x86 and SourceDisksFiles.x86), the platform-specific
///                section will be used.
///    ListInfHandle = Optional handle to an open INF file that contains the section to queue for copying. If <i>ListInfHandle</i> is
///                    not specified, <i>InfHandle</i> is assumed to contain the section.
///    Section = Pointer to a null-terminated string that specifies the name of the section to be queued for copy.
///    CopyStyle = Flags that control the behavior of the file copy operation. These flags may be a combination of the following
///                values.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueCopySectionW(void* QueueHandle, const(wchar)* SourceRootPath, void* InfHandle, void* ListInfHandle, 
                            const(wchar)* Section, uint CopyStyle);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueDelete</b> function places an individual file delete operation on a
///setup file queue.
///Params:
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    PathPart1 = Pointer to a <b>null</b>-terminated string that specifies the first part of the path of the file to be deleted.
///                If <i>PathPart2</i> is <b>NULL</b>, <i>PathPart1</i> is the full path of the file to be deleted.
///    PathPart2 = Pointer to a <b>null</b>-terminated string that specifies the second part of the path of the file to be deleted.
///                This parameter may be <b>NULL</b>. This is appended to <i>PathPart1</i> to form the full path of the file to be
///                deleted. The function checks for and collapses duplicated path separators when it combines <i>PathPart1</i> and
///                <i>PathPart2</i>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueDeleteA(void* QueueHandle, const(char)* PathPart1, const(char)* PathPart2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueDelete</b> function places an individual file delete operation on a
///setup file queue.
///Params:
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    PathPart1 = Pointer to a <b>null</b>-terminated string that specifies the first part of the path of the file to be deleted.
///                If <i>PathPart2</i> is <b>NULL</b>, <i>PathPart1</i> is the full path of the file to be deleted.
///    PathPart2 = Pointer to a <b>null</b>-terminated string that specifies the second part of the path of the file to be deleted.
///                This parameter may be <b>NULL</b>. This is appended to <i>PathPart1</i> to form the full path of the file to be
///                deleted. The function checks for and collapses duplicated path separators when it combines <i>PathPart1</i> and
///                <i>PathPart2</i>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueDeleteW(void* QueueHandle, const(wchar)* PathPart1, const(wchar)* PathPart2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueDeleteSection</b> function queues all the files in a section of an
///INF file for deletion. The section must be in the correct <b>Delete Files</b> format and the INF file must contain a
///<b>DestinationDirs</b> section.
///Params:
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    InfHandle = Handle to an open INF file that contains the <b>DestinationDirs</b> section. If <i>ListInfHandle</i> is not
///                specified, <i>InfHandle</i> contains the section name.
///    ListInfHandle = Optional handle to an open INF file that contains the section to queue for deletion. If <i>ListInfHandle</i> is
///                    not specified, <i>InfHandle</i> is assumed to contain the section name.
///    Section = Pointer to a null-terminated string that specifies the name of the section to be queued for deletion.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueDeleteSectionA(void* QueueHandle, void* InfHandle, void* ListInfHandle, const(char)* Section);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueDeleteSection</b> function queues all the files in a section of an
///INF file for deletion. The section must be in the correct <b>Delete Files</b> format and the INF file must contain a
///<b>DestinationDirs</b> section.
///Params:
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    InfHandle = Handle to an open INF file that contains the <b>DestinationDirs</b> section. If <i>ListInfHandle</i> is not
///                specified, <i>InfHandle</i> contains the section name.
///    ListInfHandle = Optional handle to an open INF file that contains the section to queue for deletion. If <i>ListInfHandle</i> is
///                    not specified, <i>InfHandle</i> is assumed to contain the section name.
///    Section = Pointer to a null-terminated string that specifies the name of the section to be queued for deletion.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueDeleteSectionW(void* QueueHandle, void* InfHandle, void* ListInfHandle, const(wchar)* Section);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueRename</b> function places an individual file rename operation on a
///setup file queue.
///Params:
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    SourcePath = Pointer to a null-terminated string that specifies the source path of the file to be renamed. If
///                 <i>SourceFileName</i> is not specified, <i>SourcePath</i> is assumed to be the full path.
///    SourceFilename = Pointer to a null-terminated string that specifies the file name part of the file to be renamed. If not
///                     specified, <i>SourcePath</i> is the full path.
///    TargetPath = Pointer to a null-terminated string that specifies the target directory. When this parameter is specified, the
///                 rename operation is actually a move operation. If <i>TargetPath</i> is not specified, the file is renamed but
///                 remains in its current location.
///    TargetFilename = Pointer to a null-terminated string that specifies the new name for the source file.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueRenameA(void* QueueHandle, const(char)* SourcePath, const(char)* SourceFilename, 
                       const(char)* TargetPath, const(char)* TargetFilename);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueRename</b> function places an individual file rename operation on a
///setup file queue.
///Params:
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    SourcePath = Pointer to a null-terminated string that specifies the source path of the file to be renamed. If
///                 <i>SourceFileName</i> is not specified, <i>SourcePath</i> is assumed to be the full path.
///    SourceFilename = Pointer to a null-terminated string that specifies the file name part of the file to be renamed. If not
///                     specified, <i>SourcePath</i> is the full path.
///    TargetPath = Pointer to a null-terminated string that specifies the target directory. When this parameter is specified, the
///                 rename operation is actually a move operation. If <i>TargetPath</i> is not specified, the file is renamed but
///                 remains in its current location.
///    TargetFilename = Pointer to a null-terminated string that specifies the new name for the source file.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueRenameW(void* QueueHandle, const(wchar)* SourcePath, const(wchar)* SourceFilename, 
                       const(wchar)* TargetPath, const(wchar)* TargetFilename);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueRenameSection</b> function queues a section in an INF file for
///renaming. The section must be in the correct rename list section format and the INF file must contain a
///<b>DestinationDirs</b> section.
///Params:
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    InfHandle = Handle to the INF file that contains the <b>DestinationDirs</b> section. If <i>ListInfHandle</i> is not
///                specified, <i>InfHandle</i> contains the section name.
///    ListInfHandle = Optional handle to an INF file that contains the section to queue for renaming. If <i>ListInfHandle</i> is not
///                    specified, <i>InfHandle</i> is assumed to contain the section name.
///    Section = Name of the section to be queued for renaming.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueRenameSectionA(void* QueueHandle, void* InfHandle, void* ListInfHandle, const(char)* Section);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueueRenameSection</b> function queues a section in an INF file for
///renaming. The section must be in the correct rename list section format and the INF file must contain a
///<b>DestinationDirs</b> section.
///Params:
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    InfHandle = Handle to the INF file that contains the <b>DestinationDirs</b> section. If <i>ListInfHandle</i> is not
///                specified, <i>InfHandle</i> contains the section name.
///    ListInfHandle = Optional handle to an INF file that contains the section to queue for renaming. If <i>ListInfHandle</i> is not
///                    specified, <i>InfHandle</i> is assumed to contain the section name.
///    Section = Name of the section to be queued for renaming.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueueRenameSectionW(void* QueueHandle, void* InfHandle, void* ListInfHandle, const(wchar)* Section);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupCommitFileQueue</b> function performs file operations queued on a setup
///file queue. The best practice is to collect all the required file operations for the file queue and commit the queue
///only once because a file queue cannot be reused after it has been committed. If additional processing of the queue is
///required after it has been committed, the handle to the queue should be closed and a new file queue created. For more
///information, see Committing a Queue. If a file is modified, the caller of this function is required have privileges
///to write into the target directory.
///Params:
///    Owner = Optional handle to a window to use as the parent of any progress dialog boxes.
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    MsgHandler = Pointer to an optional callback routine to be notified of various significant events that are in the queue
///                 processing. For more information, see Default Queue Callback Routine or FileCallback If the callback routine is
///                 <b>null</b>, <b>SetupCommitFileQueue</b> returns <b>TRUE</b> and the error is 0 or NO_ERROR.
///    Context = Value that is passed to the callback function supplied by the <i>MsgHandler</i> parameter. If the default
///              callback routine has been specified as <i>MsgHandler</i>, this context must be the context returned from
///              SetupInitDefaultQueueCallback or SetupInitDefaultQueueCallbackEx.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupCommitFileQueueA(HWND Owner, void* QueueHandle, PSP_FILE_CALLBACK_A MsgHandler, void* Context);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupCommitFileQueue</b> function performs file operations queued on a setup
///file queue. The best practice is to collect all the required file operations for the file queue and commit the queue
///only once because a file queue cannot be reused after it has been committed. If additional processing of the queue is
///required after it has been committed, the handle to the queue should be closed and a new file queue created. For more
///information, see Committing a Queue. If a file is modified, the caller of this function is required have privileges
///to write into the target directory.
///Params:
///    Owner = Optional handle to a window to use as the parent of any progress dialog boxes.
///    QueueHandle = Handle to a setup file queue, as returned by SetupOpenFileQueue.
///    MsgHandler = Pointer to an optional callback routine to be notified of various significant events that are in the queue
///                 processing. For more information, see Default Queue Callback Routine or FileCallback If the callback routine is
///                 <b>null</b>, <b>SetupCommitFileQueue</b> returns <b>TRUE</b> and the error is 0 or NO_ERROR.
///    Context = Value that is passed to the callback function supplied by the <i>MsgHandler</i> parameter. If the default
///              callback routine has been specified as <i>MsgHandler</i>, this context must be the context returned from
///              SetupInitDefaultQueueCallback or SetupInitDefaultQueueCallbackEx.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupCommitFileQueueW(HWND Owner, void* QueueHandle, PSP_FILE_CALLBACK_W MsgHandler, void* Context);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupScanFileQueue</b> function scans a setup file queue, performing an
///operation on each node in its copy list. The operation is specified by a set of flags. This function can be called
///either before or after the queue has been committed.
///Params:
///    FileQueue = Handle to the setup file queue whose copy list is to be scanned or iterated.
///    Flags = Flags to combine to control the file queue scan operation. Note that either SPQ_SCAN_FILE_PRESENCE,
///            SPQ_SCAN_USE_CALLBACK, SPQ_SCAN_USE_CALLBACKEX, or SPQ_SCAN_FILE_VALIDITY must be specified. <table> <tr>
///            <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SPQ_SCAN_FILE_PRESENCE"></a><a
///            id="spq_scan_file_presence"></a><dl> <dt><b>SPQ_SCAN_FILE_PRESENCE</b></dt> </dl> </td> <td width="60%"> Target
///            files in the copy queue are already present on the target. </td> </tr> <tr> <td width="40%"><a
///            id="SPQ_SCAN_FILE_VALIDITY"></a><a id="spq_scan_file_validity"></a><dl> <dt><b>SPQ_SCAN_FILE_VALIDITY</b></dt>
///            </dl> </td> <td width="60%"> Target files in the copy queue are already present on the target with valid
///            signatures. Available with Windows 2000 and later versions. </td> </tr> <tr> <td width="40%"><a
///            id="SPQ_SCAN_USE_CALLBACK"></a><a id="spq_scan_use_callback"></a><dl> <dt><b>SPQ_SCAN_USE_CALLBACK</b></dt> </dl>
///            </td> <td width="60%"> Callback routine for each node of the queue. If the callback routine returns a nonzero
///            value, the queue processing stops and <b>SetupScanFileQueue</b> returns zero. Issue a SPFILENOTIFY_QUEUESCAN
///            notification code and a pass a pointer to the target path as <i>Param1</i>. </td> </tr> <tr> <td width="40%"><a
///            id="SPQ_SCAN_USE_CALLBACKEX"></a><a id="spq_scan_use_callbackex"></a><dl> <dt><b>SPQ_SCAN_USE_CALLBACKEX</b></dt>
///            </dl> </td> <td width="60%"> Callback routine for each node of the queue. If the callback routine returns a
///            nonzero value, the queue processing stops and <b>SetupScanFileQueue</b> returns zero. Issue a
///            SPFILENOTIFY_QUEUESCAN_EX notification and pass a pointer to a FILEPATHS structure as <i>Param1</i>.
///            SPQ_SCAN_USE_CALLBACKEX also checks that the file has a valid signature. Available starting with Windows 2000. On
///            Windows XP only, you can turn off signature checking by combining this flag with SPQ_SCAN_FILE_PRESENCE. </td>
///            </tr> <tr> <td width="40%"><a id="SPQ_SCAN_INFORM_USER"></a><a id="spq_scan_inform_user"></a><dl>
///            <dt><b>SPQ_SCAN_INFORM_USER</b></dt> </dl> </td> <td width="60%"> Flag specified when all files in the queue pass
///            the check for valid signatures. <b>SetupScanFileQueue</b> informs the user that the operation requires files that
///            are already present on the target. This flag is ignored if SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY is
///            not specified. This flag may not be used with SPQ_SCAN_PRUNE_COPY_QUEUE or SPQ_SCAN_PRUNE_DELREN. </td> </tr>
///            <tr> <td width="40%"><a id="SPQ_SCAN_PRUNE_COPY_QUEUE"></a><a id="spq_scan_prune_copy_queue"></a><dl>
///            <dt><b>SPQ_SCAN_PRUNE_COPY_QUEUE</b></dt> </dl> </td> <td width="60%"> Combined with SPQ_SCAN_FILE_PRESENCE,
///            removes present entries from the copy queue. When combined with SPQ_SCAN_FILE_VALIDITY, removes signed entries
///            from the copy queue. Available starting with Windows 2000. On Windows XP only, files that are also specified in
///            the delete queue or rename queues are not pruned unless SPQ_SCAN_PRUNE_DELREN is specified. </td> </tr> <tr> <td
///            width="40%"><a id="SPQ_SCAN_USE_CALLBACK_SIGNERINFO"></a><a id="spq_scan_use_callback_signerinfo"></a><dl>
///            <dt><b>SPQ_SCAN_USE_CALLBACK_SIGNERINFO</b></dt> </dl> </td> <td width="60%"> Available starting with Windows XP.
///            Issues SPFILENOTIFY_QUEUESCAN_SIGNERINFO notification and passes a pointer to a FILEPATHS_SIGNERINFO structure as
///            <i>Param1</i>. Checks each file for a valid signature and reports signature information through the callback
///            function. </td> </tr> <tr> <td width="40%"><a id="SPQ_SCAN_PRUNE_DELREN"></a><a
///            id="spq_scan_prune_delren"></a><dl> <dt><b>SPQ_SCAN_PRUNE_DELREN</b></dt> </dl> </td> <td width="60%"> Combined
///            with SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY, removes entries in the delete or rename queue that are
///            also in the copy queue. When combined with SPQ_SCAN_PRUNE_COPY_QUEUE, limits files that are removed from the copy
///            queue to files that are not in the delete or rename queues. Available starting with Windows XP. </td> </tr>
///            </table>
///    Window = Optional handle to the window to own dialog boxes that are presented. This parameter is not used if the
///             <i>Flags</i> parameter does not contain SPQ_SCAN_FILE_PRESENCE or if <i>Flags</i> does not contain
///             SPQ_SCAN_INFORM_USER.
///    CallbackRoutine = Optional pointer to a FileCallback callback function to be called on each node of the copy queue. The
///                      notification code passed to the callback function is SPFILENOTIFY_QUEUESCAN. This parameter is required if
///                      <i>Flags</i> includes SPQ_SCAN_USE_CALLBACK. <div class="alert"><b>Note</b> You must supply the callback routine
///                      specified by <i>CallbackRoutine</i>. The default queue callback routine does not support
///                      <b>SetupScanFileQueue</b>.</div> <div> </div>
///    CallbackContext = Optional pointer to a context that contains caller-defined data passed to the callback routine pointed to by
///                      <i>CallbackRoutine</i>.
///    Result = Pointer to a variable that receives the result of the scan operation.
///Returns:
///    The function returns a nonzero value if all nodes in the queue were processed. If the SPQ_SCAN_USE_CALLBACK flag
///    was set, the value in <i>Result</i> is 0. The callback routine specified by <i>CallbackRoutine</i> is sent the
///    notification SPFILENOTIFY_QUEUESCAN. <i>CallbackRoutine.Param1</i> specifies a pointer to an array that contains
///    the target path information. The pointer has been cast to an unsigned integer and must be recast to a TCHAR array
///    of MAX_PATH elements before a callback routine can access the information. <i>CallbackRoutine.Param2</i> is set
///    to SPQ_DELAYED_COPY if the current queue node is in use and cannot be copied until the system is restarted.
///    Otherwise, <i>CallbackRoutine.Param2</i> takes the value 0. If SPQ_SCAN_USE_CALLBACK was not set, <i>Result</i>
///    indicates whether the queue passed the presence or validity check as shown in the following table. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>0</b></dt> </dl> </td> <td
///    width="60%"> The queue failed the check or it passed the check, but SPQ_SCAN_INFORM_USER was specified and the
///    user wants new copies of the files. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>1</b></dt> </dl> </td> <td
///    width="60%"> The queue passed the check and, if SPQ_SCAN_INFORM_USER was specified, the user indicated that
///    copying is not required. The copy queue is empty and there are no elements on the delete or rename queues, so the
///    caller can skip queue commit. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>2</b></dt> </dl> </td> <td
///    width="60%"> The queue passed the check and, if SPQ_SCAN_INFORM_USER was specified, the user indicated that
///    copying is not required. The copy queue is empty, but there are elements on the delete or rename queues, so the
///    caller cannot skip queue commit. </td> </tr> </table> The function returns zero if an error occurred or the
///    callback function returned nonzero. If <i>Result</i> is nonzero, it is the value returned by the callback
///    function that stopped queue processing. If <i>Result</i> is zero, extended error information can be retrieved by
///    a call to GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupScanFileQueueA(void* FileQueue, uint Flags, HWND Window, PSP_FILE_CALLBACK_A CallbackRoutine, 
                         void* CallbackContext, uint* Result);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupScanFileQueue</b> function scans a setup file queue, performing an
///operation on each node in its copy list. The operation is specified by a set of flags. This function can be called
///either before or after the queue has been committed.
///Params:
///    FileQueue = Handle to the setup file queue whose copy list is to be scanned or iterated.
///    Flags = Flags to combine to control the file queue scan operation. Note that either SPQ_SCAN_FILE_PRESENCE,
///            SPQ_SCAN_USE_CALLBACK, SPQ_SCAN_USE_CALLBACKEX, or SPQ_SCAN_FILE_VALIDITY must be specified. <table> <tr>
///            <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SPQ_SCAN_FILE_PRESENCE"></a><a
///            id="spq_scan_file_presence"></a><dl> <dt><b>SPQ_SCAN_FILE_PRESENCE</b></dt> </dl> </td> <td width="60%"> Target
///            files in the copy queue are already present on the target. </td> </tr> <tr> <td width="40%"><a
///            id="SPQ_SCAN_FILE_VALIDITY"></a><a id="spq_scan_file_validity"></a><dl> <dt><b>SPQ_SCAN_FILE_VALIDITY</b></dt>
///            </dl> </td> <td width="60%"> Target files in the copy queue are already present on the target with valid
///            signatures. Available with Windows 2000 and later versions. </td> </tr> <tr> <td width="40%"><a
///            id="SPQ_SCAN_USE_CALLBACK"></a><a id="spq_scan_use_callback"></a><dl> <dt><b>SPQ_SCAN_USE_CALLBACK</b></dt> </dl>
///            </td> <td width="60%"> Callback routine for each node of the queue. If the callback routine returns a nonzero
///            value, the queue processing stops and <b>SetupScanFileQueue</b> returns zero. Issue a SPFILENOTIFY_QUEUESCAN
///            notification code and a pass a pointer to the target path as <i>Param1</i>. </td> </tr> <tr> <td width="40%"><a
///            id="SPQ_SCAN_USE_CALLBACKEX"></a><a id="spq_scan_use_callbackex"></a><dl> <dt><b>SPQ_SCAN_USE_CALLBACKEX</b></dt>
///            </dl> </td> <td width="60%"> Callback routine for each node of the queue. If the callback routine returns a
///            nonzero value, the queue processing stops and <b>SetupScanFileQueue</b> returns zero. Issue a
///            SPFILENOTIFY_QUEUESCAN_EX notification and pass a pointer to a FILEPATHS structure as <i>Param1</i>.
///            SPQ_SCAN_USE_CALLBACKEX also checks that the file has a valid signature. Available starting with Windows 2000. On
///            Windows XP only, you can turn off signature checking by combining this flag with SPQ_SCAN_FILE_PRESENCE. </td>
///            </tr> <tr> <td width="40%"><a id="SPQ_SCAN_INFORM_USER"></a><a id="spq_scan_inform_user"></a><dl>
///            <dt><b>SPQ_SCAN_INFORM_USER</b></dt> </dl> </td> <td width="60%"> Flag specified when all files in the queue pass
///            the check for valid signatures. <b>SetupScanFileQueue</b> informs the user that the operation requires files that
///            are already present on the target. This flag is ignored if SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY is
///            not specified. This flag may not be used with SPQ_SCAN_PRUNE_COPY_QUEUE or SPQ_SCAN_PRUNE_DELREN. </td> </tr>
///            <tr> <td width="40%"><a id="SPQ_SCAN_PRUNE_COPY_QUEUE"></a><a id="spq_scan_prune_copy_queue"></a><dl>
///            <dt><b>SPQ_SCAN_PRUNE_COPY_QUEUE</b></dt> </dl> </td> <td width="60%"> Combined with SPQ_SCAN_FILE_PRESENCE,
///            removes present entries from the copy queue. When combined with SPQ_SCAN_FILE_VALIDITY, removes signed entries
///            from the copy queue. Available starting with Windows 2000. On Windows XP only, files that are also specified in
///            the delete queue or rename queues are not pruned unless SPQ_SCAN_PRUNE_DELREN is specified. </td> </tr> <tr> <td
///            width="40%"><a id="SPQ_SCAN_USE_CALLBACK_SIGNERINFO"></a><a id="spq_scan_use_callback_signerinfo"></a><dl>
///            <dt><b>SPQ_SCAN_USE_CALLBACK_SIGNERINFO</b></dt> </dl> </td> <td width="60%"> Available starting with Windows XP.
///            Issues SPFILENOTIFY_QUEUESCAN_SIGNERINFO notification and passes a pointer to a FILEPATHS_SIGNERINFO structure as
///            <i>Param1</i>. Checks each file for a valid signature and reports signature information through the callback
///            function. </td> </tr> <tr> <td width="40%"><a id="SPQ_SCAN_PRUNE_DELREN"></a><a
///            id="spq_scan_prune_delren"></a><dl> <dt><b>SPQ_SCAN_PRUNE_DELREN</b></dt> </dl> </td> <td width="60%"> Combined
///            with SPQ_SCAN_FILE_PRESENCE or SPQ_SCAN_FILE_VALIDITY, removes entries in the delete or rename queue that are
///            also in the copy queue. When combined with SPQ_SCAN_PRUNE_COPY_QUEUE, limits files that are removed from the copy
///            queue to files that are not in the delete or rename queues. Available starting with Windows XP. </td> </tr>
///            </table>
///    Window = Optional handle to the window to own dialog boxes that are presented. This parameter is not used if the
///             <i>Flags</i> parameter does not contain SPQ_SCAN_FILE_PRESENCE or if <i>Flags</i> does not contain
///             SPQ_SCAN_INFORM_USER.
///    CallbackRoutine = Optional pointer to a FileCallback callback function to be called on each node of the copy queue. The
///                      notification code passed to the callback function is SPFILENOTIFY_QUEUESCAN. This parameter is required if
///                      <i>Flags</i> includes SPQ_SCAN_USE_CALLBACK. <div class="alert"><b>Note</b> You must supply the callback routine
///                      specified by <i>CallbackRoutine</i>. The default queue callback routine does not support
///                      <b>SetupScanFileQueue</b>.</div> <div> </div>
///    CallbackContext = Optional pointer to a context that contains caller-defined data passed to the callback routine pointed to by
///                      <i>CallbackRoutine</i>.
///    Result = Pointer to a variable that receives the result of the scan operation.
///Returns:
///    The function returns a nonzero value if all nodes in the queue were processed. If the SPQ_SCAN_USE_CALLBACK flag
///    was set, the value in <i>Result</i> is 0. The callback routine specified by <i>CallbackRoutine</i> is sent the
///    notification SPFILENOTIFY_QUEUESCAN. <i>CallbackRoutine.Param1</i> specifies a pointer to an array that contains
///    the target path information. The pointer has been cast to an unsigned integer and must be recast to a TCHAR array
///    of MAX_PATH elements before a callback routine can access the information. <i>CallbackRoutine.Param2</i> is set
///    to SPQ_DELAYED_COPY if the current queue node is in use and cannot be copied until the system is restarted.
///    Otherwise, <i>CallbackRoutine.Param2</i> takes the value 0. If SPQ_SCAN_USE_CALLBACK was not set, <i>Result</i>
///    indicates whether the queue passed the presence or validity check as shown in the following table. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>0</b></dt> </dl> </td> <td
///    width="60%"> The queue failed the check or it passed the check, but SPQ_SCAN_INFORM_USER was specified and the
///    user wants new copies of the files. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>1</b></dt> </dl> </td> <td
///    width="60%"> The queue passed the check and, if SPQ_SCAN_INFORM_USER was specified, the user indicated that
///    copying is not required. The copy queue is empty and there are no elements on the delete or rename queues, so the
///    caller can skip queue commit. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>2</b></dt> </dl> </td> <td
///    width="60%"> The queue passed the check and, if SPQ_SCAN_INFORM_USER was specified, the user indicated that
///    copying is not required. The copy queue is empty, but there are elements on the delete or rename queues, so the
///    caller cannot skip queue commit. </td> </tr> </table> The function returns zero if an error occurred or the
///    callback function returned nonzero. If <i>Result</i> is nonzero, it is the value returned by the callback
///    function that stopped queue processing. If <i>Result</i> is zero, extended error information can be retrieved by
///    a call to GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupScanFileQueueW(void* FileQueue, uint Flags, HWND Window, PSP_FILE_CALLBACK_W CallbackRoutine, 
                         void* CallbackContext, uint* Result);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetFileQueueCount</b> function gets the count from a setup file queue.
///Params:
///    FileQueue = Handle to an open setup file queue.
///    SubQueueFileOp = Flag that specifies which subqueue count to be returned. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr>
///                     <td width="40%"><a id="FILEOP_COPY"></a><a id="fileop_copy"></a><dl> <dt><b>FILEOP_COPY</b></dt> </dl> </td> <td
///                     width="60%"> Return the number of entries in the copy subqueue. </td> </tr> <tr> <td width="40%"><a
///                     id="FILEOP_RENAME"></a><a id="fileop_rename"></a><dl> <dt><b>FILEOP_RENAME</b></dt> </dl> </td> <td width="60%">
///                     Return the number of entries in the rename subqueue. </td> </tr> <tr> <td width="40%"><a
///                     id="FILEOP_DELETE"></a><a id="fileop_delete"></a><dl> <dt><b>FILEOP_DELETE</b></dt> </dl> </td> <td width="60%">
///                     Return the number of entries in the delete subqueue. </td> </tr> <tr> <td width="40%"><a
///                     id="FILEOP_BACKUP"></a><a id="fileop_backup"></a><dl> <dt><b>FILEOP_BACKUP</b></dt> </dl> </td> <td width="60%">
///                     Return the number of entries in the backup subqueue. </td> </tr> </table>
///    NumOperations = Count from the setup file queue.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetFileQueueCount(void* FileQueue, uint SubQueueFileOp, uint* NumOperations);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupGetFileQueueFlags</b> function gets the flags from a setup file queue.
///Params:
///    FileQueue = Handle to an open setup file queue.
///    Flags = Pointer to location that contains the flag set with SetupSetFileQueueFlags and returned by
///            <b>SetupGetFileQueueFlags</b>. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="SPQ_FLAG_BACKUP_AWARE"></a><a id="spq_flag_backup_aware"></a><dl> <dt><b>SPQ_FLAG_BACKUP_AWARE</b></dt>
///            <dt>0x001</dt> </dl> </td> <td width="60%"> If this flag is set, SetupCommitFileQueue issues backup
///            notifications. </td> </tr> <tr> <td width="40%"><a id="SPQ_FLAG_ABORT_IF_UNSIGNED"></a><a
///            id="spq_flag_abort_if_unsigned"></a><dl> <dt><b>SPQ_FLAG_ABORT_IF_UNSIGNED</b></dt> <dt>0X002</dt> </dl> </td>
///            <td width="60%"> For internal use only. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupGetFileQueueFlags(void* FileQueue, uint* Flags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupSetFileQueueFlags</b> function sets the flags on a setup file queue.
///Params:
///    FileQueue = Handle to an open setup file queue.
///    FlagMask = Mask of valid flags. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="SPQ_FLAG_VALID"></a><a id="spq_flag_valid"></a><dl> <dt><b>SPQ_FLAG_VALID</b></dt> <dt>0x001</dt> </dl> </td>
///               <td width="60%"> Mask for use with SPQ_FLAG_BACKUP_AWARE. </td> </tr> </table>
///    Flags = Flags for use with <b>SetupSetFileQueueFlags</b> and returned by SetupGetFileQueueFlags. <table> <tr>
///            <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SPQ_FLAG_BACKUP_AWARE"></a><a
///            id="spq_flag_backup_aware"></a><dl> <dt><b>SPQ_FLAG_BACKUP_AWARE</b></dt> <dt>0x001</dt> </dl> </td> <td
///            width="60%"> If this flag is set, SetupCommitFileQueue issues backup notifications. </td> </tr> <tr> <td
///            width="40%"><a id="SPQ_FLAG_ABORT_IF_UNSIGNED"></a><a id="spq_flag_abort_if_unsigned"></a><dl>
///            <dt><b>SPQ_FLAG_ABORT_IF_UNSIGNED</b></dt> <dt>0X002</dt> </dl> </td> <td width="60%"> For internal use only.
///            </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is (0)
///    zero. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupSetFileQueueFlags(void* FileQueue, uint FlagMask, uint Flags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupCopyOEMInf</b> function copies a specified .inf file to the %windir%/Inf
///directory. A caller of this function is required have administrative privileges, otherwise the function fails.
///Params:
///    SourceInfFileName = Full path to the source .inf file. You should use a null-terminated string. This path should not exceed
///                        <b>MAX_PATH</b> in size, including the terminating <b>NULL</b>.
///    OEMSourceMediaLocation = Source location information to be stored in the precompiled .inf (.pnf). This location information is specific to
///                             the source media type specified. You should use a null-terminated string. This path should not exceed
///                             <b>MAX_PATH</b> in size, including the terminating <b>NULL</b>.
///    OEMSourceMediaType = Source media type referenced by the location information. This parameter may be one of the following values.
///                         <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SPOST_NONE"></a><a
///                         id="spost_none"></a><dl> <dt><b>SPOST_NONE</b></dt> </dl> </td> <td width="60%"> No source media information is
///                         stored in the .pnf file. The value of <i>OEMSourceMediaLocation</i> is ignored in this case. </td> </tr> <tr> <td
///                         width="40%"><a id="SPOST_PATH"></a><a id="spost_path"></a><dl> <dt><b>SPOST_PATH</b></dt> </dl> </td> <td
///                         width="60%"> <i>OEMSourceMediaLocation</i> contains a path to the source media. For example, if the media is on a
///                         floppy, this path might be "A:\". If <i>OEMSourceMediaLocation</i> is <b>NULL</b>, the path is assumed to be the
///                         path where the .inf is located. If the .inf has a corresponding .pnf in that location, the .pnf file's source
///                         media information is transferred to the destination .pnf file. </td> </tr> <tr> <td width="40%"><a
///                         id="SPOST_URL"></a><a id="spost_url"></a><dl> <dt><b>SPOST_URL</b></dt> </dl> </td> <td width="60%">
///                         <i>OEMSourceMediaLocation</i> contains a universal resource locator (URL) that specifies the Internet location
///                         from where the .inf/driver files were retrieved. If <i>OEMSourceMediaLocation</i> is <b>NULL</b>, it is assumed
///                         that the default Code Download Manager location was used. </td> </tr> </table>
///    CopyStyle = Specifies how the .inf file is copied into the .inf directory. The following flags can be combined. <table> <tr>
///                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SP_COPY_DELETESOURCE"></a><a
///                id="sp_copy_deletesource"></a><dl> <dt><b>SP_COPY_DELETESOURCE</b></dt> </dl> </td> <td width="60%"> Delete
///                source file on successful copy. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_REPLACEONLY"></a><a
///                id="sp_copy_replaceonly"></a><dl> <dt><b>SP_COPY_REPLACEONLY</b></dt> </dl> </td> <td width="60%"> Copy only if
///                this file already exists in the Inf directory. This flag could be used to update the source location information
///                for an existing .inf. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NOOVERWRITE"></a><a
///                id="sp_copy_nooverwrite"></a><dl> <dt><b>SP_COPY_NOOVERWRITE</b></dt> </dl> </td> <td width="60%"> Copy only if
///                the specified files do not currently exist in the Inf directory. If the .inf does currently exist, this API fails
///                and GetLastError returns ERROR_FILE_EXISTS. In this case, the existing .inf file's filename is placed into the
///                appropriate field in the destination .inf file's information output buffers. </td> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_OEMINF_CATALOG_ONLY"></a><a id="sp_copy_oeminf_catalog_only"></a><dl>
///                <dt><b>SP_COPY_OEMINF_CATALOG_ONLY</b></dt> </dl> </td> <td width="60%"> The specified .inf file's corresponding
///                catalog files is copied to %windir%\Inf. If this flag is specified, the destination filename information is
///                entered upon successful return if the specified .inf file already exists in the Inf directory. </td> </tr>
///                </table>
///    DestinationInfFileName = Pointer to a buffer to receive the .inf file name assigned to it at the time it was copied to the Inf directory.
///                             The buffer, if specified, should typically be <b>MAX_PATH</b> in length. If the SP_COPY_NOOVERWRITE flag is
///                             specified and the <b>SetupCopyOEMInf</b> function fails with a return code of ERROR_FILE_EXISTS, this buffer
///                             contains the name of the existing .inf file. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, this buffer
///                             contains the destination .inf filename if the .inf file is already present in the Inf directory. Otherwise, this
///                             buffer is set to the empty string. This parameter can be <b>NULL</b>.
///    DestinationInfFileNameSize = Size of the <i>DestinationInfFileName</i> buffer, in characters, or zero if the buffer is not specified. If
///                                 <i>DestinationInfFileName</i> is specified and this buffer size is less than the size required to return the
///                                 destination .inf filename (including full path), this function fails. In this case GetLastError returns
///                                 ERROR_INSUFFICIENT_BUFFER.
///    RequiredSize = Pointer to a variable that receives the size (in characters) required to store the destination .inf file name
///                   including a terminating <b>NULL</b>. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, this variable receives
///                   a string length only if the .inf file already exists in the Inf directory. Otherwise, this variable is set to
///                   zero. This parameter can be <b>NULL</b>.
///    DestinationInfFileNameComponent = Pointer to a string that is set upon successful return (or ERROR_FILE_EXISTS) to point to the beginning of the
///                                      filename component of the path stored in the <i>DestinationInfFileName</i> parameter. If the
///                                      SP_COPY_OEMINF_CATALOG_ONLY flag is specified, the <i>DestinationInfFileName</i> parameter may be an empty
///                                      string. In this case, the character pointer is set to <b>NULL</b> upon successful return. This parameter can be
///                                      <b>NULL</b>.
///Returns:
///    This function returns WINSETUPAPI BOOL.
///    
@DllImport("SETUPAPI")
BOOL SetupCopyOEMInfA(const(char)* SourceInfFileName, const(char)* OEMSourceMediaLocation, uint OEMSourceMediaType, 
                      uint CopyStyle, const(char)* DestinationInfFileName, uint DestinationInfFileNameSize, 
                      uint* RequiredSize, byte** DestinationInfFileNameComponent);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupCopyOEMInf</b> function copies a specified .inf file to the %windir%/Inf
///directory. A caller of this function is required have administrative privileges, otherwise the function fails.
///Params:
///    SourceInfFileName = Full path to the source .inf file. You should use a null-terminated string. This path should not exceed
///                        <b>MAX_PATH</b> in size, including the terminating <b>NULL</b>.
///    OEMSourceMediaLocation = Source location information to be stored in the precompiled .inf (.pnf). This location information is specific to
///                             the source media type specified. You should use a null-terminated string. This path should not exceed
///                             <b>MAX_PATH</b> in size, including the terminating <b>NULL</b>.
///    OEMSourceMediaType = Source media type referenced by the location information. This parameter may be one of the following values.
///                         <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SPOST_NONE"></a><a
///                         id="spost_none"></a><dl> <dt><b>SPOST_NONE</b></dt> </dl> </td> <td width="60%"> No source media information is
///                         stored in the .pnf file. The value of <i>OEMSourceMediaLocation</i> is ignored in this case. </td> </tr> <tr> <td
///                         width="40%"><a id="SPOST_PATH"></a><a id="spost_path"></a><dl> <dt><b>SPOST_PATH</b></dt> </dl> </td> <td
///                         width="60%"> <i>OEMSourceMediaLocation</i> contains a path to the source media. For example, if the media is on a
///                         floppy, this path might be "A:\". If <i>OEMSourceMediaLocation</i> is <b>NULL</b>, the path is assumed to be the
///                         path where the .inf is located. If the .inf has a corresponding .pnf in that location, the .pnf file's source
///                         media information is transferred to the destination .pnf file. </td> </tr> <tr> <td width="40%"><a
///                         id="SPOST_URL"></a><a id="spost_url"></a><dl> <dt><b>SPOST_URL</b></dt> </dl> </td> <td width="60%">
///                         <i>OEMSourceMediaLocation</i> contains a universal resource locator (URL) that specifies the Internet location
///                         from where the .inf/driver files were retrieved. If <i>OEMSourceMediaLocation</i> is <b>NULL</b>, it is assumed
///                         that the default Code Download Manager location was used. </td> </tr> </table>
///    CopyStyle = Specifies how the .inf file is copied into the .inf directory. The following flags can be combined. <table> <tr>
///                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SP_COPY_DELETESOURCE"></a><a
///                id="sp_copy_deletesource"></a><dl> <dt><b>SP_COPY_DELETESOURCE</b></dt> </dl> </td> <td width="60%"> Delete
///                source file on successful copy. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_REPLACEONLY"></a><a
///                id="sp_copy_replaceonly"></a><dl> <dt><b>SP_COPY_REPLACEONLY</b></dt> </dl> </td> <td width="60%"> Copy only if
///                this file already exists in the Inf directory. This flag could be used to update the source location information
///                for an existing .inf. </td> </tr> <tr> <td width="40%"><a id="SP_COPY_NOOVERWRITE"></a><a
///                id="sp_copy_nooverwrite"></a><dl> <dt><b>SP_COPY_NOOVERWRITE</b></dt> </dl> </td> <td width="60%"> Copy only if
///                the specified files do not currently exist in the Inf directory. If the .inf does currently exist, this API fails
///                and GetLastError returns ERROR_FILE_EXISTS. In this case, the existing .inf file's filename is placed into the
///                appropriate field in the destination .inf file's information output buffers. </td> </tr> <tr> <td width="40%"><a
///                id="SP_COPY_OEMINF_CATALOG_ONLY"></a><a id="sp_copy_oeminf_catalog_only"></a><dl>
///                <dt><b>SP_COPY_OEMINF_CATALOG_ONLY</b></dt> </dl> </td> <td width="60%"> The specified .inf file's corresponding
///                catalog files is copied to %windir%\Inf. If this flag is specified, the destination filename information is
///                entered upon successful return if the specified .inf file already exists in the Inf directory. </td> </tr>
///                </table>
///    DestinationInfFileName = Pointer to a buffer to receive the .inf file name assigned to it at the time it was copied to the Inf directory.
///                             The buffer, if specified, should typically be <b>MAX_PATH</b> in length. If the SP_COPY_NOOVERWRITE flag is
///                             specified and the <b>SetupCopyOEMInf</b> function fails with a return code of ERROR_FILE_EXISTS, this buffer
///                             contains the name of the existing .inf file. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, this buffer
///                             contains the destination .inf filename if the .inf file is already present in the Inf directory. Otherwise, this
///                             buffer is set to the empty string. This parameter can be <b>NULL</b>.
///    DestinationInfFileNameSize = Size of the <i>DestinationInfFileName</i> buffer, in characters, or zero if the buffer is not specified. If
///                                 <i>DestinationInfFileName</i> is specified and this buffer size is less than the size required to return the
///                                 destination .inf filename (including full path), this function fails. In this case GetLastError returns
///                                 ERROR_INSUFFICIENT_BUFFER.
///    RequiredSize = Pointer to a variable that receives the size (in characters) required to store the destination .inf file name
///                   including a terminating <b>NULL</b>. If the SP_COPY_OEMINF_CATALOG_ONLY flag is specified, this variable receives
///                   a string length only if the .inf file already exists in the Inf directory. Otherwise, this variable is set to
///                   zero. This parameter can be <b>NULL</b>.
///    DestinationInfFileNameComponent = Pointer to a string that is set upon successful return (or ERROR_FILE_EXISTS) to point to the beginning of the
///                                      filename component of the path stored in the <i>DestinationInfFileName</i> parameter. If the
///                                      SP_COPY_OEMINF_CATALOG_ONLY flag is specified, the <i>DestinationInfFileName</i> parameter may be an empty
///                                      string. In this case, the character pointer is set to <b>NULL</b> upon successful return. This parameter can be
///                                      <b>NULL</b>.
///Returns:
///    This function returns WINSETUPAPI BOOL.
///    
@DllImport("SETUPAPI")
BOOL SetupCopyOEMInfW(const(wchar)* SourceInfFileName, const(wchar)* OEMSourceMediaLocation, 
                      uint OEMSourceMediaType, uint CopyStyle, const(wchar)* DestinationInfFileName, 
                      uint DestinationInfFileNameSize, uint* RequiredSize, ushort** DestinationInfFileNameComponent);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupUninstallOEMInf</b> function uninstalls a specified .inf file and any
///associated .pnf file. If the .inf file was installed with a catalog for signing drivers, the catalog is also removed.
///A caller of this function must have administrative privileges, otherwise the function fails.
///Params:
///    InfFileName = File name, without path, of the .inf file in the Windows Inf directory that is to be uninstalled.
///    Flags = This parameter can be set as follows. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="SUOI_FORCEDELETE"></a><a id="suoi_forcedelete"></a><dl> <dt><b>SUOI_FORCEDELETE</b></dt> <dt>0x0001</dt>
///            </dl> </td> <td width="60%"> The <b>SetupUninstallOEMInf</b> function first checks whether there are any devices
///            installed using the .inf file. A device does not need to be present to be detected as using the .inf file. If
///            this flag is not set and the function finds a currently installed device that was installed using this .inf file,
///            the .inf file is not removed. If this flag is set, the .inf file is removed whether the function finds a device
///            that was installed with this .inf file. <div class="alert"><b>Note</b> This flag only applies to x86, amd64, and
///            ia64 architectures. It is ignored on all other architectures.</div> <div> </div> <div class="alert"><b>Note</b>
///            If the driver package has any files that are copied to a DestinationDir that uses a dirid of 13, then this force
///            flag is ignored.</div> <div> </div> </td> </tr> </table>
///    Reserved = Set to <b>null</b>.
///Returns:
///    This function returns WINSETUPAPI BOOL.
///    
@DllImport("SETUPAPI")
BOOL SetupUninstallOEMInfA(const(char)* InfFileName, uint Flags, void* Reserved);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupUninstallOEMInf</b> function uninstalls a specified .inf file and any
///associated .pnf file. If the .inf file was installed with a catalog for signing drivers, the catalog is also removed.
///A caller of this function must have administrative privileges, otherwise the function fails.
///Params:
///    InfFileName = File name, without path, of the .inf file in the Windows Inf directory that is to be uninstalled.
///    Flags = This parameter can be set as follows. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="SUOI_FORCEDELETE"></a><a id="suoi_forcedelete"></a><dl> <dt><b>SUOI_FORCEDELETE</b></dt> <dt>0x0001</dt>
///            </dl> </td> <td width="60%"> The <b>SetupUninstallOEMInf</b> function first checks whether there are any devices
///            installed using the .inf file. A device does not need to be present to be detected as using the .inf file. If
///            this flag is not set and the function finds a currently installed device that was installed using this .inf file,
///            the .inf file is not removed. If this flag is set, the .inf file is removed whether the function finds a device
///            that was installed with this .inf file. <div class="alert"><b>Note</b> This flag only applies to x86, amd64, and
///            ia64 architectures. It is ignored on all other architectures.</div> <div> </div> <div class="alert"><b>Note</b>
///            If the driver package has any files that are copied to a DestinationDir that uses a dirid of 13, then this force
///            flag is ignored.</div> <div> </div> </td> </tr> </table>
///    Reserved = Set to <b>null</b>.
///Returns:
///    This function returns WINSETUPAPI BOOL.
///    
@DllImport("SETUPAPI")
BOOL SetupUninstallOEMInfW(const(wchar)* InfFileName, uint Flags, void* Reserved);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupUninstallNewlyCopiedInfs</b> function uninstalls INF files (.inf),
///precompiled INF files (.pnf), and catalog files (.cat) that are previously installed during the committal of the
///specified file queue. A caller of this function must have administrative privileges; otherwise, the function fails.
///Params:
///    FileQueue = Handle to an open and committed file queue. This queue contains the newly installed INF, PNF, or CAT files that
///                <b>SetupUninstallNewlyCopiedInfs</b> uninstalls.
///    Flags = Flags to use with <b>SetupUninstallNewlyCopiedInfs</b>. No flags are defined currently. This parameter must be 0
///            (zero).
///    Reserved = Reserved. This parameter must be <b>NULL</b>.
///Returns:
///    If the parameters passed in are valid, the return value is <b>TRUE</b> (nonzero), which does not necessarily mean
///    that any INFs are uninstalled. If some of the parameters passed in are invalid, the return value is <b>FALSE</b>
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupUninstallNewlyCopiedInfs(void* FileQueue, uint Flags, void* Reserved);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupCreateDiskSpaceList</b> function creates a disk-space list.
///Params:
///    Reserved1 = Unused, must be zero.
///    Reserved2 = Unused, must be zero.
///    Flags = This parameter can be the following value.
///Returns:
///    If the function succeeds, it returns a handle to the disk-space list. If the function fails, it returns null. To
///    get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
void* SetupCreateDiskSpaceListA(void* Reserved1, uint Reserved2, uint Flags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupCreateDiskSpaceList</b> function creates a disk-space list.
///Params:
///    Reserved1 = Unused, must be zero.
///    Reserved2 = Unused, must be zero.
///    Flags = This parameter can be the following value.
///Returns:
///    If the function succeeds, it returns a handle to the disk-space list. If the function fails, it returns null. To
///    get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
void* SetupCreateDiskSpaceListW(void* Reserved1, uint Reserved2, uint Flags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The SetupDuplicateDiskSpaceList function duplicates a disk-space list as a new
///independent disk-space list.
///Params:
///    DiskSpace = Handle to the disk-space list to be duplicated.
///    Reserved1 = Unused, must be zero.
///    Reserved2 = Unused, must be zero.
///    Flags = Unused, must be zero.
///Returns:
///    If the function succeeds, it returns a handle to the new disk-space list. If the function fails, it returns null.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
void* SetupDuplicateDiskSpaceListA(void* DiskSpace, void* Reserved1, uint Reserved2, uint Flags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The SetupDuplicateDiskSpaceList function duplicates a disk-space list as a new
///independent disk-space list.
///Params:
///    DiskSpace = Handle to the disk-space list to be duplicated.
///    Reserved1 = Unused, must be zero.
///    Reserved2 = Unused, must be zero.
///    Flags = Unused, must be zero.
///Returns:
///    If the function succeeds, it returns a handle to the new disk-space list. If the function fails, it returns null.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
void* SetupDuplicateDiskSpaceListW(void* DiskSpace, void* Reserved1, uint Reserved2, uint Flags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupDestroyDiskSpaceList</b> function destroys a disk-space list and releases
///the resources allocated to it.
///Params:
///    DiskSpace = Handle to the disk-space list to be deconstructed.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupDestroyDiskSpaceList(void* DiskSpace);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueryDrivesInDiskSpaceList</b> function fills a buffer with a list of the
///drives referenced by the file operations listed in the disk-space list.
///Params:
///    DiskSpace = Handle to the disk-space list.
///    ReturnBuffer = Optional pointer to a buffer that receives the drive specifications, such as "X:" or "\\server\share". You should
///                   use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the
///                   destination buffer. This parameter can be <b>NULL</b>. If this parameter is not specified and no error occurs,
///                   the function returns a nonzero value and <i>RequiredSize</i> receives the buffer size required to hold the drive
///                   specifications.
///    ReturnBufferSize = Size of the buffer pointed by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator. This
///                       parameter is ignored if <i>ReturnBuffer</i> is not specified.
///    RequiredSize = Optional pointer to a variable that receives the size of the buffer required to hold the <b>null</b>-terminated
///                   list of drives, in characters. This includes the <b>null</b> terminator.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError. If the GetLastError function returns
///    ERROR_INSUFFICIENT_BUFFER, <i>ReturnBuffer</i> was specified, but <i>ReturnBufferSize</i> indicated that the
///    supplied buffer was too small.
///    
@DllImport("SETUPAPI")
BOOL SetupQueryDrivesInDiskSpaceListA(void* DiskSpace, const(char)* ReturnBuffer, uint ReturnBufferSize, 
                                      uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueryDrivesInDiskSpaceList</b> function fills a buffer with a list of the
///drives referenced by the file operations listed in the disk-space list.
///Params:
///    DiskSpace = Handle to the disk-space list.
///    ReturnBuffer = Optional pointer to a buffer that receives the drive specifications, such as "X:" or "\\server\share". You should
///                   use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the
///                   destination buffer. This parameter can be <b>NULL</b>. If this parameter is not specified and no error occurs,
///                   the function returns a nonzero value and <i>RequiredSize</i> receives the buffer size required to hold the drive
///                   specifications.
///    ReturnBufferSize = Size of the buffer pointed by <i>ReturnBuffer</i>, in characters. This includes the <b>null</b> terminator. This
///                       parameter is ignored if <i>ReturnBuffer</i> is not specified.
///    RequiredSize = Optional pointer to a variable that receives the size of the buffer required to hold the <b>null</b>-terminated
///                   list of drives, in characters. This includes the <b>null</b> terminator.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError. If the GetLastError function returns
///    ERROR_INSUFFICIENT_BUFFER, <i>ReturnBuffer</i> was specified, but <i>ReturnBufferSize</i> indicated that the
///    supplied buffer was too small.
///    
@DllImport("SETUPAPI")
BOOL SetupQueryDrivesInDiskSpaceListW(void* DiskSpace, const(wchar)* ReturnBuffer, uint ReturnBufferSize, 
                                      uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQuerySpaceRequiredOnDrive</b> function examines a disk space list to
///determine the space that is required to perform all the file operations listed for a specific drive.
///Params:
///    DiskSpace = The handle to a disk space list.
///    DriveSpec = A pointer to a null-terminated string that specifies the drive where space information is to be returned. This
///                should be in the form "x:" or "\\server\share".
///    SpaceRequired = If the function succeeds, this parameter receives the amount of additional space that is required to process all
///                    the file operations listed in the disk space list for the drive that <i>DriveSpec</i> specifies. The
///                    <b>SetupQuerySpaceRequiredOnDrive</b> function calculates the additional space required on the target drive by
///                    checking for preexisting versions of the files on the target drive. For example, if a file operation copies a
///                    2000-byte file, FIRST.EXE, to the directory, C:\MYPROG\, the <b>SetupQuerySpaceRequiredOnDrive</b> function
///                    automatically checks for a preexisting version of that file in that directory. If a preexisting version of
///                    C:\MYPROG\FIRST.EXE has a file size of 500 bytes, the additional space required on the drive C for that operation
///                    is 1500 bytes. The value received can be 0 (zero) or a negative number, if additional space is not required, or
///                    if space is freed on the target drive. If FIRST.EXE in the preceding example is being deleted from the drive C,
///                    the amount of space required is 2000 bytes, or the space freed on drive C. If the preexisting version has a file
///                    size of 5000 bytes, then the disk space required to replace it with the 2000-byte FIRST.EXE is 3000 bytes. File
///                    sizes are rounded to disk cluster boundaries.
///    Reserved1 = Reserved; must be 0 (zero).
///    Reserved2 = Reserved; must be 0 (zero).
///Returns:
///    If the function succeeds, the return value is a nonzero value and <i>SpaceRequired</i> receives the amount of
///    space required by the file operations listed in the current disk space list. If the function fails, the return
///    value is 0 (zero). To get extended error information, call GetLastError. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_DRIVE</b></dt> </dl> </td> <td
///    width="60%"> The specified drive is not on the disk-space list. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> The specified <i>DiskSpace</i> handle is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> The specified <i>DriveSpec</i> string is invalid. </td> </tr> </table>
///    
@DllImport("SETUPAPI")
BOOL SetupQuerySpaceRequiredOnDriveA(void* DiskSpace, const(char)* DriveSpec, long* SpaceRequired, void* Reserved1, 
                                     uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQuerySpaceRequiredOnDrive</b> function examines a disk space list to
///determine the space that is required to perform all the file operations listed for a specific drive.
///Params:
///    DiskSpace = The handle to a disk space list.
///    DriveSpec = A pointer to a null-terminated string that specifies the drive where space information is to be returned. This
///                should be in the form "x:" or "\\server\share".
///    SpaceRequired = If the function succeeds, this parameter receives the amount of additional space that is required to process all
///                    the file operations listed in the disk space list for the drive that <i>DriveSpec</i> specifies. The
///                    <b>SetupQuerySpaceRequiredOnDrive</b> function calculates the additional space required on the target drive by
///                    checking for preexisting versions of the files on the target drive. For example, if a file operation copies a
///                    2000-byte file, FIRST.EXE, to the directory, C:\MYPROG\, the <b>SetupQuerySpaceRequiredOnDrive</b> function
///                    automatically checks for a preexisting version of that file in that directory. If a preexisting version of
///                    C:\MYPROG\FIRST.EXE has a file size of 500 bytes, the additional space required on the drive C for that operation
///                    is 1500 bytes. The value received can be 0 (zero) or a negative number, if additional space is not required, or
///                    if space is freed on the target drive. If FIRST.EXE in the preceding example is being deleted from the drive C,
///                    the amount of space required is 2000 bytes, or the space freed on drive C. If the preexisting version has a file
///                    size of 5000 bytes, then the disk space required to replace it with the 2000-byte FIRST.EXE is 3000 bytes. File
///                    sizes are rounded to disk cluster boundaries.
///    Reserved1 = Reserved; must be 0 (zero).
///    Reserved2 = Reserved; must be 0 (zero).
///Returns:
///    If the function succeeds, the return value is a nonzero value and <i>SpaceRequired</i> receives the amount of
///    space required by the file operations listed in the current disk space list. If the function fails, the return
///    value is 0 (zero). To get extended error information, call GetLastError. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_DRIVE</b></dt> </dl> </td> <td
///    width="60%"> The specified drive is not on the disk-space list. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> The specified <i>DiskSpace</i> handle is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> The specified <i>DriveSpec</i> string is invalid. </td> </tr> </table>
///    
@DllImport("SETUPAPI")
BOOL SetupQuerySpaceRequiredOnDriveW(void* DiskSpace, const(wchar)* DriveSpec, long* SpaceRequired, 
                                     void* Reserved1, uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupAdjustDiskSpaceList</b> function adjusts the amount of required space for
///a specified drive.
///Params:
///    DiskSpace = Handle to a disk-space list.
///    DriveRoot = Specifies a valid Win32 drive root. An entry is added to the disk-space list if the specified drive is not
///                currently in the disk-space list.
///    Amount = Specifies the amount of space to add or remove. Use a negative number to remove space and use a positive number
///             to add space.
///    Reserved1 = Unused, must be zero.
///    Reserved2 = Unused, must be zero.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupAdjustDiskSpaceListA(void* DiskSpace, const(char)* DriveRoot, long Amount, void* Reserved1, 
                               uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupAdjustDiskSpaceList</b> function adjusts the amount of required space for
///a specified drive.
///Params:
///    DiskSpace = Handle to a disk-space list.
///    DriveRoot = Specifies a valid Win32 drive root. An entry is added to the disk-space list if the specified drive is not
///                currently in the disk-space list.
///    Amount = Specifies the amount of space to add or remove. Use a negative number to remove space and use a positive number
///             to add space.
///    Reserved1 = Unused, must be zero.
///    Reserved2 = Unused, must be zero.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupAdjustDiskSpaceListW(void* DiskSpace, const(wchar)* DriveRoot, long Amount, void* Reserved1, 
                               uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupAddToDiskSpaceList</b> function adds a single delete or copy operation to
///a disk-space list. To add all the file operations in a section of an INF file, use either
///SetupAddSectionToDiskSpaceList, or SetupAddInstallSectionToDiskSpaceList. Target disk compression is ignored by this
///function. Files are assumed to occupy their full size on the target disk.
///Params:
///    DiskSpace = Handle to the disk-space list.
///    TargetFilespec = File name of the file to be added to the disk-space list. You should use a null-terminated string that specifies
///                     a fully qualified path. Otherwise, the path must be relative to the current directory.
///    FileSize = Uncompressed size of the file as it will exist in the target directory, in bytes. You can use
///               SetupGetSourceFileSize to retrieve this information from an INF file. This parameter is ignored for FILEOP_DELETE
///               operations.
///    Operation = File operation to be added to the list. This parameter can be one of the following values. <table> <tr>
///                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILEOP_DELETE"></a><a
///                id="fileop_delete"></a><dl> <dt><b>FILEOP_DELETE</b></dt> </dl> </td> <td width="60%"> A file delete operation.
///                </td> </tr> <tr> <td width="40%"><a id="FILEOP_COPY."></a><a id="fileop_copy."></a><dl>
///                <dt><b>FILEOP_COPY.</b></dt> </dl> </td> <td width="60%"> A file copy operation. </td> </tr> </table>
///    Reserved1 = Must be zero.
///    Reserved2 = Must be zero.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupAddToDiskSpaceListA(void* DiskSpace, const(char)* TargetFilespec, long FileSize, uint Operation, 
                              void* Reserved1, uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupAddToDiskSpaceList</b> function adds a single delete or copy operation to
///a disk-space list. To add all the file operations in a section of an INF file, use either
///SetupAddSectionToDiskSpaceList, or SetupAddInstallSectionToDiskSpaceList. Target disk compression is ignored by this
///function. Files are assumed to occupy their full size on the target disk.
///Params:
///    DiskSpace = Handle to the disk-space list.
///    TargetFilespec = File name of the file to be added to the disk-space list. You should use a null-terminated string that specifies
///                     a fully qualified path. Otherwise, the path must be relative to the current directory.
///    FileSize = Uncompressed size of the file as it will exist in the target directory, in bytes. You can use
///               SetupGetSourceFileSize to retrieve this information from an INF file. This parameter is ignored for FILEOP_DELETE
///               operations.
///    Operation = File operation to be added to the list. This parameter can be one of the following values. <table> <tr>
///                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILEOP_DELETE"></a><a
///                id="fileop_delete"></a><dl> <dt><b>FILEOP_DELETE</b></dt> </dl> </td> <td width="60%"> A file delete operation.
///                </td> </tr> <tr> <td width="40%"><a id="FILEOP_COPY."></a><a id="fileop_copy."></a><dl>
///                <dt><b>FILEOP_COPY.</b></dt> </dl> </td> <td width="60%"> A file copy operation. </td> </tr> </table>
///    Reserved1 = Must be zero.
///    Reserved2 = Must be zero.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupAddToDiskSpaceListW(void* DiskSpace, const(wchar)* TargetFilespec, long FileSize, uint Operation, 
                              void* Reserved1, uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupAddSectionToDiskSpaceList</b> function adds to a disk-space list all the
///file delete or copy operations listed in a <b>Copy Files</b> or <b>Delete Files</b> section of an INF file. Target
///disk compression is ignored by this function. Files are assumed to occupy their full size on the target disk.
///Params:
///    DiskSpace = Handle to the disk-space list.
///    InfHandle = Handle to an open INF file that contains the <b>SourceDisksFiles</b> section. If <i>ListInfHandle</i> is not
///                specified, this INF file must also contain the section named by <i>SectionName</i>.
///    ListInfHandle = Optional handle to an open INF file that contains the section specified by <i>SectionName</i>. Otherwise,
///                    <i>InfHandle</i> is assumed to contain this section.
///    SectionName = Name of the <b>Copy Files</b> or <b>Delete Files</b> section that contains the file operations to add to the
///                  disk-space list. Use a null-terminated string.
///    Operation = Type of file operation to be added to the list. This parameter can be one of the following values. <table> <tr>
///                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILEOP_DELETE"></a><a
///                id="fileop_delete"></a><dl> <dt><b>FILEOP_DELETE</b></dt> </dl> </td> <td width="60%"> A file delete operation.
///                </td> </tr> <tr> <td width="40%"><a id="FILEOP_COPY"></a><a id="fileop_copy"></a><dl> <dt><b>FILEOP_COPY</b></dt>
///                </dl> </td> <td width="60%"> A file copy operation. </td> </tr> </table>
///    Reserved1 = Must be zero.
///    Reserved2 = Must be zero.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupAddSectionToDiskSpaceListA(void* DiskSpace, void* InfHandle, void* ListInfHandle, 
                                     const(char)* SectionName, uint Operation, void* Reserved1, uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupAddSectionToDiskSpaceList</b> function adds to a disk-space list all the
///file delete or copy operations listed in a <b>Copy Files</b> or <b>Delete Files</b> section of an INF file. Target
///disk compression is ignored by this function. Files are assumed to occupy their full size on the target disk.
///Params:
///    DiskSpace = Handle to the disk-space list.
///    InfHandle = Handle to an open INF file that contains the <b>SourceDisksFiles</b> section. If <i>ListInfHandle</i> is not
///                specified, this INF file must also contain the section named by <i>SectionName</i>.
///    ListInfHandle = Optional handle to an open INF file that contains the section specified by <i>SectionName</i>. Otherwise,
///                    <i>InfHandle</i> is assumed to contain this section.
///    SectionName = Name of the <b>Copy Files</b> or <b>Delete Files</b> section that contains the file operations to add to the
///                  disk-space list. Use a null-terminated string.
///    Operation = Type of file operation to be added to the list. This parameter can be one of the following values. <table> <tr>
///                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILEOP_DELETE"></a><a
///                id="fileop_delete"></a><dl> <dt><b>FILEOP_DELETE</b></dt> </dl> </td> <td width="60%"> A file delete operation.
///                </td> </tr> <tr> <td width="40%"><a id="FILEOP_COPY"></a><a id="fileop_copy"></a><dl> <dt><b>FILEOP_COPY</b></dt>
///                </dl> </td> <td width="60%"> A file copy operation. </td> </tr> </table>
///    Reserved1 = Must be zero.
///    Reserved2 = Must be zero.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupAddSectionToDiskSpaceListW(void* DiskSpace, void* InfHandle, void* ListInfHandle, 
                                     const(wchar)* SectionName, uint Operation, void* Reserved1, uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupAddInstallSectionToDiskSpaceList</b> function searches for
///<b>CopyFile</b> and <b>DelFile</b> lines in an <b>Install</b> section of an INF file. The function then adds the file
///operations specified in those sections to a disk-space list.
///Params:
///    DiskSpace = Handle to a disk-space list.
///    InfHandle = Handle to an open INF file that contains the <b>Install</b> section to be searched. If <i>ListInfHandle</i> is
///                not specified, the INF file must also contain the section specified by <i>SectionName</i>.
///    LayoutInfHandle = This parameter, if specified, provides the handle to the INF file that contains the <b>SourceDisksFiles</b>
///                      sections. Otherwise that section is assumed to exist in the INF file specified by <i>InfHandle</i>.
///    SectionName = Name of the Install section to be added to the disk-space list. You should use a null-terminated string.
///    Reserved1 = Must be zero.
///    Reserved2 = Must be zero.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupAddInstallSectionToDiskSpaceListA(void* DiskSpace, void* InfHandle, void* LayoutInfHandle, 
                                            const(char)* SectionName, void* Reserved1, uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupAddInstallSectionToDiskSpaceList</b> function searches for
///<b>CopyFile</b> and <b>DelFile</b> lines in an <b>Install</b> section of an INF file. The function then adds the file
///operations specified in those sections to a disk-space list.
///Params:
///    DiskSpace = Handle to a disk-space list.
///    InfHandle = Handle to an open INF file that contains the <b>Install</b> section to be searched. If <i>ListInfHandle</i> is
///                not specified, the INF file must also contain the section specified by <i>SectionName</i>.
///    LayoutInfHandle = This parameter, if specified, provides the handle to the INF file that contains the <b>SourceDisksFiles</b>
///                      sections. Otherwise that section is assumed to exist in the INF file specified by <i>InfHandle</i>.
///    SectionName = Name of the Install section to be added to the disk-space list. You should use a null-terminated string.
///    Reserved1 = Must be zero.
///    Reserved2 = Must be zero.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupAddInstallSectionToDiskSpaceListW(void* DiskSpace, void* InfHandle, void* LayoutInfHandle, 
                                            const(wchar)* SectionName, void* Reserved1, uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupRemoveFromDiskSpaceList</b> function removes a file delete or copy
///operation from a disk-space list.
///Params:
///    DiskSpace = Handle to a disk-space list.
///    TargetFilespec = Pointer to a null-terminated string that specifies the file name of the file to remove from the disk-space list.
///                     This is typically a fully qualified path. Otherwise, the path must be relative to the current directory.
///    Operation = File operation to be removed from the list. This parameter can be one of the following values. <table> <tr>
///                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILEOP_DELETE"></a><a
///                id="fileop_delete"></a><dl> <dt><b>FILEOP_DELETE</b></dt> </dl> </td> <td width="60%"> A file delete operation.
///                </td> </tr> <tr> <td width="40%"><a id="FILEOP_COPY"></a><a id="fileop_copy"></a><dl> <dt><b>FILEOP_COPY</b></dt>
///                </dl> </td> <td width="60%"> A file copy operation. </td> </tr> </table>
///    Reserved1 = Must be zero.
///    Reserved2 = Must be zero.
///Returns:
///    If the file was not in the list, the <b>SetupRemoveFromDiskSpaceList</b> function returns a nonzero value and
///    GetLastError returns ERROR_INVALID_DRIVE or ERROR_INVALID_NAME. If the file was in the list then upon success the
///    routine returns a nonzero value and <b>GetLastError</b> returns NO_ERROR. If the routine fails for some other
///    reason, it returns zero and GetLastError returns extended error information.
///    
@DllImport("SETUPAPI")
BOOL SetupRemoveFromDiskSpaceListA(void* DiskSpace, const(char)* TargetFilespec, uint Operation, void* Reserved1, 
                                   uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupRemoveFromDiskSpaceList</b> function removes a file delete or copy
///operation from a disk-space list.
///Params:
///    DiskSpace = Handle to a disk-space list.
///    TargetFilespec = Pointer to a null-terminated string that specifies the file name of the file to remove from the disk-space list.
///                     This is typically a fully qualified path. Otherwise, the path must be relative to the current directory.
///    Operation = File operation to be removed from the list. This parameter can be one of the following values. <table> <tr>
///                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILEOP_DELETE"></a><a
///                id="fileop_delete"></a><dl> <dt><b>FILEOP_DELETE</b></dt> </dl> </td> <td width="60%"> A file delete operation.
///                </td> </tr> <tr> <td width="40%"><a id="FILEOP_COPY"></a><a id="fileop_copy"></a><dl> <dt><b>FILEOP_COPY</b></dt>
///                </dl> </td> <td width="60%"> A file copy operation. </td> </tr> </table>
///    Reserved1 = Must be zero.
///    Reserved2 = Must be zero.
///Returns:
///    If the file was not in the list, the <b>SetupRemoveFromDiskSpaceList</b> function returns a nonzero value and
///    GetLastError returns ERROR_INVALID_DRIVE or ERROR_INVALID_NAME. If the file was in the list then upon success the
///    routine returns a nonzero value and <b>GetLastError</b> returns NO_ERROR. If the routine fails for some other
///    reason, it returns zero and GetLastError returns extended error information.
///    
@DllImport("SETUPAPI")
BOOL SetupRemoveFromDiskSpaceListW(void* DiskSpace, const(wchar)* TargetFilespec, uint Operation, void* Reserved1, 
                                   uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupRemoveSectionFromDiskSpaceList</b> function removes the file delete or
///copy operations listed in a <b>Copy Files</b> section of an INF file from a disk-space list.
///Params:
///    DiskSpace = Handle to the disk-space list.
///    InfHandle = Handle to an open INF file that contains the <b>SourceDisksFiles</b> section. If <i>ListInfHandle</i> is not
///                specified, this INF file must also contain the section specified by <i>SectionName</i>.
///    ListInfHandle = Optional handle to an open INF file that contains the section to remove from the disk-space list. Otherwise,
///                    <i>InfHandle</i> must contain the section specified by <i>SectionName</i>.
///    SectionName = Pointer to a null-terminated string that specifies the name of the <b>Copy Files</b> or <b>Delete Files</b>
///                  section to remove from the disk-space list.
///    Operation = File operation to remove from the list. This parameter can be one of the following values. <table> <tr>
///                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILEOP_DELETE"></a><a
///                id="fileop_delete"></a><dl> <dt><b>FILEOP_DELETE</b></dt> </dl> </td> <td width="60%"> A file delete operation.
///                </td> </tr> <tr> <td width="40%"><a id="FILEOP_COPY"></a><a id="fileop_copy"></a><dl> <dt><b>FILEOP_COPY</b></dt>
///                </dl> </td> <td width="60%"> A file copy operation. </td> </tr> </table>
///    Reserved1 = Must be zero.
///    Reserved2 = Must be zero.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupRemoveSectionFromDiskSpaceListA(void* DiskSpace, void* InfHandle, void* ListInfHandle, 
                                          const(char)* SectionName, uint Operation, void* Reserved1, uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupRemoveSectionFromDiskSpaceList</b> function removes the file delete or
///copy operations listed in a <b>Copy Files</b> section of an INF file from a disk-space list.
///Params:
///    DiskSpace = Handle to the disk-space list.
///    InfHandle = Handle to an open INF file that contains the <b>SourceDisksFiles</b> section. If <i>ListInfHandle</i> is not
///                specified, this INF file must also contain the section specified by <i>SectionName</i>.
///    ListInfHandle = Optional handle to an open INF file that contains the section to remove from the disk-space list. Otherwise,
///                    <i>InfHandle</i> must contain the section specified by <i>SectionName</i>.
///    SectionName = Pointer to a null-terminated string that specifies the name of the <b>Copy Files</b> or <b>Delete Files</b>
///                  section to remove from the disk-space list.
///    Operation = File operation to remove from the list. This parameter can be one of the following values. <table> <tr>
///                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILEOP_DELETE"></a><a
///                id="fileop_delete"></a><dl> <dt><b>FILEOP_DELETE</b></dt> </dl> </td> <td width="60%"> A file delete operation.
///                </td> </tr> <tr> <td width="40%"><a id="FILEOP_COPY"></a><a id="fileop_copy"></a><dl> <dt><b>FILEOP_COPY</b></dt>
///                </dl> </td> <td width="60%"> A file copy operation. </td> </tr> </table>
///    Reserved1 = Must be zero.
///    Reserved2 = Must be zero.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupRemoveSectionFromDiskSpaceListW(void* DiskSpace, void* InfHandle, void* ListInfHandle, 
                                          const(wchar)* SectionName, uint Operation, void* Reserved1, uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupRemoveInstallSectionFromDiskSpaceList</b> function searches an
///<b>Install</b> section of an INF file for <b>CopyFiles</b> and <b>DelFiles</b> lines, and removes the file operations
///specified in those sections from a disk-space list.
///Params:
///    DiskSpace = Handle to a disk-space list.
///    InfHandle = Handle to an open INF file that contains the <b>Install</b> section. If <i>LayoutInfHandle</i> is not specified,
///                the INF file must also contain the section specified by <i>SectionName</i>.
///    LayoutInfHandle = Optional handle to the INF file that contains the <b>SourceDisksFiles</b> sections. Otherwise, that section is
///                      assumed to exist in the INF file specified by <i>InfHandle</i>.
///    SectionName = Pointer to a null-terminated string that specifies the name of the section to be added to the disk-space list.
///    Reserved1 = Must be zero.
///    Reserved2 = Must be zero.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupRemoveInstallSectionFromDiskSpaceListA(void* DiskSpace, void* InfHandle, void* LayoutInfHandle, 
                                                 const(char)* SectionName, void* Reserved1, uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupRemoveInstallSectionFromDiskSpaceList</b> function searches an
///<b>Install</b> section of an INF file for <b>CopyFiles</b> and <b>DelFiles</b> lines, and removes the file operations
///specified in those sections from a disk-space list.
///Params:
///    DiskSpace = Handle to a disk-space list.
///    InfHandle = Handle to an open INF file that contains the <b>Install</b> section. If <i>LayoutInfHandle</i> is not specified,
///                the INF file must also contain the section specified by <i>SectionName</i>.
///    LayoutInfHandle = Optional handle to the INF file that contains the <b>SourceDisksFiles</b> sections. Otherwise, that section is
///                      assumed to exist in the INF file specified by <i>InfHandle</i>.
///    SectionName = Pointer to a null-terminated string that specifies the name of the section to be added to the disk-space list.
///    Reserved1 = Must be zero.
///    Reserved2 = Must be zero.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupRemoveInstallSectionFromDiskSpaceListW(void* DiskSpace, void* InfHandle, void* LayoutInfHandle, 
                                                 const(wchar)* SectionName, void* Reserved1, uint Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupIterateCabinet</b> function iterates through all the files in a cabinet
///and sends a notification to a callback function for each file found.
///Params:
///    CabinetFile = Cabinet (.CAB) file to iterate through.
///    Reserved = Not currently used.
///    MsgHandler = Pointer to a FileCallback routine that will process the notifications <b>SetupIterateCabinet</b> returns as it
///                 iterates through the files in the cabinet file. The callback routine may then return a value specifying whether
///                 to decompress, copy, or skip the file.
///    Context = Context value that is passed into the routine specified in <i>MsgHandler</i>. This enables the callback routine
///              to track values between notifications, without having to use global variables.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupIterateCabinetA(const(char)* CabinetFile, uint Reserved, PSP_FILE_CALLBACK_A MsgHandler, void* Context);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupIterateCabinet</b> function iterates through all the files in a cabinet
///and sends a notification to a callback function for each file found.
///Params:
///    CabinetFile = Cabinet (.CAB) file to iterate through.
///    Reserved = Not currently used.
///    MsgHandler = Pointer to a FileCallback routine that will process the notifications <b>SetupIterateCabinet</b> returns as it
///                 iterates through the files in the cabinet file. The callback routine may then return a value specifying whether
///                 to decompress, copy, or skip the file.
///    Context = Context value that is passed into the routine specified in <i>MsgHandler</i>. This enables the callback routine
///              to track values between notifications, without having to use global variables.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupIterateCabinetW(const(wchar)* CabinetFile, uint Reserved, PSP_FILE_CALLBACK_W MsgHandler, void* Context);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupPromptReboot</b> function asks the user if he wants to reboot the system,
///optionally dependent on whether any files in a committed file queue were in use during a file operation. If the user
///answers "yes" to the prompt, shutdown is initiated before this routine returns.
///Params:
///    FileQueue = Optional pointer to a handle to the file queue upon which to base the decision about whether shutdown is
///                necessary. If <i>FileQueue</i> is not specified, <b>SetupPromptReboot</b> assumes shutdown is necessary and asks
///                the user what to do.
///    Owner = Handle for the parent window to own windows created by this function.
///    ScanOnly = Indicates whether or not to prompt the user when <b>SetupPromptReboot</b> is called. If <b>TRUE</b>, the user is
///               never asked about rebooting, and system shutdown is not initiated. In this case, <i>FileQueue</i> must be
///               specified. If <b>FALSE</b>, the user is asked about rebooting, as previously described. Use <i>ScanOnly</i> to
///               determine if shutdown is necessary separately from actually initiating a shutdown.
///Returns:
///    The function returns a combination of the following flags or 1 if an error occurs. To get extended error
///    information, call GetLastError.
///    
@DllImport("SETUPAPI")
int SetupPromptReboot(void* FileQueue, HWND Owner, BOOL ScanOnly);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInitDefaultQueueCallback</b> function initializes the context used by the
///default queue callback routine included with the Setup API.
///Params:
///    OwnerWindow = Handle to the window to use as the parent of any dialog boxes generated by the default callback routine.
///Returns:
///    Pointer to the context used by the default queue callback routine. If the call to
///    <b>SetupInitDefaultQueueCallback</b> fails, the function returns a PVOID value of null. To get extended error
///    information, call GetLastError.
///    
@DllImport("SETUPAPI")
void* SetupInitDefaultQueueCallback(HWND OwnerWindow);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInitDefaultQueueCallbackEx</b> function initializes the context used by
///the default queue callback routine included with the Setup API in the same manner as SetupInitDefaultQueueCallback,
///except that an additional window is provided to the callback function to accept progress messages.
///Params:
///    OwnerWindow = Handle to the window to use as the parent of any dialog boxes generated by the default callback routine.
///    AlternateProgressWindow = Handle to a window that receives the progress messages. To prevent progress messages from being displayed, you
///                              can specify this parameter to be INVALID_HANDLE_VALUE.
///    ProgressMessage = Message that is sent to <i>AlternateProgressWindow</i> when the copy queue is started, and each time a file is
///                      copied.
///    Reserved1 = First message parameter that is sent to the <i>AlternateProgressWindow</i> by the default callback routine.
///    Reserved2 = Second message parameter that is sent to the <i>AlternateProgressWindow</i> by the default callback routine.
///Returns:
///    <b>SetupInitDefaultQueueCallbackEx</b> returns a pointer to the context used by the default queue callback
///    routine. This function can only fail if there is insufficient memory. If this function fails, it returns
///    <b>NULL</b> and does not set the last-error code for the thread.
///    
@DllImport("SETUPAPI")
void* SetupInitDefaultQueueCallbackEx(HWND OwnerWindow, HWND AlternateProgressWindow, uint ProgressMessage, 
                                      uint Reserved1, void* Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupTermDefaultQueueCallback</b> function is called after a queue has
///finished committing. It frees resources allocated by previous calls to SetupInitDefaultQueueCallback or
///SetupInitDefaultQueueCallbackEx.
///Params:
///    Context = Pointer to the context used by the default callback routine.
///Returns:
///    Does not return a value. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
void SetupTermDefaultQueueCallback(void* Context);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupDefaultQueueCallback</b> function is the default queue callback routine
///included with the Setup API. You can use it to process notifications sent by the SetupCommitFileQueue function.
///Params:
///    Context = Pointer to the context initialized by the SetupInitDefaultQueueCallback or SetupInitDefaultQueueCallbackEx
///              functions.
///    Notification = Notification of a queue action. This parameter can be one of the values shown in the following table. <table>
///                   <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_STARTQUEUE"></a><a
///                   id="spfilenotify_startqueue"></a><dl> <dt><b>SPFILENOTIFY_STARTQUEUE</b></dt> </dl> </td> <td width="60%">
///                   Started queued file operations. </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_ENDQUEUE"></a><a
///                   id="spfilenotify_endqueue"></a><dl> <dt><b>SPFILENOTIFY_ENDQUEUE</b></dt> </dl> </td> <td width="60%"> Finished
///                   queued file operations. </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_STARTSUBQUEUE"></a><a
///                   id="spfilenotify_startsubqueue"></a><dl> <dt><b>SPFILENOTIFY_STARTSUBQUEUE</b></dt> </dl> </td> <td width="60%">
///                   Started a copy, rename, or delete subqueue. </td> </tr> <tr> <td width="40%"><a
///                   id="SPFILENOTIFY_ENDSUBQUEUE"></a><a id="spfilenotify_endsubqueue"></a><dl>
///                   <dt><b>SPFILENOTIFY_ENDSUBQUEUE</b></dt> </dl> </td> <td width="60%"> Finished a copy, rename, or delete
///                   subqueue. </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_STARTRENAME"></a><a
///                   id="spfilenotify_startrename"></a><dl> <dt><b>SPFILENOTIFY_STARTRENAME</b></dt> </dl> </td> <td width="60%">
///                   Started a rename operation. </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_ENDRENAME"></a><a
///                   id="spfilenotify_endrename"></a><dl> <dt><b>SPFILENOTIFY_ENDRENAME</b></dt> </dl> </td> <td width="60%"> Finished
///                   a rename operation. </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_RENAMEERROR"></a><a
///                   id="spfilenotify_renameerror"></a><dl> <dt><b>SPFILENOTIFY_RENAMEERROR</b></dt> </dl> </td> <td width="60%">
///                   Encountered an error while renaming a file. </td> </tr> <tr> <td width="40%"><a
///                   id="SPFILENOTIFY_STARTDELETE"></a><a id="spfilenotify_startdelete"></a><dl>
///                   <dt><b>SPFILENOTIFY_STARTDELETE</b></dt> </dl> </td> <td width="60%"> Started a delete operation. </td> </tr>
///                   <tr> <td width="40%"><a id="SPFILENOTIFY_ENDDELETE"></a><a id="spfilenotify_enddelete"></a><dl>
///                   <dt><b>SPFILENOTIFY_ENDDELETE</b></dt> </dl> </td> <td width="60%"> Finished a delete operation. </td> </tr> <tr>
///                   <td width="40%"><a id="SPFILENOTIFY_DELETEERROR"></a><a id="spfilenotify_deleteerror"></a><dl>
///                   <dt><b>SPFILENOTIFY_DELETEERROR</b></dt> </dl> </td> <td width="60%"> Encountered an error while deleting a file.
///                   </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_STARTCOPY"></a><a id="spfilenotify_startcopy"></a><dl>
///                   <dt><b>SPFILENOTIFY_STARTCOPY</b></dt> </dl> </td> <td width="60%"> Started a copy operation. </td> </tr> <tr>
///                   <td width="40%"><a id="SPFILENOTIFY_ENDCOPY"></a><a id="spfilenotify_endcopy"></a><dl>
///                   <dt><b>SPFILENOTIFY_ENDCOPY</b></dt> </dl> </td> <td width="60%"> Finished a copy operation. </td> </tr> <tr> <td
///                   width="40%"><a id="SPFILENOTIFY_COPYERROR"></a><a id="spfilenotify_copyerror"></a><dl>
///                   <dt><b>SPFILENOTIFY_COPYERROR</b></dt> </dl> </td> <td width="60%"> Encountered an error while copying a file.
///                   </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_NEEDMEDIA"></a><a id="spfilenotify_needmedia"></a><dl>
///                   <dt><b>SPFILENOTIFY_NEEDMEDIA</b></dt> </dl> </td> <td width="60%"> New media is required. </td> </tr> <tr> <td
///                   width="40%"><a id="SPFILENOTIFY_LANGMISMATCH"></a><a id="spfilenotify_langmismatch"></a><dl>
///                   <dt><b>SPFILENOTIFY_LANGMISMATCH</b></dt> </dl> </td> <td width="60%"> Existing target file is in a different
///                   language than the source. </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_TARGETEXISTS"></a><a
///                   id="spfilenotify_targetexists"></a><dl> <dt><b>SPFILENOTIFY_TARGETEXISTS</b></dt> </dl> </td> <td width="60%">
///                   Target file exists. </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_TARGETNEWER_"></a><a
///                   id="spfilenotify_targetnewer_"></a><dl> <dt><b>SPFILENOTIFY_TARGETNEWER </b></dt> </dl> </td> <td width="60%">
///                   Existing target file is newer than source. </td> </tr> </table>
///    Param1 = Additional message information. The content of this parameter depends on the value of the <i>Notification</i>
///             parameter.
///    Param2 = Additional message information. The content of this parameter depends on the value of the <i>Notification</i>
///             parameter.
///Returns:
///    Returns an unsigned integer to SetupCommitFileQueue that can be the one of the values shown in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>FILEOP_ABORT</b></dt> </dl> </td> <td width="60%"> Aborts the operation. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>FILEOP_DOIT</b></dt> </dl> </td> <td width="60%"> Performs the file operation. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>FILEOP_SKIP</b></dt> </dl> </td> <td width="60%"> Skips the operation. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>FILEOP_RETRY</b></dt> </dl> </td> <td width="60%"> Retries the operation. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>FILEOP_NEWPATH</b></dt> </dl> </td> <td width="60%"> Gets a new path for
///    the operation. </td> </tr> </table> To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupDefaultQueueCallbackA(void* Context, uint Notification, size_t Param1, size_t Param2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupDefaultQueueCallback</b> function is the default queue callback routine
///included with the Setup API. You can use it to process notifications sent by the SetupCommitFileQueue function.
///Params:
///    Context = Pointer to the context initialized by the SetupInitDefaultQueueCallback or SetupInitDefaultQueueCallbackEx
///              functions.
///    Notification = Notification of a queue action. This parameter can be one of the values shown in the following table. <table>
///                   <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_STARTQUEUE"></a><a
///                   id="spfilenotify_startqueue"></a><dl> <dt><b>SPFILENOTIFY_STARTQUEUE</b></dt> </dl> </td> <td width="60%">
///                   Started queued file operations. </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_ENDQUEUE"></a><a
///                   id="spfilenotify_endqueue"></a><dl> <dt><b>SPFILENOTIFY_ENDQUEUE</b></dt> </dl> </td> <td width="60%"> Finished
///                   queued file operations. </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_STARTSUBQUEUE"></a><a
///                   id="spfilenotify_startsubqueue"></a><dl> <dt><b>SPFILENOTIFY_STARTSUBQUEUE</b></dt> </dl> </td> <td width="60%">
///                   Started a copy, rename, or delete subqueue. </td> </tr> <tr> <td width="40%"><a
///                   id="SPFILENOTIFY_ENDSUBQUEUE"></a><a id="spfilenotify_endsubqueue"></a><dl>
///                   <dt><b>SPFILENOTIFY_ENDSUBQUEUE</b></dt> </dl> </td> <td width="60%"> Finished a copy, rename, or delete
///                   subqueue. </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_STARTRENAME"></a><a
///                   id="spfilenotify_startrename"></a><dl> <dt><b>SPFILENOTIFY_STARTRENAME</b></dt> </dl> </td> <td width="60%">
///                   Started a rename operation. </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_ENDRENAME"></a><a
///                   id="spfilenotify_endrename"></a><dl> <dt><b>SPFILENOTIFY_ENDRENAME</b></dt> </dl> </td> <td width="60%"> Finished
///                   a rename operation. </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_RENAMEERROR"></a><a
///                   id="spfilenotify_renameerror"></a><dl> <dt><b>SPFILENOTIFY_RENAMEERROR</b></dt> </dl> </td> <td width="60%">
///                   Encountered an error while renaming a file. </td> </tr> <tr> <td width="40%"><a
///                   id="SPFILENOTIFY_STARTDELETE"></a><a id="spfilenotify_startdelete"></a><dl>
///                   <dt><b>SPFILENOTIFY_STARTDELETE</b></dt> </dl> </td> <td width="60%"> Started a delete operation. </td> </tr>
///                   <tr> <td width="40%"><a id="SPFILENOTIFY_ENDDELETE"></a><a id="spfilenotify_enddelete"></a><dl>
///                   <dt><b>SPFILENOTIFY_ENDDELETE</b></dt> </dl> </td> <td width="60%"> Finished a delete operation. </td> </tr> <tr>
///                   <td width="40%"><a id="SPFILENOTIFY_DELETEERROR"></a><a id="spfilenotify_deleteerror"></a><dl>
///                   <dt><b>SPFILENOTIFY_DELETEERROR</b></dt> </dl> </td> <td width="60%"> Encountered an error while deleting a file.
///                   </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_STARTCOPY"></a><a id="spfilenotify_startcopy"></a><dl>
///                   <dt><b>SPFILENOTIFY_STARTCOPY</b></dt> </dl> </td> <td width="60%"> Started a copy operation. </td> </tr> <tr>
///                   <td width="40%"><a id="SPFILENOTIFY_ENDCOPY"></a><a id="spfilenotify_endcopy"></a><dl>
///                   <dt><b>SPFILENOTIFY_ENDCOPY</b></dt> </dl> </td> <td width="60%"> Finished a copy operation. </td> </tr> <tr> <td
///                   width="40%"><a id="SPFILENOTIFY_COPYERROR"></a><a id="spfilenotify_copyerror"></a><dl>
///                   <dt><b>SPFILENOTIFY_COPYERROR</b></dt> </dl> </td> <td width="60%"> Encountered an error while copying a file.
///                   </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_NEEDMEDIA"></a><a id="spfilenotify_needmedia"></a><dl>
///                   <dt><b>SPFILENOTIFY_NEEDMEDIA</b></dt> </dl> </td> <td width="60%"> New media is required. </td> </tr> <tr> <td
///                   width="40%"><a id="SPFILENOTIFY_LANGMISMATCH"></a><a id="spfilenotify_langmismatch"></a><dl>
///                   <dt><b>SPFILENOTIFY_LANGMISMATCH</b></dt> </dl> </td> <td width="60%"> Existing target file is in a different
///                   language than the source. </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_TARGETEXISTS"></a><a
///                   id="spfilenotify_targetexists"></a><dl> <dt><b>SPFILENOTIFY_TARGETEXISTS</b></dt> </dl> </td> <td width="60%">
///                   Target file exists. </td> </tr> <tr> <td width="40%"><a id="SPFILENOTIFY_TARGETNEWER_"></a><a
///                   id="spfilenotify_targetnewer_"></a><dl> <dt><b>SPFILENOTIFY_TARGETNEWER </b></dt> </dl> </td> <td width="60%">
///                   Existing target file is newer than source. </td> </tr> </table>
///    Param1 = Additional message information. The content of this parameter depends on the value of the <i>Notification</i>
///             parameter.
///    Param2 = Additional message information. The content of this parameter depends on the value of the <i>Notification</i>
///             parameter.
///Returns:
///    Returns an unsigned integer to SetupCommitFileQueue that can be the one of the values shown in the following
///    table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>FILEOP_ABORT</b></dt> </dl> </td> <td width="60%"> Aborts the operation. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>FILEOP_DOIT</b></dt> </dl> </td> <td width="60%"> Performs the file operation. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>FILEOP_SKIP</b></dt> </dl> </td> <td width="60%"> Skips the operation. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>FILEOP_RETRY</b></dt> </dl> </td> <td width="60%"> Retries the operation. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>FILEOP_NEWPATH</b></dt> </dl> </td> <td width="60%"> Gets a new path for
///    the operation. </td> </tr> </table> To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
uint SetupDefaultQueueCallbackW(void* Context, uint Notification, size_t Param1, size_t Param2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInstallFromInfSection</b> function carries out all the directives in an
///INF file <b>Install</b> section. If the registry or file is modified, the caller of this function is required have
///privileges to write into the system or target directory.
///Params:
///    Owner = Optional pointer to the window handle to the window that owns any dialog boxes that are generated during
///            installation, such as for disk prompting or file copying. If <i>Owner</i> is not specified, these dialog boxes
///            become top-level windows.
///    InfHandle = Handle to the INF file that contains the section to be processed.
///    SectionName = Name of the <b>Install</b> section in the INF file to process.
///    Flags = Controls what actions to perform. The flags can be a combination of the following values.
///    RelativeKeyRoot = Optional parameter that must be specified if <i>Flags</i> includes SPINST_REGISTRY or SPINST_INI2REG. Handle to a
///                      registry key to be used as the root when the INF file specifies HKR as the key. Note that this parameter is
///                      ignored if <b>SetupInstallFromInfSection</b> is called with the optional <i>DeviceInfoSet</i> and
///                      <i>DeviceInfoData</i> set.
///    SourceRootPath = Source root for file copies. An example would be A:\ or \\pegasus\win\install. If <i>Flags</i> includes
///                     SPINST_FILES, and <i>SourceRootPath</i> is NULL, the system provides a default root path.
///    CopyFlags = Optional parameter that must be specified if <i>Flags</i> includes SPINST_FILES. Specifies flags to be passed to
///                the SetupQueueCopySection function when files are queued for copy. These flags may be a combination of the
///                following values.
///    MsgHandler = Pointer to the callback routine. The callback routine must be in the format of FileCallback. See Notifications
///                 for more information. This parameter is optional only if the <i>Flags</i> parameter does not include
///                 SPINST_FILES, SPINST_REGISTERCALLBACKAWARE plus SPINST_REGSVR, or SPINST_UNREGSVR. <i>MsgHandler</i> must be set
///                 if <i>Flags</i> includes SPINST_FILES. In this case, notification is sent to the callback routine when the file
///                 queue is committed with SetupCommitFileQueue. <i>MsgHandler</i> must be set if <i>Flags</i> includes
///                 SPINST_REGISTERCALLBACKAWARE plus SPINST_REGSVR or SPINST_UNREGSVR. In this case a SPFILENOTIFY_STARTREGISTRATION
///                 or SPFILENOTIFY_ENDREGISTRATION is sent to the callback routine once each time a file is registered or
///                 unregistered using the <b>RegisterDlls</b> INF directive on Windows 2000.
///    Context = Value to be passed to the callback function when the file queue built by this routine internally is committed via
///              SetupCommitFileQueue. The <i>Context</i> parameter is optional only if the <i>Flags</i> parameter does not
///              include SPINST_FIlLES. This parameter must be specified if <i>Flags</i> includes SPINST_FIlLES.
///    DeviceInfoSet = Optional pointer to a handle to a device information set. For more information about the Device Installer setup
///                    functions, see the DDK <i>Programmer's Guide</i>.
///    DeviceInfoData = Optional pointer to a pointer to the <b>SP_DEVINFO_DATA</b> structure that provides a context to a specific
///                     element in the set specified by <i>DeviceInfoSet.</i> For more information about the Device Installer setup
///                     functions, see the DDK <i>Programmer's Guide</i>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupInstallFromInfSectionA(HWND Owner, void* InfHandle, const(char)* SectionName, uint Flags, 
                                 HKEY RelativeKeyRoot, const(char)* SourceRootPath, uint CopyFlags, 
                                 PSP_FILE_CALLBACK_A MsgHandler, void* Context, void* DeviceInfoSet, 
                                 SP_DEVINFO_DATA* DeviceInfoData);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInstallFromInfSection</b> function carries out all the directives in an
///INF file <b>Install</b> section. If the registry or file is modified, the caller of this function is required have
///privileges to write into the system or target directory.
///Params:
///    Owner = Optional pointer to the window handle to the window that owns any dialog boxes that are generated during
///            installation, such as for disk prompting or file copying. If <i>Owner</i> is not specified, these dialog boxes
///            become top-level windows.
///    InfHandle = Handle to the INF file that contains the section to be processed.
///    SectionName = Name of the <b>Install</b> section in the INF file to process.
///    Flags = Controls what actions to perform. The flags can be a combination of the following values.
///    RelativeKeyRoot = Optional parameter that must be specified if <i>Flags</i> includes SPINST_REGISTRY or SPINST_INI2REG. Handle to a
///                      registry key to be used as the root when the INF file specifies HKR as the key. Note that this parameter is
///                      ignored if <b>SetupInstallFromInfSection</b> is called with the optional <i>DeviceInfoSet</i> and
///                      <i>DeviceInfoData</i> set.
///    SourceRootPath = Source root for file copies. An example would be A:\ or \\pegasus\win\install. If <i>Flags</i> includes
///                     SPINST_FILES, and <i>SourceRootPath</i> is NULL, the system provides a default root path.
///    CopyFlags = Optional parameter that must be specified if <i>Flags</i> includes SPINST_FILES. Specifies flags to be passed to
///                the SetupQueueCopySection function when files are queued for copy. These flags may be a combination of the
///                following values.
///    MsgHandler = Pointer to the callback routine. The callback routine must be in the format of FileCallback. See Notifications
///                 for more information. This parameter is optional only if the <i>Flags</i> parameter does not include
///                 SPINST_FILES, SPINST_REGISTERCALLBACKAWARE plus SPINST_REGSVR, or SPINST_UNREGSVR. <i>MsgHandler</i> must be set
///                 if <i>Flags</i> includes SPINST_FILES. In this case, notification is sent to the callback routine when the file
///                 queue is committed with SetupCommitFileQueue. <i>MsgHandler</i> must be set if <i>Flags</i> includes
///                 SPINST_REGISTERCALLBACKAWARE plus SPINST_REGSVR or SPINST_UNREGSVR. In this case a SPFILENOTIFY_STARTREGISTRATION
///                 or SPFILENOTIFY_ENDREGISTRATION is sent to the callback routine once each time a file is registered or
///                 unregistered using the <b>RegisterDlls</b> INF directive on Windows 2000.
///    Context = Value to be passed to the callback function when the file queue built by this routine internally is committed via
///              SetupCommitFileQueue. The <i>Context</i> parameter is optional only if the <i>Flags</i> parameter does not
///              include SPINST_FIlLES. This parameter must be specified if <i>Flags</i> includes SPINST_FIlLES.
///    DeviceInfoSet = Optional pointer to a handle to a device information set. For more information about the Device Installer setup
///                    functions, see the DDK <i>Programmer's Guide</i>.
///    DeviceInfoData = Optional pointer to a pointer to the <b>SP_DEVINFO_DATA</b> structure that provides a context to a specific
///                     element in the set specified by <i>DeviceInfoSet.</i> For more information about the Device Installer setup
///                     functions, see the DDK <i>Programmer's Guide</i>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupInstallFromInfSectionW(HWND Owner, void* InfHandle, const(wchar)* SectionName, uint Flags, 
                                 HKEY RelativeKeyRoot, const(wchar)* SourceRootPath, uint CopyFlags, 
                                 PSP_FILE_CALLBACK_W MsgHandler, void* Context, void* DeviceInfoSet, 
                                 SP_DEVINFO_DATA* DeviceInfoData);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInstallFilesFromInfSection</b> function queues all the files for an
///installation that are specified in the Copy Files, Delete Files, and Rename Files sections that are listed by an
///Install section. If a file is modified, the caller of this function is required to have privileges to write to the
///target directory.
///Params:
///    InfHandle = The handle to an INF file that contains the section to be installed.
///    LayoutInfHandle = An optional pointer to a handle to the INF file that contains the SourceDisksFiles and SourceDisksNames sections.
///                      If <i>LayoutInfHandle</i> is not specified, then the SourceDisksFiles and SourceDisksNames sections from
///                      <i>InfHandle</i> are used.
///    FileQueue = The handle to the queue where installation operations are to be added.
///    SectionName = The name of the Install section in the <i>InfHandle</i> parameter that lists the Copy Files, Delete Files, and
///                  Rename Files sections that contain the files to install. Use a <b>null</b>-terminated string.
///    SourceRootPath = An optional pointer to a root path to the source files to copy, for example, A:\ or \\pegasus\win\install. Use a
///                     <b>null</b>-terminated string.
///    CopyFlags = An optional pointer to a set of flags that control the behavior of the file copy operation. The flags can be a
///                combination of the following values.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupInstallFilesFromInfSectionA(void* InfHandle, void* LayoutInfHandle, void* FileQueue, 
                                      const(char)* SectionName, const(char)* SourceRootPath, uint CopyFlags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInstallFilesFromInfSection</b> function queues all the files for an
///installation that are specified in the Copy Files, Delete Files, and Rename Files sections that are listed by an
///Install section. If a file is modified, the caller of this function is required to have privileges to write to the
///target directory.
///Params:
///    InfHandle = The handle to an INF file that contains the section to be installed.
///    LayoutInfHandle = An optional pointer to a handle to the INF file that contains the SourceDisksFiles and SourceDisksNames sections.
///                      If <i>LayoutInfHandle</i> is not specified, then the SourceDisksFiles and SourceDisksNames sections from
///                      <i>InfHandle</i> are used.
///    FileQueue = The handle to the queue where installation operations are to be added.
///    SectionName = The name of the Install section in the <i>InfHandle</i> parameter that lists the Copy Files, Delete Files, and
///                  Rename Files sections that contain the files to install. Use a <b>null</b>-terminated string.
///    SourceRootPath = An optional pointer to a root path to the source files to copy, for example, A:\ or \\pegasus\win\install. Use a
///                     <b>null</b>-terminated string.
///    CopyFlags = An optional pointer to a set of flags that control the behavior of the file copy operation. The flags can be a
///                combination of the following values.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupInstallFilesFromInfSectionW(void* InfHandle, void* LayoutInfHandle, void* FileQueue, 
                                      const(wchar)* SectionName, const(wchar)* SourceRootPath, uint CopyFlags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInstallServicesFromInfSection</b> function performs service installation
///and deletion operations that are specified in the <b>Service Install</b> sections listed in the <b>Service</b>
///section of an INF file. A caller of this function is required to have access to the Service Control Manager, and
///privileges to modify services.
///Params:
///    InfHandle = A handle to the INF file that contains the <b>Service</b> section.
///    SectionName = The name of the <b>Service</b> section to process. You should use a null-terminated string.
///    Flags = The controls for the installation of each service in the specified section. <table> <tr> <th>Flag</th>
///            <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SPSVCINST_TAGTOFRONT"></a><a
///            id="spsvcinst_tagtofront"></a><dl> <dt><b>SPSVCINST_TAGTOFRONT</b></dt> <dt>0x001</dt> </dl> </td> <td
///            width="60%"> AddService section: move the service tag to the front of its group order list. </td> </tr> <tr> <td
///            width="40%"><a id="SPSVCINST_DELETEEVENTLOGENTRY"></a><a id="spsvcinst_deleteeventlogentry"></a><dl>
///            <dt><b>SPSVCINST_DELETEEVENTLOGENTRY</b></dt> <dt>0x004</dt> </dl> </td> <td width="60%"> DelService section:
///            delete the event log entry. </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_DISPLAYNAME"></a><a
///            id="spsvcinst_noclobber_displayname"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_DISPLAYNAME</b></dt> <dt>0x008</dt>
///            </dl> </td> <td width="60%"> AddService section: do not overwrite the display name if one already exists. </td>
///            </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_STARTTYPE"></a><a
///            id="spsvcinst_noclobber_starttype"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_STARTTYPE</b></dt> <dt>0x010</dt> </dl>
///            </td> <td width="60%"> AddService section: do not overwrite the start type value if the service already exists.
///            </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_ERRORCONTROL"></a><a
///            id="spsvcinst_noclobber_errorcontrol"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_ERRORCONTROL</b></dt> <dt>0x020</dt>
///            </dl> </td> <td width="60%"> AddService section: do not overwrite the error control value if the service already
///            exists. </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_LOADORDERGROUP"></a><a
///            id="spsvcinst_noclobber_loadordergroup"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_LOADORDERGROUP</b></dt>
///            <dt>0x040</dt> </dl> </td> <td width="60%"> AddService section: do not overwrite the load order group if it
///            already exists. </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_DEPENDENCIES"></a><a
///            id="spsvcinst_noclobber_dependencies"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_DEPENDENCIES</b></dt> <dt>0x080</dt>
///            </dl> </td> <td width="60%"> AddService section: do not overwrite the dependencies list if it already exists.
///            </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_DESCRIPTION"></a><a
///            id="spsvcinst_noclobber_description"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_DESCRIPTION</b></dt> <dt>0x100</dt>
///            </dl> </td> <td width="60%"> AddService section: mark this service as the function driver for the device being
///            installed. </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_STOPSERVICE"></a><a
///            id="spsvcinst_stopservice"></a><dl> <dt><b>SPSVCINST_STOPSERVICE</b></dt> <dt>0x200</dt> </dl> </td> <td
///            width="60%"> DelService section: Stop the associated service specified in the entry before deleting the service.
///            </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_CLOBBER_SECURITY"></a><a
///            id="spsvcinst_clobber_security"></a><dl> <dt><b>SPSVCINST_CLOBBER_SECURITY</b></dt> <dt>0x400</dt> </dl> </td>
///            <td width="60%"> AddService section: Security settings the service are overwritten if the service already exists
///            in the system. <div class="alert"><b>Note</b> Available starting with Windows Server 2003 and Windows XP.</div>
///            <div> </div> </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_STARTSERVICE"></a><a
///            id="spsvcinst_startservice"></a><dl> <dt><b>SPSVCINST_STARTSERVICE</b></dt> <dt>0x800</dt> </dl> </td> <td
///            width="60%"> AddService section: Start the service after the service is installed. This flag cannot be used to
///            start a service that implements a Plug and Play (PnP) function driver or filter driver for a device. Otherwise,
///            this flag can be used to start a user-mode or kernel-mode service that is managed by the Service Control Manager
///            (SCM.) <div class="alert"><b>Note</b> Available starting with Windows Server 2008 and Windows Vista.</div> <div>
///            </div> </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES"></a><a
///            id="spsvcinst_noclobber_requiredprivileges"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES</b></dt>
///            <dt>0x1000</dt> </dl> </td> <td width="60%"> AddService section: Do not overwrite the given service's required
///            privileges if the service already exists in the system. <div class="alert"><b>Note</b> Available starting with
///            Windows Server 2008 R2 and Windows 7.</div> <div> </div> </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. The function calls <b>SetLastError</b> with
///    ERROR_SUCCESS_REBOOT_REQUIRED if a reboot of the system is required. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupInstallServicesFromInfSectionA(void* InfHandle, const(char)* SectionName, uint Flags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInstallServicesFromInfSection</b> function performs service installation
///and deletion operations that are specified in the <b>Service Install</b> sections listed in the <b>Service</b>
///section of an INF file. A caller of this function is required to have access to the Service Control Manager, and
///privileges to modify services.
///Params:
///    InfHandle = A handle to the INF file that contains the <b>Service</b> section.
///    SectionName = The name of the <b>Service</b> section to process. You should use a null-terminated string.
///    Flags = The controls for the installation of each service in the specified section. <table> <tr> <th>Flag</th>
///            <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SPSVCINST_TAGTOFRONT"></a><a
///            id="spsvcinst_tagtofront"></a><dl> <dt><b>SPSVCINST_TAGTOFRONT</b></dt> <dt>0x001</dt> </dl> </td> <td
///            width="60%"> AddService section: move the service tag to the front of its group order list. </td> </tr> <tr> <td
///            width="40%"><a id="SPSVCINST_DELETEEVENTLOGENTRY"></a><a id="spsvcinst_deleteeventlogentry"></a><dl>
///            <dt><b>SPSVCINST_DELETEEVENTLOGENTRY</b></dt> <dt>0x004</dt> </dl> </td> <td width="60%"> DelService section:
///            delete the event log entry. </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_DISPLAYNAME"></a><a
///            id="spsvcinst_noclobber_displayname"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_DISPLAYNAME</b></dt> <dt>0x008</dt>
///            </dl> </td> <td width="60%"> AddService section: do not overwrite the display name if one already exists. </td>
///            </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_STARTTYPE"></a><a
///            id="spsvcinst_noclobber_starttype"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_STARTTYPE</b></dt> <dt>0x010</dt> </dl>
///            </td> <td width="60%"> AddService section: do not overwrite the start type value if the service already exists.
///            </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_ERRORCONTROL"></a><a
///            id="spsvcinst_noclobber_errorcontrol"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_ERRORCONTROL</b></dt> <dt>0x020</dt>
///            </dl> </td> <td width="60%"> AddService section: do not overwrite the error control value if the service already
///            exists. </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_LOADORDERGROUP"></a><a
///            id="spsvcinst_noclobber_loadordergroup"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_LOADORDERGROUP</b></dt>
///            <dt>0x040</dt> </dl> </td> <td width="60%"> AddService section: do not overwrite the load order group if it
///            already exists. </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_DEPENDENCIES"></a><a
///            id="spsvcinst_noclobber_dependencies"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_DEPENDENCIES</b></dt> <dt>0x080</dt>
///            </dl> </td> <td width="60%"> AddService section: do not overwrite the dependencies list if it already exists.
///            </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_DESCRIPTION"></a><a
///            id="spsvcinst_noclobber_description"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_DESCRIPTION</b></dt> <dt>0x100</dt>
///            </dl> </td> <td width="60%"> AddService section: mark this service as the function driver for the device being
///            installed. </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_STOPSERVICE"></a><a
///            id="spsvcinst_stopservice"></a><dl> <dt><b>SPSVCINST_STOPSERVICE</b></dt> <dt>0x200</dt> </dl> </td> <td
///            width="60%"> DelService section: Stop the associated service specified in the entry before deleting the service.
///            </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_CLOBBER_SECURITY"></a><a
///            id="spsvcinst_clobber_security"></a><dl> <dt><b>SPSVCINST_CLOBBER_SECURITY</b></dt> <dt>0x400</dt> </dl> </td>
///            <td width="60%"> AddService section: Security settings the service are overwritten if the service already exists
///            in the system. <div class="alert"><b>Note</b> Available starting with Windows Server 2003 and Windows XP.</div>
///            <div> </div> </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_STARTSERVICE"></a><a
///            id="spsvcinst_startservice"></a><dl> <dt><b>SPSVCINST_STARTSERVICE</b></dt> <dt>0x800</dt> </dl> </td> <td
///            width="60%"> AddService section: Start the service after the service is installed. This flag cannot be used to
///            start a service that implements a Plug and Play (PnP) function driver or filter driver for a device. Otherwise,
///            this flag can be used to start a user-mode or kernel-mode service that is managed by the Service Control Manager
///            (SCM.) <div class="alert"><b>Note</b> Available starting with Windows Server 2008 and Windows Vista.</div> <div>
///            </div> </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES"></a><a
///            id="spsvcinst_noclobber_requiredprivileges"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES</b></dt>
///            <dt>0x1000</dt> </dl> </td> <td width="60%"> AddService section: Do not overwrite the given service's required
///            privileges if the service already exists in the system. <div class="alert"><b>Note</b> Available starting with
///            Windows Server 2008 R2 and Windows 7.</div> <div> </div> </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. The function calls <b>SetLastError</b> with
///    ERROR_SUCCESS_REBOOT_REQUIRED if a reboot of the system is required. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupInstallServicesFromInfSectionW(void* InfHandle, const(wchar)* SectionName, uint Flags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInstallServicesFromInfSectionEx</b> function performs service
///installation and deletion operations that are specified in the <b>Service Install</b> sections listed in the
///<b>Service</b> section of an INF file. A caller of this function is required to have access to the Service Control
///Manager, and privileges to modify services.
///Params:
///    InfHandle = A handle to the INF file that contains the <b>Service</b> section.
///    SectionName = The name of the <b>Service</b> section to process. You should use a null-terminated string.
///    Flags = The controls for the installation. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="SPSVCINST_TAGTOFRONT"></a><a id="spsvcinst_tagtofront"></a><dl> <dt><b>SPSVCINST_TAGTOFRONT</b></dt>
///            <dt>0x001</dt> </dl> </td> <td width="60%"> Move the service tag to the front of its group order list. </td>
///            </tr> <tr> <td width="40%"><a id="SPSVCINST_ASSOCSERVICE"></a><a id="spsvcinst_assocservice"></a><dl>
///            <dt><b>SPSVCINST_ASSOCSERVICE</b></dt> <dt>0x002</dt> </dl> </td> <td width="60%"> AddService section: Mark this
///            service as the function driver for the device being installed. </td> </tr> <tr> <td width="40%"><a
///            id="SPSVCINST_DELETEEVENTLOGENTRY"></a><a id="spsvcinst_deleteeventlogentry"></a><dl>
///            <dt><b>SPSVCINST_DELETEEVENTLOGENTRY</b></dt> <dt>0x004</dt> </dl> </td> <td width="60%"> Delete the event log
///            entry for a specified service. </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_DISPLAYNAME"></a><a
///            id="spsvcinst_noclobber_displayname"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_DISPLAYNAME</b></dt> <dt>0x008</dt>
///            </dl> </td> <td width="60%"> Do not overwrite the display name if one already exists. </td> </tr> <tr> <td
///            width="40%"><a id="SPSVCINST_NOCLOBBER_STARTTYPE"></a><a id="spsvcinst_noclobber_starttype"></a><dl>
///            <dt><b>SPSVCINST_NOCLOBBER_STARTTYPE</b></dt> <dt>0x010</dt> </dl> </td> <td width="60%"> Do not overwrite the
///            start type value if the service already exists. </td> </tr> <tr> <td width="40%"><a
///            id="SPSVCINST_NOCLOBBER_ERRORCONTROL"></a><a id="spsvcinst_noclobber_errorcontrol"></a><dl>
///            <dt><b>SPSVCINST_NOCLOBBER_ERRORCONTROL</b></dt> <dt>0x020</dt> </dl> </td> <td width="60%"> Do not overwrite the
///            error control value if the service already exists. </td> </tr> <tr> <td width="40%"><a
///            id="SPSVCINST_NOCLOBBER_LOADORDERGROUP"></a><a id="spsvcinst_noclobber_loadordergroup"></a><dl>
///            <dt><b>SPSVCINST_NOCLOBBER_LOADORDERGROUP</b></dt> <dt>0x040</dt> </dl> </td> <td width="60%"> Do not overwrite
///            the load order group if it already exists. </td> </tr> <tr> <td width="40%"><a
///            id="SPSVCINST_NOCLOBBER_DEPENDENCIES"></a><a id="spsvcinst_noclobber_dependencies"></a><dl>
///            <dt><b>SPSVCINST_NOCLOBBER_DEPENDENCIES</b></dt> <dt>0x080</dt> </dl> </td> <td width="60%"> Do not overwrite the
///            dependencies list if it already exists. </td> </tr> <tr> <td width="40%"><a
///            id="SPSVCINST_NOCLOBBER_DESCRIPTION"></a><a id="spsvcinst_noclobber_description"></a><dl>
///            <dt><b>SPSVCINST_NOCLOBBER_DESCRIPTION</b></dt> <dt>0x100</dt> </dl> </td> <td width="60%"> AddService section:
///            mark this service as the function driver for the device being installed. </td> </tr> <tr> <td width="40%"><a
///            id="SPSVCINST_STOPSERVICE"></a><a id="spsvcinst_stopservice"></a><dl> <dt><b>SPSVCINST_STOPSERVICE</b></dt>
///            <dt>0x200</dt> </dl> </td> <td width="60%"> DelService section: Stop the associated service specified in the
///            entry before deleting the service. </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_CLOBBER_SECURITY"></a><a
///            id="spsvcinst_clobber_security"></a><dl> <dt><b>SPSVCINST_CLOBBER_SECURITY</b></dt> <dt>0x400</dt> </dl> </td>
///            <td width="60%"> AddService section: Security settings the service are overwritten if the service already exists
///            in the system. <div class="alert"><b>Note</b> Available starting with Windows Server 2003 and Windows XP.</div>
///            <div> </div> </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_STARTSERVICE"></a><a
///            id="spsvcinst_startservice"></a><dl> <dt><b>SPSVCINST_STARTSERVICE</b></dt> <dt>0x800</dt> </dl> </td> <td
///            width="60%"> AddService section: Start the service after the service is installed. This flag cannot be used to
///            start a service that implements a Plug and Play (PnP) function driver or filter driver for a device. Otherwise,
///            this flag can be used to start a user-mode or kernel-mode service that is managed by the Service Control Manager
///            (SCM.) <div class="alert"><b>Note</b> Available starting with Windows Server 2008 and Windows Vista.</div> <div>
///            </div> </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES"></a><a
///            id="spsvcinst_noclobber_requiredprivileges"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES</b></dt>
///            <dt>0x1000</dt> </dl> </td> <td width="60%"> AddService section: Do not overwrite the given service's required
///            privileges if the service already exists in the system. <div class="alert"><b>Note</b> Available starting with
///            Windows Server 2008 R2 and Windows 7.</div> <div> </div> </td> </tr> </table>
///    DeviceInfoSet = An optional pointer to a handle to a device information set. For more information, see the DDK <i>Programmer's
///                    Guide</i>. (This resource may not be available in some languages and countries.)
///    DeviceInfoData = An optional pointer to the <b>SP_DEVINFO_DATA</b> structure that provides a context to a specific element in the
///                     set that <i>DeviceInfoSet</i> specifies. For more information, see the DDK <i>Programmer's Guide</i>. (This
///                     resource may not be available in some languages and countries.)
///    Reserved1 = Reserved.
///    Reserved2 = Reserved.
///Returns:
///    If the function succeeds, the return value is nonzero. The function calls <b>SetLastError</b> with
///    ERROR_SUCCESS_REBOOT_REQUIRED if a reboot of the system is required. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupInstallServicesFromInfSectionExA(void* InfHandle, const(char)* SectionName, uint Flags, 
                                           void* DeviceInfoSet, SP_DEVINFO_DATA* DeviceInfoData, void* Reserved1, 
                                           void* Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInstallServicesFromInfSectionEx</b> function performs service
///installation and deletion operations that are specified in the <b>Service Install</b> sections listed in the
///<b>Service</b> section of an INF file. A caller of this function is required to have access to the Service Control
///Manager, and privileges to modify services.
///Params:
///    InfHandle = A handle to the INF file that contains the <b>Service</b> section.
///    SectionName = The name of the <b>Service</b> section to process. You should use a null-terminated string.
///    Flags = The controls for the installation. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="SPSVCINST_TAGTOFRONT"></a><a id="spsvcinst_tagtofront"></a><dl> <dt><b>SPSVCINST_TAGTOFRONT</b></dt>
///            <dt>0x001</dt> </dl> </td> <td width="60%"> Move the service tag to the front of its group order list. </td>
///            </tr> <tr> <td width="40%"><a id="SPSVCINST_ASSOCSERVICE"></a><a id="spsvcinst_assocservice"></a><dl>
///            <dt><b>SPSVCINST_ASSOCSERVICE</b></dt> <dt>0x002</dt> </dl> </td> <td width="60%"> AddService section: Mark this
///            service as the function driver for the device being installed. </td> </tr> <tr> <td width="40%"><a
///            id="SPSVCINST_DELETEEVENTLOGENTRY"></a><a id="spsvcinst_deleteeventlogentry"></a><dl>
///            <dt><b>SPSVCINST_DELETEEVENTLOGENTRY</b></dt> <dt>0x004</dt> </dl> </td> <td width="60%"> Delete the event log
///            entry for a specified service. </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_DISPLAYNAME"></a><a
///            id="spsvcinst_noclobber_displayname"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_DISPLAYNAME</b></dt> <dt>0x008</dt>
///            </dl> </td> <td width="60%"> Do not overwrite the display name if one already exists. </td> </tr> <tr> <td
///            width="40%"><a id="SPSVCINST_NOCLOBBER_STARTTYPE"></a><a id="spsvcinst_noclobber_starttype"></a><dl>
///            <dt><b>SPSVCINST_NOCLOBBER_STARTTYPE</b></dt> <dt>0x010</dt> </dl> </td> <td width="60%"> Do not overwrite the
///            start type value if the service already exists. </td> </tr> <tr> <td width="40%"><a
///            id="SPSVCINST_NOCLOBBER_ERRORCONTROL"></a><a id="spsvcinst_noclobber_errorcontrol"></a><dl>
///            <dt><b>SPSVCINST_NOCLOBBER_ERRORCONTROL</b></dt> <dt>0x020</dt> </dl> </td> <td width="60%"> Do not overwrite the
///            error control value if the service already exists. </td> </tr> <tr> <td width="40%"><a
///            id="SPSVCINST_NOCLOBBER_LOADORDERGROUP"></a><a id="spsvcinst_noclobber_loadordergroup"></a><dl>
///            <dt><b>SPSVCINST_NOCLOBBER_LOADORDERGROUP</b></dt> <dt>0x040</dt> </dl> </td> <td width="60%"> Do not overwrite
///            the load order group if it already exists. </td> </tr> <tr> <td width="40%"><a
///            id="SPSVCINST_NOCLOBBER_DEPENDENCIES"></a><a id="spsvcinst_noclobber_dependencies"></a><dl>
///            <dt><b>SPSVCINST_NOCLOBBER_DEPENDENCIES</b></dt> <dt>0x080</dt> </dl> </td> <td width="60%"> Do not overwrite the
///            dependencies list if it already exists. </td> </tr> <tr> <td width="40%"><a
///            id="SPSVCINST_NOCLOBBER_DESCRIPTION"></a><a id="spsvcinst_noclobber_description"></a><dl>
///            <dt><b>SPSVCINST_NOCLOBBER_DESCRIPTION</b></dt> <dt>0x100</dt> </dl> </td> <td width="60%"> AddService section:
///            mark this service as the function driver for the device being installed. </td> </tr> <tr> <td width="40%"><a
///            id="SPSVCINST_STOPSERVICE"></a><a id="spsvcinst_stopservice"></a><dl> <dt><b>SPSVCINST_STOPSERVICE</b></dt>
///            <dt>0x200</dt> </dl> </td> <td width="60%"> DelService section: Stop the associated service specified in the
///            entry before deleting the service. </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_CLOBBER_SECURITY"></a><a
///            id="spsvcinst_clobber_security"></a><dl> <dt><b>SPSVCINST_CLOBBER_SECURITY</b></dt> <dt>0x400</dt> </dl> </td>
///            <td width="60%"> AddService section: Security settings the service are overwritten if the service already exists
///            in the system. <div class="alert"><b>Note</b> Available starting with Windows Server 2003 and Windows XP.</div>
///            <div> </div> </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_STARTSERVICE"></a><a
///            id="spsvcinst_startservice"></a><dl> <dt><b>SPSVCINST_STARTSERVICE</b></dt> <dt>0x800</dt> </dl> </td> <td
///            width="60%"> AddService section: Start the service after the service is installed. This flag cannot be used to
///            start a service that implements a Plug and Play (PnP) function driver or filter driver for a device. Otherwise,
///            this flag can be used to start a user-mode or kernel-mode service that is managed by the Service Control Manager
///            (SCM.) <div class="alert"><b>Note</b> Available starting with Windows Server 2008 and Windows Vista.</div> <div>
///            </div> </td> </tr> <tr> <td width="40%"><a id="SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES"></a><a
///            id="spsvcinst_noclobber_requiredprivileges"></a><dl> <dt><b>SPSVCINST_NOCLOBBER_REQUIREDPRIVILEGES</b></dt>
///            <dt>0x1000</dt> </dl> </td> <td width="60%"> AddService section: Do not overwrite the given service's required
///            privileges if the service already exists in the system. <div class="alert"><b>Note</b> Available starting with
///            Windows Server 2008 R2 and Windows 7.</div> <div> </div> </td> </tr> </table>
///    DeviceInfoSet = An optional pointer to a handle to a device information set. For more information, see the DDK <i>Programmer's
///                    Guide</i>. (This resource may not be available in some languages and countries.)
///    DeviceInfoData = An optional pointer to the <b>SP_DEVINFO_DATA</b> structure that provides a context to a specific element in the
///                     set that <i>DeviceInfoSet</i> specifies. For more information, see the DDK <i>Programmer's Guide</i>. (This
///                     resource may not be available in some languages and countries.)
///    Reserved1 = Reserved.
///    Reserved2 = Reserved.
///Returns:
///    If the function succeeds, the return value is nonzero. The function calls <b>SetLastError</b> with
///    ERROR_SUCCESS_REBOOT_REQUIRED if a reboot of the system is required. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupInstallServicesFromInfSectionExW(void* InfHandle, const(wchar)* SectionName, uint Flags, 
                                           void* DeviceInfoSet, SP_DEVINFO_DATA* DeviceInfoData, void* Reserved1, 
                                           void* Reserved2);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] <b>InstallHinfSection</b> is an entry-point function exported by Setupapi.dll that
///you can use to execute a section of an .inf file. <b>InstallHinfSection</b> can be invoked by calling the
///Rundll32.exe utility as described in the Remarks section. The prototype for the <b>InstallHinfSection</b> function
///follows the form of all entry-point functions used with Rundll32.exe. If a file is copied or modified, the caller of
///this function is required have privileges to write into the target directory. If there are any services being
///installed, the caller of this function is required have access to the Service Control Manager.
///Params:
///    Window = The parent window handle. Typically <i>hwnd</i> is Null.
///    ModuleHandle = Reserved and should be Null.
///    CommandLine = Pointer to buffer containing the command line. You should use a null-terminated string.
///    ShowCommand = Reserved and should be zero.
@DllImport("SETUPAPI")
void InstallHinfSectionA(HWND Window, HINSTANCE ModuleHandle, const(char)* CommandLine, int ShowCommand);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] <b>InstallHinfSection</b> is an entry-point function exported by Setupapi.dll that
///you can use to execute a section of an .inf file. <b>InstallHinfSection</b> can be invoked by calling the
///Rundll32.exe utility as described in the Remarks section. The prototype for the <b>InstallHinfSection</b> function
///follows the form of all entry-point functions used with Rundll32.exe. If a file is copied or modified, the caller of
///this function is required have privileges to write into the target directory. If there are any services being
///installed, the caller of this function is required have access to the Service Control Manager.
///Params:
///    Window = The parent window handle. Typically <i>hwnd</i> is Null.
///    ModuleHandle = Reserved and should be Null.
///    CommandLine = Pointer to buffer containing the command line. You should use a null-terminated string.
///    ShowCommand = Reserved and should be zero.
@DllImport("SETUPAPI")
void InstallHinfSectionW(HWND Window, HINSTANCE ModuleHandle, const(wchar)* CommandLine, int ShowCommand);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInitializeFileLog</b> function initializes a file to record installation
///operations and outcomes. This can be the system log, where the system tracks the files installed as part of Windows,
///or any other file.
///Params:
///    LogFileName = Optional pointer to the file name of the file to use as the log file. You should use a <b>null</b>-terminated
///                  string. The <i>LogFileName</i> parameter must be specified if <i>Flags</i> does not include SPFILELOG_SYSTEMLOG.
///                  The <i>LogFileName</i> parameter must not be specified if <i>Flags</i> includes SPFILELOG_SYSTEMLOG. This
///                  parameter can be <b>NULL</b>.
///    Flags = Controls the log file initialization. This parameter can be a combination of the following values.
///Returns:
///    The function returns the handle to the log file if it is successful. Otherwise, the return value is
///    INVALID_HANDLE_VALUE and the logged error can be retrieved by a call to GetLastError.
///    
@DllImport("SETUPAPI")
void* SetupInitializeFileLogA(const(char)* LogFileName, uint Flags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupInitializeFileLog</b> function initializes a file to record installation
///operations and outcomes. This can be the system log, where the system tracks the files installed as part of Windows,
///or any other file.
///Params:
///    LogFileName = Optional pointer to the file name of the file to use as the log file. You should use a <b>null</b>-terminated
///                  string. The <i>LogFileName</i> parameter must be specified if <i>Flags</i> does not include SPFILELOG_SYSTEMLOG.
///                  The <i>LogFileName</i> parameter must not be specified if <i>Flags</i> includes SPFILELOG_SYSTEMLOG. This
///                  parameter can be <b>NULL</b>.
///    Flags = Controls the log file initialization. This parameter can be a combination of the following values.
///Returns:
///    The function returns the handle to the log file if it is successful. Otherwise, the return value is
///    INVALID_HANDLE_VALUE and the logged error can be retrieved by a call to GetLastError.
///    
@DllImport("SETUPAPI")
void* SetupInitializeFileLogW(const(wchar)* LogFileName, uint Flags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupTerminateFileLog</b> function releases resources associated with a file
///log.
///Params:
///    FileLogHandle = Handle to the log file as returned by a call to SetupInitializeFileLog.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupTerminateFileLog(void* FileLogHandle);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupLogFile</b> function adds an entry to the log file.
///Params:
///    FileLogHandle = Handle to the file log as returned by SetupInitializeFileLog. The caller must not have passed SPFILELOG_QUERYONLY
///                    when the log file was initialized.
///    LogSectionName = Optional pointer to the name for a logical grouping of names within the log file. You should use a
///                     <b>null</b>-terminated string. Required if SPFILELOG_SYSTEMLOG was not passed when the file log was initialized.
///                     Otherwise, this parameter can be <b>NULL</b>.
///    SourceFilename = Name of the file as it exists on the source media from which it was installed. This name should be in whatever
///                     format is meaningful to the caller. You should use a <b>null</b>-terminated string.
///    TargetFilename = Name of the file as it exists on the target. This name should be in whatever format is meaningful to the caller.
///                     You should use a <b>null</b>-terminated string.
///    Checksum = Optional pointer to a checksum value. Required for the system log.
///    DiskTagfile = Optional pointer to the tagfile for the media from which the file was installed. You should use a
///                  <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination
///                  buffer. Ignored for the system log if SPFILELOG_OEMFILE is not specified. Required for the system log if
///                  SPFILELOG_OEMFILE is specified. Otherwise, this parameter can be <b>NULL</b>.
///    DiskDescription = Optional pointer to the human-readable description of the media from which the file was installed. You should use
///                      a <b>null</b>-terminated string. Ignored for the system log if SPFILELOG_OEMFILE is not specified in the
///                      <i>Flags</i> parameter. Required for the system log if SPFILELOG_OEMFILE is specified in the Flags parameter.
///                      Otherwise, this parameter can be <b>NULL</b>.
///    OtherInfo = Optional pointer to additional information to be associated with the file. You should use a
///                <b>null</b>-terminated string. This parameter can be <b>NULL</b>.
///    Flags = This parameter can be SPFILELOG_OEMFILE, which is meaningful only for the system log and indicates that the file
///            is not supplied by Microsoft. This parameter can be used to convert an existing file's entry, such as when an OEM
///            overwrites a Microsoft-supplied system file.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupLogFileA(void* FileLogHandle, const(char)* LogSectionName, const(char)* SourceFilename, 
                   const(char)* TargetFilename, uint Checksum, const(char)* DiskTagfile, 
                   const(char)* DiskDescription, const(char)* OtherInfo, uint Flags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupLogFile</b> function adds an entry to the log file.
///Params:
///    FileLogHandle = Handle to the file log as returned by SetupInitializeFileLog. The caller must not have passed SPFILELOG_QUERYONLY
///                    when the log file was initialized.
///    LogSectionName = Optional pointer to the name for a logical grouping of names within the log file. You should use a
///                     <b>null</b>-terminated string. Required if SPFILELOG_SYSTEMLOG was not passed when the file log was initialized.
///                     Otherwise, this parameter can be <b>NULL</b>.
///    SourceFilename = Name of the file as it exists on the source media from which it was installed. This name should be in whatever
///                     format is meaningful to the caller. You should use a <b>null</b>-terminated string.
///    TargetFilename = Name of the file as it exists on the target. This name should be in whatever format is meaningful to the caller.
///                     You should use a <b>null</b>-terminated string.
///    Checksum = Optional pointer to a checksum value. Required for the system log.
///    DiskTagfile = Optional pointer to the tagfile for the media from which the file was installed. You should use a
///                  <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the destination
///                  buffer. Ignored for the system log if SPFILELOG_OEMFILE is not specified. Required for the system log if
///                  SPFILELOG_OEMFILE is specified. Otherwise, this parameter can be <b>NULL</b>.
///    DiskDescription = Optional pointer to the human-readable description of the media from which the file was installed. You should use
///                      a <b>null</b>-terminated string. Ignored for the system log if SPFILELOG_OEMFILE is not specified in the
///                      <i>Flags</i> parameter. Required for the system log if SPFILELOG_OEMFILE is specified in the Flags parameter.
///                      Otherwise, this parameter can be <b>NULL</b>.
///    OtherInfo = Optional pointer to additional information to be associated with the file. You should use a
///                <b>null</b>-terminated string. This parameter can be <b>NULL</b>.
///    Flags = This parameter can be SPFILELOG_OEMFILE, which is meaningful only for the system log and indicates that the file
///            is not supplied by Microsoft. This parameter can be used to convert an existing file's entry, such as when an OEM
///            overwrites a Microsoft-supplied system file.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupLogFileW(void* FileLogHandle, const(wchar)* LogSectionName, const(wchar)* SourceFilename, 
                   const(wchar)* TargetFilename, uint Checksum, const(wchar)* DiskTagfile, 
                   const(wchar)* DiskDescription, const(wchar)* OtherInfo, uint Flags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupRemoveFileLogEntry</b> function removes an entry or section from a file
///log.
///Params:
///    FileLogHandle = Handle to the file log as returned by SetupInitializeFileLog. The caller must not have passed SPFILELOG_QUERYONLY
///                    when the log file was initialized.
///    LogSectionName = Pointer to a <b>null</b>-terminated string that specifies the name for a logical grouping of names within the log
///                     file. Required for non-system logs. Otherwise, <i>LogSectionName</i> may be <b>NULL</b>.
///    TargetFilename = Pointer to a <b>null</b>-terminated string that specifies the name of the file as it exists on the target. This
///                     name should be in whatever format is meaningful to the caller. If <b>NULL</b>, the section specified by
///                     <i>LogSectionName</i> is removed. The main section cannot be removed.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupRemoveFileLogEntryA(void* FileLogHandle, const(char)* LogSectionName, const(char)* TargetFilename);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupRemoveFileLogEntry</b> function removes an entry or section from a file
///log.
///Params:
///    FileLogHandle = Handle to the file log as returned by SetupInitializeFileLog. The caller must not have passed SPFILELOG_QUERYONLY
///                    when the log file was initialized.
///    LogSectionName = Pointer to a <b>null</b>-terminated string that specifies the name for a logical grouping of names within the log
///                     file. Required for non-system logs. Otherwise, <i>LogSectionName</i> may be <b>NULL</b>.
///    TargetFilename = Pointer to a <b>null</b>-terminated string that specifies the name of the file as it exists on the target. This
///                     name should be in whatever format is meaningful to the caller. If <b>NULL</b>, the section specified by
///                     <i>LogSectionName</i> is removed. The main section cannot be removed.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupRemoveFileLogEntryW(void* FileLogHandle, const(wchar)* LogSectionName, const(wchar)* TargetFilename);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueryFileLog</b> function returns information from a setup file log.
///Params:
///    FileLogHandle = Handle to the file log as returned by SetupInitializeFileLog.
///    LogSectionName = Optional pointer to the section name for the log file in a format that is meaningful to the caller. You should
///                     use a <b>null</b>-terminated string. Required for non-system logs. If no <i>LogSectionName</i> is specified for a
///                     system log, a default is supplied.
///    TargetFilename = Name of the file for which log information is desired. You should use a <b>null</b>-terminated string.
///    DesiredInfo = Indicates what information should be returned to the <i>DataOut</i> buffer. This parameter can be one of the
///                  following enumerated values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="SetupFileLogSourceFile_name"></a><a id="setupfilelogsourcefile_name"></a><a
///                  id="SETUPFILELOGSOURCEFILE_NAME"></a><dl> <dt><b>SetupFileLogSourceFile name</b></dt> </dl> </td> <td
///                  width="60%"> Name of the source file as it exists on the source media </td> </tr> <tr> <td width="40%"><a
///                  id="SetupFileLogChecksum"></a><a id="setupfilelogchecksum"></a><a id="SETUPFILELOGCHECKSUM"></a><dl>
///                  <dt><b>SetupFileLogChecksum</b></dt> </dl> </td> <td width="60%"> A checksum value used by the system log </td>
///                  </tr> <tr> <td width="40%"><a id="SetupFileLogDiskTagfile"></a><a id="setupfilelogdisktagfile"></a><a
///                  id="SETUPFILELOGDISKTAGFILE"></a><dl> <dt><b>SetupFileLogDiskTagfile</b></dt> </dl> </td> <td width="60%"> Name
///                  of the tag file of the media source containing the source file </td> </tr> <tr> <td width="40%"><a
///                  id="SetupFileLogDiskDescription"></a><a id="setupfilelogdiskdescription"></a><a
///                  id="SETUPFILELOGDISKDESCRIPTION"></a><dl> <dt><b>SetupFileLogDiskDescription</b></dt> </dl> </td> <td
///                  width="60%"> The human-readable description of the media where the source file resides </td> </tr> <tr> <td
///                  width="40%"><a id="SetupFileLogOtherInfo"></a><a id="setupfilelogotherinfo"></a><a
///                  id="SETUPFILELOGOTHERINFO"></a><dl> <dt><b>SetupFileLogOtherInfo</b></dt> </dl> </td> <td width="60%"> Additional
///                  information associated with the logged file </td> </tr> </table> If the value of <i>DesiredInfo</i> is greater
///                  than <b>SetupFileLogOtherInfo</b> the function will fail, and GetLastError will return ERROR_INVALID_PARAMETER.
///    DataOut = Optional pointer to a buffer in which this function returns the requested information for the file. You should
///              use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the
///              destination buffer. You can call the function once to get the required buffer size, allocate the necessary
///              memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this
///              technique, you can avoid errors due to an insufficient buffer size. Not all information is provided for every
///              file. An error is not returned if an empty entry for the file exists in the log. This parameter can be
///              <b>NULL</b>.
///    ReturnBufferSize = Size of the <i>DataOut</i> buffer, in characters. This includes the <b>null</b> terminator. If the buffer is too
///                       small and <i>DataOut</i> is specified, data is not stored in the buffer and the function returns zero. If
///                       <i>DataOut</i> is not specified, the <i>ReturnBufferSize</i> parameter is ignored.
///    RequiredSize = Optional pointer to a variable that receives the required size of <i>DataOut</i>, in characters. This number
///                   includes the <b>null</b> terminator.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueryFileLogA(void* FileLogHandle, const(char)* LogSectionName, const(char)* TargetFilename, 
                        SetupFileLogInfo DesiredInfo, const(char)* DataOut, uint ReturnBufferSize, 
                        uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupQueryFileLog</b> function returns information from a setup file log.
///Params:
///    FileLogHandle = Handle to the file log as returned by SetupInitializeFileLog.
///    LogSectionName = Optional pointer to the section name for the log file in a format that is meaningful to the caller. You should
///                     use a <b>null</b>-terminated string. Required for non-system logs. If no <i>LogSectionName</i> is specified for a
///                     system log, a default is supplied.
///    TargetFilename = Name of the file for which log information is desired. You should use a <b>null</b>-terminated string.
///    DesiredInfo = Indicates what information should be returned to the <i>DataOut</i> buffer. This parameter can be one of the
///                  following enumerated values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="SetupFileLogSourceFile_name"></a><a id="setupfilelogsourcefile_name"></a><a
///                  id="SETUPFILELOGSOURCEFILE_NAME"></a><dl> <dt><b>SetupFileLogSourceFile name</b></dt> </dl> </td> <td
///                  width="60%"> Name of the source file as it exists on the source media </td> </tr> <tr> <td width="40%"><a
///                  id="SetupFileLogChecksum"></a><a id="setupfilelogchecksum"></a><a id="SETUPFILELOGCHECKSUM"></a><dl>
///                  <dt><b>SetupFileLogChecksum</b></dt> </dl> </td> <td width="60%"> A checksum value used by the system log </td>
///                  </tr> <tr> <td width="40%"><a id="SetupFileLogDiskTagfile"></a><a id="setupfilelogdisktagfile"></a><a
///                  id="SETUPFILELOGDISKTAGFILE"></a><dl> <dt><b>SetupFileLogDiskTagfile</b></dt> </dl> </td> <td width="60%"> Name
///                  of the tag file of the media source containing the source file </td> </tr> <tr> <td width="40%"><a
///                  id="SetupFileLogDiskDescription"></a><a id="setupfilelogdiskdescription"></a><a
///                  id="SETUPFILELOGDISKDESCRIPTION"></a><dl> <dt><b>SetupFileLogDiskDescription</b></dt> </dl> </td> <td
///                  width="60%"> The human-readable description of the media where the source file resides </td> </tr> <tr> <td
///                  width="40%"><a id="SetupFileLogOtherInfo"></a><a id="setupfilelogotherinfo"></a><a
///                  id="SETUPFILELOGOTHERINFO"></a><dl> <dt><b>SetupFileLogOtherInfo</b></dt> </dl> </td> <td width="60%"> Additional
///                  information associated with the logged file </td> </tr> </table> If the value of <i>DesiredInfo</i> is greater
///                  than <b>SetupFileLogOtherInfo</b> the function will fail, and GetLastError will return ERROR_INVALID_PARAMETER.
///    DataOut = Optional pointer to a buffer in which this function returns the requested information for the file. You should
///              use a <b>null</b>-terminated string. The <b>null</b>-terminated string should not exceed the size of the
///              destination buffer. You can call the function once to get the required buffer size, allocate the necessary
///              memory, and then call the function a second time to retrieve the data. See the Remarks section. Using this
///              technique, you can avoid errors due to an insufficient buffer size. Not all information is provided for every
///              file. An error is not returned if an empty entry for the file exists in the log. This parameter can be
///              <b>NULL</b>.
///    ReturnBufferSize = Size of the <i>DataOut</i> buffer, in characters. This includes the <b>null</b> terminator. If the buffer is too
///                       small and <i>DataOut</i> is specified, data is not stored in the buffer and the function returns zero. If
///                       <i>DataOut</i> is not specified, the <i>ReturnBufferSize</i> parameter is ignored.
///    RequiredSize = Optional pointer to a variable that receives the required size of <i>DataOut</i>, in characters. This number
///                   includes the <b>null</b> terminator.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupQueryFileLogW(void* FileLogHandle, const(wchar)* LogSectionName, const(wchar)* TargetFilename, 
                        SetupFileLogInfo DesiredInfo, const(wchar)* DataOut, uint ReturnBufferSize, 
                        uint* RequiredSize);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupOpenLog</b> function opens the log files.
///Params:
///    Erase = Must be FALSE.
///Returns:
///    <b>TRUE</b> if the log file can be opened. <b>FALSE</b> if an error occurs. To get the error code, call
///    GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupOpenLog(BOOL Erase);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupLogError</b> function writes an error message to a log file. It is meant
///to be used during the installation of Windows, but it is always available. It is not intended to be used after the
///operating system is installed  the event log should be used instead.
///Params:
///    MessageString = Pointer to the string that should be saved to Setup's log. The message must end with a return-linefeed
///                    combination (\r\n). You should use a null-terminated string. The null-terminated string should not exceed the
///                    size of the destination buffer. The message is always saved to the action log, setupact.log. If <i>Severity</i>
///                    is <b>LogSevWarning</b>, <b>LogSevError</b>, or <b>LogSevFatalError</b>, Setup also saves the message to the
///                    error log, setuperr.log. Both logs are stored in the Windows directory.
///    Severity = Severity of the message, one of the following: <b>LogSevInformation</b>, <b>LogSevWarning</b>,
///               <b>LogSevError</b>, or <b>LogSevFatalError</b>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupLogErrorA(const(char)* MessageString, uint Severity);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupLogError</b> function writes an error message to a log file. It is meant
///to be used during the installation of Windows, but it is always available. It is not intended to be used after the
///operating system is installed  the event log should be used instead.
///Params:
///    MessageString = Pointer to the string that should be saved to Setup's log. The message must end with a return-linefeed
///                    combination (\r\n). You should use a null-terminated string. The null-terminated string should not exceed the
///                    size of the destination buffer. The message is always saved to the action log, setupact.log. If <i>Severity</i>
///                    is <b>LogSevWarning</b>, <b>LogSevError</b>, or <b>LogSevFatalError</b>, Setup also saves the message to the
///                    error log, setuperr.log. Both logs are stored in the Windows directory.
///    Severity = Severity of the message, one of the following: <b>LogSevInformation</b>, <b>LogSevWarning</b>,
///               <b>LogSevError</b>, or <b>LogSevFatalError</b>.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
BOOL SetupLogErrorW(const(wchar)* MessageString, uint Severity);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupCloseLog</b> function closes the log files.
///Returns:
///    This function does not return a value.
///    
@DllImport("SETUPAPI")
void SetupCloseLog();

///The <b>SetupDiGetClassDevs</b> function returns a handle to a device information set that contains requested device
///information elements for a local computer.
///Params:
///    ClassGuid = A pointer to the GUID for a device setup class or a device interface class. This pointer is optional and can be
///                <b>NULL</b>. For more information about how to set <i>ClassGuid</i>, see the following <b>Remarks</b> section.
///    Enumerator = A pointer to a NULL-terminated string that specifies: <ul> <li> An identifier (ID) of a Plug and Play (PnP)
///                 enumerator. This ID can either be the value's globally unique identifier (GUID) or symbolic name. For example,
///                 "PCI" can be used to specify the PCI PnP value. Other examples of symbolic names for PnP values include "USB,"
///                 "PCMCIA," and "SCSI". </li> <li> A PnP device instance ID. When specifying a PnP device instance ID,
///                 DIGCF_DEVICEINTERFACE must be set in the Flags parameter. </li> </ul> This pointer is optional and can be
///                 <b>NULL</b>. If an <i>enumeration</i> value is not used to select devices, set <i>Enumerator</i> to <b>NULL</b>
///                 For more information about how to set the <i>Enumerator</i> value, see the following <b>Remarks</b> section.
///    hwndParent = A handle to the top-level window to be used for a user interface that is associated with installing a device
///                 instance in the device information set. This handle is optional and can be <b>NULL</b>.
///    Flags = A variable of type DWORD that specifies control options that filter the device information elements that are
///            added to the device information set. This parameter can be a bitwise OR of zero or more of the following flags.
///            For more information about combining these flags, see the following <b>Remarks</b> section.
///Returns:
///    If the operation succeeds, <b>SetupDiGetClassDevs</b> returns a handle to a device information set that contains
///    all installed devices that matched the supplied parameters. If the operation fails, the function returns
///    INVALID_HANDLE_VALUE. To get extended error information, call GetLastError.
///    
@DllImport("SETUPAPI")
void* SetupDiGetClassDevsA(const(GUID)* ClassGuid, const(char)* Enumerator, HWND hwndParent, uint Flags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupEnumInfSections</b> function retrieves section names from an INF file.
///Params:
///    InfHandle = Handle to the INF file that is to be queried.
///    Index = The zero-based index of the section name to retrieve. This index may not correspond to the order of sections as
///            they appear in the INF file.
///    Buffer = Pointer to a buffer that receives the section name. You can call the function once to get the required buffer
///             size, allocate the necessary memory, and then call the function a second time to retrieve the name. Using this
///             technique, you can avoid errors caused by an insufficient buffer size. This parameter is optional. For more
///             information, see the Remarks section.
///    Size = Size of the buffer pointed to by <i>ReturnBuffer</i> in characters. This number includes the terminating
///           <b>NULL</b> character.
///    SizeNeeded = Pointer to a location that receives the required size of the buffer pointed to by <i>ReturnBuffer</i>. The size
///                 is specified as the number of characters required to store the section name, including the terminating
///                 <b>NULL</b> character.
///Returns:
///    If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is
///    <b>FALSE</b>. To get extended error information, call GetLastError. GetLastError returns
///    <b>ERROR_NO_MORE_ITEMS</b> if the value of <b>EnumerationIndex</b> is greater than or equal to the number of
///    sections names in the INF file.
///    
@DllImport("SETUPAPI")
BOOL SetupEnumInfSectionsA(void* InfHandle, uint Index, const(char)* Buffer, uint Size, uint* SizeNeeded);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupEnumInfSections</b> function retrieves section names from an INF file.
///Params:
///    InfHandle = Handle to the INF file that is to be queried.
///    Index = The zero-based index of the section name to retrieve. This index may not correspond to the order of sections as
///            they appear in the INF file.
///    Buffer = Pointer to a buffer that receives the section name. You can call the function once to get the required buffer
///             size, allocate the necessary memory, and then call the function a second time to retrieve the name. Using this
///             technique, you can avoid errors caused by an insufficient buffer size. This parameter is optional. For more
///             information, see the Remarks section.
///    Size = Size of the buffer pointed to by <i>ReturnBuffer</i> in characters. This number includes the terminating
///           <b>NULL</b> character.
///    SizeNeeded = Pointer to a location that receives the required size of the buffer pointed to by <i>ReturnBuffer</i>. The size
///                 is specified as the number of characters required to store the section name, including the terminating
///                 <b>NULL</b> character.
///Returns:
///    If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is
///    <b>FALSE</b>. To get extended error information, call GetLastError. GetLastError returns
///    <b>ERROR_NO_MORE_ITEMS</b> if the value of <b>EnumerationIndex</b> is greater than or equal to the number of
///    sections names in the INF file.
///    
@DllImport("SETUPAPI")
BOOL SetupEnumInfSectionsW(void* InfHandle, uint Index, const(wchar)* Buffer, uint Size, uint* SizeNeeded);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupVerifyInfFile</b> function verifies the digital signature of the
///specified INF file by using its corresponding catalog. The verification can be performed against an alternate
///platform.
///Params:
///    InfName = The name of the INF file to be verified. This name may include a path.
///    AltPlatformInfo = An optional pointer to a SP_ALTPLATFORM_INFO_V2 structure that contains information about the alternate platform
///                      to use when validating the INF file. This parameter can be Null.
///    InfSignerInfo = A pointer to an SP_INF_SIGNER_INFO structure that receives information about the INF digital signature, that is,
///                    if it is signed.
///Returns:
///    This function returns WINSETUPAPI BOOL.
///    
@DllImport("SETUPAPI")
BOOL SetupVerifyInfFileA(const(char)* InfName, SP_ALTPLATFORM_INFO_V2* AltPlatformInfo, 
                         SP_INF_SIGNER_INFO_V2_A* InfSignerInfo);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupVerifyInfFile</b> function verifies the digital signature of the
///specified INF file by using its corresponding catalog. The verification can be performed against an alternate
///platform.
///Params:
///    InfName = The name of the INF file to be verified. This name may include a path.
///    AltPlatformInfo = An optional pointer to a SP_ALTPLATFORM_INFO_V2 structure that contains information about the alternate platform
///                      to use when validating the INF file. This parameter can be Null.
///    InfSignerInfo = A pointer to an SP_INF_SIGNER_INFO structure that receives information about the INF digital signature, that is,
///                    if it is signed.
///Returns:
///    This function returns WINSETUPAPI BOOL.
///    
@DllImport("SETUPAPI")
BOOL SetupVerifyInfFileW(const(wchar)* InfName, SP_ALTPLATFORM_INFO_V2* AltPlatformInfo, 
                         SP_INF_SIGNER_INFO_V2_W* InfSignerInfo);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupConfigureWmiFromInfSection</b> function configures the security of the
///WMI data that is exposed by an INF file when passed to the [DDInstall.WMI] section. It is used to establish security
///when the version of SetupAPI on the system does not natively support the WMI security information provided in the
///DDInstall section of the INF file.
///Params:
///    InfHandle = A handle to an open INF file.
///    SectionName = Name of the section in the INF file that contains WMI security information. This should be in the form
///                  of[DDinstall.WMI].
///    Flags = This parameter can be set as follows. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="SCWMI_CLOBBER_SECURITY"></a><a id="scwmi_clobber_security"></a><dl> <dt><b>SCWMI_CLOBBER_SECURITY</b></dt>
///            <dt>0x0001</dt> </dl> </td> <td width="60%"> If and only if this flag is set does the security information passed
///            to this function override any security information set elsewhere in the INF file. If this flag does not exist and
///            no security information exists in the INF file, the security is set. </td> </tr> </table>
///Returns:
///    This function returns WINSETUPAPI BOOL.
///    
@DllImport("SETUPAPI")
BOOL SetupConfigureWmiFromInfSectionA(void* InfHandle, const(char)* SectionName, uint Flags);

///<p class="CCE_Message">[This function is available for use in the operating systems indicated in the Requirements
///section. It may be altered or unavailable in subsequent versions. SetupAPI should no longer be used for installing
///applications. Instead, use the Windows Installer for developing application installers. SetupAPI continues to be used
///for installing device drivers.] The <b>SetupConfigureWmiFromInfSection</b> function configures the security of the
///WMI data that is exposed by an INF file when passed to the [DDInstall.WMI] section. It is used to establish security
///when the version of SetupAPI on the system does not natively support the WMI security information provided in the
///DDInstall section of the INF file.
///Params:
///    InfHandle = A handle to an open INF file.
///    SectionName = Name of the section in the INF file that contains WMI security information. This should be in the form
///                  of[DDinstall.WMI].
///    Flags = This parameter can be set as follows. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="SCWMI_CLOBBER_SECURITY"></a><a id="scwmi_clobber_security"></a><dl> <dt><b>SCWMI_CLOBBER_SECURITY</b></dt>
///            <dt>0x0001</dt> </dl> </td> <td width="60%"> If and only if this flag is set does the security information passed
///            to this function override any security information set elsewhere in the INF file. If this flag does not exist and
///            no security information exists in the INF file, the security is set. </td> </tr> </table>
///Returns:
///    This function returns WINSETUPAPI BOOL.
///    
@DllImport("SETUPAPI")
BOOL SetupConfigureWmiFromInfSectionW(void* InfHandle, const(wchar)* SectionName, uint Flags);


// Interfaces

@GUID("0ADDA830-2C26-11D2-AD65-00A0C9AF11A6")
struct MsmMerge;

///The <b>IValidate</b> interface enables authoring tools to validate a Windows Installer package against a set of
///Internal Consistency Evaluators.
interface IValidate : IUnknown
{
    ///The <b>OpenDatabase</b> method opens a Windows Installer installation package or merge module for validation.
    ///Params:
    ///    szDatabase = The fully qualified path to the installation package or merge module to be opened. The <i>szDatabase</i>
    ///                 parameter cannot be <b>NULL</b>.
    ///Returns:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The value of <i>szDatabase</i> is invalid. </td> </tr>
    ///    </table> This method can also return one or more of the errors returned by the MsiOpenDatabase function. The
    ///    error is converted to <b>HRESULTS</b> using the <b>HRESULT_FROM_WIN32</b> function.
    ///    
    HRESULT OpenDatabase(ushort* szDatabase);
    ///The <b>OpenCUB</b> method opens an Internal Consistency Evaluator (ICE) file that is to be used for validation.
    ///Params:
    ///    szCUBFile = The fully qualified path to the Internal Consistency Evaluator (ICE) file to be used for validation.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The value of
    ///    <i>szDatabase</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Failed to allocate memory. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The method failed. </td> </tr> </table>
    ///    
    HRESULT OpenCUB(ushort* szCUBFile);
    ///The <b>CloseDatabase</b> method closes the currently open Windows Installer package or merge module. Windows
    ///Installer packages or merge modules can be opened by using the OpenDatabase method.
    ///Returns:
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The method succeeded. </td> </tr> </table> This method can also return one or
    ///    more of the errors returned by the MsiCloseHandle function. The error is converted to <b>HRESULTS</b> using
    ///    the <b>HRESULT_FROM_WIN32</b> function.
    ///    
    HRESULT CloseDatabase();
    ///The <b>CloseCUB</b> method closes an open Internal Consistency Evaluator (ICE) .cub file. Internal Consistency
    ///Evaluator (ICE) .cub files can be opened using the OpenCUB method.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The method failed. </td>
    ///    </tr> </table>
    ///    
    HRESULT CloseCUB();
    ///The <b>SetDisplay</b> method enables an authoring tool to obtain ICE status messages through a callback function.
    ///Params:
    ///    pDisplayFunction = Specifies a callback function that conforms to the LPDISPLAYVAL specification.
    ///    pContext = A pointer to an application context that is passed to the callback function. This parameter can be used for
    ///               error checking. The <i>pContext</i> parameter can be <b>NULL</b>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDisplayFunction</i>
    ///    is invalid. </td> </tr> </table>
    ///    
    HRESULT SetDisplay(LPDISPLAYVAL pDisplayFunction, void* pContext);
    ///The <b>SetStatus</b> method enables an authoring tool to receive information about the progress of validation
    ///through a registered callback function.
    ///Params:
    ///    pStatusFunction = Specifies a callback function that conforms to the LPEVALCOMCALLBACK specification. The
    ///                      <i>pStatusFunction</i> can be <b>NULL</b>.
    ///    pContext = A pointer to an application context that is passed to the callback function. This parameter can be used for
    ///               error checking. The <i>pContext</i> can be <b>NULL</b>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetStatus(LPEVALCOMCALLBACK pStatusFunction, void* pContext);
    ///The <b>Validate</b> method performs validation of the installation package or merge module using the specified
    ///internal consistency evaluator file.
    ///Params:
    ///    wzICEs = Optional parameter that specifies which Internal Consistency Evaluators (ICE) should run. You can specify the
    ///             ICEs in a delimited list or in a custom table. When providing a delimited list of ICEs to be run, separate
    ///             the ICEs in the list by colons (:), for example, "ICE01:ICE03:ICE08". When providing the name of a custom
    ///             sequence table, the ICEs to be run can be entered in the custom table. If the value of <i>szICEs</i> is
    ///             <b>NULL</b>, all ICEs in the _ICESequence table are run. The _ICESequence table is the default table provided
    ///             with orca.msi and msival2.msi.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_PENDING</b></dt> </dl> </td> <td width="60%"> The method failed. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The method failed. </td>
    ///    </tr> </table>
    ///    
    HRESULT Validate(const(wchar)* wzICEs);
}

@GUID("0ADDA826-2C26-11D2-AD65-00A0C9AF11A6")
interface IEnumMsmString : IUnknown
{
    HRESULT Next(uint cFetch, BSTR* rgbstrStrings, uint* pcFetched);
    HRESULT Skip(uint cSkip);
    HRESULT Reset();
    HRESULT Clone(IEnumMsmString* pemsmStrings);
}

@GUID("0ADDA827-2C26-11D2-AD65-00A0C9AF11A6")
interface IMsmStrings : IDispatch
{
    HRESULT get_Item(int Item, BSTR* Return);
    HRESULT get_Count(int* Count);
    HRESULT get__NewEnum(IUnknown* NewEnum);
}

///The <b>IMsmError</b> interface retrieves details about a single merge error.
@GUID("0ADDA828-2C26-11D2-AD65-00A0C9AF11A6")
interface IMsmError : IDispatch
{
    ///The <b>get_Type</b> method retrieves the Type property of the Error object. This method returns a msmErrorType
    ///value indicating the type of error represented by this object.
    ///Params:
    ///    ErrorType = A pointer to a location in memory that receives the type of error. <table> <tr> <th>msmErrorType</th>
    ///                <th>Value</th> <th><b>Description</b></th> </tr> <tr> <td>msmErrorLanguageUnsupported</td> <td>1</td> <td>A
    ///                request was made to open a module with a language not supported by the module. No more general language is
    ///                supported by the module. Adds msmErrorLanguageUnsupported to the <b>Type</b> property and the requested
    ///                language to the Language Property (Error Object). All <b>Error</b> object properties are empty. The
    ///                OpenModule function returns ERROR_INSTALL_LANGUAGE_UNSUPPORTED (as HRESULT).</td> </tr> <tr>
    ///                <td>msmErrorLanguageFailed</td> <td>2</td> <td>A request was made to open a module with a supported language
    ///                but the module has an invalid language transform. Adds msmErrorLanguageFailed to the Type property and the
    ///                applied transform's language to the <b>Language</b> Property of the <b>Error</b> object. This may not be the
    ///                requested language if a more general language was used. All other properties of the <b>Error</b> object are
    ///                empty. The <b>OpenModule</b> function returns ERROR_INSTALL_LANGUAGE_UNSUPPORTED (as HRESULT).</td> </tr>
    ///                <tr> <td>msmErrorExclusion</td> <td>3</td> <td>The module cannot be merged because it excludes, or is
    ///                excluded by, another module in the database. Adds msmErrorExclusion to the <b>Type</b> property of the
    ///                <b>Error</b> object. The ModuleKeys property or DatabaseKeys property contains the primary keys of the
    ///                excluded module's row in the ModuleExclusion table. If an existing module excludes the module being merged,
    ///                the excluded module's ModuleSignature information is added to ModuleKeys. If the module being merged excludes
    ///                an existing module, DatabaseKeys contains the excluded module's ModuleSignature information. All other
    ///                properties are empty (or -1).</td> </tr> <tr> <td>msmErrorTableMerge</td> <td>4</td> <td>Merge conflict
    ///                during merge. The value of the <b>Type</b> property is set to msmErrorTableMerge. The DatabaseTable property
    ///                and DatabaseKeys property contain the table name and primary keys of the conflicting row in the database. The
    ///                ModuleTable property and ModuleKeys property contain the table name and primary keys of the conflicting row
    ///                in the module. The ModuleTable and ModuleKeys entries may be null if the row does not exist in the database.
    ///                For example, if the conflict is in a generated FeatureComponents table entry. When merging a configurable
    ///                merge module, configuration may cause these properties to refer to rows that do not exist in the module.</td>
    ///                </tr> <tr> <td>msmErrorResequenceMerge</td> <td>5</td> <td>There was a problem resequencing a sequence table
    ///                to contain the necessary merged actions. The <b>Type</b> property is set to msmErrorResequenceMerge. The
    ///                DatabaseTable and DatabaseKeys properties contain the sequence table name and primary keys (action name) of
    ///                the conflicting row. The ModuleTable and ModuleKeys properties contain the sequence table name and primary
    ///                key (action name) of the conflicting row. When merging a configurable merge module, configuration may cause
    ///                these properties to refer to rows that do not exist in the module.</td> </tr> <tr>
    ///                <td>msmErrorFileCreate</td> <td>6</td> <td>Not used.</td> </tr> <tr> <td>msmErrorDirCreate</td> <td>7</td>
    ///                <td>There was a problem creating a directory to extract a file to disk. The Path property contains the
    ///                directory that could not be created. All other properties are empty or -1. </td> </tr> <tr>
    ///                <td>msmErrorFeatureRequired</td> <td>8</td> <td>A feature name is required to complete the merge, but no
    ///                feature name was provided. The <b>Type</b> property is set to msmErrorFeatureRequired. The DatabaseTable and
    ///                DatabaseKeys contain the table name and primary keys of the conflicting row. The ModuleTable and ModuleKeys
    ///                properties contain the table name and primary keys of the row cannot be merged. When merging a configurable
    ///                merge module, configuration may cause these properties to refer to rows that do not exist in the module. If
    ///                the failure is in a generated FeatureComponents table, the DatabaseTable and DatabaseKeys properties are
    ///                empty and the ModuleTable and ModuleKeys properties refer to the row in the Component table causing the
    ///                failure.</td> </tr> <tr> <td>msmErrorBadNullSubstitution</td> <td>9</td> <td>Substitution of a Null value
    ///                into a non-nullable column. This enters msmErrorBadNullSubstitution in the <b>Type</b> property and enters
    ///                "ModuleSubstitution" and the keys from the ModuleSubstitution table for this row into the ModuleTable
    ///                property and ModuleKeys property. All other properties of the Error object are set to an empty string or -1.
    ///                This error causes the immediate failure of the merge and the <b>MergeEx</b> function to return E_FAIL. </td>
    ///                </tr> <tr> <td>msmErrorBadSubstitutionType</td> <td>10</td> <td>Substitution of Text Format Type or Integer
    ///                Format Type into a Binary Type data column. This type of error returns msmErrorBadSubstitutionType in the
    ///                <b>Type</b> property and enters "ModuleSubstitution" and the keys from the ModuleSubstitution table for this
    ///                row into the ModuleTable property. All other properties of the Error object are set to an empty string or -1.
    ///                This error causes the immediate failure of the merge and the <b>MergeEx</b> function to return E_FAIL. </td>
    ///                </tr> <tr> <td>msmErrorMissingConfigItem</td> <td>11</td> <td>A row in the ModuleSubstitution table
    ///                references a configuration item not defined in the ModuleConfiguration table. This type of error returns
    ///                msmErrorMissingConfigItem in the <b>Type</b> property and enters "ModuleSubstitution" and the keys from the
    ///                ModuleSubstitution table for this row into the ModuleTable property. All other properties of the
    ///                <b>Error</b>object are set to an empty string or -1. This error causes the immediate failure of the merge and
    ///                the <b>MergeEx</b> function to return E_FAIL. </td> </tr> <tr> <td>msmErrorBadNullResponse</td> <td>12</td>
    ///                <td>The authoring tool has returned a Null value for an item marked with the msmConfigItemNonNullable
    ///                attribute. An error of this type returns msmErrorBadNullResponse in the <b>Type</b> property and enters
    ///                "ModuleSubstitution" and the keys from the ModuleSubstitution table for for the item into the ModuleTable
    ///                property. All other properties of the Error object are set to an empty string or -1. This error causes the
    ///                immediate failure of the merge and the <b>MergeEx</b> function to return E_FAIL. </td> </tr> <tr>
    ///                <td>msmErrorDataRequestFailed</td> <td>13</td> <td>The authoring tool returned a failure code (not S_OK or
    ///                S_FALSE) when asked for data. An error of this type will return msmErrorDataRequestFailed in the <b>Type</b>
    ///                property and enters "ModuleSubstitution" and the keys from the ModuleSubstitution table for the item into the
    ///                ModuleTable property. All other properties of the Error object are set to an empty string or -1. This error
    ///                causes the immediate failure of the merge and the <b>MergeEx</b> function to return E_FAIL. </td> </tr> <tr>
    ///                <td>msmErrorPlatformMismatch</td> <td>14</td> <td>Indicates that an attempt was made to merge a 64-bit module
    ///                into a package that was not a 64-bit package. An error of this type returns msmErrorPlatformMismatch in the
    ///                <b>Type</b> property. All other properties of the error object are set to an empty string or -1. This error
    ///                causes the immediate failure of the merge and causes the Merge function or MergeEx function to return
    ///                E_FAIL.</td> </tr> </table>
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> ErrorType is Null. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td>
    ///    </tr> </table>
    ///    
    HRESULT get_Type(msmErrorType* ErrorType);
    ///The <b>get_Path</b> method retrieves the Path property of the Error object.
    ///Params:
    ///    ErrorPath = A pointer to a location in memory that is filled in with a <b>BSTR</b> value.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Path is null. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The system was unable to
    ///    allocate memory for the string. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The function succeeded. </td> </tr> </table>
    ///    
    HRESULT get_Path(BSTR* ErrorPath);
    ///The <b>get_Language</b> method retrieves the Language property of the Error object. This function returns the
    ///<b>LANGID</b> of the error.
    ///Params:
    ///    ErrorLanguage = A pointer to a location in memory that receives the language value causing this error.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Language is null. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td>
    ///    </tr> </table>
    ///    
    HRESULT get_Language(short* ErrorLanguage);
    ///The <b>get_DatabaseTable</b> method retrieves the DatabaseTable property of the Error object. The method returns
    ///the name of the table in the database that caused the error.
    ///Params:
    ///    ErrorTable = A pointer to a location in memory that is filled in with a <b>BSTR</b> value.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Table is null. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The system was unable to
    ///    allocate memory for the string. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The function succeeded. </td> </tr> </table>
    ///    
    HRESULT get_DatabaseTable(BSTR* ErrorTable);
    ///The <b>get_DatabaseKeys</b> method retrieves the DatabaseKeys property of the Error object. This method returns a
    ///pointer to a string collection containing the primary keys of the row in the database causing the error, one key
    ///per entry in the collection.
    ///Params:
    ///    ErrorKeys = A pointer to a location in memory that receives a pointer to a string collection.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> ErrorKeys is null. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td>
    ///    </tr> </table>
    ///    
    HRESULT get_DatabaseKeys(IMsmStrings* ErrorKeys);
    ///The <b>get_ModuleTable</b> method retrieves the ModuleTable property of the Error object. This method returns the
    ///name of the table in the module that caused the error.
    ///Params:
    ///    ErrorTable = A pointer to a location in memory that is filled in with a <b>BSTR</b> value.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Table is null. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The system was unable to
    ///    allocate memory for the string. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The function succeeded. </td> </tr> </table>
    ///    
    HRESULT get_ModuleTable(BSTR* ErrorTable);
    ///The <b>get_ModuleKeys</b> method retrieves the ModuleKeys property of the Error object. This method returns a
    ///pointer to a string collection that contains the primary keys of the row in the module causing the error, one key
    ///per entry in the collection.
    ///Params:
    ///    ErrorKeys = A pointer to a location in memory that receives a pointer to a string collection.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> ErrorKeys is null. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td>
    ///    </tr> </table>
    ///    
    HRESULT get_ModuleKeys(IMsmStrings* ErrorKeys);
}

@GUID("0ADDA829-2C26-11D2-AD65-00A0C9AF11A6")
interface IEnumMsmError : IUnknown
{
    HRESULT Next(uint cFetch, IMsmError* rgmsmErrors, uint* pcFetched);
    HRESULT Skip(uint cSkip);
    HRESULT Reset();
    HRESULT Clone(IEnumMsmError* pemsmErrors);
}

@GUID("0ADDA82A-2C26-11D2-AD65-00A0C9AF11A6")
interface IMsmErrors : IDispatch
{
    HRESULT get_Item(int Item, IMsmError* Return);
    HRESULT get_Count(int* Count);
    HRESULT get__NewEnum(IUnknown* NewEnum);
}

///The <b>IMsmDependency</b> interface retrieves details for a single module dependency.
@GUID("0ADDA82B-2C26-11D2-AD65-00A0C9AF11A6")
interface IMsmDependency : IDispatch
{
    ///The <b>get_Module</b> method retrieves the Module property of the Dependency object. This method returns the
    ///ModuleID of the module required by the current string in the form of a <b>BSTR</b>. The ModuleID is of the same
    ///form as used in the ModuleSignature table.
    ///Params:
    ///    Module = A pointer to a location in memory that is filled in with a <b>BSTR</b> value.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Module is null </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded </td> </tr>
    ///    </table>
    ///    
    HRESULT get_Module(BSTR* Module);
    ///The <b>get_Language</b> method retrieves the Language property of the Dependency object. This method returns the
    ///<b>LANGID</b> of the required module.
    ///Params:
    ///    Language = A pointer to a location in memory that receives the language.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Language is null. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td>
    ///    </tr> </table>
    ///    
    HRESULT get_Language(short* Language);
    ///The <b>get_Version</b> method retrieves the Version property of the Dependency object. This method returns the
    ///version of the required module in the form of a <b>BSTR</b>.
    ///Params:
    ///    Version = A pointer to a location in memory that is filled in with a <b>BSTR</b> value.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Version is null. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_Version(BSTR* Version);
}

@GUID("0ADDA82C-2C26-11D2-AD65-00A0C9AF11A6")
interface IEnumMsmDependency : IUnknown
{
    HRESULT Next(uint cFetch, IMsmDependency* rgmsmDependencies, uint* pcFetched);
    HRESULT Skip(uint cSkip);
    HRESULT Reset();
    HRESULT Clone(IEnumMsmDependency* pemsmDependencies);
}

@GUID("0ADDA82D-2C26-11D2-AD65-00A0C9AF11A6")
interface IMsmDependencies : IDispatch
{
    HRESULT get_Item(int Item, IMsmDependency* Return);
    HRESULT get_Count(int* Count);
    HRESULT get__NewEnum(IUnknown* NewEnum);
}

///The <b>IMsmMerge</b> interface and the IMsmMerge2 interface provide interfaces to the Merge object. The Merge object
///provides access to other top-level objects. A <b>Merge</b> object must be created before loading the automation
///support required by COM to access the functions in Mergemod.dll.
@GUID("0ADDA82E-2C26-11D2-AD65-00A0C9AF11A6")
interface IMsmMerge : IDispatch
{
    ///The <b>OpenDatabase</b> method opens a Windows Installer installation database, located at a specified path, that
    ///is to be merged with a module. For more information, see the OpenDatabase method of the Merge object.
    ///<b>IMsmMerge2::OpenDatabase</b> Mergemod.dll version 2.0 and later.<div> </div><b>IMsmMerge::OpenDatabase</b> All
    ///Mergemod.dll versions.
    ///Params:
    ///    Path = Path to the database being opened.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> There was an error opening the
    ///    database. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    function succeeded. </td> </tr> </table>
    ///    
    HRESULT OpenDatabase(const(ushort)* Path);
    ///The <b>OpenModule</b> method opens a Windows Installer merge module in read-only mode. A module must be opened
    ///before it can be merged with an installation database. For more information, see the OpenModule method of the
    ///Merge object. <b>IMsmMerge2::OpenModule</b> Mergemod.dll version 2.0 and later.<div>
    ///</div><b>IMsmMerge::OpenModule</b> All Mergemod.dll versions.
    ///Params:
    ///    Path = Fully qualified file name that points to a merge module. A <b>LPCWSTR</b> can be used in place of a
    ///           <b>BSTR</b>.
    ///    Language = A language identifier (<b>LANGID</b>).
    ///Returns:
    ///    The <b>OpenModule</b> function returns the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_ABORT</b></dt> </dl> </td> <td width="60%"> The file specified is
    ///    an Windows Installer database, but is not a merge module (missing ModuleSignature table). </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>ERROR_INSTALL_LANGUAGE_UNSUPPORTED as HRESULT </b></dt> </dl> </td> <td
    ///    width="60%"> The language is not supported by the module. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_INSTALL_TRANSFORM_FAILURE as HRESULT</b></dt> </dl> </td> <td width="60%"> The language is
    ///    supported by the module, but there was an error applying the transform. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>ERROR_OPEN_FAILED as HRESULT </b></dt> </dl> </td> <td width="60%"> The file could not be opened
    ///    as an Windows Installer database. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_TOO_MANY_OPEN_FILES as
    ///    HRESULT </b></dt> </dl> </td> <td width="60%"> There is already a module open. Closes the current module
    ///    first. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT OpenModule(const(ushort)* Path, const(short) Language);
    ///The <b>CloseDatabase</b> method closes the currently open Windows Installer database. For more information, see
    ///the CloseDatabase method of the Merge object. <b>IMsmMerge2::CloseDatabase</b> Mergemod.dll version 2.0 or
    ///later.<div> </div><b>IMsmMerge::CloseDatabase</b> All Mergemod.dll versions.
    ///Params:
    ///    Commit = <b>TRUE</b> if changes should be saved, <b>FALSE</b> otherwise.
    ///Returns:
    ///    The <b>CloseDatabase</b> function returns the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> There was an error
    ///    closing the database. The state of the IMsmMerge or IMsmMerge2 interface is now in an undefined state. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No database was open.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function
    ///    succeeded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>STG_E_CANTSAVE as HRESULT</b></dt> </dl> </td> <td
    ///    width="60%"> Unable to save database. This error is not generated if <i>bCommit</i> is <b>FALSE</b>. </td>
    ///    </tr> </table>
    ///    
    HRESULT CloseDatabase(const(short) Commit);
    ///The <b>CloseModule</b> method closes the currently open Windows Installer merge module. For more information, see
    ///the CloseModule method of the Merge object. <b>IMsmMerge2::CloseDatabase</b> Mergemod.dll version 2.0 or
    ///later.<div> </div> IMsmMerge::CloseDatabase All Mergemod.dll versions.
    ///Returns:
    ///    The <b>CloseModule</b> function returns the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> There was an error
    ///    closing the module. The state of the IMsmMerge or IMsmMerge2 interface is now undefined. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No module was open. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT CloseModule();
    ///The <b>OpenLog</b> method opens a log file that receives progress and error messages. If the log file already
    ///exists, the installer appends new messages. If the log file does not exist, the installer creates a log file. For
    ///more information, see the OpenLog method of the Merge object. <b>IMsmMerge2::OpenLog</b> Mergemod.dll version 2.0
    ///or later.<div> </div><b>IMsmMerge::OpenLog</b> All Mergemod.dll versions.
    ///Params:
    ///    Path = Fully qualified file name pointing to a file to open or create. A <b>LPCWSTR</b> may be used in place of a
    ///           <b>BSTR</b>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>ERROR_TOO_MANY_OPEN_FILES as HRESULT </b></dt> </dl> </td> <td width="60%"> There is
    ///    already a log file open. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_OPEN_FAILED as HRESULT </b></dt>
    ///    </dl> </td> <td width="60%"> The file could not be opened or created. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
    ///    
    HRESULT OpenLog(const(ushort)* Path);
    ///The <b>CloseLog</b> function method closes the current log. For more information, see the CloseLog method of the
    ///Merge object. <b>IMsmMerge2::CloseLog</b> Mergemod.dll version 2.0 or later. <div>
    ///</div><b>IMsmMerge::CloseLog</b> All Mergemod.dll versions.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> There was an error closing the log
    ///    file. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No log file
    ///    was open. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///    function succeeded. </td> </tr> </table>
    ///    
    HRESULT CloseLog();
    ///The <b>Log</b> method writes a text string to the currently open log file. For more information, see the Log
    ///method of the Merge object. <b>IMsmMerge2::Log</b> Mergemod.dll version 2.0 or later. <div>
    ///</div><b>IMsmMerge::Log</b> All Mergemod.dll versions.
    ///Params:
    ///    Message = The text string to display. A <b>LPCWSTR</b> may be used instead of a <b>BSTR</b>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> There was an error writing to the log
    ///    file. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The
    ///    argument is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> No log file is open. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The function succeeded. </td> </tr> </table>
    ///    
    HRESULT Log(const(ushort)* Message);
    ///The <b>get_Errors</b> method retrieves the Errors property of the Merge object. This retrieves the current
    ///collection of errors. <b>IMsmMerge2::get_Errors</b> Mergemod.dll version 2.0 or later.<div>
    ///</div><b>IMsmMerge::get_Errors</b> All Mergemod.dll versions.
    ///Params:
    ///    Errors = Pointer to a memory location containing another pointer to an <b>IMsmErrors</b> interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>Errors</i> pointer is
    ///    <b>NULL</b> </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    The system is out of memory. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The function succeeded. </td> </tr> </table>
    ///    
    HRESULT get_Errors(IMsmErrors* Errors);
    ///The <b>get_Dependencies</b> method retrieves the Dependencies property of the Merge object.
    ///<b>IMsmMerge2::get_Dependencies</b> Mergemod.dll version 2.0 or later.<div>
    ///</div><b>IMsmMerge::get_Dependencies</b> All Mergemod.dll versions.
    ///Params:
    ///    Dependencies = Pointer to a memory location to be filled with a pointer to a collection of unsatisfied dependencies for the
    ///                   current database. If there is an error, the memory location pointed to by <i>Dependencies</i> is set to null.
    ///Returns:
    ///    The <b>get_Dependencies</b> function returns the following values. <table> <tr> <th>Value</th>
    ///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> There
    ///    was no database open. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>Dependencies</i> pointer is null. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The system ran out of memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unable to verify dependencies due
    ///    to internal error. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///    The function succeeded. </td> </tr> </table>
    ///    
    HRESULT get_Dependencies(IMsmDependencies* Dependencies);
    ///The <b>Merge</b> method executes a merge of the current database and current module. The merge attaches the
    ///components in the module to the feature identified by <i>Feature</i>. The root of the module's directory tree is
    ///redirected to the location given by <i>RedirectDir</i>. For more information, see the <b>Merge</b> method of the
    ///Merge object. <b>IMsmMerge2::Merge</b> Mergemod.dll version 2.0 or later. <div> </div><b>IMsmMerge::Merge</b> All
    ///Mergemod.dll versions.
    ///Params:
    ///    Feature = The name of a feature in the database. A <b>LPCWSTR</b> can be used in place of a <b>BSTR</b>.
    ///    RedirectDir = The key of an entry in the Directory table of the database. A <b>LPCWSTR</b> can be used in place of a
    ///                  <b>BSTR</b>. This parameter can be null or an empty string.
    ///Returns:
    ///    The <b>Merge</b> function returns the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The merge failed
    ///    catastrophically. This indicates an operational error, and is not the normal error return for a failed merge.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The function
    ///    succeeded, but there were errors and the merge itself may not be valid. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the arguments is invalid. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY </b></dt> </dl> </td> <td width="60%"> The system ran out of
    ///    memory and could not complete the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
    ///    
    HRESULT Merge(const(ushort)* Feature, const(ushort)* RedirectDir);
    ///The <b>Connect</b> method connects a module that has been, or will be, merged into the database to an additional
    ///feature. For more information, see the Connect method of the Merge object. <b>IMsmMerge2::Connect</b>
    ///Mergemod.dll version 2.0 or later.<div> </div><b>IMsmMerge::Connect</b> All Mergemod.dll versions.
    ///Params:
    ///    Feature = The name of a feature in the database. A <b>LPCWSTR</b> may be used in place of a <b>BSTR</b>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the arguments is invalid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The connect
    ///    failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function
    ///    succeeded. </td> </tr> </table>
    ///    
    HRESULT Connect(const(ushort)* Feature);
    ///The <b>ExtractCAB</b> method extracts the embedded .cab file from a module and saves it as the specified file.
    ///The installer creates this file if it does not already exist and overwrites the file if it does exist. For more
    ///information, see the ExtractCAB method of the Merge object. <b>IMsmMerge2::ExtractCAB</b> Mergemod.dll version
    ///2.0 or later.<div> </div><b>IMsmMerge::ExtractCAB</b> All Mergemod.dll versions.
    ///Params:
    ///    FileName = The fully qualified destination file. A <b>LPCWSTR</b> may be used in place of a <b>BSTR</b>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the arguments is invalid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_OPEN_FAILED as HRESULT</b></dt> </dl> </td> <td
    ///    width="60%"> Could not create the output file. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_WRITE_FAULT as HRESULT</b></dt> </dl> </td> <td width="60%"> Could not write data to the output
    ///    file. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unable to
    ///    access embedded .cab file. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> No embedded .cab file was found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The function succeeded. </td> </tr> </table>
    ///    
    HRESULT ExtractCAB(const(ushort)* FileName);
    ///The <b>ExtractFiles</b> method extracts the embedded .cab file from a module and then writes those files to the
    ///destination directory. For more information, see the [ExtractFiles]() method of the Merge object.
    ///<b>IMsmMerge2::ExtractFiles</b> Mergemod.dll version 2.0 or later.<div> </div><b>IMsmMerge::ExtractFiles</b> All
    ///Mergemod.dll versions.
    ///Params:
    ///    Path = The fully qualified destination directory. A <b>LPCWSTR</b> may be used in place of a <b>BSTR</b>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>ERROR_CANNOT_MAKE as HRESULT</b></dt> </dl> </td> <td width="60%"> Could not create
    ///    the output path. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_OPEN_FAILED as HRESULT</b></dt> </dl>
    ///    </td> <td width="60%"> Could not create the output file. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>ERROR_WRITE_FAULT as HRESULT</b></dt> </dl> </td> <td width="60%"> Could not write data to the output
    ///    file. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unable to
    ///    access embedded .cab file, or create temporary file. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No embedded .cab file was found. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT ExtractFiles(const(ushort)* Path);
}

///The <b>IMsmGetFiles</b> interface enables the client to retrieve the files needed in a particular language of the
///module.
@GUID("7041AE26-2D78-11D2-888A-00A0C981B015")
interface IMsmGetFiles : IDispatch
{
    ///The <b>get_ModuleFiles</b> method retrieves the ModuleFiles property of the GetFiles object. This method returns
    ///the primary keys in the File table of the currently open module. The primary keys are returned as a collection of
    ///strings. The module must be opened by a call to the OpenModule function before calling <b>get_ModuleFiles</b>.
    ///Params:
    ///    Files = Collection of IMsmStrings that are the primary keys of the File table for the currently open module.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Invalid argument. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The function succeeded. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> No module is open. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Out of memory.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FUNCTION_FAILED as HRESULT</b></dt> </dl> </td> <td
    ///    width="60%"> The function failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_HANDLE as
    ///    HRESULT</b></dt> </dl> </td> <td width="60%"> The function failed. </td> </tr> </table>
    ///    
    HRESULT get_ModuleFiles(IMsmStrings* Files);
}

///The <b>IAssemblyName</b> interface represents a side-by-side assembly name. The side-by-side assembly name consists
///of a set of name-value pairs that describe the side-by-side assembly. An instance of the <b>IAssemblyName</b>
///interface is obtained by calling the CreateAssemblyNameObject function.
@GUID("CD193BC0-B4BC-11D2-9833-00C04FC31D2E")
interface IAssemblyName : IUnknown
{
    ///The <b>SetProperty</b> method adds a name-value pair to the side-by-side assembly name. This method can change or
    ///delete the value of an existing name-value pair.
    ///Params:
    ///    PropertyId = A property ID that represents the name-value pair. Valid property IDs are ASM_NAME enumeration values.
    ///    pvProperty = A pointer to a buffer that contains the value of the name-value pair.
    ///    cbProperty = The size in bytes of the buffer specified by <i>pvProperty</i>. Set the value of this parameter to zero to
    ///                 remove the name-value pair from the assembly name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td width="60%"> The method did not succeed. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>E_UNEXPECTED</dt> </dl> </td> <td width="60%"> The method did not succeed. The
    ///    SetProperty method was called after the Finalize method. </td> </tr> </table>
    ///    
    HRESULT SetProperty(uint PropertyId, void* pvProperty, uint cbProperty);
    ///The <b>GetProperty</b> method gets the value of a name-value pair in the assembly name.
    ///Params:
    ///    PropertyId = A property ID that represents the name-value pair. Valid property IDs are ASM_NAME enumeration values.
    ///    pvProperty = A pointer to a buffer that receives the value of the name-value pair.
    ///    pcbProperty = The size in bytes of the buffer specified by <i>pvProperty</i>. The value is zero if this property is not
    ///                  set.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td width="60%"> The method did not succeed. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetProperty(uint PropertyId, void* pvProperty, uint* pcbProperty);
    ///The <b>Finalize</b> method prevents a side-by-side assembly name from being changed. After <b>Finalize</b> is
    ///called, additional calls to the SetProperty returns <b>E_UNEXPECTED</b>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td width="60%"> The method did not succeed. </td> </tr>
    ///    </table>
    ///    
    HRESULT Finalize();
    ///The <b>GetDisplayName</b> method gets a string representation of the side-by-side assembly name.
    ///Params:
    ///    szDisplayName = A pointer to a buffer that receives the string value that contains the assembly name.
    ///    pccDisplayName = When calling this method, set this parameter to the size of the buffer specified by <b>szDisplayName</b>.
    ///                     Specify the size in characters and include the null terminator. When the method returns, the value of
    ///                     <i>pccDisplayName</i> is the size of the name returned.
    ///    dwDisplayFlags = One or more of the options of the ASM_DISPLAY_FLAGS enumeration to specify which portions of the assembly's
    ///                     name to include in the string representation of the assembly name. The default for <i>dwDisplayFlags</i> is
    ///                     0, which returns all portions of the assembly's display name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td width="60%"> The method did not succeed. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetDisplayName(const(wchar)* szDisplayName, uint* pccDisplayName, uint dwDisplayFlags);
    HRESULT Reserved(const(GUID)* refIID, IUnknown pUnkReserved1, IUnknown pUnkReserved2, ushort* szReserved, 
                     long llReserved, void* pvReserved, uint cbReserved, void** ppReserved);
    ///The <b>GetName</b> method returns the name portion of the assembly name.
    ///Params:
    ///    lpcwBuffer = When calling this method, set this parameter to the size of the buffer specified by <i>pwzName</i>. The
    ///                 specify the size in characters and include the null terminator. When the method returns, the value of
    ///                 <i>lpcwBuffer</i> is the size of the name returned.
    ///    pwzName = Pointer to the string value that receives the name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td width="60%"> The method did not succeed. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetName(uint* lpcwBuffer, const(wchar)* pwzName);
    HRESULT GetVersion(uint* pdwVersionHi, uint* pdwVersionLow);
    ///The <b>IsEqual</b> method compares the current assembly name to another assembly name.
    ///Params:
    ///    pName = A pointer to another IAssemblyName instance, which is to be compared to the current assembly.
    ///    dwCmpFlags = Indicates which portion of the assembly names are to be compared. The value can be one of the options of the
    ///                 ASM_CMP_FLAGS enumeration.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> The specified portions of the names
    ///    match. </td> </tr> <tr> <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td width="60%"> The specified
    ///    portions of the names do not match. </td> </tr> </table>
    ///    
    HRESULT IsEqual(IAssemblyName pName, uint dwCmpFlags);
    ///The <b>Clone</b> method copies the current side-by-side assembly name to a new instance of IAssemblyName.
    ///Params:
    ///    pName = Pointer to the location that contains the pointer to the new instance of IAssemblyName.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td width="60%"> The method did not succeed. </td> </tr>
    ///    </table>
    ///    
    HRESULT Clone(IAssemblyName* pName);
}

///The <b>IAssemblyCacheItem</b> interface can be used to install side-by-side assemblies into the side-by-side store
///using a stream-based installation.
@GUID("9E3AAEB4-D1CD-11D2-BAB9-00C04F8ECEAE")
interface IAssemblyCacheItem : IUnknown
{
    ///The <b>CreateStream</b> method copies the source of a manifest or module into a stream.
    ///Params:
    ///    dwFlags = Reserved.
    ///    pszStreamName = Pointer to a string value containing the name of the manifest. This becomes the name of the stream.
    ///    dwFormat = This parameter specifies whether a module or manifest is being copied to a stream. <table> <tr>
    ///               <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="STREAM_FORMAT_COMPLIB_MODULE"></a><a
    ///               id="stream_format_complib_module"></a><dl> <dt><b>STREAM_FORMAT_COMPLIB_MODULE</b></dt> </dl> </td> <td
    ///               width="60%"> Copy the source of a module for a non-Windows assembly to a stream. </td> </tr> <tr> <td
    ///               width="40%"><a id="STREAM_FORMAT_COMPLIB_MANIFEST"></a><a id="stream_format_complib_manifest"></a><dl>
    ///               <dt><b>STREAM_FORMAT_COMPLIB_MANIFEST</b></dt> </dl> </td> <td width="60%"> Copy the source of a manifest for
    ///               a non-Windows assembly to a stream. </td> </tr> <tr> <td width="40%"><a
    ///               id="STREAM_FORMAT_WIN32_MODULE"></a><a id="stream_format_win32_module"></a><dl>
    ///               <dt><b>STREAM_FORMAT_WIN32_MODULE</b></dt> </dl> </td> <td width="60%"> Copy the source of a module for a
    ///               Windows assembly to a stream. </td> </tr> <tr> <td width="40%"><a id="STREAM_FORMAT_WIN32_MANIFEST"></a><a
    ///               id="stream_format_win32_manifest"></a><dl> <dt><b>STREAM_FORMAT_WIN32_MANIFEST</b></dt> </dl> </td> <td
    ///               width="60%"> Copy the source of a manifest for a Windows assembly to a stream. </td> </tr> </table>
    ///    dwFormatFlags = Reserved.
    ///    ppIStream = Pointer to the location that contains the pointer to the IStream interface that receives the information.
    ///    puliMaxSize = Reserved.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td width="60%"> The method did not succeed. </td> </tr>
    ///    </table>
    ///    
    HRESULT CreateStream(uint dwFlags, const(wchar)* pszStreamName, uint dwFormat, uint dwFormatFlags, 
                         IStream* ppIStream, ULARGE_INTEGER* puliMaxSize);
    ///The <b>Commit</b> method copies information into the side-by-side store. When this method returns, the assembly
    ///is visible in the side-by-side store.
    ///Params:
    ///    dwFlags = This parameter specifies how existing information in the side-by-side store is to be replaced by information
    ///              for the assembly being installed. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///              id="IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH"></a><a id="iassemblycacheitem_commit_flag_refresh"></a><dl>
    ///              <dt><b>IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH</b></dt> </dl> </td> <td width="60%"> Replace existing
    ///              information in the side-by-side store with the information in the assembly being installed if the version in
    ///              the assembly is greater than or equal to the version of the existing information. This is the default option.
    ///              </td> </tr> <tr> <td width="40%"><a id="IASSEMBLYCACHEITEM_COMMIT_FLAG_FORCE_REFRESH"></a><a
    ///              id="iassemblycacheitem_commit_flag_force_refresh"></a><dl>
    ///              <dt><b>IASSEMBLYCACHEITEM_COMMIT_FLAG_FORCE_REFRESH</b></dt> </dl> </td> <td width="60%"> Replace existing
    ///              information in the side-by-side store with the information for the assembly being installed. </td> </tr>
    ///              </table>
    ///    pulDisposition = <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///                     id="IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED"></a><a
    ///                     id="iassemblycacheitem_commit_disposition_installed"></a><dl>
    ///                     <dt><b>IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED</b></dt> </dl> </td> <td width="60%"> The assembly is
    ///                     installed for the first time. </td> </tr> <tr> <td width="40%"><a
    ///                     id="IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED"></a><a
    ///                     id="iassemblycacheitem_commit_disposition_refreshed"></a><dl>
    ///                     <dt><b>IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED</b></dt> </dl> </td> <td width="60%"> The assembly
    ///                     replaces an existing assembly. </td> </tr> <tr> <td width="40%"><a
    ///                     id="IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED"></a><a
    ///                     id="iassemblycacheitem_commit_disposition_already_installed"></a><dl>
    ///                     <dt><b>IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED</b></dt> </dl> </td> <td width="60%"> The
    ///                     assembly is already installed in the side-by-side assembly store. </td> </tr> </table>
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td width="60%"> The method did not succeed. </td> </tr>
    ///    </table>
    ///    
    HRESULT Commit(uint dwFlags, uint* pulDisposition);
    HRESULT AbortItem();
}

///The <b>IAssemblyCache</b> interface can be used to install, uninstall, or query a side-by-side assembly. An instance
///of <b>IAssemblyCache</b> is obtained by calling the CreateAssemblyCache function.
@GUID("E707DCDE-D1CD-11D2-BAB9-00C04F8ECEAE")
interface IAssemblyCache : IUnknown
{
    ///The <b>UnistallAssembly</b> method removes an application reference to an assembly from the side-by-side store.
    ///If there are no other references to the assembly by other applications, the assembly becomes unusable. Windows
    ///may remove the assembly's files from the side-by-side store and reclaim disk space at a later time.
    ///Params:
    ///    dwFlags = This parameter must be 0.
    ///    pszAssemblyName = A pointer to a null-terminated string value that contains the fully-specified strong name of the assembly. If
    ///                      the full name is not provided, the result is undefined.
    ///    pRefData = A pointer to a FUSION_INSTALL_REFERENCE structure that describes the application that holds the reference to
    ///               the assembly being removed. If this value is null, no references to the assembly by applications are left in
    ///               the side-by-side store and the assembly's files are removed. <div class="alert"><b>Note</b> The characters \,
    ///               /, :, ;, *, &lt;, &gt;, and | are invalid in the reference ID.</div> <div> </div>
    ///    pulDisposition = A pointer to an integer value that describes the action performed. The <i>pulDisposition</i> parameter can
    ///                     contain one of the following values or null. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///                     width="40%"><a id="IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED"></a><a
    ///                     id="iassemblycache_uninstall_disposition_uninstalled"></a><dl>
    ///                     <dt><b>IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED</b></dt> </dl> </td> <td width="60%"> The assembly
    ///                     files have been removed from the side-by-side store. </td> </tr> <tr> <td width="40%"><a
    ///                     id="IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE"></a><a
    ///                     id="iassemblycache_uninstall_disposition_still_in_use"></a><dl>
    ///                     <dt><b>IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE</b></dt> </dl> </td> <td width="60%"> The assembly's
    ///                     files have not been removed because an application is using the assembly. </td> </tr> <tr> <td width="40%"><a
    ///                     id="IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED"></a><a
    ///                     id="iassemblycache_uninstall_disposition_already_uninstalled"></a><dl>
    ///                     <dt><b>IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED</b></dt> </dl> </td> <td width="60%"> The
    ///                     assembly does not exist in the side-by-side store. </td> </tr> <tr> <td width="40%"><a
    ///                     id="IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING"></a><a
    ///                     id="iassemblycache_uninstall_disposition_delete_pending"></a><dl>
    ///                     <dt><b>IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING</b></dt> </dl> </td> <td width="60%"> Reserved.
    ///                     </td> </tr> <tr> <td width="40%"><a id="IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES"></a><a
    ///                     id="iassemblycache_uninstall_disposition_has_install_references"></a><dl>
    ///                     <dt><b>IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES</b></dt> </dl> </td> <td width="60%"> The
    ///                     assembly's files have not been removed because the side-by-side store contains a reference to the assembly by
    ///                     another application. </td> </tr> <tr> <td width="40%"><a
    ///                     id="IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND"></a><a
    ///                     id="iassemblycache_uninstall_disposition_reference_not_found"></a><dl>
    ///                     <dt><b>IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The
    ///                     reference specified in <i>pRefData</i> does not exist in the side-by-side store. </td> </tr> </table>
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> The files of the assembly have been
    ///    removed from the side-by-side store. </td> </tr> <tr> <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td
    ///    width="60%"> The operation succeeded and the reference to the assembly was removed. The assembly files were
    ///    not removed from the side-by-side store for the reason described by the value returned by
    ///    <i>pulDisposition</i>. </td> </tr> </table>
    ///    
    HRESULT UninstallAssembly(uint dwFlags, const(wchar)* pszAssemblyName, FUSION_INSTALL_REFERENCE* pRefData, 
                              uint* pulDisposition);
    ///The <b>QueryAssemblyInfo</b> method queries the side-by-side assembly store for assembly information and
    ///validates the files in the side-by-side assembly store against the assembly manifest.
    ///Params:
    ///    dwFlags = Specifies the information to retrieve. This parameter can be one or more of the following values or 0.
    ///              <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///              id="QUERYASMINFO_FLAG_VALIDATE"></a><a id="queryasminfo_flag_validate"></a><dl>
    ///              <dt><b>QUERYASMINFO_FLAG_VALIDATE</b></dt> </dl> </td> <td width="60%"> Validates the assembly files in the
    ///              side-by-side assembly store against the assembly manifest. This includes the verification of the assembly's
    ///              hash and strong name signature. </td> </tr> <tr> <td width="40%"><a id="QUERYASMINFO_FLAG_GETSIZE"></a><a
    ///              id="queryasminfo_flag_getsize"></a><dl> <dt><b>QUERYASMINFO_FLAG_GETSIZE</b></dt> </dl> </td> <td
    ///              width="60%"> Returns the size of all files in the assembly. </td> </tr> </table>
    ///    pszAssemblyName = Pointer to null-terminated string value containing the fully-specified strong name of the assembly to query.
    ///                      If the name is not fully specified, the result of the method is undefined.
    ///    pAsmInfo = Pointer to the ASSEMBLY_INFO structure that receives the information.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td width="60%"> The method did not succeed. </td> </tr>
    ///    </table>
    ///    
    HRESULT QueryAssemblyInfo(uint dwFlags, const(wchar)* pszAssemblyName, ASSEMBLY_INFO* pAsmInfo);
    ///The <b>CreateAssemblyCacheItem</b> method creates an item in the assembly cache that corresponds to the
    ///side-by-side assembly being installed.
    ///Params:
    ///    dwFlags = Reserved.
    ///    pvReserved = Reserved.
    ///    ppAsmItem = Pointer to a location containing the pointer to the instance of the IAssemblyCacheItem that receives the
    ///                information.
    ///    pszAssemblyName = Pointer to a null-terminated string value containing the fully-specified strong name of the assembly that is
    ///                      being installed. The name provided is verified to match the name of the assembly in the manifest. Partial
    ///                      names return <b>FUSION_E_INVALID_NAME</b>. If this parameter is null, the name is not verified.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td width="60%"> The method did not succeed. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>FUSION_E_INVALID_NAME</dt> </dl> </td> <td width="60%"> The full name of the
    ///    assembly must be provided by <i>pszAssemblyName</i>. </td> </tr> </table>
    ///    
    HRESULT CreateAssemblyCacheItem(uint dwFlags, void* pvReserved, IAssemblyCacheItem* ppAsmItem, 
                                    const(wchar)* pszAssemblyName);
    HRESULT Reserved(IUnknown* ppUnk);
    ///The <b>InstallAssembly</b> method adds an application reference to an assembly to the side-by-side store and
    ///copies the files of the assembly to the side-by-side store. The files of the assembly being installed must be
    ///present in the current file system.
    ///Params:
    ///    dwFlags = This parameter specifies how existing files in the side-by-side store are to replaced by files in the
    ///              assembly being installed. One of the following options can be specified. <table> <tr> <th>Value</th>
    ///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="IASSEMBLYCACHE_INSTALL_FLAG_REFRESH"></a><a
    ///              id="iassemblycache_install_flag_refresh"></a><dl> <dt><b>IASSEMBLYCACHE_INSTALL_FLAG_REFRESH</b></dt> </dl>
    ///              </td> <td width="60%"> Replace existing files in the side-by-side store with the files in the assembly being
    ///              installed if the version of the file in the assembly is greater than or equal to the version of the existing
    ///              file. </td> </tr> <tr> <td width="40%"><a id="IASSEMBLYCACHE_INSTALL_FLAG_FORCE_REFRESH"></a><a
    ///              id="iassemblycache_install_flag_force_refresh"></a><dl>
    ///              <dt><b>IASSEMBLYCACHE_INSTALL_FLAG_FORCE_REFRESH</b></dt> </dl> </td> <td width="60%"> Replace existing files
    ///              in the side-by-side store with the files in the assembly being installed. </td> </tr> </table>
    ///    pszManifestFilePath = A pointer to a string value that contains the full path to the dynamic-linked library (DLL) or executable
    ///                          (EXE) file that contains the assembly manifest. Any other assembly files must be located in the same
    ///                          directory as this DLL or EXE.
    ///    pRefData = A pointer to a FUSION_INSTALL_REFERENCE structure that describes the application that holds the reference to
    ///               the assembly being installed. If this parameter is null, the assembly files are copied, but no application
    ///               reference is added to the side-by-side store.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt>S_OK</dt> </dl> </td> <td width="60%"> The method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt>S_FALSE</dt> </dl> </td> <td width="60%"> The method did not succeed. </td> </tr>
    ///    </table>
    ///    
    HRESULT InstallAssembly(uint dwFlags, const(wchar)* pszManifestFilePath, FUSION_INSTALL_REFERENCE* pRefData);
}


// GUIDs

const GUID CLSID_MsmMerge = GUIDOF!MsmMerge;

const GUID IID_IAssemblyCache     = GUIDOF!IAssemblyCache;
const GUID IID_IAssemblyCacheItem = GUIDOF!IAssemblyCacheItem;
const GUID IID_IAssemblyName      = GUIDOF!IAssemblyName;
const GUID IID_IEnumMsmDependency = GUIDOF!IEnumMsmDependency;
const GUID IID_IEnumMsmError      = GUIDOF!IEnumMsmError;
const GUID IID_IEnumMsmString     = GUIDOF!IEnumMsmString;
const GUID IID_IMsmDependencies   = GUIDOF!IMsmDependencies;
const GUID IID_IMsmDependency     = GUIDOF!IMsmDependency;
const GUID IID_IMsmError          = GUIDOF!IMsmError;
const GUID IID_IMsmErrors         = GUIDOF!IMsmErrors;
const GUID IID_IMsmGetFiles       = GUIDOF!IMsmGetFiles;
const GUID IID_IMsmMerge          = GUIDOF!IMsmMerge;
const GUID IID_IMsmStrings        = GUIDOF!IMsmStrings;
