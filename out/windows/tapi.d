// Written in the D programming language.

module windows.tapi;

public import windows.core;
public import windows.automation : BSTR, IDispatch, VARIANT;
public import windows.com : HRESULT, IEnumUnknown, IUnknown;
public import windows.directshow : ALLOCATOR_PROPERTIES, AM_MEDIA_TYPE;
public import windows.systemservices : BOOL, CY, HANDLE, HINSTANCE;
public import windows.windowsandmessaging : HWND, WPARAM;
public import windows.windowsprogramming : SYSTEMTIME;

extern(Windows):


// Enums


///The <b>TAPI_TONEMODE</b> enum is used to describe the different selections that are used when generating line tones.
alias TAPI_TONEMODE = int;
enum : int
{
    ///The tone is a ringback tone. Exact definition is service-provider defined.
    TTM_RINGBACK = 0x00000002,
    ///The tone is a busy tone. Exact definition is service-provider defined.
    TTM_BUSY     = 0x00000004,
    ///The tone is a beep, such as that used to announce the beginning of a recording. Exact definition is
    ///service-provider defined.
    TTM_BEEP     = 0x00000008,
    ///The tone is a billing information tone, such as a credit card prompt tone. Exact definition is service-provider
    ///defined.
    TTM_BILLING  = 0x00000010,
}

///The <b>TAPI_GATHERTERM</b> enum is used to describe the reasons why the TAPI Server terminated the gathering of
///digits on the call.
alias TAPI_GATHERTERM = int;
enum : int
{
    ///The requested number of digits has been gathered. The buffer is full.
    TGT_BUFFERFULL   = 0x00000001,
    ///One of the termination digits matched a received digit. The matched termination digit is the last digit in the
    ///buffer.
    TGT_TERMDIGIT    = 0x00000002,
    ///The first digit timeout expired. The buffer contains no digits.
    TGT_FIRSTTIMEOUT = 0x00000004,
    ///The interdigit timeout expired. The buffer contains at least one digit.
    TGT_INTERTIMEOUT = 0x00000008,
    ///The request was canceled by this application, by another application, or because the call terminated.
    TGT_CANCEL       = 0x00000010,
}

///The <b>ADDRESS_EVENT</b> enum describes address events. The ITAddressEvent::get_Event method returns a member of this
///enum to indicate the type of address event that occurred.
alias ADDRESS_EVENT = int;
enum : int
{
    ///The address state has changed. See ITAddress::get_State.
    AE_STATE          = 0x00000000,
    ///Address capabilities have changed. See capability flags.
    AE_CAPSCHANGE     = 0x00000001,
    ///There is ringing on the address.
    AE_RINGING        = 0x00000002,
    ///The address configuration has changed.
    AE_CONFIGCHANGE   = 0x00000003,
    ///Forwarding has changed. See ITAddress::get_CurrentForwardInfo.
    AE_FORWARD        = 0x00000004,
    ///A new terminal has been added. The application should respond by selecting the terminal if it is going to be used
    ///on an active call.
    AE_NEWTERMINAL    = 0x00000005,
    ///A terminal has been removed. The application should respond by unselecting the terminal if it is currently
    ///selected to an active call.
    AE_REMOVETERMINAL = 0x00000006,
    ///The message waiting indicator has been turned on. This applies only to phone addresses.
    AE_MSGWAITON      = 0x00000007,
    ///The message waiting indicator has been turned off. This applies only to phone addresses.
    AE_MSGWAITOFF     = 0x00000008,
    ///Last item in this enum.
    AE_LASTITEM       = 0x00000008,
}

///The <b>ADDRESS_STATE</b> enum is used by the ITAddress::get_State method to check the address state.
alias ADDRESS_STATE = int;
enum : int
{
    ///Normal state; the address can be used.
    AS_INSERVICE    = 0x00000000,
    ///The address is temporarily out of service, but may go back into service at some time.
    AS_OUTOFSERVICE = 0x00000001,
}

///The <b>CALL_STATE</b> enum is used by the ITCallInfo::get_CallState and ITCallStateEvent::get_State methods.
alias CALL_STATE = int;
enum : int
{
    ///The call has been created, but Connect has not been called yet. A call can never transition into the idle state.
    ///This is the initial state for both incoming and outgoing calls.
    CS_IDLE         = 0x00000000,
    ///Connect has been called, and the service provider is working on making a connection. This state is valid only on
    ///outgoing calls. This message is optional, because a service provider may have a call transition directly to the
    ///connected state.
    CS_INPROGRESS   = 0x00000001,
    ///Call has been connected to the remote end and communication can take place.
    CS_CONNECTED    = 0x00000002,
    ///Call has been disconnected. There are several causes for disconnection. See the table of valid call state
    ///transitions below.
    CS_DISCONNECTED = 0x00000003,
    ///A new call has appeared, and is being offered to an application. If the application has owner privileges on the
    ///call, it can either call Answer or Disconnect while the call is in the offering state. Current call privilege can
    ///be determined by calling ITCallInfo::get_Privilege.
    CS_OFFERING     = 0x00000004,
    ///The call is in the hold state.
    CS_HOLD         = 0x00000005,
    ///The call is queued.
    CS_QUEUED       = 0x00000006,
    CS_LASTITEM     = 0x00000006,
}

///The <b>CALL_STATE_EVENT_CAUSE</b> enum is returned by the ITCallStateEvent::get_Cause method.
alias CALL_STATE_EVENT_CAUSE = int;
enum : int
{
    ///No call event has occurred.
    CEC_NONE                  = 0x00000000,
    ///The call was disconnected as part of the normal life cycle of the call (that is, the call was over, so it was
    ///disconnected).
    CEC_DISCONNECT_NORMAL     = 0x00000001,
    ///An outgoing call failed to connect because the remote end was busy.
    CEC_DISCONNECT_BUSY       = 0x00000002,
    ///An outgoing call failed because the destination address was bad.
    CEC_DISCONNECT_BADADDRESS = 0x00000003,
    ///An outgoing call failed because the remote end was not answered.
    CEC_DISCONNECT_NOANSWER   = 0x00000004,
    ///An outgoing call failed because the caller disconnected.
    CEC_DISCONNECT_CANCELLED  = 0x00000005,
    ///The outgoing call was rejected by the remote end.
    CEC_DISCONNECT_REJECTED   = 0x00000006,
    ///The call failed to connect for some other reason.
    CEC_DISCONNECT_FAILED     = 0x00000007,
    CEC_DISCONNECT_BLOCKED    = 0x00000008,
}

///The <b>CALL_MEDIA_EVENT</b> enum describes call media events. The ITCallMediaEvent::get_Event method returns a member
///of this enum to indicate the type of call media event that occurred.
alias CALL_MEDIA_EVENT = int;
enum : int
{
    ///A new media stream has been created.
    CME_NEW_STREAM      = 0x00000000,
    ///A media stream or stream request has failed.
    CME_STREAM_FAIL     = 0x00000001,
    ///A terminal has failed.
    CME_TERMINAL_FAIL   = 0x00000002,
    ///The media stream has not been used.
    CME_STREAM_NOT_USED = 0x00000003,
    ///The media stream is active.
    CME_STREAM_ACTIVE   = 0x00000004,
    ///The media stream is not active.
    CME_STREAM_INACTIVE = 0x00000005,
    CME_LASTITEM        = 0x00000005,
}

///The <b>CALL_MEDIA_EVENT_CAUSE</b> enum is used by ITCallMediaEvent::get_Cause method to return a description of what
///caused a media event, such as a device timeout.
alias CALL_MEDIA_EVENT_CAUSE = int;
enum : int
{
    ///Call media is unknown.
    CMC_UNKNOWN            = 0x00000000,
    ///Device source or renderer is not functioning.
    CMC_BAD_DEVICE         = 0x00000001,
    ///Could not connect to media device.
    CMC_CONNECT_FAIL       = 0x00000002,
    ///A local request has been received.
    CMC_LOCAL_REQUEST      = 0x00000003,
    ///A remote request has been received.
    CMC_REMOTE_REQUEST     = 0x00000004,
    ///The media device timed out.
    CMC_MEDIA_TIMEOUT      = 0x00000005,
    ///Media processing has resumed after an interruption.
    CMC_MEDIA_RECOVERED    = 0x00000006,
    CMC_QUALITY_OF_SERVICE = 0x00000007,
}

///The <b>DISCONNECT_CODE</b> enum is used by the ITBasicCallControl::Disconnect method.
alias DISCONNECT_CODE = int;
enum : int
{
    ///The call is being disconnected as part of the normal cycle of the call.
    DC_NORMAL   = 0x00000000,
    ///The call is being disconnected because it has not been answered. (For example, an application may set a certain
    ///amount of time for the user to answer the call. If the user does not answer, the application can call Disconnect
    ///with the NOANSWER code.)
    DC_NOANSWER = 0x00000001,
    ///The user rejected the offered call.
    DC_REJECTED = 0x00000002,
}

///The <b>TERMINAL_STATE</b> enum describes the current state of a terminal device. This enum is returned by the
///ITTerminal::get_State method.
alias TERMINAL_STATE = int;
enum : int
{
    ///The terminal is currently in use.
    TS_INUSE    = 0x00000000,
    ///The terminal is not currently in use.
    TS_NOTINUSE = 0x00000001,
}

///The <b>TERMINAL_DIRECTION</b> enumeration is used to describe the direction of the media stream with respect to the
///local computer or the directional capabilities of a terminal.
alias TERMINAL_DIRECTION = int;
enum : int
{
    ///The stream is captured on the local computer, and the data is sent out to the remote end of the connection. When
    ///applied to a terminal, this means it can originate a stream.
    TD_CAPTURE          = 0x00000000,
    ///The stream is arriving from the remote end of the connection. When applied to a terminal, this means it can
    ///render a stream.
    TD_RENDER           = 0x00000001,
    ///The terminal can handle either capture or render streams.
    TD_BIDIRECTIONAL    = 0x00000002,
    ///Different tracks on the multi-track terminal may travel in different directions. For example, one track may
    ///specify <b>TD_RENDER</b> and another may specify <b>TD_CAPTURE</b>.
    TD_MULTITRACK_MIXED = 0x00000003,
    ///The terminal direction is unknown or not initialized.
    TD_NONE             = 0x00000004,
}

///The <b>TERMINAL_TYPE</b> enum describes the type of the terminal. This enum is returned by the
///ITTerminal::get_TerminalType method.
alias TERMINAL_TYPE = int;
enum : int
{
    ///A static terminal is a terminal that cannot be created and usually refers to hardware device. TAPI enumerates
    ///these terminals.
    TT_STATIC  = 0x00000000,
    ///A terminal type that can be created. The application must call ITTerminalSupport::CreateTerminal to use this type
    ///of terminal.
    TT_DYNAMIC = 0x00000001,
}

///A <b>CALL_PRIVILEGE</b> member is returned by the ITCallInfo::get_Privilege method, and indicates when the current
///application owns or is monitoring the current call.
alias CALL_PRIVILEGE = int;
enum : int
{
    ///The application is the owner of the call.
    CP_OWNER   = 0x00000000,
    ///The application is a monitor of the call.
    CP_MONITOR = 0x00000001,
}

///The <b>TAPI_EVENT</b> enumeration is used to notify an application that a change has occurred in the TAPI object. The
///ITTAPIEventNotification::Event method implementation uses members of this enumeration to indicate the type of object
///associated with the <b>IDispatch</b> pointer passed by TAPI.
alias TAPI_EVENT = int;
enum : int
{
    ///Change is in TAPI object itself. For more information, see ITTAPIObjectEvent.
    TE_TAPIOBJECT         = 0x00000001,
    ///An Address object has changed. For more information, see ITAddressEvent.
    TE_ADDRESS            = 0x00000002,
    ///A new communications session has appeared on the address and the TAPI DLL has created a new call object. This
    ///could be a result from an incoming session, a session handed off by another application, or a session being
    ///parked on the address. For more information, see ITCallNotificationEvent and ITTAPI::RegisterCallNotifications.
    TE_CALLNOTIFICATION   = 0x00000004,
    ///The Call state has changed. For more information, see ITCallStateEvent.
    TE_CALLSTATE          = 0x00000008,
    ///The media associated with a call has changed. For more information, see ITCallMediaEvent.
    TE_CALLMEDIA          = 0x00000010,
    ///A CallHub object has changed. For more information, see ITCallHubEvent.
    TE_CALLHUB            = 0x00000020,
    ///The call information has changed. For more information, see ITCallInfoChangeEvent.
    TE_CALLINFOCHANGE     = 0x00000040,
    ///A provider-specific private object has changed. The precise type of object referenced is implementation
    ///dependent. For more information, see Provider-Specific Interfaces.
    TE_PRIVATE            = 0x00000080,
    ///A Request object has changed. For more information, see ITRequestEvent.
    TE_REQUEST            = 0x00000100,
    ///An Agent object has changed. For more information, see ITAgentEvent.
    TE_AGENT              = 0x00000200,
    ///An AgentSession object has changed. For more information, see ITAgentSessionEvent.
    TE_AGENTSESSION       = 0x00000400,
    ///A QOS event has occurred. For more information, see ITQOSEvent.
    TE_QOSEVENT           = 0x00000800,
    ///An AgentHandler object has changed. For more information, see ITAgentHandlerEvent.
    TE_AGENTHANDLER       = 0x00001000,
    ///An ACDGroup object has changed. For more information, see ITACDGroupEvent.
    TE_ACDGROUP           = 0x00002000,
    ///A Queue object has changed. For more information, see ITQueueEvent.
    TE_QUEUE              = 0x00004000,
    ///A digit event has occurred. For more information, see ITDigitDetectionEvent.
    TE_DIGITEVENT         = 0x00008000,
    ///A digit generation event has occurred. For more information, see ITDigitGenerationEvent.
    TE_GENERATEEVENT      = 0x00010000,
    ///An Automatic Speech Recognition terminal event has occurred. Valid only for computers running on Windows XP and
    ///later.
    TE_ASRTERMINAL        = 0x00020000,
    ///An event has occurred on a TTS terminal. For more information, see ITTTSTerminalEvent. Valid only for computers
    ///running on Windows XP and later.
    TE_TTSTERMINAL        = 0x00040000,
    ///An event has occurred on a file terminal. For more information, see ITFileTerminalEvent. Valid only for computers
    ///running on Windows XP and later.
    TE_FILETERMINAL       = 0x00080000,
    ///An event has occurred on a tone terminal. For more information, see ITToneTerminalEvent. Valid only for computers
    ///running on Windows XP and later.
    TE_TONETERMINAL       = 0x00100000,
    ///A Phone object has changed. For more information, see ITPhoneEvent. Valid only for computers running on Windows
    ///XP and later.
    TE_PHONEEVENT         = 0x00200000,
    ///A tone event has been fired. Detection of in-band tones will be enabled or disabled. For more information, see
    ///ITToneDetectionEvent. Valid only for computers running on Windows XP and later.
    TE_TONEEVENT          = 0x00400000,
    ///A gather digits event has been fired. Digits will be gathered on the current call. For more information, see
    ///ITDigitsGatheredEvent. Valid only for computers running on Windows XP and later.
    TE_GATHERDIGITS       = 0x00800000,
    ///An address device-specific event has occurred. For more information, see ITAddressDeviceSpecificEvent. Valid only
    ///for computers running on Windows XP and later.
    TE_ADDRESSDEVSPECIFIC = 0x01000000,
    ///A phone device-specific event has occurred. For more information, see ITPhoneDeviceSpecificEvent. Valid only for
    ///computers running on Windows XP and later.
    TE_PHONEDEVSPECIFIC   = 0x02000000,
}

///The <b>CALL_NOTIFICATION_EVENT</b> enum describes call notification events. The ITCallNotificationEvent::get_Event
///method returns a member of this enum to indicate the type of call notification event that occurred.
alias CALL_NOTIFICATION_EVENT = int;
enum : int
{
    ///The current application owns the call on which the event occurred.
    CNE_OWNER    = 0x00000000,
    ///The current application is monitoring the call on which the event occurred.
    CNE_MONITOR  = 0x00000001,
    CNE_LASTITEM = 0x00000001,
}

///The <b>CALLHUB_EVENT</b> enum describes CallHub events. The ITCallHubEvent::get_Event method returns a member of this
///enum to indicate the type of CallHub event that occurred.
alias CALLHUB_EVENT = int;
enum : int
{
    ///A new call has joined the CallHub.
    CHE_CALLJOIN    = 0x00000000,
    ///A call has left the CallHub.
    CHE_CALLLEAVE   = 0x00000001,
    ///A new CallHub has appeared.
    CHE_CALLHUBNEW  = 0x00000002,
    ///A CallHub has gone idle.
    CHE_CALLHUBIDLE = 0x00000003,
    CHE_LASTITEM    = 0x00000003,
}

///The <b>CALLHUB_STATE</b> enum is a state indicator returned by the ITCallHub::get_State method.
alias CALLHUB_STATE = int;
enum : int
{
    ///The CallHub is active. There is at least one call that is not in the CS_DISCONNECTED state.
    CHS_ACTIVE = 0x00000000,
    ///All calls associated with this CallHub are in the CS_DISCONNECTED state.
    CHS_IDLE   = 0x00000001,
}

///The <b>TAPIOBJECT_EVENT</b> enum describes TAPI object events. The ITTAPIObjectEvent::get_Event method returns a
///member of this enum to indicate the type of TAPI object event that occurred.
alias TAPIOBJECT_EVENT = int;
enum : int
{
    ///A new address has been created.
    TE_ADDRESSCREATE   = 0x00000000,
    ///An address has been moved.
    TE_ADDRESSREMOVE   = 0x00000001,
    ///The TAPI object has been reinitialized
    TE_REINIT          = 0x00000002,
    ///A translation change has occurred.
    TE_TRANSLATECHANGE = 0x00000003,
    ///Address has been closed.
    TE_ADDRESSCLOSE    = 0x00000004,
    TE_PHONECREATE     = 0x00000005,
    TE_PHONEREMOVE     = 0x00000006,
}

///The <b>TAPI_OBJECT_TYPE</b> enum is used to indicate the type of TAPI object involved in an event.
alias TAPI_OBJECT_TYPE = int;
enum : int
{
    ///No TAPI object event has occurred.
    TOT_NONE     = 0x00000000,
    ///Type of TAPI object is TAPI.
    TOT_TAPI     = 0x00000001,
    ///Type of TAPI object is Address.
    TOT_ADDRESS  = 0x00000002,
    ///Type of TAPI object is Terminal.
    TOT_TERMINAL = 0x00000003,
    ///Type of TAPI object is Call.
    TOT_CALL     = 0x00000004,
    ///Type of TAPI object is CallHub.
    TOT_CALLHUB  = 0x00000005,
    TOT_PHONE    = 0x00000006,
}

///The <b>QOS_SERVICE_LEVEL</b> enum is used by the ITBasicCallControl::SetQOS method to indicate quality of service
///requirements for a call.
alias QOS_SERVICE_LEVEL = int;
enum : int
{
    ///Quality of service level required.
    QSL_NEEDED       = 0x00000001,
    ///Quality of service level desired if available.
    QSL_IF_AVAILABLE = 0x00000002,
    ///Quality of service level desired is "best effort."
    QSL_BEST_EFFORT  = 0x00000003,
}

///The <b>QOS_EVENT</b> enum describes quality of service (QOS) events. The ITQOSEvent::get_Event method returns a
///member of this enum to indicate the type of QOS event that occurred.
alias QOS_EVENT = int;
enum : int
{
    ///QOS is not available.
    QE_NOQOS            = 0x00000001,
    ///The QOS request could not be met.
    QE_ADMISSIONFAILURE = 0x00000002,
    ///The type of QOS requested is not supported.
    QE_POLICYFAILURE    = 0x00000003,
    ///Unspecified QOS error.
    QE_GENERICERROR     = 0x00000004,
    QE_LASTITEM         = 0x00000004,
}

///The <b>CALLINFOCHANGE_CAUSE</b> enum is used by the ITCallInfoChangeEvent::get_Cause method to return a description
///of the type of call information that has changed. You can retrieve specific information about the change by using the
///TAPI 3 ITCallInfo interface. TAPI 2 applications use lineGetCallInfo or lineGetCallStatus.
alias CALLINFOCHANGE_CAUSE = int;
enum : int
{
    ///Unspecified call information has changed.
    CIC_OTHER         = 0x00000000,
    ///Call information specific to a device has changed.
    CIC_DEVSPECIFIC   = 0x00000001,
    ///The bearer mode for the call has changed.
    CIC_BEARERMODE    = 0x00000002,
    ///The rate has changed.
    CIC_RATE          = 0x00000003,
    ///Call information specific to an application has changed. Application-specific information is used to pass
    ///information between applications in a multi-application environment. The information is not interpreted by the
    ///API implementation or the service provider. Only applications with owner privileges for the call can set it
    CIC_APPSPECIFIC   = 0x00000004,
    ///The call identifier has changed.
    CIC_CALLID        = 0x00000005,
    ///The related call identifier has changed.
    CIC_RELATEDCALLID = 0x00000006,
    ///The call origin has changed.
    CIC_ORIGIN        = 0x00000007,
    ///The call reason has changed.
    CIC_REASON        = 0x00000008,
    ///The completion identifier has changed.
    CIC_COMPLETIONID  = 0x00000009,
    ///The number of owners has increased.
    CIC_NUMOWNERINCR  = 0x0000000a,
    ///The number of owners has decreased.
    CIC_NUMOWNERDECR  = 0x0000000b,
    ///The number of call monitors has changed.
    CIC_NUMMONITORS   = 0x0000000c,
    ///Trunk used on call has changed.
    CIC_TRUNK         = 0x0000000d,
    ///The caller identifier has changed.
    CIC_CALLERID      = 0x0000000e,
    ///The called identifier has changed.
    CIC_CALLEDID      = 0x0000000f,
    ///The connected identifier has changed.
    CIC_CONNECTEDID   = 0x00000010,
    ///The redirection identifier has changed.
    CIC_REDIRECTIONID = 0x00000011,
    ///The redirecting identifier has changed.
    CIC_REDIRECTINGID = 0x00000012,
    ///The user-user information buffer has changed.
    CIC_USERUSERINFO  = 0x00000013,
    ///The high-level compatibility information has changed (ISDN Q.931).
    CIC_HIGHLEVELCOMP = 0x00000014,
    ///The low-level compatibility information has changed (ISDN Q.931).
    CIC_LOWLEVELCOMP  = 0x00000015,
    ///The call's charging information has changed.
    CIC_CHARGINGINFO  = 0x00000016,
    ///Treatment of calls on hold has changed.
    CIC_TREATMENT     = 0x00000017,
    ///The call data buffer has changed.
    CIC_CALLDATA      = 0x00000018,
    ///Call privilege has changed.
    CIC_PRIVILEGE     = 0x00000019,
    ///The call media type has changed.
    CIC_MEDIATYPE     = 0x0000001a,
    CIC_LASTITEM      = 0x0000001a,
}

///The <b>CALLINFO_LONG</b> enum is used by ITCallInfo methods that set and get call information of type <b>LONG</b>.
alias CALLINFO_LONG = int;
enum : int
{
    ///The media types available on the call.
    CIL_MEDIATYPESAVAILABLE      = 0x00000000,
    ///The bearer mode of a call is described by the LINEBEARERMODE_ Constants.
    CIL_BEARERMODE               = 0x00000001,
    ///The address type of the caller.
    CIL_CALLERIDADDRESSTYPE      = 0x00000002,
    ///The address type of the called party.
    CIL_CALLEDIDADDRESSTYPE      = 0x00000003,
    ///The address type of the connected party.
    CIL_CONNECTEDIDADDRESSTYPE   = 0x00000004,
    ///The address type of the destination to which a call has been redirected.
    CIL_REDIRECTIONIDADDRESSTYPE = 0x00000005,
    ///The address type of the location that redirected the call.
    CIL_REDIRECTINGIDADDRESSTYPE = 0x00000006,
    ///The origin of a call is described by the LINECALLORIGIN_ Constants, such as LINECALLORIGIN_EXTERNAL.
    CIL_ORIGIN                   = 0x00000007,
    ///The reason for a call is described by the LINECALLREASON_ Constants, such as LINECALLREASON_FWDUNCOND.
    CIL_REASON                   = 0x00000008,
    ///Application-specific information is used to pass information between applications in a multi-application
    ///environment. The information is not interpreted by the API implementation or the service provider. Only
    ///applications with owner privileges for the call can set it.
    CIL_APPSPECIFIC              = 0x00000009,
    ///Call parameter flags are described by LINECALLPARAMFLAGS_ Constants, such as LINECALLPARAMFLAGS_BLOCKID. These
    ///flags are normally set during the creation of an outgoing call.
    CIL_CALLPARAMSFLAGS          = 0x0000000a,
    ///Call treatment identifies how a call that is on hold or unanswered gets handled, and is described by
    ///LINECALLTREATMENT_ Constants, such as LINECALLTREATMENT_MUSIC.
    CIL_CALLTREATMENT            = 0x0000000b,
    ///The minimum rate for a call's data stream in bps (bits per second).
    CIL_MINRATE                  = 0x0000000c,
    ///The maximum rate for a call's data stream in bps (bits per second).
    CIL_MAXRATE                  = 0x0000000d,
    ///Country or region code.
    CIL_COUNTRYCODE              = 0x0000000e,
    ///Call identifier. Some service providers assign a unique code to each call.
    CIL_CALLID                   = 0x0000000f,
    ///Call identifier for a call related to the current call, such as on a conference.
    CIL_RELATEDCALLID            = 0x00000010,
    ///Completion identifier. The completion identifier is used to identify individual completion requests in progress.
    ///A completion identifier becomes invalid and can be reused after the request completion or after an outstanding
    ///request is canceled.
    CIL_COMPLETIONID             = 0x00000011,
    ///The number of applications having owner privileges for the current call.
    CIL_NUMBEROFOWNERS           = 0x00000012,
    ///The number of applications having monitor privileges for the current call.
    CIL_NUMBEROFMONITORS         = 0x00000013,
    ///The trunk identifier for the current call.
    CIL_TRUNK                    = 0x00000014,
    ///The current rate for a call's data stream in bps (bits per second).
    CIL_RATE                     = 0x00000015,
    CIL_GENERATEDIGITDURATION    = 0x00000016,
    CIL_MONITORDIGITMODES        = 0x00000017,
    CIL_MONITORMEDIAMODES        = 0x00000018,
}

///The <b>CALLINFO_STRING</b> enum is used by ITCallInfo methods that set and get call information involving the use of
///strings.
alias CALLINFO_STRING = int;
enum : int
{
    ///The name of the caller.
    CIS_CALLERIDNAME            = 0x00000000,
    ///The number of the caller.
    CIS_CALLERIDNUMBER          = 0x00000001,
    ///The name of the called location.
    CIS_CALLEDIDNAME            = 0x00000002,
    ///The number of the called location.
    CIS_CALLEDIDNUMBER          = 0x00000003,
    ///The name of the connected location.
    CIS_CONNECTEDIDNAME         = 0x00000004,
    ///The number of the connected location.
    CIS_CONNECTEDIDNUMBER       = 0x00000005,
    ///The name of the location to which a call has been redirected.
    CIS_REDIRECTIONIDNAME       = 0x00000006,
    ///The number of the location to which a call has been redirected.
    CIS_REDIRECTIONIDNUMBER     = 0x00000007,
    ///The name of the location that redirected the call.
    CIS_REDIRECTINGIDNAME       = 0x00000008,
    ///The number of the location that redirected the call.
    CIS_REDIRECTINGIDNUMBER     = 0x00000009,
    ///The called party friendly name.
    CIS_CALLEDPARTYFRIENDLYNAME = 0x0000000a,
    ///A comment about the call provided by the application that originated the call. The call state must be CS_IDLE
    ///when setting the comment.
    CIS_COMMENT                 = 0x0000000b,
    ///A displayable version of the called or calling address.
    CIS_DISPLAYABLEADDRESS      = 0x0000000c,
    ///The identifier of the calling party.
    CIS_CALLINGPARTYID          = 0x0000000d,
}

///The <b>CALLINFO_BUFFER</b> enum indicates the type of buffer accessed by the ITCallInfo::GetCallInfoBuffer method or
///the ITCallInfo::SetCallInfoBuffer method. The ITCallInfo::get_CallInfoBuffer and ITCallInfo::put_CallInfoBuffer
///methods are provided for Automation client applications, such as those written in Visual Basic.
alias CALLINFO_BUFFER = int;
enum : int
{
    ///The user-user information buffer allows an application to send information to the remote party on a call or
    ///receive information from that party.
    CIB_USERUSERINFO                 = 0x00000000,
    ///The device-specific buffer allows an application to communicate with a TSP concerning device-specific
    ///capabilities. The precise nature of these capabilities depends on the implementation of the service provider.
    CIB_DEVSPECIFICBUFFER            = 0x00000001,
    ///The call data buffer allows an application to communicate with a TSP concerning a specific call. The precise
    ///nature of this information depends on the implementation of the service provider.
    CIB_CALLDATABUFFER               = 0x00000002,
    ///The charging information buffer's format is specified by other standards (ISDN Q.931).
    CIB_CHARGINGINFOBUFFER           = 0x00000003,
    ///The high-level compatibility buffer's format is specified by other standards (ISDN Q.931).
    CIB_HIGHLEVELCOMPATIBILITYBUFFER = 0x00000004,
    ///The low-level compatibility buffer's format is specified by other standards (ISDN Q.931).
    CIB_LOWLEVELCOMPATIBILITYBUFFER  = 0x00000005,
}

///A member of the <b>ADDRESS_CAPABILITY</b> enum is used by the ITAddressCapabilities::get_AddressCapability method to
///indicate the address capability required.
alias ADDRESS_CAPABILITY = int;
enum : int
{
    ///An address may support more than one address type, but please note that one may be used during
    ///ITAddress::CreateCall.
    AC_ADDRESSTYPES                 = 0x00000000,
    ///Bearer modes.
    AC_BEARERMODES                  = 0x00000001,
    ///The maximum number of (minimum bandwidth) calls that can be active (connected) on the line at any one time. The
    ///actual number of active calls can be lower if higher bandwidth calls are established on the line.
    AC_MAXACTIVECALLS               = 0x00000002,
    ///Maximum number of calls that can be on hold at once.
    AC_MAXONHOLDCALLS               = 0x00000003,
    ///Maximum number of calls that can be simultaneously pending transfer or conference.
    AC_MAXONHOLDPENDINGCALLS        = 0x00000004,
    ///Contains the maximum number of parties that can join a single conference call on this address.
    AC_MAXNUMCONFERENCE             = 0x00000005,
    ///Specifies the number of parties (including "self") that can be added in a conference call that is initiated as a
    ///generic consultation call using ITBasicCallControl::Transfer and ITBasicCallControl::Finish (FM_ASCONFERENCE).
    AC_MAXNUMTRANSCONF              = 0x00000006,
    ///Specifies digit modes detectable on this address using the LINEDIGITMODE_ flags. If no flag is set, digit
    ///monitoring is not supported.
    AC_MONITORDIGITSUPPORT          = 0x00000007,
    ///Specifies digit modes that can be generated on this address using a subset of the LINEDIGITMODE_ flags:
    ///LINEDIGITMODE_PULSE indicates digits can be generated as pulse/rotary tones, and LINEDIGITMODE_DTMF indicates
    ///digits can be generated as DTMF tones. If no flag is set, digit generation is not supported.
    AC_GENERATEDIGITSUPPORT         = 0x00000008,
    ///Specifies the different kinds of tones that can be generated on this line, of type LINETONEMODE_.
    AC_GENERATETONEMODES            = 0x00000009,
    ///Contains the maximum number of frequencies that can be specified in describing a general tone.
    AC_GENERATETONEMAXNUMFREQ       = 0x0000000a,
    ///Contains the maximum number of frequencies that can be specified when monitoring a general tone. A value of 0
    ///indicates that tone monitor is not available.
    AC_MONITORTONEMAXNUMFREQ        = 0x0000000b,
    ///Contains the maximum number of entries that can be specified in a tone list.
    AC_MONITORTONEMAXNUMENTRIES     = 0x0000000c,
    ///Device capability flags.
    AC_DEVCAPFLAGS                  = 0x0000000d,
    ///Answer modes.
    AC_ANSWERMODES                  = 0x0000000e,
    ///Specifies the features available for this line using the LINEFEATURE_ constants. Invoking a supported feature
    ///requires the line to be in the proper state and the underlying line device to be opened in a compatible mode. A
    ///zero in a bit position indicates that the corresponding feature is never available. A one indicates that the
    ///corresponding feature may be available if the line is in the appropriate state for the operation to be
    ///meaningful. This member allows an application to discover which line features can be (and which can never be)
    ///supported by the device.
    AC_LINEFEATURES                 = 0x0000000f,
    ///Indicates LINEDEVSTATUS_ values that can be modified.
    AC_SETTABLEDEVSTATUS            = 0x00000010,
    ///Indicates whether park is supported using the LINEPARKMODE_ flags.
    AC_PARKSUPPORT                  = 0x00000011,
    ///Identifies support for caller number identification using the LINECALLPARTYID_ flags.
    AC_CALLERIDSUPPORT              = 0x00000012,
    ///Identifies support for called number identification using the LINECALLPARTYID_ flags.
    AC_CALLEDIDSUPPORT              = 0x00000013,
    ///Indicates whether connected ID is supported using the LINECALLPARTYID_ flags.
    AC_CONNECTEDIDSUPPORT           = 0x00000014,
    ///Indicates whether redirection ID is supported using the LINECALLPARTYID_ flags.
    AC_REDIRECTIONIDSUPPORT         = 0x00000015,
    ///Indicates whether redirecting ID is supported using the LINECALLPARTYID_ flags.
    AC_REDIRECTINGIDSUPPORT         = 0x00000016,
    ///The address capability flags describe various Boolean address capabilities. For example,
    ///LINEADDRCAPFLAGS_FWDNUMRINGS indicates whether the number of rings for a no-answer can be specified when
    ///forwarding on a no-answer.
    AC_ADDRESSCAPFLAGS              = 0x00000017,
    ///Call feature set one.
    AC_CALLFEATURES1                = 0x00000018,
    ///Supplemental call features for conferencing, transferring, and parking calls.
    AC_CALLFEATURES2                = 0x00000019,
    ///Specifies the address's capabilities for removing calls from a conference call. This member uses the
    ///LINEREMOVEFROMCONF_ constants.
    AC_REMOVEFROMCONFCAPS           = 0x0000001a,
    ///Uses the LINECALLSTATE_ constants to specify the state of the call after it has been removed from a conference
    ///call.
    AC_REMOVEFROMCONFSTATE          = 0x0000001b,
    ///Transfer modes.
    AC_TRANSFERMODES                = 0x0000001c,
    ///The line address features describe operations that can be invoked on an address. For example, if
    ///LINEADDRFEATURE_FORWARD is set, the address can be forwarded.
    AC_ADDRESSFEATURES              = 0x0000001d,
    ///The call state or states upon which a call made by a predictive dialer can be set to automatically transfer the
    ///call to another address; one or more of the LINECALLSTATE_ constants. The value 0 indicates automatic transfer
    ///based on call state is unavailable.
    AC_PREDICTIVEAUTOTRANSFERSTATES = 0x0000001e,
    ///Maximum data block size allowed.
    AC_MAXCALLDATASIZE              = 0x0000001f,
    ///Returns the device identifier of the line device with which this address is associated. TAPI 2.1 cross-reference:
    ///LINEADDRESSCAPS.
    AC_LINEID                       = 0x00000020,
    ///Address identifier. An address identifier is permanently associated with an address; the identifier remains
    ///constant across operating system upgrades.
    AC_ADDRESSID                    = 0x00000021,
    ///Forwarding modes.
    AC_FORWARDMODES                 = 0x00000022,
    ///The maximum number of different forwarding entries that can be supported by the current address.
    AC_MAXFORWARDENTRIES            = 0x00000023,
    ///Specifies the maximum number of entries that can be set using ITForwardInformation::SetForwardType that can
    ///contain forwarding instructions based on a specific caller (selective call forwarding). This member is zero if
    ///selective call forwarding is not supported.
    AC_MAXSPECIFICENTRIES           = 0x00000024,
    ///Specifies the minimum number of rings that can be set to determine when a call is officially considered "no
    ///answer."
    AC_MINFWDNUMRINGS               = 0x00000025,
    ///Specifies the maximum number of rings that can be set to determine when a call is officially considered "no
    ///answer."
    AC_MAXFWDNUMRINGS               = 0x00000026,
    ///The maximum number of concurrent call completion requests that can be outstanding on this address. Zero implies
    ///that call completion is not available.
    AC_MAXCALLCOMPLETIONS           = 0x00000027,
    ///Call completion conditions.
    AC_CALLCOMPLETIONCONDITIONS     = 0x00000028,
    ///Call completion modes.
    AC_CALLCOMPLETIONMODES          = 0x00000029,
    ///The permanent identifier by which the line device is known in the system's configuration. This value does not
    ///change as lines are added and removed from the system. It can therefore be used to link line-specific information
    ///in the registry or other files in a way that is not affected by changes in other lines. If a line has more than
    ///one address, all addresses will have the same permanent device identifier. TSP writers should note that this
    ///value must be preserved across operating system upgrades.
    AC_PERMANENTDEVICEID            = 0x0000002a,
    AC_GATHERDIGITSMINTIMEOUT       = 0x0000002b,
    AC_GATHERDIGITSMAXTIMEOUT       = 0x0000002c,
    AC_GENERATEDIGITMINDURATION     = 0x0000002d,
    AC_GENERATEDIGITMAXDURATION     = 0x0000002e,
    AC_GENERATEDIGITDEFAULTDURATION = 0x0000002f,
}

///The <b>ADDRESS_CAPABILITY_STRING</b> enum is used to check on address capabilities which are described by strings.
alias ADDRESS_CAPABILITY_STRING = int;
enum : int
{
    ///Describes a protocol-specific capability. The value is returned as a GUID in string format. For possible values,
    ///see TAPIPROTOCOL_. A TSP may define additional values. Corresponds to the <b>ProtocolGuid</b> member of TAPI 2's
    ///LINEDEVCAPS structure.
    ACS_PROTOCOL              = 0x00000000,
    ///Describes an address device-specific capability. The value is TSP dependent and can be a structure, a string, or
    ///some other type. An application should use the <b>BSTR</b> pointer received from Tapi3.dll as a pointer to an
    ///array of bytes (a buffer), and then interpret the buffer according to TSP specifications. Corresponds to the
    ///<b>dwDevSpecific</b> and <b>dwDevSpecificSize</b> members of TAPI 2's LINEADDRESSCAPS structure.
    ACS_ADDRESSDEVICESPECIFIC = 0x00000001,
    ///Describes a line device-specific capability. The value is TSP dependent and can be a structure, a string, or some
    ///other type. An application should use the <b>BSTR</b> pointer received from Tapi3.dll as a pointer to an array of
    ///bytes (a buffer), and then interpret the buffer according to TSP specifications. Corresponds to the
    ///<b>dwDevSpecific</b> and <b>dwDevSpecificSize</b> members of TAPI 2's LINEDEVCAPS structure.
    ACS_LINEDEVICESPECIFIC    = 0x00000002,
    ///Describes a provider-specific capability. The value is a plain string. It can be used with regular <b>BSTR</b>
    ///functions for operations such as printing and concatenating. A specific TSP might included embedded <b>NULL</b>
    ///characters inside these strings. If so, an application should take care when printing the value. If the embedded
    ///<b>NULL</b> characters are not replaced with blanks, the strings will appear truncated when printed. Corresponds
    ///to the <b>dwProviderInfoSize</b> and <b>dwProviderInfoOffset</b> members of TAPI 2's LINEDEVCAPS structure.
    ACS_PROVIDERSPECIFIC      = 0x00000003,
    ///Describes a switch-specific capability. The value is a plain string. It can be used with regular <b>BSTR</b>
    ///functions for operations such as printing and concatenating. A specific TSP might included embedded <b>NULL</b>
    ///characters inside these strings. If so, an application should take care when printing the value. If the embedded
    ///<b>NULL</b> characters are not replaced with blanks, the strings will appear truncated when printed. Corresponds
    ///to the <b>dwSwitchInfoSize</b> and <b>dwSwitchInfoOffset</b> members of TAPI 2's LINEDEVCAPS structure.
    ACS_SWITCHSPECIFIC        = 0x00000004,
    ///Describes the GUID of a permanent device. The value is returned as a GUID in string format. This identifier must
    ///remain stable throughout, including operating system upgrades. Corresponds to the <b>PermanentLineGuid</b> member
    ///of TAPI 2's LINEDEVCAPS structure.
    ACS_PERMANENTDEVICEGUID   = 0x00000005,
}

///The <b>FULLDUPLEX_SUPPORT</b> enum is used by applications interacting with legacy TSPs to indicate whether a
///specified terminal supports full duplex operations. This enum is returned by the ITLegacyWaveSupport::IsFullDuplex
///method.
alias FULLDUPLEX_SUPPORT = int;
enum : int
{
    ///Full duplex supported.
    FDS_SUPPORTED    = 0x00000000,
    ///Full duplex not supported.
    FDS_NOTSUPPORTED = 0x00000001,
    ///The TSP cannot determine whether the device is full duplex.
    FDS_UNKNOWN      = 0x00000002,
}

///The <b>FINISH_MODE</b> enum is used by applications to indicate the type of call finish required. Operations that the
///TAPI DLL performs vary depending on whether a call transfer is being completed or a call is being added to a
///conference.
alias FINISH_MODE = int;
enum : int
{
    ///A call transfer is being finished.
    FM_ASTRANSFER   = 0x00000000,
    ///A call is being added to a conference call.
    FM_ASCONFERENCE = 0x00000001,
}

///The <b>PHONE_PRIVILEGE</b> enum indicates the application's privilege status with respect to the current phone
///device.
alias PHONE_PRIVILEGE = int;
enum : int
{
    ///The application has owner privileges for the current phone session.
    PP_OWNER   = 0x00000000,
    ///The application has monitor privileges for the current phone session.
    PP_MONITOR = 0x00000001,
}

///The <b>PHONE_HOOK_SWITCH_DEVICE</b> enum is used to indicate the types of switch hooks on a phone device.
alias PHONE_HOOK_SWITCH_DEVICE = int;
enum : int
{
    ///The handset's hookswitch.
    PHSD_HANDSET      = 0x00000001,
    ///The speakerphone's hookswitch.
    PHSD_SPEAKERPHONE = 0x00000002,
    ///The headset's hookswitch.
    PHSD_HEADSET      = 0x00000004,
}

///The <b>PHONE_HOOK_SWITCH_STATE</b> enum provides indicators of the phone hookswitch status.
alias PHONE_HOOK_SWITCH_STATE = int;
enum : int
{
    ///Indicates that the phone is onhook.
    PHSS_ONHOOK               = 0x00000001,
    ///Indicates that only the phone's microphone is offhook.
    PHSS_OFFHOOK_MIC_ONLY     = 0x00000002,
    ///Indicates that only the phone's speaker is offhook.
    PHSS_OFFHOOK_SPEAKER_ONLY = 0x00000004,
    ///Indicates that the phone is offhook.
    PHSS_OFFHOOK              = 0x00000008,
}

///The <b>PHONE_LAMP_MODE</b> enum provides indicators of a phone lamp's status.
alias PHONE_LAMP_MODE = int;
enum : int
{
    ///The lamp identifier has no corresponding lamp.
    LM_DUMMY         = 0x00000001,
    ///The lamp is off.
    LM_OFF           = 0x00000002,
    ///The lamp is on steadily.
    LM_STEADY        = 0x00000004,
    ///The lamp is winking, which means on and off at a normal rate.
    LM_WINK          = 0x00000008,
    ///The lamp is flashing, which means a slow on and off.
    LM_FLASH         = 0x00000010,
    ///The lamp is fluttering, which means a fast on and off.
    LM_FLUTTER       = 0x00000020,
    ///The lamp is flashing, which means superposition of a flash and flutter.
    LM_BROKENFLUTTER = 0x00000040,
    ///The lamp mode is not known.
    LM_UNKNOWN       = 0x00000080,
}

///The <b>PHONECAPS_LONG</b> enum is used by methods that set or get phone capabilities described by a long value.
alias PHONECAPS_LONG = int;
enum : int
{
    ///Specifies the hookswitch devices available using one or more members of the PHONE_HOOK_SWITCH_DEVICE enum.
    PCL_HOOKSWITCHES                = 0x00000000,
    ///Specifies the handset hook switch modes.
    PCL_HANDSETHOOKSWITCHMODES      = 0x00000001,
    ///Specifies the headset hook switch modes.
    PCL_HEADSETHOOKSWITCHMODES      = 0x00000002,
    ///Specifies the speakerphone hook switch modes.
    PCL_SPEAKERPHONEHOOKSWITCHMODES = 0x00000003,
    ///Specifies the number of rows in a phone display device.
    PCL_DISPLAYNUMROWS              = 0x00000004,
    ///Specifies the number of columns in a phone display device.
    PCL_DISPLAYNUMCOLUMNS           = 0x00000005,
    ///Specifies the number of ring modes. If a USB phone returns zero for this value, the phone typically does not have
    ///a ringer device. The ringing sound plays on the default audio device for the system; for example, on sound card
    ///speakers.
    PCL_NUMRINGMODES                = 0x00000006,
    ///Specifies the number of button lamps.
    PCL_NUMBUTTONLAMPS              = 0x00000007,
    ///Specifies whether the phone is generic: a value of one indicates it is, a value of zero indicates it is not. A
    ///generic phone is a phone device that declares itself as available on all addresses that support audio terminals.
    ///For example, a USB phone is generic, because it is not tied to a specific TAPI address.
    PCL_GENERICPHONE                = 0x00000008,
}

///The <b>PHONECAPS_STRING</b> enum is used by methods that set or get phone capabilities described by a string.
alias PHONECAPS_STRING = int;
enum : int
{
    ///Name of the phone.
    PCS_PHONENAME    = 0x00000000,
    ///Phone information string.
    PCS_PHONEINFO    = 0x00000001,
    ///Phone provider string.
    PCS_PROVIDERINFO = 0x00000002,
}

///The <b>PHONECAPS_BUFFER</b> enum is used by methods that set or get phone capabilities described by a buffer.
alias PHONECAPS_BUFFER = int;
enum : int
{
    ///Device-specific phone capabilities.
    PCB_DEVSPECIFICBUFFER = 0x00000000,
}

///The <b>PHONE_BUTTON_STATE</b> enum describes the state of a phone button.
alias PHONE_BUTTON_STATE = int;
enum : int
{
    ///State of the button is up.
    PBS_UP      = 0x00000001,
    ///State of the button is down.
    PBS_DOWN    = 0x00000002,
    ///State of the button is not known.
    PBS_UNKNOWN = 0x00000004,
    ///State of the button is not available.
    PBS_UNAVAIL = 0x00000008,
}

///The <b>PHONE_BUTTON_MODE</b> enum describes the mode of a phone button.
alias PHONE_BUTTON_MODE = int;
enum : int
{
    ///Dummy button.
    PBM_DUMMY   = 0x00000000,
    ///Call button.
    PBM_CALL    = 0x00000001,
    ///Feature button.
    PBM_FEATURE = 0x00000002,
    ///Keypad button.
    PBM_KEYPAD  = 0x00000003,
    ///Local function button, such as mute or volume control.
    PBM_LOCAL   = 0x00000004,
    ///Display button.
    PBM_DISPLAY = 0x00000005,
}

///The <b>PHONE_BUTTON_FUNCTION</b> enum provides detailed information on a button's function.
alias PHONE_BUTTON_FUNCTION = int;
enum : int
{
    ///A "dummy" function assignment that indicates that the exact function of the button is unknown or has not been
    ///assigned.
    PBF_UNKNOWN      = 0x00000000,
    ///Initiates a conference call or adds a call to a conference call.
    PBF_CONFERENCE   = 0x00000001,
    ///Initiates a call transfer or completes the transfer of a call.
    PBF_TRANSFER     = 0x00000002,
    ///Drops the active call.
    PBF_DROP         = 0x00000003,
    ///Places the active call on hold.
    PBF_HOLD         = 0x00000004,
    ///Takes a call off hold.
    PBF_RECALL       = 0x00000005,
    ///Disconnects a call, such as after initiating a transfer.
    PBF_DISCONNECT   = 0x00000006,
    ///Reconnects a call that is on consultation hold.
    PBF_CONNECT      = 0x00000007,
    ///Turns on a message waiting lamp.
    PBF_MSGWAITON    = 0x00000008,
    ///Turns off a message waiting lamp.
    PBF_MSGWAITOFF   = 0x00000009,
    ///Allows the user to select the ring pattern of the phone.
    PBF_SELECTRING   = 0x0000000a,
    ///Indicates that the number to be dialed will be a short, abbreviated number consisting of one digit or a few
    ///digits.
    PBF_ABBREVDIAL   = 0x0000000b,
    ///Initiates or changes call forwarding to this phone.
    PBF_FORWARD      = 0x0000000c,
    ///Picks up a call ringing on another phone.
    PBF_PICKUP       = 0x0000000d,
    ///Initiates a request to be notified if a call cannot be completed normally because of a busy signal or no answer.
    PBF_RINGAGAIN    = 0x0000000e,
    ///Parks the active call on another phone, placing it on hold there.
    PBF_PARK         = 0x0000000f,
    ///Rejects an incoming call before the call has been answered.
    PBF_REJECT       = 0x00000010,
    ///Redirects an incoming call to another extension before the call has been answered.
    PBF_REDIRECT     = 0x00000011,
    ///Mutes the phone's microphone device.
    PBF_MUTE         = 0x00000012,
    ///Increases the volume of audio through the phone's handset speaker or speakerphone.
    PBF_VOLUMEUP     = 0x00000013,
    ///Decreases the volume of audio through the phone's handset speaker or speakerphone.
    PBF_VOLUMEDOWN   = 0x00000014,
    ///Turns the phone's external speaker on.
    PBF_SPEAKERON    = 0x00000015,
    ///Turns the phone's external speaker off.
    PBF_SPEAKEROFF   = 0x00000016,
    ///Generates the equivalent of an onhook/offhook sequence. A flash typically indicates that any digits typed next
    ///are to be understood as commands to the switch. On many switches, places an active call on consultation hold.
    PBF_FLASH        = 0x00000017,
    ///Indicates that the next call is a data call.
    PBF_DATAON       = 0x00000018,
    ///Indicates that the next call is not a data call.
    PBF_DATAOFF      = 0x00000019,
    ///Places the phone in "do not disturb" mode; incoming calls receive a busy signal or are forwarded to an operator
    ///or voicemail system.
    PBF_DONOTDISTURB = 0x0000001a,
    ///Connects to the intercom to broadcast a page.
    PBF_INTERCOM     = 0x0000001b,
    ///Selects a particular appearance of a bridged address.
    PBF_BRIDGEDAPP   = 0x0000001c,
    ///Makes the phone appear "busy" to incoming calls.
    PBF_BUSY         = 0x0000001d,
    ///Selects a particular call appearance.
    PBF_CALLAPP      = 0x0000001e,
    ///Causes the phone to display the current date and time; this information would be sent by the switch.
    PBF_DATETIME     = 0x0000001f,
    ///Calls up directory service from the switch.
    PBF_DIRECTORY    = 0x00000020,
    ///Forwards all calls destined for this phone to another phone used for coverage.
    PBF_COVER        = 0x00000021,
    ///Requests display of the caller ID on the phone's display.
    PBF_CALLID       = 0x00000022,
    ///Redials the last number dialed.
    PBF_LASTNUM      = 0x00000023,
    ///Places the phone in the mode it is configured for during night hours.
    PBF_NIGHTSRV     = 0x00000024,
    ///Sends all calls to another phone used for coverage; same as the PHONEBUTTONFUNCTION_COVER constant.
    PBF_SENDCALLS    = 0x00000025,
    ///Controls the message indicator lamp.
    PBF_MSGINDICATOR = 0x00000026,
    ///Repertory dialingthe number to be dialed is provided as a shorthand following the pressing of this button.
    PBF_REPDIAL      = 0x00000027,
    ///Programs the shorthand-to-phone number mappings accessible by means of repertory dialing (the "REPDIAL" button).
    PBF_SETREPDIAL   = 0x00000028,
    ///The number to be dialed is provided as a shorthand following the pressing of this button. The mappings for system
    ///speed dialing are configured inside the switch.
    PBF_SYSTEMSPEED  = 0x00000029,
    ///The number to be dialed is provided as a shorthand following pressing of this button. The mappings for station
    ///speed dialing are specific to this station (phone).
    PBF_STATIONSPEED = 0x0000002a,
    ///Camps on an extension that returns a busy indication. When the remote station returns to idle, the phone will be
    ///rung with a distinctive pattern. Picking up the local phone reinitiates the call.
    PBF_CAMPON       = 0x0000002b,
    ///When pressed while a call or call attempt is active, it will remember that call's number or command. When pressed
    ///while no call is active (such as during dial tone), it repeats the most recently saved command.
    PBF_SAVEREPEAT   = 0x0000002c,
    ///Queues a call to an outside number after it encounters a trunk-busy indication. When a trunk becomes available
    ///later, the phone will be rung with a distinctive pattern. Picking up the local phone reinitiates the call.
    PBF_QUEUECALL    = 0x0000002d,
    ///A "dummy" function assignment that indicates that the button does not have a function.
    PBF_NONE         = 0x0000002e,
    ///Sends a request for a communications session.
    PBF_SEND         = 0x0000002f,
}

///The <b>PHONE_TONE</b> enum identifies a phone tone.
alias PHONE_TONE = int;
enum : int
{
    ///Zero.
    PT_KEYPADZERO       = 0x00000000,
    ///One.
    PT_KEYPADONE        = 0x00000001,
    ///Two.
    PT_KEYPADTWO        = 0x00000002,
    ///Three.
    PT_KEYPADTHREE      = 0x00000003,
    ///Four.
    PT_KEYPADFOUR       = 0x00000004,
    ///Five.
    PT_KEYPADFIVE       = 0x00000005,
    ///Six.
    PT_KEYPADSIX        = 0x00000006,
    ///Seven.
    PT_KEYPADSEVEN      = 0x00000007,
    ///Eight.
    PT_KEYPADEIGHT      = 0x00000008,
    ///Nine.
    PT_KEYPADNINE       = 0x00000009,
    ///Star key.
    PT_KEYPADSTAR       = 0x0000000a,
    ///Pound sign key.
    PT_KEYPADPOUND      = 0x0000000b,
    ///Supplemental A.
    PT_KEYPADA          = 0x0000000c,
    ///Supplemental B.
    PT_KEYPADB          = 0x0000000d,
    ///Supplemental C.
    PT_KEYPADC          = 0x0000000e,
    ///Supplemental D.
    PT_KEYPADD          = 0x0000000f,
    ///Normal dial tone.
    PT_NORMALDIALTONE   = 0x00000010,
    ///External dial tone.
    PT_EXTERNALDIALTONE = 0x00000011,
    ///Busy signal tone.
    PT_BUSY             = 0x00000012,
    ///Ringback tone.
    PT_RINGBACK         = 0x00000013,
    ///Error tone.
    PT_ERRORTONE        = 0x00000014,
    ///No tone.
    PT_SILENCE          = 0x00000015,
}

///The <b>PHONE_EVENT</b> enum indicates a type of phone event.
alias PHONE_EVENT = int;
enum : int
{
    ///Phone display has changed.
    PE_DISPLAY        = 0x00000000,
    ///Lamp mode has changed.
    PE_LAMPMODE       = 0x00000001,
    ///Ringing mode has changed.
    PE_RINGMODE       = 0x00000002,
    ///Ringing volume has changed.
    PE_RINGVOLUME     = 0x00000003,
    ///Hookswitch status has changed.
    PE_HOOKSWITCH     = 0x00000004,
    ///Phone capabilities have changed.
    PE_CAPSCHANGE     = 0x00000005,
    ///The phone button has changed.
    PE_BUTTON         = 0x00000006,
    ///The phone has been closed.
    PE_CLOSE          = 0x00000007,
    ///A dialed number has been gathered by the phone.
    PE_NUMBERGATHERED = 0x00000008,
    ///The phone is dialing.
    PE_DIALING        = 0x00000009,
    ///The phone has been answered.
    PE_ANSWER         = 0x0000000a,
    ///The phone has been disconnected.
    PE_DISCONNECT     = 0x0000000b,
    ///Last item in enum. Allows device-specific additions to this enum.
    PE_LASTITEM       = 0x0000000b,
}

///The <b>TERMINAL_MEDIA_STATE</b> enum indicates the state of a file terminal.
alias TERMINAL_MEDIA_STATE = int;
enum : int
{
    ///The file terminal is idle.
    TMS_IDLE     = 0x00000000,
    ///The file terminal is active.
    TMS_ACTIVE   = 0x00000001,
    ///The file terminal is paused.
    TMS_PAUSED   = 0x00000002,
    ///Last item in this enum.
    TMS_LASTITEM = 0x00000002,
}

///The <b>FT_STATE_EVENT_CAUSE</b> enum indicates the type of file terminal event.
alias FT_STATE_EVENT_CAUSE = int;
enum : int
{
    ///State change in response to a normal API call.
    FTEC_NORMAL      = 0x00000000,
    ///Storage EOF reached on playback.
    FTEC_END_OF_FILE = 0x00000001,
    ///Storage read error on playback.
    FTEC_READ_ERROR  = 0x00000002,
    ///Storage write error on the record.
    FTEC_WRITE_ERROR = 0x00000003,
}

///The <b>AGENT_EVENT</b> enum describes agent events. The ITAgentEvent::get_Event method returns a member of this enum
///to indicate the type of agent event that occurred.
alias AGENT_EVENT = int;
enum : int
{
    ///The agent is unable to handle calls.
    AE_NOT_READY     = 0x00000000,
    ///The agent is able to handle calls.
    AE_READY         = 0x00000001,
    ///The agent is active handling an ACD call.
    AE_BUSY_ACD      = 0x00000002,
    ///The agent is active handling an incoming non-ACD call.
    AE_BUSY_INCOMING = 0x00000003,
    ///The agent is active handling an outgoing non-ACD call.
    AE_BUSY_OUTGOING = 0x00000004,
    ///Unknown state.
    AE_UNKNOWN       = 0x00000005,
}

///The <b>AGENT_STATE</b> enum is used by the ITAgent::put_State and ITAgent::get_State methods to describe the agent
///state.
alias AGENT_STATE = int;
enum : int
{
    ///Agent is not ready
    AS_NOT_READY     = 0x00000000,
    ///Agent is ready
    AS_READY         = 0x00000001,
    ///Agent is busy with an ACD call.
    AS_BUSY_ACD      = 0x00000002,
    ///Agent has a call incoming.
    AS_BUSY_INCOMING = 0x00000003,
    ///Agent has a call that is outgoing.
    AS_BUSY_OUTGOING = 0x00000004,
    ///Agent state unknown.
    AS_UNKNOWN       = 0x00000005,
}

///The <b>AGENT_SESSION_EVENT</b> enum describes agent session events. The ITAgentSessionEvent::get_Event method returns
///a member of this enum to indicate the type of agent session event that occurred.
alias AGENT_SESSION_EVENT = int;
enum : int
{
    ///A new agent session has been created.
    ASE_NEW_SESSION = 0x00000000,
    ///The agent is unable to handle calls for this session.
    ASE_NOT_READY   = 0x00000001,
    ///The agent is able to handle calls for this session.
    ASE_READY       = 0x00000002,
    ///The agent is active in this session handling an ACD call.
    ASE_BUSY        = 0x00000003,
    ///The agent is active in this session handling the wrap-up of an ACD call.
    ASE_WRAPUP      = 0x00000004,
    ///The session has completed.
    ASE_END         = 0x00000005,
}

///This <b>AGENT_SESSION_STATE</b> enum defines the agent session indicators used by the ITAgentSession::get_State and
///the ITAgentSession::put_State methods.
alias AGENT_SESSION_STATE = int;
enum : int
{
    ///The agent is unable to handle calls for this session.
    ASST_NOT_READY     = 0x00000000,
    ///The agent is able to handle calls for this session.
    ASST_READY         = 0x00000001,
    ///The agent is active in this session handling an ACD call.
    ASST_BUSY_ON_CALL  = 0x00000002,
    ///The agent is active in this session handling the wrap-up of an ACD call.
    ASST_BUSY_WRAPUP   = 0x00000003,
    ///The session has completed.
    ASST_SESSION_ENDED = 0x00000004,
}

///The <b>AGENTHANDLER_EVENT</b> enum describes agent handler events. The ITAgentHandlerEvent::get_Event method returns
///a member of this enum to indicate the type of agent handler event that occurred.
alias AGENTHANDLER_EVENT = int;
enum : int
{
    ///A new AgentHandler object has been added.
    AHE_NEW_AGENTHANDLER     = 0x00000000,
    ///An AgentHandler object has been removed.
    AHE_AGENTHANDLER_REMOVED = 0x00000001,
}

///The <b>ACDGROUP_EVENT</b> enum describes ACD group events. The ITACDGroupEvent::get_Event method returns a member of
///this enum to indicate the type of ACD group event that occurred.
alias ACDGROUP_EVENT = int;
enum : int
{
    ///A new ACD group has been added.
    ACDGE_NEW_GROUP     = 0x00000000,
    ///An ACD group has been removed.
    ACDGE_GROUP_REMOVED = 0x00000001,
}

///The <b>ACDQUEUE_EVENT</b> enum describes ACD queue events. The ITQueueEvent::get_Event method returns a member of
///this enum to indicate the type of ACD queue event that occurred.
alias ACDQUEUE_EVENT = int;
enum : int
{
    ///A new ACD queue has been added.
    ACDQE_NEW_QUEUE     = 0x00000000,
    ///An ACD queue has been removed.
    ACDQE_QUEUE_REMOVED = 0x00000001,
}

///The <b>MSP_ADDRESS_EVENT</b> constant is returned within the MSP_EVENT_INFO struct by the GetEvent method when
///MSP_EVENT is ME_ADDRESS_EVENT.
alias MSP_ADDRESS_EVENT = int;
enum : int
{
    ///A new terminal arrived by PNP.
    ADDRESS_TERMINAL_AVAILABLE   = 0x00000000,
    ///A terminal has been removed by PNP.
    ADDRESS_TERMINAL_UNAVAILABLE = 0x00000001,
}

///The <b>MSP_CALL_EVENT</b> constant is returned within the MSP_EVENT_INFO struct by the GetEvent method when MSP_EVENT
///is ME_CALL_EVENT.
alias MSP_CALL_EVENT = int;
enum : int
{
    ///A new stream is created by the call. The application can choose to select a terminal or delete the stream from
    ///the call.
    CALL_NEW_STREAM      = 0x00000000,
    ///Setup of the stream failed or the stream fails to start.
    CALL_STREAM_FAIL     = 0x00000001,
    ///The terminal failed to connect.
    CALL_TERMINAL_FAIL   = 0x00000002,
    ///The stream is not used in the call (the remote party rejected it).
    CALL_STREAM_NOT_USED = 0x00000003,
    ///The application needs this event to decide when a stream can be used to send and receive data. It is fired when
    ///the streams enter running state (the timing of which is determined by the TSP).
    CALL_STREAM_ACTIVE   = 0x00000004,
    ///No more data can be sent to or received from this stream. This happens when a send stream has sent all its data,
    ///or when a receive stream stops receiving data.
    CALL_STREAM_INACTIVE = 0x00000005,
}

///The <b>MSP_CALL_EVENT_CAUSE</b> constant is returned within the MSP_EVENT_INFO struct by the GetEvent method when
///MSP_EVENT is ME_CALL_EVENT.
alias MSP_CALL_EVENT_CAUSE = int;
enum : int
{
    ///Call event cause is unknown.
    CALL_CAUSE_UNKNOWN            = 0x00000000,
    ///A bad device caused failure, for either STREAM_FAIL or TERMINAL_FAIL.
    CALL_CAUSE_BAD_DEVICE         = 0x00000001,
    ///Either connecting the stream failed or connecting the terminal failed. Note that if a terminal cannot be
    ///connected to a stream, the application will get a TERMINAL_FAIL event with CMC_CONNECT_FAIL. If this stream
    ///failed because the terminal is the only one to use, the application will also get a STREAM_FAIL event with
    ///CMC_CONNECT_FAIL.
    CALL_CAUSE_CONNECT_FAIL       = 0x00000002,
    ///The event is the result of the application calling a method on the stream.
    CALL_CAUSE_LOCAL_REQUEST      = 0x00000003,
    ///The event is the result of the remote endpoint's request.
    CALL_CAUSE_REMOTE_REQUEST     = 0x00000004,
    ///The media that carries the stream is temporarily not available.
    CALL_CAUSE_MEDIA_TIMEOUT      = 0x00000005,
    ///The media that carries the stream is back to normal from a temporary denial of service.
    CALL_CAUSE_MEDIA_RECOVERED    = 0x00000006,
    CALL_CAUSE_QUALITY_OF_SERVICE = 0x00000007,
}

///The <b>MSP_EVENT</b> enumerator defines the type of event information contained in MSP_EVENT_INFO.
alias MSP_EVENT = int;
enum : int
{
    ///The event buffer is an MSP_ADDRESS_EVENT_INFO structure.
    ME_ADDRESS_EVENT       = 0x00000000,
    ///The event buffer is an MSP_CALL_EVENT_INFO structure.
    ME_CALL_EVENT          = 0x00000001,
    ///The event buffer is an MSP_TSP_DATA structure.
    ME_TSP_DATA            = 0x00000002,
    ///The event buffer is an MSP_PRIVATE_EVENT_INFO structure.
    ME_PRIVATE_EVENT       = 0x00000003,
    ME_ASR_TERMINAL_EVENT  = 0x00000004,
    ME_TTS_TERMINAL_EVENT  = 0x00000005,
    ME_FILE_TERMINAL_EVENT = 0x00000006,
    ME_TONE_TERMINAL_EVENT = 0x00000007,
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] The <b>DIRECTORY_TYPE</b> enum is used to indicate the type of directory server.
alias DIRECTORY_TYPE = int;
enum : int
{
    ///Directory type is NTDS.
    DT_NTDS = 0x00000001,
    ///Directory type is ILS. The ILS directory type is valid only for Windows 2000 and not for Windows XP.
    DT_ILS  = 0x00000002,
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] The <b>DIRECTORY_OBJECT_TYPE</b> enum is a descriptor of whether a directory object is a
///conference or a user.
alias DIRECTORY_OBJECT_TYPE = int;
enum : int
{
    ///Conference.
    OT_CONFERENCE = 0x00000001,
    ///User.
    OT_USER       = 0x00000002,
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] Members of the <b>RND_ADVERTISING_SCOPE</b> enumeration specify how widely a conference
///announcement is distributed. Values correspond to the advertising scope property on the ITDirectoryObjectConference
///interface.
alias RND_ADVERTISING_SCOPE = int;
enum : int
{
    ///Advertising scope is local.
    RAS_LOCAL  = 0x00000001,
    ///Advertising scope is site.
    RAS_SITE   = 0x00000002,
    ///Advertising scope is country or region.
    RAS_REGION = 0x00000003,
    ///Advertising scope is the world.
    RAS_WORLD  = 0x00000004,
}

// Callbacks

///The <b>lineCallback</b> function is a placeholder for the application-supplied function name.
///Params:
///    hDevice = Handle to either a line device or a call associated with the callback. The nature of this handle (line handle or
///              call handle) can be determined by the context provided by <i>dwMsg</i>. Applications must use the <b>DWORD</b>
///              type for this parameter because using the <b>HANDLE</b> type may generate an error.
///    dwMessage = 
///    dwInstance = 
///    dwParam1 = Parameter for the message.
///    dwParam2 = Parameter for the message.
///    dwParam3 = Parameter for the message.
alias LINECALLBACK = void function(uint hDevice, uint dwMessage, size_t dwInstance, size_t dwParam1, 
                                   size_t dwParam2, size_t dwParam3);
///The <b>phoneCallback</b> function is a placeholder for the application-supplied function name.
///Params:
///    hDevice = Handle to a phone device associated with the callback.
///    dwMessage = 
///    dwInstance = 
///    dwParam1 = Parameter for the message.
///    dwParam2 = Parameter for the message.
///    dwParam3 = Parameter for the message.
alias PHONECALLBACK = void function(uint hDevice, uint dwMessage, size_t dwInstance, size_t dwParam1, 
                                    size_t dwParam2, size_t dwParam3);

// Structs


///The <b>LINEADDRESSCAPS</b> structure describes the capabilities of a specified address. The lineGetAddressCaps
///function and the TSPI_lineGetAddressCaps function return the <b>LINEADDRESSCAPS</b> structure.
struct LINEADDRESSCAPS
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size for this data structure that is needed to hold all the returned information, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Device identifier of the line device with which this address is associated.
    uint dwLineDeviceID;
    ///Size of the address field, in bytes.
    uint dwAddressSize;
    ///Offset from the beginning of the structure to the variably sized address field. The size of the field is
    ///specified by <b>dwAddressSize</b>.
    uint dwAddressOffset;
    ///Size of the device-specific field, in bytes.
    uint dwDevSpecificSize;
    ///Offset from the beginning of the structure to the variably sized device-specific field. The size of the field is
    ///specified by <b>dwDevSpecificSize</b>.
    uint dwDevSpecificOffset;
    ///Sharing mode of the address. This member can be one of the LINEADDRESSSHARING_ Constants.
    uint dwAddressSharing;
    ///Address states changes for which the application may get notified in the LINE_ADDRESSSTATE message. This member
    ///uses one or more of the LINEADDRESSSTATE_ constants.
    uint dwAddressStates;
    ///Call information elements that are meaningful for all calls on this address. An application may get notified
    ///about changes in some of these states in LINE_CALLINFO messages. This member uses one or more of the
    ///LINECALLINFOSTATE_ constants.
    uint dwCallInfoStates;
    ///Party identifier information types that can be provided for calls on this address. The caller is the originator
    ///of the session. One or more of the LINECALLPARTYID_ constants.
    uint dwCallerIDFlags;
    ///Party identifier information types that can be provided for calls on this address. Here, "called" refers to the
    ///original destination. One or more of the LINECALLPARTYID_ constants.
    uint dwCalledIDFlags;
    ///Party identifier information types that can be provided for calls on this address. One or more of the
    ///LINECALLPARTYID_ constants.
    uint dwConnectedIDFlags;
    ///Party identifier information types that can be provided for calls on this address. Here, "redirection" is the new
    ///destination. One or more of the LINECALLPARTYID_ constants.
    uint dwRedirectionIDFlags;
    ///Party identifier information types that can be provided for calls on this address. Here, "redirecting" is the
    ///address which invoked redirection. One or more of the LINECALLPARTYID_ constants.
    uint dwRedirectingIDFlags;
    ///Call states that can be reported for calls on this address. This member uses one or more of the LINECALLSTATE_
    ///constants.
    uint dwCallStates;
    ///Dial tone modes that can be reported for calls made on this address. This member is meaningful only if the
    ///<i>dialtone</i> call state can be reported. This member uses one or more of the LINEDIALTONEMODE_ constants.
    uint dwDialToneModes;
    ///Busy modes that can be reported for calls made on this address. This member is meaningful only if the <i>busy</i>
    ///call state can be reported. This member uses one or more of the LINEBUSYMODE_ constants.
    uint dwBusyModes;
    ///Special information types that can be reported for calls made on this address. This member is meaningful only if
    ///the <i>specialInfo</i> call state can be reported. This member uses one or more of the LINESPECIALINFO_
    ///constants.
    uint dwSpecialInfo;
    ///Disconnect modes that can be reported for calls made on this address. This member is meaningful only if the
    ///<i>disconnected</i> call state can be reported. This member uses one or more of the LINEDISCONNECTMODE_
    ///constants.
    uint dwDisconnectModes;
    ///Maximum number of active call appearances that the address can handle. This number does not include calls on hold
    ///or calls on hold pending transfer or conference.
    uint dwMaxNumActiveCalls;
    ///Maximum number of call appearances at the address that can be on hold.
    uint dwMaxNumOnHoldCalls;
    ///Maximum number of call appearances at the address that can be on hold pending transfer or conference.
    uint dwMaxNumOnHoldPendingCalls;
    ///Maximum number of parties that can join a single conference call on this address.
    uint dwMaxNumConference;
    ///Number of parties (including "self") that can be added in a conference call that is initiated as a generic
    ///consultation call using lineSetupTransfer.
    uint dwMaxNumTransConf;
    ///Packed bit flags that describe a variety of address capabilities. This member uses one or more of the
    ///LINEADDRCAPFLAGS_ constants.
    uint dwAddrCapFlags;
    ///Switching capabilities or features available for all calls on this address using the LINECALLFEATURE_ Constants.
    ///This member represents the call-related features that may possibly be available on an address (static
    ///availability as opposed to dynamic availability). Invoking a supported feature requires the call to be in the
    ///proper state and the underlying line device to be opened in a compatible mode. A zero in a bit position indicates
    ///that the corresponding feature is never available. A one indicates that the corresponding feature may be
    ///available if the application has the right privileges to the call and the call is in the appropriate state for
    ///the operation to be meaningful. This member allows an application to discover which call features can be (and
    ///which can never be) supported by the address.
    uint dwCallFeatures;
    ///Address's capabilities for removing calls from a conference call. This member uses one of the LINEREMOVEFROMCONF_
    ///constants.
    uint dwRemoveFromConfCaps;
    ///Uses the LINECALLSTATE_ constants to specify the state of the call after it has been removed from a conference
    ///call.
    uint dwRemoveFromConfState;
    ///Address's capabilities for resolving transfer requests. This member uses one of the LINETRANSFERMODE_ constants.
    uint dwTransferModes;
    ///Different call park modes available at this address. This member uses one of the LINEPARKMODE_ constants.
    uint dwParkModes;
    ///Different modes of forwarding available for this address. This member uses the LINEFORWARDMODE_ constants.
    uint dwForwardModes;
    ///Maximum number of entries that can be passed to lineForward in the <i>lpForwardList</i> parameter.
    uint dwMaxForwardEntries;
    ///Maximum number of entries in the <i>lpForwardList</i> parameter passed to lineForward that can contain forwarding
    ///instructions based on a specific caller ID (selective call forwarding). This member is zero if selective call
    ///forwarding is not supported.
    uint dwMaxSpecificEntries;
    ///Minimum number of rings that can be set to determine when a call is officially considered "no answer."
    uint dwMinFwdNumRings;
    ///Maximum number of rings that can be set to determine when a call is officially considered "no answer." If this
    ///number of rings cannot be set, then <b>dwMinFwdNumRings</b> and <b>dwMaxNumRings</b> are equal.
    uint dwMaxFwdNumRings;
    ///Maximum number of concurrent call completion requests that can be outstanding on this line device. Zero implies
    ///that call completion is not available.
    uint dwMaxCallCompletions;
    ///Different call conditions under which call completion can be requested. This member uses one or more of the
    ///LINECALLCOMPLCOND_ constants.
    uint dwCallCompletionConds;
    ///Way in which the call can be completed. This member uses one of the LINECALLCOMPLMODE_ constants.
    uint dwCallCompletionModes;
    ///Number of call completion messages that can be selected from when using the LINECALLCOMPLMODE_MESSAGE option.
    ///Individual messages are identified by values in the range zero through one less than
    ///<b>dwNumCompletionMessages</b>.
    uint dwNumCompletionMessages;
    ///Size of each of the call completion text descriptions specified by <b>dwCompletionMsgTextSize</b> and
    ///<b>dwCompletionMsgTextOffset</b>, in bytes.
    uint dwCompletionMsgTextEntrySize;
    ///Size of the call completion text, in bytes.
    uint dwCompletionMsgTextSize;
    ///Offset from the beginning of this data structure to the variably sized field containing descriptive text about
    ///each of the call completion messages. Each message is <b>dwCompletionMsgTextEntrySize</b> bytes long. The string
    ///format of these textual descriptions is indicated by <b>dwStringFormat</b> in the line's device capabilities. The
    ///size of the field is specified by <b>dwCompletionMsgTextSize</b>.
    uint dwCompletionMsgTextOffset;
    ///Features available for this address using the LINEADDRFEATURE_ Constants. Invoking a supported feature requires
    ///the address to be in the proper state and the underlying line device to be opened in a compatible mode. A zero in
    ///a bit position indicates that the corresponding feature is never available. A one indicates that the
    ///corresponding feature may be available if the address is in the appropriate state for the operation to be
    ///meaningful. This member allows an application to discover which address features can be (and which can never be)
    ///supported by the address.
    uint dwAddressFeatures;
    ///Call state or states upon which a call made by a predictive dialer can be set to automatically transfer the call
    ///to another address; one or more of the LINECALLSTATE_ Constants. The value 0 indicates automatic transfer based
    ///on call state is unavailable.
    uint dwPredictiveAutoTransferStates;
    ///Number of entries in the array of LINECALLTREATMENTENTRY structures delimited by <b>dwCallTreatmentListSize</b>
    ///and <b>dwCallTreatmentListOffset</b>.
    uint dwNumCallTreatments;
    ///Size of the call treatment array, in bytes.
    uint dwCallTreatmentListSize;
    ///Offset from the beginning of the structure to an array of LINECALLTREATMENTENTRY structures the specify the call
    ///treatments supported on the address (that can be selected using lineSetCallTreatment). The value is
    ///<b>dwNumCallTreatments</b> times SIZEOF(LINECALLTREATMENTENTRY). The size of the field is specified by
    ///<b>dwCallTreatmentListSize</b>.
    uint dwCallTreatmentListOffset;
    ///Size of the list of supported device classes, in bytes.
    uint dwDeviceClassesSize;
    ///Offset from the beginning of the structure to a string consisting of the device class identifiers supported on
    ///this address for use with lineGetID. The elements are separated by <b>null</b> characters, and the last class
    ///identifier is followed by two <b>null</b> characters. The size of the field is specified by
    ///<b>dwDeviceClassesSize</b>.
    uint dwDeviceClassesOffset;
    ///Maximum number of bytes that an application can set in LINECALLINFO using lineSetCallData.
    uint dwMaxCallDataSize;
    ///Additional switching capabilities or features available for all calls on this address using the LINECALLFEATURE2_
    ///Constants. It is an extension of the <b>dwCallFeatures</b> member.
    uint dwCallFeatures2;
    ///Maximum value in seconds that can be set in the <b>dwNoAnswerTimeout</b> member in LINECALLPARAMS when making a
    ///call. A value of 0 indicates that automatic abandonment of unanswered calls is not supported by the service
    ///provider, or that the timeout value is not adjustable by applications.
    uint dwMaxNoAnswerTimeout;
    ///LINECONNECTEDMODE_ values that can appear in the <b>dwCallStateMode</b> member of LINECALLSTATUS and in
    ///LINE_CALLSTATE messages for calls on this address.
    uint dwConnectedModes;
    ///LINEOFFERINGMODE_ values that can appear in the <b>dwCallStateMode</b> member of LINECALLSTATUS and in
    ///LINE_CALLSTATE messages for calls on this address.
    uint dwOfferingModes;
    ///Media types (modes) that can be invoked on new calls created on this address, when the <b>dwAddressFeatures</b>
    ///member indicates that new calls are possible. If this member is zero, it indicates that the service provider
    ///either does not know or cannot indicate which media types are available, in which case any or all of the media
    ///types indicated in the <b>dwMediaModes</b> member in LINEDEVCAPS may be available.
    uint dwAvailableMediaModes;
}

///The <b>LINEADDRESSSTATUS</b> structure describes the current status of an address. The lineGetAddressStatus function
///and the TSPI_lineGetAddressStatus function return the <b>LINEADDRESSSTATUS</b> structure.
struct LINEADDRESSSTATUS
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size for this data structure that is needed to hold all the returned information, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Number of stations that are currently using the address.
    uint dwNumInUse;
    ///Number of calls on the address that are in call states other than <i>idle</i>, <i>onhold</i>,
    ///<i>onholdpendingtransfer</i>, and <i>onholdpendingconference</i>.
    uint dwNumActiveCalls;
    ///Number of calls on the address in the <i>onhold</i> state.
    uint dwNumOnHoldCalls;
    ///Number of calls on the address in the <i>onholdpendingtransfer</i> or <i>onholdpendingconference</i> state.
    uint dwNumOnHoldPendCalls;
    ///Address-related functions that can be invoked on the address in its current state. This member uses one or more
    ///of the LINEADDRFEATURE_ constants.
    uint dwAddressFeatures;
    ///Number of rings set for this address before an unanswered call is considered as no answer.
    uint dwNumRingsNoAnswer;
    ///Number of entries in the array referred to by <b>dwForwardSize</b> and <b>dwForwardOffset</b>.
    uint dwForwardNumEntries;
    ///Size of the forwarding information array, in bytes.
    uint dwForwardSize;
    ///Offset from the beginning of the structure to the variably sized field that describes the address's forwarding
    ///information. This information is an array of <b>dwForwardNumEntries</b> elements, of type LINEFORWARD. The
    ///offsets of the addresses in the array are relative to the beginning of the <b>LINEADDRESSSTATUS</b> structure.
    ///The offsets <b>dwCallerAddressOffset</b> and <b>dwDestAddressOffset</b> in the variably sized field of type
    ///<b>LINEFORWARD</b> pointed to by <i>dwForwardOffset</i> are relative to the beginning of the
    ///<b>LINEADDRESSSTATUS</b> data structure (the "root" container). The size of the array is specified by
    ///<b>dwForwardSize</b>.
    uint dwForwardOffset;
    ///Size of the terminal modes array, in bytes.
    uint dwTerminalModesSize;
    ///Offset from the beginning of the structure to the variably sized device field containing an array with
    ///<b>DWORD</b>-sized entries, that use one or more of the LINETERMMODE_ constants. This array is indexed by
    ///terminal identifiers, in the range from zero to one less than <b>dwNumTerminals</b>. Each entry in the array
    ///specifies the current terminal modes for the corresponding terminal set with the lineSetTerminal function for
    ///this address. The size of the array is specified by <b>dwTerminalModesSize</b>.
    uint dwTerminalModesOffset;
    ///Size of the device-specific field, in bytes.
    uint dwDevSpecificSize;
    ///Offset from the beginning of this structure to the variably sized device-specific field. The size of the field is
    ///specified by <b>dwDevSpecificSize</b>.
    uint dwDevSpecificOffset;
}

///The <b>LINEAGENTACTIVITYENTRY</b> structure describes a single ACD agent activity. The LINEAGENTACTIVITYLIST
///structure can contain an array of <b>LINEAGENTACTIVITYENTRY</b> structures.
struct LINEAGENTACTIVITYENTRY
{
align (1):
    ///Unique identifier for an activity. It is the responsibility of the agent handler to generate and maintain
    ///uniqueness of this identifier.
    uint dwID;
    ///Size of the activity name including the <b>null</b> terminator, in bytes.
    uint dwNameSize;
    ///Offset from the beginning of this structure to a <b>null</b>-terminated string specifying the name and other
    ///identifying information of an activity that can be selected by calling the lineSetAgentActivity function. The
    ///size of the string is specified by <b>dwNameSize</b>.
    uint dwNameOffset;
}

///The <b>LINEAGENTACTIVITYLIST</b> structure describes a list of ACD agent activities. This structure can contain an
///array of LINEAGENTACTIVITYENTRY structures. The lineGetAgentActivityList function returns the
///<b>LINEAGENTACTIVITYLIST</b> structure.
struct LINEAGENTACTIVITYLIST
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size needed to hold all the information requested, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Number of LINEAGENTACTIVITYENTRY structures that appear in the <i>List</i> array. The value is 0 if no agent
    ///activity codes are available.
    uint dwNumEntries;
    ///Size of the activity list array, in bytes.
    uint dwListSize;
    ///Offset from the beginning of the structure to an array of LINEAGENTACTIVITYENTRY structures indicating
    ///information about activity that could be specified for the current logged-in agent. This is <b>dwNumEntries</b>
    ///times SIZEOF(LINEAGENTACTIVITYENTRY). The size of the array is specified by <b>dwListSize</b>.
    uint dwListOffset;
}

///The <b>LINEAGENTCAPS</b> structure describes the capabilities of an ACD agent. The lineGetAgentCaps function returns
///the <b>LINEAGENTCAPS</b> structure.
struct LINEAGENTCAPS
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size needed to hold all the information requested, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Size of the agent handler information, in bytes.
    uint dwAgentHandlerInfoSize;
    ///Offset from the beginning of the structure to a null-terminated string specifying the name, version, or other
    ///identifying information of the server application that is handling agent requests. The size of the string is
    ///specified by <b>dwAgentHandlerInfoSize</b>.
    uint dwAgentHandlerInfoOffset;
    ///TAPI version that the agent handler application used in preparing the contents of this structure. This is no
    ///greater than the API version that the calling application passed in to lineGetAgentCaps.
    uint dwCapsVersion;
    ///Agent-related features available for this line using the LINEAGENTFEATURE_ constants. Invoking a supported
    ///feature requires the line and address to be in the proper state. A zero in a bit position indicates that the
    ///corresponding feature is never available. A one indicates that the corresponding feature may be available if the
    ///line is in the appropriate state for the operation to be meaningful. This field allows an application to discover
    ///which agent features can be (and which can never be) supported by the device.
    uint dwFeatures;
    ///LINEAGENTSTATE_ constants that can be used in the <i>dwAgentState</i> parameter of lineSetAgentState. Setting a
    ///supported state requires the line and address to be in the proper state. A zero in a bit position indicates that
    ///the corresponding state is never available. A one indicates that the corresponding state may be available if the
    ///line is in the appropriate state for the state to be meaningful. This field allows an application to discover
    ///which agent states can be (and which can never be) supported on the device.
    uint dwStates;
    ///LINEAGENTSTATE_ constants that can be used in the <i>dwNextAgentState</i> parameter of lineSetAgentState. Setting
    ///a supported state requires the line and address to be in the proper state. A zero in a bit position indicates
    ///that the corresponding state is never available. A one indicates that the corresponding state may be available if
    ///the line is in the appropriate state for the state to be meaningful. This field allows an application to discover
    ///which agent states can be (and which can never be) supported on the device.
    uint dwNextStates;
    ///Maximum number of agent identifiers that can be logged in on the address simultaneously. Determines the highest
    ///value that can be passed in as the <b>dwNumEntries</b> member in the LINEAGENTGROUPLIST structure to
    ///lineSetAgentGroup.
    uint dwMaxNumGroupEntries;
    ///Indicates the LINEAGENTSTATUS_ constants that can be received by the application in <i>dwParam2</i> of a
    ///LINE_AGENTSTATUS message.
    uint dwAgentStatusMessages;
    ///Number of LINEEXTENSIONID structures that appear in the <i>ExtensionIDList</i> array. The value is 0 if
    ///agent-handler-specific extensions are supported on the address.
    uint dwNumAgentExtensionIDs;
    ///Size of the agent extension IDs array, in bytes.
    uint dwAgentExtensionIDListSize;
    ///Offset from the beginning of the structure to an array of LINEEXTENSIONID structures. The size is
    ///<b>dwNumExtensionIDs</b> times SIZEOF(LINEEXTENSIONID). The array lists the 128-bit universally unique
    ///identifiers for all agent-handler-specific extensions supported by the agent handle for the address. The
    ///extension being used is referenced in the lineAgentSpecific function and LINE_AGENTSPECIFIC message by its
    ///position in this table, the first entry being entry 0, so it is important that the agent handler always present
    ///extension identifiers in this array in the same order. The size of the array is specified by
    ///<b>dwAgentExtensionIDListOffset</b>.
    uint dwAgentExtensionIDListOffset;
    ///GUID for ACD proxy associated with the line. This element is exposed only to applications that negotiate a TAPI
    ///version of 2.2 or higher.
    GUID ProxyGUID;
}

///The <b>LINEAGENTGROUPENTRY</b> structure provides information on ACD agent groups. The LINEAGENTGROUPLIST structure
///can contain an array of <b>LINEAGENTGROUPENTRY</b> structures.
struct LINEAGENTGROUPENTRY
{
align (1):
    struct GroupID
    {
    align (1):
        uint dwGroupID1;
        uint dwGroupID2;
        uint dwGroupID3;
        uint dwGroupID4;
    }
    ///Size of the ACD group or queue name including the <b>null</b> terminator, in bytes.
    uint dwNameSize;
    ///Offset from the beginning of the structure to a <b>null</b>-terminated string specifying the name and other
    ///identifying information of an ACD group or queue into which the agent can log in. This string can contain such
    ///information as supervisor and skill level, to assist the agent in selecting the correct group from a list
    ///displayed on their workstation screen. The size of the field is specified by <b>dwNameSize</b>.
    uint dwNameOffset;
}

///The <b>LINEAGENTGROUPLIST</b> structure describes a list of ACD agent groups. This structure can contain an array of
///LINEAGENTGROUPENTRY structures. Multiple functions use the <b>LINEAGENTGROUPLIST</b> structure; these include the
///lineGetAgentGroupList, lineGetGroupList and lineSetAgentGroup functions.
struct LINEAGENTGROUPLIST
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size needed to hold all the information requested, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Number of LINEAGENTGROUPENTRY structures that appear in the <i>List</i> array. The value is 0 if no agent is to
    ///be logged in on the address.
    uint dwNumEntries;
    ///Size of the group list array, in bytes.
    uint dwListSize;
    ///Offset from the beginning of this structure to an array of LINEAGENTGROUPENTRY structures that specify
    ///information about each group into which the current agent is to be logged in at the address. This is
    ///<b>dwNumEntries</b> times SIZEOF(LINEAGENTGROUPENTRY). The size of the field is specified by <b>dwListSize</b>.
    uint dwListOffset;
}

///The <b>LINEAGENTSTATUS</b> structure describes the current status of an ACD agent. The lineGetAgentStatus function
///returns the <b>LINEAGENTSTATUS</b> structure.
struct LINEAGENTSTATUS
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size needed to hold all the information requested, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Number of LINEAGENTGROUPENTRY structures that appear in the <i>GroupList</i> array. The value is 0 if no agent is
    ///logged in on the address.
    uint dwNumEntries;
    ///Size of the group list array, in bytes.
    uint dwGroupListSize;
    ///Offset from the beginning of this structure to an array of LINEAGENTGROUPENTRY structures. The size is
    ///<b>dwNumEntries</b> times SIZEOF(LINEAGENTGROUPENTRY). The array contains groups into which the agent is
    ///currently logged in on the address. The size of the field is specified by <b>dwGroupListSize</b>.
    uint dwGroupListOffset;
    ///Current state of the agent. One of the LINEAGENTSTATE_ constants.
    uint dwState;
    ///State into which the agent is automatically placed when the current call completes. One of the LINEAGENTSTATE_
    ///constants.
    uint dwNextState;
    ///Identifier of the current agent activity.
    uint dwActivityID;
    ///Size of the agent activity string, in bytes.
    uint dwActivitySize;
    ///Offset from the beginning of the structure to a null-terminated string specifying the current agent activity. The
    ///size of the string is specified by <b>dwActivitySize</b>.
    uint dwActivityOffset;
    ///Agent-related features available at the time the status was obtained, using the LINEAGENTFEATURE_ constants.
    uint dwAgentFeatures;
    ///Agent states that could be selected, at this point in time, using lineSetAgentState. Consists of one or more of
    ///the LINEAGENTSTATE_ constants.
    uint dwValidStates;
    ///Next agent states that could be selected, at this point in time, by calling the lineSetAgentState function.
    ///Consists of one or more of the LINEAGENTSTATE_ constants.
    uint dwValidNextStates;
}

///The <b>LINEAPPINFO</b> structure contains information about the application that is currently running. The
///LINEDEVSTATUS structure can contain an array of <b>LINEAPPINFO</b> structures.
struct LINEAPPINFO
{
align (1):
    ///Size of the computer name string including the <b>null</b> terminator, in bytes.
    uint dwMachineNameSize;
    ///Offset from the beginning of the LINEDEVSTATUS structure to a string specifying the name of the computer on which
    ///the application is executing. The size of the field is specified by <b>dwMachineNameSize</b>.
    uint dwMachineNameOffset;
    ///Size of the user name string including the <b>null</b> terminator, in bytes.
    uint dwUserNameSize;
    ///Offset from the beginning of the LINEDEVSTATUS structure to a string specifying the user name under whose account
    ///the application is running. The size of the field is specified by <b>dwUserNameSize</b>.
    uint dwUserNameOffset;
    ///Size of the module file name string, in bytes.
    uint dwModuleFilenameSize;
    ///Offset from the beginning of LINEDEVSTATUS to a string specifying the module file name of the application. This
    ///string can be used in a call to lineHandoff to perform a directed handoff to the application. The size of the
    ///field is specified by <b>dwModuleFilenameSize</b>.
    uint dwModuleFilenameOffset;
    ///Size of the display name string, in bytes.
    uint dwFriendlyNameSize;
    ///Offset from the beginning of LINEDEVSTATUS to the string provided by the application to lineInitialize or
    ///lineInitializeEx, which should be used in any display to the user. The size of the field is specified by
    ///<b>dwFriendlyNameSize</b>.
    uint dwFriendlyNameOffset;
    ///Media types for which the application has requested ownership of new calls; zero if when it opened the line
    ///<b>dwPrivileges</b> did not include LINECALLPRIVILEGE_OWNER.
    uint dwMediaModes;
    ///If the line handle was opened using LINEOPENOPTION_SINGLEADDRESS, contains the address identifier specified; set
    ///to 0xFFFFFFFF if the single address option was not used. An address identifier is permanently associated with an
    ///address; the identifier remains constant across operating system upgrades.
    uint dwAddressID;
}

///The <b>LINEAGENTENTRY</b> structure describes an individual ACD agent. The LINEAGENTLIST structure can contain an
///array of <b>LINEAGENTENTRY</b> structures.
struct LINEAGENTENTRY
{
align (1):
    ///Unique identifier for an agent. It is the responsibility of the agent handler to generate and maintain uniqueness
    ///of these identifiers.
    uint hAgent;
    ///Size of the agent name string including the <b>null</b> terminator, in bytes.
    uint dwNameSize;
    ///Offset from the beginning of the structure to a <b>null</b>-terminated string that specifies the name of the
    ///agent, which is also the operating system's user name. The size of the string is specified by <b>dwNameSize</b>.
    uint dwNameOffset;
    ///Size of the ID string including the <b>null</b> terminator, in bytes.
    uint dwIDSize;
    ///Offset from the beginning of the structure to a <b>null</b>-terminated string that specifies the ID of the agent.
    ///Used by legacy ACD systems to identify the agent. The size of the string is specified by <b>dwIDSize</b>.
    uint dwIDOffset;
    ///Size of the PIN string, in bytes.
    uint dwPINSize;
    ///Offset from the beginning of the structure to a <b>null</b>-terminated string that specifies the PIN or password
    ///of the agent. Used by legacy ACD systems for agent authorization. The size of the string is specified by
    ///<b>dwPINSize</b>.
    uint dwPINOffset;
}

///The <b>LINEAGENTLIST</b> structure describes a list of ACD agents. This structure can contain an array of
///LINEAGENTENTRY structures.
struct LINEAGENTLIST
{
align (1):
    ///Total size allocated to this structure, in bytes.
    uint dwTotalSize;
    ///Size needed to hold all the information requested, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Number of LINEAGENTENTRY structures that appear in the list array. The value is zero if no agents are available.
    uint dwNumEntries;
    ///Size of the agent list array, in bytes.
    uint dwListSize;
    ///Offset from the beginning of the structure to an array of LINEAGENTENTRY structures that specify information
    ///about agents. The <b>dwListOffset</b> member is <b>dwNumEntries</b> times SIZEOF(LINEAGENTENTRY). The size of the
    ///field is specified by <b>dwListSize</b>.
    uint dwListOffset;
}

///The <b>LINEAGENTINFO</b> structure contains information about an ACD agent. The lineGetAgentInfo function returns the
///<b>LINEAGENTINFO</b> structure.
struct LINEAGENTINFO
{
align (1):
    ///Total size allocated to this structure including the null terminator, in bytes.
    uint dwTotalSize;
    ///Size needed to hold all the information requested, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Must be one of the LINEAGENTSTATEEX_ constants.
    uint dwAgentState;
    ///Must be one of the LINEAGENTSTATEEX_ constants.
    uint dwNextAgentState;
    ///Period for which the switch or implementation stores and calculates information, in seconds. For example,
    ///<b>dwNumberOfACDCalls</b> holds the number of calls the agent handled; <b>dwMeasurementPeriod</b> indicates if
    ///this value referenced the calls handed in the last hour, day, or month.
    uint dwMeasurementPeriod;
    ///Agent's call rate (calls per agent hour  where agent hour represents the time that an agent was active in one
    ///or more agent sessions) across all agent sessions. This is a fixed-point decimal number.
    CY   cyOverallCallRate;
    ///Number of ACD calls handled by this agent across all sessions.
    uint dwNumberOfACDCalls;
    ///Number of incoming non-ACD calls handled by this agent.
    uint dwNumberOfIncomingCalls;
    ///Number of outgoing non-ACD calls handled by this agent.
    uint dwNumberOfOutgoingCalls;
    ///Number of seconds spent talking in ACD calls by this agent across all sessions.
    uint dwTotalACDTalkTime;
    ///Number of seconds spent on ACD calls by this agent (across all sessions). Includes the time on phone plus wrap-up
    ///time.
    uint dwTotalACDCallTime;
    ///Number of seconds spent on ACD call wrap-up (after call work) by this agent across all sessions.
    uint dwTotalACDWrapUpTime;
}

///The <b>LINEAGENTSESSIONENTRY</b> structure describes an ACD agent session. The LINEAGENTSESSIONLIST structure can
///contain an array of <b>LINEAGENTSESSIONENTRY</b> structures.
struct LINEAGENTSESSIONENTRY
{
align (1):
    ///Unique identifier for an agent session. It is the responsibility of the agent handler to generate and maintain
    ///uniqueness of these identifiers.
    uint hAgentSession;
    ///Unique identifier for an agent. It is the responsibility of the agent handler to generate and maintain uniqueness
    ///of these identifiers.
    uint hAgent;
    ///Universally unique identifier for an ACD group. It is the responsibility of the agent handler to generate and
    ///maintain uniqueness of this identifier.
    GUID GroupID;
    ///Address identifier on which the agent will receive calls for this session.
    uint dwWorkingAddressID;
}

///The <b>LINEAGENTSESSIONLIST</b> structure describes a list of ACD agent sessions. This structure can contain an array
///of [LINEAGENTSESSIONENTRY](./ns-tapi-lineagentsessionentry.md) structures. The lineGetAgentSessionList function
///returns the <b>LINEAGENTSESSIONLIST</b> structure.
struct LINEAGENTSESSIONLIST
{
align (1):
    ///Total size allocated to this structure, in bytes.
    uint dwTotalSize;
    ///Size needed to hold all the information requested, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Number of [LINEAGENTSESSIONENTRY](./ns-tapi-lineagentsessionentry.md) structures that appear in the list array.
    ///The value is zero if no agent sessions have been created.
    uint dwNumEntries;
    ///Size of the agent session list array, in bytes.
    uint dwListSize;
    ///Offset from the beginning of this structure to an array of
    ///[LINEAGENTSESSIONENTRY](./ns-tapi-lineagentsessionentry.md) structures that specify information about agents. The
    ///<b>dwListOffset</b> member is <b>dwNumEntries</b> times SIZEOF(LINEAGENTSESSIONENTRY). The size of the field is
    ///specified by <b>dwListSize</b>.
    uint dwListOffset;
}

///The <b>LINEAGENTSESSIONINFO</b> structure contains information about the ACD agent session. The
///lineGetAgentSessionInfo function returns the <b>LINEAGENTSESSIONINFO</b> structure.
struct LINEAGENTSESSIONINFO
{
align (1):
    ///Total size allocated to this structure, in bytes.
    uint   dwTotalSize;
    ///Size needed to hold all the information requested, in bytes.
    uint   dwNeededSize;
    ///Size of the portion of this structure that contains useful information, in bytes.
    uint   dwUsedSize;
    ///One of the LINEAGENTSESSIONSTATE_ constants.
    uint   dwAgentSessionState;
    ///One of the LINEAGENTSESSIONSTATE_ constants.
    uint   dwNextAgentSessionState;
    ///Time session was created.
    double dateSessionStartTime;
    ///Duration of the agent session in seconds. Active period only; timing stops when a session enters the
    ///ASST_SESSION_ENDED state.
    uint   dwSessionDuration;
    ///Number of ACD calls handled during this agent session by this agent.
    uint   dwNumberOfCalls;
    ///Number of seconds spent talking in ACD calls during this agent session by this agent.
    uint   dwTotalTalkTime;
    ///Average time spent talking for each ACD call during this agent session by this agent, in seconds.
    uint   dwAverageTalkTime;
    ///Number of seconds spent on ACD calls during this agent session by this agent. It includes time on the phone plus
    ///wrap-up time.
    uint   dwTotalCallTime;
    ///Average time spent for each ACD call during this agent session, in seconds. Includes time on the phone plus
    ///wrap-up time.
    uint   dwAverageCallTime;
    ///Number of seconds spent on ACD call wrap-up (after-call work) during this agent session by this agent.
    uint   dwTotalWrapUpTime;
    ///Average time for each ACD call spent in wrap-up (after-call work) during this agent session, in seconds.
    uint   dwAverageWrapUpTime;
    ///Call rate for each agent session. This is a fixed-point decimal number.
    CY     cyACDCallRate;
    ///Longest time a call was waiting to be answered, in seconds.
    uint   dwLongestTimeToAnswer;
    ///Average time calls waited to be answered, in seconds.
    uint   dwAverageTimeToAnswer;
}

///The <b>LINEQUEUEENTRY</b> structure provides the information for a single queue entry. The LINEQUEUELIST structure
///can contain an array of <b>LINEQUEUEENTRY</b> structures. This structure requires TAPI 3.0 version negotiation.
struct LINEQUEUEENTRY
{
align (1):
    ///Unique identifier for a queue. It is the responsibility of the agent handler to generate and maintain uniqueness
    ///of this identifier.
    uint dwQueueID;
    ///Size of the queue name string including the <b>null</b> terminator, in bytes.
    uint dwNameSize;
    ///Offset from the beginning of the structure to a <b>null</b>-terminated string that specifies the name of the
    ///queue. The size of the string is specified by <b>dwNameSize</b>.
    uint dwNameOffset;
}

///The <b>LINEQUEUELIST</b> structure describes a list of queues. This structure can contain an array of LINEQUEUEENTRY
///structures. The lineGetQueueList function returns the <b>LINEQUEUELIST</b> structure. <b>LINEQUEUELIST</b> requires
///TAPI 3.0 version negotiation.
struct LINEQUEUELIST
{
align (1):
    ///Total size allocated to this structure, in bytes.
    uint dwTotalSize;
    ///Size needed to hold all the information requested, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Number of LINEQUEUEENTRY structures that appear in the list array. The value is zero if no queue is available.
    uint dwNumEntries;
    ///Size of the agent information array, in bytes.
    uint dwListSize;
    ///Offset from the beginning of the structure to an array of LINEQUEUEENTRY structure that specify information about
    ///agents. The <b>dwListOffset</b> member is <b>dwNumEntries</b> times SIZEOF(LINEQUEUEENTRY). The size of the field
    ///is specified by <b>dwListSize</b>.
    uint dwListOffset;
}

///The <b>LINEQUEUEINFO</b> structure provides information about a queue on a line device. The lineGetQueueInfo function
///returns the <b>LINEQUEUEINFO</b> structure. This structure requires TAPI 3.0 version negotiation.
struct LINEQUEUEINFO
{
align (1):
    ///Total size allocated to this structure, in bytes.
    uint dwTotalSize;
    ///Size needed to hold all the information requested, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Period for which the switch or implementation stores and calculates information, in seconds. For example,
    ///<b>dwTotalCallsAbandoned</b> holds the number of abandoned calls; <b>dwMeasurementPeriod</b> would indicate if
    ///this value referenced the calls queued in an hour, day, or month, for example.
    uint dwMeasurementPeriod;
    ///Total number of incoming calls for this queue during this measurement period.
    uint dwTotalCallsQueued;
    ///Number of incoming calls currently waiting.
    uint dwCurrentCallsQueued;
    ///Number of abandoned calls during this measurement period.
    uint dwTotalCallsAbandoned;
    ///Total number of calls that flowed into this queue (passed down from another queue or ACD group) during this
    ///measurement period.
    uint dwTotalCallsFlowedIn;
    ///Total number of calls that flowed out of this queue (passed down to another queue or ACD group) during this
    ///measurement period.
    uint dwTotalCallsFlowedOut;
    ///Longest time any call has waited in queue, in seconds.
    uint dwLongestEverWaitTime;
    ///Longest time that a current call (call still in queue) has been waiting, in seconds.
    uint dwCurrentLongestWaitTime;
    ///Average time that a call has waited in queue, in seconds.
    uint dwAverageWaitTime;
    ///Final disposition of the queue.
    uint dwFinalDisposition;
}

///The <b>LINEPROXYREQUESTLIST</b> structure describes a list of proxy requests. The lineGetProxyStatus function returns
///the <b>LINEPROXYREQUESTLIST</b> structure.
struct LINEPROXYREQUESTLIST
{
align (1):
    ///Total size allocated to this structure, in bytes.
    uint dwTotalSize;
    ///Size needed to hold all the information requested, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Number of <b>DWORD</b> elements that appear in the list array.
    uint dwNumEntries;
    ///Size of the proxy request type list, in bytes.
    uint dwListSize;
    ///Offset from the beginning of the structure to an array of <b>DWORD</b> elements indicating the currently
    ///supported proxy request types. Each element is one of the LINEPROXYREQUEST_ constants. The <b>dwListOffset</b>
    ///member is <b>dwNumEntries</b> times SIZEOF(DWORD). The size of the field is specified by <b>dwListSize</b>.
    uint dwListOffset;
}

///The <b>LINEDIALPARAMS</b> structure specifies a collection of dialing-related fields. Call the lineSetCallParams
///function or the TSPI_lineSetCallParams function to set parameters for a call using the <b>LINEDIALPARAMS</b>
///structure.
struct LINEDIALPARAMS
{
align (1):
    ///Duration of a comma in the dialable address, in milliseconds.
    uint dwDialPause;
    ///Interdigit time period between successive digits, in milliseconds.
    uint dwDialSpeed;
    ///Duration of a digit, in milliseconds.
    uint dwDigitDuration;
    ///Maximum amount of time to wait for a dial tone when a 'W' is used in the dialable address, in milliseconds.
    uint dwWaitForDialtone;
}

///The <b>LINECALLINFO</b> structure contains information about a call. This information remains relatively fixed for
///the duration of the call. Multiple functions use <b>LINECALLINFO</b>. The structure is returned by the
///lineGetCallInfo function and the TSPI_lineGetCallInfo function. If a part of the structure does change, then a
///LINE_CALLINFO message is sent to the application indicating which information item has changed. Dynamically changing
///information about a call, such as call progress status, is available in the LINECALLSTATUS structure, returned by a
///call to the lineGetCallStatus function.
struct LINECALLINFO
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint           dwTotalSize;
    ///Size for this data structure that is needed to hold all the returned information, in bytes.
    uint           dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint           dwUsedSize;
    ///Handle to the line device with which this call is associated.
    uint           hLine;
    ///Device identifier of the line device with which this call is associated.
    uint           dwLineDeviceID;
    ///Address identifier of the address on the line on which this call exists. An address identifier is permanently
    ///associated with an address; the identifier remains constant across operating system upgrades.
    uint           dwAddressID;
    ///Current bearer mode of the call. This member uses one of the LINEBEARERMODE_ constants.
    uint           dwBearerMode;
    ///Rate of the call's data stream, in bps (bits per second).
    uint           dwRate;
    ///Media type of the information stream currently on the call. This is the media type as determined by the owner of
    ///the call, which is not necessarily the same as that of the last LINE_MONITORMEDIA message. This member is not
    ///directly affected by the LINE_MONITORMEDIA messages. This member uses the LINEMEDIAMODE_ constants.
    uint           dwMediaMode;
    ///Not interpreted by the API implementation and service provider. It can be set by any owner application of this
    ///call with the lineSetAppSpecific function.
    uint           dwAppSpecific;
    ///In some telephony environments, the switch or service provider can assign a unique identifier to each call. This
    ///allows the call to be tracked across transfers, forwards, or other events. The domain of these call IDs and their
    ///scope is service provider-defined. The <b>dwCallID</b> member makes this unique identifier available to the
    ///applications.
    uint           dwCallID;
    ///Telephony environments that use the call ID often may find it necessary to relate one call to another. The
    ///<b>dwRelatedCallID</b> member may be used by the service provider for this purpose.
    uint           dwRelatedCallID;
    ///Collection of call-related parameters when the call is outgoing. These are the same call parameters specified in
    ///lineMakeCall, one or more of the LINECALLPARAMFLAGS_ constants.
    uint           dwCallParamFlags;
    ///One or more of the LINECALLSTATE_ constants, that indicates the states in which the application can be notified
    ///on this call. The <b>dwCallStates</b> member is constant in <b>LINECALLINFO</b> and does not change depending on
    ///the call state.
    uint           dwCallStates;
    ///Various digit modes. This member is one or more of the LINEDIGITMODE_ constants, for which monitoring is
    ///currently enabled.
    uint           dwMonitorDigitModes;
    ///Various media types for which monitoring is currently enabled. This member is one or more of the LINEMEDIAMODE_
    ///constants.
    uint           dwMonitorMediaModes;
    ///Dialing parameters currently in effect on the call, of type LINEDIALPARAMS. Unless these parameters are set by
    ///either lineMakeCall or lineSetCallParams, their values are the same as the defaults used in the LINEDEVCAPS
    ///structure.
    LINEDIALPARAMS DialParams;
    ///Identifies where the call originated. This member can be one of the LINECALLORIGIN_ constants.
    uint           dwOrigin;
    ///Reason why the call occurred. This member can be one of the LINECALLREASON_ constants.
    uint           dwReason;
    ///Completion identifier for the incoming call if it is the result of a completion request that terminates. This
    ///identifier is meaningful only if <b>dwReason</b> is LINECALLREASON_CALLCOMPLETION.
    uint           dwCompletionID;
    ///Number of application modules with different call handles with owner privilege for the call.
    uint           dwNumOwners;
    ///Number of application modules with different call handles with monitor privilege for the call.
    uint           dwNumMonitors;
    ///Country or region code of the destination party. Zero if unknown.
    uint           dwCountryCode;
    ///Number of the trunk over which the call is routed. This member is used for both incoming and outgoing calls. The
    ///<b>dwTrunk</b> member should be set to 0xFFFFFFFF if it is unknown.
    uint           dwTrunk;
    ///Determines the validity and content of the caller, or originator, party identifier information. This member uses
    ///one of the LINECALLPARTYID_ constants.
    uint           dwCallerIDFlags;
    ///Size of the caller ID number, in bytes.
    uint           dwCallerIDSize;
    ///Offset from the beginning of this structure to the variably sized field containing the caller party ID number
    ///information. The size of the field is specified by <b>dwCallerIDSize</b>.
    uint           dwCallerIDOffset;
    ///Size of the caller ID name including the null terminator, in bytes.
    uint           dwCallerIDNameSize;
    ///Offset from the beginning of this structure to the variably sized field containing the caller party ID name
    ///information. The size of the field is specified by <b>dwCallerIDNameSize</b>.
    uint           dwCallerIDNameOffset;
    ///Determines the validity and content of the called-party ID information. The called party corresponds to the
    ///originally addressed party. This member uses one of the LINECALLPARTYID_ constants.
    uint           dwCalledIDFlags;
    ///Size of the called-party ID number, in bytes.
    uint           dwCalledIDSize;
    ///Offset from the beginning of the structure to the variably sized field containing the called-party ID number
    ///information. The size of the field is specified by <b>dwCalledIDSize</b>.
    uint           dwCalledIDOffset;
    ///Size of the called-party ID name including the null terminator, in bytes.
    uint           dwCalledIDNameSize;
    ///Offset from the beginning of the structure to the variably sized field containing the called-party ID name
    ///information. The size of the field is specified by <b>dwCalledIDNameSize</b>.
    uint           dwCalledIDNameOffset;
    ///Determines the validity and content of the connected party ID information. The connected party is the party that
    ///was actually connected to. This may be different from the called-party ID if the call was diverted. This member
    ///uses one of the LINECALLPARTYID_ constants.
    uint           dwConnectedIDFlags;
    ///Size of the connected-party ID number, in bytes.
    uint           dwConnectedIDSize;
    ///Offset from the beginning of this structure to the variably sized field containing the connected-party ID number
    ///information. The size of the field is specified by <b>dwConnectedIDSize</b>.
    uint           dwConnectedIDOffset;
    ///Size of the connected-party ID name including the null terminator, in bytes.
    uint           dwConnectedIDNameSize;
    ///Offset from the beginning of this structure to the variably sized field containing the connected-party ID name
    ///information. The size of the field is specified by <b>dwConnectedIDNameSize</b>.
    uint           dwConnectedIDNameOffset;
    ///Determines the validity and content of the redirection party identifier information. The redirection party
    ///identifies the address to which the session was redirected. This member uses one of the LINECALLPARTYID_
    ///constants.
    uint           dwRedirectionIDFlags;
    ///Size of the redirection-party ID number, in bytes.
    uint           dwRedirectionIDSize;
    ///Offset from the beginning of the structure to the variably sized field containing the redirection-party ID number
    ///information. The size of the field is specified by <b>dwRedirectionIDSize</b>.
    uint           dwRedirectionIDOffset;
    ///Size of the redirection-party ID name, in bytes.
    uint           dwRedirectionIDNameSize;
    ///Offset from the beginning of the structure to the variably sized field containing the redirection-party ID name
    ///information. The size of the field is specified by <b>dwRedirectionIDNameSize</b>.
    uint           dwRedirectionIDNameOffset;
    ///Determines the validity and content of the redirecting party identifier information. The redirecting party
    ///identifies the address which redirect the session. This member uses one of the LINECALLPARTYID_ constants.
    uint           dwRedirectingIDFlags;
    ///Size of the redirecting-party ID number, in bytes.
    uint           dwRedirectingIDSize;
    ///Offset from the beginning of the structure to the variably sized field containing the redirecting-party ID number
    ///information. The size of the field is specified by <b>dwRedirectingIDSize</b>.
    uint           dwRedirectingIDOffset;
    ///Size of the redirecting-party ID name including the null terminator, in bytes.
    uint           dwRedirectingIDNameSize;
    ///Offset from the beginning of the structure to the variably sized field containing the redirecting-party ID name
    ///information. The size of the field is specified by <b>dwRedirectingIDNameSize</b>.
    uint           dwRedirectingIDNameOffset;
    ///Size of the application name field including the null terminator, in bytes.
    uint           dwAppNameSize;
    ///Offset from the beginning of the structure to the variably sized field holding the user-friendly name of the
    ///application that first originated, accepted, or answered the call. This is the name that an application can
    ///specify in lineInitializeEx. If the application specifies no such name, then the application's module filename is
    ///used instead. The size of the field is specified by <b>dwAppNameSize</b>.
    uint           dwAppNameOffset;
    ///Size of the displayable address string including the null terminator, in bytes.
    uint           dwDisplayableAddressSize;
    ///Displayable string is used for logging purposes. The information is obtained from LINECALLPARAMS for functions
    ///that initiate calls. The lineTranslateAddress function returns appropriate information to be placed in this field
    ///in the <b>dwDisplayableAddressSize</b> and <b>dwDisplayableAddressOffset</b> members of the LINETRANSLATEOUTPUT
    ///structure.
    uint           dwDisplayableAddressOffset;
    ///Size of the called-party description field, in bytes.
    uint           dwCalledPartySize;
    ///Offset from the beginning of the structure to the variably sized field that specifies the user-friendly
    ///description of the called party. This information can be specified with lineMakeCall and can be optionally
    ///specified in the <i>lpCallParams</i> parameter whenever a new call is established. It is useful for call logging
    ///purposes. The size of the field is specified by <b>dwCalledPartySize</b>.
    uint           dwCalledPartyOffset;
    ///Size of the comment field, in bytes.
    uint           dwCommentSize;
    ///Offset from the beginning of the structure to the variably sized field holding a comment about the call provided
    ///by the application that originated the call using lineMakeCall. This information can be optionally specified in
    ///the <i>lpCallParams</i> parameter whenever a new call is established. The size of the field is specified by
    ///<b>dwCommentSize</b>.
    uint           dwCommentOffset;
    ///Size of the raw display information, in bytes.
    uint           dwDisplaySize;
    ///Offset from the beginning of the structure to the variably sized field holding raw display information. Depending
    ///on the telephony environment, a service provider may extract functional information from this member pair for
    ///formatting and presentation most appropriate for this telephony configuration. The size of the field is specified
    ///by <b>dwDisplaySize</b>.
    uint           dwDisplayOffset;
    ///Size of the user-user information, in bytes. If the user-user information is a pointer to a string, the size must
    ///include the null terminator.
    uint           dwUserUserInfoSize;
    ///Offset from the beginning of the structure to the variably sized field holding user-user information. The
    ///protocol discriminator field for the user-user information, if used, appears as the first byte of the data
    ///pointed to by <b>dwUserUserInfoOffset</b>, and is accounted for in <b>dwUserUserInfoSize</b>.
    uint           dwUserUserInfoOffset;
    ///Size of the high-level compatibility information, in bytes.
    uint           dwHighLevelCompSize;
    ///Offset from the beginning of the structure to the variably sized field holding high-level compatibility
    ///information. The format of this information is specified by other standards (ISDN Q.931). The size of the field
    ///is specified by <b>dwHighLevelCompSize</b>.
    uint           dwHighLevelCompOffset;
    ///Size of the low-level compatibility information, in bytes.
    uint           dwLowLevelCompSize;
    ///Offset from the beginning of the structure to the variably sized field holding low-level compatibility
    ///information. The format of this information is specified by other standards (ISDN Q.931). The size of the field
    ///is specified by <b>dwLowLevelCompSize</b>.
    uint           dwLowLevelCompOffset;
    ///Size of the charging information, in bytes.
    uint           dwChargingInfoSize;
    ///Offset from the beginning of the structure to the variably sized field holding charging information. The format
    ///of this information is specified by other standards (ISDN Q.931). The size of the field is specified by
    ///<b>dwChargingInfoSize</b>.
    uint           dwChargingInfoOffset;
    ///Size of the current terminal modes array, in bytes.
    uint           dwTerminalModesSize;
    ///Offset from the beginning of the structure to the variably sized device field containing an array with
    ///<b>DWORD</b>-sized entries. Array entries are indexed by terminal identifiers, in the range from zero to one less
    ///than <b>dwNumTerminals</b>. Each entry in the array specifies the current terminal modes for the corresponding
    ///terminal set with the lineSetTerminal function for this call's media stream, as specified by one of the
    ///LINETERMMODE_ constants. The size of the array is specified by <b>dwTerminalModesSize</b>.
    uint           dwTerminalModesOffset;
    ///Size of the device-specific field, in bytes.
    uint           dwDevSpecificSize;
    ///Offset from the beginning of the structure to the variably-sized field holding device-specific information. The
    ///size of the field is specified by <b>dwDevSpecificSize</b>.
    uint           dwDevSpecificOffset;
    ///Call treatment currently being applied on the call or that is applied when the call enters the next applicable
    ///state. Can be zero if call treatments are not supported.
    uint           dwCallTreatment;
    ///Size of the application-settable call data, in bytes.
    uint           dwCallDataSize;
    ///Offset from the beginning of the structure to the application-settable call data. The size of the field is
    ///specified by <b>dwCallDataSize</b>.
    uint           dwCallDataOffset;
    ///Size of the quality of service information, in bytes.
    uint           dwSendingFlowspecSize;
    ///Offset from the beginning of the structure to a FLOWSPEC structure followed by WinSock provider-specific data,
    ///equivalent to what would have been stored in <b>SendingFlowspec</b> in a QOS structure. Specifies the quality of
    ///service currently in effect in the sending direction on the call. The provider-specific portion following the
    ///<b>FLOWSPEC</b> structure must not contain pointers to other blocks of memory, because TAPI does not know how to
    ///marshal the data pointed to by the private pointer(s) and convey it through interprocess communication to the
    ///application. The size of the field is specified by <b>dwSendingFlowspecSize</b>.
    uint           dwSendingFlowspecOffset;
    ///Size of the quality of service information, in bytes.
    uint           dwReceivingFlowspecSize;
    ///Offset from the beginning of the structure to a FLOWSPEC structure followed by WinSock provider-specific data,
    ///equivalent to what would have been stored in <b>ReceivingFlowspec</b> in a QOS structure. Specifies the quality
    ///of service current in effect in the receiving direction on the call. The provider-specific portion following the
    ///<b>FLOWSPEC</b> structure must not contain pointers to other blocks of memory, because TAPI does not know how to
    ///marshal the data pointed to by the private pointer(s) and convey it through interprocess communication to the
    ///application. The size of the field is specified by <b>dwReceivingFlowspecSize</b>.
    uint           dwReceivingFlowspecOffset;
}

///The <b>LINECALLLIST</b> structure describes a list of call handles. A structure of this type is returned by the
///lineGetNewCalls and lineGetConfRelatedCalls functions.
struct LINECALLLIST
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size for this data structure that is needed to hold all the returned information, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Number of handles in the <i>hCalls</i> array.
    uint dwCallsNumEntries;
    ///Size of the array of call handles, in bytes.
    uint dwCallsSize;
    ///Offset from the beginning of the structure to the variably sized array of <b>HCALL</b> handles. The size of the
    ///array is specified by <b>dwCallsSize</b>.
    uint dwCallsOffset;
}

///The <b>LINECALLPARAMS</b> structure describes parameters supplied when making calls using the lineMakeCall and
///TSPI_lineMakeCall functions. The <b>LINECALLPARAMS</b> structure is also used as a parameter in other operations,
///such as the lineOpen function. The comments to the right of the syntax block indicate the default values used when
///this structure is not provided to lineMakeCall.
struct LINECALLPARAMS
{
align (1):
    ///Total size allocated to this data structure, in bytes. This size should be big enough to hold all the fixed and
    ///variably sized portions of this data structure.
    uint           dwTotalSize;
    ///Bearer mode for the call. This member uses one of the LINEBEARERMODE_ constants. If <b>dwBearerMode</b> is zero,
    ///the default value is LINEBEARERMODE_VOICE.
    uint           dwBearerMode;
    ///Minimum data rate requested for the call's data stream, in bps (bits per second).
    uint           dwMinRate;
    ///Maximum data rate requested for the call's data stream, in bps (bits per second). When making a call, the service
    ///provider attempts to provide the highest available rate in the requested range (<b>dwMinRate</b> to
    ///<b>dwMaxRate</b>). If a specific data rate is required, both <b>dwMinRate</b> and <b>dwMaxRate</b> should be set
    ///to that value. If an application works best with one rate but is able to degrade to lower rates, the application
    ///should specify these as the maximum and minimum rates, respectively. If <b>dwMaxRate</b> is zero, the default
    ///value is as specified by the <b>dwMaxRate</b> member of the LINEDEVCAPS structure. This is the maximum rate
    ///supported by the device.
    uint           dwMaxRate;
    ///Expected media type of the call. This member uses one of the LINEMEDIAMODE_ constants. If <b>dwMediaMode</b> is
    ///zero, the default value is LINEMEDIAMODE_INTERACTIVEVOICE.
    uint           dwMediaMode;
    ///Collection of Boolean call-setup parameters. This member uses one or more of the LINECALLPARAMFLAGS_ constants.
    uint           dwCallParamFlags;
    ///Mode by which the originating address is specified. This member uses one of the LINEADDRESSMODE_ constants. <div
    ///class="alert"><b>Note</b> The <b>dwAddressMode</b> member cannot be LINEADDRESSMODE_ADDRESSID for the lineOpen
    ///function call. However, this restriction does not apply to lineMakeCall.</div> <div> </div>
    uint           dwAddressMode;
    ///Address identifier of the originating address if <b>dwAddressMode</b> is set to LINEADDRESSMODE_ADDRESSID. An
    ///address identifier is permanently associated with an address; the identifier remains constant across operating
    ///system upgrades.
    uint           dwAddressID;
    ///Dial parameters to be used on this call, of type LINEDIALPARAMS. When a value of 0 is specified for this field,
    ///the default value for the field is used as indicated in the <b>DefaultDialParams</b> member of the LINEDEVCAPS
    ///structure. If a nonzero value is specified for a field that is outside the range specified by the corresponding
    ///fields in <b>MinDialParams</b> and <b>MaxDialParams</b> in the <b>LINEDEVCAPS</b> structure, the nearest value
    ///within the valid range is used instead.
    LINEDIALPARAMS DialParams;
    ///Size of the originating address field, in bytes.
    uint           dwOrigAddressSize;
    ///Offset from the beginning of the structure to the variably sized field holding the originating address. The
    ///format of this address is dependent on the <b>dwAddressMode</b> member. The size of the field is specified by
    ///<b>dwOrigAddressSize</b>.
    uint           dwOrigAddressOffset;
    ///Size of the displayable string including the <b>null</b> terminator, in bytes.
    uint           dwDisplayableAddressSize;
    ///Displayable string used for logging purposes. The content of these members is recorded in the
    ///<b>dwDisplayableAddressOffset</b> and <b>dwDisplayableAddressSize</b> members of the call's LINECALLINFO message.
    ///The lineTranslateAddress function returns appropriate information to be placed in this field in the
    ///<b>dwDisplayableAddressSize</b> and <b>dwDisplayableAddressOffset</b> members of the LINETRANSLATEOUTPUT
    ///structure. The size of the field is specified by <b>dwDisplayableAddressSize</b>.
    uint           dwDisplayableAddressOffset;
    ///Size of the called-party information, in bytes.
    uint           dwCalledPartySize;
    ///Offset from the beginning of the structure to to the variably sized field holding called-party information. This
    ///information can be specified by the application that makes the call and is made available in the call's
    ///information structure for logging purposes. The format of this field is that of <b>dwStringFormat</b>, as
    ///specified in LINEDEVCAPS. The size of the field is specified by <b>dwCalledPartySize</b>.
    uint           dwCalledPartyOffset;
    ///Size of the call comment field, in bytes.
    uint           dwCommentSize;
    ///Offset from the beginning of the structure to the variably sized field holding comments about the call. This
    ///information can be specified by the application that makes the call and is made available in the call's
    ///information structure for logging purposes. The format of this field is that of <b>dwStringFormat</b>, as
    ///specified in LINEDEVCAPS. The size of the field is specified by <b>dwCommentSize</b>.
    uint           dwCommentOffset;
    ///Size of the user-user information including the <b>null</b> terminator, in bytes.
    uint           dwUserUserInfoSize;
    ///Offset from the beginning of the structure to the variably sized field holding user-user information. The
    ///protocol discriminator field for the user-user information, if required, should appear as the first byte of the
    ///data pointed to by <b>dwUserUserInfoOffset</b>, and must be accounted for in <b>dwUserUserInfoSize</b>.
    uint           dwUserUserInfoOffset;
    ///Size of the high-level compatibility information, in bytes.
    uint           dwHighLevelCompSize;
    ///Offset from the beginning of the structure to the variably sized field holding high-level compatibility
    ///information. The size of the field is specified by <b>dwHighLevelCompSize</b>.
    uint           dwHighLevelCompOffset;
    ///Size of the low-level compatibility information, in bytes.
    uint           dwLowLevelCompSize;
    ///Offset from the beginning of the structure to the variably sized field holding low-level compatibility
    ///information. The size of the field is specified by <b>dwLowLevelCompSize</b>.
    uint           dwLowLevelCompOffset;
    ///Size of the device-specific information, in bytes.
    uint           dwDevSpecificSize;
    ///Offset from the beginning of the structure to the variably sized field holding device-specific information. The
    ///size of the field is specified by <b>dwDevSpecificSize</b>.
    uint           dwDevSpecificOffset;
    ///LINECALLSTATE_ constants, entry into which causes the call to be blind-transferred to the specified target
    ///address. Set to zero if automatic transfer is not desired.
    uint           dwPredictiveAutoTransferStates;
    ///Size of the target dialable address string including the <b>null</b> terminator, in bytes.
    uint           dwTargetAddressSize;
    ///Offset from the beginning of the structure to a string specifying the target dialable address (not
    ///<b>dwAddressID</b>); used in the case of certain automatic actions. In the case of predictive dialing, specifies
    ///the address to which the call should be automatically transferred. The size of the string is specified by
    ///<b>dwTargetAddressSize</b>. This is essentially the same string that would be passed to lineBlindTransfer if
    ///automatic transfer were not being used. Set to zero if automatic transfer is not desired. In the case of a No
    ///Hold Conference, specifies the address that should be conferenced to the call. In the case of a One Step
    ///Transfer, specifies the address to dial on the consultation call.
    uint           dwTargetAddressOffset;
    ///Size of the quality of service information, in bytes.
    uint           dwSendingFlowspecSize;
    ///Offset from the beginning of the structure to a FLOWSPEC structure followed by WinSock provider-specific data,
    ///equivalent to what would have been stored in <b>SendingFlowspec</b> in a QOS structure. Specifies the quality of
    ///service desired in the sending direction on the call. The provider-specific portion following the <b>FLOWSPEC</b>
    ///structure must not contain pointers to other blocks of memory, because TAPI does not know how to marshal the data
    ///pointed to by the private pointer(s) and convey it through interprocess communication to the application. The
    ///size of the field is specified by <b>dwSendingFlowspecSize</b>.
    uint           dwSendingFlowspecOffset;
    ///Size of the quality of service information, in bytes.
    uint           dwReceivingFlowspecSize;
    ///Offset from the beginning of the structure to a FLOWSPEC structure followed by WinSock provider-specific data,
    ///equivalent to what would have been stored in <b>ReceivingFlowspec</b> in a QOS structure. Specifies the quality
    ///of service desired in the receiving direction on the call. The provider-specific portion following the
    ///<b>FLOWSPEC</b> structure must not contain pointers to other blocks of memory, because TAPI does not know how to
    ///marshal the data pointed to by the private pointer(s) and convey it through interprocess communication to the
    ///application. The size of the field is specified by <b>dwReceivingFlowspecSize</b>.
    uint           dwReceivingFlowspecOffset;
    ///Size of the device class string including the <b>null</b> terminator, in bytes.
    uint           dwDeviceClassSize;
    ///Offset from the beginning of the structure to a <b>null</b>-terminated string that indicates the device class of
    ///the device whose configuration is specified in <i>DeviceConfig</i>. Valid device class strings are the same as
    ///those specified for the lineGetID function. The size of the string is specified by <b>dwDeviceClassSize</b>.
    uint           dwDeviceClassOffset;
    ///Size of the device configuration data, in bytes.
    uint           dwDeviceConfigSize;
    ///Offset from the beginning of the structure to the opaque configuration data structure. This value is returned in
    ///the <b>dwStringSize</b> member in the VARSTRING structure returned by lineGetDevConfig. If the size is zero, the
    ///default device configuration is used. This allows the application to set the device configuration before the call
    ///is initiated. The size of the field is specified by <b>dwDeviceConfigSize</b>.
    uint           dwDeviceConfigOffset;
    ///Size of the application-settable call data, in bytes.
    uint           dwCallDataSize;
    ///Offset from the beginning of the structure to the application-settable call data to be initially attached to the
    ///call. The size of the field is specified by <b>dwCallDataSize</b>.
    uint           dwCallDataOffset;
    ///Number of seconds, after the completion of dialing, that the call should be allowed to wait in the PROCEEDING or
    ///RINGBACK states, before it is automatically abandoned by the service provider with a LINECALLSTATE_DISCONNECTED
    ///and LINEDISCONNECTMODE_NOANSWER. A value of 0 indicates that the application does not desire automatic call
    ///abandonment.
    uint           dwNoAnswerTimeout;
    ///Size of the calling-party ID string including the <b>null</b> terminator, in bytes, including the
    ///<b>null</b>-terminating character.
    uint           dwCallingPartyIDSize;
    ///Offset from the beginning of the structure to a <b>null</b>-terminated string that specifies the identity of the
    ///party placing the call. If the content of the identifier is acceptable and a path is available, the service
    ///provider passes the identifier along to the called party to indicate the identity of the calling party. The size
    ///of the field is specified by <b>dwCallingPartyIDSize</b>.
    uint           dwCallingPartyIDOffset;
}

///The <b>LINECALLSTATUS</b> structure describes the current status of a call. The information in this structure depends
///on the device capabilities of the address, the ownership of the call by the invoking application, and the current
///state of the call being queried. The lineGetCallStatus and TSPI_lineGetCallStatus functions return the
///<b>LINECALLSTATUS</b> structure.
struct LINECALLSTATUS
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint       dwTotalSize;
    ///Size for this data structure that is needed to hold all the returned information, in bytes.
    uint       dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint       dwUsedSize;
    ///Current call state of the call using one of the LINECALLSTATE_ constants.
    uint       dwCallState;
    ///Interpretation of the <b>dwCallStateMode</b> member is call-state-dependent. In many cases, the value will be
    ///zero. The following table shows <b>dwCallStateMode</b> types for a given <b>dwCallState</b> value. <table> <tr>
    ///<th>dwCallState</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LINECALLSTATE_BUSY"></a><a
    ///id="linecallstate_busy"></a><dl> <dt><b>LINECALLSTATE_BUSY</b></dt> </dl> </td> <td width="60%"> LINEBUSYMODE_
    ///Constants </td> </tr> <tr> <td width="40%"><a id="LINECALLSTATE_CONNECTED"></a><a
    ///id="linecallstate_connected"></a><dl> <dt><b>LINECALLSTATE_CONNECTED</b></dt> </dl> </td> <td width="60%">
    ///LINECONNECTEDMODE_ Constants </td> </tr> <tr> <td width="40%"><a id="LINECALLSTATE_DIALTONE"></a><a
    ///id="linecallstate_dialtone"></a><dl> <dt><b>LINECALLSTATE_DIALTONE</b></dt> </dl> </td> <td width="60%">
    ///LINEDIALTONEMODE_ Constants </td> </tr> <tr> <td width="40%"><a id="LINECALLSTATE_DISCONNECTED"></a><a
    ///id="linecallstate_disconnected"></a><dl> <dt><b>LINECALLSTATE_DISCONNECTED</b></dt> </dl> </td> <td width="60%">
    ///LINEDISCONNECTMODE_ Constants </td> </tr> <tr> <td width="40%"><a id="LINECALLSTATE_OFFERING"></a><a
    ///id="linecallstate_offering"></a><dl> <dt><b>LINECALLSTATE_OFFERING</b></dt> </dl> </td> <td width="60%">
    ///LINEOFFERINGMODE_ Constants </td> </tr> <tr> <td width="40%"><a id="LINECALLSTATE_SPECIALINFO"></a><a
    ///id="linecallstate_specialinfo"></a><dl> <dt><b>LINECALLSTATE_SPECIALINFO</b></dt> </dl> </td> <td width="60%">
    ///LINESPECIALINFO_ Constants </td> </tr> </table>
    uint       dwCallStateMode;
    ///Application's privilege for this call. This member uses one or more of the LINECALLPRIVILEGE_ constants.
    uint       dwCallPrivilege;
    ///Flags that indicate the Telephony API functions that can be invoked on the call, given the availability of the
    ///feature in the device capabilities, the current call state, and call ownership of the invoking application. A
    ///zero indicates the corresponding feature cannot be invoked by the application on the call in its current state; a
    ///one indicates the feature can be invoked. This member uses LINECALLFEATURE_ Constants.
    uint       dwCallFeatures;
    ///Size of the device-specific field, in bytes.
    uint       dwDevSpecificSize;
    ///Offset from the beginning of the structure to the variably sized device-specific field. The size of the field is
    ///specified by <b>dwDevSpecificOffset</b>.
    uint       dwDevSpecificOffset;
    ///Indicates additional functions can be invoked on the call, given the availability of the feature in the device
    ///capabilities, the current call state, and call ownership of the invoking application. An extension of the
    ///<b>dwCallFeatures</b> member. This member uses LINECALLFEATURE2_ Constants.
    uint       dwCallFeatures2;
    ///Coordinated Universal Time at which the current call state was entered.
    SYSTEMTIME tStateEntryTime;
}

///The <b>LINECALLTREATMENTENTRY</b> structure provides information on the type of call treatment, such as music,
///recorded announcement, or silence, on the current call. The LINEADDRESSCAPS structure can contain an array of
///<b>LINECALLTREATMENTENTRY</b> structures.
struct LINECALLTREATMENTENTRY
{
align (1):
    ///One of the LINECALLTREATMENT_ Constants (if the treatment is of a predefined type) or a service provider-specific
    ///value.
    uint dwCallTreatmentID;
    ///Size of the call treatment name string, in bytes, including the null-terminating character.
    uint dwCallTreatmentNameSize;
    ///Offset from the beginning of LINEADDRESSCAPS to a null-terminated string identifying the treatment. This would
    ///ordinarily describe the content of the music or recorded announcement. If the treatment is of a predefined type,
    ///a meaningful name should still be specified, for example, "Silence\0", "Busy Signal\0", "Ringback\0", or
    ///"Music\0". The size of the string is specified by <b>dwCallTreatmentNameOffset</b>.
    uint dwCallTreatmentNameOffset;
}

///The <b>LINECARDENTRY</b> structure describes a calling card. The LINETRANSLATECAPS structure can contain an array of
///<b>LINECARDENTRY</b> structures.
struct LINECARDENTRY
{
align (1):
    ///Permanent identifier that identifies the card.
    uint dwPermanentCardID;
    ///Size of the card name string including <b>null</b> terminator, in bytes.
    uint dwCardNameSize;
    ///Offset from the beginning of the structure to a <b>null</b>-terminated string that describes the card in a
    ///user-friendly manner. The size of the field is specified by <b>dwCardNameSize</b>.
    uint dwCardNameOffset;
    ///Number of digits in the existing card number. The card number itself is not returned for security reasons (it is
    ///stored in scrambled form by TAPI). The application can use this to insert filler bytes into a text control in
    ///"password" mode to show that a number exists.
    uint dwCardNumberDigits;
    ///Size of the same-area dialing rule including the <b>null</b> terminator, in bytes.
    uint dwSameAreaRuleSize;
    ///Offset from the beginning of the LINETRANSLATECAPS structure to the dialing rule defined for calls to numbers in
    ///the same area code. The rule is a <b>null</b>-terminated string. The size of the field is specified by
    ///<b>dwSameAreaRuleSize</b>.
    uint dwSameAreaRuleOffset;
    ///Size of the long distance dialing rule including the <b>null</b> terminator, in bytes.
    uint dwLongDistanceRuleSize;
    ///Offset from the beginning of the structure to the dialing rule defined for calls to numbers in the other areas in
    ///the same country/region. The rule is a <b>null</b>-terminated string. The size of the field is specified by
    ///<b>dwLongDistanceRuleSize</b>.
    uint dwLongDistanceRuleOffset;
    ///Size of the international dialing rule including the <b>null</b> terminator, in bytes.
    uint dwInternationalRuleSize;
    ///Offset from the beginning of the structure to the dialing rule defined for calls to numbers in other
    ///countries/regions. The rule is a <b>null</b>-terminated string. The size of the field is specified by
    ///<b>dwInternationalRuleSize</b>.
    uint dwInternationalRuleOffset;
    ///Indicates other settings associated with this calling card, using the LINECARDOPTION_ Constants.
    uint dwOptions;
}

///The <b>LINECOUNTRYENTRY</b> structure provides the data for a single country/region entry. An array of one or more of
///these structures is part of the LINECOUNTRYLIST structure returned by the lineGetCountry function.
struct LINECOUNTRYENTRY
{
align (1):
    ///Country/region identifier of the entry. The country/region identifier is an internal identifier that allows
    ///multiple entries to exist in the country/region list with the same country/region code, for example, all
    ///countries or regions in North America and the Caribbean share the country/region code 1, but require separate
    ///entries in the list.
    uint dwCountryID;
    ///Country/region code of the country/region represented by the entry; that is, the digits dialed in an
    ///international call. Only this value should be displayed to users. Country/region identifiers should never be
    ///displayed.
    uint dwCountryCode;
    ///Country/region identifier of the next entry in the country/region list. Because country/region codes and
    ///identifiers are not assigned in any regular numeric sequence, the country/region list is a single linked list,
    ///with each entry pointing to the next. The last country/region in the list has a <b>dwNextCountryID</b> value of
    ///zero. When the LINECOUNTRYLIST structure is used to obtain the entire list, the entries in the list are in
    ///sequence as linked by their <b>dwNextCountryID</b> members.
    uint dwNextCountryID;
    ///Size, in bytes, of the name of the country/region including the <b>null</b> terminator.
    uint dwCountryNameSize;
    ///Offset from the beginning of the structure to a <b>null</b>-terminated string that specifies the name of the
    ///country/region. The size of the field is specified by <b>dwCountryNameSize</b>.
    uint dwCountryNameOffset;
    ///Size, in bytes, of the direct-dialed dialing rule including the <b>null</b> terminator.
    uint dwSameAreaRuleSize;
    ///Offset from the beginning of the structure to a <b>null</b>-terminated string that contains the dialing rule for
    ///direct-dialed calls to the same area code. The size of the field is specified by <b>dwSameAreaRuleSize</b>.
    uint dwSameAreaRuleOffset;
    ///Size, in bytes, of the long-distance dialing rule including the <b>null</b> terminator.
    uint dwLongDistanceRuleSize;
    ///Offset from the beginning of the structure to a <b>null</b>-terminated string that contains the dialing rule for
    ///direct-dialed calls to other areas in the same country/region. The size of the field is specified by
    ///<b>dwLongDistanceRuleSize</b>.
    uint dwLongDistanceRuleOffset;
    ///Size, in bytes, of the international dialing rule including the <b>null</b> terminator.
    uint dwInternationalRuleSize;
    ///Offset from the beginning of the LINECOUNTRYLIST structure to a <b>null</b>-terminated string that contains the
    ///dialing rule for direct-dialed calls to other countries/regions. The size of the field is specified by
    ///<b>dwInternationalRuleSize</b>.
    uint dwInternationalRuleOffset;
}

///The <b>LINECOUNTRYLIST</b> structure describes a list of countries/regions. This structure can contain an array of
///LINECOUNTRYENTRY structures. <b>LINECOUNTRYLIST</b> is returned by the lineGetCountry function.
struct LINECOUNTRYLIST
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size for this data structure that is needed to hold all the returned information, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Number of LINECOUNTRYENTRY structures present in the array defined by <b>dwCountryListSize</b> and
    ///<b>dwCountryListOffset</b>.
    uint dwNumCountries;
    ///Size of the array of country/region information, in bytes.
    uint dwCountryListSize;
    ///Offset from the beginning of the structure to an array of LINECOUNTRYENTRY structures that provides the
    ///information for each country/region. The size of the field is specified by <b>dwCountryListSize</b>.
    uint dwCountryListOffset;
}

///The <b>LINEDEVCAPS</b> structure describes the capabilities of a line device. The lineGetDevCaps function and the
///TSPI_lineGetDevCaps function return the <b>LINEDEVCAPS</b> structure.
struct LINEDEVCAPS
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint           dwTotalSize;
    ///Size needed for this data structure to hold all the returned information, in bytes.
    uint           dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint           dwUsedSize;
    ///Size of the variably sized field containing service provider information, in bytes.
    uint           dwProviderInfoSize;
    ///Offset from the beginning of the structure to the service provider information, in bytes. The
    ///<b>dwProviderInfoSize</b> and <b>dwProviderInfoOffset</b> members are intended to provide information about the
    ///provider hardware and/or software, such as the vendor name and version numbers of hardware and software. This
    ///information can be useful when a user needs to call customer service with problems regarding the provider.
    uint           dwProviderInfoOffset;
    ///Size of the variably sized device field containing switch information, in bytes.
    uint           dwSwitchInfoSize;
    ///Offset from the beginning of the structure to the switch information, in bytes. The <b>dwSwitchInfoSize</b> and
    ///<b>dwSwitchInfoOffset</b> members are intended to provide information about the switch to which the line device
    ///is connected, such as the switch manufacturer, the model name, the software version, and so on. This information
    ///can be useful when a user needs to call customer service with problems regarding the switch.
    uint           dwSwitchInfoOffset;
    ///Permanent identifier by which the line device is known in the system's configuration. It is a permanent name for
    ///the line device. This permanent name (as opposed to <i>dwDeviceID</i>) does not change as lines are added or
    ///removed from the system, and persists through operating system upgrades. It can therefore be used to link
    ///line-specific information in .ini files (or other files) in a way that is not affected by adding or removing
    ///other lines or by changing the operating system.
    uint           dwPermanentLineID;
    ///Size of the variably sized device field containing a user configurable name for this line device, in bytes.
    uint           dwLineNameSize;
    ///Offset from the beginning of this data structure to the name for this line device. This name can be configured by
    ///the user when configuring the line device's service provider, and is provided for the user's convenience. The
    ///size of the field is specified by <b>dwLineNameSize</b>.
    uint           dwLineNameOffset;
    ///String format used with this line device. This member uses one of the STRINGFORMAT_ Constants.
    uint           dwStringFormat;
    ///Mode by which the originating address is specified. This member uses the LINEADDRESSMODE_ Constants.
    uint           dwAddressModes;
    ///Number of addresses associated with this line device. Individual addresses are referred to by address
    ///identifiers. Address identifiers range from zero to one less than the value indicated by <b>dwNumAddresses</b>.
    uint           dwNumAddresses;
    ///Flag array that indicates the different bearer modes that the address is able to support. This member uses one or
    ///more of the LINEBEARERMODE_ Constants.
    uint           dwBearerModes;
    ///Maximum data rate for information exchange over the call, in bits per second.
    uint           dwMaxRate;
    ///Flag array that indicates the different media types the address is able to support. This member uses one or more
    ///of the LINEMEDIAMODE_ Constants.
    uint           dwMediaModes;
    ///Tones that can be generated on this line. This member uses one or more of the LINETONEMODE_ Constants.
    uint           dwGenerateToneModes;
    ///Maximum number of frequencies that can be specified in describing a general tone using the LINEGENERATETONE data
    ///structure when generating a tone using lineGenerateTone. A value of 0 indicates that tone generation is not
    ///available.
    uint           dwGenerateToneMaxNumFreq;
    ///Digit modes than can be generated on this line. This member uses one or more of the LINEDIGITMODE_ Constants.
    uint           dwGenerateDigitModes;
    ///Maximum number of frequencies that can be specified in describing a general tone using the LINEMONITORTONE data
    ///structure when monitoring a general tone using lineMonitorTones. A value of 0 indicates that tone monitor is not
    ///available.
    uint           dwMonitorToneMaxNumFreq;
    ///Maximum number of entries that can be specified in a tone list to lineMonitorTones.
    uint           dwMonitorToneMaxNumEntries;
    ///Digit modes than can be detected on this line. This member uses one or more of the LINEDIGITMODE_ Constants.
    uint           dwMonitorDigitModes;
    ///Minimum value that can be specified for both the first digit and inter-digit timeout values used by
    ///lineGatherDigits, in milliseconds. If both <b>dwGatherDigitsMinTimeout</b> and <b>dwGatherDigitsMaxTimeout</b>
    ///are zero, timeouts are not supported.
    uint           dwGatherDigitsMinTimeout;
    ///Maximum value that can be specified for both the first digit and inter-digit timeout values used by
    ///lineGatherDigits, in milliseconds. If both <b>dwGatherDigitsMinTimeout</b> and <b>dwGatherDigitsMaxTimeout</b>
    ///are zero, timeouts are not supported.
    uint           dwGatherDigitsMaxTimeout;
    ///Maximum number of entries that can be specified in the digit list parameter of lineSetMediaControl.
    uint           dwMedCtlDigitMaxListSize;
    ///Maximum number of entries that can be specified in the media list parameter of lineSetMediaControl.
    uint           dwMedCtlMediaMaxListSize;
    ///Maximum number of entries that can be specified in the tone list parameter of lineSetMediaControl.
    uint           dwMedCtlToneMaxListSize;
    ///Maximum number of entries that can be specified in the call state list parameter of lineSetMediaControl.
    uint           dwMedCtlCallStateMaxListSize;
    ///Boolean device capabilities. This member uses one or more of the LINEDEVCAPFLAGS_ Constants.
    uint           dwDevCapFlags;
    ///Maximum number of (minimum bandwidth) calls that can be active (connected) on the line at any one time. The
    ///actual number of active calls may be lower if higher bandwidth calls have been established on the line.
    uint           dwMaxNumActiveCalls;
    ///Effect on the active call when answering another offering call on a line device. This member uses one of the
    ///LINEANSWERMODE_ Constants.
    uint           dwAnswerMode;
    ///Number of different ring modes that can be reported in the LINE_LINEDEVSTATE message with the <i>ringing</i>
    ///indication. Different ring modes range from one to <b>dwRingModes</b>. Zero indicates no ring.
    uint           dwRingModes;
    ///Different line status components for which the application may be notified in a LINE_LINEDEVSTATE message on this
    ///line. This member uses one or more of the LINEDEVSTATE_ Constants.
    uint           dwLineStates;
    ///Maximum size of user-user information, including the <b>null</b> terminator, that can be sent during a call
    ///accept.
    uint           dwUUIAcceptSize;
    ///Maximum size of user-user information, including the <b>null</b> terminator, that can be sent during a call
    ///answer.
    uint           dwUUIAnswerSize;
    ///Maximum size of user-user information, including the <b>null</b> terminator, that can be sent during a make call.
    uint           dwUUIMakeCallSize;
    ///Maximum size of user-user information, including the <b>null</b> terminator, that can be sent during a call drop.
    uint           dwUUIDropSize;
    ///Maximum size of user-user information, including the <b>null</b> terminator, that can be sent separately any time
    ///during a call with lineSendUserUserInfo.
    uint           dwUUISendUserUserInfoSize;
    ///Maximum size of user-user information, including the <b>null</b> terminator, that can be received in the
    ///LINECALLINFO structure.
    uint           dwUUICallInfoSize;
    ///Minimum value for the dial parameters that can be set for calls on this line, in milliseconds. Dialing parameters
    ///can be set to values in the range <b>MinDialParams</b> to <b>MaxDialParams</b>. The granularity of the actual
    ///settings is service provider-specific.
    LINEDIALPARAMS MinDialParams;
    ///Maximum value for the dial parameters that can be set for calls on this line, in milliseconds. Dialing parameters
    ///can be set to values in the range <b>MinDialParams</b> to <b>MaxDialParams</b>. The granularity of the actual
    ///settings is service provider-specific.
    LINEDIALPARAMS MaxDialParams;
    ///Default dial parameters used for calls on this line. These parameter values can be overridden on a per-call
    ///basis.
    LINEDIALPARAMS DefaultDialParams;
    ///Number of terminals that can be set for this line device, its addresses, or its calls. Individual terminals are
    ///referred to by terminal IDs and range from zero to one less than the value indicated by <b>dwNumTerminals</b>.
    uint           dwNumTerminals;
    ///Size of the variably sized device field containing an array with entries of type LINETERMCAPS, in bytes.
    uint           dwTerminalCapsSize;
    ///Offset from the beginning of this structure to the variably sized device field containing an array with entries
    ///of type LINETERMCAPS. This array is indexed by terminal IDs, in the range from zero to <b>dwNumTerminals</b>
    ///minus one. Each entry in the array specifies the terminal device capabilities of the corresponding terminal. The
    ///size of the field is specified by <b>dwTerminalCapsSize</b>.
    uint           dwTerminalCapsOffset;
    ///Size of each of the terminal text descriptions, including the <b>null</b> terminator, pointed to by
    ///<b>dwTerminalTextSize</b> and <b>dwTerminalTextOffset</b>, in bytes.
    uint           dwTerminalTextEntrySize;
    ///Size of the variably sized field containing descriptive text about each of the line's available terminals,
    ///including the <b>null</b> terminator, in bytes
    uint           dwTerminalTextSize;
    ///Offset from the beginning of this structure to the descriptive text about each of the line's available terminals,
    ///in bytes. Each message is <b>dwTerminalTextEntrySize</b> bytes long. The string format of these textual
    ///descriptions is indicated by <b>dwStringFormat</b> in the line's device capabilities. The size of the field is
    ///specified by <b>dwTerminalTextSize</b>.
    uint           dwTerminalTextOffset;
    ///Size of the variably sized device-specific field, in bytes. If the device-specific information is a pointer to a
    ///string, the size must include the <b>null</b> terminator.
    uint           dwDevSpecificSize;
    ///Offset from the beginning of this structure to the device-specific field, in bytes. The size of the field is
    ///specified by <b>dwDevSpecificSize</b>.
    uint           dwDevSpecificOffset;
    ///Features available for this line using the LINEFEATURE_ Constants. Invoking a supported feature requires the line
    ///to be in the proper state and the underlying line device to be opened in a compatible mode. A zero in a bit
    ///position indicates that the corresponding feature is never available. A one indicates that the corresponding
    ///feature may be available if the line is in the appropriate state for the operation to be meaningful. This member
    ///allows an application to discover which line features can be (and which can never be) supported by the device.
    uint           dwLineFeatures;
    ///LINEDEVSTATUSFLAGS values that can be modified using lineSetLineDevStatus.
    uint           dwSettableDevStatus;
    ///Size of a string containing the device class identifiers supported on one or more addresses on this line,
    ///including the <b>null</b> terminator, in bytes.
    uint           dwDeviceClassesSize;
    ///Offset from the beginning of this structure to a string containing the device class identifiers supported on one
    ///or more addresses on this line, in bytes. These strings are for use with lineGetID; they are separated by
    ///<b>NULL</b>s, and the last identifier in the list is followed by two <b>NULL</b>s. The size of the field is
    ///specified by <b>dwDeviceClassesSize</b>.
    uint           dwDeviceClassesOffset;
    ///GUID permanently associated with the line device.
    GUID           PermanentLineGuid;
}

///The <b>LINEDEVSTATUS</b> structure describes the current status of a line device. The lineGetLineDevStatus function
///and the TSPI_lineGetLineDevStatus function return the <b>LINEDEVSTATUS</b> structure.
struct LINEDEVSTATUS
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size for this data structure that is needed to hold all the returned information, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Number of active opens on the line device.
    uint dwNumOpens;
    ///Bit array that indicates for which media types the line device is currently open.
    uint dwOpenMediaModes;
    ///Number of calls on the line in call states other than <i>idle</i>, <i>onhold</i>, <i>onholdpendingtransfer</i>,
    ///and <i>onholdpendingconference</i>.
    uint dwNumActiveCalls;
    ///Number of calls on the line in the <i>onhold</i> state.
    uint dwNumOnHoldCalls;
    ///Number of calls on the line in the <i>onholdpendingtransfer</i> or <i>onholdpendingconference</i> state.
    uint dwNumOnHoldPendCalls;
    ///Line-related functions that are currently available on this line. This member uses one or more of the
    ///LINEFEATURE_ Constants.
    uint dwLineFeatures;
    ///Number of outstanding call completion requests on the line.
    uint dwNumCallCompletions;
    ///Current ring mode on the line device.
    uint dwRingMode;
    ///Current signal level of the connection on the line. This is a value in the range 0x00000000 (weakest signal) to
    ///0x0000FFFF (strongest signal).
    uint dwSignalLevel;
    ///Current battery level of the line device hardware. This is a value in the range 0x00000000 (battery empty) to
    ///0x0000FFFF (battery full).
    uint dwBatteryLevel;
    ///Current roam mode of the line device. This member uses one of the LINEROAMMODE_ Constants.
    uint dwRoamMode;
    ///Flags that indicate status information, such as whether the device is locked. It consists of one or more members
    ///of LINEDEVSTATUSFLAGS_ Constants.
    uint dwDevStatusFlags;
    ///Size of the variably-sized device field containing an array of current terminal modes, in bytes.
    uint dwTerminalModesSize;
    ///Offset from the beginning of the structure to an array of current terminal modes, in bytes. This array is indexed
    ///by terminal IDs, in the range from zero to <b>dwNumTerminals</b> minus one. Each entry in the array specifies the
    ///current terminal modes for the corresponding terminal set using the lineSetTerminal function for this line. Each
    ///entry is a <b>DWORD</b> that specifies one or more of the LINETERMMODE_ Constants. The size of the array is
    ///specified by <b>dwTerminalModesSize</b>.
    uint dwTerminalModesOffset;
    ///Size of the variably sized device-specific field, in bytes. If the device-specific information is a pointer to a
    ///string, the size must include the <b>null</b> terminator.
    uint dwDevSpecificSize;
    ///Offset from the beginning of the structure to the device-specific field, in bytes. The size of the field is
    ///specified by <b>dwDevSpecificSize</b>.
    uint dwDevSpecificOffset;
    ///Indicates the media types that can be invoked on new calls created on this line device, when the
    ///<b>dwLineFeatures</b> member indicates that new calls are possible. If this member is zero, it indicates that the
    ///service provider either does not know or cannot indicate which media types are available, in which case any or
    ///all of the media types indicated in the <b>dwMediaModes</b> member in LINEDEVCAPS may be available.
    uint dwAvailableMediaModes;
    ///Size of the array that identifies the applications that have the line open, in bytes.
    uint dwAppInfoSize;
    ///Offset from the beginning of the structure to an array of LINEAPPINFO structures. The <b>dwNumOpens</b> member
    ///indicates the number of elements in the array. Each element in the array identifies an application that has the
    ///line open. The size of the array is specified by <b>dwAppInfoSize</b>.
    uint dwAppInfoOffset;
}

///The <b>LINEEXTENSIONID</b> structure describes an extension identifier. Extension identifiers are used to identify
///service provider-specific extensions for line devices. Multiple functions use this structure, including the
///lineNegotiateAPIVersion function and the TSPI_lineGetExtensionID function.
struct LINEEXTENSIONID
{
align (1):
    ///First part of the extension identifier.
    uint dwExtensionID0;
    ///Second part of the extension identifier.
    uint dwExtensionID1;
    ///Third part of the extension identifier.
    uint dwExtensionID2;
    ///Fourth part of the extension identifier.
    uint dwExtensionID3;
}

///The <b>LINEFORWARD</b> structure describes an entry of the forwarding instructions. The LINEFORWARDLIST and the
///LINEADDRESSSTATUS structures can contain an array of <b>LINEFORWARD</b> structures.
struct LINEFORWARD
{
align (1):
    ///Types of forwarding. This member uses one of the LINEFORWARDMODE_ Constants.
    uint dwForwardMode;
    ///Size of the variably sized field containing the address of a caller to be forwarded, in bytes.
    uint dwCallerAddressSize;
    ///Offset from the beginning of this structure to the variably sized field containing the address of a caller to be
    ///forwarded. This member is set to zero if <b>dwForwardMode</b> is not one of the following values: <a
    ///id="LINEFORWARDMODE_BUSYNASPECIFIC"></a> <a id="lineforwardmode_busynaspecific"></a>
    uint dwCallerAddressOffset;
    ///Country or region code of the destination address to which the call is to be forwarded.
    uint dwDestCountryCode;
    ///Size of the variably sized field containing the address of the address where calls are to be forwarded, in bytes.
    uint dwDestAddressSize;
    ///Offset from the beginning of this structure to the variably sized field containing the address of the address
    ///where calls are to be forwarded. The size of the field is specified by <b>dwDestAddressSize</b>.
    uint dwDestAddressOffset;
}

///The <b>LINEFORWARDLIST</b> structure describes a list of forwarding instructions. This structure can contain an array
///of LINEFORWARD structures. The lineForward and TSPI_lineForward functions use the <b>LINEFORWARDLIST</b> structure.
struct LINEFORWARDLIST
{
align (1):
    ///Total size of the data structure, in bytes.
    uint           dwTotalSize;
    ///Number of entries in the array specified as <b>ForwardList[]</b>.
    uint           dwNumEntries;
    ///Array of forwarding instruction. The array's entries are of type LINEFORWARD.
    LINEFORWARD[1] ForwardList;
}

///The <b>LINEGENERATETONE</b> structure contains information about a tone to be generated. This structure is used by
///the lineGenerateTone and TSPI_lineGenerateTone functions.
struct LINEGENERATETONE
{
align (1):
    ///Frequency of this tone component, in hertz. A service provider may adjust (round up or down) the frequency
    ///specified by the application to fit its resolution.
    uint dwFrequency;
    ///Length of the "on" duration of the cadence of the custom tone to be generated, in milliseconds. Zero means no
    ///tone is generated.
    uint dwCadenceOn;
    ///Length of the "off" duration of the cadence of the custom tone to be generated, in milliseconds. Zero means no
    ///off time, that is, a constant tone.
    uint dwCadenceOff;
    ///Volume level at which the tone is to be generated. A value of 0x0000FFFF represents full volume, and a value of
    ///0x00000000 is silence.
    uint dwVolume;
}

///The <b>LINEINITIZALIZEEXPARAMS</b> structure describes parameters supplied when making calls using LINEINITIALIZEEX.
struct LINEINITIALIZEEXPARAMS
{
align (1):
    ///Total size, in bytes, allocated to this data structure.
    uint dwTotalSize;
    ///Size for this data structure that is needed to hold all the returned information, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///One of the LINEINITIALIZEEXOPTION_ Constants. Specifies the event notification mechanism the application desires
    ///to use.
    uint dwOptions;
    union Handles
    {
    align (1):
        HANDLE hEvent;
        HANDLE hCompletionPort;
    }
    ///If <b>dwOptions</b> specifies LINEINITIALIZEEXOPTION_USECOMPLETIONPORT, the application must specify in this
    ///field a value that is returned through the <i>lpCompletionKey</i> parameter of GetQueuedCompletionStatus to
    ///identify the completion message as a telephony message.
    uint dwCompletionKey;
}

///The <b>LINELOCATIONENTRY</b> structure describes a location used to provide an address translation context. The
///LINETRANSLATECAPS structure can contain an array of <b>LINELOCATIONENTRY</b> structures.
struct LINELOCATIONENTRY
{
align (1):
    ///Permanent. Identifies the location.
    uint dwPermanentLocationID;
    ///Size, in characters, of a <b>null</b>-terminated location name string including the <b>null</b>-terminating
    ///character.
    uint dwLocationNameSize;
    ///Offset size, specified in <b>dwLocationNameSize</b>, from the beginning of the LINETRANSLATECAPS structure (that
    ///contains this entry) to a <b>null</b>-terminated string that describes the location in a user-friendly manner.
    uint dwLocationNameOffset;
    ///Country or region code of the location.
    uint dwCountryCode;
    ///Size, in characters, of the <b>null</b>-terminated city code string, including the <b>null</b>-terminating
    ///character.
    uint dwCityCodeSize;
    ///Offset, specified in <b>dwCityCodeSize</b>, from the beginning of this structure to a <b>null</b>-terminated
    ///string specifying the city/area code associated with the location. This information, with the country or region
    ///code, can be used by applications to "default" entry fields for the user when entering phone numbers, to
    ///encourage the entry of proper canonical numbers.
    uint dwCityCodeOffset;
    ///Preferred calling card when dialing from this location.
    uint dwPreferredCardID;
    ///Size, in bytes, of the local access code string, including the <b>null</b> terminator.
    uint dwLocalAccessCodeSize;
    ///Offset size, specified in <b>dwLocalAccessCodeSize</b>, from the beginning of the LINETRANSLATECAPS structure to
    ///a <b>null</b>-terminated string containing the access code to be dialed before calls to addresses in the local
    ///calling area.
    uint dwLocalAccessCodeOffset;
    ///Size, in bytes, of the long distance access code, including the <b>null</b> terminator.
    uint dwLongDistanceAccessCodeSize;
    ///Offset size, specified in <b>dwLongDistanceAccessCodeSize</b>, from the beginning of the LINETRANSLATECAPS
    ///structure to a <b>null</b>-terminated string containing the access code to be dialed before calls to addresses
    ///outside the local calling area.
    uint dwLongDistanceAccessCodeOffset;
    ///Size, in bytes, of the toll prefix, including the <b>null</b> terminator.
    uint dwTollPrefixListSize;
    ///Offset size, specified in <b>dwTollPrefixListSize</b>, from the beginning of the LINETRANSLATECAPS structure to a
    ///<b>null</b>-terminated string containing the toll prefix list for the location. The string contains only prefixes
    ///consisting of the digits "0" through "9", separated from each other by a single "," (comma) character.
    uint dwTollPrefixListOffset;
    ///Identifier of the country/region selected for the location. This can be used with the lineGetCountry function to
    ///obtain additional information about the specific country/region, such as the country/region name (the
    ///<b>dwCountryCode</b> member cannot be used for this purpose because country/region codes are not unique).
    uint dwCountryID;
    ///Options in effect for this location, with values taken from the LINELOCATIONOPTION_ Constants.
    uint dwOptions;
    ///Size, in bytes, of the cancel-call-waiting string.
    uint dwCancelCallWaitingSize;
    ///Offset size, specified in <b>dwCancelCallWaitingSize</b>, from the beginning of the LINETRANSLATECAPS structure
    ///to a <b>null</b>-terminated string containing the dial digits and modifier characters that should be prefixed to
    ///the dialable string (after the pulse/tone character) when an application sets the
    ///LINETRANSLATEOPTION_CANCELCALLWAITING bit in the <i>dwTranslateOptions</i> parameter of lineTranslateAddress. If
    ///no prefix is defined, <b>dwCancelCallWaitingSize</b> may be set to zero, or 1, and
    ///<b>dwCancelCallWaitingOffset</b> may point to an empty string (single <b>NULL</b> byte).
    uint dwCancelCallWaitingOffset;
}

///The <b>LINEMEDIACONTROLCALLSTATE</b> structure describes a media action to be executed when detecting transitions
///into one or more call states. The lineSetMediaControl and TSPI_lineSetMediaControl functions use this structure.
struct LINEMEDIACONTROLCALLSTATE
{
align (1):
    ///One or more call states. This member uses one of the LINECALLSTATE_ Constants.
    uint dwCallStates;
    ///Media control action. This member uses one of the LINEMEDIACONTROL_ Constants.
    uint dwMediaControl;
}

///The <b>LINEMEDIACONTROLDIGIT</b> structure describes a media action to be executed when detecting a digit. It is used
///as an entry in an array. The lineSetMediaControl and TSPI_lineSetMediaControl functions use this structure.
struct LINEMEDIACONTROLDIGIT
{
align (1):
    ///Low-order byte is the digit in whose detection is to trigger a media action. Valid digits depend on the media
    ///type.
    uint dwDigit;
    ///Digit mode(s) to monitor. This member uses one or more of the LINEDIGITMODE_ Constants.
    uint dwDigitModes;
    ///Media control action. This member uses one of the LINEMEDIACONTROL_ Constants.
    uint dwMediaControl;
}

///The <b>LINEMEDIACONTROLMEDIA</b> structure describes a media action to be executed when detecting a media type
///change. It is used as an entry in an array. The lineSetMediaControl and TSPI_lineSetMediaControl functions use this
///structure.
struct LINEMEDIACONTROLMEDIA
{
align (1):
    ///One or more media types. This member uses one of the LINEMEDIAMODE_ Constants.
    uint dwMediaModes;
    ///Duration of time during which the media type should be present before the application should be notified or media
    ///control action should be taken, in milliseconds.
    uint dwDuration;
    ///Media control action. This member uses one of the LINEMEDIACONTROL_ Constants.
    uint dwMediaControl;
}

///The <b>LINEMEDIACONTROLTONE</b> structure describes a media action to be executed when a tone has been detected. It
///is used as an entry in an array. The lineSetMediaControl and TSPI_lineSetMediaControl functions use this structure.
struct LINEMEDIACONTROLTONE
{
align (1):
    ///Used by the application for tagging the tone. When this tone is detected, the value of the <b>dwAppSpecific</b>
    ///member is passed back to the application.
    uint dwAppSpecific;
    ///Duration of time during which the tone should be present before a detection is made, in milliseconds.
    uint dwDuration;
    ///First frequency of the tone, in hertz.
    uint dwFrequency1;
    ///Second frequency of the tone, in hertz.
    uint dwFrequency2;
    ///Third frequency of the tone, in hertz. If fewer than three frequencies are needed in the tone, a value of 0
    ///should be used for the unused frequencies. A tone with all three frequencies set to zero is interpreted as
    ///silence and can be use for silence detection.
    uint dwFrequency3;
    ///Media control action. This member uses one of the LINEMEDIACONTROL_ Constants.
    uint dwMediaControl;
}

///The <b>LINEMESSAGE</b> structure contains parameter values specifying a change in status of the line the application
///currently has open. The lineGetMessage function returns the <b>LINEMESSAGE</b> structure.
struct LINEMESSAGE
{
align (1):
    ///Handle to either a line device or a call. The nature of this handle (line handle or call handle) can be
    ///determined by the context provided by <i>dwMessageID</i>.
    uint   hDevice;
    ///Line or call device message.
    uint   dwMessageID;
    ///Instance data passed back to the application, which was specified by the application in the
    ///<i>dwCallBackInstance</i> parameter of lineInitializeEx. This <b>DWORD</b> is not interpreted by TAPI.
    size_t dwCallbackInstance;
    ///Parameter for the message.
    size_t dwParam1;
    ///Parameter for the message.
    size_t dwParam2;
    ///Parameter for the message.
    size_t dwParam3;
}

///The <b>LINEMONITORTONE</b> structure describes a tone to be monitored. This is used as an entry in an array. The
///lineMonitorTones and TSPI_lineMonitorTones functions use this structure.
struct LINEMONITORTONE
{
align (1):
    ///Used by the application for tagging the tone. When this tone is detected, the value of the <b>dwAppSpecific</b>
    ///member is passed back to the application.
    uint dwAppSpecific;
    ///Duration of time during which the tone should be present before a detection is made, in milliseconds.
    uint dwDuration;
    ///First frequency of the tone, in hertz.
    uint dwFrequency1;
    ///Second frequency of the tone, in hertz.
    uint dwFrequency2;
    ///Third frequency of the tone, in hertz. If fewer than three frequencies are needed in the tone, a value of 0
    ///should be used for the unused frequencies. A tone with all three frequencies set to zero is interpreted as
    ///silence and can be use for silence detection.
    uint dwFrequency3;
}

///The <b>LINEPROVIDERENTRY</b> structure provides the information for a single service provider entry. An array of
///these structures is returned as part of the LINEPROVIDERLIST structure returned by the function lineGetProviderList.
struct LINEPROVIDERENTRY
{
align (1):
    ///Permanent provider identifier of the entry.
    uint dwPermanentProviderID;
    ///Size of the provider file name string, including the <b>null</b> terminator, in bytes.
    uint dwProviderFilenameSize;
    ///Offset from the beginning of the LINEPROVIDERLIST structure to a <b>null</b>-terminated string containing the
    ///file name (path) of the service provider DLL (.TSP) file. The size of the string is specified by
    ///<b>dwProviderFilenameSize</b>.
    uint dwProviderFilenameOffset;
}

///The <b>LINEPROVIDERLIST</b> structure describes a list of service providers. A structure of this type is returned by
///the lineGetProviderList function. The <b>LINEPROVIDERLIST</b> structure can contain an array of LINEPROVIDERENTRY
///structures.
struct LINEPROVIDERLIST
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size for this data structure that is needed to hold all the returned information, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Number of LINEPROVIDERENTRY structures present in the array denominated by <b>dwProviderListSize</b> and
    ///<b>dwProviderListOffset</b>.
    uint dwNumProviders;
    ///Size of the provider list array, in bytes.
    uint dwProviderListSize;
    ///Offset from the beginning of this structure to an array of LINEPROVIDERENTRY elements, which provide the
    ///information on each service provider. The size of the array is specified by <b>dwProviderListSize</b>.
    uint dwProviderListOffset;
}

///The <b>LINEPROXYREQUEST</b> structure contains parameter values of the application making the proxy request. Multiple
///TAPI call center functions generate a LINE_PROXYREQUEST message that references a <b>LINEPROXYREQUEST</b> structure.
struct LINEPROXYREQUEST
{
align (1):
    ///Total number of bytes allocated by TAPI to contain the <b>LINEPROXYREQUEST</b> structure. The <b>dwTotalSize</b>
    ///member of any structure contained within <b>LINEPROXYREQUEST</b> (for example, LINEAGENTCAPS) reflects only the
    ///number of bytes allocated for that specific structure. Total size, in bytes, of the <i>Params</i> parameter
    ///block.
    uint dwSize;
    ///Size of the client machine name string, in bytes, including the <b>null</b>-terminating character.
    uint dwClientMachineNameSize;
    ///Offset from the beginning of the structure to a <b>null</b>-terminated string identifying the client machine that
    ///made this request. The size of the string is specified by <b>dwClientMachineNameSize</b>.
    uint dwClientMachineNameOffset;
    ///Size of the client user name string, in bytes, including the <b>null</b>-terminating character.
    uint dwClientUserNameSize;
    ///Offset from the beginning of the structure to a <b>null</b>-terminated string identifying the user under whose
    ///account the application is running on the client machine. The size of the string is specified by
    ///<b>dwClientUserNameSize</b>.
    uint dwClientUserNameOffset;
    ///Highest API version supported by the application that made the request. The proxy handler should restrict the
    ///contents of any data returned to the application to those members and values that were defined in this, or
    ///earlier, versions of TAPI.
    uint dwClientAppAPIVersion;
    ///One of the LINEPROXYREQUEST_ Constants. Identifies the type of function and the union component that defines the
    ///remaining data in the structure.
    uint dwRequestType;
    union
    {
        struct SetAgentGroup
        {
        align (1):
            uint               dwAddressID;
            LINEAGENTGROUPLIST GroupList;
        }
        struct SetAgentState
        {
        align (1):
            uint dwAddressID;
            uint dwAgentState;
            uint dwNextAgentState;
        }
        struct SetAgentActivity
        {
        align (1):
            uint dwAddressID;
            uint dwActivityID;
        }
        struct GetAgentCaps
        {
        align (1):
            uint          dwAddressID;
            LINEAGENTCAPS AgentCaps;
        }
        struct GetAgentStatus
        {
        align (1):
            uint            dwAddressID;
            LINEAGENTSTATUS AgentStatus;
        }
        struct AgentSpecific
        {
        align (1):
            uint     dwAddressID;
            uint     dwAgentExtensionIDIndex;
            uint     dwSize;
            ubyte[1] Params;
        }
        struct GetAgentActivityList
        {
        align (1):
            uint dwAddressID;
            LINEAGENTACTIVITYLIST ActivityList;
        }
        struct GetAgentGroupList
        {
        align (1):
            uint               dwAddressID;
            LINEAGENTGROUPLIST GroupList;
        }
        struct CreateAgent
        {
        align (1):
            uint hAgent;
            uint dwAgentIDSize;
            uint dwAgentIDOffset;
            uint dwAgentPINSize;
            uint dwAgentPINOffset;
        }
        struct SetAgentStateEx
        {
        align (1):
            uint hAgent;
            uint dwAgentState;
            uint dwNextAgentState;
        }
        struct SetAgentMeasurementPeriod
        {
        align (1):
            uint hAgent;
            uint dwMeasurementPeriod;
        }
        struct GetAgentInfo
        {
        align (1):
            uint          hAgent;
            LINEAGENTINFO AgentInfo;
        }
        struct CreateAgentSession
        {
        align (1):
            uint hAgentSession;
            uint dwAgentPINSize;
            uint dwAgentPINOffset;
            uint hAgent;
            GUID GroupID;
            uint dwWorkingAddressID;
        }
        struct GetAgentSessionList
        {
        align (1):
            uint                 hAgent;
            LINEAGENTSESSIONLIST SessionList;
        }
        struct GetAgentSessionInfo
        {
        align (1):
            uint                 hAgentSession;
            LINEAGENTSESSIONINFO SessionInfo;
        }
        struct SetAgentSessionState
        {
        align (1):
            uint hAgentSession;
            uint dwAgentSessionState;
            uint dwNextAgentSessionState;
        }
        struct GetQueueList
        {
        align (1):
            GUID          GroupID;
            LINEQUEUELIST QueueList;
        }
        struct SetQueueMeasurementPeriod
        {
        align (1):
            uint dwQueueID;
            uint dwMeasurementPeriod;
        }
        struct GetQueueInfo
        {
        align (1):
            uint          dwQueueID;
            LINEQUEUEINFO QueueInfo;
        }
        struct GetGroupList
        {
            LINEAGENTGROUPLIST GroupList;
        }
    }
}

///The <b>LINEREQMAKECALL</b> structure describes a request initiated by a call to the lineGetRequest function.
struct LINEREQMAKECALL
{
    ///<b>Null</b>-terminated destination address of the make-call request. The address can use the canonical address
    ///format or the dialable address format. The maximum length of the address is TAPIMAXDESTADDRESSSIZE characters,
    ///which includes the <b>NULL</b> terminator. Longer strings are truncated.
    byte[80] szDestAddress;
    ///<b>Null</b>-terminated user-friendly application name or filename of the application that originated the request.
    ///The maximum length of the address is TAPIMAXAPPNAMESIZE characters, which includes the <b>NULL</b> terminator.
    byte[40] szAppName;
    ///<b>Null</b>-terminated user-friendly called-party name. The maximum length of the called-party information is
    ///TAPIMAXCALLEDPARTYSIZE characters, which includes the <b>NULL</b> terminator.
    byte[40] szCalledParty;
    ///<b>Null</b>-terminated comment about the call request. The maximum length of the comment string is
    ///TAPIMAXCOMMENTSIZE characters, which includes the <b>NULL</b> terminator.
    byte[80] szComment;
}

struct linereqmakecallW_tag
{
align (1):
    ushort[80] szDestAddress;
    ushort[40] szAppName;
    ushort[40] szCalledParty;
    ushort[80] szComment;
}

///The <b>LINEREQMEDIACALL</b> structure describes a request initiated by a call to the lineGetRequest function. This
///data structure is obsolete and should not be used.
struct LINEREQMEDIACALL
{
align (1):
    ///A handle to the window of the application that made the request.
    HWND      hWnd;
    ///The identifier of the request. Used to match an asynchronous response.
    WPARAM    wRequestID;
    ///The device class required to fill the request.
    byte[40]  szDeviceClass;
    ///The device identifier.
    ubyte[40] ucDeviceID;
    ///Size, in bytes, of this structure.
    uint      dwSize;
    ///Not used.
    uint      dwSecure;
    ///The destination address.
    byte[80]  szDestAddress;
    ///The name of application that made the request.
    byte[40]  szAppName;
    ///The called party name.
    byte[40]  szCalledParty;
    ///The comment buffer.
    byte[80]  szComment;
}

struct linereqmediacallW_tag
{
align (1):
    HWND       hWnd;
    WPARAM     wRequestID;
    ushort[40] szDeviceClass;
    ubyte[40]  ucDeviceID;
    uint       dwSize;
    uint       dwSecure;
    ushort[80] szDestAddress;
    ushort[40] szAppName;
    ushort[40] szCalledParty;
    ushort[80] szComment;
}

///The <b>LINETERMCAPS</b> structure describes the capabilities of a line's terminal device. The LINEDEVCAPS structure
///can contain an array of <b>LINETERMCAPS</b> structures.
struct LINETERMCAPS
{
align (1):
    ///Device type of the terminal. This member uses one of the LINETERMDEV_ Constants.
    uint dwTermDev;
    ///Terminal mode(s) the terminal device is able to deal with. This member uses one of the LINETERMMODE_ Constants.
    uint dwTermModes;
    ///Sharing modes for the terminal device. This member uses one of the LINETERMSHARING_ Constants.
    uint dwTermSharing;
}

///The <b>LINETRANSLATECAPS</b> structure describes the address translation capabilities. This structure can contain an
///array of LINELOCATIONENTRY structures and an array of LINECARDENTRY structures. The <b>LINETRANSLATECAPS</b>
///structure is returned by the lineGetTranslateCaps function.
struct LINETRANSLATECAPS
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size for this data structure that is needed to hold all the returned information, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Number of entries in the <b>LocationList</b>. It includes all locations defined, including zero (default).
    uint dwNumLocations;
    ///Size of the list of locations known to the address translation, in bytes.
    uint dwLocationListSize;
    ///Offset from the beginning of this structure to the list of locations known to the address translation. The list
    ///consists of a sequence of LINELOCATIONENTRY structures. The <b>dwLocationListOffset</b> member points to the
    ///first byte of the first structure, and the <b>dwLocationListSize</b> member indicates the total number of bytes
    ///in the list.
    uint dwLocationListOffset;
    ///Permanent identifier for the <b>CurrentLocation</b> entry in the [Locations] section of the registry. See the
    ///<b>dwPermanentLocationID</b> member of the LINELOCATIONENTRY structure.
    uint dwCurrentLocationID;
    ///Number of entries in the <b>CardList</b>.
    uint dwNumCards;
    ///Size of the list of calling cards known to the address translation, in bytes.
    uint dwCardListSize;
    ///Offset from the beginning of this structure to the list of calling cards known to the address translation. It
    ///includes only non-hidden card entries and always includes card 0 (direct dial). The list consists of a sequence
    ///of LINECARDENTRY structures. The <b>dwCardListOffset</b> member points to the first byte of the first structure,
    ///and the <b>dwCardListSize</b> member indicates the total number of bytes in the list.
    uint dwCardListOffset;
    ///Preferred calling card for the <b>CurrentLocation</b> entry in the [Locations] section of the registry. See the
    ///<b>dwPreferredCardID</b> member of the LINELOCATIONENTRY structure.
    uint dwCurrentPreferredCardID;
}

///The <b>LINETRANSLATEOUTPUT</b> structure describes the result of an address translation. The lineTranslateAddress
///function uses this structure.
struct LINETRANSLATEOUTPUT
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size needed for this data structure to hold all the returned information, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Size dialable string, in bytes, including the terminating <b>NULL</b>.
    uint dwDialableStringSize;
    ///Offset from the beginning of this structure to the translated output that can be passed to the lineMakeCall,
    ///lineDial, or other function requiring a dialable string. The output is always a <b>null</b>-terminated string.
    ///Ancillary fields such as name and subaddress are included in this output string if they were in the input string.
    ///This string may contain private information such as calling card numbers. It should not be displayed to the user,
    ///to prevent inadvertent visibility to unauthorized persons. The size of the field is specified by
    ///<b>dwDialableStringSize</b>.
    uint dwDialableStringOffset;
    ///Size of the translated output that can be displayed to the user, including the <b>null</b> terminator, in bytes.
    uint dwDisplayableStringSize;
    ///Offset to the translated output that can be displayed to the user for confirmation. It is identical to
    ///<b>DialableString</b>, except the calling card digits are replaced with the friendly name of the card enclosed
    ///within bracket characters (for example, "[AT&amp;T Card]"), and ancillary fields such as name and subaddress are
    ///removed. Use an appropriate message in <b>dwDisplayableStringOffset</b>, because the string might be displayed
    ///publicly in the call-status dialog box. This information is also appropriate to include in call logs. The size of
    ///the field is specified by <b>dwDisplayableStringSize</b>.
    uint dwDisplayableStringOffset;
    ///Country or region code configured in <b>CurrentLocation</b>. This value may be used to control the display by the
    ///application of certain user interface elements, for local call progress tone detection, and for other purposes.
    uint dwCurrentCountry;
    ///Destination country/region code of the translated address. This value may be passed to the <i>dwCountryCode</i>
    ///parameter of lineMakeCall and other dialing functions (so that the call progress tones of the destination
    ///country/region such as a busy signal are properly detected). This field is set to zero if the destination address
    ///passed to lineTranslateAddress is not in canonical format.
    uint dwDestCountry;
    ///Information derived from the translation process, which may assist the application in presenting user-interface
    ///elements. This field uses one of the LINETRANSLATERESULT_ Constants.
    uint dwTranslateResults;
}

///The <b>PHONEBUTTONINFO</b> structure contains information about a button on a phone device. This structure is used by
///multiple TAPI and TSPI functions.
struct PHONEBUTTONINFO
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size for this data structure that is needed to hold all the returned information, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Mode or general usage class of the button. This member uses one of the PHONEBUTTONMODE_ Constants.
    uint dwButtonMode;
    ///Function assigned to the button. This member uses one of the PHONEBUTTONFUNCTION_ Constants.
    uint dwButtonFunction;
    ///Size of the descriptive text for the button, in bytes.
    uint dwButtonTextSize;
    ///Offset from the beginning of this structure to the variably sized field containing descriptive text for this
    ///button. The format of this information is as specified in the <b>dwStringFormat</b> member of the phone's device
    ///capabilities. The size of the field is specified by <b>dwButtonTextSize</b>.
    uint dwButtonTextOffset;
    ///Size of the device-specific field, in bytes. If the device-specific field is a pointer to a string, the size must
    ///include the <b>null</b> terminator.
    uint dwDevSpecificSize;
    ///Offset from the beginning of the structure to the variably sized device-specific field. The size of the field is
    ///specified by <b>dwDevSpecificSize</b>.
    uint dwDevSpecificOffset;
    ///For the phoneGetButtonInfo function, this field indicates the current state of the button, using the
    ///PHONEBUTTONSTATE_ Constants. This field is ignored by the phoneSetButtonInfo function.
    uint dwButtonState;
}

///The <b>PHONECAPS</b> structure describes the capabilities of a phone device. The phoneGetDevCaps and
///TSPI_phoneGetDevCaps functions return this structure.
struct PHONECAPS
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size for this data structure that is needed to hold all the returned information, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Size of the provider-specific information, in bytes. If the provider-specific information is a pointer to a
    ///string, the size must include the <b>null</b> terminator.
    uint dwProviderInfoSize;
    ///Offset from the beginning of the structure to the variably sized field containing service provider-specific
    ///information. This member provides information about the provider hardware and/or software, such as the vendor
    ///name and version numbers of hardware and software. This information can be useful when a user needs to call
    ///customer service with problems regarding the provider. The size of the field is specified by
    ///<b>dwProviderInfoSize</b>.
    uint dwProviderInfoOffset;
    ///Size of the phone-specific information, in bytes. If the phone-specific information is a pointer to a string, the
    ///size must include the <b>null</b> terminator.
    uint dwPhoneInfoSize;
    ///Offset from the beginning of the structure to the variably sized device field containing phone-specific
    ///information. This member provides information about the attached phone device, such as the phone device
    ///manufacturer, the model name, the software version, and so on. This information can be useful when a user needs
    ///to call customer service with problems regarding the phone. The size of the field is specified by
    ///<b>dwPhoneInfoSize</b>.
    uint dwPhoneInfoOffset;
    ///Permanent identifier by which the phone device is known in the system's configuration.
    uint dwPermanentPhoneID;
    ///Size of the configurable name for the phone, including the <b>null</b> terminator, in bytes.
    uint dwPhoneNameSize;
    ///Offset from the beginning of the structure to the variably sized device field containing a user configurable name
    ///for this phone device. This name can be configured by the user when configuring the phone device's service
    ///provider and is provided for the user's convenience. The size of the field is specified by
    ///<b>dwPhoneNameSize</b>.
    uint dwPhoneNameOffset;
    ///String format to be used with this phone device. This member uses one of the STRINGFORMAT_ Constants.
    uint dwStringFormat;
    ///State changes for this phone device for which the application can be notified in a PHONE_STATE message. This
    ///member one or more of the PHONESTATE_ Constants.
    uint dwPhoneStates;
    ///Phone's hookswitch devices. This member uses one of the PHONEHOOKSWITCHDEV_ Constants.
    uint dwHookSwitchDevs;
    ///Hookswitch mode of the handset. The member is only meaningful if the hookswitch device is listed in
    ///<b>dwHookSwitchDevs</b>. It uses one of the PHONEHOOKSWITCHMODE_ Constants.
    uint dwHandsetHookSwitchModes;
    ///Hookswitch mode of the speaker. The member is only meaningful if the hookswitch device is listed in
    ///<b>dwHookSwitchDevs</b>. It uses one of the PHONEHOOKSWITCHMODE_ Constants.
    uint dwSpeakerHookSwitchModes;
    ///Hookswitch mode of the headset. The member is only meaningful if the hookswitch device is listed in
    ///<b>dwHookSwitchDevs</b>. It uses one of the PHONEHOOKSWITCHMODE_ Constants.
    uint dwHeadsetHookSwitchModes;
    ///Volume-setting capabilities of the phone device's speaker components. If the bit in position PHONEHOOKSWITCHDEV_
    ///is <b>TRUE</b>, the volume of the corresponding hookswitch device's speaker component can be adjusted with
    ///phoneSetVolume.
    uint dwVolumeFlags;
    ///Gain-setting capabilities of the phone device's microphone components. If the bit position PHONEHOOKSWITCHDEV_ is
    ///<b>TRUE</b>, the volume of the corresponding hookswitch device's microphone component can be adjusted with
    ///phoneSetGain.
    uint dwGainFlags;
    ///Display capabilities of the phone device by describing the number of rows in the phone display. The
    ///<b>dwDisplayNumRows</b> and <b>dwDisplayNumColumns</b> members are both zero for a phone device without a
    ///display.
    uint dwDisplayNumRows;
    ///Display capabilities of the phone device by describing the number of columns in the phone display. The
    ///<b>dwDisplayNumRows</b> and <b>dwDisplayNumColumns</b> members are both zero for a phone device without a
    ///display.
    uint dwDisplayNumColumns;
    ///Ring capabilities of the phone device. The phone is able to ring with <b>dwNumRingModes</b> different ring
    ///patterns, identified as 1, 2, through <b>dwNumRingModes</b> minus one. If the value of this member is 0,
    ///applications have no control over the ring mode of the phone. If the value of this member is greater than 0, it
    ///indicates the number of ring modes in addition to silence that are supported by the service provider. A value of
    ///0 in the <i>lpdwRingMode</i> parameter of phoneGetRing or the <i>dwRingMode</i> parameter of phoneSetRing
    ///indicates silence (the phone is not ringing or should not be rung), and <i>dwRingMode</i> values of 1 to
    ///<b>dwNumRingModes</b> are valid ring modes for the phone device.
    uint dwNumRingModes;
    ///Number of button/lamps on the phone device that are detectable in TAPI. Button/lamps are identified by their
    ///identifier. Valid button/lamp identifiers range from zero to <b>dwNumButtonLamps</b> minus one. The keypad
    ///buttons '0', through '9', '*', and '
    uint dwNumButtonLamps;
    ///Size of the button modes array, in bytes.
    uint dwButtonModesSize;
    ///Offset from the beginning of this structure to the variably sized field containing the button modes of the
    ///phone's buttons. The array is indexed by button/lamp identifier. This array uses the PHONEBUTTONMODE_ Constants.
    ///The size of the array is specified by <b>dwButtonModesSize</b>.
    uint dwButtonModesOffset;
    ///Size of the button functions field, in bytes.
    uint dwButtonFunctionsSize;
    ///Offset from the beginning of this structure to the variably sized field containing the button functions of the
    ///phone's buttons. The array is indexed by button/lamp identifier. This array uses the PHONEBUTTONFUNCTION_
    ///Constants. The size of the array is specified by <b>dwButtonFunctionsSize</b>.
    uint dwButtonFunctionsOffset;
    ///Size of the lamp modes array, in bytes.
    uint dwLampModesSize;
    ///Offset from the beginning of this structure to the variably sized field containing the lamp modes of the phone's
    ///lamps. The array is indexed by button/lamp identifier. This array uses the PHONELAMPMODE_ Constants. The size of
    ///the array is specified by <b>dwLampModesSize</b>.
    uint dwLampModesOffset;
    ///Number of different download areas in the phone device. The different areas are referred to using the data IDs 0,
    ///1, , <b>dwNumSetData</b> minus one. If this member is zero, the phone does not support the download capability.
    uint dwNumSetData;
    ///Size of the data size array, in bytes.
    uint dwSetDataSize;
    ///Offset from the beginning of this structure to the variably sized field containing the sizes (in bytes) of the
    ///phone's download data areas. This is an array with <b>DWORD</b>-sized elements indexed by data identifier. The
    ///size of the array is specified by <b>dwSetDataSize</b>.
    uint dwSetDataOffset;
    ///Number of different upload areas in the phone device. The different areas are referred to using the data IDs 0,
    ///1, , <b>dwNumGetData</b> minus one. If this field is zero, the phone does not support the upload capability.
    uint dwNumGetData;
    ///Size of the data size array, in bytes.
    uint dwGetDataSize;
    ///Offset from the beginning of this structure to the variably sized field containing the sizes (in bytes) of the
    ///phone's upload data areas. This is an array with <b>DWORD</b>-sized elements indexed by data identifier. The size
    ///of the array is specified by <b>dwGetDataSize</b>.
    uint dwGetDataOffset;
    ///Size of the device-specific field, in bytes. If the device specific information is a pointer to a string, the
    ///size must include the <b>null</b> terminator.
    uint dwDevSpecificSize;
    ///Offset from the beginning of this structure to the variably sized device-specific field. The size of the field is
    ///specified by <b>dwDevSpecificSize</b>.
    uint dwDevSpecificOffset;
    ///Size of the supported device class identifiers, in bytes.
    uint dwDeviceClassesSize;
    ///Offset from the beginning of this structure to a string consisting of the device class identifiers supported on
    ///this device for use with phoneGetID. The identifiers are separated by <b>NULL</b>s, and the last identifier in
    ///the list is followed by two <b>NULL</b>s. The size of the field is specified by <b>dwDeviceClassesSize</b>.
    uint dwDeviceClassesOffset;
    ///Flags that indicate which Telephony API functions can be invoked on the phone. A zero indicates the corresponding
    ///feature is not implemented and can never be invoked by the application on the phone; a one indicates the feature
    ///may be invoked depending on the device state and other factors. This member uses PHONEFEATURE_ Constants.
    uint dwPhoneFeatures;
    ///PHONEHOOKSWITCHMODE_ values that can be set on the handset using phoneSetHookSwitch.
    uint dwSettableHandsetHookSwitchModes;
    ///PHONEHOOKSWITCHMODE_ values that can be set on the speakerphone using phoneSetHookSwitch.
    uint dwSettableSpeakerHookSwitchModes;
    ///PHONEHOOKSWITCHMODE_ values that can be set on the headset using phoneSetHookSwitch.
    uint dwSettableHeadsetHookSwitchModes;
    ///PHONEHOOKSWITCHMODE_ values that can be detected and reported for the handset in a PHONE_STATE message and by
    ///phoneGetHookSwitch.
    uint dwMonitoredHandsetHookSwitchModes;
    ///PHONEHOOKSWITCHMODE_ values that can be detected and reported for the speakerphone in a PHONE_STATE message and
    ///by phoneSetHookSwitch.
    uint dwMonitoredSpeakerHookSwitchModes;
    ///PHONEHOOKSWITCHMODE_ values that can be detected and reported for the headset in a PHONE_STATE message and by
    ///phoneSetHookSwitch.
    uint dwMonitoredHeadsetHookSwitchModes;
    ///The GUID permanently associated with this phone.
    GUID PermanentPhoneGuid;
}

///The <b>PHONEEXTENSIONID</b> structure describes an extension identifier. Extension identifiers are used to identify
///service provider-specific extensions for phone device classes. The phoneNegotiateAPIVersion and
///TSPI_phoneGetExtensionID functions return this structure.
struct PHONEEXTENSIONID
{
align (1):
    ///First part of the extension identifier.
    uint dwExtensionID0;
    ///Second part of the extension identifier.
    uint dwExtensionID1;
    ///Third part of the extension identifier.
    uint dwExtensionID2;
    ///Fourth part of the extension identifier.
    uint dwExtensionID3;
}

///The <b>PHONEINITIALIZEEXPARAMS</b> structure contains parameters used to establish the association between an
///application and TAPI; for example, the application's selected event notification mechanism. The phoneInitializeEx
///function uses this structure.
struct PHONEINITIALIZEEXPARAMS
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size for this data structure that is needed to hold all the returned information, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///One of the PHONEINITIALIZEEXOPTION_ Constants. Specifies the event notification mechanism the application desires
    ///to use.
    uint dwOptions;
    union Handles
    {
    align (1):
        HANDLE hEvent;
        HANDLE hCompletionPort;
    }
    ///If <b>dwOptions</b> specifies PHONEINITIALIZEEXOPTION_USECOMPLETIONPORT, the application must specify in this
    ///field a value that is returned through the <i>lpCompletionKey</i> parameter of GetQueuedCompletionStatus to
    ///identify the completion message as a telephony message.
    uint dwCompletionKey;
}

///The <b>PHONEMESSAGE</b> structure contains the next message queued for delivery to the application. The
///phoneGetMessage function returns this structure.
struct PHONEMESSAGE
{
align (1):
    ///Handle to a phone device.
    uint   hDevice;
    ///Phone message.
    uint   dwMessageID;
    ///Instance data passed back to the application, which was specified by the application in phoneInitializeEx. This
    ///value is not interpreted by TAPI.
    size_t dwCallbackInstance;
    ///Parameter for the message.
    size_t dwParam1;
    ///Parameter for the message.
    size_t dwParam2;
    ///Parameter for the message.
    size_t dwParam3;
}

///The <b>PHONESTATUS</b> structure describes the current status of a phone device. The phoneGetStatus and
///TSPI_phoneGetStatus functions return this structure.
struct PHONESTATUS
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size for this data structure that is needed to hold all the returned information, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Status flags for this phone device. This member uses one of the PHONESTATUSFLAGS_ Constants.
    uint dwStatusFlags;
    ///Number of application modules with owner privilege for the phone.
    uint dwNumOwners;
    ///Number of application modules with monitor privilege for the phone.
    uint dwNumMonitors;
    ///Current ring mode of a phone device.
    uint dwRingMode;
    ///Current ring volume of a phone device. This is a value between 0x00000000 (silence) and 0x0000FFFF (maximum
    ///volume).
    uint dwRingVolume;
    ///Current hookswitch mode of the phone's handset. This member uses one of the PHONEHOOKSWITCHMODE_ Constants.
    uint dwHandsetHookSwitchMode;
    ///Current speaker volume of the phone's handset device. This is a value between 0x00000000 (silence) and 0x0000FFFF
    ///(maximum volume).
    uint dwHandsetVolume;
    ///Current microphone gain of the phone's handset device. This is a value between 0x00000000 (silence) and
    ///0x0000FFFF (maximum gain).
    uint dwHandsetGain;
    ///Current hookswitch mode of the phone's speakerphone. This member uses one of the PHONEHOOKSWITCHMODE_ Constants.
    uint dwSpeakerHookSwitchMode;
    ///Current speaker volume of the phone's speaker device. This is a value between 0x00000000 (silence) and 0x0000FFFF
    ///(maximum volume).
    uint dwSpeakerVolume;
    ///Current microphone gain of the phone's speaker device. This is a value between 0x00000000 (silence) and
    ///0x0000FFFF (maximum gain).
    uint dwSpeakerGain;
    ///Current hookswitch mode of the phone's headset. This member uses one of the PHONEHOOKSWITCHMODE_ Constants.
    uint dwHeadsetHookSwitchMode;
    ///Current speaker volume of the phone's headset device. This is a value between 0x00000000 (silence) and 0x0000FFFF
    ///(maximum volume).
    uint dwHeadsetVolume;
    ///Current microphone gain of the phone's headset device. This is a value between 0x00000000 (silence) and
    ///0x0000FFFF (maximum gain).
    uint dwHeadsetGain;
    ///Size of the display information, in bytes.
    uint dwDisplaySize;
    ///Offset from the beginning of this structure to the variably sized field containing the phone's current display
    ///information. The size of the field is specified by <b>dwDisplaySize</b>.
    uint dwDisplayOffset;
    ///Size of the current lamp modes array, in bytes.
    uint dwLampModesSize;
    ///Offset from the beginning of this structure to the variably sized field containing the phone's current lamp
    ///modes. The size of the field is specified by <b>dwLampModesSize</b>.
    uint dwLampModesOffset;
    ///Size of the name of the current owner, including the <b>null</b> terminator, in bytes.
    uint dwOwnerNameSize;
    ///Offset from the beginning of the structure to the variably sized field containing the name of the application
    ///that is the current owner of the phone device. The name is the application name provided by the application when
    ///it invoked with phoneInitialize or phoneInitializeEx. If no application name was supplied, the application's
    ///filename is used instead. The size of the field is specified by <b>dwOwnerNameSize</b>. If the phone currently
    ///has no owner, <b>dwOwnerNameSize</b> is zero.
    uint dwOwnerNameOffset;
    ///Size of the device-specific field, in bytes. If the device-specific information is a pointer to a string, the
    ///size must include the <b>null</b> terminator.
    uint dwDevSpecificSize;
    ///Offset from the beginning of this structure to the variably sized device-specific field. The size of the field is
    ///specified by <b>dwDevSpecificSize</b>.
    uint dwDevSpecificOffset;
    ///Flags that indicate which Telephony API functions can be invoked on the phone, considering the availability of
    ///the feature in the device capabilities, the current device state, and device ownership of the invoking
    ///application. A zero indicates the corresponding feature cannot be invoked by the application on the phone in its
    ///current state; a one indicates the feature can be invoked. This member uses one or more of the PHONEFEATURE_
    ///Constants.
    uint dwPhoneFeatures;
}

///The <b>VARSTRING</b> structure is used for returning variably sized strings. It is used both by the line device class
///and the phone device class.
struct VARSTRING
{
align (1):
    ///Total size allocated to this data structure, in bytes.
    uint dwTotalSize;
    ///Size for this data structure that is needed to hold all the returned information, in bytes.
    uint dwNeededSize;
    ///Size of the portion of this data structure that contains useful information, in bytes.
    uint dwUsedSize;
    ///Format of the string. This member uses one of the STRINGFORMAT_ Constants.
    uint dwStringFormat;
    ///Size of the string information, including the <b>null</b> terminator, in bytes.
    uint dwStringSize;
    ///Offset from the beginning of the structure to the variably sized device field containing the string information.
    ///The size of the field is specified by <b>dwStringSize</b>.
    uint dwStringOffset;
}

///The <b>TAPI_CUSTOMTONE</b> structure contains the parameters that define a custom tone.
struct TAPI_CUSTOMTONE
{
    ///The frequency, in hertz, of the tone.
    uint dwFrequency;
    ///The "on" duration, in milliseconds, of the cadence of a custom tone.
    uint dwCadenceOn;
    ///The "off" duration, in milliseconds, of the cadence of a custom tone.
    uint dwCadenceOff;
    ///The volume level at which to generate the tone.
    uint dwVolume;
}

///The <b>TAPI_DETECTTONE</b> structure describes a tone to be monitored. This is used as an entry in an array.
struct TAPI_DETECTTONE
{
    ///Used by the application for tagging the tone. When this tone is detected, the value of the <b>dwAppSpecific</b>
    ///member is passed back to the application.
    uint dwAppSpecific;
    ///The duration, in milliseconds, during which the tone should be present before a detection is made.
    uint dwDuration;
    ///The frequency, in hertz, of a component of the tone.
    uint dwFrequency1;
    ///The frequency, in hertz, of a component of the tone.
    uint dwFrequency2;
    ///The frequency, in hertz, of a component of the tone. If fewer than three frequencies are needed in the tone, a
    ///value of zero should be used for the unused frequencies. A tone with all three frequencies set to zero is
    ///interpreted as silence and can be used for silence detection.
    uint dwFrequency3;
}

///The <b>MSP_EVENT_INFO</b> structure defines the type of event returned by the GetEvent method.
struct MSP_EVENT_INFO
{
    ///Total size of structure returned.
    uint      dwSize;
    MSP_EVENT Event;
    ///MSP handle; may be <b>NULL</b>.
    int*      hCall;
    union
    {
        struct MSP_ADDRESS_EVENT_INFO
        {
            MSP_ADDRESS_EVENT Type;
            ITTerminal        pTerminal;
        }
        struct MSP_CALL_EVENT_INFO
        {
            MSP_CALL_EVENT       Type;
            MSP_CALL_EVENT_CAUSE Cause;
            ITStream             pStream;
            ITTerminal           pTerminal;
            HRESULT              hrError;
        }
        struct MSP_TSP_DATA
        {
            uint     dwBufferSize;
            ubyte[1] pBuffer;
        }
        struct MSP_PRIVATE_EVENT_INFO
        {
            IDispatch pEvent;
            int       lEventCode;
        }
        struct MSP_FILE_TERMINAL_EVENT_INFO
        {
            ITTerminal           pParentFileTerminal;
            ITFileTrack          pFileTrack;
            TERMINAL_MEDIA_STATE TerminalMediaState;
            FT_STATE_EVENT_CAUSE ftecEventCause;
            HRESULT              hrErrorCode;
        }
        struct MSP_ASR_TERMINAL_EVENT_INFO
        {
            ITTerminal pASRTerminal;
            HRESULT    hrErrorCode;
        }
        struct MSP_TTS_TERMINAL_EVENT_INFO
        {
            ITTerminal pTTSTerminal;
            HRESULT    hrErrorCode;
        }
        struct MSP_TONE_TERMINAL_EVENT_INFO
        {
            ITTerminal pToneTerminal;
            HRESULT    hrErrorCode;
        }
    }
}

// Functions

///The <b>lineAccept</b> function accepts the specified offered call. It can optionally send the specified user-user
///information to the calling party.
///Params:
///    hCall = Handle to the call to be accepted. The application must be an owner of the call. Call state of <i>hCall</i> must
///            be <i>offering</i>.
///    lpsUserUserInfo = Pointer to a <b>null</b>-terminated string containing user-user information to be sent to the remote party as
///                      part of the call accept. This pointer can be left <b>NULL</b> if no user-user information is to be sent.
///                      User-user information is only sent if supported by the underlying network (see LINEDEVCAPS). The protocol
///                      discriminator member for the user-user information, if required, should appear as the first byte of the buffer
///                      pointed to by <i>lpsUserUserInfo</i>, and must be accounted for in <i>dwSize</i>.
///    dwSize = Size of the user-user information in <i>lpsUserUserInfo</i> (including the <b>null</b> terminator), in bytes. If
///             <i>lpsUserUserInfo</i> is <b>NULL</b>, no user-user information is sent to the calling party and <i>dwSize</i> is
///             ignored.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds, or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_INVALCALLSTATE, LINEERR_INVALPOINTER, LINEERR_NOMEM, LINEERR_NOTOWNER,
///    LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED,
///    LINEERR_USERUSERINFOTOOBIG.
///    
@DllImport("TAPI32")
int lineAccept(uint hCall, const(char)* lpsUserUserInfo, uint dwSize);

///The <b>lineAddProvider</b> function installs a new telephony service provider into the telephony system.
///Params:
///    lpszProviderFilename = Pointer to a <b></b> <b>null</b>-terminated string containing the path of the service provider to be added.
///    hwndOwner = Handle to a window in which any dialog boxes that need to be displayed as part of the installation process (for
///                example, by the service provider's TSPI_providerInstall function) would be attached. Can be <b>NULL</b> to
///                indicate that any window created during the function should have no owner window.
///    lpdwPermanentProviderID = Pointer to a variable that receives the permanent provider identifier of the newly installed service provider.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INIFILECORRUPT, LINEERR_INVALPARAM, LINEERR_INVALPOINTER, LINEERR_NOMEM, LINEERR_NOMULTIPLEINSTANCE,
///    LINEERR_OPERATIONFAILED.
///    
@DllImport("TAPI32")
int lineAddProvider(const(char)* lpszProviderFilename, HWND hwndOwner, uint* lpdwPermanentProviderID);

///The <b>lineAddProvider</b> function installs a new telephony service provider into the telephony system.
///Params:
///    lpszProviderFilename = Pointer to a <b></b> <b>null</b>-terminated string containing the path of the service provider to be added.
///    hwndOwner = Handle to a window in which any dialog boxes that need to be displayed as part of the installation process (for
///                example, by the service provider's TSPI_providerInstall function) would be attached. Can be <b>NULL</b> to
///                indicate that any window created during the function should have no owner window.
///    lpdwPermanentProviderID = Pointer to a variable that receives the permanent provider identifier of the newly installed service provider.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INIFILECORRUPT, LINEERR_INVALPARAM, LINEERR_INVALPOINTER, LINEERR_NOMEM, LINEERR_NOMULTIPLEINSTANCE,
///    LINEERR_OPERATIONFAILED.
///    
@DllImport("TAPI32")
int lineAddProviderA(const(char)* lpszProviderFilename, HWND hwndOwner, uint* lpdwPermanentProviderID);

///The <b>lineAddProvider</b> function installs a new telephony service provider into the telephony system.
///Params:
///    lpszProviderFilename = Pointer to a <b></b> <b>null</b>-terminated string containing the path of the service provider to be added.
///    hwndOwner = Handle to a window in which any dialog boxes that need to be displayed as part of the installation process (for
///                example, by the service provider's TSPI_providerInstall function) would be attached. Can be <b>NULL</b> to
///                indicate that any window created during the function should have no owner window.
///    lpdwPermanentProviderID = Pointer to a variable that receives the permanent provider identifier of the newly installed service provider.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INIFILECORRUPT, LINEERR_INVALPARAM, LINEERR_INVALPOINTER, LINEERR_NOMEM, LINEERR_NOMULTIPLEINSTANCE,
///    LINEERR_OPERATIONFAILED.
///    
@DllImport("TAPI32")
int lineAddProviderW(const(wchar)* lpszProviderFilename, HWND hwndOwner, uint* lpdwPermanentProviderID);

///The <b>lineAddToConference</b> function adds the call specified by <i>hConsultCall</i> to the conference call
///specified by <i>hConfCall</i>.
///Params:
///    hConfCall = Handle to the conference call. The application must be an owner of this call. Any monitoring (media, tones,
///                digits) on a conference call applies only to the <i>hConfCall</i>, not to the individual participating calls.
///                Call state of <i>hConfCall</i> must be <i>onHoldPendingConference</i> or <i>onHold</i>.
///    hConsultCall = Handle to the call to be added to the conference call. The application must be an owner of this call. This call
///                   cannot be a parent of another conference or a participant in any conference. Depending on the device capabilities
///                   indicated in LINEADDRESSCAPS, the <i>hConsultCall</i> may not necessarily have been established using
///                   lineSetupConference or linePrepareAddToConference. The call state of <i>hConsultCall</i> must be
///                   <i>connected</i>, <i>onHold</i>, <i>proceeding</i>, or <i>ringback</i>. Many PBXs allow calls to be added to
///                   conferences before they are actually answered.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds, or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_CONFERENCEFULL, LINEERR_NOTOWNER, LINEERR_INVALCONFCALLHANDLE, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALCALLSTATE, LINEERR_RESOURCEUNAVAIL, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineAddToConference(uint hConfCall, uint hConsultCall);

///The <b>lineAgentSpecific</b> function allows the application to access proprietary handler-specific functions of the
///agent handler associated with the address. The meaning of the extensions are specific to the agent handler. Each set
///of agent-related extensions is identified by a universally unique 128-bit extension ID that must be obtained, along
///with the specification for the extension, from the promulgator of that extension (usually the author of the agent
///handler software on the telephony server). The list of extensions supported by the agent handler is obtained from the
///LINEAGENTCAPS structure returned by lineGetAgentCaps.
///Params:
///    hLine = Handle to the open line device.
///    dwAddressID = Address on the open line device. An address identifier is permanently associated with an address; the identifier
///                  remains constant across operating system upgrades.
///    dwAgentExtensionIDIndex = Position in the <b>ExtensionIDList</b> structure in LINEAGENTCAPS of the agent handler extension being invoked.
///    lpParams = Pointer to a memory area used to hold a parameter block. The format of this parameter block is device specific
///               and its contents are passed by TAPI to and from the agent handler application on the telephony server. This
///               parameter block must specify the function to be invoked and include sufficient room for any data to be returned.
///    dwSize = Size of the parameter block area, in bytes. <div class="alert"><b>Note</b> If <i>lpParams</i> is a pointer to a
///             string, the size must include the <b>NULL</b> terminator. </div> <div> </div>
///Returns:
///    Returns a positive request identifier if the asynchronous operation starts; otherwise, this function returns one
///    of these negative error values: LINEERR_INVALADDRESSID, LINEERR_INVALAGENTID, LINEERR_INVALLINEHANDLE,
///    LINEERR_INVALPARAM, LINEERR_INVALPOINTER, LINEERR_NOMEM, LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_STRUCTURETOOSMALL, LINEERR_UNINITIALIZED. Additional return values are specific
///    to the agent handler.
///    
@DllImport("TAPI32")
int lineAgentSpecific(uint hLine, uint dwAddressID, uint dwAgentExtensionIDIndex, void* lpParams, uint dwSize);

///The <b>lineAnswer</b> function answers the specified offering call.
///Params:
///    hCall = Handle to the call to be answered. The application must be an owner of this call. The call state of <i>hCall</i>
///            must be <i>offering</i> or <i>accepted</i>.
///    lpsUserUserInfo = Pointer to a <b>null</b>-terminated string containing user-user information to be sent to the remote party at the
///                      time the call is answered. This pointer can be left <b>NULL</b> if no user-user information is to be sent.
///                      User-user information is only sent if supported by the underlying network (see LINEDEVCAPS). The protocol
///                      discriminator field for the user-user information, if required, should appear as the first byte of the buffer
///                      pointed to by <i>lpsUserUserInfo</i>, and must be accounted for in <i>dwSize</i>.
///    dwSize = Size of the user-user information in <i>lpsUserUserInfo</i> (including the <b>null</b> terminator), in bytes If
///             <i>lpsUserUserInfo</i> is <b>NULL</b>, no user-user information is sent to the calling party and <i>dwSize</i> is
///             ignored.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_INUSE,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALCALLSTATE,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NOMEM, LINEERR_USERUSERINFOTOOBIG,
///    LINEERR_NOTOWNER.
///    
@DllImport("TAPI32")
int lineAnswer(uint hCall, const(char)* lpsUserUserInfo, uint dwSize);

///The <b>lineBlindTransfer</b> function performs a blind or single-step transfer of the specified call to the specified
///destination address.
///Params:
///    hCall = Handle to the call to be transferred. The application must be an owner of this call. The call state of
///            <i>hCall</i> must be <i>connected</i>.
///    lpszDestAddress = TBD
///    dwCountryCode = Country or region code of the destination. This is used by the implementation to select the call progress
///                    protocols for the destination address. If a value of 0 is specified, a default call-progress protocol defined by
///                    the service provider is used.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_INVALCOUNTRYCODE, LINEERR_INVALCALLSTATE, LINEERR_INVALPOINTER, LINEERR_NOMEM,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_NOTOWNER, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALADDRESS, LINEERR_UNINITIALIZED,
///    LINEERR_ADDRESSBLOCKED, LINEERR_OPERATIONFAILED.
///    
@DllImport("TAPI32")
int lineBlindTransfer(uint hCall, const(char)* lpszDestAddress, uint dwCountryCode);

///The <b>lineBlindTransfer</b> function performs a blind or single-step transfer of the specified call to the specified
///destination address.
///Params:
///    hCall = Handle to the call to be transferred. The application must be an owner of this call. The call state of
///            <i>hCall</i> must be <i>connected</i>.
///    lpszDestAddress = TBD
///    dwCountryCode = Country or region code of the destination. This is used by the implementation to select the call progress
///                    protocols for the destination address. If a value of 0 is specified, a default call-progress protocol defined by
///                    the service provider is used.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_INVALCOUNTRYCODE, LINEERR_INVALCALLSTATE, LINEERR_INVALPOINTER, LINEERR_NOMEM,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_NOTOWNER, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALADDRESS, LINEERR_UNINITIALIZED,
///    LINEERR_ADDRESSBLOCKED, LINEERR_OPERATIONFAILED.
///    
@DllImport("TAPI32")
int lineBlindTransferA(uint hCall, const(char)* lpszDestAddress, uint dwCountryCode);

///The <b>lineBlindTransfer</b> function performs a blind or single-step transfer of the specified call to the specified
///destination address.
///Params:
///    hCall = Handle to the call to be transferred. The application must be an owner of this call. The call state of
///            <i>hCall</i> must be <i>connected</i>.
///    lpszDestAddressW = Pointer to a null-terminated string identifying where the call is to be transferred to. The destination address
///                       uses the standard dialable number format.
///    dwCountryCode = Country or region code of the destination. This is used by the implementation to select the call progress
///                    protocols for the destination address. If a value of 0 is specified, a default call-progress protocol defined by
///                    the service provider is used.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_INVALCOUNTRYCODE, LINEERR_INVALCALLSTATE, LINEERR_INVALPOINTER, LINEERR_NOMEM,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_NOTOWNER, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALADDRESS, LINEERR_UNINITIALIZED,
///    LINEERR_ADDRESSBLOCKED, LINEERR_OPERATIONFAILED.
///    
@DllImport("TAPI32")
int lineBlindTransferW(uint hCall, const(wchar)* lpszDestAddressW, uint dwCountryCode);

///The <b>lineClose</b> function closes the specified open line device.
///Params:
///    hLine = Handle to the open line device to be closed. After the line has been successfully closed, this handle is no
///            longer valid.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_NOMEM, LINEERR_UNINITIALIZED, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineClose(uint hLine);

///The <b>lineCompleteCall</b> function specifies how a call that could not be connected normally should be completed
///instead. The network or switch may not be able to complete a call because network resources are busy or the remote
///station is busy or doesn't answer. The application can request that the call be completed in one of a number of ways.
///Params:
///    hCall = Handle to the call whose completion is requested. The application must be an owner of the call. The call state of
///            <i>hCall</i> must be <i>busy</i> or <i>ringback</i>.
///    lpdwCompletionID = Pointer to a <b>DWORD</b>-sized memory location. The completion identifier is used to identify individual
///                       completion requests in progress. A completion identifier becomes invalid and can be reused after the request
///                       completes or after an outstanding request is canceled.
///    dwCompletionMode = Way in which the call is to be completed. This parameter uses one and only one of the LINECALLCOMPLMODE_
///                       Constants.
///    dwMessageID = Message that is to be sent when completing the call using LINECALLCOMPLMODE_MESSAGE. This identifier selects the
///                  message from a small number of predefined messages.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_COMPLETIONOVERRUN, LINEERR_NOMEM, LINEERR_INVALCALLCOMPLMODE, LINEERR_NOTOWNER, LINEERR_INVALCALLSTATE,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALMESSAGEID,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineCompleteCall(uint hCall, uint* lpdwCompletionID, uint dwCompletionMode, uint dwMessageID);

///The <b>lineCompleteTransfer</b> function completes the transfer of the specified call to the party connected in the
///consultation call.
///Params:
///    hCall = Handle to the call to be transferred. The application must be an owner of this call. The call state of
///            <i>hCall</i> must be <i>onHold</i> or <i>onHoldPendingTransfer</i>.
///    hConsultCall = Handle to the call that represents a connection with the destination of the transfer. The application must be an
///                   owner of this call. The call state of <i>hConsultCall</i> must be <i>connected</i>, <i>ringback</i>, <i>busy</i>,
///                   or <i>proceeding</i>.
///    lphConfCall = Pointer to a memory location where an <i>hCall</i> handle can be returned. If <i>dwTransferMode</i> is
///                  LINETRANSFERMODE_CONFERENCE, the newly created conference call is returned in <i>lphConfCall</i> and the
///                  application becomes the sole owner of the conference call. Otherwise, this parameter is ignored by TAPI.
///    dwTransferMode = How the initiated transfer request is to be resolved. This parameter uses one of the LINETRANSFERMODE_ Constants.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_NOTOWNER, LINEERR_INVALCALLSTATE, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALCONSULTCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALTRANSFERMODE, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineCompleteTransfer(uint hCall, uint hConsultCall, uint* lphConfCall, uint dwTransferMode);

///The <b>lineConfigDialog</b> function causes the provider of the specified line device to display a dialog box
///(attached to <i>hwndOwner</i> of the application) to allow the user to configure parameters related to the line
///device.
///Params:
///    dwDeviceID = Identifier of the line device to be configured.
///    hwndOwner = Handle to a window to which the dialog box is to be attached. Can be <b>NULL</b> to indicate that any window
///                created during the function should have no owner window.
///    lpszDeviceClass = Pointer to a <b>null</b>-terminated string that identifies a device class name. This device class allows the
///                      application to select a specific subscreen of configuration information applicable to that device class. This
///                      parameter is optional and can be left <b>NULL</b> or empty, in which case the highest level configuration is
///                      selected.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NOMEM, LINEERR_INUSE, LINEERR_OPERATIONFAILED, LINEERR_INVALDEVICECLASS,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPARAM, LINEERR_UNINITIALIZED, LINEERR_INVALPOINTER,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineConfigDialog(uint dwDeviceID, HWND hwndOwner, const(char)* lpszDeviceClass);

///The <b>lineConfigDialog</b> function causes the provider of the specified line device to display a dialog box
///(attached to <i>hwndOwner</i> of the application) to allow the user to configure parameters related to the line
///device.
///Params:
///    dwDeviceID = Identifier of the line device to be configured.
///    hwndOwner = Handle to a window to which the dialog box is to be attached. Can be <b>NULL</b> to indicate that any window
///                created during the function should have no owner window.
///    lpszDeviceClass = Pointer to a <b>null</b>-terminated string that identifies a device class name. This device class allows the
///                      application to select a specific subscreen of configuration information applicable to that device class. This
///                      parameter is optional and can be left <b>NULL</b> or empty, in which case the highest level configuration is
///                      selected.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NOMEM, LINEERR_INUSE, LINEERR_OPERATIONFAILED, LINEERR_INVALDEVICECLASS,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPARAM, LINEERR_UNINITIALIZED, LINEERR_INVALPOINTER,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineConfigDialogA(uint dwDeviceID, HWND hwndOwner, const(char)* lpszDeviceClass);

///The <b>lineConfigDialog</b> function causes the provider of the specified line device to display a dialog box
///(attached to <i>hwndOwner</i> of the application) to allow the user to configure parameters related to the line
///device.
///Params:
///    dwDeviceID = Identifier of the line device to be configured.
///    hwndOwner = Handle to a window to which the dialog box is to be attached. Can be <b>NULL</b> to indicate that any window
///                created during the function should have no owner window.
///    lpszDeviceClass = Pointer to a <b>null</b>-terminated string that identifies a device class name. This device class allows the
///                      application to select a specific subscreen of configuration information applicable to that device class. This
///                      parameter is optional and can be left <b>NULL</b> or empty, in which case the highest level configuration is
///                      selected.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NOMEM, LINEERR_INUSE, LINEERR_OPERATIONFAILED, LINEERR_INVALDEVICECLASS,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPARAM, LINEERR_UNINITIALIZED, LINEERR_INVALPOINTER,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineConfigDialogW(uint dwDeviceID, HWND hwndOwner, const(wchar)* lpszDeviceClass);

///The <b>lineConfigDialogEdit</b> function causes the provider of the specified line device to display a dialog box
///(attached to <i>hwndOwner</i> of the application) to allow the user to configure parameters related to the line
///device.
///Params:
///    dwDeviceID = Identifier of the line device to be configured.
///    hwndOwner = Handle to a window to which the dialog box is to be attached. Can be <b>NULL</b> to indicate that any window
///                created during the function should have no owner window.
///    lpszDeviceClass = Pointer to a <b>null</b>-terminated string that identifies a device class name. This device class allows the
///                      application to select a specific subscreen of configuration information applicable to that device class. This
///                      parameter is optional and can be left <b>NULL</b> or empty, in which case the highest level configuration is
///                      selected.
///    lpDeviceConfigIn = Pointer to the opaque configuration data structure that was returned by lineGetDevConfig (or a previous
///                       invocation of <b>lineConfigDialogEdit</b>) in the variable portion of the VARSTRING structure.
///    dwSize = Number of bytes in the structure pointed to by <i>lpDeviceConfigIn</i>. This value is returned in the
///             <b>dwStringSize</b> member in the VARSTRING structure returned by lineGetDevConfig or a previous invocation of
///             <b>lineConfigDialogEdit</b>.
///    lpDeviceConfigOut = Pointer to the memory location of type VARSTRING where the device configuration structure is returned. Upon
///                        successful completion of the request, this location is filled with the device configuration. The
///                        <b>dwStringFormat</b> member in the <b>VARSTRING</b> structure is set to STRINGFORMAT_BINARY. Prior to calling
///                        lineGetDevConfig (or a future invocation of <b>lineConfigDialogEdit</b>), the application should set the
///                        <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for returning
///                        information.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_OPERATIONFAILED, LINEERR_INVALDEVICECLASS, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_INVALPARAM, LINEERR_STRUCTURETOOSMALL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NODRIVER,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_NOMEM, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineConfigDialogEdit(uint dwDeviceID, HWND hwndOwner, const(char)* lpszDeviceClass, 
                         const(void)* lpDeviceConfigIn, uint dwSize, VARSTRING* lpDeviceConfigOut);

///The <b>lineConfigDialogEdit</b> function causes the provider of the specified line device to display a dialog box
///(attached to <i>hwndOwner</i> of the application) to allow the user to configure parameters related to the line
///device.
///Params:
///    dwDeviceID = Identifier of the line device to be configured.
///    hwndOwner = Handle to a window to which the dialog box is to be attached. Can be <b>NULL</b> to indicate that any window
///                created during the function should have no owner window.
///    lpszDeviceClass = Pointer to a <b>null</b>-terminated string that identifies a device class name. This device class allows the
///                      application to select a specific subscreen of configuration information applicable to that device class. This
///                      parameter is optional and can be left <b>NULL</b> or empty, in which case the highest level configuration is
///                      selected.
///    lpDeviceConfigIn = Pointer to the opaque configuration data structure that was returned by lineGetDevConfig (or a previous
///                       invocation of <b>lineConfigDialogEdit</b>) in the variable portion of the VARSTRING structure.
///    dwSize = Number of bytes in the structure pointed to by <i>lpDeviceConfigIn</i>. This value is returned in the
///             <b>dwStringSize</b> member in the VARSTRING structure returned by lineGetDevConfig or a previous invocation of
///             <b>lineConfigDialogEdit</b>.
///    lpDeviceConfigOut = Pointer to the memory location of type VARSTRING where the device configuration structure is returned. Upon
///                        successful completion of the request, this location is filled with the device configuration. The
///                        <b>dwStringFormat</b> member in the <b>VARSTRING</b> structure is set to STRINGFORMAT_BINARY. Prior to calling
///                        lineGetDevConfig (or a future invocation of <b>lineConfigDialogEdit</b>), the application should set the
///                        <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for returning
///                        information.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_OPERATIONFAILED, LINEERR_INVALDEVICECLASS, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_INVALPARAM, LINEERR_STRUCTURETOOSMALL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NODRIVER,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_NOMEM, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineConfigDialogEditA(uint dwDeviceID, HWND hwndOwner, const(char)* lpszDeviceClass, 
                          const(void)* lpDeviceConfigIn, uint dwSize, VARSTRING* lpDeviceConfigOut);

///The <b>lineConfigDialogEdit</b> function causes the provider of the specified line device to display a dialog box
///(attached to <i>hwndOwner</i> of the application) to allow the user to configure parameters related to the line
///device.
///Params:
///    dwDeviceID = Identifier of the line device to be configured.
///    hwndOwner = Handle to a window to which the dialog box is to be attached. Can be <b>NULL</b> to indicate that any window
///                created during the function should have no owner window.
///    lpszDeviceClass = Pointer to a <b>null</b>-terminated string that identifies a device class name. This device class allows the
///                      application to select a specific subscreen of configuration information applicable to that device class. This
///                      parameter is optional and can be left <b>NULL</b> or empty, in which case the highest level configuration is
///                      selected.
///    lpDeviceConfigIn = Pointer to the opaque configuration data structure that was returned by lineGetDevConfig (or a previous
///                       invocation of <b>lineConfigDialogEdit</b>) in the variable portion of the VARSTRING structure.
///    dwSize = Number of bytes in the structure pointed to by <i>lpDeviceConfigIn</i>. This value is returned in the
///             <b>dwStringSize</b> member in the VARSTRING structure returned by lineGetDevConfig or a previous invocation of
///             <b>lineConfigDialogEdit</b>.
///    lpDeviceConfigOut = Pointer to the memory location of type VARSTRING where the device configuration structure is returned. Upon
///                        successful completion of the request, this location is filled with the device configuration. The
///                        <b>dwStringFormat</b> member in the <b>VARSTRING</b> structure is set to STRINGFORMAT_BINARY. Prior to calling
///                        lineGetDevConfig (or a future invocation of <b>lineConfigDialogEdit</b>), the application should set the
///                        <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for returning
///                        information.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_OPERATIONFAILED, LINEERR_INVALDEVICECLASS, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_INVALPARAM, LINEERR_STRUCTURETOOSMALL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NODRIVER,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_NOMEM, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineConfigDialogEditW(uint dwDeviceID, HWND hwndOwner, const(wchar)* lpszDeviceClass, 
                          const(void)* lpDeviceConfigIn, uint dwSize, VARSTRING* lpDeviceConfigOut);

///The <b>lineConfigProvider</b> function causes a service provider to display its configuration dialog box.
///Params:
///    hwndOwner = Handle to a window to which the configuration dialog box (displayed by TSPI_providerConfig) is attached. Can be
///                <b>NULL</b> to indicate that any window created during the function should have no owner window.
///    dwPermanentProviderID = Permanent provider identifier of the service provider to be configured.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INIFILECORRUPT, LINEERR_NOMEM, LINEERR_INVALPARAM, LINEERR_OPERATIONFAILED.
///    
@DllImport("TAPI32")
int lineConfigProvider(HWND hwndOwner, uint dwPermanentProviderID);

///The <b>lineCreateAgent</b> function creates a new Agent object. It generates a LINE_PROXYREQUEST message to be sent
///to a registered proxy function handler, referencing a LINEPROXYREQUEST structure of type
///LINEPROXYREQUEST_CREATEAGENT.
///Params:
///    hLine = Handle to the line device.
///    lpszAgentID = Pointer to a <b>null</b>-terminated Unicode string containing the agent identifier. Used when working with legacy
///                  ACD systems. With an ACD system that uses the operating system's user login for authentication,
///                  <i>lpszAgentID</i> is set to <b>NULL</b>.
///    lpszAgentPIN = Pointer to a <b>null</b>-terminated Unicode string containing the agent PIN or password. Used when working with
///                   legacy ACD systems. With an ACD system that uses the operating system's user login for authentication,
///                   <i>lpszAgentPIN</i> is set to <b>NULL</b>.
///    lphAgent = Handle to the created agent, returned by the ACD proxy. It is the responsibility of the agent handler proxy
///               application to generate and maintain uniqueness of this identifier.
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineCreateAgentW(uint hLine, const(wchar)* lpszAgentID, const(wchar)* lpszAgentPIN, uint* lphAgent);

///The <b>lineCreateAgent</b> function creates a new Agent object. It generates a LINE_PROXYREQUEST message to be sent
///to a registered proxy function handler, referencing a LINEPROXYREQUEST structure of type
///LINEPROXYREQUEST_CREATEAGENT.
///Params:
///    hLine = Handle to the line device.
///    lpszAgentID = Pointer to a <b>null</b>-terminated Unicode string containing the agent identifier. Used when working with legacy
///                  ACD systems. With an ACD system that uses the operating system's user login for authentication,
///                  <i>lpszAgentID</i> is set to <b>NULL</b>.
///    lpszAgentPIN = Pointer to a <b>null</b>-terminated Unicode string containing the agent PIN or password. Used when working with
///                   legacy ACD systems. With an ACD system that uses the operating system's user login for authentication,
///                   <i>lpszAgentPIN</i> is set to <b>NULL</b>.
///    lphAgent = Handle to the created agent, returned by the ACD proxy. It is the responsibility of the agent handler proxy
///               application to generate and maintain uniqueness of this identifier.
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineCreateAgentA(uint hLine, const(char)* lpszAgentID, const(char)* lpszAgentPIN, uint* lphAgent);

///The <b>lineCreateAgentSession</b> function creates a new AgentSession object. It generates a LINE_PROXYREQUEST
///message to be sent to a registered proxy function handler, referencing a LINEPROXYREQUEST structure of type
///LINEPROXYREQUEST_CREATEAGENTSESSION.
///Params:
///    hLine = Handle to the line device.
///    hAgent = Identifier of the agent for whom the session is to be created.
///    lpszAgentPIN = Pointer to a <b>null</b>-terminated Unicode string containing the agent PIN or password. Used when working with
///                   legacy ACD systems that require a separate PIN for each session created (or group logged into). With an ACD
///                   system that uses the operating system's user login for authentication, <i>lpszAgentPIN</i> is set to <b>NULL</b>.
///    dwWorkingAddressID = Identifier of the address on which the agent will receive calls for this session.
///    lpGroupID = Pointer to a GUID that identifies the group for which the session is being created.
///    lphAgentSession = Handle to the created agent session, returned by the ACD proxy. It is the responsibility of the agent handler
///                      proxy application to generate and maintain uniqueness of these identifiers.
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineCreateAgentSessionW(uint hLine, uint hAgent, const(wchar)* lpszAgentPIN, uint dwWorkingAddressID, 
                            GUID* lpGroupID, uint* lphAgentSession);

///The <b>lineCreateAgentSession</b> function creates a new AgentSession object. It generates a LINE_PROXYREQUEST
///message to be sent to a registered proxy function handler, referencing a LINEPROXYREQUEST structure of type
///LINEPROXYREQUEST_CREATEAGENTSESSION.
///Params:
///    hLine = Handle to the line device.
///    hAgent = Identifier of the agent for whom the session is to be created.
///    lpszAgentPIN = Pointer to a <b>null</b>-terminated Unicode string containing the agent PIN or password. Used when working with
///                   legacy ACD systems that require a separate PIN for each session created (or group logged into). With an ACD
///                   system that uses the operating system's user login for authentication, <i>lpszAgentPIN</i> is set to <b>NULL</b>.
///    dwWorkingAddressID = Identifier of the address on which the agent will receive calls for this session.
///    lpGroupID = Pointer to a GUID that identifies the group for which the session is being created.
///    lphAgentSession = Handle to the created agent session, returned by the ACD proxy. It is the responsibility of the agent handler
///                      proxy application to generate and maintain uniqueness of these identifiers.
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineCreateAgentSessionA(uint hLine, uint hAgent, const(char)* lpszAgentPIN, uint dwWorkingAddressID, 
                            GUID* lpGroupID, uint* lphAgentSession);

///The <b>lineDeallocateCall</b> function deallocates the specified call handle.
///Params:
///    hCall = The call handle to be deallocated. An application with monitoring privileges for a call can always deallocate its
///            handle for that call. An application with owner privilege for a call can deallocate its handle unless it is the
///            sole owner of the call and the call is not in the <i>idle</i> state. The call handle is no longer valid after it
///            has been deallocated.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values
///    include: LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALCALLSTATE, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_NOMEM, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineDeallocateCall(uint hCall);

///The <b>lineDevSpecific</b> function enables service providers to provide access to features not offered by other TAPI
///functions. The meaning of the extensions are device specific, and taking advantage of these extensions requires the
///application to be fully aware of them.
///Params:
///    hLine = Handle to a line device. This parameter is required.
///    dwAddressID = Address identifier on the given line device. An address identifier is permanently associated with an address; the
///                  identifier remains constant across operating system upgrades.
///    hCall = Handle to a call. This parameter is optional, but if it is specified, the call it represents must belong to the
///            <i>hLine</i> line device. The call state of <i>hCall</i> is device specific.
///    lpParams = Pointer to a memory area used to hold a parameter block. The format of this parameter block is device specific
///               and its contents are passed by TAPI to or from the service provider.
///    dwSize = Size of the parameter block area, in bytes.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds, or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALADDRESSID, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    Additional return values are device specific.
///    
@DllImport("TAPI32")
int lineDevSpecific(uint hLine, uint dwAddressID, uint hCall, void* lpParams, uint dwSize);

///The <b>lineDevSpecificFeature</b> function enables service providers to provide access to features not offered by
///other TAPI functions. The meaning of these extensions are device specific, and taking advantage of these extensions
///requires the application to be fully aware of them.
///Params:
///    hLine = Handle to the line device.
///    dwFeature = Feature to invoke on the line device. This parameter uses the PHONEBUTTONFUNCTION_ Constants.
///    lpParams = Pointer to a memory area used to hold a feature-dependent parameter block. The format of this parameter block is
///               device specific and its contents are passed through by TAPI to or from the service provider.
///    dwSize = Size of the buffer, in bytes.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_INVALFEATURE,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_INVALLINEHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALPOINTER,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_NOMEM, LINEERR_UNINITIALIZED. Additional return values are device specific.
///    
@DllImport("TAPI32")
int lineDevSpecificFeature(uint hLine, uint dwFeature, void* lpParams, uint dwSize);

///The <b>lineDial</b> function dials the specified dialable number on the specified call.
///Params:
///    hCall = Handle to the call on which a number is to be dialed. The application must be an owner of the call. The call
///            state of <i>hCall</i> can be any state except <i>idle</i> and <i>disconnected</i>.
///    lpszDestAddress = Destination to be dialed using the standard dialable number format.
///    dwCountryCode = Country or region code of the destination. This is used by the implementation to select the call progress
///                    protocols for the destination address. If a value of 0 is specified, a service provider-defined default call
///                    progress protocol is used.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_ADDRESSBLOCKED,
///    LINEERR_INVALPOINTER, LINEERR_DIALBILLING, LINEERR_NOMEM, LINEERR_DIALDIALTONE, LINEERR_NOTOWNER,
///    LINEERR_DIALPROMPT, LINEERR_OPERATIONFAILED, LINEERR_DIALQUIET, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALCALLHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALCALLSTATE, LINEERR_UNINITIALIZED,
///    LINEERR_INVALCOUNTRYCODE.
///    
@DllImport("TAPI32")
int lineDial(uint hCall, const(char)* lpszDestAddress, uint dwCountryCode);

///The <b>lineDial</b> function dials the specified dialable number on the specified call.
///Params:
///    hCall = Handle to the call on which a number is to be dialed. The application must be an owner of the call. The call
///            state of <i>hCall</i> can be any state except <i>idle</i> and <i>disconnected</i>.
///    lpszDestAddress = Destination to be dialed using the standard dialable number format.
///    dwCountryCode = Country or region code of the destination. This is used by the implementation to select the call progress
///                    protocols for the destination address. If a value of 0 is specified, a service provider-defined default call
///                    progress protocol is used.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_ADDRESSBLOCKED,
///    LINEERR_INVALPOINTER, LINEERR_DIALBILLING, LINEERR_NOMEM, LINEERR_DIALDIALTONE, LINEERR_NOTOWNER,
///    LINEERR_DIALPROMPT, LINEERR_OPERATIONFAILED, LINEERR_DIALQUIET, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALCALLHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALCALLSTATE, LINEERR_UNINITIALIZED,
///    LINEERR_INVALCOUNTRYCODE.
///    
@DllImport("TAPI32")
int lineDialA(uint hCall, const(char)* lpszDestAddress, uint dwCountryCode);

///The <b>lineDial</b> function dials the specified dialable number on the specified call.
///Params:
///    hCall = Handle to the call on which a number is to be dialed. The application must be an owner of the call. The call
///            state of <i>hCall</i> can be any state except <i>idle</i> and <i>disconnected</i>.
///    lpszDestAddress = Destination to be dialed using the standard dialable number format.
///    dwCountryCode = Country or region code of the destination. This is used by the implementation to select the call progress
///                    protocols for the destination address. If a value of 0 is specified, a service provider-defined default call
///                    progress protocol is used.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_ADDRESSBLOCKED,
///    LINEERR_INVALPOINTER, LINEERR_DIALBILLING, LINEERR_NOMEM, LINEERR_DIALDIALTONE, LINEERR_NOTOWNER,
///    LINEERR_DIALPROMPT, LINEERR_OPERATIONFAILED, LINEERR_DIALQUIET, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALCALLHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALCALLSTATE, LINEERR_UNINITIALIZED,
///    LINEERR_INVALCOUNTRYCODE.
///    
@DllImport("TAPI32")
int lineDialW(uint hCall, const(wchar)* lpszDestAddress, uint dwCountryCode);

///The <b>lineDrop</b> function drops or disconnects the specified call. The application has the option to specify
///user-user information to be transmitted as part of the call disconnect.
///Params:
///    hCall = Handle to the call to be dropped. The application must be an owner of the call. The call state of <i>hCall</i>
///            can be any state except <i>idle</i>.
///    lpsUserUserInfo = Pointer to a string containing user-user information to be sent to the remote party as part of the call
///                      disconnect. This pointer can be left <b>NULL</b> if no user-user information is to be sent. User-user information
///                      is only sent if supported by the underlying network (see LINEDEVCAPS). The protocol discriminator field for the
///                      user-user information, if required, should appear as the first byte of the buffer pointed to by
///                      <i>lpsUserUserInfo</i>, and must be accounted for in <i>dwSize</i>.
///    dwSize = Size of the user-user information in <i>lpsUserUserInfo</i>, in bytes. If <i>lpsUserUserInfo</i> is <b>NULL</b>,
///             no user-user information is sent to the calling party and <i>dwSize</i> is ignored.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_NOMEM, LINEERR_OPERATIONFAILED, LINEERR_NOTOWNER,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_USERUSERINFOTOOBIG, LINEERR_INVALCALLSTATE,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineDrop(uint hCall, const(char)* lpsUserUserInfo, uint dwSize);

///The <b>lineForward</b> function forwards calls destined for the specified address on the specified line, according to
///the specified forwarding instructions. When an originating address (<i>dwAddressID</i>) is forwarded, the specified
///incoming calls for that address are deflected to the other number by the switch. This function provides a combination
///of forward and do-not-disturb features. This function can also cancel forwarding currently in effect.
///Params:
///    hLine = Handle to the line device.
///    bAllAddresses = Specifies whether all originating addresses on the line or just the one specified is to be forwarded. If
///                    <b>TRUE</b>, all addresses on the line are forwarded and <i>dwAddressID</i> is ignored; if <b>FALSE</b>, only the
///                    address specified as <i>dwAddressID</i> is forwarded.
///    dwAddressID = Address on the specified line whose incoming calls are to be forwarded. This parameter is ignored if
///                  <i>bAllAddresses</i> is <b>TRUE</b>. An address identifier is permanently associated with an address; the
///                  identifier remains constant across operating system upgrades.
///    lpForwardList = Pointer to a variably sized data structure that describes the specific forwarding instructions, of type
///                    LINEFORWARDLIST.
///    dwNumRingsNoAnswer = Number of rings before a call is considered a "no answer." If <i>dwNumRingsNoAnswer</i> is out of range, the
///                         actual value is set to the nearest value in the allowable range.
///    lphConsultCall = Pointer to an HCALL location. In some telephony environments, this location is loaded with a handle to a
///                     consultation call that is used to consult the party that is being forwarded to, and the application becomes the
///                     initial sole owner of this call. This pointer must be valid even in environments where call forwarding does not
///                     require a consultation call. This handle is set to <b>NULL</b> if no consultation call is created.
///    lpCallParams = Pointer to a structure of type LINECALLPARAMS. This pointer is ignored unless <b>lineForward</b> requires the
///                   establishment of a call to the forwarding destination (and <i>lphConsultCall</i> is returned, in which case
///                   <i>lpCallParams</i> is optional). If <b>NULL</b>, default call parameters are used. Otherwise, the specified call
///                   parameters are used for establishing <i>hConsultCall</i>.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_NOMEM, LINEERR_INVALADDRESSID, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALADDRESS,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALCOUNTRYCODE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_STRUCTURETOOSMALL, LINEERR_INVALPARAM, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineForward(uint hLine, uint bAllAddresses, uint dwAddressID, const(LINEFORWARDLIST)* lpForwardList, 
                uint dwNumRingsNoAnswer, uint* lphConsultCall, const(LINECALLPARAMS)* lpCallParams);

///The <b>lineForward</b> function forwards calls destined for the specified address on the specified line, according to
///the specified forwarding instructions. When an originating address (<i>dwAddressID</i>) is forwarded, the specified
///incoming calls for that address are deflected to the other number by the switch. This function provides a combination
///of forward and do-not-disturb features. This function can also cancel forwarding currently in effect.
///Params:
///    hLine = Handle to the line device.
///    bAllAddresses = Specifies whether all originating addresses on the line or just the one specified is to be forwarded. If
///                    <b>TRUE</b>, all addresses on the line are forwarded and <i>dwAddressID</i> is ignored; if <b>FALSE</b>, only the
///                    address specified as <i>dwAddressID</i> is forwarded.
///    dwAddressID = Address on the specified line whose incoming calls are to be forwarded. This parameter is ignored if
///                  <i>bAllAddresses</i> is <b>TRUE</b>. An address identifier is permanently associated with an address; the
///                  identifier remains constant across operating system upgrades.
///    lpForwardList = Pointer to a variably sized data structure that describes the specific forwarding instructions, of type
///                    LINEFORWARDLIST.
///    dwNumRingsNoAnswer = Number of rings before a call is considered a "no answer." If <i>dwNumRingsNoAnswer</i> is out of range, the
///                         actual value is set to the nearest value in the allowable range.
///    lphConsultCall = Pointer to an HCALL location. In some telephony environments, this location is loaded with a handle to a
///                     consultation call that is used to consult the party that is being forwarded to, and the application becomes the
///                     initial sole owner of this call. This pointer must be valid even in environments where call forwarding does not
///                     require a consultation call. This handle is set to <b>NULL</b> if no consultation call is created.
///    lpCallParams = Pointer to a structure of type LINECALLPARAMS. This pointer is ignored unless <b>lineForward</b> requires the
///                   establishment of a call to the forwarding destination (and <i>lphConsultCall</i> is returned, in which case
///                   <i>lpCallParams</i> is optional). If <b>NULL</b>, default call parameters are used. Otherwise, the specified call
///                   parameters are used for establishing <i>hConsultCall</i>.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_NOMEM, LINEERR_INVALADDRESSID, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALADDRESS,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALCOUNTRYCODE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_STRUCTURETOOSMALL, LINEERR_INVALPARAM, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineForwardA(uint hLine, uint bAllAddresses, uint dwAddressID, const(LINEFORWARDLIST)* lpForwardList, 
                 uint dwNumRingsNoAnswer, uint* lphConsultCall, const(LINECALLPARAMS)* lpCallParams);

///The <b>lineForward</b> function forwards calls destined for the specified address on the specified line, according to
///the specified forwarding instructions. When an originating address (<i>dwAddressID</i>) is forwarded, the specified
///incoming calls for that address are deflected to the other number by the switch. This function provides a combination
///of forward and do-not-disturb features. This function can also cancel forwarding currently in effect.
///Params:
///    hLine = Handle to the line device.
///    bAllAddresses = Specifies whether all originating addresses on the line or just the one specified is to be forwarded. If
///                    <b>TRUE</b>, all addresses on the line are forwarded and <i>dwAddressID</i> is ignored; if <b>FALSE</b>, only the
///                    address specified as <i>dwAddressID</i> is forwarded.
///    dwAddressID = Address on the specified line whose incoming calls are to be forwarded. This parameter is ignored if
///                  <i>bAllAddresses</i> is <b>TRUE</b>. An address identifier is permanently associated with an address; the
///                  identifier remains constant across operating system upgrades.
///    lpForwardList = Pointer to a variably sized data structure that describes the specific forwarding instructions, of type
///                    LINEFORWARDLIST.
///    dwNumRingsNoAnswer = Number of rings before a call is considered a "no answer." If <i>dwNumRingsNoAnswer</i> is out of range, the
///                         actual value is set to the nearest value in the allowable range.
///    lphConsultCall = Pointer to an HCALL location. In some telephony environments, this location is loaded with a handle to a
///                     consultation call that is used to consult the party that is being forwarded to, and the application becomes the
///                     initial sole owner of this call. This pointer must be valid even in environments where call forwarding does not
///                     require a consultation call. This handle is set to <b>NULL</b> if no consultation call is created.
///    lpCallParams = Pointer to a structure of type LINECALLPARAMS. This pointer is ignored unless <b>lineForward</b> requires the
///                   establishment of a call to the forwarding destination (and <i>lphConsultCall</i> is returned, in which case
///                   <i>lpCallParams</i> is optional). If <b>NULL</b>, default call parameters are used. Otherwise, the specified call
///                   parameters are used for establishing <i>hConsultCall</i>.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_NOMEM, LINEERR_INVALADDRESSID, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALADDRESS,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALCOUNTRYCODE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_STRUCTURETOOSMALL, LINEERR_INVALPARAM, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineForwardW(uint hLine, uint bAllAddresses, uint dwAddressID, const(LINEFORWARDLIST)* lpForwardList, 
                 uint dwNumRingsNoAnswer, uint* lphConsultCall, const(LINECALLPARAMS)* lpCallParams);

///The <b>lineGatherDigits</b> function initiates the buffered gathering of digits on the specified call. The
///application specifies a buffer in which to place the digits and the maximum number of digits to be collected.
///Params:
///    hCall = Handle to the call on which digits are to be gathered. The application must be an owner of the call. The call
///            state of <i>hCall</i> can be any state.
///    dwDigitModes = Digit modes to be monitored. This parameter uses one or more of the LINEDIGITMODE_ Constants.
///    lpsDigits = Pointer to the buffer where detected digits are to be stored as text characters. Digits may not show up in the
///                buffer one at a time as they are collected. Only after a LINE_GATHERDIGITS message is received should the content
///                of the buffer be assumed to be valid. If <i>lpsDigits</i> is <b>NULL</b>, the digit gathering currently in
///                progress on the call is terminated and <i>dwNumDigits</i> is ignored. Otherwise, <i>lpsDigits</i> is assumed to
///                have room for <i>dwNumDigits</i> digits.
///    dwNumDigits = Number of digits to be collected before a LINE_GATHERDIGITS message is sent to the application. The
///                  <i>dwNumDigits</i> parameter is ignored when <i>lpsDigits</i> is <b>NULL</b>. This function fails if
///                  <i>dwNumDigits</i> is zero.
///    lpszTerminationDigits = <b>Null</b>-terminated string of termination digits as text characters. If one of the digits in the string is
///                            detected, that termination digit is appended to the buffer, digit collection is terminated, and the
///                            LINE_GATHERDIGITS message is sent to the application. The list of valid characters is dependent on the constant
///                            provided in <i>dwDigitModes</i>. For a list of the valid characters for each possible mode, see LINEDIGITMODE_
///                            Constants. If this pointer is <b>NULL</b>, or if it points to an empty string, the function behaves as though no
///                            termination digits were supplied.
///    dwFirstDigitTimeout = Time duration in milliseconds in which the first digit is expected. If the first digit is not received in this
///                          timeframe, digit collection is aborted and a LINE_GATHERDIGITS message is sent to the application. The buffer
///                          only contains the <b>NULL</b> character, indicating that no digits were received and the first digit timeout
///                          terminated digit gathering. The call's line-device capabilities specify the valid range for this parameter or
///                          indicate that timeouts are not supported.
///    dwInterDigitTimeout = Maximum time duration in milliseconds between consecutive digits. If no digit is received in this timeframe,
///                          digit collection is aborted and a LINE_GATHERDIGITS message is sent to the application. The buffer only contains
///                          the digits collected up to this point followed by a <b>NULL</b> character, indicating that an interdigit timeout
///                          terminated digit gathering. The call's line-device capabilities specify the valid range for this parameter or
///                          indicate that timeouts are not supported.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_NOMEM, LINEERR_INVALCALLSTATE, LINEERR_NOTOWNER, LINEERR_INVALDIGITMODE,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_INVALDIGITS, LINEERR_OPERATIONFAILED, LINEERR_INVALPARAM,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGatherDigits(uint hCall, uint dwDigitModes, const(char)* lpsDigits, uint dwNumDigits, 
                     const(char)* lpszTerminationDigits, uint dwFirstDigitTimeout, uint dwInterDigitTimeout);

///The <b>lineGatherDigits</b> function initiates the buffered gathering of digits on the specified call. The
///application specifies a buffer in which to place the digits and the maximum number of digits to be collected.
///Params:
///    hCall = Handle to the call on which digits are to be gathered. The application must be an owner of the call. The call
///            state of <i>hCall</i> can be any state.
///    dwDigitModes = Digit modes to be monitored. This parameter uses one or more of the LINEDIGITMODE_ Constants.
///    lpsDigits = Pointer to the buffer where detected digits are to be stored as text characters. Digits may not show up in the
///                buffer one at a time as they are collected. Only after a LINE_GATHERDIGITS message is received should the content
///                of the buffer be assumed to be valid. If <i>lpsDigits</i> is <b>NULL</b>, the digit gathering currently in
///                progress on the call is terminated and <i>dwNumDigits</i> is ignored. Otherwise, <i>lpsDigits</i> is assumed to
///                have room for <i>dwNumDigits</i> digits.
///    dwNumDigits = Number of digits to be collected before a LINE_GATHERDIGITS message is sent to the application. The
///                  <i>dwNumDigits</i> parameter is ignored when <i>lpsDigits</i> is <b>NULL</b>. This function fails if
///                  <i>dwNumDigits</i> is zero.
///    lpszTerminationDigits = <b>Null</b>-terminated string of termination digits as text characters. If one of the digits in the string is
///                            detected, that termination digit is appended to the buffer, digit collection is terminated, and the
///                            LINE_GATHERDIGITS message is sent to the application. The list of valid characters is dependent on the constant
///                            provided in <i>dwDigitModes</i>. For a list of the valid characters for each possible mode, see LINEDIGITMODE_
///                            Constants. If this pointer is <b>NULL</b>, or if it points to an empty string, the function behaves as though no
///                            termination digits were supplied.
///    dwFirstDigitTimeout = Time duration in milliseconds in which the first digit is expected. If the first digit is not received in this
///                          timeframe, digit collection is aborted and a LINE_GATHERDIGITS message is sent to the application. The buffer
///                          only contains the <b>NULL</b> character, indicating that no digits were received and the first digit timeout
///                          terminated digit gathering. The call's line-device capabilities specify the valid range for this parameter or
///                          indicate that timeouts are not supported.
///    dwInterDigitTimeout = Maximum time duration in milliseconds between consecutive digits. If no digit is received in this timeframe,
///                          digit collection is aborted and a LINE_GATHERDIGITS message is sent to the application. The buffer only contains
///                          the digits collected up to this point followed by a <b>NULL</b> character, indicating that an interdigit timeout
///                          terminated digit gathering. The call's line-device capabilities specify the valid range for this parameter or
///                          indicate that timeouts are not supported.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_NOMEM, LINEERR_INVALCALLSTATE, LINEERR_NOTOWNER, LINEERR_INVALDIGITMODE,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_INVALDIGITS, LINEERR_OPERATIONFAILED, LINEERR_INVALPARAM,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGatherDigitsA(uint hCall, uint dwDigitModes, const(char)* lpsDigits, uint dwNumDigits, 
                      const(char)* lpszTerminationDigits, uint dwFirstDigitTimeout, uint dwInterDigitTimeout);

///The <b>lineGatherDigits</b> function initiates the buffered gathering of digits on the specified call. The
///application specifies a buffer in which to place the digits and the maximum number of digits to be collected.
///Params:
///    hCall = Handle to the call on which digits are to be gathered. The application must be an owner of the call. The call
///            state of <i>hCall</i> can be any state.
///    dwDigitModes = Digit modes to be monitored. This parameter uses one or more of the LINEDIGITMODE_ Constants.
///    lpsDigits = Pointer to the buffer where detected digits are to be stored as text characters. Digits may not show up in the
///                buffer one at a time as they are collected. Only after a LINE_GATHERDIGITS message is received should the content
///                of the buffer be assumed to be valid. If <i>lpsDigits</i> is <b>NULL</b>, the digit gathering currently in
///                progress on the call is terminated and <i>dwNumDigits</i> is ignored. Otherwise, <i>lpsDigits</i> is assumed to
///                have room for <i>dwNumDigits</i> digits.
///    dwNumDigits = Number of digits to be collected before a LINE_GATHERDIGITS message is sent to the application. The
///                  <i>dwNumDigits</i> parameter is ignored when <i>lpsDigits</i> is <b>NULL</b>. This function fails if
///                  <i>dwNumDigits</i> is zero.
///    lpszTerminationDigits = <b>Null</b>-terminated string of termination digits as text characters. If one of the digits in the string is
///                            detected, that termination digit is appended to the buffer, digit collection is terminated, and the
///                            LINE_GATHERDIGITS message is sent to the application. The list of valid characters is dependent on the constant
///                            provided in <i>dwDigitModes</i>. For a list of the valid characters for each possible mode, see LINEDIGITMODE_
///                            Constants. If this pointer is <b>NULL</b>, or if it points to an empty string, the function behaves as though no
///                            termination digits were supplied.
///    dwFirstDigitTimeout = Time duration in milliseconds in which the first digit is expected. If the first digit is not received in this
///                          timeframe, digit collection is aborted and a LINE_GATHERDIGITS message is sent to the application. The buffer
///                          only contains the <b>NULL</b> character, indicating that no digits were received and the first digit timeout
///                          terminated digit gathering. The call's line-device capabilities specify the valid range for this parameter or
///                          indicate that timeouts are not supported.
///    dwInterDigitTimeout = Maximum time duration in milliseconds between consecutive digits. If no digit is received in this timeframe,
///                          digit collection is aborted and a LINE_GATHERDIGITS message is sent to the application. The buffer only contains
///                          the digits collected up to this point followed by a <b>NULL</b> character, indicating that an interdigit timeout
///                          terminated digit gathering. The call's line-device capabilities specify the valid range for this parameter or
///                          indicate that timeouts are not supported.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_NOMEM, LINEERR_INVALCALLSTATE, LINEERR_NOTOWNER, LINEERR_INVALDIGITMODE,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_INVALDIGITS, LINEERR_OPERATIONFAILED, LINEERR_INVALPARAM,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGatherDigitsW(uint hCall, uint dwDigitModes, const(wchar)* lpsDigits, uint dwNumDigits, 
                      const(wchar)* lpszTerminationDigits, uint dwFirstDigitTimeout, uint dwInterDigitTimeout);

///The <b>lineGenerateDigits</b> function initiates the generation of the specified digits on the specified call as
///inband tones using the specified signaling mode. Calling this function with a <b>NULL</b> value for <i>lpszDigits</i>
///aborts any digit generation currently in progress. Invoking <b>lineGenerateDigits</b> or lineGenerateTone while digit
///generation is in progress aborts the current digit generation or tone generation and initiates the generation of the
///most recently specified digits or tone.
///Params:
///    hCall = Handle to the call. The application must be an owner of the call. Call state of <i>hCall</i> can be any state.
///            TAPI does not impose any callstate requirements, however some Tapi Service Providers may require that the hCall
///            be in the LINECALLSTATE_CONNECTED state.
///    dwDigitMode = Format to be used for signaling these digits. Be aware that <i>dwDigitMode</i> can only have a single flag set.
///                  This parameter uses one of the LINEDIGITMODE_ Constants.
///    lpszDigits = Pointer to a <b>null</b>-terminated character buffer that contains the digits to be generated. Valid characters
///                 are those specified for the LINEDIGITMODE_ Constants provided in <i>dwDigitModes</i>. In addition, the comma (,)
///                 is also a valid character. A comma injects an extra delay between the signaling of the previous and next digits
///                 it separates. The duration of this pause is configuration defined, and the line device capabilities indicate this
///                 duration. Multiple commas can be used to inject longer pauses. Invalid digits are ignored during the generation,
///                 rather than being reported as errors. The exclamation (!) is a valid character. This character causes a
///                 "hookflash" operation, as described for dialable addresses.
///    dwDuration = Both the duration in milliseconds of DTMF digits and pulse and DTMF inter-digit spacing. A value of 0 uses a
///                 default value. The <i>dwDuration</i> parameter must be within the range specified by <b>MinDialParams</b> and
///                 <b>MaxDialParams</b> in LINEDEVCAPS. If out of range, the actual value is set to the nearest value in the range.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_NOTOWNER, LINEERR_INVALCALLSTATE, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALDIGITMODE, LINEERR_OPERATIONFAILED, LINEERR_INVALPOINTER, LINEERR_RESOURCEUNAVAIL, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGenerateDigits(uint hCall, uint dwDigitMode, const(char)* lpszDigits, uint dwDuration);

///The <b>lineGenerateDigits</b> function initiates the generation of the specified digits on the specified call as
///inband tones using the specified signaling mode. Calling this function with a <b>NULL</b> value for <i>lpszDigits</i>
///aborts any digit generation currently in progress. Invoking <b>lineGenerateDigits</b> or lineGenerateTone while digit
///generation is in progress aborts the current digit generation or tone generation and initiates the generation of the
///most recently specified digits or tone.
///Params:
///    hCall = Handle to the call. The application must be an owner of the call. Call state of <i>hCall</i> can be any state.
///            TAPI does not impose any callstate requirements, however some Tapi Service Providers may require that the hCall
///            be in the LINECALLSTATE_CONNECTED state.
///    dwDigitMode = Format to be used for signaling these digits. Be aware that <i>dwDigitMode</i> can only have a single flag set.
///                  This parameter uses one of the LINEDIGITMODE_ Constants.
///    lpszDigits = Pointer to a <b>null</b>-terminated character buffer that contains the digits to be generated. Valid characters
///                 are those specified for the LINEDIGITMODE_ Constants provided in <i>dwDigitModes</i>. In addition, the comma (,)
///                 is also a valid character. A comma injects an extra delay between the signaling of the previous and next digits
///                 it separates. The duration of this pause is configuration defined, and the line device capabilities indicate this
///                 duration. Multiple commas can be used to inject longer pauses. Invalid digits are ignored during the generation,
///                 rather than being reported as errors. The exclamation (!) is a valid character. This character causes a
///                 "hookflash" operation, as described for dialable addresses.
///    dwDuration = Both the duration in milliseconds of DTMF digits and pulse and DTMF inter-digit spacing. A value of 0 uses a
///                 default value. The <i>dwDuration</i> parameter must be within the range specified by <b>MinDialParams</b> and
///                 <b>MaxDialParams</b> in LINEDEVCAPS. If out of range, the actual value is set to the nearest value in the range.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_NOTOWNER, LINEERR_INVALCALLSTATE, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALDIGITMODE, LINEERR_OPERATIONFAILED, LINEERR_INVALPOINTER, LINEERR_RESOURCEUNAVAIL, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGenerateDigitsA(uint hCall, uint dwDigitMode, const(char)* lpszDigits, uint dwDuration);

///The <b>lineGenerateDigits</b> function initiates the generation of the specified digits on the specified call as
///inband tones using the specified signaling mode. Calling this function with a <b>NULL</b> value for <i>lpszDigits</i>
///aborts any digit generation currently in progress. Invoking <b>lineGenerateDigits</b> or lineGenerateTone while digit
///generation is in progress aborts the current digit generation or tone generation and initiates the generation of the
///most recently specified digits or tone.
///Params:
///    hCall = Handle to the call. The application must be an owner of the call. Call state of <i>hCall</i> can be any state.
///            TAPI does not impose any callstate requirements, however some Tapi Service Providers may require that the hCall
///            be in the LINECALLSTATE_CONNECTED state.
///    dwDigitMode = Format to be used for signaling these digits. Be aware that <i>dwDigitMode</i> can only have a single flag set.
///                  This parameter uses one of the LINEDIGITMODE_ Constants.
///    lpszDigits = Pointer to a <b>null</b>-terminated character buffer that contains the digits to be generated. Valid characters
///                 are those specified for the LINEDIGITMODE_ Constants provided in <i>dwDigitModes</i>. In addition, the comma (,)
///                 is also a valid character. A comma injects an extra delay between the signaling of the previous and next digits
///                 it separates. The duration of this pause is configuration defined, and the line device capabilities indicate this
///                 duration. Multiple commas can be used to inject longer pauses. Invalid digits are ignored during the generation,
///                 rather than being reported as errors. The exclamation (!) is a valid character. This character causes a
///                 "hookflash" operation, as described for dialable addresses.
///    dwDuration = Both the duration in milliseconds of DTMF digits and pulse and DTMF inter-digit spacing. A value of 0 uses a
///                 default value. The <i>dwDuration</i> parameter must be within the range specified by <b>MinDialParams</b> and
///                 <b>MaxDialParams</b> in LINEDEVCAPS. If out of range, the actual value is set to the nearest value in the range.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_NOTOWNER, LINEERR_INVALCALLSTATE, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALDIGITMODE, LINEERR_OPERATIONFAILED, LINEERR_INVALPOINTER, LINEERR_RESOURCEUNAVAIL, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGenerateDigitsW(uint hCall, uint dwDigitMode, const(wchar)* lpszDigits, uint dwDuration);

///The <b>lineGenerateTone</b> function generates the specified inband tone over the specified call. Invoking this
///function with a zero for <i>dwToneMode</i> aborts the tone generation currently in progress on the specified call.
///Invoking <b>lineGenerateTone</b> or lineGenerateDigits while tone generation is in progress aborts the current tone
///generation or digit generation and initiates the generation of the newly specified tone or digits.
///Params:
///    hCall = Handle to the call on which a tone is to be generated. The application must be an owner of the call. The call
///            state of <i>hCall</i> can be any state.
///    dwToneMode = Defines the tone to be generated. Tones can be either standard or custom. A custom tone is composed of a set of
///                 arbitrary frequencies. A small number of standard tones are predefined. The duration of the tone is specified
///                 with <i>dwDuration</i> for both standard and custom tones. The <i>dwToneMode</i> parameter can only have one bit
///                 set. If no bits are set (the value 0 is passed), tone generation is canceled. This parameter uses one of the
///                 LINETONEMODE_ Constants.
///    dwDuration = Duration in milliseconds during which the tone should be sustained. A value of 0 for <i>dwDuration</i> uses a
///                 default duration for the specified tone. Default values are: CUSTOM: The tone is sustained until it is shut off,
///                 usually by user interaction or an equipment time-out. RINGBACK: The tone is sustained until it is shut off,
///                 usually by user interaction or an equipment time-out. BUSY: The tone is sustained until it is shut off, usually
///                 by user interaction or an equipment time-out. BEEP: The tone is sustained until it is shut off, usually by user
///                 interaction or an equipment time-out. BILLING: Fixed (single cycle).
///    dwNumTones = Number of entries in the <i>lpTones</i> array. This parameter is ignored if <i>dwToneMode</i> is not equal to
///                 CUSTOM.
///    lpTones = Pointer to a LINEGENERATETONE array that specifies the tone's components. This parameter is ignored for standard
///              LINETONEMODE_ Constants tones such as LINETONEMODE_BUSY. If <i>lpTones</i> is a multifrequency tone, the various
///              tones are played simultaneously.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_NOTOWNER, LINEERR_INVALCALLSTATE, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALPOINTER, LINEERR_OPERATIONFAILED, LINEERR_INVALTONEMODE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALTONE,
///    LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineGenerateTone(uint hCall, uint dwToneMode, uint dwDuration, uint dwNumTones, 
                     const(LINEGENERATETONE)* lpTones);

///The <b>lineGetAddressCaps</b> function queries the specified address on the specified line device to determine its
///telephony capabilities.
///Params:
///    hLineApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Line device containing the address to be queried.
///    dwAddressID = Address on the given line device whose capabilities are to be queried. An address identifier is permanently
///                  associated with an address; the identifier remains constant across operating system upgrades.
///    dwAPIVersion = Version number of the Telephony API to be used. The high-order word contains the major version number; the
///                   low-order word contains the minor version number. This number is obtained by lineNegotiateAPIVersion.
///    dwExtVersion = Version number of the service provider-specific extensions to be used. This number can be set to zero if no
///                   device-specific extensions are to be used. Otherwise, the high-order word contains the major version number; and
///                   the low-order word contains the minor version number.
///    lpAddressCaps = Pointer to a variably sized structure of type LINEADDRESSCAPS. Upon successful completion of the request, this
///                    structure is filled with address capabilities information. Prior to calling <b>lineGetAddressCaps</b>, the
///                    application should set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available
///                    to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in the structure are not
///                    correct, there is a possibility that data could get overwritten. For more information on setting structure sizes,
///                    see the memory allocation topic. </div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NOMEM, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_OPERATIONFAILED,
///    LINEERR_INCOMPATIBLEEXTVERSION, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALADDRESSID, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALAPPHANDLE, LINEERR_UNINITIALIZED, LINEERR_INVALPOINTER, LINEERR_OPERATIONUNAVAIL, LINEERR_NODRIVER,
///    LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineGetAddressCaps(uint hLineApp, uint dwDeviceID, uint dwAddressID, uint dwAPIVersion, uint dwExtVersion, 
                       LINEADDRESSCAPS* lpAddressCaps);

///The <b>lineGetAddressCaps</b> function queries the specified address on the specified line device to determine its
///telephony capabilities.
///Params:
///    hLineApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Line device containing the address to be queried.
///    dwAddressID = Address on the given line device whose capabilities are to be queried. An address identifier is permanently
///                  associated with an address; the identifier remains constant across operating system upgrades.
///    dwAPIVersion = Version number of the Telephony API to be used. The high-order word contains the major version number; the
///                   low-order word contains the minor version number. This number is obtained by lineNegotiateAPIVersion.
///    dwExtVersion = Version number of the service provider-specific extensions to be used. This number can be set to zero if no
///                   device-specific extensions are to be used. Otherwise, the high-order word contains the major version number; and
///                   the low-order word contains the minor version number.
///    lpAddressCaps = Pointer to a variably sized structure of type LINEADDRESSCAPS. Upon successful completion of the request, this
///                    structure is filled with address capabilities information. Prior to calling <b>lineGetAddressCaps</b>, the
///                    application should set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available
///                    to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in the structure are not
///                    correct, there is a possibility that data could get overwritten. For more information on setting structure sizes,
///                    see the memory allocation topic. </div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NOMEM, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_OPERATIONFAILED,
///    LINEERR_INCOMPATIBLEEXTVERSION, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALADDRESSID, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALAPPHANDLE, LINEERR_UNINITIALIZED, LINEERR_INVALPOINTER, LINEERR_OPERATIONUNAVAIL, LINEERR_NODRIVER,
///    LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineGetAddressCapsA(uint hLineApp, uint dwDeviceID, uint dwAddressID, uint dwAPIVersion, uint dwExtVersion, 
                        LINEADDRESSCAPS* lpAddressCaps);

///The <b>lineGetAddressCaps</b> function queries the specified address on the specified line device to determine its
///telephony capabilities.
///Params:
///    hLineApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Line device containing the address to be queried.
///    dwAddressID = Address on the given line device whose capabilities are to be queried. An address identifier is permanently
///                  associated with an address; the identifier remains constant across operating system upgrades.
///    dwAPIVersion = Version number of the Telephony API to be used. The high-order word contains the major version number; the
///                   low-order word contains the minor version number. This number is obtained by lineNegotiateAPIVersion.
///    dwExtVersion = Version number of the service provider-specific extensions to be used. This number can be set to zero if no
///                   device-specific extensions are to be used. Otherwise, the high-order word contains the major version number; and
///                   the low-order word contains the minor version number.
///    lpAddressCaps = Pointer to a variably sized structure of type LINEADDRESSCAPS. Upon successful completion of the request, this
///                    structure is filled with address capabilities information. Prior to calling <b>lineGetAddressCaps</b>, the
///                    application should set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available
///                    to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in the structure are not
///                    correct, there is a possibility that data could get overwritten. For more information on setting structure sizes,
///                    see the memory allocation topic. </div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NOMEM, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_OPERATIONFAILED,
///    LINEERR_INCOMPATIBLEEXTVERSION, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALADDRESSID, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALAPPHANDLE, LINEERR_UNINITIALIZED, LINEERR_INVALPOINTER, LINEERR_OPERATIONUNAVAIL, LINEERR_NODRIVER,
///    LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineGetAddressCapsW(uint hLineApp, uint dwDeviceID, uint dwAddressID, uint dwAPIVersion, uint dwExtVersion, 
                        LINEADDRESSCAPS* lpAddressCaps);

///The <b>lineGetAddressID</b> function returns the address identifier associated with an address in a different format
///on the specified line.
///Params:
///    hLine = Handle to the open line device.
///    lpdwAddressID = Pointer to a <b>DWORD</b>-sized memory location where the address identifier is returned. An address identifier
///                    is permanently associated with an address; the identifier remains constant across operating system upgrades.
///    dwAddressMode = Address mode of the address contained in <i>lpsAddress</i>. This parameter uses one and only one of the
///                    LINEADDRESSMODE_ Constants. You must specify LINEADDRESSMODE_DIALABLEADDR.
///    lpsAddress = Pointer to a data structure holding the address assigned to the specified line device. The format of the address
///                 is determined by <i>dwAddressMode</i>. Because the only valid value is LINEADDRESSMODE_DIALABLEADDR,
///                 <i>lpsAddress</i> uses the common dialable number format and is null-terminated.
///    dwSize = Size, in bytes, of the address contained in <i>lpsAddress</i>. The size of the string must include the null
///             terminator.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALADDRESSMODE, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALPOINTER, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALADDRESS, LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineGetAddressID(uint hLine, uint* lpdwAddressID, uint dwAddressMode, const(char)* lpsAddress, uint dwSize);

///The <b>lineGetAddressID</b> function returns the address identifier associated with an address in a different format
///on the specified line.
///Params:
///    hLine = Handle to the open line device.
///    lpdwAddressID = Pointer to a <b>DWORD</b>-sized memory location where the address identifier is returned. An address identifier
///                    is permanently associated with an address; the identifier remains constant across operating system upgrades.
///    dwAddressMode = Address mode of the address contained in <i>lpsAddress</i>. This parameter uses one and only one of the
///                    LINEADDRESSMODE_ Constants. You must specify LINEADDRESSMODE_DIALABLEADDR.
///    lpsAddress = Pointer to a data structure holding the address assigned to the specified line device. The format of the address
///                 is determined by <i>dwAddressMode</i>. Because the only valid value is LINEADDRESSMODE_DIALABLEADDR,
///                 <i>lpsAddress</i> uses the common dialable number format and is null-terminated.
///    dwSize = Size, in bytes, of the address contained in <i>lpsAddress</i>. The size of the string must include the null
///             terminator.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALADDRESSMODE, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALPOINTER, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALADDRESS, LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineGetAddressIDA(uint hLine, uint* lpdwAddressID, uint dwAddressMode, const(char)* lpsAddress, uint dwSize);

///The <b>lineGetAddressID</b> function returns the address identifier associated with an address in a different format
///on the specified line.
///Params:
///    hLine = Handle to the open line device.
///    lpdwAddressID = Pointer to a <b>DWORD</b>-sized memory location where the address identifier is returned. An address identifier
///                    is permanently associated with an address; the identifier remains constant across operating system upgrades.
///    dwAddressMode = Address mode of the address contained in <i>lpsAddress</i>. This parameter uses one and only one of the
///                    LINEADDRESSMODE_ Constants. You must specify LINEADDRESSMODE_DIALABLEADDR.
///    lpsAddress = Pointer to a data structure holding the address assigned to the specified line device. The format of the address
///                 is determined by <i>dwAddressMode</i>. Because the only valid value is LINEADDRESSMODE_DIALABLEADDR,
///                 <i>lpsAddress</i> uses the common dialable number format and is null-terminated.
///    dwSize = Size, in bytes, of the address contained in <i>lpsAddress</i>. The size of the string must include the null
///             terminator.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALADDRESSMODE, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALPOINTER, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALADDRESS, LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineGetAddressIDW(uint hLine, uint* lpdwAddressID, uint dwAddressMode, const(wchar)* lpsAddress, uint dwSize);

///The <b>lineGetAddressStatus</b> function allows an application to query the specified address for its current status.
///Params:
///    hLine = Handle to the open line device.
///    dwAddressID = Address on the given open line device. This is the address to be queried. An address identifier is permanently
///                  associated with an address; the identifier remains constant across operating system upgrades.
///    lpAddressStatus = Pointer to a variably sized data structure of type LINEADDRESSSTATUS. Prior to calling
///                      <b>lineGetAddressStatus</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate
///                      the amount of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size
///                      parameters in the structure are not correct, there is a possibility that data could get overwritten. For more
///                      information on setting structure sizes, see the memory allocation topic. </div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALADDRESSID, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALLINEHANDLE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NOMEM, LINEERR_OPERATIONUNAVAIL, LINEERR_OPERATIONFAILED.
///    
@DllImport("TAPI32")
int lineGetAddressStatus(uint hLine, uint dwAddressID, LINEADDRESSSTATUS* lpAddressStatus);

///The <b>lineGetAddressStatus</b> function allows an application to query the specified address for its current status.
///Params:
///    hLine = Handle to the open line device.
///    dwAddressID = Address on the given open line device. This is the address to be queried. An address identifier is permanently
///                  associated with an address; the identifier remains constant across operating system upgrades.
///    lpAddressStatus = Pointer to a variably sized data structure of type LINEADDRESSSTATUS. Prior to calling
///                      <b>lineGetAddressStatus</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate
///                      the amount of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size
///                      parameters in the structure are not correct, there is a possibility that data could get overwritten. For more
///                      information on setting structure sizes, see the memory allocation topic. </div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALADDRESSID, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALLINEHANDLE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NOMEM, LINEERR_OPERATIONUNAVAIL, LINEERR_OPERATIONFAILED.
///    
@DllImport("TAPI32")
int lineGetAddressStatusA(uint hLine, uint dwAddressID, LINEADDRESSSTATUS* lpAddressStatus);

///The <b>lineGetAddressStatus</b> function allows an application to query the specified address for its current status.
///Params:
///    hLine = Handle to the open line device.
///    dwAddressID = Address on the given open line device. This is the address to be queried. An address identifier is permanently
///                  associated with an address; the identifier remains constant across operating system upgrades.
///    lpAddressStatus = Pointer to a variably sized data structure of type LINEADDRESSSTATUS. Prior to calling
///                      <b>lineGetAddressStatus</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate
///                      the amount of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size
///                      parameters in the structure are not correct, there is a possibility that data could get overwritten. For more
///                      information on setting structure sizes, see the memory allocation topic. </div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALADDRESSID, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALLINEHANDLE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NOMEM, LINEERR_OPERATIONUNAVAIL, LINEERR_OPERATIONFAILED.
///    
@DllImport("TAPI32")
int lineGetAddressStatusW(uint hLine, uint dwAddressID, LINEADDRESSSTATUS* lpAddressStatus);

///The <b>lineGetAgentActivityList</b> function obtains the identities of activities that the application can select
///using lineSetAgentActivity to indicate what function the agent is actually performing at the moment.
///Params:
///    hLine = Handle to the open line device.
///    dwAddressID = Address on the open line device whose agent status is to be queried. An address identifier is permanently
///                  associated with an address; the identifier remains constant across operating system upgrades.
///    lpAgentActivityList = Pointer to a variably sized structure of type LINEAGENTACTIVITYLIST. Upon successful completion of the request,
///                          this structure is filled with a list of the agent activity codes that can be selected using lineSetAgentActivity.
///                          Prior to calling <b>lineGetAgentActivityList</b>, the application should set the <b>dwTotalSize</b> member of
///                          this structure to indicate the amount of memory available to TAPI for returning information.
///Returns:
///    Returns a positive request identifier if the asynchronous operation starts; otherwise, this function returns one
///    of these negative error values: LINEERR_INVALADDRESSID, LINEERR_OPERATIONFAILED, LINEERR_INVALAGENTID,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_STRUCTURETOOSMALL, LINEERR_NOMEM, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetAgentActivityListA(uint hLine, uint dwAddressID, LINEAGENTACTIVITYLIST* lpAgentActivityList);

///The <b>lineGetAgentActivityList</b> function obtains the identities of activities that the application can select
///using lineSetAgentActivity to indicate what function the agent is actually performing at the moment.
///Params:
///    hLine = Handle to the open line device.
///    dwAddressID = Address on the open line device whose agent status is to be queried. An address identifier is permanently
///                  associated with an address; the identifier remains constant across operating system upgrades.
///    lpAgentActivityList = Pointer to a variably sized structure of type LINEAGENTACTIVITYLIST. Upon successful completion of the request,
///                          this structure is filled with a list of the agent activity codes that can be selected using lineSetAgentActivity.
///                          Prior to calling <b>lineGetAgentActivityList</b>, the application should set the <b>dwTotalSize</b> member of
///                          this structure to indicate the amount of memory available to TAPI for returning information.
///Returns:
///    Returns a positive request identifier if the asynchronous operation starts; otherwise, this function returns one
///    of these negative error values: LINEERR_INVALADDRESSID, LINEERR_OPERATIONFAILED, LINEERR_INVALAGENTID,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_STRUCTURETOOSMALL, LINEERR_NOMEM, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetAgentActivityListW(uint hLine, uint dwAddressID, LINEAGENTACTIVITYLIST* lpAgentActivityList);

///The <b>lineGetAgentCaps</b> function obtains the agent-related capabilities supported on the specified line device.
///If a specific agent is named, the capabilities include a listing of ACD groups into which the agent is permitted to
///log in.
///Params:
///    hLineApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Line device containing the address to be queried.
///    dwAddressID = Address on the given line device whose capabilities are to be queried. An address identifier is permanently
///                  associated with an address; the identifier remains constant across operating system upgrades.
///    dwAppAPIVersion = Highest API version supported by the application. This should not be the value negotiated using
///                      lineNegotiateAPIVersion on the device being queried.
///    lpAgentCaps = Pointer to a variably sized structure of type LINEAGENTCAPS. Upon successful completion of the request, this
///                  structure is filled with agent capabilities information. Prior to calling <b>lineGetAgentCaps</b>, the
///                  application should set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available
///                  to TAPI for returning information.
///Returns:
///    Returns a positive request identifier if the asynchronous operation starts; otherwise, this function returns one
///    of these negative error values: LINEERR_BADDEVICEID, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_INVALADDRESSID,
///    LINEERR_INVALAPPHANDLE, LINEERR_INVALPOINTER, LINEERR_NODEVICE, LINEERR_NODRIVER, LINEERR_NOMEM,
///    LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetAgentCapsA(uint hLineApp, uint dwDeviceID, uint dwAddressID, uint dwAppAPIVersion, 
                      LINEAGENTCAPS* lpAgentCaps);

///The <b>lineGetAgentCaps</b> function obtains the agent-related capabilities supported on the specified line device.
///If a specific agent is named, the capabilities include a listing of ACD groups into which the agent is permitted to
///log in.
///Params:
///    hLineApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Line device containing the address to be queried.
///    dwAddressID = Address on the given line device whose capabilities are to be queried. An address identifier is permanently
///                  associated with an address; the identifier remains constant across operating system upgrades.
///    dwAppAPIVersion = Highest API version supported by the application. This should not be the value negotiated using
///                      lineNegotiateAPIVersion on the device being queried.
///    lpAgentCaps = Pointer to a variably sized structure of type LINEAGENTCAPS. Upon successful completion of the request, this
///                  structure is filled with agent capabilities information. Prior to calling <b>lineGetAgentCaps</b>, the
///                  application should set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available
///                  to TAPI for returning information.
///Returns:
///    Returns a positive request identifier if the asynchronous operation starts; otherwise, this function returns one
///    of these negative error values: LINEERR_BADDEVICEID, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_INVALADDRESSID,
///    LINEERR_INVALAPPHANDLE, LINEERR_INVALPOINTER, LINEERR_NODEVICE, LINEERR_NODRIVER, LINEERR_NOMEM,
///    LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetAgentCapsW(uint hLineApp, uint dwDeviceID, uint dwAddressID, uint dwAppAPIVersion, 
                      LINEAGENTCAPS* lpAgentCaps);

///The <b>lineGetAgentGroupList</b> function obtains the identities of agent groups (combination of queue, supervisor,
///skill level, and so on) into which the agent currently logged in on the workstation is permitted to log into on the
///automatic call distributor.
///Params:
///    hLine = Handle to the open line device.
///    dwAddressID = Address on the open line device whose agent status is to be queried.
///    lpAgentGroupList = Pointer to a variably sized structure of type LINEAGENTGROUPLIST. Upon successful completion of the request, this
///                       structure is filled with a list of the agent groups into which the agent can log in at this time (which should
///                       include any groups into which the agent is already logged in, if any).
///Returns:
///    Returns a positive request identifier if the asynchronous operation starts; otherwise, this function returns one
///    of these negative error values: LINEERR_INVALADDRESSID, LINEERR_INVALAGENTID, LINEERR_INVALLINEHANDLE,
///    LINEERR_INVALPOINTER, LINEERR_NOMEM, LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_STRUCTURETOOSMALL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetAgentGroupListA(uint hLine, uint dwAddressID, LINEAGENTGROUPLIST* lpAgentGroupList);

///The <b>lineGetAgentGroupList</b> function obtains the identities of agent groups (combination of queue, supervisor,
///skill level, and so on) into which the agent currently logged in on the workstation is permitted to log into on the
///automatic call distributor.
///Params:
///    hLine = Handle to the open line device.
///    dwAddressID = Address on the open line device whose agent status is to be queried.
///    lpAgentGroupList = Pointer to a variably sized structure of type LINEAGENTGROUPLIST. Upon successful completion of the request, this
///                       structure is filled with a list of the agent groups into which the agent can log in at this time (which should
///                       include any groups into which the agent is already logged in, if any).
///Returns:
///    Returns a positive request identifier if the asynchronous operation starts; otherwise, this function returns one
///    of these negative error values: LINEERR_INVALADDRESSID, LINEERR_INVALAGENTID, LINEERR_INVALLINEHANDLE,
///    LINEERR_INVALPOINTER, LINEERR_NOMEM, LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_STRUCTURETOOSMALL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetAgentGroupListW(uint hLine, uint dwAddressID, LINEAGENTGROUPLIST* lpAgentGroupList);

///The <b>lineGetAgentInfo</b> function returns a structure holding the ACD information associated with a particular
///agent handle. It generates a LINE_PROXYREQUEST message to be sent to a registered proxy function handler, referencing
///a LINEPROXYREQUEST structure of type LINEPROXYREQUEST_GETAGENTINFO.
///Params:
///    hLine = Handle to the line device.
///    hAgent = Identifier of the agent whose information is to be retrieved.
///    lpAgentInfo = Pointer to a structure of type LINEAGENTINFO. If the request succeeds, this structure is filled with the agent
///                  statistics.
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetAgentInfo(uint hLine, uint hAgent, LINEAGENTINFO* lpAgentInfo);

///The <b>lineGetAgentSessionInfo</b> function returns a structure that holds the ACD information associated with a
///particular agent session handle. It generates a LINE_PROXYREQUEST message to be sent to a registered proxy function
///handler, referencing a LINEPROXYREQUEST structure of type LINEPROXYREQUEST_GETAGENTSESSIONINFO.
///Params:
///    hLine = Handle to the line device.
///    hAgentSession = Identifier of the agent session whose information is to be retrieved.
///    lpAgentSessionInfo = Pointer to a structure of type LINEAGENTSESSIONINFO. Upon successful completion of the request, this structure is
///                         filled with the agent session statistics. Prior to calling the <b>lineGetAgentSessionInfo</b> function, the
///                         application must set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available
///                         to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in the structure are not
///                         correct, there is a possibility that memory could get overwritten. For more information on setting structure
///                         sizes, see the memory allocation topic.</div> <div> </div>
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetAgentSessionInfo(uint hLine, uint hAgentSession, LINEAGENTSESSIONINFO* lpAgentSessionInfo);

///The <b>lineGetAgentSessionList</b> function returns a list of agent sessions created for the specified agent. It
///generates a LINE_PROXYREQUEST message to be sent to a registered proxy function handler, referencing a
///LINEPROXYREQUEST structure of type LINEPROXYREQUEST_GETAGENTSESSIONLIST.
///Params:
///    hLine = Handle to the line device.
///    hAgent = Identifier of the agent whose information is to be retrieved.
///    lpAgentSessionList = Pointer to a variably sized structure of type LINEAGENTSESSIONLIST. Upon successful completion of the request,
///                         this structure is filled with a list of the agent sessions that have been created for this agent. Prior to
///                         calling the <b>lineGetAgentSessionList</b> function, the application must set the <b>dwTotalSize</b> member of
///                         this structure to indicate the amount of memory available to TAPI for returning information. <div
///                         class="alert"><b>Note</b> If the size parameters in the structure are not correct, there is a possibility that
///                         memory could get overwritten. For more information on setting structure sizes, see the memory allocation
///                         topic.</div> <div> </div>
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetAgentSessionList(uint hLine, uint hAgent, LINEAGENTSESSIONLIST* lpAgentSessionList);

///The <b>lineGetAgentStatus</b> function obtains the agent-related status on the specified address.
///Params:
///    hLine = Handle to the open line device.
///    dwAddressID = Address on the open line device whose agent status is to be queried. An address identifier is permanently
///                  associated with an address; the identifier remains constant across operating system upgrades.
///    lpAgentStatus = Pointer to a variably sized structure of type LINEAGENTSTATUS. Upon successful completion of the request, this
///                    structure is filled with agent status information. Prior to calling <b>lineGetAgentStatus</b>, the application
///                    must set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for
///                    returning information. <div class="alert"><b>Note</b> If the size parameters in the structure are not correct,
///                    there is a possibility that memory could get overwritten. For more information on setting structure sizes, see
///                    the memory allocation topic.</div> <div> </div>
///Returns:
///    Returns a positive request identifier if the asynchronous operation starts; otherwise, one of these negative
///    error values: LINEERR_INVALADDRESSID, LINEERR_INVALLINEHANDLE, LINEERR_INVALPOINTER, LINEERR_NOMEM,
///    LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetAgentStatusA(uint hLine, uint dwAddressID, LINEAGENTSTATUS* lpAgentStatus);

///The <b>lineGetAgentStatus</b> function obtains the agent-related status on the specified address.
///Params:
///    hLine = Handle to the open line device.
///    dwAddressID = Address on the open line device whose agent status is to be queried. An address identifier is permanently
///                  associated with an address; the identifier remains constant across operating system upgrades.
///    lpAgentStatus = Pointer to a variably sized structure of type LINEAGENTSTATUS. Upon successful completion of the request, this
///                    structure is filled with agent status information. Prior to calling <b>lineGetAgentStatus</b>, the application
///                    must set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for
///                    returning information. <div class="alert"><b>Note</b> If the size parameters in the structure are not correct,
///                    there is a possibility that memory could get overwritten. For more information on setting structure sizes, see
///                    the memory allocation topic.</div> <div> </div>
///Returns:
///    Returns a positive request identifier if the asynchronous operation starts; otherwise, one of these negative
///    error values: LINEERR_INVALADDRESSID, LINEERR_INVALLINEHANDLE, LINEERR_INVALPOINTER, LINEERR_NOMEM,
///    LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetAgentStatusW(uint hLine, uint dwAddressID, LINEAGENTSTATUS* lpAgentStatus);

///The <b>lineGetAppPriority</b> function enables an application to determine whether or not it is in the handoff
///priority list for a particular media mode or Assisted Telephony request mode and, if so, its position in the priority
///list.
///Params:
///    lpszAppFilename = A pointer to a string that contains the application executable module file name, without directory data. In API
///                      version 2.0 or later, the parameter can be in long file name format, of which the 8.3 file name format is a
///                      proper subset. Long file names, unlike 8.3 file names, are case preserving. Neither file name format is case
///                      sensitive. For more information, see File Name Conventions. In API versions earlier than 2.0, the parameter must
///                      specify a file name in the 8.3 format; long file names cannot be used.
///    dwMediaMode = A media mode for which the priority data is to be obtained. The value can be one of the LINEMEDIAMODE_ Constants;
///                  only a single bit can be on. The value 0 should be used if verifying application priority for Assisted Telephony
///                  requests.
///    lpExtensionID = A pointer to structure of type LINEEXTENSIONID. This parameter is ignored.
///    dwRequestMode = The conditions for this parameter are, if the <i>dwMediaMode</i> parameter is zero, this parameter specifies the
///                    Assisted Telephony request mode for which priority is to be checked. It must be LINEREQUESTMODE_MAKECALL. This
///                    parameter is ignored if <i>dwMediaMode</i> is non-zero.
///    lpExtensionName = This parameter is ignored.
///    lpdwPriority = A pointer to a <b>DWORD</b>-size memory location into which TAPI writes the priority of the application for the
///                   specified media or request mode. The value 0 is returned if the application is not in the stored priority list
///                   and does not currently have any line device open with ownership requested of the specified media mode or having
///                   registered for the specified request mode. In API versions earlier than 2.0, the value 1 (0xFFFFFFFF) is
///                   returned if the application has the line open for the specified media mode or has registered for the specified
///                   requests, but the application is not in the stored priority list; that is, it is in the temporary priority list
///                   only. In API version 2.0 or later, the value 0 is returned to indicate this condition. Otherwise, the value
///                   indicates the application position in the list; 1 being highest priority, and increasing values indicating
///                   decreasing priority.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    <b>LINEERR_INIFILECORRUPT</b>, <b>LINEERR_INVALREQUESTMODE</b>, <b>LINEERR_INVALAPPNAME</b>,
///    <b>LINEERR_NOMEM</b>, <b>LINEERR_INVALMEDIAMODE</b>, <b>LINEERR_OPERATIONFAILED</b>, <b>LINEERR_INVALPOINTER</b>,
///    <b>LINEERR_STRUCTURETOOSMALL</b>.
///    
@DllImport("TAPI32")
int lineGetAppPriority(const(char)* lpszAppFilename, uint dwMediaMode, LINEEXTENSIONID* lpExtensionID, 
                       uint dwRequestMode, VARSTRING* lpExtensionName, uint* lpdwPriority);

///The <b>lineGetAppPriority</b> function enables an application to determine whether or not it is in the handoff
///priority list for a particular media mode or Assisted Telephony request mode and, if so, its position in the priority
///list.
///Params:
///    lpszAppFilename = A pointer to a string that contains the application executable module file name, without directory data. In API
///                      version 2.0 or later, the parameter can be in long file name format, of which the 8.3 file name format is a
///                      proper subset. Long file names, unlike 8.3 file names, are case preserving. Neither file name format is case
///                      sensitive. For more information, see File Name Conventions. In API versions earlier than 2.0, the parameter must
///                      specify a file name in the 8.3 format; long file names cannot be used.
///    dwMediaMode = A media mode for which the priority data is to be obtained. The value can be one of the LINEMEDIAMODE_ Constants;
///                  only a single bit can be on. The value 0 should be used if verifying application priority for Assisted Telephony
///                  requests.
///    lpExtensionID = A pointer to structure of type LINEEXTENSIONID. This parameter is ignored.
///    dwRequestMode = The conditions for this parameter are, if the <i>dwMediaMode</i> parameter is zero, this parameter specifies the
///                    Assisted Telephony request mode for which priority is to be checked. It must be LINEREQUESTMODE_MAKECALL. This
///                    parameter is ignored if <i>dwMediaMode</i> is non-zero.
///    lpExtensionName = This parameter is ignored.
///    lpdwPriority = A pointer to a <b>DWORD</b>-size memory location into which TAPI writes the priority of the application for the
///                   specified media or request mode. The value 0 is returned if the application is not in the stored priority list
///                   and does not currently have any line device open with ownership requested of the specified media mode or having
///                   registered for the specified request mode. In API versions earlier than 2.0, the value 1 (0xFFFFFFFF) is
///                   returned if the application has the line open for the specified media mode or has registered for the specified
///                   requests, but the application is not in the stored priority list; that is, it is in the temporary priority list
///                   only. In API version 2.0 or later, the value 0 is returned to indicate this condition. Otherwise, the value
///                   indicates the application position in the list; 1 being highest priority, and increasing values indicating
///                   decreasing priority.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    <b>LINEERR_INIFILECORRUPT</b>, <b>LINEERR_INVALREQUESTMODE</b>, <b>LINEERR_INVALAPPNAME</b>,
///    <b>LINEERR_NOMEM</b>, <b>LINEERR_INVALMEDIAMODE</b>, <b>LINEERR_OPERATIONFAILED</b>, <b>LINEERR_INVALPOINTER</b>,
///    <b>LINEERR_STRUCTURETOOSMALL</b>.
///    
@DllImport("TAPI32")
int lineGetAppPriorityA(const(char)* lpszAppFilename, uint dwMediaMode, LINEEXTENSIONID* lpExtensionID, 
                        uint dwRequestMode, VARSTRING* lpExtensionName, uint* lpdwPriority);

///The <b>lineGetAppPriority</b> function enables an application to determine whether or not it is in the handoff
///priority list for a particular media mode or Assisted Telephony request mode and, if so, its position in the priority
///list.
///Params:
///    lpszAppFilename = A pointer to a string that contains the application executable module file name, without directory data. In API
///                      version 2.0 or later, the parameter can be in long file name format, of which the 8.3 file name format is a
///                      proper subset. Long file names, unlike 8.3 file names, are case preserving. Neither file name format is case
///                      sensitive. For more information, see File Name Conventions. In API versions earlier than 2.0, the parameter must
///                      specify a file name in the 8.3 format; long file names cannot be used.
///    dwMediaMode = A media mode for which the priority data is to be obtained. The value can be one of the LINEMEDIAMODE_ Constants;
///                  only a single bit can be on. The value 0 should be used if verifying application priority for Assisted Telephony
///                  requests.
///    lpExtensionID = A pointer to structure of type LINEEXTENSIONID. This parameter is ignored.
///    dwRequestMode = The conditions for this parameter are, if the <i>dwMediaMode</i> parameter is zero, this parameter specifies the
///                    Assisted Telephony request mode for which priority is to be checked. It must be LINEREQUESTMODE_MAKECALL. This
///                    parameter is ignored if <i>dwMediaMode</i> is non-zero.
///    lpExtensionName = This parameter is ignored.
///    lpdwPriority = A pointer to a <b>DWORD</b>-size memory location into which TAPI writes the priority of the application for the
///                   specified media or request mode. The value 0 is returned if the application is not in the stored priority list
///                   and does not currently have any line device open with ownership requested of the specified media mode or having
///                   registered for the specified request mode. In API versions earlier than 2.0, the value 1 (0xFFFFFFFF) is
///                   returned if the application has the line open for the specified media mode or has registered for the specified
///                   requests, but the application is not in the stored priority list; that is, it is in the temporary priority list
///                   only. In API version 2.0 or later, the value 0 is returned to indicate this condition. Otherwise, the value
///                   indicates the application position in the list; 1 being highest priority, and increasing values indicating
///                   decreasing priority.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    <b>LINEERR_INIFILECORRUPT</b>, <b>LINEERR_INVALREQUESTMODE</b>, <b>LINEERR_INVALAPPNAME</b>,
///    <b>LINEERR_NOMEM</b>, <b>LINEERR_INVALMEDIAMODE</b>, <b>LINEERR_OPERATIONFAILED</b>, <b>LINEERR_INVALPOINTER</b>,
///    <b>LINEERR_STRUCTURETOOSMALL</b>.
///    
@DllImport("TAPI32")
int lineGetAppPriorityW(const(wchar)* lpszAppFilename, uint dwMediaMode, LINEEXTENSIONID* lpExtensionID, 
                        uint dwRequestMode, VARSTRING* lpExtensionName, uint* lpdwPriority);

///The <b>lineGetCallInfo</b> function enables an application to obtain fixed information about the specified call.
///Params:
///    hCall = Handle to the call to be queried. The call state of <i>hCall</i> can be any state.
///    lpCallInfo = Pointer to a variably sized data structure of type LINECALLINFO. Upon successful completion of the request, this
///                 structure is filled with call-related information. Prior to calling <b>lineGetCallInfo</b>, the application
///                 should set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for
///                 returning information.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED, LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineGetCallInfo(uint hCall, LINECALLINFO* lpCallInfo);

///The <b>lineGetCallInfo</b> function enables an application to obtain fixed information about the specified call.
///Params:
///    hCall = Handle to the call to be queried. The call state of <i>hCall</i> can be any state.
///    lpCallInfo = Pointer to a variably sized data structure of type LINECALLINFO. Upon successful completion of the request, this
///                 structure is filled with call-related information. Prior to calling <b>lineGetCallInfo</b>, the application
///                 should set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for
///                 returning information.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED, LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineGetCallInfoA(uint hCall, LINECALLINFO* lpCallInfo);

///The <b>lineGetCallInfo</b> function enables an application to obtain fixed information about the specified call.
///Params:
///    hCall = Handle to the call to be queried. The call state of <i>hCall</i> can be any state.
///    lpCallInfo = Pointer to a variably sized data structure of type LINECALLINFO. Upon successful completion of the request, this
///                 structure is filled with call-related information. Prior to calling <b>lineGetCallInfo</b>, the application
///                 should set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for
///                 returning information.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED, LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineGetCallInfoW(uint hCall, LINECALLINFO* lpCallInfo);

///The <b>lineGetCallStatus</b> function returns the current status of the specified call.
///Params:
///    hCall = Handle to the call to be queried. The call state of <i>hCall</i> can be any state.
///    lpCallStatus = Pointer to a variably sized data structure of type LINECALLSTATUS. Upon successful completion of the request,
///                   this structure is filled with call status information. Prior to calling <b>lineGetCallStatus</b>, the application
///                   must set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for
///                   returning information. <div class="alert"><b>Note</b> If the size parameters in the structure are not correct,
///                   there is a possibility that data could get overwritten. For more information on setting structure sizes, see the
///                   memory allocation topic. </div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED, LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineGetCallStatus(uint hCall, LINECALLSTATUS* lpCallStatus);

///The <b>lineGetConfRelatedCalls</b> function returns a list of call handles that are part of the same conference call
///as the specified call. The specified call is either a conference call or a participant call in a conference call. New
///handles are generated for those calls for which the application does not already have handles, and the application is
///granted monitor privilege to those calls.
///Params:
///    hCall = Handle to a call. This is either a conference call or a participant call in a conference call. For a conference
///            parent call, the call state of <i>hCall</i> can be any state. For a conference participant call, it must be in
///            the <i>conferenced</i> state.
///    lpCallList = Pointer to a variably sized data structure of type LINECALLLIST. Upon successful completion of the request, call
///                 handles to all calls in the conference call are returned in this structure. The first call in the list is the
///                 conference call, the other calls are the participant calls. The application is granted monitor privilege to those
///                 calls for which it does not already have handles; the privileges to calls in the list for which the application
///                 already has handles is unchanged. Prior to calling <b>lineGetConfRelatedCalls</b>, the application must set the
///                 <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for returning
///                 information. <div class="alert"><b>Note</b> If the size parameters in the structure are not correct, there is a
///                 possibility that data could get overwritten. For more information on setting structure sizes, see the memory
///                 allocation topic. </div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_NOCONFERENCE, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL, LINEERR_NOMEM, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetConfRelatedCalls(uint hCall, LINECALLLIST* lpCallList);

///The <b>lineGetCountry</b> function fetches the stored dialing rules and other information related to a specified
///country/region, the first country/region in the country/region list, or all countries/regions.
///Params:
///    dwCountryID = Country/region identifier (not the country code) of the country/region for which information is to be obtained.
///                  If the value 1 is specified, information on the first country/region in the country/region list is obtained. If
///                  the value 0 is specified, information on all countries/regions is obtained (which can require a great deal of
///                  memory  20 KB or more).
///    dwAPIVersion = Highest version of TAPI supported by the application (not necessarily the value negotiated by
///                   lineNegotiateAPIVersion on some particular line device).
///    lpLineCountryList = Pointer to a location to which a LINECOUNTRYLIST structure is loaded. Prior to calling <b>lineGetCountry</b>, the
///                        application must set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available
///                        to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in the structure are not
///                        correct, there is a possibility that data could get overwritten. For more information on setting structure sizes,
///                        see the memory allocation topic.</div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NOMEM, LINEERR_INIFILECORRUPT, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALCOUNTRYCODE, LINEERR_STRUCTURETOOSMALL, LINEERR_INVALPOINTER.
///    
@DllImport("TAPI32")
int lineGetCountry(uint dwCountryID, uint dwAPIVersion, LINECOUNTRYLIST* lpLineCountryList);

///The <b>lineGetCountry</b> function fetches the stored dialing rules and other information related to a specified
///country/region, the first country/region in the country/region list, or all countries/regions.
///Params:
///    dwCountryID = Country/region identifier (not the country code) of the country/region for which information is to be obtained.
///                  If the value 1 is specified, information on the first country/region in the country/region list is obtained. If
///                  the value 0 is specified, information on all countries/regions is obtained (which can require a great deal of
///                  memory  20 KB or more).
///    dwAPIVersion = Highest version of TAPI supported by the application (not necessarily the value negotiated by
///                   lineNegotiateAPIVersion on some particular line device).
///    lpLineCountryList = Pointer to a location to which a LINECOUNTRYLIST structure is loaded. Prior to calling <b>lineGetCountry</b>, the
///                        application must set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available
///                        to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in the structure are not
///                        correct, there is a possibility that data could get overwritten. For more information on setting structure sizes,
///                        see the memory allocation topic.</div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NOMEM, LINEERR_INIFILECORRUPT, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALCOUNTRYCODE, LINEERR_STRUCTURETOOSMALL, LINEERR_INVALPOINTER.
///    
@DllImport("TAPI32")
int lineGetCountryA(uint dwCountryID, uint dwAPIVersion, LINECOUNTRYLIST* lpLineCountryList);

///The <b>lineGetCountry</b> function fetches the stored dialing rules and other information related to a specified
///country/region, the first country/region in the country/region list, or all countries/regions.
///Params:
///    dwCountryID = Country/region identifier (not the country code) of the country/region for which information is to be obtained.
///                  If the value 1 is specified, information on the first country/region in the country/region list is obtained. If
///                  the value 0 is specified, information on all countries/regions is obtained (which can require a great deal of
///                  memory  20 KB or more).
///    dwAPIVersion = Highest version of TAPI supported by the application (not necessarily the value negotiated by
///                   lineNegotiateAPIVersion on some particular line device).
///    lpLineCountryList = Pointer to a location to which a LINECOUNTRYLIST structure is loaded. Prior to calling <b>lineGetCountry</b>, the
///                        application must set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available
///                        to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in the structure are not
///                        correct, there is a possibility that data could get overwritten. For more information on setting structure sizes,
///                        see the memory allocation topic.</div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NOMEM, LINEERR_INIFILECORRUPT, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALCOUNTRYCODE, LINEERR_STRUCTURETOOSMALL, LINEERR_INVALPOINTER.
///    
@DllImport("TAPI32")
int lineGetCountryW(uint dwCountryID, uint dwAPIVersion, LINECOUNTRYLIST* lpLineCountryList);

///The <b>lineGetDevCaps</b> function queries a specified line device to determine its telephony capabilities. The
///returned information is valid for all addresses on the line device.
///Params:
///    hLineApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Identifier of the line device to be queried.
///    dwAPIVersion = Version number of the Telephony API to be used. The high-order word contains the major version number; the
///                   low-order word contains the minor version number. This number is obtained by lineNegotiateAPIVersion.
///    dwExtVersion = Version number of the service provider-specific extensions to be used. This number is obtained by
///                   lineNegotiateExtVersion. It can be left zero if no device-specific extensions are to be used. Otherwise, the
///                   high-order word contains the major version number; the low-order word contains the minor version number.
///    lpLineDevCaps = Pointer to a variably sized structure of type LINEDEVCAPS. Upon successful completion of the request, this
///                    structure is filled with line device capabilities information. Prior to calling <b>lineGetDevCaps</b>, the
///                    application must set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available
///                    to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in the structure are not
///                    correct, there is a possibility that data could get overwritten. For more information on setting structure sizes,
///                    see the memory allocation topic. </div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NOMEM, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_OPERATIONFAILED,
///    LINEERR_INCOMPATIBLEEXTVERSION, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALAPPHANDLE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NODRIVER, LINEERR_OPERATIONUNAVAIL, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineGetDevCaps(uint hLineApp, uint dwDeviceID, uint dwAPIVersion, uint dwExtVersion, 
                   LINEDEVCAPS* lpLineDevCaps);

///The <b>lineGetDevCaps</b> function queries a specified line device to determine its telephony capabilities. The
///returned information is valid for all addresses on the line device.
///Params:
///    hLineApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Identifier of the line device to be queried.
///    dwAPIVersion = Version number of the Telephony API to be used. The high-order word contains the major version number; the
///                   low-order word contains the minor version number. This number is obtained by lineNegotiateAPIVersion.
///    dwExtVersion = Version number of the service provider-specific extensions to be used. This number is obtained by
///                   lineNegotiateExtVersion. It can be left zero if no device-specific extensions are to be used. Otherwise, the
///                   high-order word contains the major version number; the low-order word contains the minor version number.
///    lpLineDevCaps = Pointer to a variably sized structure of type LINEDEVCAPS. Upon successful completion of the request, this
///                    structure is filled with line device capabilities information. Prior to calling <b>lineGetDevCaps</b>, the
///                    application must set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available
///                    to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in the structure are not
///                    correct, there is a possibility that data could get overwritten. For more information on setting structure sizes,
///                    see the memory allocation topic. </div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NOMEM, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_OPERATIONFAILED,
///    LINEERR_INCOMPATIBLEEXTVERSION, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALAPPHANDLE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NODRIVER, LINEERR_OPERATIONUNAVAIL, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineGetDevCapsA(uint hLineApp, uint dwDeviceID, uint dwAPIVersion, uint dwExtVersion, 
                    LINEDEVCAPS* lpLineDevCaps);

///The <b>lineGetDevCaps</b> function queries a specified line device to determine its telephony capabilities. The
///returned information is valid for all addresses on the line device.
///Params:
///    hLineApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Identifier of the line device to be queried.
///    dwAPIVersion = Version number of the Telephony API to be used. The high-order word contains the major version number; the
///                   low-order word contains the minor version number. This number is obtained by lineNegotiateAPIVersion.
///    dwExtVersion = Version number of the service provider-specific extensions to be used. This number is obtained by
///                   lineNegotiateExtVersion. It can be left zero if no device-specific extensions are to be used. Otherwise, the
///                   high-order word contains the major version number; the low-order word contains the minor version number.
///    lpLineDevCaps = Pointer to a variably sized structure of type LINEDEVCAPS. Upon successful completion of the request, this
///                    structure is filled with line device capabilities information. Prior to calling <b>lineGetDevCaps</b>, the
///                    application must set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available
///                    to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in the structure are not
///                    correct, there is a possibility that data could get overwritten. For more information on setting structure sizes,
///                    see the memory allocation topic. </div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NOMEM, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_OPERATIONFAILED,
///    LINEERR_INCOMPATIBLEEXTVERSION, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALAPPHANDLE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NODRIVER, LINEERR_OPERATIONUNAVAIL, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineGetDevCapsW(uint hLineApp, uint dwDeviceID, uint dwAPIVersion, uint dwExtVersion, 
                    LINEDEVCAPS* lpLineDevCaps);

///The <b>lineGetDevConfig</b> function returns an "opaque" data structure object, the contents of which are specific to
///the line (service provider) and device class. The data structure object stores the current configuration of a
///media-stream device associated with the line device.
///Params:
///    dwDeviceID = Identifier of the line device to be configured.
///    lpDeviceConfig = Pointer to the memory location of type VARSTRING where the device configuration structure is returned. Upon
///                     successful completion of the request, this location is filled with the device configuration. The
///                     <b>dwStringFormat</b> member in the <b>VARSTRING</b> structure is set to STRINGFORMAT_BINARY. Prior to calling
///                     <b>lineGetDevConfig</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate the
///                     amount of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size
///                     parameters in the structure are not correct, there is a possibility that data could get overwritten. For more
///                     information on setting structure sizes, see the memory allocation topic. </div> <div> </div>
///    lpszDeviceClass = Pointer to a null-terminated string that specifies the device class of the device whose configuration is
///                      requested. Valid device class lineGetID strings are the same as those specified for the function.
///Returns:
///    Returns zero if the function succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NODRIVER, LINEERR_INVALDEVICECLASS, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_STRUCTURETOOSMALL, LINEERR_OPERATIONFAILED, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineGetDevConfig(uint dwDeviceID, VARSTRING* lpDeviceConfig, const(char)* lpszDeviceClass);

///The <b>lineGetDevConfig</b> function returns an "opaque" data structure object, the contents of which are specific to
///the line (service provider) and device class. The data structure object stores the current configuration of a
///media-stream device associated with the line device.
///Params:
///    dwDeviceID = Identifier of the line device to be configured.
///    lpDeviceConfig = Pointer to the memory location of type VARSTRING where the device configuration structure is returned. Upon
///                     successful completion of the request, this location is filled with the device configuration. The
///                     <b>dwStringFormat</b> member in the <b>VARSTRING</b> structure is set to STRINGFORMAT_BINARY. Prior to calling
///                     <b>lineGetDevConfig</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate the
///                     amount of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size
///                     parameters in the structure are not correct, there is a possibility that data could get overwritten. For more
///                     information on setting structure sizes, see the memory allocation topic. </div> <div> </div>
///    lpszDeviceClass = Pointer to a null-terminated string that specifies the device class of the device whose configuration is
///                      requested. Valid device class lineGetID strings are the same as those specified for the function.
///Returns:
///    Returns zero if the function succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NODRIVER, LINEERR_INVALDEVICECLASS, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_STRUCTURETOOSMALL, LINEERR_OPERATIONFAILED, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineGetDevConfigA(uint dwDeviceID, VARSTRING* lpDeviceConfig, const(char)* lpszDeviceClass);

///The <b>lineGetDevConfig</b> function returns an "opaque" data structure object, the contents of which are specific to
///the line (service provider) and device class. The data structure object stores the current configuration of a
///media-stream device associated with the line device.
///Params:
///    dwDeviceID = Identifier of the line device to be configured.
///    lpDeviceConfig = Pointer to the memory location of type VARSTRING where the device configuration structure is returned. Upon
///                     successful completion of the request, this location is filled with the device configuration. The
///                     <b>dwStringFormat</b> member in the <b>VARSTRING</b> structure is set to STRINGFORMAT_BINARY. Prior to calling
///                     <b>lineGetDevConfig</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate the
///                     amount of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size
///                     parameters in the structure are not correct, there is a possibility that data could get overwritten. For more
///                     information on setting structure sizes, see the memory allocation topic. </div> <div> </div>
///    lpszDeviceClass = Pointer to a null-terminated string that specifies the device class of the device whose configuration is
///                      requested. Valid device class lineGetID strings are the same as those specified for the function.
///Returns:
///    Returns zero if the function succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NODRIVER, LINEERR_INVALDEVICECLASS, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_STRUCTURETOOSMALL, LINEERR_OPERATIONFAILED, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineGetDevConfigW(uint dwDeviceID, VARSTRING* lpDeviceConfig, const(wchar)* lpszDeviceClass);

///The <b>lineGetGroupList</b> function returns a list of ACD groups available on the ACD system. It generates a
///LINE_PROXYREQUEST message to be sent to a registered proxy function handler, referencing a LINEPROXYREQUEST structure
///of type <b>LINEPROXYREQUEST_GETGROUPLIST</b>.
///Params:
///    hLine = Handle to the line device.
///    lpGroupList = Pointer to a variably sized structure of type LINEAGENTGROUPLIST. Upon successful completion of the request, this
///                  structure is filled with a list of the available ACD groups. Prior to calling the <b>lineGetGroupList</b>
///                  function, the application must set the <b>dwTotalSize</b> member of this structure to indicate the amount of
///                  memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in the
///                  structure are not correct, there is a possibility that data could get overwritten. For more information on
///                  setting structure sizes, see the memory allocation topic.</div> <div> </div>
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetGroupListA(uint hLine, LINEAGENTGROUPLIST* lpGroupList);

///The <b>lineGetGroupList</b> function returns a list of ACD groups available on the ACD system. It generates a
///LINE_PROXYREQUEST message to be sent to a registered proxy function handler, referencing a LINEPROXYREQUEST structure
///of type <b>LINEPROXYREQUEST_GETGROUPLIST</b>.
///Params:
///    hLine = Handle to the line device.
///    lpGroupList = Pointer to a variably sized structure of type LINEAGENTGROUPLIST. Upon successful completion of the request, this
///                  structure is filled with a list of the available ACD groups. Prior to calling the <b>lineGetGroupList</b>
///                  function, the application must set the <b>dwTotalSize</b> member of this structure to indicate the amount of
///                  memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in the
///                  structure are not correct, there is a possibility that data could get overwritten. For more information on
///                  setting structure sizes, see the memory allocation topic.</div> <div> </div>
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetGroupListW(uint hLine, LINEAGENTGROUPLIST* lpGroupList);

///The <b>lineGetIcon</b> function allows an application to retrieve a service line device-specific (or
///provider-specific) icon for display to the user.
///Params:
///    dwDeviceID = Identifier of the line device whose icon is requested.
///    lpszDeviceClass = Pointer to a <b>null</b>-terminated string that identifies a device class name. This device class allows the
///                      application to select a specific sub-icon applicable to that device class. This parameter is optional and can be
///                      left <b>NULL</b> or empty, in which case the highest-level icon associated with the line device rather than a
///                      specified media stream device would be selected.
///    lphIcon = Pointer to a memory location in which the handle to the icon is returned.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_OPERATIONFAILED, LINEERR_INVALPOINTER, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_INVALDEVICECLASS, LINEERR_UNINITIALIZED, LINEERR_NOMEM, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineGetIcon(uint dwDeviceID, const(char)* lpszDeviceClass, ptrdiff_t* lphIcon);

///The <b>lineGetIcon</b> function allows an application to retrieve a service line device-specific (or
///provider-specific) icon for display to the user.
///Params:
///    dwDeviceID = Identifier of the line device whose icon is requested.
///    lpszDeviceClass = Pointer to a <b>null</b>-terminated string that identifies a device class name. This device class allows the
///                      application to select a specific sub-icon applicable to that device class. This parameter is optional and can be
///                      left <b>NULL</b> or empty, in which case the highest-level icon associated with the line device rather than a
///                      specified media stream device would be selected.
///    lphIcon = Pointer to a memory location in which the handle to the icon is returned.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_OPERATIONFAILED, LINEERR_INVALPOINTER, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_INVALDEVICECLASS, LINEERR_UNINITIALIZED, LINEERR_NOMEM, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineGetIconA(uint dwDeviceID, const(char)* lpszDeviceClass, ptrdiff_t* lphIcon);

///The <b>lineGetIcon</b> function allows an application to retrieve a service line device-specific (or
///provider-specific) icon for display to the user.
///Params:
///    dwDeviceID = Identifier of the line device whose icon is requested.
///    lpszDeviceClass = Pointer to a <b>null</b>-terminated string that identifies a device class name. This device class allows the
///                      application to select a specific sub-icon applicable to that device class. This parameter is optional and can be
///                      left <b>NULL</b> or empty, in which case the highest-level icon associated with the line device rather than a
///                      specified media stream device would be selected.
///    lphIcon = Pointer to a memory location in which the handle to the icon is returned.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_OPERATIONFAILED, LINEERR_INVALPOINTER, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_INVALDEVICECLASS, LINEERR_UNINITIALIZED, LINEERR_NOMEM, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineGetIconW(uint dwDeviceID, const(wchar)* lpszDeviceClass, ptrdiff_t* lphIcon);

///The <b>lineGetID</b> function returns a device identifier for the specified device class associated with the selected
///line, address, or call.
///Params:
///    hLine = Handle to an open line device.
///    dwAddressID = Address on the given open line device. An address identifier is permanently associated with an address; the
///                  identifier remains constant across operating system upgrades.
///    hCall = Handle to a call.
///    dwSelect = Specifies whether the requested device identifier is associated with the line, address or a single call. This
///               parameter uses one and only one of the LINECALLSELECT_ Constants.
///    lpDeviceID = Pointer to a memory location of type VARSTRING, where the device identifier is returned. Upon successful
///                 completion of the request, this location is filled with the device identifier. The format of the returned
///                 information depends on the method used by the device class API for naming devices. Prior to calling
///                 <b>lineGetID</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate the amount
///                 of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in
///                 the structure are not correct, there is a possibility that data could get overwritten. For more information on
///                 setting structure sizes, see the memory allocation topic. </div> <div> </div>
///    lpszDeviceClass = Pointer to a null-terminated string that specifies the device class of the device whose identifier is requested.
///                      Valid device class strings are those used in the SYSTEM.INI section to identify device classes.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_NOMEM, LINEERR_INVALADDRESSID, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALCALLSELECT, LINEERR_INVALDEVICECLASS,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL, LINEERR_NODEVICE,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetID(uint hLine, uint dwAddressID, uint hCall, uint dwSelect, VARSTRING* lpDeviceID, 
              const(char)* lpszDeviceClass);

///The <b>lineGetID</b> function returns a device identifier for the specified device class associated with the selected
///line, address, or call.
///Params:
///    hLine = Handle to an open line device.
///    dwAddressID = Address on the given open line device. An address identifier is permanently associated with an address; the
///                  identifier remains constant across operating system upgrades.
///    hCall = Handle to a call.
///    dwSelect = Specifies whether the requested device identifier is associated with the line, address or a single call. This
///               parameter uses one and only one of the LINECALLSELECT_ Constants.
///    lpDeviceID = Pointer to a memory location of type VARSTRING, where the device identifier is returned. Upon successful
///                 completion of the request, this location is filled with the device identifier. The format of the returned
///                 information depends on the method used by the device class API for naming devices. Prior to calling
///                 <b>lineGetID</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate the amount
///                 of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in
///                 the structure are not correct, there is a possibility that data could get overwritten. For more information on
///                 setting structure sizes, see the memory allocation topic. </div> <div> </div>
///    lpszDeviceClass = Pointer to a null-terminated string that specifies the device class of the device whose identifier is requested.
///                      Valid device class strings are those used in the SYSTEM.INI section to identify device classes.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_NOMEM, LINEERR_INVALADDRESSID, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALCALLSELECT, LINEERR_INVALDEVICECLASS,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL, LINEERR_NODEVICE,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetIDA(uint hLine, uint dwAddressID, uint hCall, uint dwSelect, VARSTRING* lpDeviceID, 
               const(char)* lpszDeviceClass);

///The <b>lineGetID</b> function returns a device identifier for the specified device class associated with the selected
///line, address, or call.
///Params:
///    hLine = Handle to an open line device.
///    dwAddressID = Address on the given open line device. An address identifier is permanently associated with an address; the
///                  identifier remains constant across operating system upgrades.
///    hCall = Handle to a call.
///    dwSelect = Specifies whether the requested device identifier is associated with the line, address or a single call. This
///               parameter uses one and only one of the LINECALLSELECT_ Constants.
///    lpDeviceID = Pointer to a memory location of type VARSTRING, where the device identifier is returned. Upon successful
///                 completion of the request, this location is filled with the device identifier. The format of the returned
///                 information depends on the method used by the device class API for naming devices. Prior to calling
///                 <b>lineGetID</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate the amount
///                 of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in
///                 the structure are not correct, there is a possibility that data could get overwritten. For more information on
///                 setting structure sizes, see the memory allocation topic. </div> <div> </div>
///    lpszDeviceClass = Pointer to a null-terminated string that specifies the device class of the device whose identifier is requested.
///                      Valid device class strings are those used in the SYSTEM.INI section to identify device classes.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_NOMEM, LINEERR_INVALADDRESSID, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALCALLSELECT, LINEERR_INVALDEVICECLASS,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL, LINEERR_NODEVICE,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetIDW(uint hLine, uint dwAddressID, uint hCall, uint dwSelect, VARSTRING* lpDeviceID, 
               const(wchar)* lpszDeviceClass);

///The <b>lineGetLineDevStatus</b> function enables an application to query the specified open line device for its
///current status.
///Params:
///    hLine = Handle to the open line device to be queried.
///    lpLineDevStatus = Pointer to a variably sized data structure of type LINEDEVSTATUS. Upon successful completion of the request, this
///                      structure is filled with the line's device status. Prior to calling <b>lineGetLineDevStatus</b>, the application
///                      should set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for
///                      returning information.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED, LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineGetLineDevStatus(uint hLine, LINEDEVSTATUS* lpLineDevStatus);

///The <b>lineGetLineDevStatus</b> function enables an application to query the specified open line device for its
///current status.
///Params:
///    hLine = Handle to the open line device to be queried.
///    lpLineDevStatus = Pointer to a variably sized data structure of type LINEDEVSTATUS. Upon successful completion of the request, this
///                      structure is filled with the line's device status. Prior to calling <b>lineGetLineDevStatus</b>, the application
///                      should set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for
///                      returning information.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED, LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineGetLineDevStatusA(uint hLine, LINEDEVSTATUS* lpLineDevStatus);

///The <b>lineGetLineDevStatus</b> function enables an application to query the specified open line device for its
///current status.
///Params:
///    hLine = Handle to the open line device to be queried.
///    lpLineDevStatus = Pointer to a variably sized data structure of type LINEDEVSTATUS. Upon successful completion of the request, this
///                      structure is filled with the line's device status. Prior to calling <b>lineGetLineDevStatus</b>, the application
///                      should set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for
///                      returning information.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED, LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineGetLineDevStatusW(uint hLine, LINEDEVSTATUS* lpLineDevStatus);

///The <b>lineGetMessage</b> function returns the next TAPI message that is queued for delivery to an application that
///is using the Event Handle notification mechanism (see lineInitializeEx for further details).
///Params:
///    hLineApp = Handle returned by lineInitializeEx. The application must have set the LINEINITIALIZEEXOPTION_USEEVENT option in
///               the <b>dwOptions</b> member of the LINEINITIALIZEEXPARAMS structure.
///    lpMessage = Pointer to a LINEMESSAGE structure. Upon successful return from this function, the structure contains the next
///                message that had been queued for delivery to the application.
///    dwTimeout = Time-out interval, in milliseconds. The function returns if the interval elapses, even if no message can be
///                returned. If <i>dwTimeout</i> is zero, the function checks for a queued message and returns immediately. If
///                <i>dwTimeout</i> is INFINITE, the function's time-out interval never elapses.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALAPPHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALPOINTER, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineGetMessage(uint hLineApp, LINEMESSAGE* lpMessage, uint dwTimeout);

///The <b>lineGetNewCalls</b> function returns call handles to calls on a specified line or address for which the
///application currently does not have handles. The application is granted monitor privilege to these calls.
///Params:
///    hLine = Handle to an open line device.
///    dwAddressID = Address on the given open line device. An address identifier is permanently associated with an address; the
///                  identifier remains constant across operating system upgrades.
///    dwSelect = Selection of calls that are requested. This parameter uses one and only one of the LINECALLSELECT_ Constants.
///    lpCallList = Pointer to a variably sized data structure of type LINECALLLIST. Upon successful completion of the request, call
///                 handles to all selected calls are returned in this structure. Prior to calling <b>lineGetNewCalls</b>, the
///                 application must set the <b>dwTotalSize</b> member of this structure to indicate the amount of memory available
///                 to TAPI for returning information. <div class="alert"><b>Note</b> If the size parameters in the structure are not
///                 correct, there is a possibility that data could get overwritten. For more information on setting structure sizes,
///                 see the memory allocation topic. </div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALADDRESSID, LINEERR_OPERATIONFAILED, LINEERR_INVALCALLSELECT, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_INVALLINEHANDLE, LINEERR_STRUCTURETOOSMALL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineGetNewCalls(uint hLine, uint dwAddressID, uint dwSelect, LINECALLLIST* lpCallList);

///The <b>lineGetNumRings</b> function determines the number of rings an incoming call on the given address should ring
///prior to answering the call.
///Params:
///    hLine = Handle to the open line device.
///    dwAddressID = Address on the line device. An address identifier is permanently associated with an address; the identifier
///                  remains constant across operating system upgrades.
///    lpdwNumRings = Number of rings that is the minimum of all current lineSetNumRings requests.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALADDRESSID, LINEERR_OPERATIONFAILED, LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineGetNumRings(uint hLine, uint dwAddressID, uint* lpdwNumRings);

///The <b>lineGetProviderList</b> function returns a list of service providers currently installed in the telephony
///system.
///Params:
///    dwAPIVersion = Highest version of TAPI supported by the application (not necessarily the value negotiated by
///                   lineNegotiateAPIVersion on some particular line device).
///    lpProviderList = Pointer to a memory location where TAPI can return a LINEPROVIDERLIST structure. Prior to calling
///                     <b>lineGetProviderList</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate
///                     the amount of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size
///                     parameters in the structure are not correct, there is a possibility that data could get overwritten. For more
///                     information on setting structure sizes, see the memory allocation topic. </div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NOMEM, LINEERR_INIFILECORRUPT, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL.
///    
@DllImport("TAPI32")
int lineGetProviderList(uint dwAPIVersion, LINEPROVIDERLIST* lpProviderList);

///The <b>lineGetProviderList</b> function returns a list of service providers currently installed in the telephony
///system.
///Params:
///    dwAPIVersion = Highest version of TAPI supported by the application (not necessarily the value negotiated by
///                   lineNegotiateAPIVersion on some particular line device).
///    lpProviderList = Pointer to a memory location where TAPI can return a LINEPROVIDERLIST structure. Prior to calling
///                     <b>lineGetProviderList</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate
///                     the amount of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size
///                     parameters in the structure are not correct, there is a possibility that data could get overwritten. For more
///                     information on setting structure sizes, see the memory allocation topic. </div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NOMEM, LINEERR_INIFILECORRUPT, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL.
///    
@DllImport("TAPI32")
int lineGetProviderListA(uint dwAPIVersion, LINEPROVIDERLIST* lpProviderList);

///The <b>lineGetProviderList</b> function returns a list of service providers currently installed in the telephony
///system.
///Params:
///    dwAPIVersion = Highest version of TAPI supported by the application (not necessarily the value negotiated by
///                   lineNegotiateAPIVersion on some particular line device).
///    lpProviderList = Pointer to a memory location where TAPI can return a LINEPROVIDERLIST structure. Prior to calling
///                     <b>lineGetProviderList</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate
///                     the amount of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size
///                     parameters in the structure are not correct, there is a possibility that data could get overwritten. For more
///                     information on setting structure sizes, see the memory allocation topic. </div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NOMEM, LINEERR_INIFILECORRUPT, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL.
///    
@DllImport("TAPI32")
int lineGetProviderListW(uint dwAPIVersion, LINEPROVIDERLIST* lpProviderList);

///The <b>lineGetProxyStatus</b> function returns a list of proxy request types that are currently being serviced for
///the specified device.
///Params:
///    hLineApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Line device to be queried.
///    dwAppAPIVersion = Version number of TAPI to be used.
///    lpLineProxyReqestList = Pointer to a variably sized structure of type LINEPROXYREQUESTLIST. Upon successful completion of the request,
///                            this structure is filled with a list of the currently supported proxy requests. Prior to calling
///                            <b>lineGetProxyStatus</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate
///                            the amount of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size
///                            parameters in the structure are not correct, there is a possibility that data could get overwritten. For more
///                            information on setting structure sizes, see the memory allocation topic.</div> <div> </div>
///Returns:
///    Returns zero if the request succeeds; otherwise, the function returns one of the following negative error values:
///    LINEERR_BADDEVICEID, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetProxyStatus(uint hLineApp, uint dwDeviceID, uint dwAppAPIVersion, 
                       LINEPROXYREQUESTLIST* lpLineProxyReqestList);

///The <b>lineGetQueueInfo</b> function returns a structure holding the ACD information associated with a particular
///queue. It generates a LINE_PROXYREQUEST message to be sent to a registered proxy function handler, referencing a
///LINEPROXYREQUEST structure of type LINEPROXYREQUEST_GETQUEUEINFO.
///Params:
///    hLine = Handle to the line device.
///    dwQueueID = Identifier of the queue whose information is to be retrieved.
///    lpLineQueueInfo = Pointer to a structure of type LINEQUEUEINFO. Upon successful completion of the request, this structure is filled
///                      with the queue statistics. Prior to calling <b>lineGetQueueInfo</b>, the application must set the
///                      <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for returning
///                      information. <div class="alert"><b>Note</b> If the size parameters in the structure are not correct, there is a
///                      possibility that data could get overwritten. For more information on setting structure sizes, see the memory
///                      allocation topic.</div> <div> </div>
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetQueueInfo(uint hLine, uint dwQueueID, LINEQUEUEINFO* lpLineQueueInfo);

///The <b>lineGetQueueList</b> function returns a list of queues associated with a particular ACD Group. It generates a
///LINE_PROXYREQUEST message to be sent to a registered proxy function handler, referencing a LINEPROXYREQUEST structure
///of type LINEPROXYREQUEST_GETQUEUELIST.
///Params:
///    hLine = Handle to the line device.
///    lpGroupID = Pointer to GUID that identifies the group for which the list of queues is requested.
///    lpQueueList = Pointer to a variably sized structure of type LINEQUEUELIST. Upon successful completion of the request, this
///                  structure is filled with a list of queues. Prior to calling <b>lineGetQueueList</b>, the application must set the
///                  <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for returning
///                  information. <div class="alert"><b>Note</b> If the size parameters in the structure are not correct, there is a
///                  possibility that data could get overwritten. For more information on setting structure sizes, see the memory
///                  allocation topic.</div> <div> </div>
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetQueueListA(uint hLine, GUID* lpGroupID, LINEQUEUELIST* lpQueueList);

///The <b>lineGetQueueList</b> function returns a list of queues associated with a particular ACD Group. It generates a
///LINE_PROXYREQUEST message to be sent to a registered proxy function handler, referencing a LINEPROXYREQUEST structure
///of type LINEPROXYREQUEST_GETQUEUELIST.
///Params:
///    hLine = Handle to the line device.
///    lpGroupID = Pointer to GUID that identifies the group for which the list of queues is requested.
///    lpQueueList = Pointer to a variably sized structure of type LINEQUEUELIST. Upon successful completion of the request, this
///                  structure is filled with a list of queues. Prior to calling <b>lineGetQueueList</b>, the application must set the
///                  <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for returning
///                  information. <div class="alert"><b>Note</b> If the size parameters in the structure are not correct, there is a
///                  possibility that data could get overwritten. For more information on setting structure sizes, see the memory
///                  allocation topic.</div> <div> </div>
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetQueueListW(uint hLine, GUID* lpGroupID, LINEQUEUELIST* lpQueueList);

///The <b>lineGetRequest</b> function retrieves the next by-proxy request for the specified request mode.
///Params:
///    hLineApp = The application usage handle for the line portion of TAPI.
///    dwRequestMode = A type of request to be obtained. Be aware that <i>dwRequestMode</i> can only have one bit set. This parameter
///                    uses one and only one of the LINEREQUESTMODE_ Constants.
///    lpRequestBuffer = A pointer to a memory buffer where the parameters of the request are to be placed. The size of the buffer and the
///                      interpretation of the data placed in the buffer depends on the request mode. The application-allocated buffer is
///                      assumed to be of sufficient size to hold the request. If <i>dwRequestMode</i> is LINEREQUESTMODE_MAKECALL,
///                      interpret the content of the request buffer using the LINEREQMAKECALL structure. LINEREQUESTMODE_MEDIACALL is
///                      obsolete. For more information, see tapiRequestMediaCall.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    <b>LINEERR_INVALAPPHANDLE</b>, <b>LINEERR_NOTREGISTERED</b>, <b>LINEERR_INVALPOINTER</b>,
///    <b>LINEERR_OPERATIONFAILED</b>, <b>LINEERR_INVALREQUESTMODE</b>, <b>LINEERR_RESOURCEUNAVAIL</b>,
///    <b>LINEERR_NOMEM</b>, <b>LINEERR_UNINITIALIZED</b>, <b>LINEERR_NOREQUEST</b>.
///    
@DllImport("TAPI32")
int lineGetRequest(uint hLineApp, uint dwRequestMode, void* lpRequestBuffer);

///The <b>lineGetRequest</b> function retrieves the next by-proxy request for the specified request mode.
///Params:
///    hLineApp = The application usage handle for the line portion of TAPI.
///    dwRequestMode = A type of request to be obtained. Be aware that <i>dwRequestMode</i> can only have one bit set. This parameter
///                    uses one and only one of the LINEREQUESTMODE_ Constants.
///    lpRequestBuffer = A pointer to a memory buffer where the parameters of the request are to be placed. The size of the buffer and the
///                      interpretation of the data placed in the buffer depends on the request mode. The application-allocated buffer is
///                      assumed to be of sufficient size to hold the request. If <i>dwRequestMode</i> is LINEREQUESTMODE_MAKECALL,
///                      interpret the content of the request buffer using the LINEREQMAKECALL structure. LINEREQUESTMODE_MEDIACALL is
///                      obsolete. For more information, see tapiRequestMediaCall.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    <b>LINEERR_INVALAPPHANDLE</b>, <b>LINEERR_NOTREGISTERED</b>, <b>LINEERR_INVALPOINTER</b>,
///    <b>LINEERR_OPERATIONFAILED</b>, <b>LINEERR_INVALREQUESTMODE</b>, <b>LINEERR_RESOURCEUNAVAIL</b>,
///    <b>LINEERR_NOMEM</b>, <b>LINEERR_UNINITIALIZED</b>, <b>LINEERR_NOREQUEST</b>.
///    
@DllImport("TAPI32")
int lineGetRequestA(uint hLineApp, uint dwRequestMode, void* lpRequestBuffer);

///The <b>lineGetRequest</b> function retrieves the next by-proxy request for the specified request mode.
///Params:
///    hLineApp = The application usage handle for the line portion of TAPI.
///    dwRequestMode = A type of request to be obtained. Be aware that <i>dwRequestMode</i> can only have one bit set. This parameter
///                    uses one and only one of the LINEREQUESTMODE_ Constants.
///    lpRequestBuffer = A pointer to a memory buffer where the parameters of the request are to be placed. The size of the buffer and the
///                      interpretation of the data placed in the buffer depends on the request mode. The application-allocated buffer is
///                      assumed to be of sufficient size to hold the request. If <i>dwRequestMode</i> is LINEREQUESTMODE_MAKECALL,
///                      interpret the content of the request buffer using the LINEREQMAKECALL structure. LINEREQUESTMODE_MEDIACALL is
///                      obsolete. For more information, see tapiRequestMediaCall.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    <b>LINEERR_INVALAPPHANDLE</b>, <b>LINEERR_NOTREGISTERED</b>, <b>LINEERR_INVALPOINTER</b>,
///    <b>LINEERR_OPERATIONFAILED</b>, <b>LINEERR_INVALREQUESTMODE</b>, <b>LINEERR_RESOURCEUNAVAIL</b>,
///    <b>LINEERR_NOMEM</b>, <b>LINEERR_UNINITIALIZED</b>, <b>LINEERR_NOREQUEST</b>.
///    
@DllImport("TAPI32")
int lineGetRequestW(uint hLineApp, uint dwRequestMode, void* lpRequestBuffer);

///The <b>lineGetStatusMessages</b> function enables an application to query which notification messages the application
///is set up to receive for events related to status changes for the specified line or any of its addresses.
///Params:
///    hLine = Handle to the line device.
///    lpdwLineStates = Bit array that identifies for which line device status changes a message is to be sent to the application. If a
///                     flag is <b>TRUE</b>, that message is enabled; if <b>FALSE</b>, it is disabled. This parameter uses one or more of
///                     the LINEDEVSTATE_ Constants.
///    lpdwAddressStates = Bit array that identifies for which address status changes a message is to be sent to the application. If a flag
///                        is <b>TRUE</b>, that message is enabled; if <b>FALSE</b>, disabled. This parameter uses one or more of the
///                        LINEADDRESSSTATE_ Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALPOINTER, LINEERR_RESOURCEUNAVAIL, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineGetStatusMessages(uint hLine, uint* lpdwLineStates, uint* lpdwAddressStates);

///The <b>lineGetTranslateCaps</b> function returns address translation capabilities.
///Params:
///    hLineApp = Handle returned by the lineInitializeEx function. If an application has not yet called the
///               <b>lineInitializeEx</b> function, this parameter can be zero. <div class="alert"><b>Note</b> TAPI 1.4
///               applications must set this parameter to a valid hLineApp handle, as returned by the lineInitialize function.
///               </div> <div> </div>
///    dwAPIVersion = Highest version of TAPI supported by the application (not necessarily the value negotiated by
///                   lineNegotiateAPIVersion on some particular line device).
///    lpTranslateCaps = Pointer to a location to which a LINETRANSLATECAPS structure is loaded. Prior to calling
///                      <b>lineGetTranslateCaps</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate
///                      the amount of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size
///                      parameters in the structure are not correct, there is a possibility that data could get overwritten. For more
///                      information on setting structure sizes, see the memory allocation topic.</div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NOMEM, LINEERR_INIFILECORRUPT, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALAPPHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_NODRIVER.
///    
@DllImport("TAPI32")
int lineGetTranslateCaps(uint hLineApp, uint dwAPIVersion, LINETRANSLATECAPS* lpTranslateCaps);

///The <b>lineGetTranslateCaps</b> function returns address translation capabilities.
///Params:
///    hLineApp = Handle returned by the lineInitializeEx function. If an application has not yet called the
///               <b>lineInitializeEx</b> function, this parameter can be zero. <div class="alert"><b>Note</b> TAPI 1.4
///               applications must set this parameter to a valid hLineApp handle, as returned by the lineInitialize function.
///               </div> <div> </div>
///    dwAPIVersion = Highest version of TAPI supported by the application (not necessarily the value negotiated by
///                   lineNegotiateAPIVersion on some particular line device).
///    lpTranslateCaps = Pointer to a location to which a LINETRANSLATECAPS structure is loaded. Prior to calling
///                      <b>lineGetTranslateCaps</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate
///                      the amount of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size
///                      parameters in the structure are not correct, there is a possibility that data could get overwritten. For more
///                      information on setting structure sizes, see the memory allocation topic.</div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NOMEM, LINEERR_INIFILECORRUPT, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALAPPHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_NODRIVER.
///    
@DllImport("TAPI32")
int lineGetTranslateCapsA(uint hLineApp, uint dwAPIVersion, LINETRANSLATECAPS* lpTranslateCaps);

///The <b>lineGetTranslateCaps</b> function returns address translation capabilities.
///Params:
///    hLineApp = Handle returned by the lineInitializeEx function. If an application has not yet called the
///               <b>lineInitializeEx</b> function, this parameter can be zero. <div class="alert"><b>Note</b> TAPI 1.4
///               applications must set this parameter to a valid hLineApp handle, as returned by the lineInitialize function.
///               </div> <div> </div>
///    dwAPIVersion = Highest version of TAPI supported by the application (not necessarily the value negotiated by
///                   lineNegotiateAPIVersion on some particular line device).
///    lpTranslateCaps = Pointer to a location to which a LINETRANSLATECAPS structure is loaded. Prior to calling
///                      <b>lineGetTranslateCaps</b>, the application must set the <b>dwTotalSize</b> member of this structure to indicate
///                      the amount of memory available to TAPI for returning information. <div class="alert"><b>Note</b> If the size
///                      parameters in the structure are not correct, there is a possibility that data could get overwritten. For more
///                      information on setting structure sizes, see the memory allocation topic.</div> <div> </div>
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NOMEM, LINEERR_INIFILECORRUPT, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALAPPHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_NODRIVER.
///    
@DllImport("TAPI32")
int lineGetTranslateCapsW(uint hLineApp, uint dwAPIVersion, LINETRANSLATECAPS* lpTranslateCaps);

///The <b>lineHandoff</b> function gives ownership of the specified call to another application. The application can be
///either specified directly by its file name or indirectly as the highest priority application that handles calls of
///the specified media mode.
///Params:
///    hCall = Handle to the call to be handed off. The application must be an owner of the call. The call state of <i>hCall</i>
///            can be any state.
///    lpszFileName = Pointer to a <b>null</b>-terminated string. If this pointer parameter is non-<b>NULL</b>, it contains the file
///                   name of the application that is the target of the handoff. If <b>NULL</b>, the handoff target is the highest
///                   priority application that has opened the line for owner privilege for the specified media mode. A valid file name
///                   does not include the path of the file.
///    dwMediaMode = Media mode used to identify the target for the indirect handoff. The <i>dwMediaMode</i> parameter indirectly
///                  identifies the target application that is to receive ownership of the call. This parameter is ignored if
///                  <i>lpszFileName</i> is not <b>NULL</b>. This parameter uses one and only one of the LINEMEDIAMODE_ Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALMEDIAMODE, LINEERR_TARGETNOTFOUND,
///    LINEERR_INVALPOINTER, LINEERR_TARGETSELF, LINEERR_NOMEM, LINEERR_UNINITIALIZED, LINEERR_NOTOWNER.
///    
@DllImport("TAPI32")
int lineHandoff(uint hCall, const(char)* lpszFileName, uint dwMediaMode);

///The <b>lineHandoff</b> function gives ownership of the specified call to another application. The application can be
///either specified directly by its file name or indirectly as the highest priority application that handles calls of
///the specified media mode.
///Params:
///    hCall = Handle to the call to be handed off. The application must be an owner of the call. The call state of <i>hCall</i>
///            can be any state.
///    lpszFileName = Pointer to a <b>null</b>-terminated string. If this pointer parameter is non-<b>NULL</b>, it contains the file
///                   name of the application that is the target of the handoff. If <b>NULL</b>, the handoff target is the highest
///                   priority application that has opened the line for owner privilege for the specified media mode. A valid file name
///                   does not include the path of the file.
///    dwMediaMode = Media mode used to identify the target for the indirect handoff. The <i>dwMediaMode</i> parameter indirectly
///                  identifies the target application that is to receive ownership of the call. This parameter is ignored if
///                  <i>lpszFileName</i> is not <b>NULL</b>. This parameter uses one and only one of the LINEMEDIAMODE_ Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALMEDIAMODE, LINEERR_TARGETNOTFOUND,
///    LINEERR_INVALPOINTER, LINEERR_TARGETSELF, LINEERR_NOMEM, LINEERR_UNINITIALIZED, LINEERR_NOTOWNER.
///    
@DllImport("TAPI32")
int lineHandoffA(uint hCall, const(char)* lpszFileName, uint dwMediaMode);

///The <b>lineHandoff</b> function gives ownership of the specified call to another application. The application can be
///either specified directly by its file name or indirectly as the highest priority application that handles calls of
///the specified media mode.
///Params:
///    hCall = Handle to the call to be handed off. The application must be an owner of the call. The call state of <i>hCall</i>
///            can be any state.
///    lpszFileName = Pointer to a <b>null</b>-terminated string. If this pointer parameter is non-<b>NULL</b>, it contains the file
///                   name of the application that is the target of the handoff. If <b>NULL</b>, the handoff target is the highest
///                   priority application that has opened the line for owner privilege for the specified media mode. A valid file name
///                   does not include the path of the file.
///    dwMediaMode = Media mode used to identify the target for the indirect handoff. The <i>dwMediaMode</i> parameter indirectly
///                  identifies the target application that is to receive ownership of the call. This parameter is ignored if
///                  <i>lpszFileName</i> is not <b>NULL</b>. This parameter uses one and only one of the LINEMEDIAMODE_ Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALMEDIAMODE, LINEERR_TARGETNOTFOUND,
///    LINEERR_INVALPOINTER, LINEERR_TARGETSELF, LINEERR_NOMEM, LINEERR_UNINITIALIZED, LINEERR_NOTOWNER.
///    
@DllImport("TAPI32")
int lineHandoffW(uint hCall, const(wchar)* lpszFileName, uint dwMediaMode);

///The <b>lineHold</b> function places the specified call on hold.
///Params:
///    hCall = Handle to the call to be placed on hold. The application must be an owner of the call. The call state of
///            <i>hCall</i> must be <i>connected</i>.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSTATE, LINEERR_OPERATIONFAILED,
///    LINEERR_NOMEM, LINEERR_RESOURCEUNAVAIL, LINEERR_NOTOWNER, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineHold(uint hCall);

///The <b>lineInitialize</b> function is obsolete. It continues to be exported by Tapi.dll and Tapi32.dll for backward
///compatibility with applications using API versions 1.3 and 1.4. Applications using API version 2.0 or later must use
///lineInitializeEx instead. <b>For TAPI Versions 1.4 and Earlier: </b> The <b>lineInitialize</b> function initializes
///the application's use of Tapi.dll for subsequent use of the line abstraction. The function registers the
///application's specified notification mechanism and returns the number of line devices available to the application. A
///line device is any device that provides an implementation for the line-prefixed functions in TAPI.
///Params:
///    lphLineApp = Pointer to a location that is filled with the application's usage handle for TAPI.
///    hInstance = Instance handle of the client application or DLL.
///    lpfnCallback = Address of a callback function that is invoked to determine status and events on the line device, addresses, or
///                   calls. For more information, see lineCallbackFunc.
///    lpszAppName = Pointer to a <b>null</b>-terminated text string that contains only displayable characters. If this parameter is
///                  not <b>NULL</b>, it contains an application-supplied name for the application. This name is provided in the
///                  LINECALLINFO structure to indicate, in a user-friendly way, which application originated, or originally accepted
///                  or answered the call. This information can be useful for call logging purposes. If <i>lpszAppName</i> is
///                  <b>NULL</b>, the application's file name is used instead.
///    lpdwNumDevs = Pointer to a <b>DWORD</b>-sized location. Upon successful completion of this request, this location is filled
///                  with the number of line devices available to the application.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALAPPNAME, LINEERR_OPERATIONFAILED, LINEERR_INIFILECORRUPT, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_INVALPOINTER, LINEERR_REINIT, LINEERR_NODRIVER, LINEERR_NODEVICE, LINEERR_NOMEM,
///    LINEERR_NOMULTIPLEINSTANCE.
///    
@DllImport("TAPI32")
int lineInitialize(uint* lphLineApp, HINSTANCE hInstance, LINECALLBACK lpfnCallback, const(char)* lpszAppName, 
                   uint* lpdwNumDevs);

///The <b>lineInitializeEx</b> function initializes the application's use of TAPI for subsequent use of the line
///abstraction. It registers the application's specified notification mechanism and returns the number of line devices
///available to the application. A line device is any device that provides an implementation for the line-prefixed
///functions in the Telephony API.
///Params:
///    lphLineApp = Pointer to a location that is filled with the application's usage handle for TAPI.
///    hInstance = Instance handle of the client application or DLL. The application or DLL can pass <b>NULL</b> for this parameter,
///                in which case TAPI uses the module handle of the root executable of the process (for purposes of identifying call
///                handoff targets and media mode priorities).
///    lpfnCallback = Address of a callback function that is invoked to determine status and events on the line device, addresses, or
///                   calls, when the application is using the "hidden window" method of event notification (for more information see
///                   lineCallbackFunc). This parameter is ignored and should be set to <b>NULL</b> when the application chooses to use
///                   the "event handle" or "completion port" event notification mechanisms.
///    lpszFriendlyAppName = Pointer to a <b>null</b>-terminated text string that contains only displayable characters. If this parameter is
///                          not <b>NULL</b>, it contains an application-supplied name for the application. This name is provided in the
///                          LINECALLINFO structure to indicate, in a user-friendly way, which application originated, or originally accepted
///                          or answered the call. This information can be useful for call-logging purposes. If <i>lpszFriendlyAppName</i> is
///                          <b>NULL</b>, the application's module file name is used instead (as returned by the function GetModuleFileName).
///    lpdwNumDevs = Pointer to a <b>DWORD</b>-sized location. Upon successful completion of this request, this location is filled
///                  with the number of line devices available to the application.
///    lpdwAPIVersion = Pointer to a <b>DWORD</b>-sized location. The application must initialize this <b>DWORD</b>, before calling this
///                     function, to the highest API version it is designed to support (for example, the same value it would pass into
///                     <i>dwAPIHighVersion</i> parameter of lineNegotiateAPIVersion). Artificially high values must not be used; the
///                     value must be accurately set. TAPI translates any newer messages or structures into values or formats supported
///                     by the application's version. Upon successful completion of this request, this location is filled with the
///                     highest API version supported by TAPI, thereby allowing the application to detect and adapt to having been
///                     installed on a system with a different version of TAPI.
///    lpLineInitializeExParams = Pointer to a structure of type LINEINITIALIZEEXPARAMS containing additional parameters used to establish the
///                               association between the application and TAPI (specifically, the application's selected event notification
///                               mechanism and associated parameters).
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALAPPNAME, LINEERR_OPERATIONFAILED, LINEERR_INIFILECORRUPT, LINEERR_INVALPOINTER, LINEERR_REINIT,
///    LINEERR_NOMEM, LINEERR_INVALPARAM.
///    
@DllImport("TAPI32")
int lineInitializeExA(uint* lphLineApp, HINSTANCE hInstance, LINECALLBACK lpfnCallback, 
                      const(char)* lpszFriendlyAppName, uint* lpdwNumDevs, uint* lpdwAPIVersion, 
                      LINEINITIALIZEEXPARAMS* lpLineInitializeExParams);

///The <b>lineInitializeEx</b> function initializes the application's use of TAPI for subsequent use of the line
///abstraction. It registers the application's specified notification mechanism and returns the number of line devices
///available to the application. A line device is any device that provides an implementation for the line-prefixed
///functions in the Telephony API.
///Params:
///    lphLineApp = Pointer to a location that is filled with the application's usage handle for TAPI.
///    hInstance = Instance handle of the client application or DLL. The application or DLL can pass <b>NULL</b> for this parameter,
///                in which case TAPI uses the module handle of the root executable of the process (for purposes of identifying call
///                handoff targets and media mode priorities).
///    lpfnCallback = Address of a callback function that is invoked to determine status and events on the line device, addresses, or
///                   calls, when the application is using the "hidden window" method of event notification (for more information see
///                   lineCallbackFunc). This parameter is ignored and should be set to <b>NULL</b> when the application chooses to use
///                   the "event handle" or "completion port" event notification mechanisms.
///    lpszFriendlyAppName = Pointer to a <b>null</b>-terminated text string that contains only displayable characters. If this parameter is
///                          not <b>NULL</b>, it contains an application-supplied name for the application. This name is provided in the
///                          LINECALLINFO structure to indicate, in a user-friendly way, which application originated, or originally accepted
///                          or answered the call. This information can be useful for call-logging purposes. If <i>lpszFriendlyAppName</i> is
///                          <b>NULL</b>, the application's module file name is used instead (as returned by the function GetModuleFileName).
///    lpdwNumDevs = Pointer to a <b>DWORD</b>-sized location. Upon successful completion of this request, this location is filled
///                  with the number of line devices available to the application.
///    lpdwAPIVersion = Pointer to a <b>DWORD</b>-sized location. The application must initialize this <b>DWORD</b>, before calling this
///                     function, to the highest API version it is designed to support (for example, the same value it would pass into
///                     <i>dwAPIHighVersion</i> parameter of lineNegotiateAPIVersion). Artificially high values must not be used; the
///                     value must be accurately set. TAPI translates any newer messages or structures into values or formats supported
///                     by the application's version. Upon successful completion of this request, this location is filled with the
///                     highest API version supported by TAPI, thereby allowing the application to detect and adapt to having been
///                     installed on a system with a different version of TAPI.
///    lpLineInitializeExParams = Pointer to a structure of type LINEINITIALIZEEXPARAMS containing additional parameters used to establish the
///                               association between the application and TAPI (specifically, the application's selected event notification
///                               mechanism and associated parameters).
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALAPPNAME, LINEERR_OPERATIONFAILED, LINEERR_INIFILECORRUPT, LINEERR_INVALPOINTER, LINEERR_REINIT,
///    LINEERR_NOMEM, LINEERR_INVALPARAM.
///    
@DllImport("TAPI32")
int lineInitializeExW(uint* lphLineApp, HINSTANCE hInstance, LINECALLBACK lpfnCallback, 
                      const(wchar)* lpszFriendlyAppName, uint* lpdwNumDevs, uint* lpdwAPIVersion, 
                      LINEINITIALIZEEXPARAMS* lpLineInitializeExParams);

///The <b>lineMakeCall</b> function places a call on the specified line to the specified destination address.
///Optionally, call parameters can be specified if anything but default call setup parameters are requested.
///Params:
///    hLine = Handle to the open line device on which a call is to be originated.
///    lphCall = Pointer to an HCALL handle. The handle is only valid after the LINE_REPLY message is received by the application
///              indicating that the <b>lineMakeCall</b> function successfully completed. Use this handle to identify the call
///              when invoking other telephony operations on the call. The application is initially the sole owner of this call.
///              This handle is void if the function returns an error (synchronously or asynchronously by the reply message).
///    lpszDestAddress = Pointer to the destination address. This follows the standard dialable number format. This pointer can be
///                      <b>NULL</b> for non-dialed addresses (as with a hot phone) or when all dialing is performed using lineDial. In
///                      the latter case, <b>lineMakeCall</b> allocates an available call appearance that would typically remain in the
///                      <b>dialtone</b> state until dialing begins. Service providers that have inverse multiplexing capabilities can
///                      allow an application to specify multiple addresses at once.
///    dwCountryCode = Country or region code of the called party. If a value of 0 is specified, a default is used by the
///                    implementation.
///    lpCallParams = Pointer to a LINECALLPARAMS structure. This structure allows the application to specify how it wants the call to
///                   be set up. If <b>NULL</b> is specified, a default 3.1 kHz voice call is established and an arbitrary origination
///                   address on the line is selected. This structure allows the application to select elements such as the call's
///                   bearer mode, data rate, expected media mode, origination address, blocking of caller ID information, and dialing
///                   parameters.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_ADDRESSBLOCKED,
///    LINEERR_INVALLINEHANDLE, LINEERR_BEARERMODEUNAVAIL, LINEERR_INVALLINESTATE, LINEERR_CALLUNAVAIL,
///    LINEERR_INVALMEDIAMODE, LINEERR_DIALBILLING, LINEERR_INVALPARAM, LINEERR_DIALDIALTONE, LINEERR_INVALPOINTER,
///    LINEERR_DIALPROMPT, LINEERR_INVALRATE, LINEERR_DIALQUIET, LINEERR_NOMEM, LINEERR_INUSE, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALADDRESS, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALADDRESSID, LINEERR_RATEUNAVAIL,
///    LINEERR_INVALADDRESSMODE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALBEARERMODE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALCALLPARAMS, LINEERR_UNINITIALIZED, LINEERR_INVALCOUNTRYCODE, LINEERR_USERUSERINFOTOOBIG.
///    
@DllImport("TAPI32")
int lineMakeCall(uint hLine, uint* lphCall, const(char)* lpszDestAddress, uint dwCountryCode, 
                 const(LINECALLPARAMS)* lpCallParams);

///The <b>lineMakeCall</b> function places a call on the specified line to the specified destination address.
///Optionally, call parameters can be specified if anything but default call setup parameters are requested.
///Params:
///    hLine = Handle to the open line device on which a call is to be originated.
///    lphCall = Pointer to an HCALL handle. The handle is only valid after the LINE_REPLY message is received by the application
///              indicating that the <b>lineMakeCall</b> function successfully completed. Use this handle to identify the call
///              when invoking other telephony operations on the call. The application is initially the sole owner of this call.
///              This handle is void if the function returns an error (synchronously or asynchronously by the reply message).
///    lpszDestAddress = Pointer to the destination address. This follows the standard dialable number format. This pointer can be
///                      <b>NULL</b> for non-dialed addresses (as with a hot phone) or when all dialing is performed using lineDial. In
///                      the latter case, <b>lineMakeCall</b> allocates an available call appearance that would typically remain in the
///                      <b>dialtone</b> state until dialing begins. Service providers that have inverse multiplexing capabilities can
///                      allow an application to specify multiple addresses at once.
///    dwCountryCode = Country or region code of the called party. If a value of 0 is specified, a default is used by the
///                    implementation.
///    lpCallParams = Pointer to a LINECALLPARAMS structure. This structure allows the application to specify how it wants the call to
///                   be set up. If <b>NULL</b> is specified, a default 3.1 kHz voice call is established and an arbitrary origination
///                   address on the line is selected. This structure allows the application to select elements such as the call's
///                   bearer mode, data rate, expected media mode, origination address, blocking of caller ID information, and dialing
///                   parameters.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_ADDRESSBLOCKED,
///    LINEERR_INVALLINEHANDLE, LINEERR_BEARERMODEUNAVAIL, LINEERR_INVALLINESTATE, LINEERR_CALLUNAVAIL,
///    LINEERR_INVALMEDIAMODE, LINEERR_DIALBILLING, LINEERR_INVALPARAM, LINEERR_DIALDIALTONE, LINEERR_INVALPOINTER,
///    LINEERR_DIALPROMPT, LINEERR_INVALRATE, LINEERR_DIALQUIET, LINEERR_NOMEM, LINEERR_INUSE, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALADDRESS, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALADDRESSID, LINEERR_RATEUNAVAIL,
///    LINEERR_INVALADDRESSMODE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALBEARERMODE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALCALLPARAMS, LINEERR_UNINITIALIZED, LINEERR_INVALCOUNTRYCODE, LINEERR_USERUSERINFOTOOBIG.
///    
@DllImport("TAPI32")
int lineMakeCallA(uint hLine, uint* lphCall, const(char)* lpszDestAddress, uint dwCountryCode, 
                  const(LINECALLPARAMS)* lpCallParams);

///The <b>lineMakeCall</b> function places a call on the specified line to the specified destination address.
///Optionally, call parameters can be specified if anything but default call setup parameters are requested.
///Params:
///    hLine = Handle to the open line device on which a call is to be originated.
///    lphCall = Pointer to an HCALL handle. The handle is only valid after the LINE_REPLY message is received by the application
///              indicating that the <b>lineMakeCall</b> function successfully completed. Use this handle to identify the call
///              when invoking other telephony operations on the call. The application is initially the sole owner of this call.
///              This handle is void if the function returns an error (synchronously or asynchronously by the reply message).
///    lpszDestAddress = Pointer to the destination address. This follows the standard dialable number format. This pointer can be
///                      <b>NULL</b> for non-dialed addresses (as with a hot phone) or when all dialing is performed using lineDial. In
///                      the latter case, <b>lineMakeCall</b> allocates an available call appearance that would typically remain in the
///                      <b>dialtone</b> state until dialing begins. Service providers that have inverse multiplexing capabilities can
///                      allow an application to specify multiple addresses at once.
///    dwCountryCode = Country or region code of the called party. If a value of 0 is specified, a default is used by the
///                    implementation.
///    lpCallParams = Pointer to a LINECALLPARAMS structure. This structure allows the application to specify how it wants the call to
///                   be set up. If <b>NULL</b> is specified, a default 3.1 kHz voice call is established and an arbitrary origination
///                   address on the line is selected. This structure allows the application to select elements such as the call's
///                   bearer mode, data rate, expected media mode, origination address, blocking of caller ID information, and dialing
///                   parameters.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_ADDRESSBLOCKED,
///    LINEERR_INVALLINEHANDLE, LINEERR_BEARERMODEUNAVAIL, LINEERR_INVALLINESTATE, LINEERR_CALLUNAVAIL,
///    LINEERR_INVALMEDIAMODE, LINEERR_DIALBILLING, LINEERR_INVALPARAM, LINEERR_DIALDIALTONE, LINEERR_INVALPOINTER,
///    LINEERR_DIALPROMPT, LINEERR_INVALRATE, LINEERR_DIALQUIET, LINEERR_NOMEM, LINEERR_INUSE, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALADDRESS, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALADDRESSID, LINEERR_RATEUNAVAIL,
///    LINEERR_INVALADDRESSMODE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALBEARERMODE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALCALLPARAMS, LINEERR_UNINITIALIZED, LINEERR_INVALCOUNTRYCODE, LINEERR_USERUSERINFOTOOBIG.
///    
@DllImport("TAPI32")
int lineMakeCallW(uint hLine, uint* lphCall, const(wchar)* lpszDestAddress, uint dwCountryCode, 
                  const(LINECALLPARAMS)* lpCallParams);

///The <b>lineMonitorDigits</b> function enables and disables the unbuffered detection of digits received on the call.
///Each time a digit of the specified digit mode is detected, a message is sent to the application indicating which
///digit has been detected.
///Params:
///    hCall = Handle to the call on which digits are to be detected. The call state of <i>hCall</i> can be any state except
///            <i>idle</i> or <i>disconnected</i>.
///    dwDigitModes = Digit mode or modes that are to be monitored. If <i>dwDigitModes</i> is zero, digit monitoring is canceled. This
///                   parameter uses one or more of the LINEDIGITMODE_ Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSTATE, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALDIGITMODE, LINEERR_RESOURCEUNAVAIL, LINEERR_NOMEM, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineMonitorDigits(uint hCall, uint dwDigitModes);

///The <b>lineMonitorMedia</b> function enables and disables the detection of media types (modes) on the specified call.
///When a media type is detected, a message is sent to the application. For more information, see
///ITLegacyCallMediaControl::MonitorMedia.
///Params:
///    hCall = Handle to the call. The call state of <i>hCall</i> can be any state except idle.
///    dwMediaModes = Media types to be monitored. If this parameter is zero, it cancels all media type detection. This parameter uses
///                   one or more of the LINEMEDIAMODE_ Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSTATE, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALMEDIAMODE, LINEERR_RESOURCEUNAVAIL, LINEERR_NOMEM, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineMonitorMedia(uint hCall, uint dwMediaModes);

///The <b>lineMonitorTones</b> function enables and disables the detection of inband tones on the call. Each time a
///specified tone is detected, a message is sent to the application.
///Params:
///    hCall = Handle to the call on whose voice channel tones are to be monitored. The call state of <i>hCall</i> can be any
///            state except <i>idle</i>.
///    lpToneList = List of tones to be monitored. This parameter is of type LINEMONITORTONE. Each tone in this list has an
///                 application-defined tag field that is used to identify individual tones in the list to report a tone detection.
///                 Tone monitoring in progress is canceled or changed by calling this operation with either <b>NULL</b> for
///                 <i>lpToneList</i> or with another tone list.
///    dwNumEntries = Number of entries in <i>lpToneList</i>. This parameter is ignored if <i>lpToneList</i> is <b>NULL</b>.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_INVALCALLSTATE, LINEERR_INVALPOINTER, LINEERR_INVALTONE, LINEERR_NOMEM,
///    LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineMonitorTones(uint hCall, const(LINEMONITORTONE)* lpToneList, uint dwNumEntries);

///The <b>lineNegotiateAPIVersion</b> function allows an application to negotiate an API version to use.
///Params:
///    hLineApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Identifier of the line device to be queried.
///    dwAPILowVersion = Earliest TAPI version with which the application is compliant. The high-order word is the major version number;
///                      the low-order word is the minor version number.
///    dwAPIHighVersion = Latest TAPI version with which the application is compliant. The high-order word is the major version number; the
///                       low-order word is the minor version number.
///    lpdwAPIVersion = Pointer to a variable that contains the TAPI version number that was negotiated. If negotiation succeeds, this
///                     number is in the range between <i>dwAPILowVersion</i> and <i>dwAPIHighVersion</i>.
///    lpExtensionID = Pointer to a structure of type LINEEXTENSIONID. If the service provider for the specified <i>dwDeviceID</i>
///                    supports provider-specific extensions, then, upon a successful negotiation, this structure is filled with the
///                    extension identifier of these extensions. This structure contains all zeros if the line provides no extensions.
///                    An application can ignore the returned parameter if it does not use extensions.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NODRIVER, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALAPPHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NOMEM,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineNegotiateAPIVersion(uint hLineApp, uint dwDeviceID, uint dwAPILowVersion, uint dwAPIHighVersion, 
                            uint* lpdwAPIVersion, LINEEXTENSIONID* lpExtensionID);

///The <b>lineNegotiateExtVersion</b> function allows an application to negotiate an extension version to use with the
///specified line device. This operation need not be called if the application does not support extensions.
///Params:
///    hLineApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Identifier of the line device to be queried.
///    dwAPIVersion = TAPI version number that was negotiated for the specified line device using lineNegotiateAPIVersion.
///    dwExtLowVersion = Earliest extension version of the extension identifier returned by lineNegotiateAPIVersion with which the
///                      application is compliant. The high-order word is the major version number; the low-order word is the minor
///                      version number.
///    dwExtHighVersion = Latest extension version of the extension identifier returned by lineNegotiateAPIVersion with which the
///                       application is compliant. The high-order word is the major version number; the low-order word is the minor
///                       version number.
///    lpdwExtVersion = Pointer to a variable that contains the extension version number that was negotiated. If negotiation succeeds,
///                     this number is in the range between <i>dwExtLowVersion</i> and <i>dwExtHighVersion</i>.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NOMEM, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NODRIVER,
///    LINEERR_INCOMPATIBLEEXTVERSION, LINEERR_OPERATIONFAILED, LINEERR_INVALAPPHANDLE, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NODEVICE, LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineNegotiateExtVersion(uint hLineApp, uint dwDeviceID, uint dwAPIVersion, uint dwExtLowVersion, 
                            uint dwExtHighVersion, uint* lpdwExtVersion);

///The <b>lineOpen</b> function opens the line device specified by its device identifier and returns a line handle for
///the corresponding opened line device. This line handle is used in subsequent operations on the line device.
///Params:
///    hLineApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Identifies the line device to be opened. It can either be a valid device identifier or the value. <table> <tr>
///                 <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LINEMAPPER"></a><a id="linemapper"></a><dl>
///                 <dt><b>LINEMAPPER</b></dt> </dl> </td> <td width="60%"> This value is used to open a line device in the system
///                 that supports the properties specified in <i>lpCallParams</i>. The application can use lineGetID to determine the
///                 identifier of the line device that was opened. </td> </tr> </table>
///    lphLine = Pointer to an HLINE handle that is then loaded with the handle representing the opened line device. Use this
///              handle to identify the device when invoking other functions on the open line device.
///    dwAPIVersion = API version number under which the application and Telephony API have agreed to operate. This number is obtained
///                   with lineNegotiateAPIVersion.
///    dwExtVersion = Extension version number under which the application and the service provider agree to operate. This number is
///                   zero if the application does not use any extensions. This number is obtained with lineNegotiateExtVersion.
///    dwCallbackInstance = User-instance data passed back to the application with each message associated with this line or with addresses
///                         or calls on this line. This parameter is not interpreted by the Telephony API.
///    dwPrivileges = Privilege the application wants when notified of a call This parameter contains one or more of the
///                   LINECALLPRIVILEGE_ Constants. For applications using TAPI version 2.0 or later, values for this parameter can
///                   also be combined with one or more of the LINEOPENOPTION_ Constants. If the LINEOPENOPTION_SINGLEADDRESS option is
///                   specified, then the application is interested only in new calls that appear on the address specified by the
///                   <b>dwAddressID</b> member in the LINECALLPARAMS structure pointed to by the <i>lpCallParams</i> parameter (which
///                   must be specified). If LINEOPENOPTION_SINGLEADDRESS is specified but either <i>lpCallParams</i> is invalid or the
///                   included <b>dwAddressID</b> does not exist on the line, the open fails with LINERR_INVALADDRESSID. In addition to
///                   setting the <b>dwAddressID</b> member of the LINECALLPARAMS structure to the desired address, the application
///                   must also set <b>dwAddressMode</b> in <b>LINECALLPARAMS</b> to LINEADDRESSMODE_ADDRESSID. The
///                   LINEOPENOPTION_SINGLEADDRESS option affects only TAPI's assignment of initial call ownership of calls created by
///                   the service provider using a LINE_NEWCALL message. An application that opens the line with
///                   LINECALLPRIVILEGE_MONITOR continues to receive monitoring handles to all calls created on the line. Furthermore,
///                   the application is not restricted in any way from making calls or performing other operations that affect other
///                   addresses on the opened line. When the LINEOPENOPTION_PROXY option is specified (TAPI 2.0 or higher only), the
///                   application must also indicate which specific proxy requests it is prepared to handle. It does so by passing, in
///                   the <i>lpCallParams</i> parameter, a pointer to a LINECALLPARAMS structure in which the <b>dwDevSpecificSize</b>
///                   and <b>dwDevSpecificOffset</b> members have been set to delimit an array of <b>DWORD</b>s. Each element of this
///                   array shall contain one of the LINEPROXYREQUEST_ Constants. For example, a proxy handler application that
///                   supports all five of the Agent-related functions would pass in an array of five <b>DWORD</b>s
///                   (<b>dwDevSpecificSize</b> would be 20 decimal) containing the five defined LINEPROXYREQUEST_ values. The proxy
///                   request handler application can run on any machine that has authorization to control the line device. However,
///                   requests are always routed through the server on which the service provider is executing that actually controls
///                   the line device. Thus, it is most efficient if the application handling proxy requests (such as ACD agent
///                   control) executes directly on the server along with the service provider. Subsequent attempts, by the same
///                   application or other applications, to open the line device and register to handle the same proxy requests as an
///                   application that is already registered fail with LINEERR_NOTREGISTERED. To stop handling requests on the line,
///                   the application simply calls lineClose. Other flag combinations return the LINEERR_INVALPRIVSELECT error.
///    dwMediaModes = The media type or modes of interest to the application. This parameter is used to register the application as a
///                   potential target for incoming call and call handoff for the specified media type. This parameter is meaningful
///                   only if the bit LINECALLPRIVILEGE_OWNER in <i>dwPrivileges</i> is set (and ignored otherwise). This parameter
///                   uses one or more of the LINEMEDIAMODE_ Constants.
///    lpCallParams = Pointer to a structure of type LINECALLPARAMS. This pointer is only used if LINEMAPPER or LINEOPENOPTION_PROXY is
///                   used; otherwise <i>lpCallParams</i> is ignored. It describes the call parameter that the line device should be
///                   able to provide.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_ALLOCATED, LINEERR_LINEMAPPERFAILED, LINEERR_BADDEVICEID, LINEERR_NODRIVER,
///    LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NOMEM, LINEERR_INCOMPATIBLEEXTVERSION, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALAPPHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALMEDIAMODE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_INVALPRIVSELECT, LINEERR_REINIT, LINEERR_NODEVICE,
///    LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineOpen(uint hLineApp, uint dwDeviceID, uint* lphLine, uint dwAPIVersion, uint dwExtVersion, 
             size_t dwCallbackInstance, uint dwPrivileges, uint dwMediaModes, const(LINECALLPARAMS)* lpCallParams);

///The <b>lineOpen</b> function opens the line device specified by its device identifier and returns a line handle for
///the corresponding opened line device. This line handle is used in subsequent operations on the line device.
///Params:
///    hLineApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Identifies the line device to be opened. It can either be a valid device identifier or the value. <table> <tr>
///                 <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LINEMAPPER"></a><a id="linemapper"></a><dl>
///                 <dt><b>LINEMAPPER</b></dt> </dl> </td> <td width="60%"> This value is used to open a line device in the system
///                 that supports the properties specified in <i>lpCallParams</i>. The application can use lineGetID to determine the
///                 identifier of the line device that was opened. </td> </tr> </table>
///    lphLine = Pointer to an HLINE handle that is then loaded with the handle representing the opened line device. Use this
///              handle to identify the device when invoking other functions on the open line device.
///    dwAPIVersion = API version number under which the application and Telephony API have agreed to operate. This number is obtained
///                   with lineNegotiateAPIVersion.
///    dwExtVersion = Extension version number under which the application and the service provider agree to operate. This number is
///                   zero if the application does not use any extensions. This number is obtained with lineNegotiateExtVersion.
///    dwCallbackInstance = User-instance data passed back to the application with each message associated with this line or with addresses
///                         or calls on this line. This parameter is not interpreted by the Telephony API.
///    dwPrivileges = Privilege the application wants when notified of a call This parameter contains one or more of the
///                   LINECALLPRIVILEGE_ Constants. For applications using TAPI version 2.0 or later, values for this parameter can
///                   also be combined with one or more of the LINEOPENOPTION_ Constants. If the LINEOPENOPTION_SINGLEADDRESS option is
///                   specified, then the application is interested only in new calls that appear on the address specified by the
///                   <b>dwAddressID</b> member in the LINECALLPARAMS structure pointed to by the <i>lpCallParams</i> parameter (which
///                   must be specified). If LINEOPENOPTION_SINGLEADDRESS is specified but either <i>lpCallParams</i> is invalid or the
///                   included <b>dwAddressID</b> does not exist on the line, the open fails with LINERR_INVALADDRESSID. In addition to
///                   setting the <b>dwAddressID</b> member of the LINECALLPARAMS structure to the desired address, the application
///                   must also set <b>dwAddressMode</b> in <b>LINECALLPARAMS</b> to LINEADDRESSMODE_ADDRESSID. The
///                   LINEOPENOPTION_SINGLEADDRESS option affects only TAPI's assignment of initial call ownership of calls created by
///                   the service provider using a LINE_NEWCALL message. An application that opens the line with
///                   LINECALLPRIVILEGE_MONITOR continues to receive monitoring handles to all calls created on the line. Furthermore,
///                   the application is not restricted in any way from making calls or performing other operations that affect other
///                   addresses on the opened line. When the LINEOPENOPTION_PROXY option is specified (TAPI 2.0 or higher only), the
///                   application must also indicate which specific proxy requests it is prepared to handle. It does so by passing, in
///                   the <i>lpCallParams</i> parameter, a pointer to a LINECALLPARAMS structure in which the <b>dwDevSpecificSize</b>
///                   and <b>dwDevSpecificOffset</b> members have been set to delimit an array of <b>DWORD</b>s. Each element of this
///                   array shall contain one of the LINEPROXYREQUEST_ Constants. For example, a proxy handler application that
///                   supports all five of the Agent-related functions would pass in an array of five <b>DWORD</b>s
///                   (<b>dwDevSpecificSize</b> would be 20 decimal) containing the five defined LINEPROXYREQUEST_ values. The proxy
///                   request handler application can run on any machine that has authorization to control the line device. However,
///                   requests are always routed through the server on which the service provider is executing that actually controls
///                   the line device. Thus, it is most efficient if the application handling proxy requests (such as ACD agent
///                   control) executes directly on the server along with the service provider. Subsequent attempts, by the same
///                   application or other applications, to open the line device and register to handle the same proxy requests as an
///                   application that is already registered fail with LINEERR_NOTREGISTERED. To stop handling requests on the line,
///                   the application simply calls lineClose. Other flag combinations return the LINEERR_INVALPRIVSELECT error.
///    dwMediaModes = The media type or modes of interest to the application. This parameter is used to register the application as a
///                   potential target for incoming call and call handoff for the specified media type. This parameter is meaningful
///                   only if the bit LINECALLPRIVILEGE_OWNER in <i>dwPrivileges</i> is set (and ignored otherwise). This parameter
///                   uses one or more of the LINEMEDIAMODE_ Constants.
///    lpCallParams = Pointer to a structure of type LINECALLPARAMS. This pointer is only used if LINEMAPPER or LINEOPENOPTION_PROXY is
///                   used; otherwise <i>lpCallParams</i> is ignored. It describes the call parameter that the line device should be
///                   able to provide.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_ALLOCATED, LINEERR_LINEMAPPERFAILED, LINEERR_BADDEVICEID, LINEERR_NODRIVER,
///    LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NOMEM, LINEERR_INCOMPATIBLEEXTVERSION, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALAPPHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALMEDIAMODE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_INVALPRIVSELECT, LINEERR_REINIT, LINEERR_NODEVICE,
///    LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineOpenA(uint hLineApp, uint dwDeviceID, uint* lphLine, uint dwAPIVersion, uint dwExtVersion, 
              size_t dwCallbackInstance, uint dwPrivileges, uint dwMediaModes, const(LINECALLPARAMS)* lpCallParams);

///The <b>lineOpen</b> function opens the line device specified by its device identifier and returns a line handle for
///the corresponding opened line device. This line handle is used in subsequent operations on the line device.
///Params:
///    hLineApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Identifies the line device to be opened. It can either be a valid device identifier or the value. <table> <tr>
///                 <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LINEMAPPER"></a><a id="linemapper"></a><dl>
///                 <dt><b>LINEMAPPER</b></dt> </dl> </td> <td width="60%"> This value is used to open a line device in the system
///                 that supports the properties specified in <i>lpCallParams</i>. The application can use lineGetID to determine the
///                 identifier of the line device that was opened. </td> </tr> </table>
///    lphLine = Pointer to an HLINE handle that is then loaded with the handle representing the opened line device. Use this
///              handle to identify the device when invoking other functions on the open line device.
///    dwAPIVersion = API version number under which the application and Telephony API have agreed to operate. This number is obtained
///                   with lineNegotiateAPIVersion.
///    dwExtVersion = Extension version number under which the application and the service provider agree to operate. This number is
///                   zero if the application does not use any extensions. This number is obtained with lineNegotiateExtVersion.
///    dwCallbackInstance = User-instance data passed back to the application with each message associated with this line or with addresses
///                         or calls on this line. This parameter is not interpreted by the Telephony API.
///    dwPrivileges = Privilege the application wants when notified of a call This parameter contains one or more of the
///                   LINECALLPRIVILEGE_ Constants. For applications using TAPI version 2.0 or later, values for this parameter can
///                   also be combined with one or more of the LINEOPENOPTION_ Constants. If the LINEOPENOPTION_SINGLEADDRESS option is
///                   specified, then the application is interested only in new calls that appear on the address specified by the
///                   <b>dwAddressID</b> member in the LINECALLPARAMS structure pointed to by the <i>lpCallParams</i> parameter (which
///                   must be specified). If LINEOPENOPTION_SINGLEADDRESS is specified but either <i>lpCallParams</i> is invalid or the
///                   included <b>dwAddressID</b> does not exist on the line, the open fails with LINERR_INVALADDRESSID. In addition to
///                   setting the <b>dwAddressID</b> member of the LINECALLPARAMS structure to the desired address, the application
///                   must also set <b>dwAddressMode</b> in <b>LINECALLPARAMS</b> to LINEADDRESSMODE_ADDRESSID. The
///                   LINEOPENOPTION_SINGLEADDRESS option affects only TAPI's assignment of initial call ownership of calls created by
///                   the service provider using a LINE_NEWCALL message. An application that opens the line with
///                   LINECALLPRIVILEGE_MONITOR continues to receive monitoring handles to all calls created on the line. Furthermore,
///                   the application is not restricted in any way from making calls or performing other operations that affect other
///                   addresses on the opened line. When the LINEOPENOPTION_PROXY option is specified (TAPI 2.0 or higher only), the
///                   application must also indicate which specific proxy requests it is prepared to handle. It does so by passing, in
///                   the <i>lpCallParams</i> parameter, a pointer to a LINECALLPARAMS structure in which the <b>dwDevSpecificSize</b>
///                   and <b>dwDevSpecificOffset</b> members have been set to delimit an array of <b>DWORD</b>s. Each element of this
///                   array shall contain one of the LINEPROXYREQUEST_ Constants. For example, a proxy handler application that
///                   supports all five of the Agent-related functions would pass in an array of five <b>DWORD</b>s
///                   (<b>dwDevSpecificSize</b> would be 20 decimal) containing the five defined LINEPROXYREQUEST_ values. The proxy
///                   request handler application can run on any machine that has authorization to control the line device. However,
///                   requests are always routed through the server on which the service provider is executing that actually controls
///                   the line device. Thus, it is most efficient if the application handling proxy requests (such as ACD agent
///                   control) executes directly on the server along with the service provider. Subsequent attempts, by the same
///                   application or other applications, to open the line device and register to handle the same proxy requests as an
///                   application that is already registered fail with LINEERR_NOTREGISTERED. To stop handling requests on the line,
///                   the application simply calls lineClose. Other flag combinations return the LINEERR_INVALPRIVSELECT error.
///    dwMediaModes = The media type or modes of interest to the application. This parameter is used to register the application as a
///                   potential target for incoming call and call handoff for the specified media type. This parameter is meaningful
///                   only if the bit LINECALLPRIVILEGE_OWNER in <i>dwPrivileges</i> is set (and ignored otherwise). This parameter
///                   uses one or more of the LINEMEDIAMODE_ Constants.
///    lpCallParams = Pointer to a structure of type LINECALLPARAMS. This pointer is only used if LINEMAPPER or LINEOPENOPTION_PROXY is
///                   used; otherwise <i>lpCallParams</i> is ignored. It describes the call parameter that the line device should be
///                   able to provide.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_ALLOCATED, LINEERR_LINEMAPPERFAILED, LINEERR_BADDEVICEID, LINEERR_NODRIVER,
///    LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NOMEM, LINEERR_INCOMPATIBLEEXTVERSION, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALAPPHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALMEDIAMODE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_INVALPRIVSELECT, LINEERR_REINIT, LINEERR_NODEVICE,
///    LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineOpenW(uint hLineApp, uint dwDeviceID, uint* lphLine, uint dwAPIVersion, uint dwExtVersion, 
              size_t dwCallbackInstance, uint dwPrivileges, uint dwMediaModes, const(LINECALLPARAMS)* lpCallParams);

///The <b>linePark</b> function parks the specified call according to the specified park mode.
///Params:
///    hCall = Handle to the call to be parked. The application must be an owner of the call. The call state of <i>hCall</i>
///            must be <i>connected</i>.
///    dwParkMode = Park mode with which the call is to be parked. This parameter can have only a single flag set, and uses one of
///                 the LINEPARKMODE_ Constants.
///    lpszDirAddress = Pointer to a <b>null</b>-terminated string that indicates the address where the call is to be parked when using
///                     directed park. The address is in dialable number format. This parameter is ignored for nondirected park.
///    lpNonDirAddress = Pointer to a structure of type VARSTRING. For nondirected park, the address where the call is parked is returned
///                      in this structure. This parameter is ignored for directed park. Within the <b>VARSTRING</b> structure,
///                      <b>dwStringFormat</b> must be set to STRINGFORMAT_ASCII (an ASCII string buffer containing a
///                      <b>null</b>-terminated string), and the terminating <b>NULL</b> must be accounted for in the <b>dwStringSize</b>.
///                      Prior to calling <b>linePark</b>, the application must set the <b>dwTotalSize</b> member of this structure to
///                      indicate the amount of memory available to TAPI for returning information.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_INVALADDRESS,
///    LINEERR_NOTOWNER, LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSTATE,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALPARKMODE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_STRUCTURETOOSMALL, LINEERR_NOMEM, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int linePark(uint hCall, uint dwParkMode, const(char)* lpszDirAddress, VARSTRING* lpNonDirAddress);

///The <b>linePark</b> function parks the specified call according to the specified park mode.
///Params:
///    hCall = Handle to the call to be parked. The application must be an owner of the call. The call state of <i>hCall</i>
///            must be <i>connected</i>.
///    dwParkMode = Park mode with which the call is to be parked. This parameter can have only a single flag set, and uses one of
///                 the LINEPARKMODE_ Constants.
///    lpszDirAddress = Pointer to a <b>null</b>-terminated string that indicates the address where the call is to be parked when using
///                     directed park. The address is in dialable number format. This parameter is ignored for nondirected park.
///    lpNonDirAddress = Pointer to a structure of type VARSTRING. For nondirected park, the address where the call is parked is returned
///                      in this structure. This parameter is ignored for directed park. Within the <b>VARSTRING</b> structure,
///                      <b>dwStringFormat</b> must be set to STRINGFORMAT_ASCII (an ASCII string buffer containing a
///                      <b>null</b>-terminated string), and the terminating <b>NULL</b> must be accounted for in the <b>dwStringSize</b>.
///                      Prior to calling <b>linePark</b>, the application must set the <b>dwTotalSize</b> member of this structure to
///                      indicate the amount of memory available to TAPI for returning information.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_INVALADDRESS,
///    LINEERR_NOTOWNER, LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSTATE,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALPARKMODE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_STRUCTURETOOSMALL, LINEERR_NOMEM, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineParkA(uint hCall, uint dwParkMode, const(char)* lpszDirAddress, VARSTRING* lpNonDirAddress);

///The <b>linePark</b> function parks the specified call according to the specified park mode.
///Params:
///    hCall = Handle to the call to be parked. The application must be an owner of the call. The call state of <i>hCall</i>
///            must be <i>connected</i>.
///    dwParkMode = Park mode with which the call is to be parked. This parameter can have only a single flag set, and uses one of
///                 the LINEPARKMODE_ Constants.
///    lpszDirAddress = Pointer to a <b>null</b>-terminated string that indicates the address where the call is to be parked when using
///                     directed park. The address is in dialable number format. This parameter is ignored for nondirected park.
///    lpNonDirAddress = Pointer to a structure of type VARSTRING. For nondirected park, the address where the call is parked is returned
///                      in this structure. This parameter is ignored for directed park. Within the <b>VARSTRING</b> structure,
///                      <b>dwStringFormat</b> must be set to STRINGFORMAT_ASCII (an ASCII string buffer containing a
///                      <b>null</b>-terminated string), and the terminating <b>NULL</b> must be accounted for in the <b>dwStringSize</b>.
///                      Prior to calling <b>linePark</b>, the application must set the <b>dwTotalSize</b> member of this structure to
///                      indicate the amount of memory available to TAPI for returning information.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_INVALADDRESS,
///    LINEERR_NOTOWNER, LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSTATE,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALPARKMODE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_STRUCTURETOOSMALL, LINEERR_NOMEM, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineParkW(uint hCall, uint dwParkMode, const(wchar)* lpszDirAddress, VARSTRING* lpNonDirAddress);

///The <b>linePickup</b> function picks up a call alerting at the specified destination address and returns a call
///handle for the picked-up call. If invoked with <b>NULL</b> for the <i>lpszDestAddress</i> parameter, a group pickup
///is performed. If required by the device, <i>lpszGroupID</i> specifies the group identifier to which the alerting
///station belongs.
///Params:
///    hLine = Handle to the open line device on which a call is to be picked up.
///    dwAddressID = Address on <i>hLine</i> at which the pickup is to be originated. An address identifier is permanently associated
///                  with an address; the identifier remains constant across operating system upgrades.
///    lphCall = Pointer to a memory location where the handle to the picked up call is returned. The application is the initial
///              sole owner of the call.
///    lpszDestAddress = Pointer to a <b>null</b>-terminated character buffer that contains the address whose call is to be picked up. The
///                      address is in standard dialable address format.
///    lpszGroupID = Pointer to a <b>null</b>-terminated character buffer containing the group identifier to which the alerting
///                  station belongs. This parameter is required on some switches to pick up calls outside of the current pickup
///                  group. The <i>lpszGroupID</i> parameter can be specified by itself with a <b>NULL</b> pointer for
///                  <i>lpszDestAddress</i>. Alternatively, <i>lpszGroupID</i> can be specified in addition to <i>lpszDestAddress</i>,
///                  if required by the device.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_INVALADDRESS,
///    LINEERR_NOMEM, LINEERR_INVALADDRESSID, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALGROUPID, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int linePickup(uint hLine, uint dwAddressID, uint* lphCall, const(char)* lpszDestAddress, const(char)* lpszGroupID);

///The <b>linePickup</b> function picks up a call alerting at the specified destination address and returns a call
///handle for the picked-up call. If invoked with <b>NULL</b> for the <i>lpszDestAddress</i> parameter, a group pickup
///is performed. If required by the device, <i>lpszGroupID</i> specifies the group identifier to which the alerting
///station belongs.
///Params:
///    hLine = Handle to the open line device on which a call is to be picked up.
///    dwAddressID = Address on <i>hLine</i> at which the pickup is to be originated. An address identifier is permanently associated
///                  with an address; the identifier remains constant across operating system upgrades.
///    lphCall = Pointer to a memory location where the handle to the picked up call is returned. The application is the initial
///              sole owner of the call.
///    lpszDestAddress = Pointer to a <b>null</b>-terminated character buffer that contains the address whose call is to be picked up. The
///                      address is in standard dialable address format.
///    lpszGroupID = Pointer to a <b>null</b>-terminated character buffer containing the group identifier to which the alerting
///                  station belongs. This parameter is required on some switches to pick up calls outside of the current pickup
///                  group. The <i>lpszGroupID</i> parameter can be specified by itself with a <b>NULL</b> pointer for
///                  <i>lpszDestAddress</i>. Alternatively, <i>lpszGroupID</i> can be specified in addition to <i>lpszDestAddress</i>,
///                  if required by the device.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_INVALADDRESS,
///    LINEERR_NOMEM, LINEERR_INVALADDRESSID, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALGROUPID, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int linePickupA(uint hLine, uint dwAddressID, uint* lphCall, const(char)* lpszDestAddress, 
                const(char)* lpszGroupID);

///The <b>linePickup</b> function picks up a call alerting at the specified destination address and returns a call
///handle for the picked-up call. If invoked with <b>NULL</b> for the <i>lpszDestAddress</i> parameter, a group pickup
///is performed. If required by the device, <i>lpszGroupID</i> specifies the group identifier to which the alerting
///station belongs.
///Params:
///    hLine = Handle to the open line device on which a call is to be picked up.
///    dwAddressID = Address on <i>hLine</i> at which the pickup is to be originated. An address identifier is permanently associated
///                  with an address; the identifier remains constant across operating system upgrades.
///    lphCall = Pointer to a memory location where the handle to the picked up call is returned. The application is the initial
///              sole owner of the call.
///    lpszDestAddress = Pointer to a <b>null</b>-terminated character buffer that contains the address whose call is to be picked up. The
///                      address is in standard dialable address format.
///    lpszGroupID = Pointer to a <b>null</b>-terminated character buffer containing the group identifier to which the alerting
///                  station belongs. This parameter is required on some switches to pick up calls outside of the current pickup
///                  group. The <i>lpszGroupID</i> parameter can be specified by itself with a <b>NULL</b> pointer for
///                  <i>lpszDestAddress</i>. Alternatively, <i>lpszGroupID</i> can be specified in addition to <i>lpszDestAddress</i>,
///                  if required by the device.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_INVALADDRESS,
///    LINEERR_NOMEM, LINEERR_INVALADDRESSID, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALGROUPID, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int linePickupW(uint hLine, uint dwAddressID, uint* lphCall, const(wchar)* lpszDestAddress, 
                const(wchar)* lpszGroupID);

///The <b>linePrepareAddToConference</b> function prepares an existing conference call for the addition of another
///party.
///Params:
///    hConfCall = Handle to a conference call. The application must be an owner of this call. The call state of <i>hConfCall</i>
///                must be <i>connected</i>.
///    lphConsultCall = Pointer to an HCALL handle. This location is then loaded with a handle identifying the consultation call to be
///                     added. Initially, the application is the sole owner of this call.
///    lpCallParams = Pointer to a LINECALLPARAMS structure containing call parameters to use when establishing the consultation call.
///                   This parameter can be set to <b>NULL</b> if no special call setup parameters are desired.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_BEARERMODEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_CALLUNAVAIL, LINEERR_INVALRATE, LINEERR_CONFERENCEFULL,
///    LINEERR_NOMEM, LINEERR_INUSE, LINEERR_NOTOWNER, LINEERR_INVALADDRESSMODE, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALBEARERMODE, LINEERR_OPERATIONFAILED, LINEERR_INVALCALLPARAMS, LINEERR_RATEUNAVAIL,
///    LINEERR_INVALCALLSTATE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALCONFCALLHANDLE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALLINESTATE, LINEERR_USERUSERINFOTOOBIG, LINEERR_INVALMEDIAMODE, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int linePrepareAddToConference(uint hConfCall, uint* lphConsultCall, const(LINECALLPARAMS)* lpCallParams);

///The <b>linePrepareAddToConference</b> function prepares an existing conference call for the addition of another
///party.
///Params:
///    hConfCall = Handle to a conference call. The application must be an owner of this call. The call state of <i>hConfCall</i>
///                must be <i>connected</i>.
///    lphConsultCall = Pointer to an HCALL handle. This location is then loaded with a handle identifying the consultation call to be
///                     added. Initially, the application is the sole owner of this call.
///    lpCallParams = Pointer to a LINECALLPARAMS structure containing call parameters to use when establishing the consultation call.
///                   This parameter can be set to <b>NULL</b> if no special call setup parameters are desired.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_BEARERMODEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_CALLUNAVAIL, LINEERR_INVALRATE, LINEERR_CONFERENCEFULL,
///    LINEERR_NOMEM, LINEERR_INUSE, LINEERR_NOTOWNER, LINEERR_INVALADDRESSMODE, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALBEARERMODE, LINEERR_OPERATIONFAILED, LINEERR_INVALCALLPARAMS, LINEERR_RATEUNAVAIL,
///    LINEERR_INVALCALLSTATE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALCONFCALLHANDLE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALLINESTATE, LINEERR_USERUSERINFOTOOBIG, LINEERR_INVALMEDIAMODE, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int linePrepareAddToConferenceA(uint hConfCall, uint* lphConsultCall, const(LINECALLPARAMS)* lpCallParams);

///The <b>linePrepareAddToConference</b> function prepares an existing conference call for the addition of another
///party.
///Params:
///    hConfCall = Handle to a conference call. The application must be an owner of this call. The call state of <i>hConfCall</i>
///                must be <i>connected</i>.
///    lphConsultCall = Pointer to an HCALL handle. This location is then loaded with a handle identifying the consultation call to be
///                     added. Initially, the application is the sole owner of this call.
///    lpCallParams = Pointer to a LINECALLPARAMS structure containing call parameters to use when establishing the consultation call.
///                   This parameter can be set to <b>NULL</b> if no special call setup parameters are desired.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_BEARERMODEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_CALLUNAVAIL, LINEERR_INVALRATE, LINEERR_CONFERENCEFULL,
///    LINEERR_NOMEM, LINEERR_INUSE, LINEERR_NOTOWNER, LINEERR_INVALADDRESSMODE, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALBEARERMODE, LINEERR_OPERATIONFAILED, LINEERR_INVALCALLPARAMS, LINEERR_RATEUNAVAIL,
///    LINEERR_INVALCALLSTATE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALCONFCALLHANDLE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_INVALLINESTATE, LINEERR_USERUSERINFOTOOBIG, LINEERR_INVALMEDIAMODE, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int linePrepareAddToConferenceW(uint hConfCall, uint* lphConsultCall, const(LINECALLPARAMS)* lpCallParams);

///The <b>lineProxyMessage</b> function is used by a registered proxy request handler to generate TAPI messages related
///to its role. For example, an ACD agent handler can use this function to generate LINE_AGENTSTATUS messages that are
///received by all applications that have the specified line open. TAPI suppresses generation of the message on the
///<i>hLine</i> specified in the function parameters.
///Params:
///    hLine = Handle to the open line device. This is converted by TAPI into the correct <i>hLine</i> for each application that
///            receives the message.
///    hCall = If the message is related to a specific call (which it is not, in the case of LINE_AGENTSTATUS), specifies the
///            proxy handler's handle to that call; shall be set to <b>NULL</b> for messages not related to a specific call.
///            This is converted by TAPI into the correct <i>hCall</i> for each application that receives the message.
///    dwMsg = The TAPI message to generate. This must be a message that is permitted to be generated by proxy handlers.
///    dwParam1 = Parameter associated with the message to be sent.
///    dwParam2 = Parameter associated with the message to be sent.
///    dwParam3 = Parameter associated with the message to be sent.
///Returns:
///    Returns zero if the function succeeds or one of these negative error values: LINEERR_INVALLINEHANDLE,
///    LINEERR_INVALCALLHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_NOTREGISTERED, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineProxyMessage(uint hLine, uint hCall, uint dwMsg, uint dwParam1, uint dwParam2, uint dwParam3);

///The <b>lineProxyResponse</b> function indicates completion of a proxy request by a registered proxy handler, such as
///an ACD agent handler on a server.
///Params:
///    hLine = A handle to the open line device.
///    lpProxyRequest = A pointer to the proxy request buffer given to the application by TAPI in a LINE_PROXYREQUEST message. In the
///                     case of proxy requests that return data to the client application, the proxy handler should have filled in the
///                     necessary structure in this buffer before calling this function. The <b>dwNeededSize</b> and <b>dwUsedSize</b>
///                     members of the structure to be returned must have been set appropriately. <div class="alert"><b>Note</b> If the
///                     size parameters in the structure are incorrect, it is possible that data could be overwritten. For more
///                     information about setting structure sizes, see memory allocation.</div> <div> </div>
///    dwResult = A function result returned to the calling application in a LINE_REPLY message (generated automatically by TAPI).
///               Must be zero or one of the negative error values defined for the called function.
///Returns:
///    Returns zero if the function succeeds or one of these negative error values: <b>LINEERR_INVALLINEHANDLE</b>,
///    <b>LINEERR_INVALPARAM</b>, <b>LINEERR_INVALPOINTER</b>, <b>LINEERR_NOMEM</b>, <b>LINEERR_NOTREGISTERED</b>,
///    <b>LINEERR_OPERATIONFAILED</b>, <b>LINE ERR_OPERATIONUNAVAIL</b>, <b>LINEERR_RESOURCEUNAVAIL</b>,
///    <b>LINEERR_UNINITIALIZED</b>.
///    
@DllImport("TAPI32")
int lineProxyResponse(uint hLine, LINEPROXYREQUEST* lpProxyRequest, uint dwResult);

///The <b>lineRedirect</b> function redirects the specified offering call to the specified destination address.
///Params:
///    hCall = Handle to the call to be redirected. The application must be an owner of the call. The call state of <i>hCall</i>
///            must be <i>offering</i>.
///    lpszDestAddress = Pointer to the destination address. This follows the standard dialable number format.
///    dwCountryCode = Country/region code of the party the call is redirected to. If a value of 0 is specified, a default is used by
///                    the implementation.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_INVALADDRESS,
///    LINEERR_NOTOWNER, LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSTATE,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALCOUNTRYCODE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineRedirect(uint hCall, const(char)* lpszDestAddress, uint dwCountryCode);

///The <b>lineRedirect</b> function redirects the specified offering call to the specified destination address.
///Params:
///    hCall = Handle to the call to be redirected. The application must be an owner of the call. The call state of <i>hCall</i>
///            must be <i>offering</i>.
///    lpszDestAddress = Pointer to the destination address. This follows the standard dialable number format.
///    dwCountryCode = Country/region code of the party the call is redirected to. If a value of 0 is specified, a default is used by
///                    the implementation.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_INVALADDRESS,
///    LINEERR_NOTOWNER, LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSTATE,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALCOUNTRYCODE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineRedirectA(uint hCall, const(char)* lpszDestAddress, uint dwCountryCode);

///The <b>lineRedirect</b> function redirects the specified offering call to the specified destination address.
///Params:
///    hCall = Handle to the call to be redirected. The application must be an owner of the call. The call state of <i>hCall</i>
///            must be <i>offering</i>.
///    lpszDestAddress = Pointer to the destination address. This follows the standard dialable number format.
///    dwCountryCode = Country/region code of the party the call is redirected to. If a value of 0 is specified, a default is used by
///                    the implementation.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_INVALADDRESS,
///    LINEERR_NOTOWNER, LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSTATE,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALCOUNTRYCODE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineRedirectW(uint hCall, const(wchar)* lpszDestAddress, uint dwCountryCode);

///The <b>lineRegisterRequestRecipient</b> function registers the invoking application as a recipient of requests for
///the specified request mode.
///Params:
///    hLineApp = Application's usage handle for the line portion of TAPI.
///    dwRegistrationInstance = Application-specific <b>DWORD</b> that is passed back as a parameter of the LINE_REQUEST message. This message
///                             notifies the application that a request is pending. This parameter is ignored if <i>bEnable</i> is set to zero.
///                             This parameter is examined by TAPI only for registration, not for deregistration. The
///                             <i>dwRegistrationInstance</i> value used while deregistering need not match the <i>dwRegistrationInstance</i>
///                             used while registering for a request mode.
///    dwRequestMode = Type of request for which the application registers. This parameter uses one or more of the LINEREQUESTMODE_
///                    Constants.
///    bEnable = If <b>TRUE</b>, the application registers the specified request modes; if <b>FALSE</b>, the application
///              deregisters for the specified request modes.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALAPPHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALREQUESTMODE, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_NOMEM, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineRegisterRequestRecipient(uint hLineApp, uint dwRegistrationInstance, uint dwRequestMode, uint bEnable);

///The <b>lineReleaseUserUserInfo</b> function informs the service provider that the application has processed the
///user-user information contained in the LINECALLINFO structure, and that subsequently received user-user information
///can now be written into that structure. The service provider sends a LINE_CALLINFO message indicating
///LINECALLINFOSTATE_USERUSERINFO when new information is available.
///Params:
///    hCall = Handle to the call. The application must be an owner of the call. The call state of <i>hCall</i> can be any
///            state.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_NOMEM, LINEERR_RESOURCEUNAVAIL, LINEERR_NOTOWNER,
///    LINEERR_UNINITIALIZED, LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineReleaseUserUserInfo(uint hCall);

///The <b>lineRemoveFromConference</b> function removes the specified call from the conference call to which it
///currently belongs. The remaining calls in the conference call are unaffected.
///Params:
///    hCall = Handle to the call to be removed from the conference. The application must be an owner of this call. The call
///            state of <i>hCall</i> must be <i>conferenced</i>.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSTATE, LINEERR_OPERATIONFAILED,
///    LINEERR_NOMEM, LINEERR_RESOURCEUNAVAIL, LINEERR_NOTOWNER, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineRemoveFromConference(uint hCall);

///The <b>lineRemoveProvider</b> function removes an existing telephony service provider from the telephony system.
///Params:
///    dwPermanentProviderID = Permanent provider identifier of the service provider to be removed.
///    hwndOwner = Handle to a window to which any dialog boxes that need to be displayed as part of the removal process (for
///                example, a confirmation dialog box by the service provider's TSPI_providerRemove function) would be attached. Can
///                be a <b>NULL</b> value to indicate that any window created during the function should have no owner window.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INIFILECORRUPT, LINEERR_NOMEM, LINEERR_INVALPARAM, LINEERR_OPERATIONFAILED.
///    
@DllImport("TAPI32")
int lineRemoveProvider(uint dwPermanentProviderID, HWND hwndOwner);

///The <b>lineSecureCall</b> function secures the call from any interruptions or interference that can affect the call's
///media stream.
///Params:
///    hCall = Handle to the call to be secured. The application must be an owner of the call. The call state of <i>hCall</i>
///            can be any state.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSTATE, LINEERR_OPERATIONFAILED,
///    LINEERR_NOMEM, LINEERR_RESOURCEUNAVAIL, LINEERR_NOTOWNER, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineSecureCall(uint hCall);

///The <b>lineSendUserUserInfo</b> function sends user-user information to the remote party on the specified call.
///Params:
///    hCall = Handle to the call on which to send user-user information. The application must be an owner of the call. The call
///            state of <i>hCall</i> must be <i>connected</i>, <i>offering</i>, <i>accepted</i>, or <i>ringback</i>.
///    lpsUserUserInfo = Pointer to a string containing user-user information to be sent to the remote party. User-user information is
///                      only sent if supported by the underlying network (see LINEDEVCAPS). The protocol discriminator field for the
///                      user-user information, if required, should appear as the first byte of the buffer pointed to by
///                      <i>lpsUserUserInfo</i>, and must be accounted for in <i>dwSize</i>.
///    dwSize = Size of the user-user information in <i>lpsUserUserInfo</i>, in bytes.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSTATE, LINEERR_OPERATIONFAILED,
///    LINEERR_INVALPOINTER, LINEERR_RESOURCEUNAVAIL, LINEERR_NOMEM, LINEERR_USERUSERINFOTOOBIG, LINEERR_NOTOWNER,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineSendUserUserInfo(uint hCall, const(char)* lpsUserUserInfo, uint dwSize);

///The <b>lineSetAgentActivity</b> function sets the agent activity code associated with a particular address.
///Params:
///    hLine = Handle to the line device.
///    dwAddressID = Identifier of the address for which the agent activity code is to be changed. An address identifier is
///                  permanently associated with an address; the identifier remains constant across operating system upgrades.
///    dwActivityID = New agent activity. The meaning of all values of this parameter are specific to the application and call center
///                   server.
///Returns:
///    Returns a positive request identifier if the asynchronous operation starts; otherwise, the function returns one
///    of these negative error values: LINEERR_INVALADDRESSID, LINEERR_INVALADDRESSSTATE, LINEERR_INVALAGENTACTIVITY,
///    LINEERR_INVALLINEHANDLE, LINEERR_INVALPOINTER, LINEERR_NOMEM, LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineSetAgentActivity(uint hLine, uint dwAddressID, uint dwActivityID);

///The <b>lineSetAgentGroup</b> function sets the agent groups into which the agent is logged into on a particular
///address.
///Params:
///    hLine = Handle to the line device.
///    dwAddressID = Identifier of the address for which the agent information is to be changed. An address identifier is permanently
///                  associated with an address; the identifier remains constant across operating system upgrades.
///    lpAgentGroupList = Pointer to a LINEAGENTGROUPLIST structure identifying the groups into which the current agent is to be logged in
///                       on the address. If the pointer is <b>NULL</b> or the number of groups in the indicated structure is zero, then
///                       the agent is logged out of any ACD groups into which it is currently logged in. The "Name" fields in the
///                       LINEAGENTGROUPENTRY items in the list are ignored for purposes of this function; the control of the logged-in
///                       groups is based on the group identifier values only.
///Returns:
///    Returns a positive request identifier if the asynchronous operation starts; otherwise, the function returns one
///    of these negative error values: LINEERR_INVALADDRESSID, LINEERR_INVALADDRESSSTATE, LINEERR_INVALAGENTGROUP,
///    LINEERR_INVALAGENTID, LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_INVALPASSWORD, LINEERR_INVALPOINTER,
///    LINEERR_NOMEM, LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineSetAgentGroup(uint hLine, uint dwAddressID, LINEAGENTGROUPLIST* lpAgentGroupList);

///The <b>lineSetAgentMeasurementPeriod</b> function sets the measurement period associated with a particular agent. It
///generates a LINE_PROXYREQUEST message to be sent to a registered proxy function handler, referencing a
///LINEPROXYREQUEST structure of type LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD.
///Params:
///    hLine = Handle to the line device.
///    hAgent = Identifier of the agent whose information is to be changed.
///    dwMeasurementPeriod = New measurement period (seconds). Must be greater than zero.
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineSetAgentMeasurementPeriod(uint hLine, uint hAgent, uint dwMeasurementPeriod);

///The <b>lineSetAgentSessionState</b> function sets the agent session state associated with a particular agent session
///handle. It generates a LINE_PROXYREQUEST message to be sent to a registered proxy function handler, referencing a
///LINEPROXYREQUEST structure of type LINEPROXYREQUEST_SETAGENTSESSIONSTATE.
///Params:
///    hLine = Handle to the line device.
///    hAgentSession = Identifier of the agent session whose information is to be changed.
///    dwAgentSessionState = New agent session state. Must be one of the LINEAGENTSESSIONSTATE_ constants or zero to leave the agent session
///                          state unchanged and modify only the next state.
///    dwNextAgentSessionState = Next agent session state. Must be one of the LINEAGENTSESSIONSTATE_ constants or zero.
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALAGENTSTATE, LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM,
///    LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineSetAgentSessionState(uint hLine, uint hAgentSession, uint dwAgentSessionState, 
                             uint dwNextAgentSessionState);

///The <b>lineSetAgentStateEx</b> function sets the agent state associated with a particular agent handle. It generates
///a LINE_PROXYREQUEST message to be sent to a registered proxy function handler, referencing a LINEPROXYREQUEST
///structure of type LINEPROXYREQUEST_SETAGENTSTATEEX.
///Params:
///    hLine = Handle to the line device.
///    hAgent = Identifier of the agent whose information is to be changed.
///    dwAgentState = New agent state. Must be one of the LINEAGENTSTATEEX_ constants, or zero to leave the agent state unchanged and
///                   modify only the next state.
///    dwNextAgentState = Next agent state. Must be one of the LINEAGENTSTATEEX_ constants or zero.
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALAGENTSTATE, LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM,
///    LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineSetAgentStateEx(uint hLine, uint hAgent, uint dwAgentState, uint dwNextAgentState);

///The <b>lineSetAgentState</b> function sets the agent state associated with a particular address.
///Params:
///    hLine = Handle to the line device.
///    dwAddressID = Identifier of the address for which the agent information is to be changed. An address identifier is permanently
///                  associated with an address; the identifier remains constant across operating system upgrades.
///    dwAgentState = New agent state. Must be one of the LINEAGENTSTATE_ Constants, or zero to leave the agent state unchanged and
///                   modify only the next state.
///    dwNextAgentState = The agent state that should be automatically set when the current call on the address becomes <i>idle</i>. For
///                       example, if it is known that after-call work must be performed, this field can be set to
///                       LINEAGENTSTATE_WORKAFTERCALL so that a new call is not assigned to the agent after the current call. Must be one
///                       of the LINEAGENTSTATE_ Constants, or zero to use the default next state configured for the agent.
///Returns:
///    Returns a positive request identifier if the asynchronous operation starts; otherwise, the function returns one
///    of these negative error values: LINEERR_INVALADDRESSID, LINEERR_INVALADDRESSSTATE, LINEERR_INVALAGENTSTATE,
///    LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineSetAgentState(uint hLine, uint dwAddressID, uint dwAgentState, uint dwNextAgentState);

///The <b>lineSetAppPriority</b> function enables an application to set its priority in the handoff priority list for a
///particular media type or Assisted Telephony request mode, or to remove itself from the priority list.
///Params:
///    lpszAppFilename = A pointer to a string that contains the application executable module filename, without the directory data. In
///                      TAPI version 2.0 or later, the parameter can specify a filename in either long or 8.3 filename format.
///    dwMediaMode = A media type for which the priority of the application is to be set. The value can be one or more of the
///                  LINEMEDIAMODE constants. The value zero should be used to set the application priority for Assisted Telephony
///                  requests.
///    lpExtensionID = A pointer to a structure of type LINEEXTENSIONID. This parameter is ignored.
///    dwRequestMode = The conditions for this parameter are, if the <i>dwMediaMode</i> parameter is zero, this parameter specifies the
///                    Assisted Telephony request mode for which priority is to be set. It must be LINEREQUESTMODE_MAKECALL. This
///                    parameter is ignored if <i>dwMediaMode</i> is nonzero.
///    lpszExtensionName = This parameter is ignored.
///    dwPriority = A parameter that indicates a new priority for the application. If the value 0 is passed, the application is
///                 removed from the priority list for the specified media or request mode; if it was not already present, no error
///                 is generated. If the value 1 is passed, the application is inserted as the highest-priority application for the
///                 media or request mode; it is removed from a lower-priority position, if already in the list. Any other value
///                 generates an error.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    <b>LINEERR_INIFILECORRUPT</b>, <b>LINEERR_INVALREQUESTMODE</b>, <b>LINEERR_INVALAPPNAME</b>,
///    <b>LINEERR_NOMEM</b>, <b>LINEERR_INVALMEDIAMODE</b>, <b>LINEERR_OPERATIONFAILED</b>, <b>LINEERR_INVALPARAM</b>,
///    <b>LINEERR_RESOURCEUNAVAIL</b>, <b>LINEERR_INVALPOINTER</b>.
///    
@DllImport("TAPI32")
int lineSetAppPriority(const(char)* lpszAppFilename, uint dwMediaMode, LINEEXTENSIONID* lpExtensionID, 
                       uint dwRequestMode, const(char)* lpszExtensionName, uint dwPriority);

///The <b>lineSetAppPriority</b> function enables an application to set its priority in the handoff priority list for a
///particular media type or Assisted Telephony request mode, or to remove itself from the priority list.
///Params:
///    lpszAppFilename = A pointer to a string that contains the application executable module filename, without the directory data. In
///                      TAPI version 2.0 or later, the parameter can specify a filename in either long or 8.3 filename format.
///    dwMediaMode = A media type for which the priority of the application is to be set. The value can be one or more of the
///                  LINEMEDIAMODE constants. The value zero should be used to set the application priority for Assisted Telephony
///                  requests.
///    lpExtensionID = A pointer to a structure of type LINEEXTENSIONID. This parameter is ignored.
///    dwRequestMode = The conditions for this parameter are, if the <i>dwMediaMode</i> parameter is zero, this parameter specifies the
///                    Assisted Telephony request mode for which priority is to be set. It must be LINEREQUESTMODE_MAKECALL. This
///                    parameter is ignored if <i>dwMediaMode</i> is nonzero.
///    lpszExtensionName = This parameter is ignored.
///    dwPriority = A parameter that indicates a new priority for the application. If the value 0 is passed, the application is
///                 removed from the priority list for the specified media or request mode; if it was not already present, no error
///                 is generated. If the value 1 is passed, the application is inserted as the highest-priority application for the
///                 media or request mode; it is removed from a lower-priority position, if already in the list. Any other value
///                 generates an error.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    <b>LINEERR_INIFILECORRUPT</b>, <b>LINEERR_INVALREQUESTMODE</b>, <b>LINEERR_INVALAPPNAME</b>,
///    <b>LINEERR_NOMEM</b>, <b>LINEERR_INVALMEDIAMODE</b>, <b>LINEERR_OPERATIONFAILED</b>, <b>LINEERR_INVALPARAM</b>,
///    <b>LINEERR_RESOURCEUNAVAIL</b>, <b>LINEERR_INVALPOINTER</b>.
///    
@DllImport("TAPI32")
int lineSetAppPriorityA(const(char)* lpszAppFilename, uint dwMediaMode, LINEEXTENSIONID* lpExtensionID, 
                        uint dwRequestMode, const(char)* lpszExtensionName, uint dwPriority);

///The <b>lineSetAppPriority</b> function enables an application to set its priority in the handoff priority list for a
///particular media type or Assisted Telephony request mode, or to remove itself from the priority list.
///Params:
///    lpszAppFilename = A pointer to a string that contains the application executable module filename, without the directory data. In
///                      TAPI version 2.0 or later, the parameter can specify a filename in either long or 8.3 filename format.
///    dwMediaMode = A media type for which the priority of the application is to be set. The value can be one or more of the
///                  LINEMEDIAMODE constants. The value zero should be used to set the application priority for Assisted Telephony
///                  requests.
///    lpExtensionID = A pointer to a structure of type LINEEXTENSIONID. This parameter is ignored.
///    dwRequestMode = The conditions for this parameter are, if the <i>dwMediaMode</i> parameter is zero, this parameter specifies the
///                    Assisted Telephony request mode for which priority is to be set. It must be LINEREQUESTMODE_MAKECALL. This
///                    parameter is ignored if <i>dwMediaMode</i> is nonzero.
///    lpszExtensionName = This parameter is ignored.
///    dwPriority = A parameter that indicates a new priority for the application. If the value 0 is passed, the application is
///                 removed from the priority list for the specified media or request mode; if it was not already present, no error
///                 is generated. If the value 1 is passed, the application is inserted as the highest-priority application for the
///                 media or request mode; it is removed from a lower-priority position, if already in the list. Any other value
///                 generates an error.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    <b>LINEERR_INIFILECORRUPT</b>, <b>LINEERR_INVALREQUESTMODE</b>, <b>LINEERR_INVALAPPNAME</b>,
///    <b>LINEERR_NOMEM</b>, <b>LINEERR_INVALMEDIAMODE</b>, <b>LINEERR_OPERATIONFAILED</b>, <b>LINEERR_INVALPARAM</b>,
///    <b>LINEERR_RESOURCEUNAVAIL</b>, <b>LINEERR_INVALPOINTER</b>.
///    
@DllImport("TAPI32")
int lineSetAppPriorityW(const(wchar)* lpszAppFilename, uint dwMediaMode, LINEEXTENSIONID* lpExtensionID, 
                        uint dwRequestMode, const(wchar)* lpszExtensionName, uint dwPriority);

///The <b>lineSetAppSpecific</b> function enables an application to set the application-specific field of the specified
///call's call-information record.
///Params:
///    hCall = Handle to the call whose application-specific field needs to be set. The application must be an owner of the
///            call. The call state of <i>hCall</i> can be any state.
///    dwAppSpecific = New content of the <b>dwAppSpecific</b> member for the call's LINECALLINFO structure. This value is not
///                    interpreted by the Telephony API.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_NOMEM, LINEERR_UNINITIALIZED, LINEERR_NOTOWNER,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_OPERATIONFAILED.
///    
@DllImport("TAPI32")
int lineSetAppSpecific(uint hCall, uint dwAppSpecific);

///The <b>lineSetCallData</b> function sets the <b>CallData</b> member in LINECALLINFO. Depending on the service
///provider implementation, the <b>CallData</b> member can be propagated to all applications having handles to the call,
///including those on other machines (through the server), and can travel with the call when it is transferred.
///Params:
///    hCall = Handle to the call. The application must have OWNER privilege.
///    lpCallData = Address of the data to be copied to the <b>CallData</b> member in LINECALLINFO, replacing any existing data. For
///                 more information, see the call data topic.
///    dwSize = Number of bytes of data to be copied. A value of 0 causes any existing data to be removed. <div
///             class="alert"><b>Note</b> If <i>lpCallData</i> is a pointer to a string, the size must include the null
///             terminator.</div> <div> </div>
///Returns:
///    Returns a positive request identifier if the asynchronous operation starts; otherwise, the function returns one
///    of these negative error values: LINEERR_INVALCALLHANDLE, LINEERR_INVALCALLSTATE, LINEERR_INVALPARAM,
///    LINEERR_INVALPOINTER, LINEERR_NOMEM, LINEERR_NOTOWNER, LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineSetCallData(uint hCall, void* lpCallData, uint dwSize);

///The <b>lineSetCallParams</b> function allows an application to change bearer mode and/or the rate parameters of an
///existing call.
///Params:
///    hCall = Handle to the call whose parameters are to be changed. The application must be an owner of the call. The call
///            state of <i>hCall</i> can be any state except <i>idle</i> or <i>disconnected</i>.
///    dwBearerMode = New bearer mode for the call. This parameter uses one and only one of the LINEBEARERMODE_ Constants.
///    dwMinRate = Lower bound for the call's new data rate. The application can accept a new rate as low as this one.
///    dwMaxRate = Upper bound for the call's new data rate. This is the maximum data rate the application can accept. If an exact
///                data rate is required, <i>dwMinRate</i> and <i>dwMaxRate</i> should be equal.
///    lpDialParams = Pointer to the new dial parameters for the call, of type LINEDIALPARAMS. This parameter can be left <b>NULL</b>
///                   if the call's current dialing parameters are to be used.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_BEARERMODEUNAVAIL, LINEERR_NOTOWNER, LINEERR_INVALBEARERMODE, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALCALLSTATE, LINEERR_RATEUNAVAIL,
///    LINEERR_INVALPOINTER, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALRATE, LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineSetCallParams(uint hCall, uint dwBearerMode, uint dwMinRate, uint dwMaxRate, 
                      const(LINEDIALPARAMS)* lpDialParams);

///The <b>lineSetCallPrivilege</b> function sets the application's privilege to the specified privilege.
///Params:
///    hCall = Handle to the call whose privilege is to be set. The call state of <i>hCall</i> can be any state.
///    dwCallPrivilege = Required privilege for the specified call. This parameter uses one and only one of the LINECALLPRIVILEGE_
///                      Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALCALLSTATE, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_INVALCALLPRIVILEGE, LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineSetCallPrivilege(uint hCall, uint dwCallPrivilege);

///The <b>lineSetCallQualityOfService</b> function allows the application to attempt to change the quality of service
///parameters (reserved capacity and performance guarantees) for an existing call. Except for basic parameter
///validation, this is a straight pass-through to a service provider.
///Params:
///    hCall = Handle to the call. The application must have OWNER privilege.
///    lpSendingFlowspec = Pointer to memory containing a FLOWSPEC structure followed by provider-specific data. The provider-specific
///                        portion following the <b>FLOWSPEC</b> structure must not contain pointers to other blocks of memory in the
///                        application process, because TAPI will not know how to marshal the data pointed to by the private pointer(s) and
///                        convey it through interprocess communication to the service provider.
///    dwSendingFlowspecSize = Total size of the FLOWSPEC structure and accompanying provider-specific data, in bytes. This is equivalent to
///                            what would have been stored in <b>SendingFlowspec</b> in a QOS structure.
///    lpReceivingFlowspec = Pointer to memory containing a FLOWSPEC structure followed by provider-specific data. The provider-specific
///                          portion following the FLOWSPEC structure must not contain pointers to other blocks of memory in the application
///                          process, because TAPI will not know how to marshal the data pointed to by the private pointer(s) and convey it
///                          through interprocess communication to the service provider.
///    dwReceivingFlowspecSize = Total size of the FLOWSPEC and accompanying provider-specific data, in bytes. This is equivalent to what would
///                              have been stored in <b>ReceivingFlowspec</b> in a QOS structure.
///Returns:
///    Returns a positive request identifier if the asynchronous operation starts; otherwise, the function returns one
///    of these negative error values: LINEERR_INVALCALLHANDLE, LINEERR_INVALCALLSTATE, LINEERR_INVALPARAM,
///    LINEERR_INVALPOINTER, LINEERR_INVALRATE, LINEERR_NOMEM, LINEERR_NOTOWNER, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_OPERATIONFAILED, LINEERR_RATEUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineSetCallQualityOfService(uint hCall, void* lpSendingFlowspec, uint dwSendingFlowspecSize, 
                                void* lpReceivingFlowspec, uint dwReceivingFlowspecSize);

///The <b>lineSetCallTreatment</b> function sets the sounds a party on a call that is unanswered or on hold hears.
///Except for basic parameter validation, it is a straight pass-through by TAPI to the service provider.
///Params:
///    hCall = Handle to the call. The application must have OWNER privilege.
///    dwTreatment = One of the call treatments supported on the address on which the call appears, as indicated by LINEADDRESSCAPS.
///                  LINEERR_INVALPARAM is returned if the specified treatment is not supported.
///Returns:
///    Returns a positive request identifier if the asynchronous operation starts; otherwise, the function returns one
///    of these negative error values: LINEERR_INVALCALLHANDLE, LINEERR_INVALCALLSTATE, LINEERR_INVALPARAM,
///    LINEERR_NOMEM, LINEERR_NOTOWNER, LINEERR_OPERATIONFAILED, LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineSetCallTreatment(uint hCall, uint dwTreatment);

///The <b>lineSetCurrentLocation</b> function sets the location used as the context for address translation.
///Params:
///    hLineApp = Application handle returned by lineInitializeEx. If an application has not yet called the <b>lineInitializeEx</b>
///               function, it can set the <i>hLineApp</i> parameter to zero.
///    dwLocation = New value for the CurrentLocation entry in the [Locations] section in the registry. It must contain a valid
///                 permanent identifier of a Location entry in the [Locations] section, as obtained from lineGetTranslateCaps. If it
///                 is valid, the CurrentLocation entry is updated.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INIFILECORRUPT, LINEERR_NOMEM, LINEERR_INVALAPPHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALLOCATION,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_NODRIVER, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineSetCurrentLocation(uint hLineApp, uint dwLocation);

///The <b>lineSetDevConfig</b> function allows the application to restore the configuration of a media stream device on
///a line device to a setup previously obtained using lineGetDevConfig. For example, the contents of this structure
///could specify data rate, character format, modulation schemes, and error control protocol settings for a "datamodem"
///media device associated with the line.
///Params:
///    dwDeviceID = Identifier of the line device to be configured.
///    lpDeviceConfig = Pointer to the opaque configuration data structure that was returned by lineGetDevConfig in the variable portion
///                     of the VARSTRING structure.
///    dwSize = Number of bytes in the structure pointed to by <i>lpDeviceConfig</i>. This value is returned in the
///             <b>dwStringSize</b> member in the VARSTRING structure returned by lineGetDevConfig.
///    lpszDeviceClass = Pointer to a null-terminated string that specifies the device class of the device whose configuration is to be
///                      set. Valid device class strings are the same as those specified for the lineGetID function.
///Returns:
///    Returns zero if the function succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NODRIVER, LINEERR_INVALDEVICECLASS, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALPARAM, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALLINESTATE,
///    LINEERR_UNINITIALIZED, LINEERR_NOMEM, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineSetDevConfig(uint dwDeviceID, const(void)* lpDeviceConfig, uint dwSize, const(char)* lpszDeviceClass);

///The <b>lineSetDevConfig</b> function allows the application to restore the configuration of a media stream device on
///a line device to a setup previously obtained using lineGetDevConfig. For example, the contents of this structure
///could specify data rate, character format, modulation schemes, and error control protocol settings for a "datamodem"
///media device associated with the line.
///Params:
///    dwDeviceID = Identifier of the line device to be configured.
///    lpDeviceConfig = Pointer to the opaque configuration data structure that was returned by lineGetDevConfig in the variable portion
///                     of the VARSTRING structure.
///    dwSize = Number of bytes in the structure pointed to by <i>lpDeviceConfig</i>. This value is returned in the
///             <b>dwStringSize</b> member in the VARSTRING structure returned by lineGetDevConfig.
///    lpszDeviceClass = Pointer to a null-terminated string that specifies the device class of the device whose configuration is to be
///                      set. Valid device class strings are the same as those specified for the lineGetID function.
///Returns:
///    Returns zero if the function succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NODRIVER, LINEERR_INVALDEVICECLASS, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALPARAM, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALLINESTATE,
///    LINEERR_UNINITIALIZED, LINEERR_NOMEM, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineSetDevConfigA(uint dwDeviceID, const(void)* lpDeviceConfig, uint dwSize, const(char)* lpszDeviceClass);

///The <b>lineSetDevConfig</b> function allows the application to restore the configuration of a media stream device on
///a line device to a setup previously obtained using lineGetDevConfig. For example, the contents of this structure
///could specify data rate, character format, modulation schemes, and error control protocol settings for a "datamodem"
///media device associated with the line.
///Params:
///    dwDeviceID = Identifier of the line device to be configured.
///    lpDeviceConfig = Pointer to the opaque configuration data structure that was returned by lineGetDevConfig in the variable portion
///                     of the VARSTRING structure.
///    dwSize = Number of bytes in the structure pointed to by <i>lpDeviceConfig</i>. This value is returned in the
///             <b>dwStringSize</b> member in the VARSTRING structure returned by lineGetDevConfig.
///    lpszDeviceClass = Pointer to a null-terminated string that specifies the device class of the device whose configuration is to be
///                      set. Valid device class strings are the same as those specified for the lineGetID function.
///Returns:
///    Returns zero if the function succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NODRIVER, LINEERR_INVALDEVICECLASS, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALPOINTER,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALPARAM, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALLINESTATE,
///    LINEERR_UNINITIALIZED, LINEERR_NOMEM, LINEERR_NODEVICE.
///    
@DllImport("TAPI32")
int lineSetDevConfigW(uint dwDeviceID, const(void)* lpDeviceConfig, uint dwSize, const(wchar)* lpszDeviceClass);

///The <b>lineSetLineDevStatus</b> function sets the line device status. Except for basic parameter validation, it is a
///straight pass-through to the service provider. The service provider sends a LINE_LINEDEVSTATE message to inform
///applications of the new state, when set; TAPI does not synthesize these messages.
///Params:
///    hLine = Handle to the line device.
///    dwStatusToChange = One or more of the LINEDEVSTATUSFLAGS_ Constants.
///    fStatus = <b>TRUE</b> (1) to turn on the indicated status bit(s), <b>FALSE</b> (0) to turn off.
@DllImport("TAPI32")
int lineSetLineDevStatus(uint hLine, uint dwStatusToChange, uint fStatus);

///The <b>lineSetMediaControl</b> function enables and disables control actions on the media stream associated with the
///specified line, address, or call. Media control actions can be triggered by the detection of specified digits, media
///types, custom tones, and call states.
///Params:
///    hLine = Handle to an open line device.
///    dwAddressID = Address identifier on the given open line device. An address identifier is permanently associated with an
///                  address; the identifier remains constant across operating system upgrades.
///    hCall = Handle to a call. The application must be an owner of the call. The call state of <i>hCall</i> can be any state.
///    dwSelect = Whether the media control requested is associated with a single call, is the default for all calls on an address,
///               or is the default for all calls on a line. This parameter one and only one of the LINECALLSELECT_ Constants.
///    lpDigitList = Pointer to the array that contains the digits that are to trigger media control actions, of type
///                  LINEMEDIACONTROLDIGIT. Each time a digit in the digit list is detected, the specified media control action is
///                  carried out on the call's media stream. Valid digits for pulse mode are '0' through '9'. Valid digits for DTMF
///                  mode are '0' through '9', 'A', 'B', 'C', 'D', '*', '
///    dwDigitNumEntries = Number of entries in the <i>lpDigitList</i>.
///    lpMediaList = Pointer to an array with entries of type LINEMEDIACONTROLMEDIA. The array has <i>dwMediaNumEntries</i> entries.
///                  Each entry contains a media type to be monitored, media-type specific information (such as duration), and a media
///                  control field. If a media type in the list is detected, the corresponding media control action is performed on
///                  the call's media stream.
///    dwMediaNumEntries = Number of entries in <i>lpMediaList</i>.
///    lpToneList = Pointer to an array with entries of type LINEMEDIACONTROLTONE. The array has <i>dwToneNumEntries</i> entries.
///                 Each entry contains a description of a tone to be monitored, duration of the tone, and a media-control field. If
///                 a tone in the list is detected, the corresponding media control action is performed on the call's media stream.
///    dwToneNumEntries = Number of entries in <i>lpToneList</i>.
///    lpCallStateList = Pointer to an array with entries of type LINEMEDIACONTROLCALLSTATE. The array has <i>dwCallStateNumEntries</i>
///                      entries. Each entry contains a call state and a media control action. Whenever the given call transitions into
///                      one of the call states in the list, the corresponding media control action is invoked.
///    dwCallStateNumEntries = Number of entries in <i>lpCallStateList</i>.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALADDRESSID, LINEERR_NOMEM, LINEERR_INVALCALLHANDLE, LINEERR_NOTOWNER, LINEERR_INVALCALLSELECT,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSTATELIST, LINEERR_OPERATIONFAILED, LINEERR_INVALDIGITLIST,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALLINEHANDLE, LINEERR_UNINITIALIZED, LINEERR_INVALMEDIALIST,
///    LINEERR_INVALPOINTER, LINEERR_INVALTONELIST.
///    
@DllImport("TAPI32")
int lineSetMediaControl(uint hLine, uint dwAddressID, uint hCall, uint dwSelect, 
                        const(LINEMEDIACONTROLDIGIT)* lpDigitList, uint dwDigitNumEntries, 
                        const(LINEMEDIACONTROLMEDIA)* lpMediaList, uint dwMediaNumEntries, 
                        const(LINEMEDIACONTROLTONE)* lpToneList, uint dwToneNumEntries, 
                        const(LINEMEDIACONTROLCALLSTATE)* lpCallStateList, uint dwCallStateNumEntries);

///The <b>lineSetMediaMode</b> function sets the media type(s) of the specified call in its LINECALLINFO structure. For
///more information, see ITLegacyCallMediaControl::SetMediaType.
///Params:
///    hCall = Handle to the call whose media type is to be changed. The application must be an owner of the call. The call
///            state of <i>hCall</i> can be any state.
///    dwMediaModes = New media type(s) for the call. This parameter uses the LINEMEDIAMODE_ Constants. As long as the UNKNOWN media
///                   type flag is set, other media type flags may be set as well. This is used to identify a call's media type as not
///                   fully determined, but narrowed down to one of a small set of specified media types. If the UNKNOWN flag is not
///                   set, only a single media type can be specified.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALMEDIAMODE, LINEERR_RESOURCEUNAVAIL, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED, LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineSetMediaMode(uint hCall, uint dwMediaModes);

///The <b>lineSetQueueMeasurementPeriod</b> function sets the measurement period associated with a particular queue. It
///generates a LINE_PROXYREQUEST message to be sent to a registered proxy function handler, referencing a
///LINEPROXYREQUEST structure of type LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD.
///Params:
///    hLine = Handle to the line device.
///    dwQueueID = Identifier of the queue whose information is to be changed.
///    dwMeasurementPeriod = New measurement period (seconds). Must be greater than zero.
///Returns:
///    Returns a request identifier if the asynchronous operation starts; otherwise, the function returns one of the
///    following error values: LINEERR_INVALLINEHANDLE, LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_RESOURCEUNAVAIL, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineSetQueueMeasurementPeriod(uint hLine, uint dwQueueID, uint dwMeasurementPeriod);

///The <b>lineSetNumRings</b> function sets the number of rings that must occur before an incoming call is answered.
///This function can be used to implement a toll-saver-style function. It allows multiple independent applications to
///each register the number of rings. The function lineGetNumRings returns the minimum number of rings requested. It can
///be used by the application that answers incoming calls to determine the number of rings it should wait before
///answering the call.
///Params:
///    hLine = Handle to the open line device.
///    dwAddressID = Address on the line device. An address identifier is permanently associated with an address; the identifier
///                  remains constant across operating system upgrades.
///    dwNumRings = Number of rings before a call should be answered in order to honor the toll-saver requests from all applications.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALADDRESSID, LINEERR_RESOURCEUNAVAIL, LINEERR_NOMEM,
///    LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineSetNumRings(uint hLine, uint dwAddressID, uint dwNumRings);

///The <b>lineSetStatusMessages</b> function enables an application to specify which notification messages to receive
///for events related to status changes for the specified line or any of its addresses.
///Params:
///    hLine = Handle to the line device.
///    dwLineStates = Bit array that identifies for which line-device status changes a message is to be sent to the application. This
///                   parameter uses one or more of the LINEDEVSTATE_ Constants.
///    dwAddressStates = Bit array that identifies for which address status changes a message is to be sent to the application. This
///                      parameter uses one or more of the LINEADDRESSSTATE_ Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALADDRESSSTATE, LINEERR_OPERATIONFAILED, LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_INVALLINESTATE, LINEERR_UNINITIALIZED, LINEERR_NOMEM, LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineSetStatusMessages(uint hLine, uint dwLineStates, uint dwAddressStates);

///The <b>lineSetTerminal</b> function enables an application to specify which terminal information related to the
///specified line, address, or call is to be routed. The <b>lineSetTerminal</b> function can be used while calls are in
///progress on the line to allow an application to route these events to different devices as required.
///Params:
///    hLine = Handle to an open line device.
///    dwAddressID = Address on the given open line device. An address identifier is permanently associated with an address; the
///                  identifier remains constant across operating system upgrades.
///    hCall = Handle to a call. The call state of <i>hCall</i> can be any state, if <i>dwSelect</i> is CALL.
///    dwSelect = Whether the terminal setting is requested for the line, the address, or just the specified call. If line or
///               address is specified, events either apply to the line or address itself or serve as a default initial setting for
///               all new calls on the line or address. This parameter uses one of the LINECALLSELECT_ Constants.
///    dwTerminalModes = Class of low-level events to be routed to the given terminal. This parameter uses one or more of the
///                      LINETERMMODE_ Constants.
///    dwTerminalID = Device identifier of the terminal device where the given events are to be routed. Terminal identifiers are small
///                   integers in the range of zero to one less than <b>dwNumTerminals</b>, where <b>dwNumTerminals</b>, and the
///                   terminal modes each terminal is capable of handling, are returned by lineGetDevCaps. These terminal identifiers
///                   have no relation to other device identifiers and are defined by the service provider using device capabilities.
///    bEnable = If <b>TRUE</b>, <i>dwTerminalID</i> is valid and the specified event classes are routed to or from that terminal.
///              If <b>FALSE</b>, these events are not routed to or from the terminal device with identifier equal to
///              <i>dwTerminalID</i>.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_INVALADDRESSID,
///    LINEERR_NOMEM, LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSELECT,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALTERMINALID,
///    LINEERR_UNINITIALIZED, LINEERR_INVALTERMINALMODE.
///    
@DllImport("TAPI32")
int lineSetTerminal(uint hLine, uint dwAddressID, uint hCall, uint dwSelect, uint dwTerminalModes, 
                    uint dwTerminalID, uint bEnable);

///The <b>lineSetTollList</b> function manipulates the toll list.
///Params:
///    hLineApp = Application handle returned by lineInitializeEx. If an application has not yet called the <b>lineInitializeEx</b>
///               function, it can set the <i>hLineApp</i> parameter to zero.
///    dwDeviceID = Device identifier for the line device upon which the call is intended to be dialed, so that variations in dialing
///                 procedures on different lines can be applied to the translation process.
///    lpszAddressIn = TBD
///    dwTollListOption = Toll list operation to be performed. This parameter uses one and only one of the LINETOLLLISTOPTION_ Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NODRIVER, LINEERR_INVALAPPHANDLE, LINEERR_NOMEM, LINEERR_INVALADDRESS,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALPARAM, LINEERR_RESOURCEUNAVAIL, LINEERR_INIFILECORRUPT,
///    LINEERR_UNINITIALIZED, LINEERR_INVALLOCATION.
///    
@DllImport("TAPI32")
int lineSetTollList(uint hLineApp, uint dwDeviceID, const(char)* lpszAddressIn, uint dwTollListOption);

///The <b>lineSetTollList</b> function manipulates the toll list.
///Params:
///    hLineApp = Application handle returned by lineInitializeEx. If an application has not yet called the <b>lineInitializeEx</b>
///               function, it can set the <i>hLineApp</i> parameter to zero.
///    dwDeviceID = Device identifier for the line device upon which the call is intended to be dialed, so that variations in dialing
///                 procedures on different lines can be applied to the translation process.
///    lpszAddressIn = TBD
///    dwTollListOption = Toll list operation to be performed. This parameter uses one and only one of the LINETOLLLISTOPTION_ Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NODRIVER, LINEERR_INVALAPPHANDLE, LINEERR_NOMEM, LINEERR_INVALADDRESS,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALPARAM, LINEERR_RESOURCEUNAVAIL, LINEERR_INIFILECORRUPT,
///    LINEERR_UNINITIALIZED, LINEERR_INVALLOCATION.
///    
@DllImport("TAPI32")
int lineSetTollListA(uint hLineApp, uint dwDeviceID, const(char)* lpszAddressIn, uint dwTollListOption);

///The <b>lineSetTollList</b> function manipulates the toll list.
///Params:
///    hLineApp = Application handle returned by lineInitializeEx. If an application has not yet called the <b>lineInitializeEx</b>
///               function, it can set the <i>hLineApp</i> parameter to zero.
///    dwDeviceID = Device identifier for the line device upon which the call is intended to be dialed, so that variations in dialing
///                 procedures on different lines can be applied to the translation process.
///    lpszAddressInW = Pointer to a <b>null</b>-terminated string containing the address from which the prefix information is to be
///                     extracted for processing. This parameter must not be <b>NULL</b>, and it must be in the canonical address format.
///    dwTollListOption = Toll list operation to be performed. This parameter uses one and only one of the LINETOLLLISTOPTION_ Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_NODRIVER, LINEERR_INVALAPPHANDLE, LINEERR_NOMEM, LINEERR_INVALADDRESS,
///    LINEERR_OPERATIONFAILED, LINEERR_INVALPARAM, LINEERR_RESOURCEUNAVAIL, LINEERR_INIFILECORRUPT,
///    LINEERR_UNINITIALIZED, LINEERR_INVALLOCATION.
///    
@DllImport("TAPI32")
int lineSetTollListW(uint hLineApp, uint dwDeviceID, const(wchar)* lpszAddressInW, uint dwTollListOption);

///The <b>lineSetupConference</b> function sets up a conference call for the addition of the third party.
///Params:
///    hCall = Handle to the Initial call that identifies the first party of a conference call. In some environments (as
///            described in device capabilities), a call must exist to start a conference call, and the application must be an
///            owner of this call. In other telephony environments, no call initially exists, <i>hCall</i> must be left
///            <b>NULL</b>, and <i>hLine</i> must be specified to identify the line on which the conference call is to be
///            initiated. The call state of <i>hCall</i> must be <i>connected</i>.
///    hLine = Handle to the line. This handle is used to identify the line device on which to originate the conference call if
///            <i>hCall</i> is <b>NULL</b>. The <i>hLine</i> parameter is ignored if <i>hCall</i> is non-<b>NULL</b>.
///    lphConfCall = Pointer to an HCALL handle. This location is then loaded with a handle identifying the newly created conference
///                  call. The application is the initial sole owner of this call. The call state of <i>hConfCall</i> is not
///                  applicable.
///    lphConsultCall = Pointer to an HCALL handle. When setting up a call for the addition of a new party, a new temporary call
///                     (consultation call) is automatically allocated. Initially, the application is the sole owner for this call.
///    dwNumParties = Expected number of parties in the conference call. This number is passed to the service provider. The service
///                   provider is free to do as it pleases with this number: ignore it, use it as a hint to allocate the right size
///                   conference bridge inside the switch, and so on.
///    lpCallParams = Pointer to a LINECALLPARAMS structure containing call parameters to use when establishing the consultation call.
///                   This parameter can be set to <b>NULL</b> if no special call setup parameters are desired.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_BEARERMODEUNAVAIL, LINEERR_UNINITIALIZED, LINEERR_CALLUNAVAIL, LINEERR_INVALMEDIAMODE,
///    LINEERR_CONFERENCEFULL, LINEERR_INVALPOINTER, LINEERR_INUSE, LINEERR_INVALRATE, LINEERR_INVALADDRESSMODE,
///    LINEERR_NOMEM, LINEERR_INVALBEARERMODE, LINEERR_NOTOWNER, LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALCALLSTATE, LINEERR_OPERATIONFAILED, LINEERR_INVALCALLPARAMS, LINEERR_RATEUNAVAIL,
///    LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALLINESTATE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_USERUSERINFOTOOBIG.
///    
@DllImport("TAPI32")
int lineSetupConference(uint hCall, uint hLine, uint* lphConfCall, uint* lphConsultCall, uint dwNumParties, 
                        const(LINECALLPARAMS)* lpCallParams);

///The <b>lineSetupConference</b> function sets up a conference call for the addition of the third party.
///Params:
///    hCall = Handle to the Initial call that identifies the first party of a conference call. In some environments (as
///            described in device capabilities), a call must exist to start a conference call, and the application must be an
///            owner of this call. In other telephony environments, no call initially exists, <i>hCall</i> must be left
///            <b>NULL</b>, and <i>hLine</i> must be specified to identify the line on which the conference call is to be
///            initiated. The call state of <i>hCall</i> must be <i>connected</i>.
///    hLine = Handle to the line. This handle is used to identify the line device on which to originate the conference call if
///            <i>hCall</i> is <b>NULL</b>. The <i>hLine</i> parameter is ignored if <i>hCall</i> is non-<b>NULL</b>.
///    lphConfCall = Pointer to an HCALL handle. This location is then loaded with a handle identifying the newly created conference
///                  call. The application is the initial sole owner of this call. The call state of <i>hConfCall</i> is not
///                  applicable.
///    lphConsultCall = Pointer to an HCALL handle. When setting up a call for the addition of a new party, a new temporary call
///                     (consultation call) is automatically allocated. Initially, the application is the sole owner for this call.
///    dwNumParties = Expected number of parties in the conference call. This number is passed to the service provider. The service
///                   provider is free to do as it pleases with this number: ignore it, use it as a hint to allocate the right size
///                   conference bridge inside the switch, and so on.
///    lpCallParams = Pointer to a LINECALLPARAMS structure containing call parameters to use when establishing the consultation call.
///                   This parameter can be set to <b>NULL</b> if no special call setup parameters are desired.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_BEARERMODEUNAVAIL, LINEERR_UNINITIALIZED, LINEERR_CALLUNAVAIL, LINEERR_INVALMEDIAMODE,
///    LINEERR_CONFERENCEFULL, LINEERR_INVALPOINTER, LINEERR_INUSE, LINEERR_INVALRATE, LINEERR_INVALADDRESSMODE,
///    LINEERR_NOMEM, LINEERR_INVALBEARERMODE, LINEERR_NOTOWNER, LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALCALLSTATE, LINEERR_OPERATIONFAILED, LINEERR_INVALCALLPARAMS, LINEERR_RATEUNAVAIL,
///    LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALLINESTATE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_USERUSERINFOTOOBIG.
///    
@DllImport("TAPI32")
int lineSetupConferenceA(uint hCall, uint hLine, uint* lphConfCall, uint* lphConsultCall, uint dwNumParties, 
                         const(LINECALLPARAMS)* lpCallParams);

///The <b>lineSetupConference</b> function sets up a conference call for the addition of the third party.
///Params:
///    hCall = Handle to the Initial call that identifies the first party of a conference call. In some environments (as
///            described in device capabilities), a call must exist to start a conference call, and the application must be an
///            owner of this call. In other telephony environments, no call initially exists, <i>hCall</i> must be left
///            <b>NULL</b>, and <i>hLine</i> must be specified to identify the line on which the conference call is to be
///            initiated. The call state of <i>hCall</i> must be <i>connected</i>.
///    hLine = Handle to the line. This handle is used to identify the line device on which to originate the conference call if
///            <i>hCall</i> is <b>NULL</b>. The <i>hLine</i> parameter is ignored if <i>hCall</i> is non-<b>NULL</b>.
///    lphConfCall = Pointer to an HCALL handle. This location is then loaded with a handle identifying the newly created conference
///                  call. The application is the initial sole owner of this call. The call state of <i>hConfCall</i> is not
///                  applicable.
///    lphConsultCall = Pointer to an HCALL handle. When setting up a call for the addition of a new party, a new temporary call
///                     (consultation call) is automatically allocated. Initially, the application is the sole owner for this call.
///    dwNumParties = Expected number of parties in the conference call. This number is passed to the service provider. The service
///                   provider is free to do as it pleases with this number: ignore it, use it as a hint to allocate the right size
///                   conference bridge inside the switch, and so on.
///    lpCallParams = Pointer to a LINECALLPARAMS structure containing call parameters to use when establishing the consultation call.
///                   This parameter can be set to <b>NULL</b> if no special call setup parameters are desired.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_BEARERMODEUNAVAIL, LINEERR_UNINITIALIZED, LINEERR_CALLUNAVAIL, LINEERR_INVALMEDIAMODE,
///    LINEERR_CONFERENCEFULL, LINEERR_INVALPOINTER, LINEERR_INUSE, LINEERR_INVALRATE, LINEERR_INVALADDRESSMODE,
///    LINEERR_NOMEM, LINEERR_INVALBEARERMODE, LINEERR_NOTOWNER, LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL,
///    LINEERR_INVALCALLSTATE, LINEERR_OPERATIONFAILED, LINEERR_INVALCALLPARAMS, LINEERR_RATEUNAVAIL,
///    LINEERR_INVALLINEHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_INVALLINESTATE, LINEERR_STRUCTURETOOSMALL,
///    LINEERR_USERUSERINFOTOOBIG.
///    
@DllImport("TAPI32")
int lineSetupConferenceW(uint hCall, uint hLine, uint* lphConfCall, uint* lphConsultCall, uint dwNumParties, 
                         const(LINECALLPARAMS)* lpCallParams);

///The <b>lineSetupTransfer</b> function initiates a transfer of the call specified by the <i>hCall</i> parameter. It
///establishes a consultation call, <i>lphConsultCall</i>, on which the party can be dialed that can become the
///destination of the transfer. The application acquires owner privilege to the <i>lphConsultCall</i> parameter.
///Params:
///    hCall = Handle to the call to be transferred. The application must be an owner of the call. The call state of
///            <i>hCall</i> must be <i>connected</i>.
///    lphConsultCall = Pointer to an <i>hCall</i> handle. This location is then loaded with a handle identifying the temporary
///                     consultation call. When setting up a call for transfer, a consultation call is automatically allocated that
///                     enables lineDial to dial the address associated with the new transfer destination of the call. The originating
///                     party can carry on a conversation over this consultation call prior to completing the transfer. The call state of
///                     <i>hConsultCall</i> is not applicable. This transfer procedure may not be valid for some line devices. The
///                     application may need to ignore the new consultation call and unhold an existing held call (using lineUnhold) to
///                     identify the destination of the transfer. On switches that support cross-address call transfer, the consultation
///                     call can exist on a different address than the call to be transferred. It may also be necessary that the
///                     consultation call be set up as an entirely new call, by lineMakeCall, to the destination of the transfer. Which
///                     forms of transfer are available are specified in the call's address capabilities.
///    lpCallParams = Pointer to a LINECALLPARAMS structure containing the call parameters to use when establishing the consultation
///                   call. This parameter can be set to <b>NULL</b> if no special call setup parameters are desired.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_BEARERMODEUNAVAIL, LINEERR_INVALRATE, LINEERR_CALLUNAVAIL, LINEERR_NOMEM, LINEERR_INUSE,
///    LINEERR_NOTOWNER, LINEERR_INVALADDRESSMODE, LINEERR_OPERATIONFAILED, LINEERR_INVALBEARERMODE,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLHANDLE, LINEERR_RATEUNAVAIL, LINEERR_INVALCALLPARAMS,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALCALLSTATE, LINEERR_STRUCTURETOOSMALL, LINEERR_INVALLINESTATE,
///    LINEERR_UNINITIALIZED, LINEERR_INVALMEDIAMODE, LINEERR_USERUSERINFOTOOBIG, LINEERR_INVALPOINTER.
///    
@DllImport("TAPI32")
int lineSetupTransfer(uint hCall, uint* lphConsultCall, const(LINECALLPARAMS)* lpCallParams);

///The <b>lineSetupTransfer</b> function initiates a transfer of the call specified by the <i>hCall</i> parameter. It
///establishes a consultation call, <i>lphConsultCall</i>, on which the party can be dialed that can become the
///destination of the transfer. The application acquires owner privilege to the <i>lphConsultCall</i> parameter.
///Params:
///    hCall = Handle to the call to be transferred. The application must be an owner of the call. The call state of
///            <i>hCall</i> must be <i>connected</i>.
///    lphConsultCall = Pointer to an <i>hCall</i> handle. This location is then loaded with a handle identifying the temporary
///                     consultation call. When setting up a call for transfer, a consultation call is automatically allocated that
///                     enables lineDial to dial the address associated with the new transfer destination of the call. The originating
///                     party can carry on a conversation over this consultation call prior to completing the transfer. The call state of
///                     <i>hConsultCall</i> is not applicable. This transfer procedure may not be valid for some line devices. The
///                     application may need to ignore the new consultation call and unhold an existing held call (using lineUnhold) to
///                     identify the destination of the transfer. On switches that support cross-address call transfer, the consultation
///                     call can exist on a different address than the call to be transferred. It may also be necessary that the
///                     consultation call be set up as an entirely new call, by lineMakeCall, to the destination of the transfer. Which
///                     forms of transfer are available are specified in the call's address capabilities.
///    lpCallParams = Pointer to a LINECALLPARAMS structure containing the call parameters to use when establishing the consultation
///                   call. This parameter can be set to <b>NULL</b> if no special call setup parameters are desired.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_BEARERMODEUNAVAIL, LINEERR_INVALRATE, LINEERR_CALLUNAVAIL, LINEERR_NOMEM, LINEERR_INUSE,
///    LINEERR_NOTOWNER, LINEERR_INVALADDRESSMODE, LINEERR_OPERATIONFAILED, LINEERR_INVALBEARERMODE,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLHANDLE, LINEERR_RATEUNAVAIL, LINEERR_INVALCALLPARAMS,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALCALLSTATE, LINEERR_STRUCTURETOOSMALL, LINEERR_INVALLINESTATE,
///    LINEERR_UNINITIALIZED, LINEERR_INVALMEDIAMODE, LINEERR_USERUSERINFOTOOBIG, LINEERR_INVALPOINTER.
///    
@DllImport("TAPI32")
int lineSetupTransferA(uint hCall, uint* lphConsultCall, const(LINECALLPARAMS)* lpCallParams);

///The <b>lineSetupTransfer</b> function initiates a transfer of the call specified by the <i>hCall</i> parameter. It
///establishes a consultation call, <i>lphConsultCall</i>, on which the party can be dialed that can become the
///destination of the transfer. The application acquires owner privilege to the <i>lphConsultCall</i> parameter.
///Params:
///    hCall = Handle to the call to be transferred. The application must be an owner of the call. The call state of
///            <i>hCall</i> must be <i>connected</i>.
///    lphConsultCall = Pointer to an <i>hCall</i> handle. This location is then loaded with a handle identifying the temporary
///                     consultation call. When setting up a call for transfer, a consultation call is automatically allocated that
///                     enables lineDial to dial the address associated with the new transfer destination of the call. The originating
///                     party can carry on a conversation over this consultation call prior to completing the transfer. The call state of
///                     <i>hConsultCall</i> is not applicable. This transfer procedure may not be valid for some line devices. The
///                     application may need to ignore the new consultation call and unhold an existing held call (using lineUnhold) to
///                     identify the destination of the transfer. On switches that support cross-address call transfer, the consultation
///                     call can exist on a different address than the call to be transferred. It may also be necessary that the
///                     consultation call be set up as an entirely new call, by lineMakeCall, to the destination of the transfer. Which
///                     forms of transfer are available are specified in the call's address capabilities.
///    lpCallParams = Pointer to a LINECALLPARAMS structure containing the call parameters to use when establishing the consultation
///                   call. This parameter can be set to <b>NULL</b> if no special call setup parameters are desired.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_BEARERMODEUNAVAIL, LINEERR_INVALRATE, LINEERR_CALLUNAVAIL, LINEERR_NOMEM, LINEERR_INUSE,
///    LINEERR_NOTOWNER, LINEERR_INVALADDRESSMODE, LINEERR_OPERATIONFAILED, LINEERR_INVALBEARERMODE,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLHANDLE, LINEERR_RATEUNAVAIL, LINEERR_INVALCALLPARAMS,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALCALLSTATE, LINEERR_STRUCTURETOOSMALL, LINEERR_INVALLINESTATE,
///    LINEERR_UNINITIALIZED, LINEERR_INVALMEDIAMODE, LINEERR_USERUSERINFOTOOBIG, LINEERR_INVALPOINTER.
///    
@DllImport("TAPI32")
int lineSetupTransferW(uint hCall, uint* lphConsultCall, const(LINECALLPARAMS)* lpCallParams);

///The <b>lineShutdown</b> function shuts down the application's usage of the line abstraction of the API.
///Params:
///    hLineApp = Application's usage handle for the line API.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALAPPHANDLE, LINEERR_RESOURCEUNAVAIL, LINEERR_NOMEM, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineShutdown(uint hLineApp);

///The <b>lineSwapHold</b> function swaps the specified active call with the specified call on consultation hold.
///Params:
///    hActiveCall = Handle to the active call. The application must be an owner of the call. The call state of <i>hActiveCall</i>
///                  must be <i>connected</i>.
///    hHeldCall = Handle to the consultation call. The application must be an owner of the call. The call state of <i>hHeldCall</i>
///                can be <i>onHoldPendingTransfer</i>, <i>onHoldPendingConference</i>, or <i>onHold</i>.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSTATE, LINEERR_OPERATIONFAILED,
///    LINEERR_NOMEM, LINEERR_RESOURCEUNAVAIL, LINEERR_NOTOWNER, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineSwapHold(uint hActiveCall, uint hHeldCall);

///The <b>lineTranslateAddress</b> function translates the specified address into another format.
///Params:
///    hLineApp = Handle returned by lineInitializeEx. If a TAPI 2.x application has not yet called the <b>lineInitializeEx</b>
///               function, it can set this parameter to <b>NULL</b>. TAPI 1.4 applications must still call lineInitialize first.
///    dwDeviceID = Device identifier of the line device upon which the call is to be dialed, so that variations in dialing
///                 procedures on different lines can be applied to the translation process.
///    dwAPIVersion = Highest version of TAPI supported by the application (not necessarily the value negotiated by
///                   lineNegotiateAPIVersion on some particular line device).
///    lpszAddressIn = Pointer to a <b>null</b>-terminated string that contains the address of the information that is to be extracted
///                    for translation. Must be in either the canonical address format, or an arbitrary string of dialable digits
///                    (non-canonical). This parameter must not be <b>NULL</b>. If the <i>AddressIn</i> contains a subaddress or name
///                    field, or additional addresses separated from the first address by CR and LF characters, only the first address
///                    is translated.
///    dwCard = Credit card to be used for dialing. This parameter is only valid if the CARDOVERRIDE bit is set in
///             <i>dwTranslateOptions</i>. This parameter specifies the permanent identifier of a Card entry in the [Cards]
///             section in the registry (as obtained from lineTranslateCaps) that should be used instead of the
///             <b>PreferredCardID</b> specified in the definition of the <b>CurrentLocation</b>. It does not cause the
///             <i>PreferredCardID</i> parameter of the current Location entry in the registry to be modified; the override
///             applies only to the current translation operation. This parameter is ignored if the CARDOVERRIDE bit is not set
///             in <i>dwTranslateOptions</i>.
///    dwTranslateOptions = Associated operations to be performed prior to the translation of the address into a dialable string. This
///                         parameter uses one of the LINETRANSLATEOPTION_ Constants. If you have set the
///                         LINETRANSLATEOPTION_CANCELCALLWAITING bit, it is also advisable to set the LINECALLPARAMFLAGS_SECURE bit in the
///                         <b>dwCallParamFlags</b> member of the LINECALLPARAMS structure (passed in to lineMakeCall through the
///                         <i>lpCallParams</i> parameter). This prevents the line device from using dialable digits to suppress call
///                         interrupts.
///    lpTranslateOutput = Pointer to an application-allocated memory area to contain the output of the translation operation, of type
///                        LINETRANSLATEOUTPUT. Prior to calling <b>lineTranslateAddress</b>, the application must set the
///                        <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for returning
///                        information.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_INVALPOINTER, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NODRIVER,
///    LINEERR_INIFILECORRUPT, LINEERR_NOMEM, LINEERR_INVALADDRESS, LINEERR_OPERATIONFAILED, LINEERR_INVALAPPHANDLE,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALCARD, LINEERR_STRUCTURETOOSMALL, LINEERR_INVALPARAM.
///    
@DllImport("TAPI32")
int lineTranslateAddress(uint hLineApp, uint dwDeviceID, uint dwAPIVersion, const(char)* lpszAddressIn, 
                         uint dwCard, uint dwTranslateOptions, LINETRANSLATEOUTPUT* lpTranslateOutput);

///The <b>lineTranslateAddress</b> function translates the specified address into another format.
///Params:
///    hLineApp = Handle returned by lineInitializeEx. If a TAPI 2.x application has not yet called the <b>lineInitializeEx</b>
///               function, it can set this parameter to <b>NULL</b>. TAPI 1.4 applications must still call lineInitialize first.
///    dwDeviceID = Device identifier of the line device upon which the call is to be dialed, so that variations in dialing
///                 procedures on different lines can be applied to the translation process.
///    dwAPIVersion = Highest version of TAPI supported by the application (not necessarily the value negotiated by
///                   lineNegotiateAPIVersion on some particular line device).
///    lpszAddressIn = Pointer to a <b>null</b>-terminated string that contains the address of the information that is to be extracted
///                    for translation. Must be in either the canonical address format, or an arbitrary string of dialable digits
///                    (non-canonical). This parameter must not be <b>NULL</b>. If the <i>AddressIn</i> contains a subaddress or name
///                    field, or additional addresses separated from the first address by CR and LF characters, only the first address
///                    is translated.
///    dwCard = Credit card to be used for dialing. This parameter is only valid if the CARDOVERRIDE bit is set in
///             <i>dwTranslateOptions</i>. This parameter specifies the permanent identifier of a Card entry in the [Cards]
///             section in the registry (as obtained from lineTranslateCaps) that should be used instead of the
///             <b>PreferredCardID</b> specified in the definition of the <b>CurrentLocation</b>. It does not cause the
///             <i>PreferredCardID</i> parameter of the current Location entry in the registry to be modified; the override
///             applies only to the current translation operation. This parameter is ignored if the CARDOVERRIDE bit is not set
///             in <i>dwTranslateOptions</i>.
///    dwTranslateOptions = Associated operations to be performed prior to the translation of the address into a dialable string. This
///                         parameter uses one of the LINETRANSLATEOPTION_ Constants. If you have set the
///                         LINETRANSLATEOPTION_CANCELCALLWAITING bit, it is also advisable to set the LINECALLPARAMFLAGS_SECURE bit in the
///                         <b>dwCallParamFlags</b> member of the LINECALLPARAMS structure (passed in to lineMakeCall through the
///                         <i>lpCallParams</i> parameter). This prevents the line device from using dialable digits to suppress call
///                         interrupts.
///    lpTranslateOutput = Pointer to an application-allocated memory area to contain the output of the translation operation, of type
///                        LINETRANSLATEOUTPUT. Prior to calling <b>lineTranslateAddress</b>, the application must set the
///                        <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for returning
///                        information.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_INVALPOINTER, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NODRIVER,
///    LINEERR_INIFILECORRUPT, LINEERR_NOMEM, LINEERR_INVALADDRESS, LINEERR_OPERATIONFAILED, LINEERR_INVALAPPHANDLE,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALCARD, LINEERR_STRUCTURETOOSMALL, LINEERR_INVALPARAM.
///    
@DllImport("TAPI32")
int lineTranslateAddressA(uint hLineApp, uint dwDeviceID, uint dwAPIVersion, const(char)* lpszAddressIn, 
                          uint dwCard, uint dwTranslateOptions, LINETRANSLATEOUTPUT* lpTranslateOutput);

///The <b>lineTranslateAddress</b> function translates the specified address into another format.
///Params:
///    hLineApp = Handle returned by lineInitializeEx. If a TAPI 2.x application has not yet called the <b>lineInitializeEx</b>
///               function, it can set this parameter to <b>NULL</b>. TAPI 1.4 applications must still call lineInitialize first.
///    dwDeviceID = Device identifier of the line device upon which the call is to be dialed, so that variations in dialing
///                 procedures on different lines can be applied to the translation process.
///    dwAPIVersion = Highest version of TAPI supported by the application (not necessarily the value negotiated by
///                   lineNegotiateAPIVersion on some particular line device).
///    lpszAddressIn = Pointer to a <b>null</b>-terminated string that contains the address of the information that is to be extracted
///                    for translation. Must be in either the canonical address format, or an arbitrary string of dialable digits
///                    (non-canonical). This parameter must not be <b>NULL</b>. If the <i>AddressIn</i> contains a subaddress or name
///                    field, or additional addresses separated from the first address by CR and LF characters, only the first address
///                    is translated.
///    dwCard = Credit card to be used for dialing. This parameter is only valid if the CARDOVERRIDE bit is set in
///             <i>dwTranslateOptions</i>. This parameter specifies the permanent identifier of a Card entry in the [Cards]
///             section in the registry (as obtained from lineTranslateCaps) that should be used instead of the
///             <b>PreferredCardID</b> specified in the definition of the <b>CurrentLocation</b>. It does not cause the
///             <i>PreferredCardID</i> parameter of the current Location entry in the registry to be modified; the override
///             applies only to the current translation operation. This parameter is ignored if the CARDOVERRIDE bit is not set
///             in <i>dwTranslateOptions</i>.
///    dwTranslateOptions = Associated operations to be performed prior to the translation of the address into a dialable string. This
///                         parameter uses one of the LINETRANSLATEOPTION_ Constants. If you have set the
///                         LINETRANSLATEOPTION_CANCELCALLWAITING bit, it is also advisable to set the LINECALLPARAMFLAGS_SECURE bit in the
///                         <b>dwCallParamFlags</b> member of the LINECALLPARAMS structure (passed in to lineMakeCall through the
///                         <i>lpCallParams</i> parameter). This prevents the line device from using dialable digits to suppress call
///                         interrupts.
///    lpTranslateOutput = Pointer to an application-allocated memory area to contain the output of the translation operation, of type
///                        LINETRANSLATEOUTPUT. Prior to calling <b>lineTranslateAddress</b>, the application must set the
///                        <b>dwTotalSize</b> member of this structure to indicate the amount of memory available to TAPI for returning
///                        information.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_INVALPOINTER, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NODRIVER,
///    LINEERR_INIFILECORRUPT, LINEERR_NOMEM, LINEERR_INVALADDRESS, LINEERR_OPERATIONFAILED, LINEERR_INVALAPPHANDLE,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALCARD, LINEERR_STRUCTURETOOSMALL, LINEERR_INVALPARAM.
///    
@DllImport("TAPI32")
int lineTranslateAddressW(uint hLineApp, uint dwDeviceID, uint dwAPIVersion, const(wchar)* lpszAddressIn, 
                          uint dwCard, uint dwTranslateOptions, LINETRANSLATEOUTPUT* lpTranslateOutput);

///The <b>lineTranslateDialog</b> function displays an application-modal dialog box that allows the user to change the
///current location of a phone number about to be dialed, adjust location and calling card parameters, and see the
///effect.
///Params:
///    hLineApp = Application handle returned by lineInitializeEx. If an application has not yet called the <b>lineInitializeEx</b>
///               function, it can set the <i>hLineApp</i> parameter to zero.
///    dwDeviceID = Device identifier for the line device upon which the call is intended to be dialed, so that variations in dialing
///                 procedures on different lines can be applied to the translation process.
///    dwAPIVersion = Highest version of TAPI supported by the application (not necessarily the value negotiated by
///                   lineNegotiateAPIVersion on the line device indicated by <i>dwDeviceID</i>).
///    hwndOwner = Handle to a window to which the dialog box is to be attached. Can be a <b>NULL</b> value to indicate that any
///                window created during the function should have no owner window.
///    lpszAddressIn = Pointer to a <b>null</b>-terminated string containing a phone number that is used, in the lower portion of the
///                    dialog box, to show the effect of the user's changes on the location parameters. The number must be in canonical
///                    format; if noncanonical, the phone number portion of the dialog box is not displayed. This pointer can be left
///                    <b>NULL</b>, in which case the phone number portion of the dialog box is not displayed. If the
///                    <i>lpszAddressIn</i> parameter contains a subaddress or name field, or additional addresses separated from the
///                    first address by CR and LF characters, only the first address is used in the dialog box.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_INVALPARAM, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_INVALPOINTER,
///    LINEERR_INIFILECORRUPT, LINEERR_NODRIVER, LINEERR_INUSE, LINEERR_NOMEM, LINEERR_INVALADDRESS,
///    LINEERR_INVALAPPHANDLE, LINEERR_OPERATIONFAILED.
///    
@DllImport("TAPI32")
int lineTranslateDialog(uint hLineApp, uint dwDeviceID, uint dwAPIVersion, HWND hwndOwner, 
                        const(char)* lpszAddressIn);

///The <b>lineTranslateDialog</b> function displays an application-modal dialog box that allows the user to change the
///current location of a phone number about to be dialed, adjust location and calling card parameters, and see the
///effect.
///Params:
///    hLineApp = Application handle returned by lineInitializeEx. If an application has not yet called the <b>lineInitializeEx</b>
///               function, it can set the <i>hLineApp</i> parameter to zero.
///    dwDeviceID = Device identifier for the line device upon which the call is intended to be dialed, so that variations in dialing
///                 procedures on different lines can be applied to the translation process.
///    dwAPIVersion = Highest version of TAPI supported by the application (not necessarily the value negotiated by
///                   lineNegotiateAPIVersion on the line device indicated by <i>dwDeviceID</i>).
///    hwndOwner = Handle to a window to which the dialog box is to be attached. Can be a <b>NULL</b> value to indicate that any
///                window created during the function should have no owner window.
///    lpszAddressIn = Pointer to a <b>null</b>-terminated string containing a phone number that is used, in the lower portion of the
///                    dialog box, to show the effect of the user's changes on the location parameters. The number must be in canonical
///                    format; if noncanonical, the phone number portion of the dialog box is not displayed. This pointer can be left
///                    <b>NULL</b>, in which case the phone number portion of the dialog box is not displayed. If the
///                    <i>lpszAddressIn</i> parameter contains a subaddress or name field, or additional addresses separated from the
///                    first address by CR and LF characters, only the first address is used in the dialog box.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_INVALPARAM, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_INVALPOINTER,
///    LINEERR_INIFILECORRUPT, LINEERR_NODRIVER, LINEERR_INUSE, LINEERR_NOMEM, LINEERR_INVALADDRESS,
///    LINEERR_INVALAPPHANDLE, LINEERR_OPERATIONFAILED.
///    
@DllImport("TAPI32")
int lineTranslateDialogA(uint hLineApp, uint dwDeviceID, uint dwAPIVersion, HWND hwndOwner, 
                         const(char)* lpszAddressIn);

///The <b>lineTranslateDialog</b> function displays an application-modal dialog box that allows the user to change the
///current location of a phone number about to be dialed, adjust location and calling card parameters, and see the
///effect.
///Params:
///    hLineApp = Application handle returned by lineInitializeEx. If an application has not yet called the <b>lineInitializeEx</b>
///               function, it can set the <i>hLineApp</i> parameter to zero.
///    dwDeviceID = Device identifier for the line device upon which the call is intended to be dialed, so that variations in dialing
///                 procedures on different lines can be applied to the translation process.
///    dwAPIVersion = Highest version of TAPI supported by the application (not necessarily the value negotiated by
///                   lineNegotiateAPIVersion on the line device indicated by <i>dwDeviceID</i>).
///    hwndOwner = Handle to a window to which the dialog box is to be attached. Can be a <b>NULL</b> value to indicate that any
///                window created during the function should have no owner window.
///    lpszAddressIn = Pointer to a <b>null</b>-terminated string containing a phone number that is used, in the lower portion of the
///                    dialog box, to show the effect of the user's changes on the location parameters. The number must be in canonical
///                    format; if noncanonical, the phone number portion of the dialog box is not displayed. This pointer can be left
///                    <b>NULL</b>, in which case the phone number portion of the dialog box is not displayed. If the
///                    <i>lpszAddressIn</i> parameter contains a subaddress or name field, or additional addresses separated from the
///                    first address by CR and LF characters, only the first address is used in the dialog box.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    LINEERR_BADDEVICEID, LINEERR_INVALPARAM, LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_INVALPOINTER,
///    LINEERR_INIFILECORRUPT, LINEERR_NODRIVER, LINEERR_INUSE, LINEERR_NOMEM, LINEERR_INVALADDRESS,
///    LINEERR_INVALAPPHANDLE, LINEERR_OPERATIONFAILED.
///    
@DllImport("TAPI32")
int lineTranslateDialogW(uint hLineApp, uint dwDeviceID, uint dwAPIVersion, HWND hwndOwner, 
                         const(wchar)* lpszAddressIn);

///The <b>lineUncompleteCall</b> function cancels the specified call completion request on the specified line.
///Params:
///    hLine = Handle to the line device on which a call completion is to be canceled.
///    dwCompletionID = Completion identifier for the request that is to be canceled.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALLINEHANDLE, LINEERR_OPERATIONFAILED, LINEERR_INVALCOMPLETIONID, LINEERR_RESOURCEUNAVAIL,
///    LINEERR_NOMEM, LINEERR_UNINITIALIZED, LINEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int lineUncompleteCall(uint hLine, uint dwCompletionID);

///The <b>lineUnhold</b> function retrieves the specified held call.
///Params:
///    hCall = Handle to the call to be retrieved. The application must be an owner of this call. The call state of <i>hCall</i>
///            must be <i>onHold</i>, <i>onHoldPendingTransfer</i>, or <i>onHoldPendingConference</i>.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    LINEERR_INVALCALLHANDLE, LINEERR_OPERATIONUNAVAIL, LINEERR_INVALCALLSTATE, LINEERR_OPERATIONFAILED,
///    LINEERR_NOMEM, LINEERR_RESOURCEUNAVAIL, LINEERR_NOTOWNER, LINEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int lineUnhold(uint hCall);

///The <b>lineUnpark</b> function retrieves the call parked at the specified address and returns a call handle for it.
///Params:
///    hLine = Handle to the open line device on which a call is to be unparked.
///    dwAddressID = Address on <i>hLine</i> at which the unpark is to be originated. An address identifier is permanently associated
///                  with an address; the identifier remains constant across operating system upgrades.
///    lphCall = Pointer to the location of type HCALL where the handle to the unparked call is returned. This handle is unrelated
///              to any other handle that might have been previously associated with the retrieved call, such as the handle that
///              might have been associated with the call when it was originally parked. The application is the initial sole owner
///              of this call.
///    lpszDestAddress = Pointer to a null-terminated character buffer that contains the address where the call is parked. The address is
///                      in standard dialable address format.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_INVALADDRESS,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_INVALADDRESSID, LINEERR_OPERATIONFAILED, LINEERR_INVALLINEHANDLE,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineUnpark(uint hLine, uint dwAddressID, uint* lphCall, const(char)* lpszDestAddress);

///The <b>lineUnpark</b> function retrieves the call parked at the specified address and returns a call handle for it.
///Params:
///    hLine = Handle to the open line device on which a call is to be unparked.
///    dwAddressID = Address on <i>hLine</i> at which the unpark is to be originated. An address identifier is permanently associated
///                  with an address; the identifier remains constant across operating system upgrades.
///    lphCall = Pointer to the location of type HCALL where the handle to the unparked call is returned. This handle is unrelated
///              to any other handle that might have been previously associated with the retrieved call, such as the handle that
///              might have been associated with the call when it was originally parked. The application is the initial sole owner
///              of this call.
///    lpszDestAddress = Pointer to a null-terminated character buffer that contains the address where the call is parked. The address is
///                      in standard dialable address format.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_INVALADDRESS,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_INVALADDRESSID, LINEERR_OPERATIONFAILED, LINEERR_INVALLINEHANDLE,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineUnparkA(uint hLine, uint dwAddressID, uint* lphCall, const(char)* lpszDestAddress);

///The <b>lineUnpark</b> function retrieves the call parked at the specified address and returns a call handle for it.
///Params:
///    hLine = Handle to the open line device on which a call is to be unparked.
///    dwAddressID = Address on <i>hLine</i> at which the unpark is to be originated. An address identifier is permanently associated
///                  with an address; the identifier remains constant across operating system upgrades.
///    lphCall = Pointer to the location of type HCALL where the handle to the unparked call is returned. This handle is unrelated
///              to any other handle that might have been previously associated with the retrieved call, such as the handle that
///              might have been associated with the call when it was originally parked. The application is the initial sole owner
///              of this call.
///    lpszDestAddress = Pointer to a null-terminated character buffer that contains the address where the call is parked. The address is
///                      in standard dialable address format.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously, or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding LINE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are: LINEERR_INVALADDRESS,
///    LINEERR_OPERATIONUNAVAIL, LINEERR_INVALADDRESSID, LINEERR_OPERATIONFAILED, LINEERR_INVALLINEHANDLE,
///    LINEERR_RESOURCEUNAVAIL, LINEERR_INVALPOINTER, LINEERR_UNINITIALIZED, LINEERR_NOMEM.
///    
@DllImport("TAPI32")
int lineUnparkW(uint hLine, uint dwAddressID, uint* lphCall, const(wchar)* lpszDestAddress);

///The <b>phoneClose</b> function closes the specified open phone device.
///Params:
///    hPhone = Handle to the open phone device to be closed. If the function succeeds, the handle is no longer valid.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_OPERATIONFAILED, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_OPERATIONUNAVAIL, PHONEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int phoneClose(uint hPhone);

///The <b>phoneConfigDialog</b> function causes the provider of the specified phone device to display a modal dialog box
///(attached to the application's <i>hwndOwner</i> parameter) that allows the user to configure parameters related to
///the phone device specified by <i>dwDeviceID</i>.
///Params:
///    dwDeviceID = Identifier of the phone device to be configured.
///    hwndOwner = Handle to a window to which the dialog box is to be attached. Can be a <b>NULL</b> value to indicate that any
///                window created during the function should have no owner window.
///    lpszDeviceClass = Pointer to a <b>null</b>-terminated string that identifies a device class name. This device class allows the
///                      application to select a specific subscreen of configuration information applicable to that device class. This
///                      parameter is optional and can be left <b>NULL</b> or empty, in which case the highest level configuration is
///                      selected.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_BADDEVICEID, PHONEERR_NOMEM, PHONEERR_INUSE, PHONEERR_OPERATIONFAILED, PHONEERR_INVALPARAM,
///    PHONEERR_OPERATIONUNAVAIL, PHONEERR_INVALDEVICECLASS, PHONEERR_RESOURCEUNAVAIL, PHONEERR_INVALPOINTER,
///    PHONEERR_UNINITIALIZED, PHONEERR_NODEVICE.
///    
@DllImport("TAPI32")
int phoneConfigDialog(uint dwDeviceID, HWND hwndOwner, const(char)* lpszDeviceClass);

///The <b>phoneConfigDialog</b> function causes the provider of the specified phone device to display a modal dialog box
///(attached to the application's <i>hwndOwner</i> parameter) that allows the user to configure parameters related to
///the phone device specified by <i>dwDeviceID</i>.
///Params:
///    dwDeviceID = Identifier of the phone device to be configured.
///    hwndOwner = Handle to a window to which the dialog box is to be attached. Can be a <b>NULL</b> value to indicate that any
///                window created during the function should have no owner window.
///    lpszDeviceClass = Pointer to a <b>null</b>-terminated string that identifies a device class name. This device class allows the
///                      application to select a specific subscreen of configuration information applicable to that device class. This
///                      parameter is optional and can be left <b>NULL</b> or empty, in which case the highest level configuration is
///                      selected.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_BADDEVICEID, PHONEERR_NOMEM, PHONEERR_INUSE, PHONEERR_OPERATIONFAILED, PHONEERR_INVALPARAM,
///    PHONEERR_OPERATIONUNAVAIL, PHONEERR_INVALDEVICECLASS, PHONEERR_RESOURCEUNAVAIL, PHONEERR_INVALPOINTER,
///    PHONEERR_UNINITIALIZED, PHONEERR_NODEVICE.
///    
@DllImport("TAPI32")
int phoneConfigDialogA(uint dwDeviceID, HWND hwndOwner, const(char)* lpszDeviceClass);

///The <b>phoneConfigDialog</b> function causes the provider of the specified phone device to display a modal dialog box
///(attached to the application's <i>hwndOwner</i> parameter) that allows the user to configure parameters related to
///the phone device specified by <i>dwDeviceID</i>.
///Params:
///    dwDeviceID = Identifier of the phone device to be configured.
///    hwndOwner = Handle to a window to which the dialog box is to be attached. Can be a <b>NULL</b> value to indicate that any
///                window created during the function should have no owner window.
///    lpszDeviceClass = Pointer to a <b>null</b>-terminated string that identifies a device class name. This device class allows the
///                      application to select a specific subscreen of configuration information applicable to that device class. This
///                      parameter is optional and can be left <b>NULL</b> or empty, in which case the highest level configuration is
///                      selected.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_BADDEVICEID, PHONEERR_NOMEM, PHONEERR_INUSE, PHONEERR_OPERATIONFAILED, PHONEERR_INVALPARAM,
///    PHONEERR_OPERATIONUNAVAIL, PHONEERR_INVALDEVICECLASS, PHONEERR_RESOURCEUNAVAIL, PHONEERR_INVALPOINTER,
///    PHONEERR_UNINITIALIZED, PHONEERR_NODEVICE.
///    
@DllImport("TAPI32")
int phoneConfigDialogW(uint dwDeviceID, HWND hwndOwner, const(wchar)* lpszDeviceClass);

///The <b>phoneDevSpecific</b> function is used as a general extension mechanism to enable a Telephony API
///implementation to provide features not described in the other TAPI functions. The meanings of these extensions are
///device specific.
///Params:
///    hPhone = Handle to a phone device.
///    lpParams = Pointer to a memory area used to hold a parameter block. Its interpretation is device specific. The contents of
///               the parameter block are passed unchanged to or from the service provider by TAPI.
///    dwSize = Size of the parameter block area, in bytes.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding PHONE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALPOINTER, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_OPERATIONUNAVAIL, PHONEERR_UNINITIALIZED, PHONEERR_OPERATIONFAILED. Additional return values are device
///    specific.
///    
@DllImport("TAPI32")
int phoneDevSpecific(uint hPhone, void* lpParams, uint dwSize);

///The <b>phoneGetButtonInfo</b> function returns information about the specified button.
///Params:
///    hPhone = Handle to the open phone device.
///    dwButtonLampID = Button on the phone device.
///    lpButtonInfo = Pointer to a variably sized structure of type PHONEBUTTONINFO. This data structure describes the mode and the
///                   function, and provides additional descriptive text corresponding to the button.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALBUTTONLAMPID, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_INVALPOINTER, PHONEERR_OPERATIONFAILED, PHONEERR_INVALPHONESTATE, PHONEERR_STRUCTURETOOSMALL,
///    PHONEERR_OPERATIONUNAVAIL, PHONEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int phoneGetButtonInfo(uint hPhone, uint dwButtonLampID, PHONEBUTTONINFO* lpButtonInfo);

///The <b>phoneGetButtonInfo</b> function returns information about the specified button.
///Params:
///    hPhone = Handle to the open phone device.
///    dwButtonLampID = Button on the phone device.
///    lpButtonInfo = Pointer to a variably sized structure of type PHONEBUTTONINFO. This data structure describes the mode and the
///                   function, and provides additional descriptive text corresponding to the button.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALBUTTONLAMPID, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_INVALPOINTER, PHONEERR_OPERATIONFAILED, PHONEERR_INVALPHONESTATE, PHONEERR_STRUCTURETOOSMALL,
///    PHONEERR_OPERATIONUNAVAIL, PHONEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int phoneGetButtonInfoA(uint hPhone, uint dwButtonLampID, PHONEBUTTONINFO* lpButtonInfo);

///The <b>phoneGetButtonInfo</b> function returns information about the specified button.
///Params:
///    hPhone = Handle to the open phone device.
///    dwButtonLampID = Button on the phone device.
///    lpButtonInfo = Pointer to a variably sized structure of type PHONEBUTTONINFO. This data structure describes the mode and the
///                   function, and provides additional descriptive text corresponding to the button.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALBUTTONLAMPID, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_INVALPOINTER, PHONEERR_OPERATIONFAILED, PHONEERR_INVALPHONESTATE, PHONEERR_STRUCTURETOOSMALL,
///    PHONEERR_OPERATIONUNAVAIL, PHONEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int phoneGetButtonInfoW(uint hPhone, uint dwButtonLampID, PHONEBUTTONINFO* lpButtonInfo);

///The <b>phoneGetData</b> function uploads the information from the specified location in the open phone device to the
///specified buffer.
///Params:
///    hPhone = Handle to the open phone device.
///    dwDataID = Where in the phone device the buffer is to be uploaded from.
///    lpData = Pointer to the memory buffer where the data is to be uploaded.
///    dwSize = Size of the data buffer, in bytes.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALPOINTER, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_INVALPHONESTATE, PHONEERR_OPERATIONFAILED, PHONEERR_INVALDATAID, PHONEERR_UNINITIALIZED,
///    PHONEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int phoneGetData(uint hPhone, uint dwDataID, void* lpData, uint dwSize);

///The <b>phoneGetDevCaps</b> function queries a specified phone device to determine its telephony capabilities.
///Params:
///    hPhoneApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Identifier of the phone device to be queried.
///    dwAPIVersion = Version number of the Telephony API to be used. The high-order word contains the major version number; the
///                   low-order word contains the minor version number. This number is obtained with the function
///                   phoneNegotiateAPIVersion.
///    dwExtVersion = Version number of the service provider-specific extensions to be used. This number is obtained with the function
///                   phoneNegotiateExtVersion. It can be left zero if no device-specific extensions are to be used. Otherwise, the
///                   high-order word contains the major version number; the low-order word contains the minor version number.
///    lpPhoneCaps = Pointer to a variably sized structure of type PHONECAPS. Upon successful completion of the request, this
///                  structure is filled with phone device capabilities information.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALAPPHANDLE, PHONEERR_INVALPOINTER, PHONEERR_BADDEVICEID, PHONEERR_OPERATIONFAILED,
///    PHONEERR_INCOMPATIBLEAPIVERSION, PHONEERR_OPERATIONUNAVAIL, PHONEERR_INCOMPATIBLEEXTVERSION, PHONEERR_NOMEM,
///    PHONEERR_STRUCTURETOOSMALL, PHONEERR_RESOURCEUNAVAIL, PHONEERR_NODRIVER, PHONEERR_UNINITIALIZED,
///    PHONEERR_NODEVICE.
///    
@DllImport("TAPI32")
int phoneGetDevCaps(uint hPhoneApp, uint dwDeviceID, uint dwAPIVersion, uint dwExtVersion, PHONECAPS* lpPhoneCaps);

///The <b>phoneGetDevCaps</b> function queries a specified phone device to determine its telephony capabilities.
///Params:
///    hPhoneApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Identifier of the phone device to be queried.
///    dwAPIVersion = Version number of the Telephony API to be used. The high-order word contains the major version number; the
///                   low-order word contains the minor version number. This number is obtained with the function
///                   phoneNegotiateAPIVersion.
///    dwExtVersion = Version number of the service provider-specific extensions to be used. This number is obtained with the function
///                   phoneNegotiateExtVersion. It can be left zero if no device-specific extensions are to be used. Otherwise, the
///                   high-order word contains the major version number; the low-order word contains the minor version number.
///    lpPhoneCaps = Pointer to a variably sized structure of type PHONECAPS. Upon successful completion of the request, this
///                  structure is filled with phone device capabilities information.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALAPPHANDLE, PHONEERR_INVALPOINTER, PHONEERR_BADDEVICEID, PHONEERR_OPERATIONFAILED,
///    PHONEERR_INCOMPATIBLEAPIVERSION, PHONEERR_OPERATIONUNAVAIL, PHONEERR_INCOMPATIBLEEXTVERSION, PHONEERR_NOMEM,
///    PHONEERR_STRUCTURETOOSMALL, PHONEERR_RESOURCEUNAVAIL, PHONEERR_NODRIVER, PHONEERR_UNINITIALIZED,
///    PHONEERR_NODEVICE.
///    
@DllImport("TAPI32")
int phoneGetDevCapsA(uint hPhoneApp, uint dwDeviceID, uint dwAPIVersion, uint dwExtVersion, PHONECAPS* lpPhoneCaps);

///The <b>phoneGetDevCaps</b> function queries a specified phone device to determine its telephony capabilities.
///Params:
///    hPhoneApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Identifier of the phone device to be queried.
///    dwAPIVersion = Version number of the Telephony API to be used. The high-order word contains the major version number; the
///                   low-order word contains the minor version number. This number is obtained with the function
///                   phoneNegotiateAPIVersion.
///    dwExtVersion = Version number of the service provider-specific extensions to be used. This number is obtained with the function
///                   phoneNegotiateExtVersion. It can be left zero if no device-specific extensions are to be used. Otherwise, the
///                   high-order word contains the major version number; the low-order word contains the minor version number.
///    lpPhoneCaps = Pointer to a variably sized structure of type PHONECAPS. Upon successful completion of the request, this
///                  structure is filled with phone device capabilities information.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALAPPHANDLE, PHONEERR_INVALPOINTER, PHONEERR_BADDEVICEID, PHONEERR_OPERATIONFAILED,
///    PHONEERR_INCOMPATIBLEAPIVERSION, PHONEERR_OPERATIONUNAVAIL, PHONEERR_INCOMPATIBLEEXTVERSION, PHONEERR_NOMEM,
///    PHONEERR_STRUCTURETOOSMALL, PHONEERR_RESOURCEUNAVAIL, PHONEERR_NODRIVER, PHONEERR_UNINITIALIZED,
///    PHONEERR_NODEVICE.
///    
@DllImport("TAPI32")
int phoneGetDevCapsW(uint hPhoneApp, uint dwDeviceID, uint dwAPIVersion, uint dwExtVersion, PHONECAPS* lpPhoneCaps);

///The <b>phoneGetDisplay</b> function returns the current contents of the specified phone display.
///Params:
///    hPhone = Handle to the open phone device.
///    lpDisplay = Pointer to the memory location where the display content is to be stored, of type VARSTRING.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_RESOURCEUNAVAIL, PHONEERR_INVALPOINTER, PHONEERR_OPERATIONFAILED,
///    PHONEERR_INVALPHONESTATE, PHONEERR_STRUCTURETOOSMALL, PHONEERR_OPERATIONUNAVAIL, PHONEERR_UNINITIALIZED,
///    PHONEERR_NOMEM.
///    
@DllImport("TAPI32")
int phoneGetDisplay(uint hPhone, VARSTRING* lpDisplay);

///The <b>phoneGetGain</b> function returns the gain setting of the microphone of the specified phone's hookswitch
///device.
///Params:
///    hPhone = Handle to the open phone device.
///    dwHookSwitchDev = Hookswitch device whose gain level is queried. The <i>dwHookSwitchDev</i> parameter can have only one bit set.
///                      This parameter uses one and only one of the PHONEHOOKSWITCHDEV_ Constants.
///    lpdwGain = Pointer to a <b>DWORD</b> containing the current gain setting of the hookswitch microphone component. The
///               <i>dwGain</i> parameter specifies the volume level of the hookswitch device. This is a number in the range
///               0x00000000 (silence) to 0x0000FFFF (maximum volume). The actual granularity and quantization of gain settings in
///               this range are service provider-specific.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALPOINTER, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_INVALPHONESTATE, PHONEERR_OPERATIONFAILED, PHONEERR_INVALHOOKSWITCHDEV, PHONEERR_UNINITIALIZED,
///    PHONEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int phoneGetGain(uint hPhone, uint dwHookSwitchDev, uint* lpdwGain);

///The <b>phoneGetHookSwitch</b> function returns the current hookswitch mode of the specified open phone device.
///Params:
///    hPhone = Handle to the open phone device.
///    lpdwHookSwitchDevs = Pointer to a <b>DWORD</b> to be filled with the mode of the phone's hookswitch devices. If a bit position is
///                         <b>FALSE</b>, the corresponding hookswitch device is onhook; if <b>TRUE</b>, the microphone and/or speaker part
///                         of the corresponding hookswitch device is offhook. To find out whether the microphone and/or speaker are enabled,
///                         the application can use phoneGetStatus. This parameter uses one or more of the PHONEHOOKSWITCHDEV_ Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALPOINTER, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_INVALPHONESTATE, PHONEERR_OPERATIONFAILED, PHONEERR_OPERATIONUNAVAIL, PHONEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int phoneGetHookSwitch(uint hPhone, uint* lpdwHookSwitchDevs);

///The <b>phoneGetIcon</b> function allows an application to retrieve a service phone device-specific (or
///provider-specific) icon that can be displayed to the user.
///Params:
///    dwDeviceID = Identifier of the phone device whose icon is requested.
///    lpszDeviceClass = Pointer to a <b>null</b>-terminated string that identifies a device class name. This device class allows the
///                      application to select a specific sub-icon applicable to that device class. This parameter is optional and can be
///                      left <b>NULL</b> or empty, in which case the highest-level icon associated with the phone device rather than a
///                      specified media stream device would be selected.
///    lphIcon = Pointer to a memory location in which the handle to the icon is returned.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_BADDEVICEID, PHONEERR_RESOURCEUNAVAIL, PHONEERR_INVALPOINTER, PHONEERR_OPERATIONFAILED,
///    PHONEERR_INVALDEVICECLASS, PHONEERR_UNINITIALIZED, PHONEERR_NOMEM, PHONEERR_NODEVICE.
///    
@DllImport("TAPI32")
int phoneGetIcon(uint dwDeviceID, const(char)* lpszDeviceClass, ptrdiff_t* lphIcon);

///The <b>phoneGetIcon</b> function allows an application to retrieve a service phone device-specific (or
///provider-specific) icon that can be displayed to the user.
///Params:
///    dwDeviceID = Identifier of the phone device whose icon is requested.
///    lpszDeviceClass = Pointer to a <b>null</b>-terminated string that identifies a device class name. This device class allows the
///                      application to select a specific sub-icon applicable to that device class. This parameter is optional and can be
///                      left <b>NULL</b> or empty, in which case the highest-level icon associated with the phone device rather than a
///                      specified media stream device would be selected.
///    lphIcon = Pointer to a memory location in which the handle to the icon is returned.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_BADDEVICEID, PHONEERR_RESOURCEUNAVAIL, PHONEERR_INVALPOINTER, PHONEERR_OPERATIONFAILED,
///    PHONEERR_INVALDEVICECLASS, PHONEERR_UNINITIALIZED, PHONEERR_NOMEM, PHONEERR_NODEVICE.
///    
@DllImport("TAPI32")
int phoneGetIconA(uint dwDeviceID, const(char)* lpszDeviceClass, ptrdiff_t* lphIcon);

///The <b>phoneGetIcon</b> function allows an application to retrieve a service phone device-specific (or
///provider-specific) icon that can be displayed to the user.
///Params:
///    dwDeviceID = Identifier of the phone device whose icon is requested.
///    lpszDeviceClass = Pointer to a <b>null</b>-terminated string that identifies a device class name. This device class allows the
///                      application to select a specific sub-icon applicable to that device class. This parameter is optional and can be
///                      left <b>NULL</b> or empty, in which case the highest-level icon associated with the phone device rather than a
///                      specified media stream device would be selected.
///    lphIcon = Pointer to a memory location in which the handle to the icon is returned.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_BADDEVICEID, PHONEERR_RESOURCEUNAVAIL, PHONEERR_INVALPOINTER, PHONEERR_OPERATIONFAILED,
///    PHONEERR_INVALDEVICECLASS, PHONEERR_UNINITIALIZED, PHONEERR_NOMEM, PHONEERR_NODEVICE.
///    
@DllImport("TAPI32")
int phoneGetIconW(uint dwDeviceID, const(wchar)* lpszDeviceClass, ptrdiff_t* lphIcon);

///The <b>phoneGetID</b> function returns a device identifier for the given device class associated with the specified
///phone device.
///Params:
///    hPhone = Handle to an open phone device.
///    lpDeviceID = Pointer to a data structure of type VARSTRING where the device identifier is returned. Upon successful completion
///                 of the request, this location is filled with the device identifier. The format of the returned information
///                 depends on the method used by the device class (API) for naming devices.
///    lpszDeviceClass = Pointer to a null-terminated string that specifies the device class of the device whose identifier is requested.
///                      Valid device class strings are those used in the System.ini section to identify device classes.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALPOINTER, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_INVALDEVICECLASS, PHONEERR_UNINITIALIZED, PHONEERR_OPERATIONFAILED, PHONEERR_STRUCTURETOOSMALL,
///    PHONEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int phoneGetID(uint hPhone, VARSTRING* lpDeviceID, const(char)* lpszDeviceClass);

///The <b>phoneGetID</b> function returns a device identifier for the given device class associated with the specified
///phone device.
///Params:
///    hPhone = Handle to an open phone device.
///    lpDeviceID = Pointer to a data structure of type VARSTRING where the device identifier is returned. Upon successful completion
///                 of the request, this location is filled with the device identifier. The format of the returned information
///                 depends on the method used by the device class (API) for naming devices.
///    lpszDeviceClass = Pointer to a null-terminated string that specifies the device class of the device whose identifier is requested.
///                      Valid device class strings are those used in the System.ini section to identify device classes.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALPOINTER, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_INVALDEVICECLASS, PHONEERR_UNINITIALIZED, PHONEERR_OPERATIONFAILED, PHONEERR_STRUCTURETOOSMALL,
///    PHONEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int phoneGetIDA(uint hPhone, VARSTRING* lpDeviceID, const(char)* lpszDeviceClass);

///The <b>phoneGetID</b> function returns a device identifier for the given device class associated with the specified
///phone device.
///Params:
///    hPhone = Handle to an open phone device.
///    lpDeviceID = Pointer to a data structure of type VARSTRING where the device identifier is returned. Upon successful completion
///                 of the request, this location is filled with the device identifier. The format of the returned information
///                 depends on the method used by the device class (API) for naming devices.
///    lpszDeviceClass = Pointer to a null-terminated string that specifies the device class of the device whose identifier is requested.
///                      Valid device class strings are those used in the System.ini section to identify device classes.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALPOINTER, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_INVALDEVICECLASS, PHONEERR_UNINITIALIZED, PHONEERR_OPERATIONFAILED, PHONEERR_STRUCTURETOOSMALL,
///    PHONEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int phoneGetIDW(uint hPhone, VARSTRING* lpDeviceID, const(wchar)* lpszDeviceClass);

///The <b>phoneGetLamp</b> function returns the current lamp mode of the specified lamp.
///Params:
///    hPhone = Handle to the open phone device.
///    dwButtonLampID = Identifier of the lamp to be queried.
///    lpdwLampMode = Pointer to a memory location that holds the lamp mode status of the given lamp. This parameter uses one and only
///                   one of the PHONELAMPMODE_ Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALBUTTONLAMPID, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_INVALPOINTER, PHONEERR_OPERATIONFAILED, PHONEERR_INVALPHONESTATE, PHONEERR_UNINITIALIZED,
///    PHONEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int phoneGetLamp(uint hPhone, uint dwButtonLampID, uint* lpdwLampMode);

///The <b>phoneGetMessage</b> function returns the next TAPI message that is queued for delivery to an application that
///is using the Event Handle notification mechanism (see phoneInitializeEx for further details).
///Params:
///    hPhoneApp = Handle returned by phoneInitializeEx. The application must have set the PHONEINITIALIZEEXOPTION_USEEVENT option
///                in the <b>dwOptions</b> member of the PHONEINITIALIZEEXPARAMS structure.
///    lpMessage = Pointer to a PHONEMESSAGE structure. Upon successful return from this function, the structure contains the next
///                message that had been queued for delivery to the application.
///    dwTimeout = Time-out interval, in milliseconds. The function returns if the interval elapses, even if no message can be
///                returned. If <i>dwTimeout</i> is zero, the function checks for a queued message and returns immediately. If
///                <i>dwTimeout</i> is INFINITE, the function's time-out interval never elapses.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALAPPHANDLE, PHONEERR_OPERATIONFAILED, PHONEERR_INVALPOINTER, PHONEERR_NOMEM.
///    
@DllImport("TAPI32")
int phoneGetMessage(uint hPhoneApp, PHONEMESSAGE* lpMessage, uint dwTimeout);

///The <b>phoneGetRing</b> function enables an application to query the specified open phone device as to its current
///ring mode.
///Params:
///    hPhone = Handle to the open phone device.
///    lpdwRingMode = Ringing pattern with which the phone is ringing. Zero indicates that the phone is not ringing.
///    lpdwVolume = Volume level with which the phone is ringing. This is a number in the range 0x00000000 (silence) to 0x0000FFFF
///                 (maximum volume). The actual granularity and quantization of volume settings in this range are service
///                 provider-specific.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALPHONESTATE, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_INVALPOINTER, PHONEERR_OPERATIONFAILED, PHONEERR_OPERATIONUNAVAIL, PHONEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int phoneGetRing(uint hPhone, uint* lpdwRingMode, uint* lpdwVolume);

///The <b>phoneGetStatus</b> function enables an application to query the specified open phone device for its overall
///status.
///Params:
///    hPhone = Handle to the open phone device to be queried.
///    lpPhoneStatus = Pointer to a variably sized data structure of type PHONESTATUS, which is loaded with the returned information
///                    about the phone's status.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALPOINTER, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_OPERATIONFAILED, PHONEERR_STRUCTURETOOSMALL, PHONEERR_OPERATIONUNAVAIL, PHONEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int phoneGetStatus(uint hPhone, PHONESTATUS* lpPhoneStatus);

///The <b>phoneGetStatus</b> function enables an application to query the specified open phone device for its overall
///status.
///Params:
///    hPhone = Handle to the open phone device to be queried.
///    lpPhoneStatus = Pointer to a variably sized data structure of type PHONESTATUS, which is loaded with the returned information
///                    about the phone's status.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALPOINTER, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_OPERATIONFAILED, PHONEERR_STRUCTURETOOSMALL, PHONEERR_OPERATIONUNAVAIL, PHONEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int phoneGetStatusA(uint hPhone, PHONESTATUS* lpPhoneStatus);

///The <b>phoneGetStatus</b> function enables an application to query the specified open phone device for its overall
///status.
///Params:
///    hPhone = Handle to the open phone device to be queried.
///    lpPhoneStatus = Pointer to a variably sized data structure of type PHONESTATUS, which is loaded with the returned information
///                    about the phone's status.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALPOINTER, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_OPERATIONFAILED, PHONEERR_STRUCTURETOOSMALL, PHONEERR_OPERATIONUNAVAIL, PHONEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int phoneGetStatusW(uint hPhone, PHONESTATUS* lpPhoneStatus);

///The <b>phoneGetStatusMessages</b> function returns which phone-state changes on the specified phone device generate a
///callback to the application.
///Params:
///    hPhone = Handle to the open phone device to be monitored.
///    lpdwPhoneStates = Pointer to a <b>DWORD</b> holding zero, one or more of the PHONESTATE_ Constants. These flags specify the set of
///                      phone status changes and events for which the application can receive notification messages. Monitoring can be
///                      individually enabled and disabled.
///    lpdwButtonModes = Pointer to a <b>DWORD</b> containing flags that specify the set of phone-button modes for which the application
///                      can receive notification messages. This parameter uses zero, one or more of the PHONEBUTTONMODE_ Constants.
///    lpdwButtonStates = Pointer to a <b>DWORD</b> that contains flags specifying the set of phone button state changes for which the
///                       application can receive notification messages. This parameter uses zero, one or more of the PHONEBUTTONSTATE_
///                       Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALPOINTER, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_OPERATIONFAILED, PHONEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int phoneGetStatusMessages(uint hPhone, uint* lpdwPhoneStates, uint* lpdwButtonModes, uint* lpdwButtonStates);

///The <b>phoneGetVolume</b> function returns the volume setting of the specified phone's hookswitch device.
///Params:
///    hPhone = Handle to the open phone device.
///    dwHookSwitchDev = A single hookswitch device whose volume level is queried. This parameter uses one of the PHONEHOOKSWITCHDEV_
///                      Constants.
///    lpdwVolume = Pointer to a <b>DWORD</b>. The function returns the current volume setting of the hookswitch device in this
///                 location. This is a number in the range 0x00000000 (silence) to 0x0000FFFF (maximum volume). The actual
///                 granularity and quantization of volume settings in this range are service provider-specific.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALPHONESTATE, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_INVALPOINTER, PHONEERR_OPERATIONFAILED, PHONEERR_INVALHOOKSWITCHDEV, PHONEERR_UNINITIALIZED,
///    PHONEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int phoneGetVolume(uint hPhone, uint dwHookSwitchDev, uint* lpdwVolume);

///The <b>phoneInitialize</b> function is obsolete. It continues to be exported by Tapi.dll and Tapi32.dll for backward
///compatibility with applications using TAPI versions 1.3 and 1.4. Applications using TAPI version 2.0 or later must
///use phoneInitializeEx instead. <b>For TAPI Versions 1.4 and Earlier: </b>The <b>phoneInitialize</b> function
///initializes the application's use of TAPI for the subsequent use of the phone functions in the Telephony API. It
///registers the application's specified notification mechanism and returns the number of phone devices that are
///available to the application.
///Params:
///    lphPhoneApp = Pointer to a location that is filled with the application's usage handle for TAPI.
///    hInstance = Instance handle of the client application or DLL.
///    lpfnCallback = Address of a callback function that is invoked to determine status and events on the phone device.
///    lpszAppName = Pointer to a <b>null</b>-terminated string that contains displayable characters. If this parameter is
///                  non-<b>NULL</b>, it contains an application-supplied name of the application. This name is provided in the
///                  PHONESTATUS structure to indicate, in a user-friendly way, which application is the current owner of the phone
///                  device. This information can be useful for logging and status reporting purposes. If <i>lpszAppName</i> is
///                  <b>NULL</b>, the application's filename is used instead.
///    lpdwNumDevs = Pointer to <b>DWORD</b>. This location is loaded with the number of phone devices available to the application.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALAPPNAME, PHONEERR_INIFILECORRUPT, PHONEERR_INVALPOINTER, PHONEERR_NOMEM, PHONEERR_OPERATIONFAILED,
///    PHONEERR_REINIT, PHONEERR_RESOURCEUNAVAIL, PHONEERR_NODEVICE, PHONEERR_NODRIVER, PHONEERR_INVALPARAM
///    
@DllImport("TAPI32")
int phoneInitialize(uint* lphPhoneApp, HINSTANCE hInstance, PHONECALLBACK lpfnCallback, const(char)* lpszAppName, 
                    uint* lpdwNumDevs);

///The <b>phoneInitializeEx</b> function initializes the application's use of TAPI for subsequent use of the phone
///abstraction. It registers the application's specified notification mechanism and returns the number of phone devices
///available to the application. A phone device is any device that provides an implementation for the phone-prefixed
///functions in the Telephony API.
///Params:
///    lphPhoneApp = Pointer to a location that is filled with the application's usage handle for TAPI.
///    hInstance = Instance handle of the client application or DLL. The application or DLL can pass <b>NULL</b> for this parameter,
///                in which case TAPI uses the module handle of the root executable of the process.
///    lpfnCallback = Address of a callback function that is invoked to determine status and events on the line device, addresses, or
///                   calls, when the application is using the "hidden window" method of event notification (for more information see
///                   phoneCallbackFunc). This parameter is ignored and should be set to <b>NULL</b> when the application chooses to
///                   use the "event handle" or "completion port" event notification mechanisms.
///    lpszFriendlyAppName = Pointer to a <b>null</b>-terminated string that contains only displayable characters. If this parameter is not
///                          <b>NULL</b>, it contains an application-supplied name for the application. This name is provided in the
///                          PHONESTATUS structure to indicate, in a user-friendly way, which application has ownership of the phone device.
///                          If <i>lpszFriendlyAppName</i> is <b>NULL</b>, the application's module filename is used instead (as returned by
///                          the function GetModuleFileName).
///    lpdwNumDevs = Pointer to a <b>DWORD</b>. Upon successful completion of this request, this location is filled with the number of
///                  phone devices available to the application.
///    lpdwAPIVersion = Pointer to a <b>DWORD</b>. The application must initialize this <b>DWORD</b>, before calling this function, to
///                     the highest API version it is designed to support (for example, the same value it would pass into
///                     <i>dwAPIHighVersion</i> parameter of phoneNegotiateAPIVersion). Artificially high values must not be used; the
///                     value must be accurately set. TAPI translates any newer messages or structures into values or formats supported
///                     by the application's version. Upon successful completion of this request, this location is filled with the
///                     highest API version supported by TAPI, thereby allowing the application to detect and adapt to having been
///                     installed on a system with an older version of TAPI.
///    lpPhoneInitializeExParams = Pointer to a structure of type PHONEINITIALIZEEXPARAMS containing additional parameters used to establish the
///                                association between the application and TAPI (specifically, the application's selected event notification
///                                mechanism and associated parameters).
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALAPPNAME, PHONEERR_OPERATIONFAILED, PHONEERR_INIFILECORRUPT, PHONEERR_INVALPOINTER, PHONEERR_REINIT,
///    PHONEERR_NOMEM, PHONEERR_INVALPARAM.
///    
@DllImport("TAPI32")
int phoneInitializeExA(uint* lphPhoneApp, HINSTANCE hInstance, PHONECALLBACK lpfnCallback, 
                       const(char)* lpszFriendlyAppName, uint* lpdwNumDevs, uint* lpdwAPIVersion, 
                       PHONEINITIALIZEEXPARAMS* lpPhoneInitializeExParams);

///The <b>phoneInitializeEx</b> function initializes the application's use of TAPI for subsequent use of the phone
///abstraction. It registers the application's specified notification mechanism and returns the number of phone devices
///available to the application. A phone device is any device that provides an implementation for the phone-prefixed
///functions in the Telephony API.
///Params:
///    lphPhoneApp = Pointer to a location that is filled with the application's usage handle for TAPI.
///    hInstance = Instance handle of the client application or DLL. The application or DLL can pass <b>NULL</b> for this parameter,
///                in which case TAPI uses the module handle of the root executable of the process.
///    lpfnCallback = Address of a callback function that is invoked to determine status and events on the line device, addresses, or
///                   calls, when the application is using the "hidden window" method of event notification (for more information see
///                   phoneCallbackFunc). This parameter is ignored and should be set to <b>NULL</b> when the application chooses to
///                   use the "event handle" or "completion port" event notification mechanisms.
///    lpszFriendlyAppName = Pointer to a <b>null</b>-terminated string that contains only displayable characters. If this parameter is not
///                          <b>NULL</b>, it contains an application-supplied name for the application. This name is provided in the
///                          PHONESTATUS structure to indicate, in a user-friendly way, which application has ownership of the phone device.
///                          If <i>lpszFriendlyAppName</i> is <b>NULL</b>, the application's module filename is used instead (as returned by
///                          the function GetModuleFileName).
///    lpdwNumDevs = Pointer to a <b>DWORD</b>. Upon successful completion of this request, this location is filled with the number of
///                  phone devices available to the application.
///    lpdwAPIVersion = Pointer to a <b>DWORD</b>. The application must initialize this <b>DWORD</b>, before calling this function, to
///                     the highest API version it is designed to support (for example, the same value it would pass into
///                     <i>dwAPIHighVersion</i> parameter of phoneNegotiateAPIVersion). Artificially high values must not be used; the
///                     value must be accurately set. TAPI translates any newer messages or structures into values or formats supported
///                     by the application's version. Upon successful completion of this request, this location is filled with the
///                     highest API version supported by TAPI, thereby allowing the application to detect and adapt to having been
///                     installed on a system with an older version of TAPI.
///    lpPhoneInitializeExParams = Pointer to a structure of type PHONEINITIALIZEEXPARAMS containing additional parameters used to establish the
///                                association between the application and TAPI (specifically, the application's selected event notification
///                                mechanism and associated parameters).
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALAPPNAME, PHONEERR_OPERATIONFAILED, PHONEERR_INIFILECORRUPT, PHONEERR_INVALPOINTER, PHONEERR_REINIT,
///    PHONEERR_NOMEM, PHONEERR_INVALPARAM.
///    
@DllImport("TAPI32")
int phoneInitializeExW(uint* lphPhoneApp, HINSTANCE hInstance, PHONECALLBACK lpfnCallback, 
                       const(wchar)* lpszFriendlyAppName, uint* lpdwNumDevs, uint* lpdwAPIVersion, 
                       PHONEINITIALIZEEXPARAMS* lpPhoneInitializeExParams);

///The <b>phoneNegotiateAPIVersion</b> allows an application to negotiate an API version to use for the specified phone
///device.
///Params:
///    hPhoneApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Identifier of the phone device to be queried.
///    dwAPILowVersion = Least recent API version the application is compliant with. The high-order word is the major version number, the
///                      low-order word is the minor version number.
///    dwAPIHighVersion = Most recent API version the application is compliant with. The high-order word is the major version number, the
///                       low-order word is the minor version number.
///    lpdwAPIVersion = Pointer to a <b>DWORD</b> in which the API version number that was negotiated will be returned. If negotiation
///                     succeeds, this number is in the range <i>dwAPILowVersion</i> to <i>dwAPIHighVersion</i>.
///    lpExtensionID = Pointer to a structure of type PHONEEXTENSIONID. If the service provider for the specified <i>dwDeviceID</i>
///                    parameter supports provider-specific extensions, this structure is filled with the extension identifier of these
///                    extensions when negotiation succeeds. This structure contains all zeros if the line provides no extensions. An
///                    application can ignore the returned parameter if it does not use extensions.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALAPPHANDLE, PHONEERR_OPERATIONFAILED, PHONEERR_BADDEVICEID, PHONEERR_OPERATIONUNAVAIL,
///    PHONEERR_NODRIVER, PHONEERR_NOMEM, PHONEERR_INVALPOINTER, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_INCOMPATIBLEAPIVERSION, PHONEERR_UNINITIALIZED, PHONEERR_NODEVICE.
///    
@DllImport("TAPI32")
int phoneNegotiateAPIVersion(uint hPhoneApp, uint dwDeviceID, uint dwAPILowVersion, uint dwAPIHighVersion, 
                             uint* lpdwAPIVersion, PHONEEXTENSIONID* lpExtensionID);

///The <b>phoneNegotiateExtVersion</b> function allows an application to negotiate an extension version to use with the
///specified phone device. This operation need not be called if the application does not support extensions.
///Params:
///    hPhoneApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Identifier of the phone device to be queried.
///    dwAPIVersion = API version number that was negotiated for the specified phone device using phoneNegotiateAPIVersion.
///    dwExtLowVersion = Least recent extension version of the extension identifier returned by phoneNegotiateAPIVersion that the
///                      application is compliant with. The high-order word is the major version number; the low-order word is the minor
///                      version number.
///    dwExtHighVersion = Most recent extension version of the extension identifier returned by phoneNegotiateAPIVersion that the
///                       application is compliant with. The high-order word is the major version number; the low-order word is the minor
///                       version number.
///    lpdwExtVersion = Pointer to a <b>DWORD</b> in which the extension version number that was negotiated is returned. If negotiation
///                     succeeds, this number is in the range <i>dwExtLowVersion</i> to <i>dwExtHighVersion</i>.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALAPPHANDLE, PHONEERR_OPERATIONFAILED, PHONEERR_BADDEVICEID, PHONEERR_OPERATIONUNAVAIL,
///    PHONEERR_NODRIVER, PHONEERR_NOMEM, PHONEERR_INCOMPATIBLEAPIVERSION, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_INCOMPATIBLEEXTVERSION, PHONEERR_UNINITIALIZED, PHONEERR_INVALPOINTER, PHONEERR_NODEVICE.
///    
@DllImport("TAPI32")
int phoneNegotiateExtVersion(uint hPhoneApp, uint dwDeviceID, uint dwAPIVersion, uint dwExtLowVersion, 
                             uint dwExtHighVersion, uint* lpdwExtVersion);

///The <b>phoneOpen</b> function opens the specified phone device. A phone device can be opened using either owner
///privilege or monitor privilege. An application that opens the phone with owner privilege can control the phone's
///lamps, display, ringer, and hookswitch or hookswitches. An application that opens the phone device with monitor
///privilege is notified only about events that occur at the phone, such as hookswitch changes or button presses.
///Ownership of a phone device is exclusive. In other words, only one application can have a phone device opened with
///owner privilege at a time. The phone device can, however, be opened multiple times with monitor privilege.
///Params:
///    hPhoneApp = Handle to the application's registration with TAPI.
///    dwDeviceID = Identifier of the phone device to be opened.
///    lphPhone = Pointer to an HPHONE handle that identifies the open phone device. Use this handle to identify the device when
///               invoking other phone control functions.
///    dwAPIVersion = API version number under which the application and Telephony API have agreed to operate. This number is obtained
///                   from phoneNegotiateAPIVersion.
///    dwExtVersion = Extension version number under which the application and the service provider agree to operate. This number is
///                   zero if the application does not use any extensions. This number is obtained from phoneNegotiateExtVersion.
///    dwCallbackInstance = User instance data passed back to the application with each message. This parameter is not interpreted by the
///                         Telephony API.
///    dwPrivilege = Privilege requested. This parameter uses one and only one of the PHONEPRIVILEGE_ Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_ALLOCATED, PHONEERR_NODRIVER, PHONEERR_BADDEVICEID, PHONEERR_NOMEM, PHONEERR_INCOMPATIBLEAPIVERSION,
///    PHONEERR_OPERATIONFAILED, PHONEERR_INCOMPATIBLEEXTVERSION, PHONEERR_OPERATIONUNAVAIL, PHONEERR_INVALAPPHANDLE,
///    PHONEERR_RESOURCEUNAVAIL, PHONEERR_INVALPOINTER, PHONEERR_UNINITIALIZED, PHONEERR_INVALPRIVILEGE,
///    PHONEERR_REINIT, PHONEERR_INUSE, PHONEERR_NODEVICE, PHONEERR_INIFILECORRUPT.
///    
@DllImport("TAPI32")
int phoneOpen(uint hPhoneApp, uint dwDeviceID, uint* lphPhone, uint dwAPIVersion, uint dwExtVersion, 
              size_t dwCallbackInstance, uint dwPrivilege);

///The <b>phoneSetButtonInfo</b> function sets information about the specified button on the specified phone.
///Params:
///    hPhone = Handle to the open phone device. The application must be the owner of the phone device.
///    dwButtonLampID = Button on the phone device.
///    lpButtonInfo = Pointer to a variably sized structure of type PHONEBUTTONINFO. This data structure describes the mode, the
///                   function, and provides additional descriptive text about the button.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding PHONE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALBUTTONLAMPID, PHONEERR_OPERATIONFAILED, PHONEERR_INVALPHONEHANDLE, PHONEERR_STRUCTURETOOSMALL,
///    PHONEERR_INVALPOINTER, PHONEERR_UNINITIALIZED, PHONEERR_NOTOWNER, PHONEERR_NOMEM, PHONEERR_OPERATIONUNAVAIL,
///    PHONEERR_RESOURCEUNAVAIL.
///    
@DllImport("TAPI32")
int phoneSetButtonInfo(uint hPhone, uint dwButtonLampID, const(PHONEBUTTONINFO)* lpButtonInfo);

///The <b>phoneSetButtonInfo</b> function sets information about the specified button on the specified phone.
///Params:
///    hPhone = Handle to the open phone device. The application must be the owner of the phone device.
///    dwButtonLampID = Button on the phone device.
///    lpButtonInfo = Pointer to a variably sized structure of type PHONEBUTTONINFO. This data structure describes the mode, the
///                   function, and provides additional descriptive text about the button.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding PHONE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALBUTTONLAMPID, PHONEERR_OPERATIONFAILED, PHONEERR_INVALPHONEHANDLE, PHONEERR_STRUCTURETOOSMALL,
///    PHONEERR_INVALPOINTER, PHONEERR_UNINITIALIZED, PHONEERR_NOTOWNER, PHONEERR_NOMEM, PHONEERR_OPERATIONUNAVAIL,
///    PHONEERR_RESOURCEUNAVAIL.
///    
@DllImport("TAPI32")
int phoneSetButtonInfoA(uint hPhone, uint dwButtonLampID, const(PHONEBUTTONINFO)* lpButtonInfo);

///The <b>phoneSetButtonInfo</b> function sets information about the specified button on the specified phone.
///Params:
///    hPhone = Handle to the open phone device. The application must be the owner of the phone device.
///    dwButtonLampID = Button on the phone device.
///    lpButtonInfo = Pointer to a variably sized structure of type PHONEBUTTONINFO. This data structure describes the mode, the
///                   function, and provides additional descriptive text about the button.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding PHONE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALBUTTONLAMPID, PHONEERR_OPERATIONFAILED, PHONEERR_INVALPHONEHANDLE, PHONEERR_STRUCTURETOOSMALL,
///    PHONEERR_INVALPOINTER, PHONEERR_UNINITIALIZED, PHONEERR_NOTOWNER, PHONEERR_NOMEM, PHONEERR_OPERATIONUNAVAIL,
///    PHONEERR_RESOURCEUNAVAIL.
///    
@DllImport("TAPI32")
int phoneSetButtonInfoW(uint hPhone, uint dwButtonLampID, const(PHONEBUTTONINFO)* lpButtonInfo);

///The <b>phoneSetData</b> function downloads the information in the specified buffer to the opened phone device at the
///selected data identifier.
///Params:
///    hPhone = Handle to the open phone device. The application must be the owner of the phone.
///    dwDataID = Where in the phone device the buffer is to be downloaded.
///    lpData = Pointer to the memory location where the data is to be downloaded from.
///    dwSize = Size of the buffer, in bytes.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding PHONE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_OPERATIONUNAVAIL, PHONEERR_NOTOWNER, PHONEERR_NOMEM, PHONEERR_INVALDATAID,
///    PHONEERR_RESOURCEUNAVAIL, PHONEERR_INVALPHONESTATE, PHONEERR_OPERATIONFAILED, PHONEERR_INVALPOINTER,
///    PHONEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int phoneSetData(uint hPhone, uint dwDataID, const(void)* lpData, uint dwSize);

///The <b>phoneSetDisplay</b> function causes the specified string to be displayed on the specified open phone device.
///Params:
///    hPhone = Handle to the open phone device. The application must be the owner of the phone.
///    dwRow = Row position on the display where the new text is to be displayed.
///    dwColumn = Column position on the display where the new text is to be displayed.
///    lpsDisplay = Pointer to the memory location where the display content is stored. The display information must have the format
///                 specified in the <b>dwStringFormat</b> member of the PHONECAPS structure, which describes the phone's device
///                 capabilities.
///    dwSize = Size of the information pointed to by <i>lpsDisplay</i>, in bytes. If the <i>lpsDisplay</i> parameter is a
///             pointer to a string, the size must include the null terminator.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding PHONE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_OPERATIONUNAVAIL, PHONEERR_NOTOWNER, PHONEERR_OPERATIONFAILED,
///    PHONEERR_INVALPHONESTATE, PHONEERR_UNINITIALIZED, PHONEERR_INVALPOINTER, PHONEERR_NOMEM, PHONEERR_INVALPARAM,
///    PHONEERR_RESOURCEUNAVAIL.
///    
@DllImport("TAPI32")
int phoneSetDisplay(uint hPhone, uint dwRow, uint dwColumn, const(char)* lpsDisplay, uint dwSize);

///The <b>phoneSetGain</b> function sets the gain of the microphone of the specified hookswitch device to the specified
///gain level.
///Params:
///    hPhone = Handle to the open phone device. The application must be the owner of the phone.
///    dwHookSwitchDev = Hookswitch device whose microphone's gain is to be set. This parameter uses one and only one of the
///                      PHONEHOOKSWITCHDEV_ Constants.
///    dwGain = Pointer to a <b>DWORD</b> containing the new gain setting of the device. The <i>dwGain</i> parameter specifies
///             the gain level of the hookswitch device. This is a number in the range 0x00000000 (silence) to 0x0000FFFF
///             (maximum volume). The actual granularity and quantization of gain settings in this range are service
///             provider-specific. A value for <i>dwGain</i> that is out of range is set to the nearest value in the range.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding PHONE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_NOTOWNER, PHONEERR_RESOURCEUNAVAIL, PHONEERR_INVALPHONESTATE,
///    PHONEERR_OPERATIONFAILED, PHONEERR_INVALHOOKSWITCHDEV, PHONEERR_UNINITIALIZED, PHONEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int phoneSetGain(uint hPhone, uint dwHookSwitchDev, uint dwGain);

///The <b>phoneSetHookSwitch</b> function sets the hook state of the specified open phone's hookswitch devices to the
///specified mode. Only the hookswitch state of the hookswitch devices listed is affected.
///Params:
///    hPhone = Handle to the open phone device. The application must be the owner of the phone.
///    dwHookSwitchDevs = Device whose hookswitch mode is to be set. This parameter uses one and only one of the PHONEHOOKSWITCHDEV_
///                       Constants.
///    dwHookSwitchMode = Hookswitch mode to set. This parameter uses one and only one of the PHONEHOOKSWITCHMODE_ Constants.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding PHONE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_OPERATIONUNAVAIL, PHONEERR_NOTOWNER, PHONEERR_NOMEM,
///    PHONEERR_INVALHOOKSWITCHDEV, PHONEERR_RESOURCEUNAVAIL, PHONEERR_INVALHOOKSWITCHMODE, PHONEERR_OPERATIONFAILED,
///    PHONEERR_INVALPHONESTATE, PHONEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int phoneSetHookSwitch(uint hPhone, uint dwHookSwitchDevs, uint dwHookSwitchMode);

///The <b>phoneSetLamp</b> function causes the specified lamp to be lit on the specified open phone device in the
///specified lamp mode.
///Params:
///    hPhone = Handle to the open phone device. The application must be the owner of the phone.
///    dwButtonLampID = Button whose lamp is to be lit.
///    dwLampMode = How the lamp is to be lit. This parameter uses one and only one of the PHONELAMPMODE_ Constants.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding PHONE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_OPERATIONUNAVAIL, PHONEERR_NOTOWNER, PHONEERR_NOMEM,
///    PHONEERR_INVALBUTTONLAMPID, PHONEERR_RESOURCEUNAVAIL, PHONEERR_INVALPHONESTATE, PHONEERR_OPERATIONFAILED,
///    PHONEERR_INVALLAMPMODE, PHONEERR_UNINITIALIZED.
///    
@DllImport("TAPI32")
int phoneSetLamp(uint hPhone, uint dwButtonLampID, uint dwLampMode);

///The <b>phoneSetRing</b> function rings the specified open phone device using the specified ring mode and volume.
///Params:
///    hPhone = Handle to the open phone device. The application must be the owner of the phone device.
///    dwRingMode = Ringing pattern with which to ring the phone. This parameter must be within the range of zero to the value of the
///                 <b>dwNumRingModes</b> member in the PHONECAPS structure. If <b>dwNumRingModes</b> is zero, the ring mode of the
///                 phone cannot be controlled; if <b>dwNumRingModes</b> is 1, a value of 0 for <i>dwRingMode</i> indicates that the
///                 phone should not be rung (silence), and other values from 1 to <b>dwNumRingModes</b> are valid ring modes for the
///                 phone device.
///    dwVolume = Volume level with which the phone is ringing. This is a number in the range 0x00000000 (silence) to 0x0000FFFF
///               (maximum volume). The actual granularity and quantization of volume settings in this range are service
///               provider-specific. A value for <i>dwVolume</i> that is out of range is set to the nearest value in the range.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding PHONE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_NOTOWNER, PHONEERR_RESOURCEUNAVAIL, PHONEERR_INVALPHONESTATE,
///    PHONEERR_OPERATIONFAILED, PHONEERR_INVALRINGMODE, PHONEERR_UNINITIALIZED, PHONEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int phoneSetRing(uint hPhone, uint dwRingMode, uint dwVolume);

///The <b>phoneSetStatusMessages</b> function enables an application to monitor the specified phone device for selected
///status events.
///Params:
///    hPhone = Handle to the open phone device to be monitored.
///    dwPhoneStates = Set of phone status changes and events for which the application can receive notification messages. This
///                    parameter can have zero, one, or more of the PHONESTATE_ Constants.
///    dwButtonModes = Set of phone-button modes for which the application can receive notification messages. This parameter can have
///                    zero, one, or more of the PHONEBUTTONMODE_ Constants.
///    dwButtonStates = Set of phone-button state changes for which the application can receive notification messages. If the
///                     <i>dwButtonModes</i> parameter is zero, <i>dwButtonStates</i> is ignored. If <i>dwButtonModes</i> has one or more
///                     bits set, this parameter must also have at least one bit set. This parameter uses the PHONEBUTTONSTATE_
///                     Constants.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_INVALPHONESTATE, PHONEERR_RESOURCEUNAVAIL,
///    PHONEERR_INVALBUTTONMODE, PHONEERR_OPERATIONFAILED, PHONEERR_INVALBUTTONSTATE, PHONEERR_UNINITIALIZED,
///    PHONEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int phoneSetStatusMessages(uint hPhone, uint dwPhoneStates, uint dwButtonModes, uint dwButtonStates);

///The <b>phoneSetVolume</b> function sets the volume of the speaker component of the specified hookswitch device to the
///specified level.
///Params:
///    hPhone = Handle to the open phone device. The application must be the owner of the phone.
///    dwHookSwitchDev = Hookswitch device whose speaker's volume is to be set, one of the PHONEHOOKSWITCHDEV_ Constants.
///    dwVolume = New volume setting of the device. The <i>dwVolume</i> parameter specifies the volume level of the hookswitch
///               device. This is a number in the range 0x00000000 (silence) to 0x0000FFFF (maximum volume). The actual granularity
///               and quantization of volume settings in this range are service provider-specific. A value for <i>dwVolume</i> that
///               is out of range is set to the nearest value in the range.
///Returns:
///    Returns a positive request identifier if the function is completed asynchronously or a negative error number if
///    an error occurs. The <i>dwParam2</i> parameter of the corresponding PHONE_REPLY message is zero if the function
///    succeeds or it is a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALPHONEHANDLE, PHONEERR_NOMEM, PHONEERR_NOTOWNER, PHONEERR_RESOURCEUNAVAIL, PHONEERR_INVALPHONESTATE,
///    PHONEERR_OPERATIONFAILED, PHONEERR_INVALHOOKSWITCHDEV, PHONEERR_UNINITIALIZED, PHONEERR_OPERATIONUNAVAIL.
///    
@DllImport("TAPI32")
int phoneSetVolume(uint hPhone, uint dwHookSwitchDev, uint dwVolume);

///The <b>phoneShutdown</b> function shuts down the application's usage of TAPI's phone abstraction.
///Params:
///    hPhoneApp = Application's usage handle for TAPI.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are:
///    PHONEERR_INVALAPPHANDLE, PHONEERR_NOMEM, PHONEERR_UNINITIALIZED, PHONEERR_RESOURCEUNAVAIL.
///    
@DllImport("TAPI32")
int phoneShutdown(uint hPhoneApp);

///The <b>tapiGetLocationInfo</b> function returns the country or region code and city (area) code that the user has set
///in the current location parameters in the Telephony Control Panel. The application can use this information to assist
///the user in forming proper canonical telephone numbers, such as by offering these as defaults when new numbers are
///entered in a phone book entry or database record.
///Params:
///    lpszCountryCode = TBD
///    lpszCityCode = TBD
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are
///    TAPIERR_REQUESTFAILED.
///    
@DllImport("TAPI32")
int tapiGetLocationInfo(const(char)* lpszCountryCode, const(char)* lpszCityCode);

///The <b>tapiGetLocationInfo</b> function returns the country or region code and city (area) code that the user has set
///in the current location parameters in the Telephony Control Panel. The application can use this information to assist
///the user in forming proper canonical telephone numbers, such as by offering these as defaults when new numbers are
///entered in a phone book entry or database record.
///Params:
///    lpszCountryCode = TBD
///    lpszCityCode = TBD
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are
///    TAPIERR_REQUESTFAILED.
///    
@DllImport("TAPI32")
int tapiGetLocationInfoA(const(char)* lpszCountryCode, const(char)* lpszCityCode);

///The <b>tapiGetLocationInfo</b> function returns the country or region code and city (area) code that the user has set
///in the current location parameters in the Telephony Control Panel. The application can use this information to assist
///the user in forming proper canonical telephone numbers, such as by offering these as defaults when new numbers are
///entered in a phone book entry or database record.
///Params:
///    lpszCountryCodeW = Pointer to a memory location where a <b>null</b>-terminated string specifying the country or region code for the
///                       current location is to be returned. The application should allocate at least 8 bytes of storage at this location
///                       to hold the string (TAPI does not return more than 8 bytes, including the terminating <b>NULL</b>). An empty
///                       string (\0) is returned if the country or region code has not been set for the current location.
///    lpszCityCodeW = Pointer to a memory location where a <b>null</b>-terminated string specifying the city (area) code for the
///                    current location is to be returned. The application should allocate at least 8 bytes of storage at this location
///                    to hold the string (TAPI does not return more than 8 bytes, including the terminating <b>NULL</b>). An empty
///                    string (\0) is returned if the city code has not been set for the current location.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible return values are
///    TAPIERR_REQUESTFAILED.
///    
@DllImport("TAPI32")
int tapiGetLocationInfoW(const(wchar)* lpszCountryCodeW, const(wchar)* lpszCityCodeW);

///Closes a call request made by a previous call to tapiRequestMediaCall. <div class="alert"><b>Note</b> The
///tapiRequestDrop function is nonfunctional and obsolete for all classes of Windows-based applications. It should not
///be used.</div><div> </div>
///Params:
///    hwnd = Handle to the Windows process that issued this request.
///    wRequestID = Pointer to a 32-bit integer value that contains the ID of the call request.
///Returns:
///    The function is obsolete and will always return an error code.
///    
@DllImport("TAPI32")
int tapiRequestDrop(HWND hwnd, WPARAM wRequestID);

///The <b>tapiRequestMakeCall</b> function requests the establishment of a voice call. A call-manager application is
///responsible for establishing the call on behalf of the requesting application, which is then controlled by the user's
///call-manager application.
///Params:
///    lpszDestAddress = Pointer to a memory location where the <b>null</b>-terminated destination address of the call request is located.
///                      The address can use the [canonical address](/windows/win32/tapi/address-ovr
///    lpszAppName = Pointer to a memory location where the <b>null</b>-terminated user-friendly application name of the call request
///                  is located. This pointer can be left <b>NULL</b> if the application does not supply an application name. The
///                  maximum length of the address is TAPIMAXAPPNAMESIZE characters, which includes the <b>NULL</b> terminator. Longer
///                  strings are truncated.
///    lpszCalledParty = Pointer to a memory location where the <b>null</b>-terminated called party name for the called party of the call
///                      is located. This pointer can be left <b>NULL</b> if the application does not wish to supply this information. The
///                      maximum length of the string is TAPIMAXCALLEDPARTYSIZE characters, which includes the <b>NULL</b> terminator.
///                      Longer strings are truncated.
///    lpszComment = Pointer to a memory location where the <b>null</b>-terminated comment about the call is located. This pointer can
///                  be left <b>NULL</b> if the application does not supply a comment. The maximum length of the address is
///                  TAPIMAXCOMMENTSIZE characters, which includes the <b>NULL</b> terminator. Longer strings are truncated.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible error return value
///    are: TAPIERR_NOREQUESTRECIPIENT, TAPIERR_INVALDESTADDRESS, TAPIERR_REQUESTQUEUEFULL, TAPIERR_INVALPOINTER.
///    
@DllImport("TAPI32")
int tapiRequestMakeCall(const(char)* lpszDestAddress, const(char)* lpszAppName, const(char)* lpszCalledParty, 
                        const(char)* lpszComment);

///The <b>tapiRequestMakeCall</b> function requests the establishment of a voice call. A call-manager application is
///responsible for establishing the call on behalf of the requesting application, which is then controlled by the user's
///call-manager application.
///Params:
///    lpszDestAddress = Pointer to a memory location where the <b>null</b>-terminated destination address of the call request is located.
///                      The address can use the [canonical address](/windows/win32/tapi/address-ovr
///    lpszAppName = Pointer to a memory location where the <b>null</b>-terminated user-friendly application name of the call request
///                  is located. This pointer can be left <b>NULL</b> if the application does not supply an application name. The
///                  maximum length of the address is TAPIMAXAPPNAMESIZE characters, which includes the <b>NULL</b> terminator. Longer
///                  strings are truncated.
///    lpszCalledParty = Pointer to a memory location where the <b>null</b>-terminated called party name for the called party of the call
///                      is located. This pointer can be left <b>NULL</b> if the application does not wish to supply this information. The
///                      maximum length of the string is TAPIMAXCALLEDPARTYSIZE characters, which includes the <b>NULL</b> terminator.
///                      Longer strings are truncated.
///    lpszComment = Pointer to a memory location where the <b>null</b>-terminated comment about the call is located. This pointer can
///                  be left <b>NULL</b> if the application does not supply a comment. The maximum length of the address is
///                  TAPIMAXCOMMENTSIZE characters, which includes the <b>NULL</b> terminator. Longer strings are truncated.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible error return value
///    are: TAPIERR_NOREQUESTRECIPIENT, TAPIERR_INVALDESTADDRESS, TAPIERR_REQUESTQUEUEFULL, TAPIERR_INVALPOINTER.
///    
@DllImport("TAPI32")
int tapiRequestMakeCallA(const(char)* lpszDestAddress, const(char)* lpszAppName, const(char)* lpszCalledParty, 
                         const(char)* lpszComment);

///The <b>tapiRequestMakeCall</b> function requests the establishment of a voice call. A call-manager application is
///responsible for establishing the call on behalf of the requesting application, which is then controlled by the user's
///call-manager application.
///Params:
///    lpszDestAddress = Pointer to a memory location where the <b>null</b>-terminated destination address of the call request is located.
///                      The address can use the [canonical address](/windows/win32/tapi/address-ovr
///    lpszAppName = Pointer to a memory location where the <b>null</b>-terminated user-friendly application name of the call request
///                  is located. This pointer can be left <b>NULL</b> if the application does not supply an application name. The
///                  maximum length of the address is TAPIMAXAPPNAMESIZE characters, which includes the <b>NULL</b> terminator. Longer
///                  strings are truncated.
///    lpszCalledParty = Pointer to a memory location where the <b>null</b>-terminated called party name for the called party of the call
///                      is located. This pointer can be left <b>NULL</b> if the application does not wish to supply this information. The
///                      maximum length of the string is TAPIMAXCALLEDPARTYSIZE characters, which includes the <b>NULL</b> terminator.
///                      Longer strings are truncated.
///    lpszComment = Pointer to a memory location where the <b>null</b>-terminated comment about the call is located. This pointer can
///                  be left <b>NULL</b> if the application does not supply a comment. The maximum length of the address is
///                  TAPIMAXCOMMENTSIZE characters, which includes the <b>NULL</b> terminator. Longer strings are truncated.
///Returns:
///    Returns zero if the request succeeds or a negative error number if an error occurs. Possible error return value
///    are: TAPIERR_NOREQUESTRECIPIENT, TAPIERR_INVALDESTADDRESS, TAPIERR_REQUESTQUEUEFULL, TAPIERR_INVALPOINTER.
///    
@DllImport("TAPI32")
int tapiRequestMakeCallW(const(wchar)* lpszDestAddress, const(wchar)* lpszAppName, const(wchar)* lpszCalledParty, 
                         const(wchar)* lpszComment);

@DllImport("TAPI32")
int tapiRequestMediaCall(HWND hwnd, WPARAM wRequestID, const(char)* lpszDeviceClass, const(char)* lpDeviceID, 
                         uint dwSize, uint dwSecure, const(char)* lpszDestAddress, const(char)* lpszAppName, 
                         const(char)* lpszCalledParty, const(char)* lpszComment);

@DllImport("TAPI32")
int tapiRequestMediaCallA(HWND hwnd, WPARAM wRequestID, const(char)* lpszDeviceClass, const(char)* lpDeviceID, 
                          uint dwSize, uint dwSecure, const(char)* lpszDestAddress, const(char)* lpszAppName, 
                          const(char)* lpszCalledParty, const(char)* lpszComment);

@DllImport("TAPI32")
int tapiRequestMediaCallW(HWND hwnd, WPARAM wRequestID, const(wchar)* lpszDeviceClass, const(wchar)* lpDeviceID, 
                          uint dwSize, uint dwSecure, const(wchar)* lpszDestAddress, const(wchar)* lpszAppName, 
                          const(wchar)* lpszCalledParty, const(wchar)* lpszComment);


// Interfaces

@GUID("21D6D48E-A88B-11D0-83DD-00AA003CCABD")
struct TAPI;

@GUID("E9225296-C759-11D1-A02B-00C04FB6809F")
struct DispatchMapper;

@GUID("AC48FFE0-F8C4-11D1-A030-00C04FB6809F")
struct RequestMakeCall;

@GUID("F1029E5B-CB5B-11D0-8D59-00C04FD91AC0")
struct Rendezvous;

@GUID("DF0DAEF2-A289-11D1-8697-006008B0E5D2")
struct McastAddressAllocation;

///The <b>ITTAPI</b> interface is the base interface for the TAPI object. The TAPI object is created by
///<b>CoCreateInstance</b>. For information on <b>CoCreateInstance</b>, see documentation on COM. All other TAPI 3
///objects are created by TAPI 3 itself. <b>ITTAPI</b> methods are provided to initialize a TAPI session, enumerate
///available addresses, register for CallHub and CallEvent notifications, and shut down a TAPI session. The ITTAPI2
///interface derives from the <b>ITTAPI</b> interface. It adds additional methods on the TAPI object to support phone
///devices.
@GUID("B1EFC382-9355-11D0-835C-00AA003CCABD")
interface ITTAPI : IDispatch
{
    ///The <b>Initialize</b> method initializes TAPI. This method must be called before calling any other TAPI 3 method.
    ///The application must call the Shutdown method when ending a TAPI session.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> TAPI has already been initialized.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Initialize();
    ///The <b>Shutdown</b> method shuts down a TAPI session.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> TAPI session has already been shut
    ///    down. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Shutdown();
    ///The <b>get_Addresses</b> method creates a collection of addresses that are currently available. Provided for
    ///Automation client applications, such as those written in Visual Basic. C and C++ applications must use the
    ///EnumerateAddresses method.
    ///Params:
    ///    pVariant = Pointer to a <b>VARIANT</b> containing an ITCollection of ITAddress interface pointers (address objects).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter is not a valid pointer.
    ///    </td> </tr> </table>
    ///    
    HRESULT get_Addresses(VARIANT* pVariant);
    ///The <b>EnumerateAddresses</b> method enumerates the addresses that are currently available. Provided for C and
    ///C++ applications. Automation client applications, such as those written in Visual Basic, must use the
    ///get_Addresses method.
    ///Params:
    ///    ppEnumAddress = Pointer to the IEnumAddress interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnumAddress</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The TAPI object has not been initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT EnumerateAddresses(IEnumAddress* ppEnumAddress);
    ///The <b>RegisterCallNotifications</b> method sets which new call notifications an application will receive. The
    ///application must call the method for each address, indicating media type or types it can handle, and specifying
    ///the privileges it requests. An application that will make only outgoing calls does not need to call this method.
    ///The ITTAPIEventNotification outgoing interface must be registered prior to calling this method. If both owner and
    ///monitor privileges are needed for an address, this method should be called only once, with both <i>fMonitor</i>
    ///and <i>fOwner</i> set to <b>TRUE</b>.
    ///Params:
    ///    pAddress = Pointer to ITAddress interface.
    ///    fMonitor = Boolean value indicating whether the application will monitor calls. VARIANT_TRUE indicates that the
    ///               application will monitor calls; VARIANT_FALSE that it will not.
    ///    fOwner = Boolean value indicating whether the application will own incoming calls. VARIANT_TRUE indicates that the
    ///             application will own incoming calls; VARIANT_FALSE indicates that it will not.
    ///    lMediaTypes = Media types that can be handled by the application.
    ///    lCallbackInstance = Callback instance to be used by the TAPI 3 DLL. Can be the gulAdvise value returned by
    ///                        IConnectionPoint::Advise during registration of the ITTAPIEventNotification outgoing interface.
    ///    plRegister = On success, the returned value that is used by ITTAPI::UnregisterNotifications.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plRegister</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_NOT_INITIALIZED</b></dt> </dl>
    ///    </td> <td width="60%"> The TAPI object has not been initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT RegisterCallNotifications(ITAddress pAddress, short fMonitor, short fOwner, int lMediaTypes, 
                                      int lCallbackInstance, int* plRegister);
    ///The <b>UnregisterNotifications</b> method removes any incoming call notification registrations that have been
    ///performed using ITTAPI::RegisterCallNotifications.
    ///Params:
    ///    lRegister = The value returned by the RegisterCallNotifications method in the <i>plRegister</i> parameter.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The TAPI object has not yet been
    ///    initialized or the <i>lRegister</i> parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT UnregisterNotifications(int lRegister);
    ///The <b>get_CallHubs</b> method creates a collection of the currently available call hubs. Provided for Automation
    ///client applications, such as those written in Visual Basic. C and C++ applications must use the EnumerateCallHubs
    ///method.
    ///Params:
    ///    pVariant = Pointer to <b>VARIANT</b> containing an ITCollection of ITCallHub interface pointers (CallHub objects).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter is not a valid pointer.
    ///    </td> </tr> </table>
    ///    
    HRESULT get_CallHubs(VARIANT* pVariant);
    ///The <b>EnumerateCallHubs</b> method enumerates the currently available call hubs. Provided for C and C++
    ///applications. Automation client applications, such as those written in Visual Basic, must use the get_Callhubs
    ///method.
    ///Params:
    ///    ppEnumCallHub = Pointer to the IEnumCallHub interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnumCallHub</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The TAPI object has not been initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT EnumerateCallHubs(IEnumCallHub* ppEnumCallHub);
    ///The <b>SetCallHubTracking</b> method enables or disables CallHub tracking.
    ///Params:
    ///    pAddresses = Pointer to a <b>VARIANT</b> containing a <b>SAFEARRAY</b> of ITAddress interface pointers.
    ///    bTracking = VARIANT_TRUE to enable tracking, VARIANT_FALSE to disable.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The TAPI object has not been
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT SetCallHubTracking(VARIANT pAddresses, short bTracking);
    ///This method is not implemented and will return E_NOTIMPL.
    ///Params:
    ///    ppEnumUnknown = This method is not implemented.
    HRESULT EnumeratePrivateTAPIObjects(IEnumUnknown* ppEnumUnknown);
    ///This method is not implemented and will return E_NOTIMPL.
    ///Params:
    ///    pVariant = This method is not implemented.
    HRESULT get_PrivateTAPIObjects(VARIANT* pVariant);
    ///The <b>RegisterRequestRecipient</b> method registers an application instance as being the proper one to handle
    ///assisted telephony requests.
    ///Params:
    ///    lRegistrationInstance = Pointer to registration instance.
    ///    lRequestMode = Request mode.
    ///    fEnable = VARIANT_TRUE indicates that the caller wants to register as the handler; VARIANT_FALSE that it wants to
    ///              unregister as the handler.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The TAPI object has not been
    ///    initialized. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT RegisterRequestRecipient(int lRegistrationInstance, int lRequestMode, short fEnable);
    ///The <b>SetAssistedTelephonyPriority</b> method sets the application priority to handle assisted telephony
    ///requests.
    ///Params:
    ///    pAppFilename = Pointer to a <b>BSTR</b> containing the name of the application.
    ///    fPriority = Set to VARIANT_FALSE to disable, VARIANT_TRUE to enable.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT SetAssistedTelephonyPriority(BSTR pAppFilename, short fPriority);
    ///The <b>SetApplicationPriority</b> method allows an application to set its priority in the handoff priority list
    ///for a particular media type or Assisted Telephony request mode, or to remove itself from the priority list.
    ///Params:
    ///    pAppFilename = Pointer to <b>BSTR</b> containing name of application.
    ///    lMediaType = Media associated with application.
    ///    fPriority = The new priority for the application. If the value VARIANT_FALSE is passed, the application is removed from
    ///                the priority list for the specified media or request mode (if it was already not present, no error is
    ///                generated). If the value VARIANT_TRUE is passed, the application is inserted as the highest-priority
    ///                application for the media or request mode (and removed from a lower-priority position, if it was already in
    ///                the list).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT SetApplicationPriority(BSTR pAppFilename, int lMediaType, short fPriority);
    ///The <b>put_EventFilter</b> method sets the event filter mask. The mask is a series of ORed members of the
    ///TAPI_EVENT enumeration. <div class="alert"><b>Note</b> You must call this method to enable reception of events.
    ///If you do not call <b>ITTAPI::put_EventFilter</b>, your application will not receive any events.</div><div>
    ///</div>
    ///Params:
    ///    lFilterMask = Event filter mask.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT put_EventFilter(int lFilterMask);
    ///The <b>get_EventFilter</b> method gets the current event filter mask. The mask is a series of ORed members of the
    ///TAPI_EVENT enumeration.
    ///Params:
    ///    plFilterMask = Pointer to the event filter mask.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_EventFilter(int* plFilterMask);
}

///The <b>ITTAPI2</b> interface derives from the ITTAPI interface. It adds additional methods on the TAPI object to
///support phone devices.
@GUID("54FBDC8C-D90F-4DAD-9695-B373097F094B")
interface ITTAPI2 : ITTAPI
{
    ///The <b>get_Phones</b> method enumerates the phone objects corresponding to the phone devices. If there are no
    ///phones available that can be used with the address, this method produces an empty collection and returns S_OK.
    ///This method is intended for Visual Basic and scripting applications. C/C++ applications will find the
    ///EnumeratePhones method more convenient.
    ///Params:
    ///    pPhones = Pointer to a <b>VARIANT</b> containing an ITCollection of ITPhone interface pointers.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Phones(VARIANT* pPhones);
    ///The <b>EnumeratePhones</b> method enumerates the phone objects corresponding to the phone devices. If there are
    ///no phones available that can be used with the address, this method produces an empty enumeration and returns
    ///S_OK. This method is intended for C/C++ applications. Visual Basic and scripting applications must use the
    ///get_Phones method.
    ///Params:
    ///    ppEnumPhone = Pointer to an IEnumPhone interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnumeratePhones(IEnumPhone* ppEnumPhone);
    ///The <b>CreateEmptyCollectionObject</b> method creates an empty collection object. The collection can be filled
    ///with ITDetectTone or ITCustomTone objects for use with the DetectTonesByCollection method or the
    ///GenerateCustomTonesByCollection method, respectively. This method is intended for Visual Basic and scripting
    ///applications.
    ///Params:
    ///    ppCollection = Pointer to an ITCollection2 interface on the new collection object.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppCollection</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> There is not enough memory to allocate the object. </td> </tr> </table>
    ///    
    HRESULT CreateEmptyCollectionObject(ITCollection2* ppCollection);
}

///The <b>ITMediaSupport</b> interface provides methods that allow an application to discover the media support
///capabilities for an Address Object that exposes this interface. A pointer to this interface can be obtained by
///calling <b>QueryInterface</b> using any address interface pointer, such as ITAddress.
@GUID("B1EFC384-9355-11D0-835C-00AA003CCABD")
interface ITMediaSupport : IDispatch
{
    ///The <b>get_MediaTypes</b> method gets the media type or types supported on the current address.
    ///Params:
    ///    plMediaTypes = Pointer to bitmask of ORed of media type.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plMediaTypes</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_MediaTypes(int* plMediaTypes);
    ///The <b>QueryMediaType</b> method indicates whether the service provider associated with the current address
    ///supports the media type or types indicated by <i>lMediaType</i>.
    ///Params:
    ///    lMediaType = Media type or types being queried.
    ///    pfSupport = Pointer to a VARIANT_BOOL indicating whether the media type is supported. If the returned value is
    ///                VARIANT_TRUE, the media is supported; if it is VARIANT_FALSE, the media is not supported.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pfSupport</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT QueryMediaType(int lMediaType, short* pfSupport);
}

///The <b>ITPluggableTerminalClassInfo</b> interface exposes methods that allow the application to retrieve information
///concerning a pluggable terminal. The IEnumPluggableTerminalClassInfo::Next and
///ITTerminalSupport2::get_PluggableTerminalClasses methods create the <b>ITPluggableTerminalClassInfo</b> interface.
@GUID("41757F4A-CF09-4B34-BC96-0A79D2390076")
interface ITPluggableTerminalClassInfo : IDispatch
{
    ///The <b>get_Name</b> method gets the terminal's friendly name.
    ///Params:
    ///    pName = The <b>BSTR</b> representation of the terminal's friendly name. The <b>BSTR</b> is allocated using
    ///            SysAllocString. The <b>BSTR</b> argument should be deallocated by the client.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Name(BSTR* pName);
    ///The <b>get_Company</b> method gets the name of the company that issued this pluggable terminal.
    ///Params:
    ///    pCompany = The <b>BSTR</b> representation of the terminal's company name. The <b>BSTR</b> is allocated using
    ///               SysAllocString. The <b>BSTR</b> argument should be deallocated by the client.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Company(BSTR* pCompany);
    ///The <b>get_Version</b> method gets the terminal version.
    ///Params:
    ///    pVersion = The <b>BSTR</b> representation of the terminal version. The <b>BSTR</b> is allocated using SysAllocString.
    ///               The <b>BSTR</b> argument should be deallocated by the client.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Version(BSTR* pVersion);
    ///The <b>get_TerminalClass</b> method gets the terminal's terminal class.
    ///Params:
    ///    pTerminalClass = The <b>BSTR</b> representation of the terminal's terminal class. The <b>BSTR</b> is allocated using
    ///                     SysAllocString. It should be deallocated by the client.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_TerminalClass(BSTR* pTerminalClass);
    ///The <b>get_CLSID</b> method gets the CLSID used to <b>CoCreateInstance</b> the terminal.
    ///Params:
    ///    pCLSID = The <b>BSTR</b> representation of the CLSID. The <b>BSTR</b> is allocated using SysAllocString. The
    ///             <b>BSTR</b> argument should be deallocated by the client.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_CLSID(BSTR* pCLSID);
    ///The <b>get_Direction</b> method gets the direction supported by the terminal.
    ///Params:
    ///    pDirection = The TERMINAL_DIRECTION descriptor for the direction supported by the terminal.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Direction(TERMINAL_DIRECTION* pDirection);
    ///The <b>get_MediaTypes</b> method gets the media types supported by the terminal.
    ///Params:
    ///    pMediaTypes = Bitwise ORed list of media types supported by the terminal.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_MediaTypes(int* pMediaTypes);
}

///The <b>ITPluggableTerminalSuperclassInfo</b> interface exposes methods that get the name and CLSID of a pluggable
///terminal class. The IEnumPluggableSuperclassInfo::Next and ITTerminalSupport2::get_PluggableSuperclasses methods
///create the <b>ITPluggableTerminalSuperclassInfo</b> interface.
@GUID("6D54E42C-4625-4359-A6F7-631999107E05")
interface ITPluggableTerminalSuperclassInfo : IDispatch
{
    ///The <b>get_Name</b> method gets the terminal's friendly name.
    ///Params:
    ///    pName = The <b>BSTR</b> representation of the friendly name. The <b>BSTR</b> is allocated using SysAllocString. The
    ///            <b>BSTR</b> argument should be deallocated by the client.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Name(BSTR* pName);
    ///The <b>get_CLSID</b> method gets the CLSID used to <b>CoCreateInstance</b> the terminal.
    ///Params:
    ///    pCLSID = The <b>BSTR</b> representation of the CLSID. The <b>BSTR</b> is allocated using SysAllocString. The
    ///             <b>BSTR</b> argument should be deallocated by the client.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_CLSID(BSTR* pCLSID);
}

///The <b>ITTerminalSupport</b> interface is exposed on an Address object only if an MSP exists. The methods of this
///interface allow an application to discover available terminals and/or create one, and get pointers to required
///Terminal objects. An tapi3.itterminalsupport pointer can be obtained by calling QueryInterface on any Address
///interface, such as ITAddress. If E_NOINTERFACE is returned, the service provider associated with the address does not
///support media controls. The ITTerminalSupport2 interface is derived from the <b>ITTerminalSupport</b> interface.
///<b>ITTerminalSupport2</b> supports the retrieval of information about pluggable terminal classes and superclasses by
///C, C++, and scripting applications.
@GUID("B1EFC385-9355-11D0-835C-00AA003CCABD")
interface ITTerminalSupport : IDispatch
{
    ///The <b>get_StaticTerminals</b> method creates a collection of currently available static terminals. This method
    ///is provided for Automation client applications, such as those written in Visual Basic. C and C++ applications
    ///must use the EnumerateStaticTerminals method.
    ///Params:
    ///    pVariant = Pointer to a <b>VARIANT</b>, which TAPI will fill in with an ITCollection of ITTerminal interface pointers.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter is not
    ///    a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_StaticTerminals(VARIANT* pVariant);
    ///The <b>EnumerateStaticTerminals</b> method enumerates the currently available static terminals associated with
    ///the address. This method is provided for C and C++ applications. Automation client applications, such as those
    ///written in Visual Basic, must use the get_StaticTerminals method.
    ///Params:
    ///    ppTerminalEnumerator = Pointer to an IEnumTerminal enumerator.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppTerminalEnumerator</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT EnumerateStaticTerminals(IEnumTerminal* ppTerminalEnumerator);
    ///The <b>get_DynamicTerminalClasses</b> method creates a collection of currently available dynamic terminals. This
    ///method is provided for Automation client applications, such as those written in Visual Basic. C and C++
    ///applications must use the EnumerateDynamicTerminalClasses method.
    ///Params:
    ///    pVariant = Pointer to a <b>VARIANT</b> containing an ITCollection of terminal classes in a string (<b>BSTR</b>) format.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pVariant</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_DynamicTerminalClasses(VARIANT* pVariant);
    ///The <b>EnumerateDynamicTerminalClasses</b> method enumerates the currently available dynamic terminal classes
    ///that are supported. This method is provided for C and C++ applications. Automation client applications, such as
    ///those written in Visual Basic, must use the get_DynamicTerminalClasses method.
    ///Params:
    ///    ppTerminalClassEnumerator = Pointer to an IEnumTerminalClass enumerator. TAPI returns these classes as GUIDs.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppTerminalClassEnumerator</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT EnumerateDynamicTerminalClasses(IEnumTerminalClass* ppTerminalClassEnumerator);
    ///The <b>CreateTerminal</b> method creates and initializes a new ITTerminal object based on the dynamic terminal
    ///class and media. The terminal class is identified by a GUID. The GUID must be converted to a string using
    ///StringFromIID to pass to this method.
    ///Params:
    ///    pTerminalClass = Pointer to <b>BSTR</b> containing the terminal class (GUID) for the new terminal object.
    ///    lMediaType = Pointer to the media type for the new terminal object.
    ///    Direction = TERMINAL_DIRECTION descriptor of the terminal direction.
    ///    ppTerminal = Pointer to the ITTerminal object created.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pTerminalClass</i> or
    ///    <i>lMediaType</i> parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt>
    ///    </dl> </td> <td width="60%"> The <i>ppTerminal</i> parameter is not a valid pointer. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    create the ITTerminal object. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_MEDIATYPE</b></dt> </dl> </td>
    ///    <td width="60%"> The <i>lMediaType</i> parameter is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_NOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> Dynamic terminal creation is not supported.
    ///    </td> </tr> </table>
    ///    
    HRESULT CreateTerminal(BSTR pTerminalClass, int lMediaType, TERMINAL_DIRECTION Direction, 
                           ITTerminal* ppTerminal);
    ///The <b>GetDefaultStaticTerminal</b> method gets the default static terminal for the media type specified.
    ///Params:
    ///    lMediaType = Media type of the required terminal.
    ///    Direction = TERMINAL_DIRECTION descriptor of the terminal direction.
    ///    ppTerminal = Pointer to the ITTerminal interface. <b>NULL</b> if no terminal is available.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No terminal is available.
    ///    *<i>ppTerminal</i> will be returned as <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>lMediaType</i> parameter is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_MEDIATYPE</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>lMediaType</i> parameter is not a valid media type. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to create the Terminal
    ///    object. </td> </tr> </table>
    ///    
    HRESULT GetDefaultStaticTerminal(int lMediaType, TERMINAL_DIRECTION Direction, ITTerminal* ppTerminal);
}

///The <b>ITTerminalSupport2</b> interface is derived from the ITTerminalSupport interface. <b>ITTerminalSupport2</b>
///supports the retrieval of information about pluggable terminal classes and superclasses by C, C++, and scripting
///applications.
@GUID("F3EB39BC-1B1F-4E99-A0C0-56305C4DD591")
interface ITTerminalSupport2 : ITTerminalSupport
{
    ///The <b>get_PluggableSuperclasses</b> method returns a collection of ITPluggableTerminalSuperclassInfo superclass
    ///information interface pointers. This method is intended for Visual Basic and scripting applications. C/C++
    ///applications can use the EnumeratePluggableSuperclasses method.
    ///Params:
    ///    pVariant = Pointer to a <b>VARIANT</b> containing an ITCollection of ITPluggableTerminalSuperclassInfo interface
    ///               pointers.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The method failed. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter is not
    ///    a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_PluggableSuperclasses(VARIANT* pVariant);
    ///The <b>EnumeratePluggableSuperclasses</b> method enumerates the pluggable terminal superclasses registered on the
    ///current system. This method is intended for Visual Basic and scripting applications. C/C++ applications must use
    ///the get_PluggableSuperClasses method.
    ///Params:
    ///    ppSuperclassEnumerator = Pointer to the IEnumPluggableSuperclassInfo interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The method failed. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppSuperclassEnumerator</i>
    ///    parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT EnumeratePluggableSuperclasses(IEnumPluggableSuperclassInfo* ppSuperclassEnumerator);
    ///The <b>get_PluggableTerminalClasses</b> method returns a collection of ITPluggableTerminalClassInfo terminal
    ///class information interface pointers. This method is intended for Visual Basic and scripting applications. C/C++
    ///applications can use the EnumeratePluggableTerminalClasses method.
    ///Params:
    ///    bstrTerminalSuperclass = The <b>BSTR</b> representation of the CLSID for the terminal superclass.
    ///    lMediaType = Bitwise ORed list of media types supported by the terminal classes.
    ///    pVariant = Pointer to a <b>VARIANT</b> containing an ITCollection of ITPluggableTerminalClassInfo interface pointers.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>lMediaType</i> parameter
    ///    is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The
    ///    method failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    The <i>bstrTerminalSuperclass</i> or <i>pVariant</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_PluggableTerminalClasses(BSTR bstrTerminalSuperclass, int lMediaType, VARIANT* pVariant);
    ///The <b>EnumeratePluggableTerminalClasses</b> method enumerates the pluggable terminal classes registered under a
    ///given superclass. This method is intended for C/C++ applications. Visual Basic and scripting applications must
    ///use the get_PluggableTerminalClasses method.
    ///Params:
    ///    iidTerminalSuperclass = CLSID for the terminal superclass.
    ///    lMediaType = Bitwise ORed list of media types supported by the terminal classes.
    ///    ppClassEnumerator = Pointer to the IEnumPluggableTerminalClassInfo interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>lMediaType</i> parameter
    ///    is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The
    ///    method failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    The <i>ppClassEnumerator</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT EnumeratePluggableTerminalClasses(GUID iidTerminalSuperclass, int lMediaType, 
                                              IEnumPluggableTerminalClassInfo* ppClassEnumerator);
}

///The <b>ITAddress</b> interface is the base interface for the Address object. Applications use this interface to get
///information about and use the Address object. The ITAddress2 interface derives from the <b>ITAddress</b> interface.
///<b>ITAddress2</b> adds methods to the Address object in order to support phone devices. The IEnumAddress::Next and
///ITTapi::get_Addresses methods create the <b>ITAddress</b> interface.
@GUID("B1EFC386-9355-11D0-835C-00AA003CCABD")
interface ITAddress : IDispatch
{
    ///The <b>get_State</b> method gets the current state of the address in <i>pAddressState</i>.
    ///Params:
    ///    pAddressState = Pointer to a member of ADDRESS_STATE.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pAddressState</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_State(ADDRESS_STATE* pAddressState);
    ///The <b>get_AddressName</b> method gets the displayable name of the address.
    ///Params:
    ///    ppName = Pointer to <b>BSTR</b> containing a displayable address name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppName</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_AddressName(BSTR* ppName);
    ///The <b>get_ServiceProviderName</b> method gets the name of the Telephony Service Provider (TSP) that supports
    ///this address: for example, Unimdm.tsp for the Unimodem service provider or H323.tsp for the H323 service
    ///provider.
    ///Params:
    ///    ppName = Pointer to <b>BSTR</b> containing the service provider name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppName</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_NODRIVER</b></dt> </dl> </td> <td width="60%"> No service provider was found that supports the
    ///    current address. </td> </tr> </table>
    ///    
    HRESULT get_ServiceProviderName(BSTR* ppName);
    ///The <b>get_TAPIObject</b> method gets a pointer to the TAPI object that owns this address.
    ///Params:
    ///    ppTapiObject = Pointer to ITTAPI interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppTapiObject</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_TAPIObject(ITTAPI* ppTapiObject);
    ///The <b>CreateCall</b> method creates a new Call object that can be used to make an outgoing call and returns a
    ///pointer to the object's ITBasicCallControl interface. The newly created call is in the CS_IDLE state and has no
    ///media or terminals selected. Acceptable input values for call address, address type, and media types are specific
    ///to the telephony service provider that supports the current address. For information on TSPs shipped with Windows
    ///2000, see About The Telephony Service Provider (TSP). For third party TSPs, see the documentation provided by the
    ///vender.
    ///Params:
    ///    pDestAddress = This <b>BSTR</b> string contains a destination address. The format is provider-specific. This pointer can be
    ///                   <b>NULL</b> for non-dialed addresses (such as with a hot phone) or when all dialing is performed using
    ///                   ITBasicCallControl::Dial. <b>NULL</b> in combination with a <b>NULL</b><i>pGroupID</i> in
    ///                   ITBasicCallControl::Pickup results in a group pickup. Service providers that have inverse multiplexing
    ///                   capabilities can allow an application to specify multiple addresses at once.
    ///    lAddressType = Contains an address type constant, such as LINEADDRESSTYPE_PHONENUMBER, which describes the format of the
    ///                   address. The value must be valid for this address. Use ITAddressCapabilities::get_AddressCapability with
    ///                   <i>AddressCap</i> set to AC_ADDRESSTYPES to verify the value.
    ///    lMediaTypes = Identifies the media type or types that will be involved in the call session.
    ///    ppCall = Pointer to ITBasicCallControl interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The address type,
    ///    <i>lAddressType</i>, is invalid or specifies more than one address type. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>ppCall</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT CreateCall(BSTR pDestAddress, int lAddressType, int lMediaTypes, ITBasicCallControl* ppCall);
    ///The <b>get_Calls</b> method creates a collection of calls currently active on the address. This method is
    ///provided for Automation client applications, such as those written in Visual Basic. C and C++ applications must
    ///use the EnumerateCalls method.
    ///Params:
    ///    pVariant = Pointer to a <b>VARIANT</b> containing an ITCollection of ITCallInfo interface pointers (call objects).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter is not
    ///    a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Calls(VARIANT* pVariant);
    ///The <b>EnumerateCalls</b> method enumerates calls on the current address. This method is provided for C and C++
    ///applications. Automation client applications, such as those written in Visual Basic, must use the get_Calls
    ///method.
    ///Params:
    ///    ppCallEnum = Pointer to an IEnumCall interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppCallEnum</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT EnumerateCalls(IEnumCall* ppCallEnum);
    ///The <b>get_DialableAddress</b> method gets the <b>BSTR</b> which can be used to connect to this address. The
    ///<b>BSTR</b> corresponds to the destination address string that another application would use to connect to this
    ///address, such as a phone number or an e-mail name.
    ///Params:
    ///    pDialableAddress = Pointer to <b>BSTR</b> containing the dialable address string. This will match the <i>pDestAddress</i>
    ///                       argument of ITAddress::CreateCall.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pDialableAddress</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_DialableAddress(BSTR* pDialableAddress);
    ///The <b>CreateForwardInfoObject</b> method creates the forwarding information object and returns an
    ///ITForwardInformation interface pointer. This interface exposes methods that allow an application to control
    ///aspects of how a call is forwarded, such as whether internal calls will be handled differently than external
    ///calls.
    ///Params:
    ///    ppForwardInfo = Pointer to ITForwardInformation interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppForwardInfo</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT CreateForwardInfoObject(ITForwardInformation* ppForwardInfo);
    ///The Forward method forwards calls destined for the address according to the forwarding instructions contained in
    ///ITForwardInformation. If <i>pForwardInfo</i> is set to <b>NULL</b>, forwarding is canceled.
    ///Params:
    ///    pForwardInfo = Pointer to ITForwardInformation interface, or set to <b>NULL</b> to cancel forwarding.
    ///    pCall = Pointer to ITBasicCallControl interface for the consultation call, if required by the telephony environment.
    ///            May be <b>NULL</b> if not required.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The address does not support
    ///    forwarding, or <i>pCall</i> does not point to a valid call. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>pForwardInfo</i> or <i>pCall</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>LINEERR_</b></dt>
    ///    </dl> </td> <td width="60%"> See LineForward for error codes returned from this TAPI 2.1 function. </td>
    ///    </tr> </table>
    ///    
    HRESULT Forward(ITForwardInformation pForwardInfo, ITBasicCallControl pCall);
    ///The <b>get_CurrentForwardInfo</b> method gets a pointer to the current forwarding information object.
    ///Params:
    ///    ppForwardInfo = Pointer to ITForwardInformation interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method not implemented. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory
    ///    exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>LINEERR_INVALPOINTER</b></dt>
    ///    </dl> </td> <td width="60%"> The <i>ppForwardInfo</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_CurrentForwardInfo(ITForwardInformation* ppForwardInfo);
    ///The <b>put_MessageWaiting</b> method sets the status of the message waiting on the address.
    ///Params:
    ///    fMessageWaiting = Status of message waiting to be set.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>fMessageWaiting</i>
    ///    parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT put_MessageWaiting(short fMessageWaiting);
    ///The <b>get_MessageWaiting</b> method determines if the address has a message waiting.
    ///Params:
    ///    pfMessageWaiting = If VARIANT_TRUE is returned, a message is waiting; if VARIANT_FALSE is returned, no message is waiting.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pfMessageWaiting</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_MessageWaiting(short* pfMessageWaiting);
    ///The <b>put_DoNotDisturb</b> method sets the do not disturb status. The do not disturb feature may not be
    ///available on all addresses.
    ///Params:
    ///    fDoNotDisturb = If VARIANT_TRUE, the do not disturb feature will be activated. If VARIANT_FALSE, the do not disturb feature
    ///                    will be deactivated and all forwarding canceled.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>fDoNotDisturb</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL
    ///    timed it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT put_DoNotDisturb(short fDoNotDisturb);
    ///The <b>get_DoNotDisturb</b> method gets the current status of the do not disturb feature on the address. The do
    ///not disturb feature may not be available on all addresses.
    ///Params:
    ///    pfDoNotDisturb = If VARIANT_TRUE, the do not disturb feature has been activated. If VARIANT_FALSE, the do not disturb feature
    ///                     is not active.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OPERATIONUNAVAIL</b></dt> </dl> </td> <td width="60%"> Operation unavailable.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_NOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> This
    ///    operation is not supported on this address. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt>
    ///    </dl> </td> <td width="60%"> The <i>pfDoNotDisturb</i> parameter is not a valid pointer. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_DoNotDisturb(short* pfDoNotDisturb);
}

///The <b>ITAddress2</b> interface derives from the ITAddress interface. <b>ITAddress2</b> adds methods to the Address
///object in order to support phone devices. All Address objects enumerated from TAPI 3.1 automatically implement this
///interface.
@GUID("B0AE5D9B-BE51-46C9-B0F7-DFA8A22A8BC4")
interface ITAddress2 : ITAddress
{
    ///The <b>get_Phones</b> method returns a VARIANT pointer to an ITCollection of phone objects corresponding to the
    ///phone devices that can be used with this address. This method is intended for Visual Basic and scripting
    ///applications. C/C++ applications should use the EnumeratePhones method instead.
    ///Params:
    ///    pPhones = Pointer to a VARIANT containing an ITCollection of ITPhone interface pointers.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Phones(VARIANT* pPhones);
    ///The <b>EnumeratePhones</b> method enumerates the phone objects corresponding to the phone devices that can be
    ///used with this address. This method is intended for C/C++ applications. Visual Basic and scripting applications
    ///must use the get_Phones method.
    ///Params:
    ///    ppEnumPhone = Pointer to the new IEnumPhone interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnumPhone</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The method failed for unknown reasons. </td> </tr>
    ///    </table>
    ///    
    HRESULT EnumeratePhones(IEnumPhone* ppEnumPhone);
    ///The <b>GetPhoneFromTerminal</b> method returns the phone object associated with the terminal. Only one phone can
    ///be associated with a terminal.
    ///Params:
    ///    pTerminal = Pointer to the ITTerminal interface.
    ///    ppPhone = Pointer to the ITPhone interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPhoneFromTerminal(ITTerminal pTerminal, ITPhone* ppPhone);
    ///The <b>get_PreferredPhones</b> method returns a collection of phone objects corresponding to the phone devices
    ///that are preferred for use with this address. This method is intended for Visual Basic and scripting
    ///applications. C/C++ applications should use the EnumeratePreferredPhones method instead.
    ///Params:
    ///    pPhones = Pointer to a <b>VARIANT</b> containing an ITCollection of ITPhone interface pointers.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pPhones</i> parameter is not
    ///    a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> There is not enough memory to allocate the collection object. </td> </tr> </table>
    ///    
    HRESULT get_PreferredPhones(VARIANT* pPhones);
    ///The <b>EnumeratePreferredPhones</b> method enumerates the preferred phone objects for this address. This method
    ///is intended for C/C++ applications. Visual Basic and scripting applications must use the get_PreferredPhones
    ///method.
    ///Params:
    ///    ppEnumPhone = Pointer to the location where, on success, this method will place a pointer to an enumeration object that
    ///                  contains the returned list of phones.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnumPhone</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> There is not enough memory to allocate the enumeration object. </td> </tr> </table>
    ///    
    HRESULT EnumeratePreferredPhones(IEnumPhone* ppEnumPhone);
    ///The <b>get_EventFilter</b> method retrieves the current filter settings for the current address and a given
    ///TAPI_EVENT value. If no filters are set for an address, no event information for that address will be sent to the
    ///application.
    ///Params:
    ///    TapiEvent = The TAPI_EVENT descriptor of event type information being checked.
    ///    lSubEvent = Subevent value. <b>NULL</b> if not applicable.
    ///    pEnable = Pointer to VARIANT_BOOL indicating whether the current event is required by the application.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_EventFilter(TAPI_EVENT TapiEvent, int lSubEvent, short* pEnable);
    ///The <b>put_EventFilter</b> method sets an event filter for the current address. If no event filters are set, the
    ///application will not be notified of events on this address.
    ///Params:
    ///    TapiEvent = The TAPI_EVENT descriptor of the event type.
    ///    lSubEvent = Subevent descriptor.
    ///    bEnable = VARIANT_TRUE if the application requires notification of this event type. VARIANT_FALSE if the application
    ///              does not require notifications for this event.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_EventFilter(TAPI_EVENT TapiEvent, int lSubEvent, short bEnable);
    ///The <b>DeviceSpecific</b> method enables service providers to provide access to features not offered by other
    ///TAPI functions. The meaning of the extensions are device specific, and taking advantage of these extensions
    ///requires the application to be fully aware of them. This method is provided for C and C++ applications.
    ///Automation client applications, such as those written in Visual Basic, must use the DeviceSpecificVariant method.
    ///Params:
    ///    pCall = Pointer to the ITCallInfo interface of the call object.
    ///    pParams = Pointer to a memory area used to hold a parameter block. The format of this parameter block is device
    ///              specific; TAPI passes its contents between the application and the service provider.
    ///    dwSize = Size, in bytes, of the parameter block area.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pParams</i> or <i>pCall</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT DeviceSpecific(ITCallInfo pCall, ubyte* pParams, uint dwSize);
    ///The <b>DeviceSpecificVariant</b> method enables service providers to provide access to features not offered by
    ///other TAPI functions. The meaning of the extensions are device specific, and taking advantage of these extensions
    ///requires the application to be fully aware of them. This method is provided for Automation client applications,
    ///such as those written in Visual Basic. C and C++ applications must use the DeviceSpecific method.
    ///Params:
    ///    pCall = Pointer to the ITCallInfo interface of the call object.
    ///    varDevSpecificByteArray = VARIANT containing the parameter block. The format of this parameter block is device specific; TAPI passes
    ///                              its contents between the application and the service provider.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pCall</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT DeviceSpecificVariant(ITCallInfo pCall, VARIANT varDevSpecificByteArray);
    ///The <b>NegotiateExtVersion</b> method allows an application to negotiate an extension version to use with the
    ///specified line device. This method need not be called if the application does not support provider-specific
    ///extensions.
    ///Params:
    ///    lLowVersion = Least recent extension version of the extension identifier returned by <b>NegotiateExtVersion</b> that the
    ///                  application is compliant with. The high-order word is the major version number; the low-order word is the
    ///                  minor version number.
    ///    lHighVersion = Most recent extension version of the extension identifier returned by <b>NegotiateExtVersion</b> that the
    ///                   application is compliant with. The high-order word is the major version number; the low-order word is the
    ///                   minor version number.
    ///    plExtVersion = Pointer to a <b>long</b> that contains the extension version number that was negotiated. If negotiation
    ///                   succeeds, this number is in the range between <i>lLowVersion</i> and <i>lHighVersion</i>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The version entered in either
    ///    <i>lLowVersion</i> or <i>lHighVersion</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>plExtVersion</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT NegotiateExtVersion(int lLowVersion, int lHighVersion, int* plExtVersion);
}

///The <b>ITAddressCapabilities</b> interface is used to obtain information about an address's capabilities. It is on
///the Address object, and an application can access it by calling <b>QueryInterface</b> on the Address object.
@GUID("8DF232F5-821B-11D1-BB5C-00C04FB6809F")
interface ITAddressCapabilities : IDispatch
{
    ///The <b>get_AddressCapability</b> method gets the capability value for a given ADDRESS_CAPABILITY.
    ///Params:
    ///    AddressCap = Descriptor for desired address capability.
    ///    plCapability = Value of address capability.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>AddressCap</i>
    ///    parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plCapability</i> parameter in not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT get_AddressCapability(ADDRESS_CAPABILITY AddressCap, int* plCapability);
    ///The <b>get_AddressCapabilityString</b> method gets the capability string for a given ADDRESS_CAPABILITY_STRING.
    ///Params:
    ///    AddressCapString = Descriptor for desired address capability string.
    ///    ppCapabilityString = Pointer to <b>BSTR</b> value of address capability. <b>NULL</b> is a possible return value if the TSP does
    ///                         not provide a value for <i>AddressCapString</i>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>AddressCapString</i>
    ///    parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppCapabilityString</i> parameter is not a valid pointer. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>TAPI_E_NOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> TAPI version is not 3.0 or
    ///    higher. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_AddressCapabilityString(ADDRESS_CAPABILITY_STRING AddressCapString, BSTR* ppCapabilityString);
    ///The <b>get_CallTreatments</b> method gets call treatments. This method is provided for Automation client
    ///applications, such as those written in Visual Basic and scripting languages.
    ///Params:
    ///    pVariant = Pointer to a <b>VARIANT</b> containing an ITCollection of call treatments.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td> <td width="60%"> Call state must be
    ///    CS_IDLE. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method
    ///    not implemented. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_CallTreatments(VARIANT* pVariant);
    ///The <b>EnumerateCallTreatments</b> method gets call treatments. This method is provided for applications written
    ///in C/C++ and Java.
    ///Params:
    ///    ppEnumCallTreatment = Pointer to call treatment enumeration.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method not implemented. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory
    ///    exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT EnumerateCallTreatments(IEnumBstr* ppEnumCallTreatment);
    ///The <b>get_CompletionMessages</b> gets completion messages. This method is provided for Automation client
    ///applications, such as those written in Visual Basic and scripting languages.
    ///Params:
    ///    pVariant = Pointer to <b>VARIANT</b> containing completion messages.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method not implemented. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient
    ///    memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_CompletionMessages(VARIANT* pVariant);
    ///The <b>EnumerateCompletionMessages</b> method gets completion messages. This method is provided for applications
    ///written in C/C++ and Java.
    ///Params:
    ///    ppEnumCompletionMessage = Pointer to enumeration of completion messages.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method not implemented. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory
    ///    exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT EnumerateCompletionMessages(IEnumBstr* ppEnumCompletionMessage);
    ///The <b>get_DeviceClasses</b> method gets device classes. This method is provided for Automation client
    ///applications, such as those written in Visual Basic and scripting languages.
    ///Params:
    ///    pVariant = Pointer to <b>VARIANT</b> containing device classes.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method not implemented. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient
    ///    memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_DeviceClasses(VARIANT* pVariant);
    ///The <b>EnumerateDeviceClasses</b> method gets device classes. This method is provided for applications written in
    ///C/C++ and Java.
    ///Params:
    ///    ppEnumDeviceClass = Pointer to enumeration of device classes.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method not implemented. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory
    ///    exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT EnumerateDeviceClasses(IEnumBstr* ppEnumDeviceClass);
}

///The <b>ITPhone</b> interface is the main interface for the new Phone objects in the TAPI 3.1 object model. This
///interface allows access to the phone device at a level comparable to that available with the TAPI 2.<i>x</i> C API.
///The interface also allows the application to determine which addresses the phone is usable on, and to get a list of
///terminals associated with the phone. The IEnumPhone::Next and ITPhoneEvent::get_Phone methods create the
///<b>ITPhone</b> interface.
@GUID("09D48DB4-10CC-4388-9DE7-A8465618975A")
interface ITPhone : IDispatch
{
    ///The <b>Open</b> method opens this phone device. The phone device remains open until the application calls
    ///ITPhone::Close or until TAPI is shut down. This method is analogous to the TAPI 2.<i>x</i> phoneOpen function;
    ///please see the TAPI 2.<i>x</i> documentation for more information.
    ///Params:
    ///    Privilege = The PHONE_PRIVILEGE descriptor for the application's privilege status with respect to the phone device.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Open(PHONE_PRIVILEGE Privilege);
    ///The <b>Close</b> method closes this phone device. The phone device remains closed until the application calls the
    ///ITPhone::Open method. For more information, see the following Remarks section. This method is analogous to the
    ///TAPI 2.<i>x</i> phoneOpen function; please see the TAPI 2.<i>x</i> documentation for more information.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Close();
    ///The <b>get_Addresses</b> method returns a collection of addresses that the phone can be used on. The application
    ///does not have to call ITPhone::Open before executing this method. This method is intended for Visual Basic and
    ///scripting applications. C/C++ applications should use the EnumerateAddresses method instead.
    ///Params:
    ///    pAddresses = Pointer to a VARIANT containing an ITCollection of ITAddress interface pointers.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Addresses(VARIANT* pAddresses);
    ///The <b>EnumerateAddresses</b> method enumerates the addresses that the phone can be used on. The application does
    ///not have to call ITPhone::Open before executing this method. This method is intended for C/C++ applications.
    ///Visual Basic and scripting applications must use the get_Addresses method.
    ///Params:
    ///    ppEnumAddress = Pointer to the IEnumAddress interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnumerateAddresses(IEnumAddress* ppEnumAddress);
    ///The <b>get_PhoneCapsLong</b> method gets a <b>DWORD</b> capability of the phone, based on the PHONECAPS_LONG enum
    ///passed in. The application does not have to call ITPhone::Open before executing this method.
    ///Params:
    ///    pclCap = The PHONECAPS_LONG descriptor for the phone capability.
    ///    plCapability = Capability value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_PhoneCapsLong(PHONECAPS_LONG pclCap, int* plCapability);
    ///The <b>get_PhoneCapsString</b> method gets a string capability/information about the phone, based on the
    ///PHONECAPS_STRING enum passed in. The application does not have to call ITPhone::Open before executing this
    ///method.
    ///Params:
    ///    pcsCap = The PHONECAPS_STRING descriptor for the phone capability.
    ///    ppCapability = Capability value. The <b>BSTR</b> is allocated using SysAllocString. The <b>BSTR</b> argument should be
    ///                   deallocated by the client.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_PhoneCapsString(PHONECAPS_STRING pcsCap, BSTR* ppCapability);
    ///The <b>get_Terminals</b> method retrieves a collection of terminals that are associated with the phone. The
    ///application does not have to call ITPhone::Open before executing this method.
    ///Params:
    ///    pAddress = Pointer to the ITAddress interface.
    ///    pTerminals = Pointer to a <b>VARIANT</b> containing an ITCollection of ITTerminal interface pointers.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Terminals(ITAddress pAddress, VARIANT* pTerminals);
    ///The <b>EnumerateTerminals</b> method retrieves an enumeration of terminals that are associated with the phone.
    ///The application does not have to call ITPhone::Open before executing this method.
    ///Params:
    ///    pAddress = Pointer to ITAddress interface.
    ///    ppEnumTerminal = Pointer to the IEnumTerminal interface that enumerates terminals.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT EnumerateTerminals(ITAddress pAddress, IEnumTerminal* ppEnumTerminal);
    ///The <b>get_ButtonMode</b> method retrieves the button mode associated with a particular button. The application
    ///must call ITPhone::Open before invoking this method; otherwise, the invocation fails.
    ///Params:
    ///    lButtonID = Button identifier. For more information, see the following Remarks section.
    ///    pButtonMode = The PHONE_BUTTON_MODE descriptor for the button's mode.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_ButtonMode(int lButtonID, PHONE_BUTTON_MODE* pButtonMode);
    ///The <b>put_ButtonMode</b> method sets the button mode.
    ///Params:
    ///    lButtonID = Button identifier.
    ///    ButtonMode = The PHONE_BUTTON_MODE descriptor for the button's mode.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_ButtonMode(int lButtonID, PHONE_BUTTON_MODE ButtonMode);
    ///The <b>get_ButtonFunction</b> method retrieves the button function associated with a particular button. The
    ///application must call the ITPhone::Open method before invoking this method; otherwise, the method fails.
    ///Params:
    ///    lButtonID = Button identifier.
    ///    pButtonFunction = The PHONE_BUTTON_FUNCTION descriptor for the button's function.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_ButtonFunction(int lButtonID, PHONE_BUTTON_FUNCTION* pButtonFunction);
    ///The <b>put_ButtonFunction</b> method sets the button function.
    ///Params:
    ///    lButtonID = Button identifier.
    ///    ButtonFunction = The PHONE_BUTTON_FUNCTION descriptor for the button's function.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_ButtonFunction(int lButtonID, PHONE_BUTTON_FUNCTION ButtonFunction);
    ///The <b>get_ButtonText</b> method retrieves the button text associated with a particular button. The application
    ///must call ITPhone::Open before invoking this method; otherwise, the invocation fails. See the TAPI 2.<i>x</i>
    ///documentation for more information about the concept of button text.
    ///Params:
    ///    lButtonID = Button identifier.
    ///    ppButtonText = The <b>BSTR</b> representation of the button text. The <b>BSTR</b> is allocated using SysAllocString. The
    ///                   <b>BSTR</b> argument should be deallocated by the client.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_ButtonText(int lButtonID, BSTR* ppButtonText);
    ///The <b>put_ButtonText</b> method sets the button text.
    ///Params:
    ///    lButtonID = Button identifier.
    ///    bstrButtonText = The BS<b></b>TR representation of the button text.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_ButtonText(int lButtonID, BSTR bstrButtonText);
    ///The <b>get_ButtonState</b> method retrieves the button state associated with a particular button. The application
    ///must call the ITPhone::Open method before invoking this method; otherwise, the invocation fails.
    ///Params:
    ///    lButtonID = Button identifier.
    ///    pButtonState = The PHONE_BUTTON_STATE descriptor for the button's state.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_ButtonState(int lButtonID, PHONE_BUTTON_STATE* pButtonState);
    ///The <b>get_HookSwitchState</b> method retrieves the current hookswitch state for a particular hookswitch device
    ///on the phone. The application must call ITPhone::Open before invoking this method; otherwise, the invocation
    ///fails.
    ///Params:
    ///    HookSwitchDevice = The PHONE_HOOK_SWITCH_DEVICE descriptor for the hookswitch type.
    ///    pHookSwitchState = The PHONE_HOOK_SWITCH_STATE descriptor for the hookswitch status.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_HookSwitchState(PHONE_HOOK_SWITCH_DEVICE HookSwitchDevice, 
                                PHONE_HOOK_SWITCH_STATE* pHookSwitchState);
    ///The <b>put_HookSwitchState</b> method sets the current hookswitch state for a particular hookswitch device on the
    ///phone. The application must call ITPhone::Open before invoking this method; otherwise, the invocation fails.
    ///Params:
    ///    HookSwitchDevice = The PHONE_HOOK_SWITCH_DEVICE descriptor for the hookswitch type.
    ///    HookSwitchState = The PHONE_HOOK_SWITCH_STATE descriptor for the hookswitch status.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_HookSwitchState(PHONE_HOOK_SWITCH_DEVICE HookSwitchDevice, PHONE_HOOK_SWITCH_STATE HookSwitchState);
    ///The <b>put_RingMode</b> method requests that the phone change its ring mode. The application must call
    ///ITPhone::Open before invoking this method; otherwise, the invocation fails.
    ///Params:
    ///    lRingMode = Ring mode.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_RingMode(int lRingMode);
    ///The <b>get_RingMode</b> method retrieves the current ring mode for the phone. The application must call
    ///ITPhone::Open before invoking this method; otherwise, the invocation fails.
    ///Params:
    ///    plRingMode = Phone ring mode.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_RingMode(int* plRingMode);
    ///The <b>put_RingVolume</b> method requests that the phone change its ring volume. The application must call
    ///ITPhone::Open before invoking this method; otherwise, the invocation fails.
    ///Params:
    ///    lRingVolume = Phone volume. For more information, see the following Remarks section.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_RingVolume(int lRingVolume);
    ///The <b>get_RingVolume</b> method retrieves the current ring volume for the phone. The application must call
    ///ITPhone::Open before invoking this method; otherwise, the invocation fails.
    ///Params:
    ///    plRingVolume = Ring volume.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_RingVolume(int* plRingVolume);
    ///The <b>get_Privilege</b> method retrieves the privilege of the open phone. The application must call
    ///ITPhone::Open before invoking this method; otherwise, the invocation fails.
    ///Params:
    ///    pPrivilege = The PHONE_PRIVILEGE descriptor for the application's privilege status with respect to the phone device.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Privilege(PHONE_PRIVILEGE* pPrivilege);
    ///The <b>GetPhoneCapsBuffer</b> method gets a buffer capability/information about the phone, based on the
    ///PHONECAPS_BUFFER enum passed in. This method is intended for C/C++ applications. Visual Basic and scripting
    ///applications must use the get_PhoneCapsBuffer method.
    ///Params:
    ///    pcbCaps = The PHONECAPS_BUFFER descriptor for the phone capability.
    ///    pdwSize = Size of the buffer, in bytes.
    ///    ppPhoneCapsBuffer = Pointer to the buffer containing the values.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetPhoneCapsBuffer(PHONECAPS_BUFFER pcbCaps, uint* pdwSize, ubyte** ppPhoneCapsBuffer);
    ///The <b>get_PhoneCapsBuffer</b> method gets a buffer capability/information about the phone, based on the
    ///PHONECAPS_BUFFER enum passed in. This method is intended for Visual Basic and scripting applications. C/C++
    ///applications must use the GetPhoneCapsBuffer method.
    ///Params:
    ///    pcbCaps = The PHONECAPS_BUFFER descriptor for the phone capability.
    ///    pVarBuffer = Pointer to VARIANT containing the capability value.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_PhoneCapsBuffer(PHONECAPS_BUFFER pcbCaps, VARIANT* pVarBuffer);
    ///The <b>get_LampMode</b> method gets the current lamp mode for the given lamp.
    ///Params:
    ///    lLampID = Lamp identifier.
    ///    pLampMode = The PHONE_LAMP_MODE descriptor for the phone's lamp status.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_LampMode(int lLampID, PHONE_LAMP_MODE* pLampMode);
    ///The <b>put_LampMode</b> method sets the current lamp mode for the given lamp.
    ///Params:
    ///    lLampID = Lamp identifier.
    ///    LampMode = The PHONE_LAMP_MODE descriptor for the phone's lamp status.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_LampMode(int lLampID, PHONE_LAMP_MODE LampMode);
    ///The <b>get_Display</b> method gets the display for the phone. In TAPI, the display is simply an NxM character
    ///buffer.
    ///Params:
    ///    pbstrDisplay = The <b>BSTR</b> representation of the phone display. The <b>BSTR</b> is allocated using SysAllocString. The
    ///                   <b>BSTR</b> argument should be deallocated by the client.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Display(BSTR* pbstrDisplay);
    ///The <b>SetDisplay</b> method sets what will appear in a given row and column of the phone's display.
    ///Params:
    ///    lRow = Display row.
    ///    lColumn = Display column.
    ///    bstrDisplay = The <b>BSTR</b> representation of the value to display.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetDisplay(int lRow, int lColumn, BSTR bstrDisplay);
    ///The <b>get_PreferredAddresses</b> method returns a collection of addresses that the phone is preferred for use
    ///on. The application does not have to call ITPhone::Open before executing this method. This method is intended for
    ///Visual Basic and scripting applications. C/C++ applications will find it more convenient to use the
    ///EnumerateAddresses method.
    ///Params:
    ///    pAddresses = Pointer to a <b>VARIANT</b> containing an ITCollection of ITAddress interface pointers.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pAddresses</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> There is not enough memory to allocate the collection object. </td> </tr> </table>
    ///    
    HRESULT get_PreferredAddresses(VARIANT* pAddresses);
    ///The <b>EnumeratePreferredAddresses</b> method enumerates the preferred addresses for the phone object. The
    ///application does not have to call ITPhone::Open before executing this method. This method is intended for C/C++
    ///applications. Visual Basic and scripting applications must use the get_Addresses method.
    ///Params:
    ///    ppEnumAddress = Pointer to a location where, on success, the method places a pointer to an enumeration object that contains
    ///                    the list of addresses. For more information, see the following Remarks section.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnumAddress</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> There is not enough memory to allocate the enumeration object. </td> </tr> </table>
    ///    
    HRESULT EnumeratePreferredAddresses(IEnumAddress* ppEnumAddress);
    ///The <b>DeviceSpecific</b> method enables service providers to provide access to device specific features not
    ///offered by other TAPI functions. The meaning of the extensions are device specific, and taking advantage of these
    ///extensions requires the application to be fully aware of them. This method is provided for C and C++
    ///applications. Automation client applications, such as those written in Visual Basic, must use the
    ///DeviceSpecificVariant method.
    ///Params:
    ///    pParams = Pointer to a memory area used to hold a parameter block. The format of this parameter block is device
    ///              specific; TAPI passes its contents between the application and the service provider.
    ///    dwSize = The size, in bytes, of the parameter block area.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pParams</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT DeviceSpecific(ubyte* pParams, uint dwSize);
    ///The <b>DeviceSpecificVariant</b> method enables service providers to provide access to features not offered by
    ///other TAPI functions. The meaning of the extensions are device specific, and taking advantage of these extensions
    ///requires the application to be fully aware of them. This method is provided for Automation client applications,
    ///such as those written in Visual Basic. C and C++ applications must use the DeviceSpecific method.
    ///Params:
    ///    varDevSpecificByteArray = VARIANT containing the parameter block. The format of this parameter block is device specific; TAPI passes
    ///                              its contents between the application and the service provider.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT DeviceSpecificVariant(VARIANT varDevSpecificByteArray);
    ///The <b>NegotiateExtVersion</b> method allows an application to negotiate an extension version to use with the
    ///specified phone device. This operation need not be called if the application does not support provider specific
    ///extensions.
    ///Params:
    ///    lLowVersion = Least recent extension version of the extension identifier returned by <b>NegotiateExtVersion</b> that the
    ///                  application is compliant with. The high-order word is the major version number; the low-order word is the
    ///                  minor version number.
    ///    lHighVersion = Most recent extension version of the extension identifier returned by <b>NegotiateExtVersion</b> that the
    ///                   application is compliant with. The high-order word is the major version number; the low-order word is the
    ///                   minor version number.
    ///    plExtVersion = Pointer to a <b>long</b> that contains the extension version number that was negotiated. If negotiation
    ///                   succeeds, this number is in the range between <i>lLowVersion</i> and <i>lHighVersion</i>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The version in
    ///    <i>lHighVersion</i> or <i>lLowVersion</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>plExtVersion</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT NegotiateExtVersion(int lLowVersion, int lHighVersion, int* plExtVersion);
}

///The <b>ITAutomatedPhoneControl</b> is a fully OLE automatable and scriptable interface exposed by the TAPI phone
///object. When a phone device is opened with owner privilege, you can call the QueryInterface method on the ITPhone
///interface to obtain an <b>ITAutomatedPhoneControl</b> interface pointer. This interface performs several high-level
///phone-related functions: <ul> <li>Enable and configure automated control of the phone's tones and rings based on
///input from the phone's hookswitch and buttons.</li> <li>Enable and configure automated call handling based on the
///phone's hookswitch state. For example, when the phone goes onhook while it is handling a connected call, the phone
///object can automatically invoke ITBasicCallControl::Disconnect on that call.</li> <li>Generate specific tones on the
///audio devices associated with the phone, without accessing any audio APIs directly. The tone control allows an
///application to play tones on the audio devices associated with the phone, outside of the context of a call. Because
///these tones are not transmitted on any call, they are independent of the audio streaming functionality accessed
///through terminals.</li> <li>Ring the phone without requiring information on whether the phone has a ringer and, if
///the phone has a ringer, determine the types of rings the phone supports.</li> </ul>
@GUID("1EE1AF0E-6159-4A61-B79B-6A4BA3FC9DFC")
interface ITAutomatedPhoneControl : IDispatch
{
    ///The <b>StartTone</b> method sends control tones.
    ///Params:
    ///    Tone = PHONE_TONE descriptor of the type of tone to send, such as PT_KEYPADONE.
    ///    lDuration = Duration, in milliseconds, of the tone being sent.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT StartTone(PHONE_TONE Tone, int lDuration);
    ///The <b>StopTone</b> method ceases any tone that is currently being played. If no tone is being played, the method
    ///performs no action and returns success.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT StopTone();
    ///The <b>get_Tone</b> method returns a PHONE_TONE enum value indicating the type of tone, if any, that the phone is
    ///currently playing. If no tone is currently being played, the <b>PHONE_TONE</b> value returned is PT_SILENCE. This
    ///method has knowledge only of tones initiated by the StartTone method on this interface.
    ///Params:
    ///    pTone = PHONE_TONE descriptor of tone being played.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_Tone(PHONE_TONE* pTone);
    ///The <b>StartRinger</b> method starts the phone's ringer, specifying the ring mode and the duration of the ring.
    ///Params:
    ///    lRingMode = Ring mode. The exact meaning of this value is device-dependent. For more information, see the following
    ///                Remarks section.
    ///    lDuration = Length of ring.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT StartRinger(int lRingMode, int lDuration);
    ///The <b>StopRinger</b> method ceases any incoming ring that is currently being produced. If no ring is being
    ///produced, the method performs no action and returns success.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT StopRinger();
    ///The <b>get_Ringer</b> method returns a Boolean value indicating whether the phone is currently performing an
    ///incoming ring that was initiated by the StartRinger method on this interface.
    ///Params:
    ///    pfRinging = If VARIANT_TRUE, the phone is currently ringing.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_Ringer(short* pfRinging);
    ///The <b>put_PhoneHandlingEnabled</b> method sets the <b>PhoneHandlingEnabled</b> property. Setting the property
    ///enables or disables all the automatic phone interaction features for this phone. Features include automated
    ///control of a phone's tones and rings, and automated call handling based on a phone's hookswitch state.
    ///Params:
    ///    fEnabled = If VARIANT_TRUE, phone handling is enabled. If VARIANT_FALSE, phone handling is disabled. The default value
    ///               is VARIANT_FALSE.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT put_PhoneHandlingEnabled(short fEnabled);
    ///The <b>get_PhoneHandlingEnabled</b> method retrieves the current value of the <b>PhoneHandlingEnabled</b>
    ///property. Setting the property enables or disables all the automatic phone interaction features for this phone.
    ///Features include automated control of a phone's tones and rings, and automated call handling based on a phone's
    ///hookswitch state.
    ///Params:
    ///    pfEnabled = VARIANT_TRUE if automated phone handling is enabled, VARIANT_FALSE if automated phone handling is not
    ///                enabled. The default value is VARIANT_FALSE.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_PhoneHandlingEnabled(short* pfEnabled);
    ///The <b>put_AutoEndOfNumberTimeout</b> method sets the value of the <b>AutoEndOfNumberTimeout</b> property. The
    ///property specifies how long to wait after a digit has been pressed before it is assumed that the entire number
    ///has been gathered.
    ///Params:
    ///    lTimeout = Timeout interval to wait, in milliseconds (ms). The default value is 3000 ms.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT put_AutoEndOfNumberTimeout(int lTimeout);
    ///The <b>get_AutoEndOfNumberTimeout</b> method retrieves the current value of the <b>AutoEndOfNumberTimeout</b>
    ///property. The property specifies how long to wait after a digit has been pressed before it is assumed that the
    ///entire number has been gathered.
    ///Params:
    ///    plTimeout = Time-out interval to wait, in milliseconds (ms). The default value is 3000 ms.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_AutoEndOfNumberTimeout(int* plTimeout);
    ///The <b>put_AutoDialtone</b> method sets the value of the <b>AutoDialtone</b> property. The method enables or
    ///disables automatic dial tone response for this phone. When this feature is enabled, the phone going offhook
    ///results in a dial tone produced on the audio render device associated with the phone. No dial tone is produced if
    ///the phone was ringing when it went offhook.
    ///Params:
    ///    fEnabled = If VARIANT_TRUE, enables automatic dial tone. If VARIANT_FALSE, disables automatic dial tone. The default
    ///               value is VARIANT_TRUE.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT put_AutoDialtone(short fEnabled);
    ///The <b>get_AutoDialtone</b> method retrieves the current value of the <b>AutoDialtone</b> property. When this
    ///feature is enabled, the phone going offhook results in a dial tone produced on the audio render device associated
    ///with the phone. No dial tone is produced if the phone was ringing when it went offhook.
    ///Params:
    ///    pfEnabled = If VARIANT_TRUE, auto dial tone is enabled. If VARIANT_FALSE, auto dial tone is disabled.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_AutoDialtone(short* pfEnabled);
    ///The <b>put_AutoStopTonesOnOnHook</b> method sets the <b>AutoStopTonesOnOnHook</b> property for this phone. When
    ///this feature is enabled, the phone going onhook results in the termination of any tone produced on the audio
    ///render device associated with the phone (via a call to ITAutomatedPhoneControl::StopTone).
    ///Params:
    ///    fEnabled = If VARIANT_TRUE, enables automatic stop of tone generation if the phone goes onhook. If VARIANT_FALSE,
    ///               disables automatic stop if the phone goes onhook. The default value is VARIANT_TRUE.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT put_AutoStopTonesOnOnHook(short fEnabled);
    ///The <b>get_AutoStopTonesOnOnHook</b> method retrieves the current value of the <b>AutoStopTonesOnOnHook</b>
    ///property. When this feature is enabled, the phone going onhook results in the termination of any tone produced on
    ///the audio render device associated with the phone (via a call to ITAutomatedPhoneControl::StopTone).
    ///Params:
    ///    pfEnabled = If VARIANT_TRUE, automatic stop of tone generation upon onhook is enabled. If VARIANT_FALSE, automatic stop
    ///                of tone generation upon onhook is disabled.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_AutoStopTonesOnOnHook(short* pfEnabled);
    ///The <b>put_AutoStopRingOnOffHook</b> method sets the <b>AutoStopRingOnOffHook</b> property. When this feature is
    ///enabled, the phone going offhook results in the termination of any incoming ring produced on the phone (via a
    ///call to ITAutomatedPhoneControl::StopRinger).
    ///Params:
    ///    fEnabled = If VARIANT_TRUE, enables automatic incoming ring termination if the phone goes offhook. If VARIANT_FALSE,
    ///               disables automatic incoming ring termination if the phone goes offhook. The default value is VARIANT_TRUE.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT put_AutoStopRingOnOffHook(short fEnabled);
    ///The <b>get_AutoStopRingOnOffHook</b> method retrieves the current value of the <b>AutoStopRingOnOffHook</b>
    ///property. When this feature is enabled, the phone going offhook results in the termination of any incoming ring
    ///produced on the phone (via a call to ITAutomatedPhoneControl::StopRinger).
    ///Params:
    ///    pfEnabled = If VARIANT_TRUE, automatic incoming ring termination when the phone goes offhook is enabled. If
    ///                VARIANT_FALSE, automatic incoming ring termination when the phone goes offhook is disabled.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_AutoStopRingOnOffHook(short* pfEnabled);
    ///The <b>put_AutoKeypadTones</b> method sets the <b>AutoKeypadTones</b> property for this phone. When this feature
    ///is enabled, a digit tone is automatically played whenever a keypad button is pressed.
    ///Params:
    ///    fEnabled = If VARIANT_TRUE, automatic phone keypad tone generation is enabled. If VARIANT_FALSE, keypad tone generation
    ///               is disabled. The default value is VARIANT_TRUE.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT put_AutoKeypadTones(short fEnabled);
    ///The <b>get_AutoKeypadTones</b> method gets the <b>AutoKeypadTones</b> property for this phone. When this feature
    ///is enabled, a digit tone is automatically played whenever a keypad button is pressed.
    ///Params:
    ///    pfEnabled = VARIANT_TRUE if automatic phone keypad feedback tone generation is enabled for this phone. VARIANT_FALSE if
    ///                automatic phone keypad feedback tone generation is disabled for this phone.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_AutoKeypadTones(short* pfEnabled);
    ///The <b>put_AutoKeypadTonesMinimumDuration</b> method sets the value of the <b>AutoKeypadTonesMinimumDuration</b>
    ///property. The property specifies how long to play keypad tones on PBS_DOWN.
    ///Params:
    ///    lDuration = Minimum duration of keypad tones, in milliseconds (ms). The default value is 250 ms. If the minimum duration
    ///                elapses without a PBS_UP event, the keypad tone continues until the PBS_UP event is received.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT put_AutoKeypadTonesMinimumDuration(int lDuration);
    ///The <b>get_AutoKeypadTonesMinimumDuration</b> method retrieves the current value of the
    ///<b>AutoKeypadTonesMinimumDuration</b> property. The property specifies how long to play keypad tones on PBS_DOWN.
    ///Params:
    ///    plDuration = Minimum duration of keypad tones, in milliseconds (ms). The default value is 250 ms. If the minimum duration
    ///                 elapses without a PBS_UP event, the keypad tone continues until the PBS_UP event is received.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_AutoKeypadTonesMinimumDuration(int* plDuration);
    ///The <b>put_AutoVolumeControl</b> method sets the <b>AutoVolumeControl</b> property for this phone. When this
    ///feature is enabled, the phone's wave output volume is automatically adjusted whenever a volume button is pressed.
    ///The volume is adjusted by the amount indicated by the <b>AutoVolumeControlStep</b> property.
    ///Params:
    ///    fEnabled = If VARIANT_TRUE, enables automatic volume control. If VARIANT_FALSE, disables automatic volume control. The
    ///               default value is VARIANT_TRUE.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT put_AutoVolumeControl(short fEnabled);
    ///The <b>get_AutoVolumeControl</b> method retrieves the current value of the <b>AutoVolumeControl</b> property.
    ///When this feature is enabled, the phone's wave output volume is automatically adjusted whenever a volume button
    ///is pressed. The volume is adjusted by the amount indicated by the <b>AutoVolumeControlStep</b> property.
    ///Params:
    ///    fEnabled = VARIANT_TRUE indicates that automatic volume control is enabled. VARIANT_FALSE indicates that automatic
    ///               volume control is disabled.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_AutoVolumeControl(short* fEnabled);
    ///The <b>put_AutoVolumeControlStep</b> method sets the <b>AutoVolumeControlStep</b> property. The property
    ///determines the amount that the phone volume is adjusted when the volume button is pressed.
    ///Params:
    ///    lStepSize = Volume control step, in milliseconds. The default value of the <b>AutoVolumeControlStep</b> property is 4096.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT put_AutoVolumeControlStep(int lStepSize);
    ///The <b>get_AutoVolumeControlStep</b> method retrieves the current value of the <b>AutoVolumeControlStep</b>
    ///property. The property determines the amount that the phone volume is adjusted when the volume button is pressed.
    ///Params:
    ///    plStepSize = Volume control step. The default value of the <b>AutoVolumeControlStep</b> property is 4096.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_AutoVolumeControlStep(int* plStepSize);
    ///The <b>put_AutoVolumeControlRepeatDelay</b> method sets the <b>AutoVolumeControlRepeatDelay</b> property. The
    ///property specifies the delay, in milliseconds (ms), before a volume button starts repeating when it is held down.
    ///Params:
    ///    lDelay = Delay, in milliseconds (ms), before the volume button starts repeating. The default value is 500 ms.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT put_AutoVolumeControlRepeatDelay(int lDelay);
    ///The <b>get_AutoVolumeControlRepeatDelay</b> method retrieves the current value of the
    ///<b>AutoVolumeControlRepeatDelay</b> property. The property specifies the delay, in milliseconds (ms), before a
    ///volume button starts repeating when it is held down.
    ///Params:
    ///    plDelay = Delay, in milliseconds, of the volume repeat delay. The default value is 500 ms.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_AutoVolumeControlRepeatDelay(int* plDelay);
    ///The <b>put_AutoVolumeControlRepeatPeriod</b> method sets the <b>AutoVolumeControlRepeatPeriod</b> property. The
    ///property controls the period, in milliseconds (ms), of button repeats when a volume button is held down.
    ///Params:
    ///    lPeriod = Period, in milliseconds (ms), of button repeats when a volume button is held down. The default value is 100
    ///              ms.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT put_AutoVolumeControlRepeatPeriod(int lPeriod);
    ///The <b>get_AutoVolumeControlRepeatPeriod</b> method retrieves the current value of the
    ///<b>AutoVolumeControlRepeatPeriod</b> property. The property controls the period, in milliseconds (ms), of button
    ///repeats when a volume button is held down.
    ///Params:
    ///    plPeriod = Period, in milliseconds (ms), of button repeats when a volume button is held down.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_AutoVolumeControlRepeatPeriod(int* plPeriod);
    ///The <b>SelectCall</b> method selects the current phone object onto the Call object pointed to by the <i>pCall</i>
    ///parameter.
    ///Params:
    ///    pCall = Pointer to the ITCallInfo interface.
    ///    fSelectDefaultTerminals = If VARIANT_TRUE, use default terminals. For more information, see the following Remarks section.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT SelectCall(ITCallInfo pCall, short fSelectDefaultTerminals);
    ///The <b>UnselectCall</b> method removes the specified call from this phone object, releasing the phone object's
    ///reference to the call object. The phone object performs no further call control handling on the call object once
    ///the call object has been successfully unselected. See ITAutomatedPhoneControl::SelectCall for more information.
    ///Params:
    ///    pCall = Pointer to the ITCallInfo interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT UnselectCall(ITCallInfo pCall);
    ///The <b>EnumerateSelectedCalls</b> method retrieves an enumerator object indicating which calls are currently
    ///selected on this phone. See ITAutomatedPhoneControl::SelectCall for more information. This method is intended for
    ///C and C++ programmers. Applications written in Visual Basic, Java, or various scripting languages should use the
    ///get_SelectedCalls method instead.
    ///Params:
    ///    ppCallEnum = Pointer to the IEnumCall interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT EnumerateSelectedCalls(IEnumCall* ppCallEnum);
    ///The <b>get_SelectedCalls</b> method retrieves a VARIANT containing a pointer to a collection object indicating
    ///which calls are currently selected on this phone. See ITAutomatedPhoneControl::SelectCall for more information.
    ///This method is intended for applications written in Visual Basic, Java, or various scripting languages. C and C++
    ///programmers should use the EnumerateSelectedCalls method instead.
    ///Params:
    ///    pVariant = Pointer to a VARIANT containing an ITCollection of IEnumCall interface pointers.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_SelectedCalls(VARIANT* pVariant);
}

///The <b>ITBasicCallControl</b> interface is used by the application to connect, answer, and perform basic telephony
///operations on a call object. The ITBasicCallControl2 interface is an extension of the <b>ITBasicCallControl</b>
///interface. <b>ITBasicCallControl2</b> supplies additional methods that allow an application to select a terminal onto
///a call. The ITAddress::CreateCall method creates the <b>ITBasicCallControl</b> interface. Note to programmers
///familiar with TAPI 2.1: The general function of this interface is similar to the TAPI 2.1 line functions. For
///example, the lineAnswer function and the ITBasicCallControl::Answer method provide similar functionality.
@GUID("B1EFC389-9355-11D0-835C-00AA003CCABD")
interface ITBasicCallControl : IDispatch
{
    ///The <b>Connect</b> method attempts to complete the connection of an outgoing call.
    ///Params:
    ///    fSync = Boolean indicating whether connection is to be performed synchronously (VARIANT_TRUE) or asynchronously
    ///            (VARIANT_FALSE).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td> <td width="60%"> Call state must be
    ///    CS_IDLE. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%">
    ///    The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two minutes. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory
    ///    exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Connect(short fSync);
    ///The <b>Answer</b> method answers an incoming call. This method can succeed only if the call state is CS_OFFERING.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Call state was not CS_OFFERING. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT Answer();
    ///The <b>Disconnect</b> method disconnects the call. The call state will transition to CS_DISCONNECTED after the
    ///method completes successfully.
    ///Params:
    ///    code = DISCONNECT_CODE indicating reason for call disconnection.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The call state is CS_IDLE or a
    ///    valid handle for the call could not be obtained by the TAPI 3 DLL. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%">
    ///    The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two minutes. </td> </tr>
    ///    </table>
    ///    
    HRESULT Disconnect(DISCONNECT_CODE code);
    ///The <b>Hold</b> method places or removes the call from the hold.
    ///Params:
    ///    fHold = If <i>fHold</i> is VARIANT_TRUE and the method succeeds, the call state transitions to the CS_HOLD state. If
    ///            <i>fHold</i> is VARIANT_FALSE, the call state transitions to CS_CONNECTED.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl>
    ///    </td> <td width="60%"> The call associated with this interface no longer exists. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because
    ///    the TAPI 3 DLL timed it out. The timeout interval is two minutes </td> </tr> </table>
    ///    
    HRESULT Hold(short fHold);
    ///The <b>HandoffDirect</b> method hands off the call to another application. This indicates that the application no
    ///longer requires ownership of the call.
    ///Params:
    ///    pApplicationName = Pointer to <b>BSTR</b> containing the specific application name to hand off call to. Can be full path name or
    ///                       executable name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pApplicationName</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT HandoffDirect(BSTR pApplicationName);
    ///The <b>HandoffIndirect</b> method hands off the call to another application based on the media type of the call.
    ///If multiple applications have registered as able to handle the types involved, TAPI will hand off to the
    ///highest-priority application, which is usually the one that registered first. This indicates that the application
    ///no longer requires ownership of the call.
    ///Params:
    ///    lMediaType = Media type to transfer to.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>lMediaType</i>
    ///    parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT HandoffIndirect(int lMediaType);
    ///The Conference method adds a consultation call to the conference in which the current call is a participant. If
    ///an associated ITCallHub object does not exist, it is created.
    ///Params:
    ///    pCall = Pointer to the ITBasicCallControl interface for the consultation call.
    ///    fSync = Indicates whether the call should be conferenced synchronously (VARIANT_TRUE) or asynchronously
    ///            (VARIANT_FALSE). See Connect for additional explanation.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pCall</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pCall</i> parameter does not point to a
    ///    valid interface. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td
    ///    width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two minutes.
    ///    </td> </tr> </table>
    ///    
    HRESULT Conference(ITBasicCallControl pCall, short fSync);
    ///The <b>Transfer</b> method transfers the current call to the destination address.
    ///Params:
    ///    pCall = Pointer to ITBasicCallControl interface of consultation call created for the transfer.
    ///    fSync = Indicates whether the method should be completed synchronously (VARIANT_TRUE) or asynchronously
    ///            (VARIANT_FALSE).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pCall</i> parameter does
    ///    not point to a valid call. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Transfers not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because
    ///    the TAPI 3 DLL timed it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT Transfer(ITBasicCallControl pCall, short fSync);
    ///The <b>BlindTransfer</b> method performs a blind or single-step transfer of the specified call to the specified
    ///destination address. The application must be the owner of the call. After a successful transfer, the call state
    ///transitions to CS_DISCONNECTED.
    ///Params:
    ///    pDestAddress = Pointer to <b>BSTR</b> containing destination address for the transfer.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDestAddress</i> is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    Blind transfer is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL
    ///    timed it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT BlindTransfer(BSTR pDestAddress);
    ///The <b>SwapHold</b> method swaps the call (which is active) with the specified call on hold. Swapping the active
    ///call with the call on consultation hold allows the application to toggle between these two calls. This is typical
    ///in call waiting.
    ///Params:
    ///    pCall = Call, currently on hold, that is to be made active.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> This operation is not supported.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>pCall</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pCall</i> parameter does not describe a
    ///    currently existing call. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OPERATIONFAILED</b></dt> </dl> </td> <td width="60%"> The operation failed. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because
    ///    the TAPI 3 DLL timed it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT SwapHold(ITBasicCallControl pCall);
    ///The <b>ParkDirect</b> method parks the call at a specified address.
    ///Params:
    ///    pParkAddress = Pointer to <b>BSTR</b> containing the address where the call is to be parked.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pParkAddress</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> Park is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> The <i>pParkAddress</i> parameter is not valid. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td
    ///    width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two minutes.
    ///    </td> </tr> </table>
    ///    
    HRESULT ParkDirect(BSTR pParkAddress);
    ///The <b>ParkIndirect</b> method parks the call and returns the parked address.
    ///Params:
    ///    ppNonDirAddress = Pointer to a <b>BSTR</b> representation of the address where the call was parked.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppNonDirAddress</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td>
    ///    <td width="60%"> Park is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> The <i>ppNonDirAddress</i> parameter is not valid. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td
    ///    width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two minutes.
    ///    </td> </tr> </table>
    ///    
    HRESULT ParkIndirect(BSTR* ppNonDirAddress);
    ///The <b>Unpark</b> method gets the call from park.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The park operation is not supported.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td> <td width="60%">
    ///    Call state must be CS_IDLE. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Unpark();
    ///The <b>SetQOS</b> method sets the quality of service level for the call.
    ///Params:
    ///    lMediaType = Media type of call.
    ///    ServiceLevel = QOS_SERVICE_LEVEL indicator of desired QOS level for call.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>lMediaType</i>
    ///    parameter is not a valid media type. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT SetQOS(int lMediaType, QOS_SERVICE_LEVEL ServiceLevel);
    ///The Pickup method picks up a call alerting at the specified group identification.
    ///Params:
    ///    pGroupID = Pointer to a <b>BSTR</b> containing the group identifier to which the alerting station belongs.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Pickup did not succeed. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pGroupID</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL
    ///    timed it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT Pickup(BSTR pGroupID);
    ///The <b>Dial</b> method dials the specified address.
    ///Params:
    ///    pDestAddress = Pointer to <b>BSTR</b> representation of address to be dialed. The format must conform to a standard dialable
    ///                   address.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pDestAddress</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT Dial(BSTR pDestAddress);
    ///The <b>Finish</b> method is called on a consultation call to finish a conference or a transfer.
    ///Params:
    ///    finishMode = A FINISH_MODE indicator of the type of call being finished, such as FM_ASCONFERENCE.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td> <td width="60%"> Call is not flagged
    ///    as a transfer or a conference. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl>
    ///    </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Finish(FINISH_MODE finishMode);
    ///The <b>RemoveFromConference</b> method removes the call from a conference if it is involved in one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> </table>
    ///    
    HRESULT RemoveFromConference();
}

///The <b>ITCallInfo</b> interface gets and sets a variety of information concerning a Call object. The
///ITAddress::get_Calls and IEnumCall::Next methods create the <b>ITCallInfo</b> interface. The ITCallInfo2 interface is
///an extension of the <b>ITCallInfo</b> interface. <b>ITCallInfo2</b> provides additional methods that allow an
///application to set event filtering on a per-call basis. For a table showing the relationships between TAPI 2
///functions and <b>ITCallInfo</b> methods, see TAPI 2.x to TAPI 3.x Cross-Reference.
@GUID("350F85D1-1227-11D3-83D4-00C04FB6809F")
interface ITCallInfo : IDispatch
{
    ///The <b>get_Address</b> method gets a pointer to the ITAddress interface of the Address object.
    ///Params:
    ///    ppAddress = Pointer to ITAddress interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppAddress</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Address(ITAddress* ppAddress);
    ///The <b>get_CallState</b> method gets a pointer to the current call state, such as CS_IDLE.
    ///Params:
    ///    pCallState = Pointer to variable containing current CALL_STATE type.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pCallState</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_CallState(CALL_STATE* pCallState);
    ///The <b>get_Privilege</b> method gets the call privilege of the application for the current call, such as
    ///CP_MONITOR.
    ///Params:
    ///    pPrivilege = Pointer to CALL_PRIVILEGE.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pPrivilege</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Privilege(CALL_PRIVILEGE* pPrivilege);
    ///The <b>get_CallHub</b> method gets a pointer to the ITCallHub interface of the CallHub object.
    ///Params:
    ///    ppCallHub = Pointer to ITCallHub interface of the CallHub object.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_PENDING</b></dt> </dl> </td> <td width="60%"> Call hub not yet available. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppCallHub</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_CallHub(ITCallHub* ppCallHub);
    ///The <b>get_CallInfoLong</b> method gets call information items described by a long, such as the bearer mode.
    ///Params:
    ///    CallInfoLong = CALLINFO_LONG indicator of information type needed, such as CIL_BEARERMODE.
    ///    plCallInfoLongVal = Pointer to value returned.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plCallInfoLongVal</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>CallInfoLong</i> parameter is not a
    ///    valid value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td> <td
    ///    width="60%"> The current call state is not valid for this operation. </td> </tr> </table>
    ///    
    HRESULT get_CallInfoLong(CALLINFO_LONG CallInfoLong, int* plCallInfoLongVal);
    ///The <b>put_CallInfoLong</b> method sets call information items described by a long, such as the bearer mode.
    ///Params:
    ///    CallInfoLong = CALLINFO_LONG indicator of information type needed, such as CIL_BEARERMODE.
    ///    lCallInfoLongVal = Pointer to new value.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>CallInfoLong</i> parameter is not a valid value. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td> <td width="60%"> The current call state is not valid for
    ///    this operation. </td> </tr> </table>
    ///    
    HRESULT put_CallInfoLong(CALLINFO_LONG CallInfoLong, int lCallInfoLongVal);
    ///The <b>get_CallInfoString</b> method gets call information items described by a string, such as the displayable
    ///address.
    ///Params:
    ///    CallInfoString = CALLINFO_STRING indicator of information type needed, such as CIS_DISPLAYABLEADDRESS.
    ///    ppCallInfoString = Pointer to <b>BSTR</b> representation of needed string.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppCallInfoString</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>CallInfoString</i> parameter is not a
    ///    valid value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td> <td
    ///    width="60%"> The current call state is not valid for this operation. </td> </tr> </table>
    ///    
    HRESULT get_CallInfoString(CALLINFO_STRING CallInfoString, BSTR* ppCallInfoString);
    ///The <b>put_CallInfoString</b> method sets call information items described by a string, such as the displayable
    ///address.
    ///Params:
    ///    CallInfoString = CALLINFO_STRING indicator of information type, such as CIS_DISPLAYABLEADDRESS.
    ///    pCallInfoString = Pointer to a BSTR representation of the string.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>CallInfoString</i> parameter is not a valid value. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td> <td width="60%"> The current call state is not valid for
    ///    this operation. </td> </tr> </table>
    ///    
    HRESULT put_CallInfoString(CALLINFO_STRING CallInfoString, BSTR pCallInfoString);
    ///The <b>get_CallInfoBuffer</b> method gets call information items which require a buffer, such as user-user
    ///information. This method is provided for Automation client applications, such as those written in Visual Basic. C
    ///and C++ applications must use the ITCallInfo::GetCallInfoBuffer method.
    ///Params:
    ///    CallInfoBuffer = CALLINFO_BUFFER indicator of information type needed, such as CIB_USERUSERINFO.
    ///    ppCallInfoBuffer = Pointer to <b>VARIANT</b> representation of call information buffer. The application must call the
    ///                       CoTaskMemFree function to free the memory allocated for this parameter.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppCallInfoBuffer</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>CallInfoBuffer</i> parameter is not a
    ///    valid value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td> <td
    ///    width="60%"> The current call state is not valid for this operation. </td> </tr> </table>
    ///    
    HRESULT get_CallInfoBuffer(CALLINFO_BUFFER CallInfoBuffer, VARIANT* ppCallInfoBuffer);
    ///The <b>put_CallInfoBuffer</b> method sets call information items which require a buffer, such as user-user
    ///information. This method is provided for Automation client applications, such as those written in Visual Basic. C
    ///and C++ applications must use the ITCallInfo::SetCallInfoBuffer method.
    ///Params:
    ///    CallInfoBuffer = CALLINFO_BUFFER indicator of information type, such as CIB_USERUSERINFO.
    ///    pCallInfoBuffer = <b>VARIANT</b>
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>CallInfoBuffer</i> parameter is not a valid value. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td> <td width="60%"> The current call state is not valid for
    ///    this operation. </td> </tr> </table>
    ///    
    HRESULT put_CallInfoBuffer(CALLINFO_BUFFER CallInfoBuffer, VARIANT pCallInfoBuffer);
    ///The <b>GetCallInfoBuffer</b> method gets call information items that require a buffer, such as user-user
    ///information. Automation client applications, such as those written in Visual Basic, must use the
    ///ITCallInfo::get_CallInfoBuffer method.
    ///Params:
    ///    CallInfoBuffer = CALLINFO_BUFFER indicator of information type needed, such as CIB_USERUSERINFO.
    ///    pdwSize = Size of buffer returned in bytes.
    ///    ppCallInfoBuffer = Pointer to buffer containing the needed call information.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pdwSize</i> or <i>ppCallInfoBuffer</i> parameter is not a valid pointer. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>CallInfoBuffer</i>
    ///    parameter is not a valid value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt>
    ///    </dl> </td> <td width="60%"> The current call state is not valid for this operation. </td> </tr> </table>
    ///    
    HRESULT GetCallInfoBuffer(CALLINFO_BUFFER CallInfoBuffer, uint* pdwSize, char* ppCallInfoBuffer);
    ///The <b>SetCallInfoBuffer</b> method sets call information items that require a buffer, such as user-user
    ///information. Automation client applications, such as those written in Visual Basic, must use the
    ///ITCallInfo::put_CallInfoBuffer method.
    ///Params:
    ///    CallInfoBuffer = CALLINFO_BUFFER indicator of information type needed, such as CIB_USERUSERINFO.
    ///    dwSize = Size of <i>pCallInfoBuffer</i>.
    ///    pCallInfoBuffer = Pointer to call information buffer.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pCallInfoBuffer</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>CallInfoBuffer</i> parameter is not a
    ///    valid value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td> <td
    ///    width="60%"> The current call state is not valid for this operation. </td> </tr> </table>
    ///    
    HRESULT SetCallInfoBuffer(CALLINFO_BUFFER CallInfoBuffer, uint dwSize, char* pCallInfoBuffer);
    ///The <b>ReleaseUserUserInfo</b> method informs the service provider that the application has processed the
    ///user-user information obtained from the ITCallInfo::GetCallInfoBuffer method, called with the CIB_USERUSERINFO
    ///member of CALLINFO_BUFFER, and subsequently received user-user information can now be written.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td>
    ///    <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> </table>
    ///    
    HRESULT ReleaseUserUserInfo();
}

///The <b>ITCallInfo2</b> interface is an extension of the ITCallInfo interface. <b>ITCallInfo2</b> provides additional
///methods that allow an application to set event filtering on a per-call basis.
@GUID("94D70CA6-7AB0-4DAA-81CA-B8F8643FAEC1")
interface ITCallInfo2 : ITCallInfo
{
    ///The <b>get_EventFilter</b> method gets the event filter information applicable to this call.
    ///Params:
    ///    TapiEvent = The TAPI_EVENT descriptor of event type information being checked.
    ///    lSubEvent = Subevent descriptor.
    ///    pEnable = VARIANT_TRUE if notifications are being sent on this event type for this call.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_EventFilter(TAPI_EVENT TapiEvent, int lSubEvent, short* pEnable);
    ///The <b>put_EventFilter</b> method sets an event filter for the current call.
    ///Params:
    ///    TapiEvent = The TAPI_EVENT descriptor of the event type.
    ///    lSubEvent = Subevent descriptor.
    ///    bEnable = VARIANT_TRUE if application requires notification of this event type. VARIANT_FALSE indicates the application
    ///              does not require notifications for this event.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_EventFilter(TAPI_EVENT TapiEvent, int lSubEvent, short bEnable);
}

///The <b>ITTerminal</b> interface is the base interface for a Terminal object. This object, and the interface, is
///available only when an MSP exists. It provides methods that allow an application to obtain information such as
///terminal class and media supported. The following methods create the <b>ITTerminal</b> interface:
///ITBasicCallControl2::RequestTerminal ITTerminalSupport::CreateTerminal IEnumTerminal::Next
@GUID("B1EFC38A-9355-11D0-835C-00AA003CCABD")
interface ITTerminal : IDispatch
{
    ///The <b>get_Name</b> method gets a descriptive name of the terminal. The name must be usable to the user.
    ///Params:
    ///    ppName = Pointer to <b>BSTR</b> containing the name of the terminal.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppName</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Name(BSTR* ppName);
    ///The <b>get_State</b> method gets the current state of the terminal.
    ///Params:
    ///    pTerminalState = Pointer to a TERMINAL_STATE enum member.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pTerminalState</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_State(TERMINAL_STATE* pTerminalState);
    ///The <b>get_TerminalType</b> method gets the TERMINAL_TYPE of the terminal.
    ///Params:
    ///    pType = Pointer to a TERMINAL_TYPE.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pType</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_TerminalType(TERMINAL_TYPE* pType);
    ///The <b>get_TerminalClass</b> method gets the Terminal Class of the terminal.
    ///Params:
    ///    ppTerminalClass = Pointer to <b>BSTR</b> representation of the Terminal Class of the terminal.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppTerminalClass</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_TerminalClass(BSTR* ppTerminalClass);
    ///The <b>get_MediaType</b> method determines the media that this terminal supports.
    ///Params:
    ///    plMediaType = Pointer to media type.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plMediaType</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_MediaType(int* plMediaType);
    ///The <b>get_Direction</b> method gets a TERMINAL_DIRECTION descriptor of the media stream direction for the
    ///terminal.
    ///Params:
    ///    pDirection = TERMINAL_DIRECTION descriptor of the media stream direction for the terminal.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDirection</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Direction(TERMINAL_DIRECTION* pDirection);
}

///This <b>ITMultiTrackTerminal</b> interface is exposed on all multitrack terminals. The interface includes methods for
///enumerating, creating, and removing tracks. The <b>ITMultiTrackTerminal</b> interface is created by calling
///<b>QueryInterface</b> on ITTerminal.
@GUID("FE040091-ADE8-4072-95C9-BF7DE8C54B44")
interface ITMultiTrackTerminal : IDispatch
{
    ///The <b>get_TrackTerminals</b> method creates and returns a collection containing the terminals contained by the
    ///multitrack terminal on which this method was called. The variant returned contains a pointer to an ITCollection
    ///interface that can be used to iterate through elements of type IEnumVARIANT. The elements of the collection
    ///contain pointers to tracks.
    ///Params:
    ///    pVariant = Pointer to a VARIANT containing an ITCollection of ITTerminal interface pointers for the tracks available.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter is not
    ///    a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter was not empty. </td>
    ///    </tr> </table>
    ///    
    HRESULT get_TrackTerminals(VARIANT* pVariant);
    ///The <b>EnumerateTrackTerminals</b> method creates and returns an enumeration containing the terminals contained
    ///by the multitrack terminal on which this method was called.
    ///Params:
    ///    ppEnumTerminal = Pointer to the IEnumTerminal interface enumerating terminals contained in the multitrack terminal.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppTerminalEnum</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT EnumerateTrackTerminals(IEnumTerminal* ppEnumTerminal);
    ///The <b>CreateTrackTerminal</b> method creates a multitrack terminal that can handle a given media type or types
    ///and media direction.
    ///Params:
    ///    MediaType = Bitwise ORed list of media types required for the terminal.
    ///    TerminalDirection = The TERMINAL_DIRECTION descriptor for the terminal.
    ///    ppTerminal = Pointer to the ITTerminal interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateTrackTerminal(int MediaType, TERMINAL_DIRECTION TerminalDirection, ITTerminal* ppTerminal);
    ///The <b>get_MediaTypesInUse</b> method returns the media types (bitwise ORed) of all tracks managed currently by
    ///the multitrack terminal. For tracks that are multitrack terminals themselves, this method calls the track's
    ///<b>ITMultiTrackTerminal::get_MediaTypesInUse</b> method to determine the track's media types.
    ///Params:
    ///    plMediaTypesInUse = Bitwise ORed list of media types in use.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_MediaTypesInUse(int* plMediaTypesInUse);
    ///The <b>get_DirectionsInUse</b> method returns the direction of all tracks managed currently by the multitrack
    ///terminal. For tracks that are multitrack terminals themselves, this method calls the track's
    ///<b>ITMultiTrackTerminal::get_DirectionsInUse</b> method to determine the track's directions.
    ///Params:
    ///    plDirectionsInUsed = Pointer to the TERMINAL_DIRECTION descriptor of the directions.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_DirectionsInUse(TERMINAL_DIRECTION* plDirectionsInUsed);
    ///The <b>RemoveTrackTerminal</b> method removes the specified terminal from the collection of track terminals that
    ///belong to the multitrack terminal on which the method was called. If the track terminal has been selected on a
    ///stream, it should be unselected first.
    ///Params:
    ///    pTrackTerminalToRemove = Pointer to the ITTerminal interface of the terminal to remove.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>pTrackTerminalToRemove</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT RemoveTrackTerminal(ITTerminal pTrackTerminalToRemove);
}

///The <b>ITFileTrack</b> interface exposes methods that allow an application to get and set information concerning file
///terminal tracks. The ITFileTerminalEvent::get_Track method creates the <b>ITFileTrack</b> interface.
@GUID("31CA6EA9-C08A-4BEA-8811-8E9C1BA3EA3A")
interface ITFileTrack : IDispatch
{
    ///The <b>get_Format</b> method gets the file terminal's format.
    ///Params:
    ///    ppmt = Pointer to an <b>AM_MEDIA_TYPE</b> descriptor of the terminal format. For more information on
    ///           <b>AM_MEDIA_TYPE</b>, see the DirectX documentation.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Format(AM_MEDIA_TYPE** ppmt);
    ///The <b>put_Format</b> method sets the format type of the track.
    ///Params:
    ///    pmt = The <b>AM_MEDIA_TYPE</b> descriptor of the file track format. For more information about
    ///          <b>AM_MEDIA_TYPE</b>, see the DirectX documentation. The ITFileTrack only supports the
    ///          <b>FORMAT_WaveFormatEx</b> format type in the <b>AM_MEDIA_TYPE</b> structure.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_Format(const(AM_MEDIA_TYPE)* pmt);
    ///The <b>get_ControllingTerminal</b> method returns the multitrack terminal that controls the current track.
    ///Params:
    ///    ppControllingTerminal = Pointer to the ITTerminal interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_ControllingTerminal(ITTerminal* ppControllingTerminal);
    ///The <b>get_AudioFormatForScripting</b> method gets the audio scripting format.
    ///Params:
    ///    ppAudioFormat = Pointer to the ITScriptableAudioFormat interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_AudioFormatForScripting(ITScriptableAudioFormat* ppAudioFormat);
    ///The <b>put_AudioFormatForScripting</b> method sets the audio scripting format.
    ///Params:
    ///    pAudioFormat = Pointer to the ITScriptableAudioFormat interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_AudioFormatForScripting(ITScriptableAudioFormat pAudioFormat);
    ///The <b>get_EmptyAudioFormatForScripting</b> method is used to get an ITScriptableAudioFormat interface with all
    ///fields set to 0.
    ///Params:
    ///    ppAudioFormat = Pointer to ITScriptableAudioFormat interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_EmptyAudioFormatForScripting(ITScriptableAudioFormat* ppAudioFormat);
}

///The <b>ITMediaPlayback</b> interface provides playback-specific methods that allow an application to set and get the
///list of files to play. This interface is created by calling <b>QueryInterface</b> on ITTerminal.
@GUID("627E8AE6-AE4C-4A69-BB63-2AD625404B77")
interface ITMediaPlayback : IDispatch
{
    ///The <b>put_PlayList</b> method provides the file playback terminal with the list of files to play.
    ///Params:
    ///    PlayListVariant = Variant of type VT_ARRAY, which contains variants of type VT_BSTR and VT_STORAGE. The VT_BSTR elements of the
    ///                      array contain the names of the files to play. The file name extension is used to determine the type of file.
    ///                      Currently, the supported file name extensions are .avi and .wav.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_PlayList(VARIANT PlayListVariant);
    ///The <b>get_PlayList</b> method gets the list of files to play.
    ///Params:
    ///    pPlayListVariant = Pointer to variant of type VT_ARRAY, which contains variants of type VT_BSTR and VT_STORAGE. The VT_BSTR
    ///                       elements of the array contain the names of the files to play. The file name extension is used to specify the
    ///                       type of file. Currently, supported file name extensions are .avi and .wav.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_PlayList(VARIANT* pPlayListVariant);
}

///The <b>ITMediaRecord</b> interface provides recording-specific methods that allow an application to set and get the
///names of files to record.
@GUID("F5DD4592-5476-4CC1-9D4D-FAD3EEFE7DB2")
interface ITMediaRecord : IDispatch
{
    ///The <b>put_FileName</b> method sets the name of the file to record.
    ///Params:
    ///    bstrFileName = The <b>BSTR</b> representation of the file name.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT put_FileName(BSTR bstrFileName);
    ///The <b>get_FileName</b> method retrieves the name of the file that was used for recording by this terminal.
    ///Params:
    ///    pbstrFileName = The <b>BSTR</b> representation of the file name. The <b>BSTR</b> is allocated using SysAllocString. The
    ///                    <b>BSTR</b> argument should be deallocated by the client.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_FileName(BSTR* pbstrFileName);
}

///The <b>ITMediaControl</b> interface is a generic interface for media file terminals. The interface exposes methods
///that allow the application to start, stop, or pause current actions, such as a playback.
@GUID("C445DDE8-5199-4BC7-9807-5FFB92E42E09")
interface ITMediaControl : IDispatch
{
    ///The <b>Start</b> method starts the action at the current location.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Start();
    ///The <b>Stop</b> method stops the current action and sets the current location to the beginning of the file.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Stop();
    ///The <b>Pause</b> method pauses the action, remaining at the current location in the file.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Pause();
    ///The <b>get_MediaState</b> method gets the current state of media on the file terminal.
    ///Params:
    ///    pTerminalMediaState = Pointer to the TERMINAL_MEDIA_STATE descriptor of the current state of the file terminal.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_MediaState(TERMINAL_MEDIA_STATE* pTerminalMediaState);
}

///The <b>ITBasicAudioTerminal</b> interface provides methods that allow an application to control basic sound
///characteristics of terminal. These methods are taken from the <b>IBasicAudio</b> interface in DirectShow. Please
///check the index for the Platform Software Development Kit (SDK) for additional information. The
///<b>ITBasicAudioTerminal</b> interface can be obtained through <b>QueryInterface</b> from terminal objects that
///support this interface. For example, if the computer running Windows 2000 has a sound card, the addresses exposed by
///the H323 and IPCONF providers will enumerate, in their ITTerminalSupport interface, two static terminals that support
///the <b>ITBasicAudioTerminal</b> interface: one for "audio record" and one for "audio playback."
@GUID("B1EFC38D-9355-11D0-835C-00AA003CCABD")
interface ITBasicAudioTerminal : IDispatch
{
    ///The <b>put_Volume</b> method sets the volume.
    ///Params:
    ///    lVolume = The volume property is a value between 0 and FFFF, representing a set of logarithmic steps. Not all devices
    ///              support as many distinguishable steps.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_NOTERMINALSELECTED</b></dt>
    ///    </dl> </td> <td width="60%"> A terminal must be selected before the volume can be adjusted. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_Volume(int lVolume);
    ///The <b>get_Volume</b> method gets the volume.
    ///Params:
    ///    plVolume = Pointer to volume. The volume property is a value between 0 and FFFF, representing a set of logarithmic
    ///               steps. Not all devices support as many distinguishable steps.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plVolume</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Volume(int* plVolume);
    ///The <b>put_Balance</b> method sets the balance. This method is not implemented for terminals shipped with TAPI
    ///3.0 and higher.
    ///Params:
    ///    lBalance = Balance.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td
    ///    width="60%"> Terminal's balance methods are not implemented. </td> </tr> </table>
    ///    
    HRESULT put_Balance(int lBalance);
    ///The <b>get_Balance</b> method gets the balance. This method is not implemented for terminals shipped with TAPI
    ///3.0 and higher.
    ///Params:
    ///    plBalance = Pointer to balance.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_NOTSUPPORTED</b></dt> </dl>
    ///    </td> <td width="60%"> Terminal does not support balance operations. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Terminal's balance methods are not implemented. </td>
    ///    </tr> </table>
    ///    
    HRESULT get_Balance(int* plBalance);
}

///The <b>ITStaticAudioTerminal</b> interface is an interface that TAPI 3.1 MSPs must expose on all static audio
///terminals. The interface defines methods on static audio terminal objects that are needed to support phone devices.
///If an MSP's audio terminals are for devices that are not accessible via standard audio APIs, then a QueryInterface on
///ITTerminal(IID_ITStaticAudioTerminal) should return E_NOINTERFACE, and it will be impossible to associate a USB phone
///with any of these audio terminals in TAPI 3.1.
@GUID("A86B7871-D14C-48E6-922E-A8D15F984800")
interface ITStaticAudioTerminal : IDispatch
{
    ///The <b>get_WaveId</b> method returns the wave ID for the audio device used to implement this terminal.
    ///Params:
    ///    plWaveId = Pointer to a variable where, on success, the method will store the wave ID for this terminal.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_WaveId(int* plWaveId);
}

///The <b>ITCallHub</b> interface provides methods to retrieve information concerning a CallHub object. The
///IEnumCallHub::Next and ITTapi::get_CallHubs methods create the <b>ITCallHub</b> interface.
@GUID("A3C1544E-5B92-11D1-8F4E-00C04FB6809F")
interface ITCallHub : IDispatch
{
    ///The <b>Clear</b> method attempts to remove all calls and participants from CallHub. The application may not have
    ///the privileges required to disconnect every call.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Clear();
    ///The <b>EnumerateCalls</b> method enumerates calls currently associated with the call hub. This method is provided
    ///for C and C++ applications. Automation client applications, such as those written in Visual Basic, must use the
    ///get_Calls method.
    ///Params:
    ///    ppEnumCall = Pointer to IEnumCall interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    create the enumerator. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppEnumCall</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT EnumerateCalls(IEnumCall* ppEnumCall);
    ///The <b>get_Calls</b> method creates a collection of calls associated with the current call hub. This method is
    ///provided for Automation client applications, such as those written in Visual Basic. C and C++ applications must
    ///use the EnumerateCalls method.
    ///Params:
    ///    pCalls = Pointer to a <b>VARIANT</b> containing an ITCollection of ITCallInfo interface pointers (call objects).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pCalls</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Calls(VARIANT* pCalls);
    ///The <b>get_NumCalls</b> method gets the number of calls currently in the CallHub.
    ///Params:
    ///    plCalls = Total number of calls in the CallHub.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plCalls</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_NumCalls(int* plCalls);
    ///The <b>get_State</b> method gets the current state of the CallHub.
    ///Params:
    ///    pState = Pointer to CALLHUB_STATE indicator of state.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pState</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_State(CALLHUB_STATE* pState);
}

///The <b>ITLegacyAddressMediaControl</b> interface is provided to support legacy applications that require direct
///access to a device and its configuration. It is exposed by the Address Object and can be created by calling
///<b>QueryInterface</b> on ITAddress. The ITLegacyAddressMediaControl2 interface derives from the
///<b>ITLegacyAddressMediaControl</b> interface. <b>ITLegacyAddressMediaControl2</b> provides additional methods that
///allow the configuration of parameters related to line devices.
@GUID("AB493640-4C0B-11D2-A046-00C04FB6809F")
interface ITLegacyAddressMediaControl : IUnknown
{
    ///The <b>GetID</b> method returns a device identifier for the specified device class associated with the current
    ///address. This method is intended for C/C++ applications only. There is no corresponding method available for
    ///Visual Basic and scripting applications.
    ///Params:
    ///    pDeviceClass = Pointer to <b>BSTR</b> containing TAPI device class for which configuration information is needed.
    ///    pdwSize = Length of device identifier returned.
    ///    ppDeviceID = Device identifier.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Method failed. This may mean there
    ///    is no device of a specified class associated with the current address. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pdwSize</i> or <i>ppDeviceID</i> parameter is
    ///    not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT GetID(BSTR pDeviceClass, uint* pdwSize, char* ppDeviceID);
    ///The <b>GetDevConfig</b> method returns an opaque data structure. The exact contents are specific to the service
    ///provider and device class. The data structure specifies the configuration of a device associated with a
    ///particular line device. For example, the contents of this structure could specify data rate, character format,
    ///modulation schemes, and error control protocol settings for a datamodem device associated with the line.
    ///Params:
    ///    pDeviceClass = Pointer to <b>BSTR</b> containing TAPI device class for which configuration information is needed.
    ///    pdwSize = Pointer to size of configuration array.
    ///    ppDeviceConfig = Pointer to array of bytes containing device configuration information.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDeviceClass</i>,
    ///    <i>pdwSize</i>, or <i>ppDeviceConfig</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT GetDevConfig(BSTR pDeviceClass, uint* pdwSize, char* ppDeviceConfig);
    ///The <b>SetDevConfig</b> function allows the application to restore the configuration of a media stream device on
    ///a line device to a setup previously obtained using GetDevConfig.
    ///Params:
    ///    pDeviceClass = Pointer to <b>BSTR</b> containing TAPI device class for which configuration information is needed.
    ///    dwSize = Size of configuration array.
    ///    pDeviceConfig = Pointer to the array of bytes containing device configuration information obtained by a call to GetDevConfig.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDeviceClass</i>,
    ///    <i>pdwSize</i>, or <i>ppDeviceConfig</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pdwSize</i> parameter is zero. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient
    ///    memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT SetDevConfig(BSTR pDeviceClass, uint dwSize, char* pDeviceConfig);
}

///The <b>ITPrivateEvent</b> interface exposes methods that allows an application to process events generated by a
///private object.
@GUID("0E269CD0-10D4-4121-9C22-9C85D625650D")
interface ITPrivateEvent : IDispatch
{
    ///The <b>get_Address</b> method gets the ITAddress interface pointer to the private object involved in the event.
    ///Params:
    ///    ppAddress = Pointer to an ITAddress interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppAddress</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Address(ITAddress* ppAddress);
    ///The <b>get_Call</b> method returns a pointer to the ITCallInfo interface of the call on which the event occurred.
    ///Params:
    ///    ppCallInfo = Pointer to the ITCallInfo interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppCallInfo</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Call(ITCallInfo* ppCallInfo);
    ///The <b>get_CallHub</b> method returns a pointer to the ITCallHub interface on which the event occurred.
    ///Params:
    ///    ppCallHub = Pointer to ITCallHub interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppCallHub</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_CallHub(ITCallHub* ppCallHub);
    ///The <b>get_EventCode</b> method returns a pointer to a provider-specific event descriptor.
    ///Params:
    ///    plEventCode = Pointer to the provider-specific event descriptor.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plEventCode</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_EventCode(int* plEventCode);
    ///The <b>get_EventInterface</b> method returns a pointer to the <b>IDispatch</b> interface of the private object's
    ///event handler.
    ///Params:
    ///    pEventInterface = Pointer to the <b>IDispatch</b> interface of the private object's event handler.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pEventInterface</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_EventInterface(IDispatch* pEventInterface);
}

///The <b>ITLegacyAddressMediaControl2</b> interface derives from the ITLegacyAddressMediaControl interface.
///<b>ITLegacyAddressMediaControl2</b> provides additional methods that allow the configuration of parameters related to
///line devices.
@GUID("B0EE512B-A531-409E-9DD9-4099FE86C738")
interface ITLegacyAddressMediaControl2 : ITLegacyAddressMediaControl
{
    ///The <b>ConfigDialog</b> method causes the provider of the specified line device to display a dialog box to allow
    ///the user to configure parameters related to the line device. The parameters that can be edited are those
    ///currently in use on the device.
    ///Params:
    ///    hwndOwner = A handle to a window to which the dialog box is to be attached. This parameter can be <b>NULL</b> to indicate
    ///                that a window created by the method should have no owner window.
    ///    pDeviceClass = Pointer to a <b>BSTR</b> that specifies a device class name. This device class allows the application to
    ///                   select a specific subscreen of configuration information applicable to that device class. This parameter is
    ///                   optional and can be left <b>NULL</b> or empty, in which case the highest-level configuration is selected.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ConfigDialog(HWND hwndOwner, BSTR pDeviceClass);
    ///The <b>ConfigDialogEdit</b> method causes the provider of the specified line device to display a dialog box to
    ///allow the user to configure parameters related to the line device. The configuration data is passed in and out of
    ///this method by the application. (The data is the same as that retrieved by the
    ///ITLegacyAddressMediaControl::GetDevConfig method and set by the ITLegacyAddressMediaControl::SetDevConfig
    ///method.)
    ///Params:
    ///    hwndOwner = A handle to a window to which the dialog box is to be attached. Can be <b>NULL</b> to indicate that a window
    ///                created by the method should have no owner window.
    ///    pDeviceClass = Pointer to a <b>BSTR</b> that specifies a device class name. This device class allows the application to
    ///                   select a specific subscreen of configuration information applicable to that device class. This parameter is
    ///                   optional and can be left <b>NULL</b> or empty, in which case the highest level configuration is selected.
    ///    dwSizeIn = Pointer to the size of the configuration data pointed to by the <i>pDeviceConfigIn</i> parameter.
    ///    pDeviceConfigIn = Pointer to an array of bytes containing device configuration data to edit.
    ///    pdwSizeOut = Pointer to the size of the configuration data pointed to by the <i>ppDeviceConfigOut</i> parameter.
    ///    ppDeviceConfigOut = Pointer to an array of bytes containing edited device configuration data.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT ConfigDialogEdit(HWND hwndOwner, BSTR pDeviceClass, uint dwSizeIn, char* pDeviceConfigIn, 
                             uint* pdwSizeOut, char* ppDeviceConfigOut);
}

///The <b>ITLegacyCallMediaControl</b> interface supports legacy applications that must communicate directly with a
///device. This interface is exposed on the Call Object and can be created by calling <b>QueryInterface</b> on
///ITBasicCallControl. The ITLegacyCallMediaControl2 interface is an extension of the <b>ITLegacyCallMediaControl</b>
///interface. <b>ITLegacyCallMediaControl2</b> provides additional methods, primarily for tone detection and generation.
@GUID("D624582F-CC23-4436-B8A5-47C625C8045D")
interface ITLegacyCallMediaControl : IDispatch
{
    ///The <b>DetectDigits</b> method sets an identifier of the type of digits that will be detected on the current
    ///call, such as rotary pulse or DTMF.
    ///Params:
    ///    DigitMode = Indicates digit mode.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl>
    ///    </td> <td width="60%"> No call currently exists. </td> </tr> </table>
    ///    
    HRESULT DetectDigits(int DigitMode);
    ///The <b>GenerateDigits</b> method causes digits to be output on the current call.
    ///Params:
    ///    pDigits = Pointer to <b>BSTR</b> representation of digits to be sent.
    ///    DigitMode = Indicates digit mode.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl>
    ///    </td> <td width="60%"> No call currently exists. </td> </tr> </table>
    ///    
    HRESULT GenerateDigits(BSTR pDigits, int DigitMode);
    ///The <b>GetID</b> method gets the identifier for the device associated with the current call. This method is
    ///intended for C/C++ applications. Visual Basic and scripting applications should use the
    ///ITLegacyCallMediaControl2::GetIDAsVariant method.
    ///Params:
    ///    pDeviceClass = Pointer to <b>BSTR</b> representing the TAPI device class.
    ///    pdwSize = Size in bytes of device identifier.
    ///    ppDeviceID = Device identifier.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pdwSize</i> or <i>ppDeviceID</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT GetID(BSTR pDeviceClass, uint* pdwSize, char* ppDeviceID);
    ///The <b>SetMediaType</b> method sets the media type(s) for the current call in its LINECALLINFO structure. For
    ///more information, see lineSetMediaMode.
    ///Params:
    ///    lMediaType = Indicator of media type.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The associated call object is not
    ///    valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>lMediaType</i> parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT SetMediaType(int lMediaType);
    ///The <b>MonitorMedia</b> method sets monitoring for a given media type on the current call. This method enables
    ///and disables the detection of media types (modes) on the specified call. When a media type is detected, a message
    ///is sent to the application. For more information, see lineMonitorMedia.
    ///Params:
    ///    lMediaType = Indicator of media type.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>lMediaType</i>
    ///    parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> The associated call object is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT MonitorMedia(int lMediaType);
}

///The <b>ITLegacyCallMediaControl2</b> interface is an extension of the ITLegacyCallMediaControl interface.
///<b>ITLegacyCallMediaControl2</b> provides additional methods, primarily for tone detection and generation.
@GUID("57CA332D-7BC2-44F1-A60C-936FE8D7CE73")
interface ITLegacyCallMediaControl2 : ITLegacyCallMediaControl
{
    ///The <b>GenerateDigits2</b> method causes digits to be output on the current call. This method extends the
    ///ITLegacyCallMediaControl::GenerateDigits method by adding a duration parameter.
    ///Params:
    ///    pDigits = A pointer to a <b>BSTR</b> representation of the digits to generate.
    ///    DigitMode = Indicates the digit mode. Valid values are those from the TAPI 2.<i>x</i> LINEDIGITMODE_constants.
    ///    lDuration = Both the duration, in milliseconds, of DTMF digits and pulse, and DTMF interdigit spacing.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDigits</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td>
    ///    <td width="60%"> The call must be in the <i>connected</i> state. </td> </tr> </table>
    ///    
    HRESULT GenerateDigits2(BSTR pDigits, int DigitMode, int lDuration);
    ///The <b>GatherDigits</b> method initiates the gathering of digits on the specified call. The application specifies
    ///the maximum number of digits to collect.
    ///Params:
    ///    DigitMode = The digit mode(s) to monitor. This parameter specifies one or more of the LINEDIGITMODE constants.
    ///    lNumDigits = The number of digits to collect. If this parameter is zero, the method cancels any digit-gathering in
    ///                 progress, without starting a new digit-gathering attempt. For more information, see the following Remarks
    ///                 section.
    ///    pTerminationDigits = Pointer to a <b>BSTR</b> representation of the termination digits. If one of the termination digits in the
    ///                         string is detected, that digit is appended to the buffer, digit collection is terminated, and the
    ///                         <b>TE_GATHERDIGITS</b> event is sent to the application.
    ///    lFirstDigitTimeout = The length of time, in milliseconds, during which the first digit is expected. If the first digit is not
    ///                         received in this timeframe, digit collection is aborted and a <b>TE_GATHERDIGITS</b> event is sent to the
    ///                         application. The buffer contains only the <b>NULL</b> character, indicating that no digits were received and
    ///                         that the first-digit-timeout terminated digit-gathering. The minimum and maximum timeouts you can specify are
    ///                         found in the AC_GATHERDIGITSMINTIMEOUT and AC_GATHERDIGITSMAXTIMEOUT capabilities.
    ///    lInterDigitTimeout = The maximum time, in milliseconds, between consecutive digits. If the next digit is not received in this
    ///                         timeframe, digit collection is aborted and a <b>TE_GATHERDIGITS</b> event is sent to the application. The
    ///                         buffer contains only the digits collected up to this point followed by a <b>NULL</b> character, indicating
    ///                         that an interdigit-timeout terminated the digit-gathering. The minimum and maximum timeouts that can be
    ///                         specified are found in the AC_GATHERDIGITSMINTIMEOUT and AC_GATHERDIGITSMAXTIMEOUT capabilities.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pTerminationDigits</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> There is not enough memory to allocate the gather digits buffer. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td> <td width="60%"> The call must be in the
    ///    <i>connected</i> state. </td> </tr> </table>
    ///    
    HRESULT GatherDigits(int DigitMode, int lNumDigits, BSTR pTerminationDigits, int lFirstDigitTimeout, 
                         int lInterDigitTimeout);
    ///The <b>DetectTones</b> method enables and disables the detection of inband tones on the call. Each time a
    ///specified tone is detected, a message is sent to the application. This method is intended for C/C++ applications.
    ///Visual Basic and scripting applications should use the DetectTonesByCollection method instead.
    ///Params:
    ///    pToneList = Pointer to a TAPI_DETECTTONE array that specifies the tones to detect. Each tone in the array has an
    ///                application-defined tag field that is used to identify the individual tones in the list when a tone detection
    ///                event of type <b>TE_TONEEVENT</b> is reported. For more information, see the following Remarks section.
    ///    lNumTones = The number of entries in the array specified by the <i>pToneList</i> parameter. This parameter is ignored if
    ///                <i>pToneList</i> is <b>NULL</b>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pToneList</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl>
    ///    </td> <td width="60%"> The call must be in the <i>connected</i> state. </td> </tr> </table>
    ///    
    HRESULT DetectTones(TAPI_DETECTTONE* pToneList, int lNumTones);
    ///The <b>DetectTonesByCollection</b> method enables and disables the detection of inband tones on the call. Each
    ///time a specified tone is detected, a message is sent to the application. This method is intended for Visual Basic
    ///and scripting applications. C/C++ applications should use the DetectTones method instead.
    ///Params:
    ///    pDetectToneCollection = Pointer to an ITCollection2 interface containing a collection of ITDetectTone interface pointers that
    ///                            represent the tones to monitor. Each tone in the list has an application-defined tag field that is used to
    ///                            identify the individual tones when tone detection is reported by a <b>TE_TONEEVENT</b> event. For more
    ///                            information, see the following Remarks section.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDetectToneCollection</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> There is not enough memory to allocate the tones buffer. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td> <td width="60%"> The call must be in the
    ///    <i>connected</i> state. </td> </tr> </table>
    ///    
    HRESULT DetectTonesByCollection(ITCollection2 pDetectToneCollection);
    ///The <b>GenerateTone</b> method generates the specified tone. To generate custom tones, call the
    ///GenerateCustomTones (C/C++) or the GenerateCustomTonesByCollection method (Visual Basic and scripting
    ///applications).
    ///Params:
    ///    ToneMode = Indicates the tone mode. The values used are those from the TAPI_TONEMODE enumeration.
    ///    lDuration = Both the duration, in milliseconds, of DTMF digits and pulse, and DTMF interdigit spacing.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameters is
    ///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td> <td
    ///    width="60%"> The call must be in the <i>connected</i> state. </td> </tr> </table>
    ///    
    HRESULT GenerateTone(TAPI_TONEMODE ToneMode, int lDuration);
    ///The <b>GenerateCustomTones</b> method generates the specified custom tone. This method is intended for C/C++
    ///applications. Visual Basic and scripting applications should use the GenerateCustomTonesByCollection method
    ///instead.
    ///Params:
    ///    pToneList = Pointer to a TAPI_CUSTOMTONE array that specifies the tones to generate.
    ///    lNumTones = The number of entries in the array specified by the <i>pToneList</i> parameter.
    ///    lDuration = The duration, in milliseconds, during which the tone should be sustained.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GenerateCustomTones(TAPI_CUSTOMTONE* pToneList, int lNumTones, int lDuration);
    ///The <b>GenerateCustomTonesByCollection</b> method generates the specified custom tone. This method is intended
    ///for Visual Basic and scripting applications. C/C++ applications should use the GenerateCustomTones method
    ///instead.
    ///Params:
    ///    pCustomToneCollection = Pointer to an ITCollection2 interface containing a collection of ITCustomTone interface pointers representing
    ///                            the tone's components. If the collection is a multifrequency tone, the various tones are played
    ///                            simultaneously.
    ///    lDuration = The duration, in milliseconds, during which the tone should be sustained. A value of zero uses a default
    ///                duration.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pCustomToneCollection</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> There is not enough memory to allocate the tones buffer. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>TAPI_E_INVALCALLSTATE</b></dt> </dl> </td> <td width="60%"> The call must be in the
    ///    <i>connected</i> state. </td> </tr> </table>
    ///    
    HRESULT GenerateCustomTonesByCollection(ITCollection2 pCustomToneCollection, int lDuration);
    ///The <b>CreateDetectToneObject</b> method creates a detect tone object to use with the DetectTonesByCollection
    ///method. This method is intended for Visual Basic and scripting applications. C/C++ applications should use the
    ///DetectTones method instead.
    ///Params:
    ///    ppDetectTone = Pointer to an ITDetectTone interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppDetectTone</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> There is not enough memory to allocate the object. </td> </tr> </table>
    ///    
    HRESULT CreateDetectToneObject(ITDetectTone* ppDetectTone);
    ///The <b>CreateCustomToneObject</b> method creates a custom tone object to use with the
    ///GenerateCustomTonesByCollection method. This method is intended for Visual Basic and scripting applications.
    ///C/C++ applications should use the GenerateCustomTones method instead.
    ///Params:
    ///    ppCustomTone = Pointer to an ITCustomTone interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppCustomTone</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> There is not enough memory to allocate the object. </td> </tr> </table>
    ///    
    HRESULT CreateCustomToneObject(ITCustomTone* ppCustomTone);
    ///The <b>GetIDAsVariant</b> method gets the identifier for the device associated with the current call. This method
    ///is intended for Visual Basic and scripting applications. C/C++ applications should use the
    ///ITLegacyCallMediaControl::GetID method.
    ///Params:
    ///    bstrDeviceClass = <b>BSTR</b> representing the TAPI device class.
    ///    pVarDeviceID = Pointer to a variant array of bytes of type VT_ARRAY | VT_UI1 which contains the identifier for the device
    ///                   specified in <i>bstrDeviceClass</i>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pVarDeviceID</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT GetIDAsVariant(BSTR bstrDeviceClass, VARIANT* pVarDeviceID);
}

///The <b>ITDetectTone</b> interface exposes methods that allow an application to specify the tones and tone
///characteristics that should cause the TAPI Server to generate a tone event. The
///ITLegacyCallMediaControl2::CreateDetectToneObject and ITLegacyCallMediaControl2::DetectTonesByCollection methods
///create the <b>ITDetectTone</b> interface.
@GUID("961F79BD-3097-49DF-A1D6-909B77E89CA0")
interface ITDetectTone : IDispatch
{
    ///The <b>get_AppSpecific</b> method retrieves the application-defined tag that identifies the tone to detect.
    ///Params:
    ///    plAppSpecific = Pointer to a value to receive the application-specific identifier for the tone. When the TAPI Server detects
    ///                    the tone, the value of this parameter is passed back to the application in the <b>TE_TONEEVENT</b> event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plAppSpecific</i>
    ///    parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_AppSpecific(int* plAppSpecific);
    ///The <b>put_AppSpecific</b> method sets the application-defined tag that identifies the tone to detect.
    ///Params:
    ///    lAppSpecific = Specifies an application-specific tag that identifies the tone to detect. When the TAPI Server detects the
    ///                   tone, the value of this parameter is passed back to the application in the <b>TE_TONEEVENT</b> event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_AppSpecific(int lAppSpecific);
    ///The <b>get_Duration</b> method retrieves the length of time during which a tone should be present before the TAPI
    ///Server generates a tone event.
    ///Params:
    ///    plDuration = Pointer to a value that receives the tone duration, in milliseconds, during which the specified tone should
    ///                 be present.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plDuration</i> parameter
    ///    is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Duration(int* plDuration);
    ///The <b>put_Duration</b> method sets the length of time during which a tone should be present before the TAPI
    ///Server generates a tone event.
    ///Params:
    ///    lDuration = Specifies the tone duration, in milliseconds, during which the specified tone should be present.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_Duration(int lDuration);
    ///The <b>get_Frequency</b> method retrieves the frequency of the tone for which the TAPI Server generates a tone
    ///event.
    ///Params:
    ///    Index = Specifies the index of the tone.
    ///    plFrequency = Pointer to a value to receive the frequency, in hertz, of the tone. For more information, see the following
    ///                  Remarks section.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plFrequency</i> parameter
    ///    is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Frequency(int Index, int* plFrequency);
    ///The <b>put_Frequency</b> method sets the frequency of the tone for which the TAPI Server should generate a tone
    ///event.
    ///Params:
    ///    Index = Specifies the index of the tone to set.
    ///    lFrequency = Specifies the frequency, in hertz, of the tone. For more information, see the following Remarks section.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_Frequency(int Index, int lFrequency);
}

///The <b>ITCustomTone</b> interface exposes methods that allow detailed control over the custom tones that are
///available with some phone sets. The ITLegacyCallMediaControl2::CreateCustomToneObject and
///ITLegacyCallMediaControl2::GenerateCustomTonesByCollection methods create the <b>ITCustomTone</b> interface.
@GUID("357AD764-B3C6-4B2A-8FA5-0722827A9254")
interface ITCustomTone : IDispatch
{
    ///The <b>get_Frequency</b> method retrieves the frequency of the tone component to generate.
    ///Params:
    ///    plFrequency = Pointer to a value to receive the frequency, in hertz, of the tone component.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plFrequency</i> parameter
    ///    is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Frequency(int* plFrequency);
    ///The <b>put_Frequency</b> method sets the frequency of the tone component to generate.
    ///Params:
    ///    lFrequency = Specifies the frequency, in hertz, of the tone component.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_Frequency(int lFrequency);
    ///The <b>get_CadenceOn</b> method retrieves the "on" duration of the cadence of the custom tone to generate.
    ///Params:
    ///    plCadenceOn = Pointer to a value to receive the "on" duration, in milliseconds, of the cadence of the custom tone. Zero
    ///                  means no tone is generated.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCadenceOn</i> parameter
    ///    is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_CadenceOn(int* plCadenceOn);
    ///The <b>put_CadenceOn</b> method sets the "on" duration of the cadence of the custom tone to generate.
    ///Params:
    ///    CadenceOn = Specifies the "on" duration, in milliseconds, of the cadence of the custom tone to generate. Zero means no
    ///                tone is generated.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_CadenceOn(int CadenceOn);
    ///The <b>get_CadenceOff</b> method retrieves the "off" duration of the cadence of the custom tone to generate.
    ///Params:
    ///    plCadenceOff = Pointer to a value to receive the "off" duration, in milliseconds, of the cadence of the custom tone. Zero
    ///                   means no off time, that is, a constant tone.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCadenceOff</i>
    ///    parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_CadenceOff(int* plCadenceOff);
    ///The <b>put_CadenceOff</b> method sets the "off" duration of the cadence of the custom tone to generate.
    ///Params:
    ///    lCadenceOff = Specifies the "off" duration, in milliseconds, of the cadence of the custom tone to generate. Zero means no
    ///                  off time, that is, a constant tone.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_CadenceOff(int lCadenceOff);
    ///The <b>get_Volume</b> method retrieves the volume level at which to generate the tone.
    ///Params:
    ///    plVolume = Pointer to a value to receive the volume level. A value of 0x0000FFFF represents full volume; a value of
    ///               0x00000000 represents silence.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plVolume</i> parameter is
    ///    not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Volume(int* plVolume);
    ///The <b>put_Volume</b> method sets the volume level at which to generate the tone.
    ///Params:
    ///    lVolume = Specifies the volume level for the tone. A value of 0x0000FFFF represents full volume; a value of 0x00000000
    ///              represents silence.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_Volume(int lVolume);
}

///The <b>IEnumPhone</b> interface provides COM-standard enumeration methods for the ITPhone interface. The
///ITAddress2::EnumeratePhones and ITTAPI2::EnumeratePhones methods return a pointer to <b>IEnumPhone</b>. The
///<b>IEnumPhone</b> interface is hidden from Visual Basic and scripting languages.
@GUID("F15B7669-4780-4595-8C89-FB369C8CF7AA")
interface IEnumPhone : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence. This method is
    ///hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITPhone list of pointers returned.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>ppElements</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, char* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets the enumeration sequence to the beginning. This method is hidden from Visual Basic
    ///and scripting languages.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence. This method
    ///is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///This method is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    ppEnum = Pointer to new IEnumPhone interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The method failed for unknown reasons. </td> </tr>
    ///    </table>
    ///    
    HRESULT Clone(IEnumPhone* ppEnum);
}

///The <b>IEnumTerminal</b> interface provides COM-standard enumeration methods for the ITTerminal interface. The
///following methods return a pointer to <b>IEnumTerminal</b>:<dl> <dd> ITStream::EnumerateTerminals </dd> <dd>
///ITSubStream::EnumerateTerminals </dd> <dd> ITTerminalSupport::EnumerateStaticTerminals </dd> </dl> The
///<b>IEnumTerminal</b> interface is hidden from Visual Basic and scripting languages.
@GUID("AE269CF4-935E-11D0-835C-00AA003CCABD")
interface IEnumTerminal : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence. This method is
    ///hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITTerminal pointers returned.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppElements</i> parameter is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, ITTerminal* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets to the beginning of the enumeration sequence. This method is hidden from Visual
    ///Basic and scripting languages.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence. This method
    ///is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///This method is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    ppEnum = Pointer to new IEnumTerminal interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumTerminal* ppEnum);
}

///The <b>IEnumTerminalClass</b> interface provides COM-standard enumeration methods to discover and use the dynamic
///terminal classes that are available. The ITTerminalSupport::EnumerateDynamicTerminalClasses method returns a pointer
///to this interface. The <b>IEnumTerminalClass</b> interface is hidden from Visual Basic and scripting languages.
@GUID("AE269CF5-935E-11D0-835C-00AA003CCABD")
interface IEnumTerminalClass : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence. This method is
    ///hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements requested.
    ///    pElements = Pointer to list of elements returned.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppElements</i> parameter is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, char* pElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets to the beginning of the enumeration sequence. This method is hidden from Visual
    ///Basic and scripting languages.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence. This method
    ///is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///This method is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    ppEnum = Pointer to new IEnumTerminalClass interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumTerminalClass* ppEnum);
}

///The <b>IEnumCall</b> interface provides COM-standard enumeration methods for the ITCallInfo interface. The
///ITCallHub::EnumerateCalls and ITAddress::EnumerateCalls methods return a pointer to <b>IEnumCall</b>. The
///<b>IEnumCall</b> interface is hidden from Visual Basic and scripting languages.
@GUID("AE269CF6-935E-11D0-835C-00AA003CCABD")
interface IEnumCall : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence. This method is
    ///hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITCallInfo pointer.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppElements</i> parameter is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, ITCallInfo* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets to the beginning of the enumeration sequence. This method is hidden from Visual
    ///Basic and scripting languages.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence. This method
    ///is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///This method is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    ppEnum = Pointer to new IEnumCall interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumCall* ppEnum);
}

///The <b>IEnumAddress</b> interface provides COM-standard enumeration methods for the ITAddress interface. The
///ITTAPI::EnumerateAddresses and ITAgentHandler::EnumerateUsableAddresses methods return a pointer to
///<b>IEnumAddress</b>. The <b>IEnumAddress</b> interface is hidden from Visual Basic and scripting languages.
@GUID("1666FCA1-9363-11D0-835C-00AA003CCABD")
interface IEnumAddress : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence. This method is
    ///hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITAddress pointer.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppElements</i> parameter is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, char* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets to the beginning of the enumeration sequence. This method is hidden from Visual
    ///Basic and scripting languages.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence. This method
    ///is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///This method is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    ppEnum = Pointer to new IEnumAddress interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumAddress* ppEnum);
}

///The <b>IEnumCallHub</b> interface provides COM-standard enumeration methods for the ITCallHub interface. The
///ITTAPI::EnumerateCallHubs method returns a pointer to <b>IEnumCallHub</b>. The <b>IEnumCallHub</b> interface is
///hidden from Visual Basic and scripting languages.
@GUID("A3C15450-5B92-11D1-8F4E-00C04FB6809F")
interface IEnumCallHub : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence. This method is
    ///hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITCallHub list of pointers returned.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppElements</i> parameter is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, char* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets to the beginning of the enumeration sequence. This method is hidden from Visual
    ///Basic and scripting languages.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence. This method
    ///is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///This method is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    ppEnum = Pointer to new IEnumCallHub interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumCallHub* ppEnum);
}

///The <b>IEnumBstr</b> interface provides COM-standard methods to enumerate <b>BSTR</b> strings. The following methods
///return a pointer to this interface: <ul> <li> ITAddressCapabilities::EnumerateCallTreatments </li> <li>
///ITAddressCapabilities::EnumerateCompletionMessages </li> <li> ITAddressCapabilities::EnumerateDeviceClasses </li>
///<li> IMcastLeaseInfo::EnumerateAddresses </li> </ul>The <b>IEnumBstr</b> interface is hidden from Visual Basic and
///scripting languages.
@GUID("35372049-0BC6-11D2-A033-00C04FB6809F")
interface IEnumBstr : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence. This method is
    ///hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppStrings = Pointer to the list of <b>BSTR</b> pointers returned.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppStrings</i> parameter is not a valid pointer.
    ///    </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, char* ppStrings, uint* pceltFetched);
    ///The <b>Reset</b> method resets to the beginning of the enumeration sequence. This method is hidden from Visual
    ///Basic and scripting languages.
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence. This method
    ///is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements to skip.
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///This method is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    ppEnum = Pointer to new IEnumBstr interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumBstr* ppEnum);
}

///The <b>IEnumPluggableTerminalClassInfo</b> interface provides COM-standard enumeration methods for the
///ITPluggableTerminalClassInfo interface. The ITTerminalSupport2::EnumeratePluggableTerminalClasses method returns a
///pointer to <b>IEnumPluggableTerminalClassInfo</b>. The <b>IEnumPluggableTerminalClassInfo</b> interface is hidden
///from Visual Basic and scripting languages.
@GUID("4567450C-DBEE-4E3F-AAF5-37BF9EBF5E29")
interface IEnumPluggableTerminalClassInfo : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence. This method is
    ///hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITPluggableTerminalClassInfo list of pointers returned.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>ppElements</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, char* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets the enumeration sequence to the beginning. This method is hidden from Visual Basic
    ///and scripting languages.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence. This method
    ///is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///This method is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    ppEnum = Pointer to new IEnumPluggableTerminalClassInfo interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The method failed for unknown reasons. </td> </tr>
    ///    </table>
    ///    
    HRESULT Clone(IEnumPluggableTerminalClassInfo* ppEnum);
}

///The <b>IEnumPluggableSuperclassInfo</b> interface provides COM-standard enumeration methods for the
///ITPluggableTerminalSuperclassInfo interface. The ITTerminalSupport2::EnumeratePluggableSuperclasses method returns a
///pointer to <b>IEnumPluggableSuperclassInfo</b>. The <b>IEnumPluggableSuperclassInfo</b> interface is hidden from
///Visual Basic and scripting languages.
@GUID("E9586A80-89E6-4CFF-931D-478D5751F4C0")
interface IEnumPluggableSuperclassInfo : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence. This method is
    ///hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITPluggableTerminalSuperclassInfo list of pointers returned.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>ppElements</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, char* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets the enumeration sequence to the beginning. This method is hidden from Visual Basic
    ///and scripting languages.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence. This method
    ///is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///This method is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    ppEnum = Pointer to new IEnumPluggableSuperclassInfo interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The method failed for unknown reasons. </td> </tr>
    ///    </table>
    ///    
    HRESULT Clone(IEnumPluggableSuperclassInfo* ppEnum);
}

///The <b>ITPhoneEvent</b> interface contains methods that retrieve the description of phone events that have occurred.
///When the application's implementation of the ITTAPIEventNotification::Event method indicates a TAPI_EVENT equal to
///<b>TE_PHONEEVENT</b>, the method's <i>pEvent</i> parameter is an IDispatch pointer for the <b>ITPhoneEvent</b>
///interface. <div class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter method and set an event filter
///mask that includes <b>TE_PHONEEVENT</b> to enable reception of phone events. If you do not call
///<b>ITTAPI::put_EventFilter</b>, your application will not receive any events. For more information, see the Events
///overview.</div><div> </div>
@GUID("8F942DD8-64ED-4AAF-A77D-B23DB0837EAD")
interface ITPhoneEvent : IDispatch
{
    ///The <b>get_Phone</b> method returns a pointer to the ITPhone interface on the phone object that fired this event.
    ///Params:
    ///    ppPhone = Pointer to the ITPhone interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Phone(ITPhone* ppPhone);
    ///The <b>get_Event</b> method returns a PHONE_EVENT value specifying the type of phone event that occurred.
    ///Params:
    ///    pEvent = The PHONE_EVENT descriptor of the event.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Event(PHONE_EVENT* pEvent);
    ///The <b>get_ButtonState</b> method returns a PHONE_BUTTON_STATE value specifying the state to which the button has
    ///transitioned. This information is available only when the ITPhoneEvent::get_Event method returns PE_BUTTON.
    ///Params:
    ///    pState = Pointer to the PHONE_BUTTON_STATE descriptor of the button's current state.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_ButtonState(PHONE_BUTTON_STATE* pState);
    ///The <b>get_HookSwitchState</b> method returns a PHONE_HOOK_SWITCH_STATE value specifying the state to which the
    ///hookswitch has transitioned. This information is available only when the ITPhoneEvent::get_Event method returns
    ///PE_HOOKSWITCH.
    ///Params:
    ///    pState = Pointer to the PHONE_HOOK_SWITCH_STATE descriptor of the current hookswitch state.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_HookSwitchState(PHONE_HOOK_SWITCH_STATE* pState);
    ///The <b>get_HookSwitchDevice</b> method returns a PHONE_HOOK_SWITCH_DEVICE value specifying the hookswitch device
    ///that changed state. This information is available only when the ITPhoneEvent::get_Event method returns
    ///PE_HOOKSWITCH.
    ///Params:
    ///    pDevice = Pointer to the PHONE_HOOK_SWITCH_DEVICE descriptor of the type of device that has changed hookswitch state.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_HookSwitchDevice(PHONE_HOOK_SWITCH_DEVICE* pDevice);
    ///The <b>get_RingMode</b> method returns a long value specifying the ring mode to which the phone has transitioned.
    ///This information is available only when the ITPhoneEvent::get_Event method returns PE_RINGMODE.
    ///Params:
    ///    plRingMode = Ring mode.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_RingMode(int* plRingMode);
    ///The <b>get_ButtonLampId</b> method returns a long value indicating which button or lamp triggered the event. This
    ///information is available only when ITPhoneEvent::get_Event returns PE_LAMPMODE or PE_BUTTON.
    ///Params:
    ///    plButtonLampId = Button or lamp ID.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_ButtonLampId(int* plButtonLampId);
    ///The <b>get_NumberGathered</b> method returns a <b>BSTR</b> value specifying the phone number that was gathered.
    ///This information is available only when the ITPhoneEvent::get_Event method returns PE_NUMBERGATHERED.
    ///Params:
    ///    ppNumber = Phone number that was gathered. The <b>BSTR</b> is allocated using SysAllocString and should be deallocated
    ///               by the client.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_NumberGathered(BSTR* ppNumber);
    ///The <b>get_Call</b> method returns a pointer to the ITCallInfo interface for the call object involved in the
    ///event.
    ///Params:
    ///    ppCallInfo = Pointer to the ITCallInfo interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppCallInfo</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Call(ITCallInfo* ppCallInfo);
}

///The <b>ITCallStateEvent</b> interface contains methods that retrieve the description of call state events. When the
///application's implementation of the ITTAPIEventNotification::Event method indicates a TAPI_EVENT equal to
///<b>TE_CALLSTATE</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b> pointer for the
///<b>ITCallStateEvent</b> interface. The methods of this interface can be used to retrieve information concerning the
///change that has occurred in the call state. <div class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter
///method and set an event filter mask that includes the <b>TE_CALLSTATE</b> event to enable reception of call state
///events. If you do not call <b>ITTAPI::put_EventFilter</b>, your application will not receive any events. For more
///information, see the Events overview.</div><div> </div>
@GUID("62F47097-95C9-11D0-835D-00AA003CCABD")
interface ITCallStateEvent : IDispatch
{
    ///The <b>get_Call</b> method gets a pointer to the call information interface for the call on which the event has
    ///occurred.
    ///Params:
    ///    ppCallInfo = Pointer to ITCallInfo interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppCallInfo</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Call(ITCallInfo* ppCallInfo);
    ///The <b>get_State</b> method gets information on the new call state.
    ///Params:
    ///    pCallState = Pointer to CALL_STATE constant.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pCallState</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_State(CALL_STATE* pCallState);
    ///The <b>get_Cause</b> method gets the cause associated with this event.
    ///Params:
    ///    pCEC = Pointer to CALL_STATE_EVENT_CAUSE indicator.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pCEC</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Cause(CALL_STATE_EVENT_CAUSE* pCEC);
    ///The <b>get_CallbackInstance</b> method gets a pointer to the callback instance associated with this event.
    ///Params:
    ///    plCallbackInstance = Pointer to callback instance returned by ITTAPI::RegisterCallNotifications.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plCallbackInstance</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_CallbackInstance(int* plCallbackInstance);
}

///The <b>ITPhoneDeviceSpecificEvent</b> exposes methods that allow an application to retrieve information about a phone
///device-specific event. For a code example that illustrates how to create this interface, see the Phone and Address
///Device-specific Events topic.
@GUID("63FFB2A6-872B-4CD3-A501-326E8FB40AF7")
interface ITPhoneDeviceSpecificEvent : IDispatch
{
    ///The <b>get_Phone</b> method retrieves the ITPhone interface pointer for a phone device event.
    ///Params:
    ///    ppPhone = Pointer to the ITPhone interface for the phone object involved in the event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppPhone</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Phone(ITPhone* ppPhone);
    ///The <b>get_lParam1</b> method retrieves the first of three buffers specific to a given phone device. The precise
    ///content and meaning of these buffers is defined by the provider.
    ///Params:
    ///    pParam1 = Pointer to a <b>long</b> concerning information on the phone device event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pParam1</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_lParam1(int* pParam1);
    ///The <b>get_lParam2</b> method retrieves the second of three buffers specific to a given phone device. The precise
    ///content and meaning of these buffers is defined by the provider.
    ///Params:
    ///    pParam2 = Pointer to a <b>long</b> concerning information on the phone device event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pParam2</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_lParam2(int* pParam2);
    ///The <b>get_lParam3</b> method retrieves the third of three buffers specific to a given phone device. The precise
    ///content and meaning of these buffers is defined by the provider.
    ///Params:
    ///    pParam3 = Pointer to a variable that receives information on the phone device event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pParam3</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_lParam3(int* pParam3);
}

///The <b>ITCallMediaEvent</b> interface contains methods that retrieve the description of media events. When the
///application's implementation of the ITTAPIEventNotification::Event method indicates a TAPI_EVENT equal to
///<b>TE_CALLMEDIA</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b> pointer for the
///<b>ITCallMediaEvent</b> interface. The methods of this interface can be used to retrieve information concerning the
///call media event that has occurred. <div class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter method
///and set an event filter mask that includes the <b>TE_CALLMEDIA</b> event to enable reception of call media events. If
///you do not call <b>ITTAPI::put_EventFilter</b>, your application will not receive any events. For more information,
///see the Events overview.</div><div> </div>
@GUID("FF36B87F-EC3A-11D0-8EE4-00C04FB6809F")
interface ITCallMediaEvent : IDispatch
{
    ///The <b>get_Call</b> method gets an ITCallInfo interface pointer for the call object associated with this event.
    ///Params:
    ///    ppCallInfo = Pointer to ITCallInfo interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppCallInfo</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Call(ITCallInfo* ppCallInfo);
    ///The <b>get_Event</b> method gets the call media event indicator.
    ///Params:
    ///    pCallMediaEvent = Pointer to CALL_MEDIA_EVENT indicator.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pCallMediaEvent</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Event(CALL_MEDIA_EVENT* pCallMediaEvent);
    ///The <b>get_Error</b> method gets the error associated with the media event, if any.
    ///Params:
    ///    phrError = Pointer to error.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>phrError</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Error(int* phrError);
    ///The <b>get_Terminal</b> method gets the terminal associated with the event.
    ///Params:
    ///    ppTerminal = Pointer to ITTerminal interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppTerminal</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Terminal(ITTerminal* ppTerminal);
    ///The <b>get_Stream</b> method gets a pointer to the ITStream interface associated with the call media event.
    ///Params:
    ///    ppStream = Pointer to ITStream interface pointer.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppStream</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Stream(ITStream* ppStream);
    ///The <b>get_Cause</b> method gets the cause of the call media event, such as a timeout on the renderer device.
    ///Params:
    ///    pCause = Pointer to CALL_MEDIA_EVENT_CAUSE.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pCause</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Cause(CALL_MEDIA_EVENT_CAUSE* pCause);
}

///The <b>ITDigitDetectionEvent</b> interface contains methods that retrieve the description of DTMF digit events. When
///the application's implementation of the ITTAPIEventNotification::Event method indicates a TAPI_EVENT equal to
///<b>TE_DIGITEVENT</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b> pointer for the
///<b>ITDigitDetectionEvent</b> interface. The methods of this interface can be used to detect DTMF digits during a
///call. This interface is implemented by the application and called by the TAPI 3 DLL. <div class="alert"><b>Note</b>
///You must call the ITTAPI::put_EventFilter method and set an event filter mask that includes the <b>TE_DIGITEVENT</b>
///event to enable reception of DTMF digit events. If you do not call <b>ITTAPI::put_EventFilter</b>, your application
///will not receive any events. You must also call ITLegacyCallMediaControl::DetectDigits to indicate which type of
///digit detection is needed. For more information, see the Events overview.</div><div> </div>
@GUID("80D3BFAC-57D9-11D2-A04A-00C04FB6809F")
interface ITDigitDetectionEvent : IDispatch
{
    ///The <b>get_Call</b> method gets a pointer to the ITCallInfo interface for the call on which the event occurred.
    ///Params:
    ///    ppCallInfo = Pointer to ITCallInfo interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppCallInfo</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Call(ITCallInfo* ppCallInfo);
    ///The <b>get_Digit</b> method retrieves an unsigned char pointer to the digit that was detected.
    ///Params:
    ///    pucDigit = Pointer to the digit.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pucDigit</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Digit(ubyte* pucDigit);
    ///The <b>get_DigitMode</b> method gets the indicator of the line digit mode, such as LINEDIGITMODE_DTMF.
    ///Params:
    ///    pDigitMode = Pointer to indicator of digit mode.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pDigitMode</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_DigitMode(int* pDigitMode);
    ///The <b>get_TickCount</b> method gets the "tick count" (number of milliseconds since Windows started) at which the
    ///digit gathering completed.
    ///Params:
    ///    plTickCount = Pointer to tick count.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plTickCount</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_TickCount(int* plTickCount);
    ///The <b>get_CallbackInstance</b> method gets a pointer to the callback instance associated with the event.
    ///Params:
    ///    plCallbackInstance = Pointer to the callback instance returned by ITTAPI::RegisterCallNotifications.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plCallbackInstance</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_CallbackInstance(int* plCallbackInstance);
}

///The <b>ITDigitGenerationEvent</b> interface contains methods that describe digit generation events. When the
///application's implementation of the ITTAPIEventNotification::Event method indicates a TAPI_EVENT equal to
///<b>TE_GENERATEEVENT</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b> pointer for the
///<b>ITDigitGenerationEvent</b> interface. The methods of this interface can be used to report on calls that require
///the generation of DTMF digits. This interface is implemented by the application and called by the TAPI 3 DLL. <div
///class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter method and set an event filter mask that includes
///the <b>TE_GENERATEEVENT</b> event to enable reception of digit generation events. If you do not call
///<b>ITTAPI::put_EventFilter</b>, your application will not receive any events. For more information, see the Events
///overview.</div><div> </div>
@GUID("80D3BFAD-57D9-11D2-A04A-00C04FB6809F")
interface ITDigitGenerationEvent : IDispatch
{
    ///The <b>get_Call</b> method returns an ITCallInfo interface pointer for the call on which the event is required.
    ///Params:
    ///    ppCallInfo = Pointer to ITCallInfo interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppCallInfo</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Call(ITCallInfo* ppCallInfo);
    ///The <b>get_GenerationTermination</b> method gets the digit or digits that indicate the end of the generated digit
    ///series.
    ///Params:
    ///    plGenerationTermination = Pointer to digit or digits that indicate the end of the generated digit series.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>plGenerationTermination</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT get_GenerationTermination(int* plGenerationTermination);
    ///The <b>get_TickCount</b> method gets the "tick count" (number of milliseconds since Windows started) at which the
    ///digit generation completed.
    ///Params:
    ///    plTickCount = Pointer to tick count.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plTickCount</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_TickCount(int* plTickCount);
    ///The <b>get_CallbackInstance</b> method gets a pointer to the callback instance associated with the event.
    ///Params:
    ///    plCallbackInstance = Pointer to the callback instance returned by ITTAPI::RegisterCallNotifications.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCallbackInstance</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_CallbackInstance(int* plCallbackInstance);
}

///The <b>ITDigitsGatheredEvent</b> interface exposes methods that allow an application to retrieve data when the TAPI
///Server sends an event indicating that the Server has gathered digits required by the application.
@GUID("E52EC4C1-CBA3-441A-9E6A-93CB909E9724")
interface ITDigitsGatheredEvent : IDispatch
{
    ///The <b>get_Call</b> method gets a pointer to the call information interface for the call object on which the
    ///event occurred.
    ///Params:
    ///    ppCallInfo = Pointer to the ITCallInfo interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppCallInfo</i> parameter
    ///    is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Call(ITCallInfo* ppCallInfo);
    ///The <b>get_Digits</b> method gets the gathered digits for the call.
    ///Params:
    ///    ppDigits = Pointer to a <b>BSTR</b> where the gathered digits are stored.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppDigits</i> parameter is
    ///    not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Digits(BSTR* ppDigits);
    ///The <b>get_GatherTermination</b> method gets the reason why the TAPI Server terminated the gathering of digits on
    ///the call.
    ///Params:
    ///    pGatherTermination = Pointer to a value from the TAPI_GATHERTERM enumeration.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pGatherTermination</i>
    ///    parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_GatherTermination(TAPI_GATHERTERM* pGatherTermination);
    ///The <b>get_TickCount</b> method gets the "tick count" (the number of milliseconds since Windows started) at which
    ///digit-gathering completed.
    ///Params:
    ///    plTickCount = Pointer to a value to receive the tick count.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plTickCount</i> parameter
    ///    is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_TickCount(int* plTickCount);
    ///The <b>get_CallbackInstance</b> method gets a pointer to the application's callback function that will process
    ///the event.
    ///Params:
    ///    plCallbackInstance = Pointer to the callback instance returned by ITTAPI::RegisterCallNotifications.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCallbackInstance</i>
    ///    parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_CallbackInstance(int* plCallbackInstance);
}

///The <b>ITToneDetectionEvent</b> interface exposes methods that allow an application to retrieve information about a
///tone detection event.
@GUID("407E0FAF-D047-4753-B0C6-8E060373FECD")
interface ITToneDetectionEvent : IDispatch
{
    ///The <b>get_Call</b> method gets a pointer to the call information interface for the call object on which the tone
    ///detection event occurred.
    ///Params:
    ///    ppCallInfo = Pointer to the ITCallInfo interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppCallInfo</i> parameter is
    ///    not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Call(ITCallInfo* ppCallInfo);
    ///The <b>get_AppSpecific</b> method gets the application-defined tag that identifies the tone associated with the
    ///tone detection event.
    ///Params:
    ///    plAppSpecific = Pointer to a value to receive the application-specific identifier for the tone, as defined in the
    ///                    ITDetectTone object or in the LINEMONITORTONE structure.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plAppSpecific</i>
    ///    parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_AppSpecific(int* plAppSpecific);
    ///The <b>get_TickCount</b> method gets the "tick count" (the number of milliseconds since Windows started) at which
    ///the tone was detected.
    ///Params:
    ///    plTickCount = Pointer to a value to receive the tick count.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plTickCount</i> parameter
    ///    is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_TickCount(int* plTickCount);
    ///The <b>get_CallbackInstance</b> method gets a pointer to the application's callback function that will process
    ///the event.
    ///Params:
    ///    plCallbackInstance = Pointer to the callback instance returned by the ITTAPI::RegisterCallNotifications method.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code/value</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>plCallbackInstance</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt>8</dt>
    ///    </dl> </td> <td width="60%"> LegacyMediaControl2 Enums </td> </tr> </table>
    ///    
    HRESULT get_CallbackInstance(int* plCallbackInstance);
}

///The <b>ITTAPIObjectEvent</b> interface contains methods that retrieve the description of TAPI object events. When the
///application's implementation of the ITTAPIEventNotification::Event method indicates a TAPI_EVENT equal to
///<b>TE_TAPIOBJECT</b>, the method's <i>pEvent</i> parameter is an IDispatch pointer for the <b>ITTAPIObjectEvent</b>
///interface. The methods of this interface can be used to retrieve information concerning the TAPI object change that
///has occurred. <div class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter method and set an event filter
///mask that includes the <b>TE_TAPIOBJECT</b> event to enable reception of TAPI object events. If you do not call
///<b>ITTAPI::put_EventFilter</b>, your application will not receive any events. For more information, see the Events
///overview.</div><div> </div>The ITTAPIObjectEvent2 interface is an extension of the <b>ITTAPIObjectEvent</b>
///interface. <b>ITTAPIObjectEvent2</b> exposes an additional method that returns a pointer to an ITPhone interface on
///the phone object that caused the TAPI object event.
@GUID("F4854D48-937A-11D1-BB58-00C04FB6809F")
interface ITTAPIObjectEvent : IDispatch
{
    ///The <b>get_TAPIObject</b> method gets a pointer to the TAPI object on which the event occurred.
    ///Params:
    ///    ppTAPIObject = Pointer to an ITTAPI interface of the TAPI object on which the event occurred.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppTAPIObject</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_TAPIObject(ITTAPI* ppTAPIObject);
    ///The <b>get_Event</b> method gets information concerning an asynchronous event notification. The application uses
    ///TAPIOBJECT_EVENT to determine what type of event is being signaled.
    ///Params:
    ///    pEvent = TAPIOBJECT_EVENT indicator of the event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pEvent</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Event(TAPIOBJECT_EVENT* pEvent);
    ///The <b>get_Address</b> method gets a pointer to the Address object on which the event occurred.
    ///Params:
    ///    ppAddress = Pointer to an ITAddress interface pointer.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppAddress</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Address(ITAddress* ppAddress);
    ///The <b>get_CallbackInstance</b> method gets a pointer to the callback instance associated with the event.
    ///Params:
    ///    plCallbackInstance = Pointer to the callback instance returned by ITTAPI::RegisterCallNotifications.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppAddress</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_CallbackInstance(int* plCallbackInstance);
}

///The <b>ITTAPIObjectEvent2</b> interface is an extension of the ITTAPIObjectEvent interface. <b>ITTAPIObjectEvent2</b>
///exposes an additional method that returns a pointer to an ITPhone interface on the phone object that caused the TAPI
///object event. When the application's implementation of the ITTAPIEventNotification::Event method indicates a
///TAPI_EVENT equal to <b>TE_TAPIOBJECT</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b> pointer for the
///<b>ITTAPIObjectEvent2</b> interface. <div class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter method
///and set an event filter mask that includes the <b>TE_TAPIOBJECT</b> event to enable reception of TAPI object events.
///If you do not call <b>ITTAPI::put_EventFilter</b>, your application will not receive any events. For more
///information, see the Events overview.</div><div> </div>
@GUID("359DDA6E-68CE-4383-BF0B-169133C41B46")
interface ITTAPIObjectEvent2 : ITTAPIObjectEvent
{
    ///The <b>get_Phone</b> method returns a pointer to the ITPhone interface on the phone object that caused this TAPI
    ///object event to be fired.
    ///Params:
    ///    ppPhone = Pointer to the ITPhone interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Phone(ITPhone* ppPhone);
}

///The <b>ITTAPIEventNotification</b> interface is an outgoing interface that allows an application to control the
///processing of event information. The application must implement this interface: it must create a COM object that
///supports this interface, and then register it using the COM standard IConnectionPointContainer and IConnectionPoint
///interfaces. The ITTAPIEventNotification::Event method of this interface is called by TAPI in response to an event.
///Typically, the application implements a set of switch statements that use the value of a TAPI_EVENT enumerator to
///determine the response to the event. After registration of this interface, the application calls
///ITTAPI::put_EventFilter to specify which events it must receive. If this method is not called, the application will
///not receive any events. The application may then call ITTAPI::RegisterCallNotifications to notify TAPI of addresses
///and media types for which the application will accept incoming call sessions. Please refer to the Event overview for
///additional information on event handling.
@GUID("EDDB9426-3B91-11D1-8F30-00C04FB6809F")
interface ITTAPIEventNotification : IUnknown
{
    ///The <b>Event</b> method is called by TAPI to determine the response to an asynchronous event notification. The
    ///application implements a set of case statements that use <i>TapiEvent</i> to determine the type of event being
    ///signaled, then calls <b>IUnknown::QueryInterface</b> on <i>pEvent</i> to obtain the appropriate event interface
    ///pointer. Each event defined by TAPI 3 has an interface associated with it. The specific events handled depend on
    ///the needs of the application.
    ///Params:
    ///    TapiEvent = TAPI_EVENT indicator of the event.
    ///    pEvent = Pointer to an <b>IDispatch</b> interface of the object associated with this event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pEvent</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Event(TAPI_EVENT TapiEvent, IDispatch pEvent);
}

///The <b>ITCallHubEvent</b> interface contains methods that retrieve the description of CallHub events. When the
///application's implementation of the ITTAPIEventNotification::Event method indicates a TAPI_EVENT equal to
///<b>TE_CALLHUB</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b> pointer for the <b>ITCallHubEvent</b>
///interface. The methods of this interface can be used to retrieve information concerning the CallHub change that has
///occurred. <div class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter method and set an event filter
///mask that includes the <b>TE_CALLHUB</b> event to enable reception of CallHub events. If you do not call
///<b>ITTAPI::put_EventFilter</b>, your application will not receive any events. For more information, see the Events
///overview.</div><div> </div>
@GUID("A3C15451-5B92-11D1-8F4E-00C04FB6809F")
interface ITCallHubEvent : IDispatch
{
    ///The <b>get_Event</b> method returns a pointer to a CALLHUB_EVENT enum description of the event that occurred.
    ///Params:
    ///    pEvent = Pointer to a CALLHUB_EVENT enum description of the event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pEvent</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Event(CALLHUB_EVENT* pEvent);
    ///The <b>get_CallHub</b> method returns a pointer to the ITCallHub interface on which the event occurred.
    ///Params:
    ///    ppCallHub = Pointer to ITCallHub interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pCallHubState</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_CallHub(ITCallHub* ppCallHub);
    ///The <b>get_Call</b> method returns a pointer to the ITCallInfo interface of the call on which the event occurred.
    ///Params:
    ///    ppCall = <b>ITCallInfo</b> interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppCallt</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Call(ITCallInfo* ppCall);
}

///The <b>ITAddressEvent</b> interface contains methods that retrieve the description of address events. When the
///application's implementation of the ITTAPIEventNotification::Event method indicates a TAPI_EVENT equal to
///<b>TE_ADDRESS</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b> pointer for the <b>ITAddressEvent</b>
///interface. The methods of this interface can be used to retrieve information concerning the type of event, which
///address the event has occurred on, and for which terminal. <div class="alert"><b>Note</b> You must call the
///ITTAPI::put_EventFilter method and set an event filter mask that includes the <b>TE_ADDRESS</b> event to enable
///reception of address events. If you do not call <b>ITTAPI::put_EventFilter</b>, your application will not receive any
///events. For more information, see the Events overview.</div><div> </div>
@GUID("831CE2D1-83B5-11D1-BB5C-00C04FB6809F")
interface ITAddressEvent : IDispatch
{
    ///The <b>get_Address</b> method gets a pointer to the ITAddress object involved in an event.
    ///Params:
    ///    ppAddress = Pointer to an ITAddress interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppAddress</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Address(ITAddress* ppAddress);
    ///The <b>get_Event</b> method gets the ADDRESS_EVENT descriptor of an event.
    ///Params:
    ///    pEvent = Pointer to the ADDRESS_EVENT descriptor of an event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pEvent</i> parameter is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pEvent</i> parameter is not a valid pointer.
    ///    </td> </tr> </table>
    ///    
    HRESULT get_Event(ADDRESS_EVENT* pEvent);
    ///The <b>get_Terminal</b> method gets a pointer to the ITTerminal interface associated with the event.
    ///Params:
    ///    ppTerminal = Pointer to ITTerminal interface, or <b>NULL</b> if the event does not refer to a terminal.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ppTerminal</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppTerminal</i> parameter is not a valid
    ///    pointer. </td> </tr> </table>
    ///    
    HRESULT get_Terminal(ITTerminal* ppTerminal);
}

///The <b>ITAddressDeviceSpecificEvent</b> exposes methods that allow an application to retrieve information about a
///device-specific event. For a code example that illustrates how to create this interface, see the Phone and Address
///Device-specific Events topic.
@GUID("3ACB216B-40BD-487A-8672-5CE77BD7E3A3")
interface ITAddressDeviceSpecificEvent : IDispatch
{
    ///The <b>get_Address</b> method gets a pointer to the ITAddress interface of the Address object involved in the
    ///event.
    ///Params:
    ///    ppAddress = Pointer to the ITAddress interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppAddress</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Address(ITAddress* ppAddress);
    ///The <b>get_Call</b> method gets a pointer to the ITCallInfo interface pointer for the call object involved in the
    ///event.
    ///Params:
    ///    ppCall = Pointer to the ITCallInfo interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppCall</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Call(ITCallInfo* ppCall);
    ///The <b>get_lParam1</b> method retrieves the first of three buffers specific to a given address device. The
    ///precise content and meaning of these buffers is defined by the provider.
    ///Params:
    ///    pParam1 = Pointer to a <b>long</b> concerning information on the address device event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pParam1</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_lParam1(int* pParam1);
    ///The <b>get_lParam2</b> method retrieves the second of three buffers specific to a given address device. The
    ///precise content and meaning of these buffers is defined by the provider.
    ///Params:
    ///    pParam2 = Pointer to a <b>long</b> concerning information on the address device event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pParam2</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_lParam2(int* pParam2);
    ///The <b>get_lParam3</b> method retrieves the third of three buffers specific to a given address device. The
    ///precise content and meaning of these buffers is defined by the provider.
    ///Params:
    ///    pParam3 = Pointer to a <b>long</b> concerning information on the address device event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pParam3</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_lParam3(int* pParam3);
}

///The <b>ITFileTerminalEvent</b> interface contains methods that retrieve the description of file terminal events that
///have occurred. When the application's implementation of the ITTAPIEventNotification::Event method indicates a
///TAPI_EVENT equal to <b>TE_FILETERMINAL</b>, the method's <i>pEvent</i> parameter is an IDispatch pointer for the
///<b>ITFileTerminalEvent</b> interface. <div class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter method
///and set an event filter mask that includes <b>TE_FILETERMINAL</b> to enable reception of file terminal events. If you
///do not call <b>ITTAPI::put_EventFilter</b>, your application will not receive any events. For more information, see
///the Events overview.</div><div> </div>
@GUID("E4A7FBAC-8C17-4427-9F55-9F589AC8AF00")
interface ITFileTerminalEvent : IDispatch
{
    ///The <b>get_Terminal</b> method returns the file terminal that generated this event.
    ///Params:
    ///    ppTerminal = Pointer to the ITTerminal interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Terminal(ITTerminal* ppTerminal);
    ///The <b>get_Track</b> method returns the track terminal that generated this event.
    ///Params:
    ///    ppTrackTerminal = Pointer to ITFileTrack interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Track(ITFileTrack* ppTrackTerminal);
    ///The <b>get_Call</b> method gets a pointer to the call information interface for the call on which the event has
    ///occurred.
    ///Params:
    ///    ppCall = Pointer to the ITCallInfo interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Call(ITCallInfo* ppCall);
    ///The <b>get_State</b> method gets information on the new file terminal state.
    ///Params:
    ///    pState = TERMINAL_MEDIA_STATE descriptor of the new terminal state.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_State(TERMINAL_MEDIA_STATE* pState);
    ///The <b>get_Cause</b> method gets the cause associated with this event.
    ///Params:
    ///    pCause = FT_STATE_EVENT_CAUSE descriptor of the cause of this event.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Cause(FT_STATE_EVENT_CAUSE* pCause);
    ///The <b>get_Error</b> method gets the error code for the event.
    ///Params:
    ///    phrErrorCode = HRESULT cast of error code associated with this event.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Error(int* phrErrorCode);
}

///The <b>ITTTSTerminalEvent</b> interface contains methods that retrieve the description of Text-to-Speech (TTS)
///terminal events that have occurred. When the application's implementation of the ITTAPIEventNotification::Event
///method indicates a TAPI_EVENT equal to <b>TE_TTSTERMINAL</b>, the method's <i>pEvent</i> parameter is an IDispatch
///pointer for the <b>ITTTSTerminalEvent</b> interface. <div class="alert"><b>Note</b> You must call the
///ITTAPI::put_EventFilter method and set an event filter mask that includes <b>TE_TTSTERMINAL</b> to enable reception
///of Text-to-Speech terminal events. If you do not call <b>ITTAPI::put_EventFilter</b>, your application will not
///receive any events. For more information, see the Events overview.</div><div> </div>
@GUID("D964788F-95A5-461D-AB0C-B9900A6C2713")
interface ITTTSTerminalEvent : IDispatch
{
    ///The <b>get_Terminal</b> method gets an ITTerminal interface pointer for the terminal object involved in the
    ///event.
    ///Params:
    ///    ppTerminal = Pointer to the ITTerminal interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Terminal(ITTerminal* ppTerminal);
    ///The <b>get_Call</b> method returns an ITCallInfo interface pointer for the call involved in the terminal event.
    ///Params:
    ///    ppCall = Pointer to the ITCallInfo interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Call(ITCallInfo* ppCall);
    ///The <b>get_Error</b> method gets an <b>HRESULT</b> cast of the error code involved in the terminal event.
    ///Params:
    ///    phrErrorCode = Pointer to the <b>HRESULT</b> cast of the error code.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Error(int* phrErrorCode);
}

///The <b>ITASRTerminalEvent</b> interface contains methods that retrieve the description of Automatic Speech
///Recognition terminal events that have occurred. When the application's implementation of the
///ITTAPIEventNotification::Event method indicates a TAPI_EVENT equal to <b>TE_ASRTERMINAL</b>, the method's
///<i>pEvent</i> parameter is an IDispatch pointer for the <b>ITASRTerminalEvent</b> interface. <div
///class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter method and set an event filter mask that includes
///<b>TE_ASRTERMINAL</b> to enable reception of Automatic Speech Recognition terminal events. If you do not call
///<b>ITTAPI::put_EventFilter</b>, your application will not receive any events. For more information, see the Events
///overview.</div><div> </div>
@GUID("EE016A02-4FA9-467C-933F-5A15B12377D7")
interface ITASRTerminalEvent : IDispatch
{
    ///The <b>get_Terminal</b> method returns a pointer to the ITTerminal interface for the terminal on which the event
    ///occurred.
    ///Params:
    ///    ppTerminal = Pointer to ITTerminal interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_Terminal(ITTerminal* ppTerminal);
    ///The <b>get_Call</b> method returns a pointer to the ITCallInfo interface for the call object involved in the
    ///terminal event.
    ///Params:
    ///    ppCall = Pointer to ITCallInfo interface.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_Call(ITCallInfo* ppCall);
    ///The <b>get_Error</b> method returns an HRESULT cast of the error associated with the terminal event.
    ///Params:
    ///    phrErrorCode = Pointer to error code.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT get_Error(int* phrErrorCode);
}

///The <b>ITToneTerminalEvent</b> interface contains methods that retrieve the description of tone terminal events that
///have occurred. When the application's implementation of the ITTAPIEventNotification::Event method indicates a
///TAPI_EVENT equal to <b>TE_TONETERMINAL</b>, the method's <i>pEvent</i> parameter is an IDispatch pointer for the
///<b>ITToneTerminalEvent</b> interface. <div class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter method
///and set an event filter mask that includes <b>TE_TONETERMINAL</b> to enable reception of tone terminal events. If you
///do not call <b>ITTAPI::put_EventFilter</b>, your application will not receive any events. For more information, see
///the Events overview.</div><div> </div>
@GUID("E6F56009-611F-4945-BBD2-2D0CE5612056")
interface ITToneTerminalEvent : IDispatch
{
    ///The <b>get_Terminal</b> method returns an ITTerminal pointer for the tone terminal on which the event occurred.
    ///Params:
    ///    ppTerminal = Pointer to the ITTerminal interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Terminal(ITTerminal* ppTerminal);
    ///The <b>get_Call</b> method retrieves an interface pointer for the call object on which the event occurred.
    ///Params:
    ///    ppCall = Pointer to the ITCallInfo interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Call(ITCallInfo* ppCall);
    ///The <b>get_Error</b> method returns an <b>HRESULT</b> cast of the error code involved in the event.
    ///Params:
    ///    phrErrorCode = <b>HRESULT</b> cast of the error code.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT get_Error(int* phrErrorCode);
}

///The <b>ITQOSEvent</b> interface contains methods that retrieve the description of quality of service (QOS) events.
///When the application's implementation of the ITTAPIEventNotification::Event method indicates a TAPI_EVENT equal to
///<b>TE_QOSEVENT</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b> pointer for the <b>ITQOSEvent</b>
///interface. The methods of this interface can be used to retrieve information concerning a QOS event that has
///occurred. <div class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter method and set an event filter
///mask that includes the <b>TE_QOSEVENT</b> to enable reception of QOS events. If you do not call
///<b>ITTAPI::put_EventFilter</b>, your application will not receive any events. For more information, see the Events
///overview.</div><div> </div>
@GUID("CFA3357C-AD77-11D1-BB68-00C04FB6809F")
interface ITQOSEvent : IDispatch
{
    ///The <b>get_Call</b> method gets a pointer to the ITCallInfo interface for the call on which the QOS event
    ///occurred.
    ///Params:
    ///    ppCall = Points to ITCallInfo interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppCall</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Call(ITCallInfo* ppCall);
    ///The <b>get_Event</b> method gets the QOS_EVENT indicator.
    ///Params:
    ///    pQosEvent = Indicator of the QOS event type.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pQosEvent</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Event(QOS_EVENT* pQosEvent);
    ///The <b>get_MediaType</b> method gets the media type indicator.
    ///Params:
    ///    plMediaType = Indicates the media type for the call on which the QOS event occurred.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plMediaType</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_MediaType(int* plMediaType);
}

///The <b>ITCallInfoChangeEvent</b> interface contains methods that retrieve the description of call information change
///events. When the application's implementation of the ITTAPIEventNotification::Event method indicates a TAPI_EVENT
///equal to <b>TE_CALLINFOCHANGE</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b> pointer for the
///<b>ITCallInfoChangeEvent</b> interface. The methods of this interface can be used to retrieve information concerning
///the call information that has changed. The <b>ITCallInfoChangeEvent</b> is an outgoing interface. This interface is
///registered with the TAPI object to get all information about calls. An application must have called the
///ITTAPI::RegisterCallNotifications method on the TAPI object before registering this interface. If not, the call to
///<b>Advise</b> will fail. This interface cannot be unregistered<b>Unadvise</b> will always fail. <div
///class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter method and set an event filter mask that includes
///the <b>TE_CALLINFOCHANGE</b> event to enable reception of call information change events. If you do not call
///<b>ITTAPI::put_EventFilter</b>, your application will not receive any events. For more information, see the Events
///overview.</div><div> </div>
@GUID("5D4B65F9-E51C-11D1-A02F-00C04FB6809F")
interface ITCallInfoChangeEvent : IDispatch
{
    ///The <b>get_Call</b> method returns the ITCallInfo interface on which call information has changed.
    ///Params:
    ///    ppCall = Pointer to ITCallInfo interface on which information has changed.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppCall</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Call(ITCallInfo* ppCall);
    ///The <b>get_Cause</b> method gets a CALLINFOCHANGE_CAUSE description of the change.
    ///Params:
    ///    pCIC = Pointer to CALLINFOCHANGE_CAUSE description of the call event that has occurred.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pCIC</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Cause(CALLINFOCHANGE_CAUSE* pCIC);
    ///The <b>get_CallbackInstance</b> method gets a pointer to the callback instance associated with this event.
    ///Params:
    ///    plCallbackInstance = Pointer to callback instance returned by ITTAPI::RegisterCallNotifications.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plCallbackInstance</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_CallbackInstance(int* plCallbackInstance);
}

///The <b>ITRequest</b> interface allows an application to use Assisted Telephony. Assisted Telephony provides
///telephony-enabled applications with a simple mechanism for making phone calls without requiring the developer to
///become fully literate in telephony. The Request object must be created using COM <b>CoCreateInstance</b>.
@GUID("AC48FFDF-F8C4-11D1-A030-00C04FB6809F")
interface ITRequest : IDispatch
{
    ///The <b>MakeCall</b> method makes a call to the designated party.
    ///Params:
    ///    pDestAddress = Pointer to a <b>BSTR</b> containing the destination address for the call.
    ///    pAppName = Pointer to a <b>BSTR</b> containing the name of the application.
    ///    pCalledParty = Pointer to a <b>BSTR</b> containing the called party name.
    ///    pComment = Pointer to a <b>BSTR</b> containing a comment.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPIERR_NOREQUESTRECIPIENT</b></dt>
    ///    </dl> </td> <td width="60%"> No application exists that can handle the assisted telephony request. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>TAPIERR_INVALDESTADDRESS</b></dt> </dl> </td> <td width="60%"> The
    ///    destination address is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPIERR_REQUESTQUEUEFULL</b></dt> </dl> </td> <td width="60%"> The TAPI Server request queue is full
    ///    and cannot handle another assisted telephony request. </td> </tr> </table>
    ///    
    HRESULT MakeCall(BSTR pDestAddress, BSTR pAppName, BSTR pCalledParty, BSTR pComment);
}

///The <b>ITRequestEvent</b> interface contains methods that allow an application to receive and process Assisted
///Telephony request events. When the application's implementation of the ITTAPIEventNotification::Event method
///indicates a TAPI_EVENT equal to <b>TE_REQUEST</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b>
///pointer for the <b>ITRequestEvent</b> interface. The methods of this interface can be used to retrieve information
///concerning a request event that has occurred. <div class="alert"><b>Note</b> You must call the
///ITTAPI::put_EventFilter method and set an event filter mask that includes the <b>TE_REQUEST</b> event to enable
///reception of request events. If you do not call <b>ITTAPI::put_EventFilter</b>, your application will not receive any
///events. For more information, see the Events overview.</div><div> </div>
@GUID("AC48FFDE-F8C4-11D1-A030-00C04FB6809F")
interface ITRequestEvent : IDispatch
{
    ///The <b>get_RegistrationInstance</b> method gets the registration instance.
    ///Params:
    ///    plRegistrationInstance = Pointer to the registration instance.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>plRegistrationInstance</i> is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT get_RegistrationInstance(int* plRegistrationInstance);
    ///The <b>get_RequestMode</b> method gets the mode of the request.
    ///Params:
    ///    plRequestMode = Pointer to the request mode.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plRequestMode</i> is not
    ///    a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_RequestMode(int* plRequestMode);
    ///The <b>get_DestAddress</b> method gets the destination address.
    ///Params:
    ///    ppDestAddress = Pointer to a <b>BSTR</b> containing the destination address.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppDestAddress</i> is not
    ///    a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_DestAddress(BSTR* ppDestAddress);
    ///The <b>get_AppName</b> method gets the name of the application.
    ///Params:
    ///    ppAppName = Pointer to a <b>BSTR</b> containing the application name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppAppName</i> is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_AppName(BSTR* ppAppName);
    ///The <b>get_CalledParty</b> method gets the called party.
    ///Params:
    ///    ppCalledParty = Pointer to a <b>BSTR</b> containing the called party identifier.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppCalledParty</i> is not
    ///    a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_CalledParty(BSTR* ppCalledParty);
    ///The <b>get_Comment</b> method gets the comment.
    ///Params:
    ///    ppComment = Pointer to a <b>BSTR</b> containing the comment.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppComment</i> is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Comment(BSTR* ppComment);
}

///The <b>ITCollection</b> interface allows Automation client applications, such as those written in Visual Basic, to
///retrieve collection information. C or C++ programs use enumerator interfaces to retrieve the same information.
///Collection methods return a <b>VARIANT</b> which contains a pointer to an <b>ITCollection</b> interface. The
///ITCollection2 interface is an extension of the <b>ITCollection</b> interface. <b>ITCollection2</b> exposes additional
///methods for modifying the collection.
@GUID("5EC5ACF2-9C02-11D0-8362-00AA003CCABD")
interface ITCollection : IDispatch
{
    ///The <b>get_Count</b> method gets the number of items in the collection.
    ///Params:
    ///    lCount = Number of items.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Count(int* lCount);
    ///The <b>get_Item</b> method, given an index, returns an item in the collection.
    ///Params:
    ///    Index = Index of item to be retrieved.
    ///    pVariant = Pointer to item returned.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Item(int Index, VARIANT* pVariant);
    ///The <b>get__NewEnum</b> method gets an enumerator for the collection.
    ///Params:
    ///    ppNewEnum = Pointer to an IUnknown interface on an enumerator object for the collection. Call the QueryInterface method
    ///                on the returned <b>IUnknown</b> interface to obtain a pointer to an IEnumVARIANT enumeration interface on the
    ///                collection. <b>IEnumVARIANT</b> provides a number of methods that you can use to iterate through the
    ///                collection. For more information, see the following Remarks section.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get__NewEnum(IUnknown* ppNewEnum);
}

///The <b>ITCollection2</b> interface is an extension of the ITCollection interface. <b>ITCollection2</b> exposes
///additional methods for modifying the collection.
@GUID("E6DDDDA5-A6D3-48FF-8737-D32FC4D95477")
interface ITCollection2 : ITCollection
{
    ///The <b>Add</b> method inserts a new item into the collection at the specified index.
    ///Params:
    ///    Index = Specifies the location in the collection where the item should be added.
    ///    pVariant = Pointer to a <b>VARIANT</b> containing the item to add.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>Index</i> parameter does not specify a valid index. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> There is not enough memory to reallocate the
    ///    collection. </td> </tr> </table>
    ///    
    HRESULT Add(int Index, VARIANT* pVariant);
    ///The <b>Remove</b> method deletes an item from the collection at the specified index.
    ///Params:
    ///    Index = Specifies the location in the collection of the item to remove.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>Index</i> parameter
    ///    does not specify a valid index. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> There is not enough memory to reallocate the collection. </td> </tr> </table>
    ///    
    HRESULT Remove(int Index);
}

///The <b>ITForwardInformation</b> interface provides methods for setup and implementation of call forwarding. The
///forward information object is created by ITAddress::CreateForwardInfoObject. A pointer to an existing forward
///information object can be retrieved using ITAddress::get_CurrentForwardInfo.
@GUID("449F659E-88A3-11D1-BB5D-00C04FB6809F")
interface ITForwardInformation : IDispatch
{
    ///The <b>put_NumRingsNoAnswer</b> method sets the number of rings after which a no answer condition is assumed.
    ///Params:
    ///    lNumRings = Number of rings.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT put_NumRingsNoAnswer(int lNumRings);
    ///The <b>get_NumRingsNoAnswer</b> method retrieves the number of rings after which a no answer condition is
    ///assumed.
    ///Params:
    ///    plNumRings = Pointer to number of rings.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plNumRings</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_NumRingsNoAnswer(int* plNumRings);
    ///The <b>SetForwardType</b> method sets the forwarding mode and destination by caller address.
    ///Params:
    ///    ForwardType = Line forward mode.
    ///    pDestAddress = Pointer to <b>BSTR</b> representation of destination address for forwarding.
    ///    pCallerAddress = Pointer to <b>BSTR</b> representation of caller address.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDestAddress</i> or
    ///    <i>pCallerAddress</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ForwardType</i> parameter is not valid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT SetForwardType(int ForwardType, BSTR pDestAddress, BSTR pCallerAddress);
    ///The <b>get_ForwardTypeDestination</b> method gets the destination for a forwarding mode.
    ///Params:
    ///    ForwardType = Line forward mode.
    ///    ppDestAddress = Pointer to <b>BSTR</b> representation of destination address.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ppDestAddress</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppDestAddress</i> parameter is not a valid
    ///    pointer. </td> </tr> </table>
    ///    
    HRESULT get_ForwardTypeDestination(int ForwardType, BSTR* ppDestAddress);
    ///The <b>get_ForwardTypeCaller</b> method gets the type of caller for a given forwarding mode.
    ///Params:
    ///    Forwardtype = Line forward mode.
    ///    ppCallerAddress = Pointer to <b>BSTR</b> representation of caller address.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppCallerAddress</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The <i>Forwardtype</i> parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT get_ForwardTypeCaller(int Forwardtype, BSTR* ppCallerAddress);
    ///The <b>GetForwardType</b> method gets the forwarding mode.
    ///Params:
    ///    ForwardType = Line forward mode.
    ///    ppDestinationAddress = Pointer to <b>BSTR</b> representation of destination address.
    ///    ppCallerAddress = Pointer to <b>BSTR</b> representation of the call originator's address.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ppDestAddress</i> or
    ///    <i>ppCallerAddress</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT GetForwardType(int ForwardType, BSTR* ppDestinationAddress, BSTR* ppCallerAddress);
    ///The <b>Clear</b> method clears all forwarding information in this object.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Clear();
}

///The <b>ITForwardInformation2</b> interface exposes methods that provide additional methods for the control of
///forwarding information. See ITForwardInformation for the basic forwarding control methods.
@GUID("5229B4ED-B260-4382-8E1A-5DF3A8A4CCC0")
interface ITForwardInformation2 : ITForwardInformation
{
    ///The <b>SetForwardType2</b> method sets the current forwarding mode, specified by caller address.
    ///Params:
    ///    ForwardType = Line forward type to be set.
    ///    pDestAddress = Pointer to the <b>BSTR</b> representation of the destination address.
    ///    DestAddressType = Address type of destination.
    ///    pCallerAddress = Pointer to the <b>BSTR</b> representation of the caller address.
    ///    CallerAddressType = Address type of caller.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ForwardType</i>,
    ///    <i>DestAddressType</i>, or <i>CallerAddressType</i> is invalid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>pDestAddress</i> or <i>pCallerAddress</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT SetForwardType2(int ForwardType, BSTR pDestAddress, int DestAddressType, BSTR pCallerAddress, 
                            int CallerAddressType);
    ///The <b>GetForwardType2</b> method gets the current forwarding mode, specified by caller address.
    ///Params:
    ///    ForwardType = Line forward type to be retrieved.
    ///    ppDestinationAddress = Pointer to the <b>BSTR</b> representation of the destination address.
    ///    pDestAddressType = Address type of the destination.
    ///    ppCallerAddress = Pointer to the <b>BSTR</b> representation of the caller address.
    ///    pCallerAddressType = Address type of the caller.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ForwardType</i>,
    ///    <i>pDestAddressType</i>, or <i>pCallerAddressType</i> parameter is invalid. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>ppDestinationAddress</i>, <i>pDestAddressType</i>, <i>pCallerAddressType</i>, or <i>ppCallerAddress</i>
    ///    parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT GetForwardType2(int ForwardType, BSTR* ppDestinationAddress, int* pDestAddressType, 
                            BSTR* ppCallerAddress, int* pCallerAddressType);
    ///The <b>get_ForwardTypeDestinationAddressType</b> method gets the destination address type for a given forwarding
    ///type.
    ///Params:
    ///    ForwardType = Line forward type to be retrieved.
    ///    pDestAddressType = Address type of the destination.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ForwardType</i> parameter
    ///    is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDestAddressType</i> parameter is not a valid
    ///    pointer. </td> </tr> </table>
    ///    
    HRESULT get_ForwardTypeDestinationAddressType(int ForwardType, int* pDestAddressType);
    ///The <b>get_ForwardTypeCallerAddressType</b> method gets the caller address type for a given forwarding type.
    ///Params:
    ///    Forwardtype = Line forward type to be retrieved.
    ///    pCallerAddressType = Address type of the caller.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>Forwardtype</i> parameter
    ///    is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pCallerAddressType</i> parameter is not a valid
    ///    pointer. </td> </tr> </table>
    ///    
    HRESULT get_ForwardTypeCallerAddressType(int Forwardtype, int* pCallerAddressType);
}

///The <b>ITAddressTranslation</b> interface provides methods that allow translation of a calling address into a
///different format. For example, an application may need to translate an address from canonical to dialable prior to
///making a call. The most common use of this interface is to obtain the <i>pDestAddress</i> string needed for
///ITAddress::CreateCall. The addresses to be translated are mainly phone numbers in canonical format. The
///<b>ITAddressTranslation</b> interface is exposed on the Address Object. A pointer can be obtained by calling
///<b>QueryInterface</b> on ITAddress. For additional information, see Address Translation and Dialable Addresses.
@GUID("0C4D8F03-8DDB-11D1-A09E-00805FC147D3")
interface ITAddressTranslation : IDispatch
{
    ///The <b>TranslateAddress</b> method creates the address translation information interface. The primary goal of the
    ///<b>TranslateAddress</b> method is to obtain the <i>pDestAddress</i> string (dialable address) needed as a
    ///parameter for ITAddress::CreateCall. The <b>TranslateAddress</b> method returns the dialable address indirectly,
    ///as one of the properties of an ITAddressTranslationInfo object.
    ///Params:
    ///    pAddressToTranslate = Pointer to <b>BSTR</b> containing address that requires translation.
    ///    lCard = Calling card used for translation.
    ///    lTranslateOptions = Indicator of translation options, see LINETRANSLATEOPTION__Constants.
    ///    ppTranslated = Pointer to newly created ITAddressTranslationInfo interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppTranslated</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> The method failed for unknown reasons. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>lTranslateOptions</i> value is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_NODRIVER</b></dt> </dl> </td> <td width="60%"> This address has no TSP associated with it.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_REGISTRY_SETTING_CORRUPT</b></dt> </dl> </td> <td
    ///    width="60%"> The registry is corrupt. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_OPERATIONFAILED</b></dt> </dl> </td> <td width="60%"> The method failed with TAPI. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>TAPI_E_RESOURCEUNAVAIL</b></dt> </dl> </td> <td width="60%"> The TSP is not
    ///    available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INVALCARD</b></dt> </dl> </td> <td
    ///    width="60%"> The card number is not valid. </td> </tr> </table>
    ///    
    HRESULT TranslateAddress(BSTR pAddressToTranslate, int lCard, int lTranslateOptions, 
                             ITAddressTranslationInfo* ppTranslated);
    ///The <b>TranslateDialog</b> method displays an application-modal dialog box that allows the user to change the
    ///current location of a phone number about to be dialed, adjust location and calling card parameters, and see the
    ///effect.
    ///Params:
    ///    hwndOwner = A handle to a window to which the dialog box is to be attached. Can be a <b>NULL</b> value to indicate that
    ///                any window created during the function should have no owner window.
    ///    pAddressIn = A pointer to <b>BSTR</b> containing a phone number that is used to show the effect of the user's changes on
    ///                 the location parameters. The number must be in canonical format. This pointer can be left <b>NULL</b>, in
    ///                 which case the phone number portion of the dialog box is not displayed. If the <i>pAddressIn</i> parameter
    ///                 contains a subaddress or name field or additional addresses separated from the first address by ASCII CR and
    ///                 LF characters, only the first address is used in the dialog box.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>hwndOwner</i>
    ///    parameter is not a valid handle or the <i>pAddressIn</i> parameter is not a valid phone number. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pAddressIn</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> An unexpected error occurred. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>TAPI_E_REGISTRY_SETTING_CORRUPT</b></dt> </dl> </td> <td width="60%"> The
    ///    registry settings for address translation are not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_NODRIVER</b></dt> </dl> </td> <td width="60%"> No TSP exists that can do translation for this
    ///    address. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INUSE</b></dt> </dl> </td> <td width="60%"> The
    ///    dialog is already open and in use. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INVALADDRESS</b></dt>
    ///    </dl> </td> <td width="60%"> The current address is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_OPERATIONFAILED</b></dt> </dl> </td> <td width="60%"> TAPI was not able to complete the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT TranslateDialog(int hwndOwner, BSTR pAddressIn);
    ///The <b>EnumerateLocations</b> method enumerates the currently available address locations. This method is
    ///provided for C and C++ applications. Automation client applications, such as those written in Visual Basic, must
    ///use the get_Locations method.
    ///Params:
    ///    ppEnumLocation = Pointer to IEnumLocation object created.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnumLocations</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to create object. </td> </tr> </table>
    ///    
    HRESULT EnumerateLocations(IEnumLocation* ppEnumLocation);
    ///The <b>get_Locations</b> method creates a collection of currently available address locations. This method is
    ///provided for Automation client applications, such as those written in Visual Basic. C and C++ applications must
    ///use the EnumerateLocations method.
    ///Params:
    ///    pVariant = Pointer to <b>VARIANT</b> containing an ITCollection of ITLocationInfo interface pointers (location objects).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter is not
    ///    a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Locations(VARIANT* pVariant);
    ///The <b>EnumerateCallingCards</b> method enumerates calling cards associated with the address. This method is
    ///provided for C and C++ applications. Automation client applications, such as those written in Visual Basic, must
    ///use the get_CallingCards method.
    ///Params:
    ///    ppEnumCallingCard = Pointer to IEnumCallingCard interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnumCallingCard</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT EnumerateCallingCards(IEnumCallingCard* ppEnumCallingCard);
    ///The <b>get_CallingCards</b> method creates a collection of calling cards associated with the address. This method
    ///is provided for Automation client applications, such as those written in Visual Basic. C and C++ applications
    ///must use the EnumerateCallingCards method.
    ///Params:
    ///    pVariant = Pointer to <b>VARIANT</b> containing an ITCollection of ITCallingCard interface pointers.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter is not
    ///    a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_CallingCards(VARIANT* pVariant);
}

///The <b>ITAddressTranslationInfo</b> interface is used to determine the address translation data. To obtain a pointer
///to it, call ITAddressTranslation::TranslateAddress.
@GUID("AFC15945-8D40-11D1-A09E-00805FC147D3")
interface ITAddressTranslationInfo : IDispatch
{
    ///The <b>get_DialableString</b> method gets a string that contains a dialable number. Typically, this number is
    ///then used as the <i>pDestAddress</i> argument in ITAddress::CreateCall.
    ///Params:
    ///    ppDialableString = Pointer to <b>BSTR</b> containing representation of dialable string.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppDialableString</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_DialableString(BSTR* ppDialableString);
    ///The <b>get_DisplayableString</b> method gets a string that contains a displayable version of the dialable number.
    ///Params:
    ///    ppDisplayableString = Pointer to <b>BSTR</b> containing representation of displayable string.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppDisplayableString</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_DisplayableString(BSTR* ppDisplayableString);
    ///The <b>get_CurrentCountryCode</b> method gets the current country/region code.
    ///Params:
    ///    CountryCode = Pointer to the country/region code.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>CountryCode</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_CurrentCountryCode(int* CountryCode);
    ///The <b>get_DestinationCountryCode</b> method retrieves the country/region code for the call destination.
    ///Params:
    ///    CountryCode = A pointer to destination country/region code.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>CountryCode</i> parameter
    ///    is an invalid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_DestinationCountryCode(int* CountryCode);
    ///The <b>get_TranslationResults</b> method gets the results of a translation operation.
    ///Params:
    ///    plResults = Indicates the information derived from the translation process, which may assist the application in
    ///                presenting user-interface elements. This value uses one of the LINETRANSLATERESULT_ Constants.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plResults</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_TranslationResults(int* plResults);
}

///The <b>ITLocationInfo</b> interface is used to get information related to the location of the calling party. This is
///the location information that is entered by using the Telephony applet under the Control Panel. An
///<b>ITLocationInfo</b> interface pointer is obtained by using ITAddressTranslation::EnumerateLocations or
///ITAddressTranslation::get_Locations. There can be more than one location entries in the Telephony applet. If so,
///<b>EnumerateLocations</b> and <b>get_Locations</b> will return them all. However, only one of them is the current
///location, and TAPI uses that one as the address translation context when ITAddressTranslation::TranslateAddress is
///called. The <b>ITLocationInfo</b> interface is a COM wrapper for the TAPI 2.<i>x</i> LINELOCATIONENTRY structure.
@GUID("0C4D8EFF-8DDB-11D1-A09E-00805FC147D3")
interface ITLocationInfo : IDispatch
{
    ///The <b>get_PermanentLocationID</b> method gets the permanent location identifier.
    ///Params:
    ///    plLocationID = Pointer to the permanent location identifier.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plLocationID</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_PermanentLocationID(int* plLocationID);
    ///The <b>get_CountryCode</b> method gets the country/region code.
    ///Params:
    ///    plCountryCode = Pointer to country/region code.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCountryCode</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_CountryCode(int* plCountryCode);
    ///The <b>get_CountryID</b> method gets the identifier for the country/region.
    ///Params:
    ///    plCountryID = Country/region ID.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ulCountryID</i>
    ///    parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ulCountryID</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT get_CountryID(int* plCountryID);
    ///The <b>get_Options</b> method gets an indicator of whether the current location supports pulse or tone dialing.
    ///Params:
    ///    plOptions = Dialing options, as indicated by values from LINELOCATIONOPTION_ Constants.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plOptions</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Options(int* plOptions);
    ///The <b>get_PreferredCardID</b> method gets the preferred calling card identifier for dialing from the current
    ///location.
    ///Params:
    ///    plCardID = Calling card ID.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCardID</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_PreferredCardID(int* plCardID);
    ///The <b>get_LocationName</b> method gets the location name.
    ///Params:
    ///    ppLocationName = Pointer to the <b>BSTR</b> representation of the location name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppLocationName</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_LocationName(BSTR* ppLocationName);
    ///The <b>get_CityCode</b> method gets the code for the city.
    ///Params:
    ///    ppCode = Pointer to the <b>BSTR</b> representation of the city code.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppCode</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_CityCode(BSTR* ppCode);
    ///The <b>get_LocalAccessCode</b> method gets the local access code.
    ///Params:
    ///    ppCode = Pointer to <b>BSTR</b> representation of local access code.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ppCode</i> parameter
    ///    is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    The <i>ppCode</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT get_LocalAccessCode(BSTR* ppCode);
    ///The <b>get_LongDistanceAccessCode</b> method gets the code to access long distance.
    ///Params:
    ///    ppCode = Pointer to <b>BSTR</b> representation of long distance access code.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ppCode</i> parameter
    ///    is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    The <i>ppCode</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT get_LongDistanceAccessCode(BSTR* ppCode);
    ///The <b>get_TollPrefixList</b> method gets the toll prefix list.
    ///Params:
    ///    ppTollList = Pointer to the <b>BSTR</b> containing a list of toll prefixes.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppTollList</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_TollPrefixList(BSTR* ppTollList);
    ///The <b>get_CancelCallWaitingCode</b> method gets the dial digits and modifier characters that must be prefixed to
    ///a dialable string to cancel call waiting.
    ///Params:
    ///    ppCode = Pointer to <b>BSTR</b> representation of dial digits and modifier characters required to cancel call waiting.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppCode</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_CancelCallWaitingCode(BSTR* ppCode);
}

///The <b>IEnumLocation</b> interface provides COM-standard enumeration methods for the ITLocationInfo interface. The
///ITAddressTranslation::EnumerateLocations method returns a pointer to <b>IEnumLocation</b>. The <b>IEnumLocation</b>
///interface is hidden from Visual Basic and scripting languages.
@GUID("0C4D8F01-8DDB-11D1-A09E-00805FC147D3")
interface IEnumLocation : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence. This method is
    ///hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITLocationInfo pointer.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppElements</i> parameter is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, ITLocationInfo* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets to the beginning of the enumeration sequence. This method is hidden from Visual
    ///Basic and scripting languages.
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence. This method
    ///is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements to skip.
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///This method is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    ppEnum = Pointer to new IEnumLocation interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumLocation* ppEnum);
}

///The <b>ITCallingCard</b> interface provides methods to retrieve information concerning telephony calling cards. An
///<b>ITCallingCard</b> interface pointer can be obtained using ITAddressTranslation::get_CallingCards or
///ITAddressTranslation::EnumerateCallingCards. <b>TAPI 2.1 Cross-Reference: </b>The information obtainable using this
///interface parallels that contained in the LINECARDENTRY structure. The lineGetTranslateCaps function returns a
///LINETRANSLATECAPS structure. The <b>dwCardListOffset</b> member of this structure points to a list of
///<b>LINECARDENTRY</b> structures.
@GUID("0C4D8F00-8DDB-11D1-A09E-00805FC147D3")
interface ITCallingCard : IDispatch
{
    ///The <b>get_PermanentCardID</b> method gets the permanent identifier that identifies the card.
    ///Params:
    ///    plCardID = Pointer to calling card identifier.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>plCardID</i> parameter
    ///    is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    The <i>plCardID</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT get_PermanentCardID(int* plCardID);
    ///The <b>get_NumberOfDigits</b> method gets the number of digits in the existing card number.
    ///Params:
    ///    plDigits = Pointer to number of digits in the card number.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>plDigits</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plDigits</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT get_NumberOfDigits(int* plDigits);
    ///The <b>get_Options</b> method gets the translation options for this address and card.
    ///Params:
    ///    plOptions = Pointer to LINETRANSLATEOPTION flags.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plOptions</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Options(int* plOptions);
    ///The <b>get_CardName</b> method gets the friendly name for the calling card.
    ///Params:
    ///    ppCardName = Pointer to <b>BSTR</b> containing a displayable name for the calling card.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppCardName</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_CardName(BSTR* ppCardName);
    ///The <b>get_SameAreaDialingRule</b> method gets the dialing rules for calls within the same area code.
    ///Params:
    ///    ppRule = Pointer to <b>BSTR</b> representation of local area dialing rules.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppRule</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_SameAreaDialingRule(BSTR* ppRule);
    ///The <b>get_LongDistanceDialingRule</b> method gets the long distance dialing rules for this calling card.
    ///Params:
    ///    ppRule = Pointer to <b>BSTR</b> representation of long distance dialing rules.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppRule</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_LongDistanceDialingRule(BSTR* ppRule);
    ///The <b>get_InternationalDialingRule</b> method gets the international dialing rules for this calling card.
    ///Params:
    ///    ppRule = Pointer to <b>BSTR</b> representation of international dialing rules.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>ppRule</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppRule</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT get_InternationalDialingRule(BSTR* ppRule);
}

///The <b>IEnumCallingCard</b> interface provides COM-standard enumeration methods for the ITCallingCard interface. The
///ITAddressTranslation::EnumerateCallingCards method returns a pointer to <b>IEnumCallingCard</b>. The
///<b>IEnumCallingCard</b> interface is hidden from Visual Basic and scripting languages.
@GUID("0C4D8F02-8DDB-11D1-A09E-00805FC147D3")
interface IEnumCallingCard : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence. This method is
    ///hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITCallingCard pointer.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppElements</i> parameter is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, ITCallingCard* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets to the beginning of the enumeration sequence. This method is hidden from Visual
    ///Basic and scripting languages.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence. This method
    ///is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///This method is hidden from Visual Basic and scripting languages.
    ///Params:
    ///    ppEnum = Pointer to new IEnumCallingCard interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter not
    ///    a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumCallingCard* ppEnum);
}

///The <b>ITCallNotificationEvent</b> interface contains methods that retrieve the description of call notification
///events. When the application's implementation of the ITTAPIEventNotification::Event method indicates a TAPI_EVENT
///equal to <b>TE_CALLNOTIFICATION</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b> pointer for the
///<b>ITCallNotificationEvent</b> interface. The methods of this interface can be used to retrieve information
///concerning the call notification event that has occurred. This outgoing interface is registered with the TAPI object
///to get all information about calls. An application must call the ITTAPI::RegisterCallNotifications method on the TAPI
///object before registering this interface. <div class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter
///method and set an event filter mask that includes the <b>TE_CALLNOTIFICATION</b> event to enable reception of call
///notification events. If you do not call <b>ITTAPI::put_EventFilter</b>, your application will not receive any events.
///For more information, see the Events overview.</div><div> </div>
@GUID("895801DF-3DD6-11D1-8F30-00C04FB6809F")
interface ITCallNotificationEvent : IDispatch
{
    ///The <b>get_Call</b> method returns the ITCallInfo interface on which a call event has occurred.
    ///Params:
    ///    ppCall = Pointer to ITCallInfo interface on which call event has occurred.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppCall</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Call(ITCallInfo* ppCall);
    ///The <b>get_Event</b> method returns a CALL_NOTIFICATION_EVENT description of whether the application owns or is
    ///monitoring the call on which the event has occurred.
    ///Params:
    ///    pCallNotificationEvent = Pointer to the CALL_NOTIFICATION_EVENT description of the application's privilege on the call returned by
    ///                             ITCallNotificationEvent::get_Call.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pCallNotificationEvent</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Event(CALL_NOTIFICATION_EVENT* pCallNotificationEvent);
    ///The <b>get_CallbackInstance</b> method gets a pointer to the callback instance associated with this event.
    ///Params:
    ///    plCallbackInstance = Pointer to callback instance returned by ITTAPI::RegisterCallNotifications.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plCallbackInstance</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_CallbackInstance(int* plCallbackInstance);
}

///The <b>ITDispatchMapper</b> interface allows an application to retrieve the dispatch pointer of another interface on
///an object, given the dispatch pointer of one interface and the GUID of another. This interface is provided to assist
///programmers using scripting applications which do not automatically support tracking of multiple interfaces on an
///object. The Dispatch Mapper will use the object's <b>IObjectSafety</b> interface to make sure the object is safe for
///scripting on the requested interface. If the object does not implement <b>IObjectSafety</b>, or if the object is not
///safe on this particular interface, the call will fail. The Dispatch Mapper object must be created using COM
///<b>CoCreateInstance</b>.
@GUID("E9225295-C759-11D1-A02B-00C04FB6809F")
interface ITDispatchMapper : IDispatch
{
    ///The <b>QueryDispatchInterface</b> method returns a dispatch pointer to a different interface on an object given
    ///its GUID and the dispatch pointer of another interface on the object.
    ///Params:
    ///    pIID = Pointer to <b>BSTR</b> representation of GUID for needed interface.
    ///    pInterfaceToMap = <b>IDispatch</b> pointer of starting interface.
    ///    ppReturnedInterface = <b>IDispatch</b> pointer of interface corresponding the GUID contained in <i>pIID</i>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pIID</i> parameter either is not a valid BSTR or does not translate into a valid GUID.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOINTERFACE</b></dt> </dl> </td> <td width="60%"> The
    ///    interface requested is not exposed or the object does not implement the <b>IObjectSafety</b> interface. </td>
    ///    </tr> </table>
    ///    
    HRESULT QueryDispatchInterface(BSTR pIID, IDispatch pInterfaceToMap, IDispatch* ppReturnedInterface);
}

///The <b>ITStreamControl</b> interface represents the media streaming features of a call and exposes methods that allow
///an application to enumerate, create, or remove streams. If this interface exists, a TAPI application acquires a
///pointer to this interface by performing a QueryInterface on any call interface, such as ITCallInfo. This interface is
///not available if an MSP is not involved in the current call session. Internal to the TAPI DLL, this interface is
///implemented by the MSP's call object, which is created in the ITMSPAddress::CreateMSPCall method. TAPI then
///aggregates this interface onto the TAPI call object and exposes it to TAPI applications.
@GUID("EE3BD604-3868-11D2-A045-00C04FB6809F")
interface ITStreamControl : IDispatch
{
    ///The <b>CreateStream</b> method creates a new media stream.
    ///Params:
    ///    lMediaType = Indicates media type for stream.
    ///    td = Indicates the TERMINAL_DIRECTION.
    ///    ppStream = Pointer to pointer for newly created ITStream interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppStream</i> parameter is not
    ///    a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> The <i>lMediaType</i> parameter is not a
    ///    valid media type. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_INVALIDDIRECTION</b></dt> </dl> </td>
    ///    <td width="60%"> The <i>td</i> parameter is not a valid terminal direction. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>TAPI_E_MAXSTREAMS</b></dt> </dl> </td> <td width="60%"> The maximum number of streams supported
    ///    has already been reached. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_NOTSUPPORTED</b></dt> </dl>
    ///    </td> <td width="60%"> This operation is not supported. </td> </tr> </table>
    ///    
    HRESULT CreateStream(int lMediaType, TERMINAL_DIRECTION td, ITStream* ppStream);
    ///The <b>RemoveStream</b> method removes a media stream.
    ///Params:
    ///    pStream = Pointer to ITStream interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pStream</i> parameter is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_NOTSUPPORTED</b></dt> </dl> </td> <td
    ///    width="60%"> This operation is not supported. </td> </tr> </table>
    ///    
    HRESULT RemoveStream(ITStream pStream);
    ///The <b>EnumerateStreams</b> method enumerates currently available media streams. Provided for C and C++
    ///applications. Automation client applications such as Visual Basic must use the get_Streams method.
    ///Params:
    ///    ppEnumStream = Pointer to pointer for IEnumStream enumerator.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppEnumStream</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT EnumerateStreams(IEnumStream* ppEnumStream);
    ///The <b>get_Streams</b> method creates a collection of media streams currently available on the call. Provided for
    ///Automation client applications, such as those written in Visual Basic. C and C++ applications must use the
    ///EnumerateStreams method.
    ///Params:
    ///    pVariant = Pointer to <b>VARIANT</b> containing an ITCollection of ITStream interface pointers.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pVariant</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Streams(VARIANT* pVariant);
}

///The <b>ITStream</b> interfaces expose methods that allow an application to retrieve information on a stream; to
///start, pause, or stop the stream; to select or unselect terminals on a stream; and to obtain a list of terminals
///selected on the stream. The following methods create the <b>ITStream</b> interface: CMSPCallBase::CreateStreamObject
///IEnumStream::Next ITSubStream::get_Stream ITStreamControl::CreateStream
@GUID("EE3BD605-3868-11D2-A045-00C04FB6809F")
interface ITStream : IDispatch
{
    ///The <b>get_MediaType</b> method gets the stream's media type.
    ///Params:
    ///    plMediaType = Pointer to media type descriptor.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plMediaType</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_MediaType(int* plMediaType);
    ///The <b>get_Direction</b> method gets the stream's terminal direction.
    ///Params:
    ///    pTD = Pointer to TERMINAL_DIRECTION descriptor.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pTD</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Direction(TERMINAL_DIRECTION* pTD);
    ///The <b>get_Name</b> method gets a <b>BSTR</b> representing the name of the stream. This name is used for
    ///informational or display purposes.
    ///Params:
    ///    ppName = Pointer to <b>BSTR</b> representation of stream's name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppName</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Name(BSTR* ppName);
    ///The <b>StartStream</b> method starts the stream.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method not implemented. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>TAPI_E_NOTERMINALSELECTED</b></dt> </dl> </td> <td width="60%"> No terminal
    ///    has been selected on the stream, so it cannot be started. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_NOTSTOPPED</b></dt> </dl> </td> <td width="60%"> Stream has already been started. </td> </tr>
    ///    </table>
    ///    
    HRESULT StartStream();
    ///The <b>PauseStream</b> method pauses the stream.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method not implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT PauseStream();
    ///The <b>StopStream</b> method stops the stream.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method not implemented. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>TAPI_E_NOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> The provider does
    ///    not support this operation. </td> </tr> </table>
    ///    
    HRESULT StopStream();
    ///The <b>SelectTerminal</b> method selects an ITTerminal object onto the stream.
    ///Params:
    ///    pTerminal = Pointer to ITTerminal interface of selected terminal.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pTerminal</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_MAXTERMINALS</b></dt> </dl> </td> <td width="60%"> Multiple terminals have been selected on the
    ///    stream, but media mixing or splitting is not possible. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_INVALIDTERMINAL</b></dt> </dl> </td> <td width="60%"> The terminal selected is not valid. </td>
    ///    </tr> </table>
    ///    
    HRESULT SelectTerminal(ITTerminal pTerminal);
    ///The <b>UnselectTerminal</b> method unselects the terminal from the stream and stops streaming for this stream.
    ///Params:
    ///    pTerminal = Pointer to ITTerminal interface terminal to remove from stream.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pTerminal</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_INVALIDTERMINAL</b></dt> </dl> </td> <td width="60%"> The <i>pTerminal</i> parameter does not
    ///    point to a valid terminal. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_NOTSUPPORTED</b></dt> </dl>
    ///    </td> <td width="60%"> The provider does not support this operation. </td> </tr> </table>
    ///    
    HRESULT UnselectTerminal(ITTerminal pTerminal);
    ///The <b>EnumerateTerminals</b> method enumerates terminals selected on the stream. Provided for C and C++
    ///applications. Automation client applications such as Visual Basic must use the get_Terminals method.
    ///Params:
    ///    ppEnumTerminal = Pointer to an IEnumTerminal terminal enumerator.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnumTerminal</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT EnumerateTerminals(IEnumTerminal* ppEnumTerminal);
    ///The <b>get_Terminals</b> method creates a collection of terminals associated with the current stream. Provided
    ///for Automation client applications, such as those written in Visual Basic. C and C++ applications must use the
    ///EnumerateTerminals method.
    ///Params:
    ///    pTerminals = Pointer to <b>VARIANT</b> containing an ITCollection of ITTerminal interface pointers (terminal objects).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pTerminals</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Terminals(VARIANT* pTerminals);
}

///The <b>IEnumStream</b> interface provides COM-standard enumeration methods for the ITStream interface. The
///ITStreamControl::EnumerateStreams and ITParticipant::EnumerateStreams methods return a pointer to <b>IEnumStream</b>.
@GUID("EE3BD606-3868-11D2-A045-00C04FB6809F")
interface IEnumStream : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITStream pointers returned.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppElements</i> parameter is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, ITStream* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets to the beginning of the enumeration sequence.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///Params:
    ///    ppEnum = Pointer to new IEnumStream interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumStream* ppEnum);
}

///The <b>ITSubStreamControl</b> interface exposes methods that allow an application to enumerate, create, or remove
///substreams. Many MSPs do not support this interface. A pointer to this interface can be obtained by calling
///QueryInterface on the stream object.
@GUID("EE3BD607-3868-11D2-A045-00C04FB6809F")
interface ITSubStreamControl : IDispatch
{
    ///The <b>CreateSubStream</b> method creates a substream.
    ///Params:
    ///    ppSubStream = Pointer to ITSubStream interface created.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppSubStream</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_MAXSTREAMS</b></dt> </dl> </td> <td width="60%"> Substream cannot be created because the
    ///    maximum number of streams has already been reached. </td> </tr> </table>
    ///    
    HRESULT CreateSubStream(ITSubStream* ppSubStream);
    ///The <b>RemoveSubStream</b> method removes a substream.
    ///Params:
    ///    pSubStream = Pointer to ITSubStream to be removed.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pSubStream</i> parameter
    ///    does not point to a valid interface. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>TAPI_E_INVALIDSTREAM</b></dt> </dl> </td> <td width="60%"> The <i>pSubStream</i>
    ///    parameter does not point to a valid substream. </td> </tr> </table>
    ///    
    HRESULT RemoveSubStream(ITSubStream pSubStream);
    ///The <b>EnumerateSubStreams</b> method enumerates currently available media substreams. Provided for C and C++
    ///applications. Automation client applications such as Visual Basic must use the get_SubStreams method.
    ///Params:
    ///    ppEnumSubStream = Pointer to IEnumSubStream enumeration of substreams.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppEnumSubStream</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT EnumerateSubStreams(IEnumSubStream* ppEnumSubStream);
    ///The <b>get_SubStreams</b> method creates a collection of substreams currently available. Provided for Automation
    ///client applications, such as those written in Visual Basic. C and C++ applications must use the
    ///EnumerateSubStreams method.
    ///Params:
    ///    pVariant = Pointer to <b>VARIANT</b> containing an ITCollection of ITSubStream interface pointers.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter is not
    ///    a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> The call appears to have been shut down. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT get_SubStreams(VARIANT* pVariant);
}

///An <b>ITSubStream</b> is a component of an ITStream, and gives an application finer control over the media streaming.
///The <b>ITSubStream</b> interface provides methods that start, pause, or stop a substream, select or unselect
///terminals, and obtain a list of terminals selected on the stream. The IEnumSubStream::Next and
///ITSubStreamControl::CreateSubStream methods create the <b>ITSubStream</b> interface.
@GUID("EE3BD608-3868-11D2-A045-00C04FB6809F")
interface ITSubStream : IDispatch
{
    ///The <b>StartSubStream</b> method starts the substream. See the Remarks section under ITStream::StartStream for
    ///additional information.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>TAPI_E_NOTERMINALSELECTED</b></dt> </dl> </td> <td width="60%"> No terminal has been
    ///    selected on the substream so it cannot be started. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_NOTSTOPPED</b></dt> </dl> </td> <td width="60%"> Substream has already been started. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_NOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> This
    ///    operation is not supported. </td> </tr> </table>
    ///    
    HRESULT StartSubStream();
    ///The <b>PauseSubStream</b> method pauses the substream.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>TAPI_E_NOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> This operation is not
    ///    supported. </td> </tr> </table>
    ///    
    HRESULT PauseSubStream();
    ///The <b>StopSubStream</b> method stops the substream. For additional information, see ITStream::StopStream.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>TAPI_E_NOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> The provider does not
    ///    support this operation. </td> </tr> </table>
    ///    
    HRESULT StopSubStream();
    ///The <b>SelectTerminal</b> method selects an ITTerminal object onto the substream. See the Remarks section under
    ///ITStream::SelectTerminal for additional information.
    ///Params:
    ///    pTerminal = Pointer to ITTerminal interface of selected terminal.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pTerminal</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_MAXTERMINALS</b></dt> </dl> </td> <td width="60%"> Multiple terminals have been selected on the
    ///    substream, but media mixing or splitting is not possible. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_INVALIDTERMINAL</b></dt> </dl> </td> <td width="60%"> The terminal selected is not valid. </td>
    ///    </tr> </table>
    ///    
    HRESULT SelectTerminal(ITTerminal pTerminal);
    ///The <b>UnselectTerminal</b> method unselects the terminal from the substream.
    ///Params:
    ///    pTerminal = Pointer to ITTerminal interface terminal to remove from stream.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pTerminal</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_INVALIDTERMINAL</b></dt> </dl> </td> <td width="60%"> The <i>pTerminal</i> parameter does not
    ///    point to a valid terminal. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_NOTSUPPORTED</b></dt> </dl>
    ///    </td> <td width="60%"> The provider does not support this operation. </td> </tr> </table>
    ///    
    HRESULT UnselectTerminal(ITTerminal pTerminal);
    ///The <b>EnumerateTerminals</b> method enumerates terminals selected on the substream. Provided for C and C++
    ///applications. Automation client applications such as Visual Basic must use the get_Terminals method.
    ///Params:
    ///    ppEnumTerminal = Pointer to an IEnumTerminal terminal enumerator.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnumTerminal</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT EnumerateTerminals(IEnumTerminal* ppEnumTerminal);
    ///The <b>get_Terminals</b> method creates a collection of terminals associated with the current substream. Provided
    ///for Automation client applications, such as those written in Visual Basic. C and C++ applications must use the
    ///EnumerateTerminals method.
    ///Params:
    ///    pTerminals = Pointer to <b>VARIANT</b> containing an ITCollection of ITTerminal interface pointers (terminal objects).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pTerminals</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Terminals(VARIANT* pTerminals);
    ///The <b>get_Stream</b> method retrieves the pointer to the ITStream interface for the current substream.
    ///Params:
    ///    ppITStream = Pointer to current ITStream interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppITStream</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Stream(ITStream* ppITStream);
}

///The <b>IEnumSubStream</b> interface provides COM-standard enumeration methods for the ITSubStream interface. The
///ITSubStreamControl::EnumerateSubStreams method returns a pointer to <b>IEnumSubStream</b>.
@GUID("EE3BD609-3868-11D2-A045-00C04FB6809F")
interface IEnumSubStream : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITSubStream pointers returned.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppElements</i> parameter is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, ITSubStream* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets to the beginning of the enumeration sequence.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///Params:
    ///    ppEnum = Pointer to new IEnumSubStream interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumSubStream* ppEnum);
}

///The <b>ITLegacyWaveSupport</b> interface allows an application to discover whether a terminal created by a legacy TSP
///(pre-TAPI 3) can be controlled using the Wave API.
@GUID("207823EA-E252-11D2-B77E-0080C7135381")
interface ITLegacyWaveSupport : IDispatch
{
    ///The <b>IsFullDuplex</b> method gets an indicator of whether the address supports wave devices.
    ///Params:
    ///    pSupport = Pointer to FULLDUPLEX_SUPPORT enumerator member, such as FDS_SUPPORTED.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT IsFullDuplex(FULLDUPLEX_SUPPORT* pSupport);
}

///The <b>ITBasicCallControl2</b> interface is an extension of the ITBasicCallControl interface.
///<b>ITBasicCallControl2</b> supplies additional methods that allow an application to select a terminal onto a call.
///The <b>ITBasicCallControl2</b> interface is created by calling <b>QueryInterface</b> on ITCallInfo.
@GUID("161A4A56-1E99-4B3F-A46A-168F38A5EE4C")
interface ITBasicCallControl2 : ITBasicCallControl
{
    ///The <b>RequestTerminal</b> method gets a suitable terminal, given the class, media, and direction required.
    ///Params:
    ///    bstrTerminalClassGUID = The terminal class required for the call.
    ///    lMediaType = Bitwise ORed list of media types required for the call.
    ///    Direction = The TERMINAL_DIRECTION descriptor for the terminal.
    ///    ppTerminal = Pointer to ITTerminal interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RequestTerminal(BSTR bstrTerminalClassGUID, int lMediaType, TERMINAL_DIRECTION Direction, 
                            ITTerminal* ppTerminal);
    ///The <b>SelectTerminalOnCall</b> method selects the terminal onto the call.
    ///Params:
    ///    pTerminal = Pointer to the ITTerminal interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SelectTerminalOnCall(ITTerminal pTerminal);
    ///The <b>UnselectTerminalOnCall</b> method unselects a terminal from the call.
    ///Params:
    ///    pTerminal = Pointer to ITTerminal interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UnselectTerminalOnCall(ITTerminal pTerminal);
}

///The <b>ITScriptableAudioFormat</b> interface is used by scriptable clients to get the audio format from, or set the
///audio format for, the track. The interface provides properties for each member from the WAVEFORMATEX structure. The
///ITFileTrack::get_AudioFormatForScripting and ITFileTrack::get_EmptyAudioFormatForScripting methods create the
///<b>ITScriptableAudioFormat</b> interface.
@GUID("B87658BD-3C59-4F64-BE74-AEDE3E86A81E")
interface ITScriptableAudioFormat : IDispatch
{
    ///The <b>get_Channels</b> method returns the value for the <b>nChannels</b> member in the WAVEFORMATEX structure.
    ///Params:
    ///    pVal = Pointer to the value of the <b>nChannels</b> member in the WAVEFORMATEX structure.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVal</i> argument is not
    ///    a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Channels(int* pVal);
    ///The <b>put_Channels</b> method sets the <b>nChannels</b> member in the WAVEFORMATEX structure.
    ///Params:
    ///    nNewVal = New value for the <b>nChannels</b> member in the WAVEFORMATEX structure.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_Channels(const(int) nNewVal);
    ///The <b>get_SamplesPerSec</b> method returns the value for the <b>nSamplesPerSec</b> member in the WAVEFORMATEX
    ///structure.
    ///Params:
    ///    pVal = Pointer to the value of the <b>nSamplesPerSec</b> member in the WAVEFORMATEX structure.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVal</i> argument is not
    ///    a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_SamplesPerSec(int* pVal);
    ///The <b>put_SamplesPerSec</b> method sets the <b>nSamplesPerSec</b> member in the WAVEFORMATEX structure.
    ///Params:
    ///    nNewVal = New value for the <b>nSamplesPerSec</b> member in the WAVEFORMATEX structure.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_SamplesPerSec(const(int) nNewVal);
    ///The <b>get_AvgBytesPerSec</b> method returns the value for the <b>nAvgBytesPerSec</b> member in the WAVEFORMATEX
    ///structure.
    ///Params:
    ///    pVal = Pointer to the value for the <b>nAvgBytesPerSec</b> member in the WAVEFORMATEX structure.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVal</i> argument is not a
    ///    valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_AvgBytesPerSec(int* pVal);
    ///The <b>put_AvgBytesPerSec</b> method sets the <b>nAvgBytesPerSec</b> member in the WAVEFORMATEX structure.
    ///Params:
    ///    nNewVal = New value for the <b>nAvgBytesPerSec</b> member in the WAVEFORMATEX structure.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_AvgBytesPerSec(const(int) nNewVal);
    ///The <b>get_BlockAlign</b> method returns the value for the <b>nBlockAlign</b> member in the WAVEFORMATEX
    ///structure.
    ///Params:
    ///    pVal = Pointer to the value of the <b>nBlockAlign</b> member in the WAVEFORMATEX structure.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVal</i> argument is not
    ///    a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_BlockAlign(int* pVal);
    ///The <b>put_BlockAlign</b> method sets the <b>nBlockAlign</b> member in the WAVEFORMATEX structure.
    ///Params:
    ///    nNewVal = New value for the <b>nBlockAlign</b> member in the WAVEFORMATEX structure.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_BlockAlign(const(int) nNewVal);
    ///The <b>get_BitsPerSample</b> method returns the value for the <b>wBitsPerSample</b> member in the WAVEFORMATEX
    ///structure.
    ///Params:
    ///    pVal = Pointer to the value of the <b>wBitsPerSample</b> member in the WAVEFORMATEX structure.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVal</i> argument is not
    ///    a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_BitsPerSample(int* pVal);
    ///The <b>put_BitsPerSample</b> method sets the <b>wBitsPerSample</b> member in the WAVEFORMATEX structure.
    ///Params:
    ///    nNewVal = New value for the <b>wBitsPerSample</b> member in the WAVEFORMATEX structure.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_BitsPerSample(const(int) nNewVal);
    ///The <b>get_FormatTag</b> method returns the value for the <b>wFormatTag</b> member in the WAVEFORMATEX structure.
    ///Params:
    ///    pVal = Pointer to the value of the <b>wFormatTag</b> member in the WAVEFORMATEX structure.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVal</i> argument is not
    ///    a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_FormatTag(int* pVal);
    ///The <b>put_FormatTag</b> method sets the <b>wFormatTag</b> member in the WAVEFORMATEX structure.
    ///Params:
    ///    nNewVal = New value for the <b>wFormatTag</b> member in the WAVEFORMATEX structure.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_FormatTag(const(int) nNewVal);
}

///Agents are the heart of a call center. They are responsible for receiving and processing incoming calls and, at
///times, making outgoing calls to customers or prospects. The following methods create the <b>ITAgent</b> interface:
///IEnumAgent::Next ITAgentEvent::get_Agent ITAgentHandler::CreateAgent See About Call Center Controls for additional
///information.
@GUID("5770ECE5-4B27-11D1-BF80-00805FC147D3")
interface ITAgent : IDispatch
{
    ///The <b>EnumerateAgentSessions</b> method enumerates the current agent sessions. This method is provided for C and
    ///C++ applications. Automation client applications, such as those written in Visual Basic, must use the
    ///get_AgentSessions method.
    ///Params:
    ///    ppEnumAgentSession = Pointer to an IEnumAgentSession agent session enumerator.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <b>ppEnumAgentSession</b>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT EnumerateAgentSessions(IEnumAgentSession* ppEnumAgentSession);
    ///The <b>CreateSession</b> method creates a new agent session for the input ACD group and address.
    ///Params:
    ///    pACDGroup = Pointer to ITACDGroup interface.
    ///    pAddress = Pointer to ITAddress object available for receiving ACD calls.
    ///    ppAgentSession = Pointer to ITAgentSession interface for object created.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppAgentSession</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Failed to open a line for the target Address. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pACDGroup</i> or <i>pAddress</i> argument is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT CreateSession(ITACDGroup pACDGroup, ITAddress pAddress, ITAgentSession* ppAgentSession);
    ///The <b>CreateSessionWithPIN</b> method creates a new agent session for the input ACD group and address, with
    ///Personal Identification Number (PIN).
    ///Params:
    ///    pACDGroup = Pointer to ITACDGroup interface.
    ///    pAddress = Pointer to ITAddress interface for object available for receiving ACD calls.
    ///    pPIN = Pointer to a <b>BSTR</b> representation of agent's PIN.
    ///    ppAgentSession = Pointer to session created.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>TAPI_E_CALLCENTER_NO_AGENT_ID</b></dt> </dl> </td> <td width="60%"> Agent not
    ///    created by CreateAgentWithID. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl>
    ///    </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    <i>pPIN</i> is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pPIN</i> or <i>ppAgentSession</i> parameter is not a valid pointer. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> </table>
    ///    
    HRESULT CreateSessionWithPIN(ITACDGroup pACDGroup, ITAddress pAddress, BSTR pPIN, 
                                 ITAgentSession* ppAgentSession);
    ///The <b>get_ID</b> method gets an agent's ID.
    ///Params:
    ///    ppID = Pointer to <b>BSTR</b> containing agent ID.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>TAPI_E_CALLCENTER_NO_AGENT_ID</b></dt> </dl> </td> <td width="60%"> ITAgent was
    ///    not created using ITAgentHandler::CreateAgentWithID, but with ITAgentHandler::CreateAgent. No ID exists.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppID</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_ID(BSTR* ppID);
    ///The <b>get_User</b> method gets the agent user name, which is the same as the operating system user login or
    ///e-mail name.
    ///Params:
    ///    ppUser = Pointer to <b>BSTR</b> containing user name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppUser</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_User(BSTR* ppUser);
    ///The <b>put_State</b> method sets the state of an agent session.
    ///Params:
    ///    AgentState = AGENT_STATE.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Agent session state is
    ///    incorrect. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT put_State(AGENT_STATE AgentState);
    ///The <b>get_State</b> method gets the state of an agent session.
    ///Params:
    ///    pAgentState = Pointer to an AGENT_STATE.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pAgentState</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_State(AGENT_STATE* pAgentState);
    ///The <b>put_MeasurementPeriod</b> method sets the period (in seconds) for which the switch and/or implementation
    ///stores and calculates information. This also resets any cumulative counts to zero.
    ///Params:
    ///    lPeriod = Measurement period (in seconds).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Value of <i>lPeriod</i> is
    ///    zero. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>LINEERR_</b></dt> </dl> </td> <td width="60%"> See lineSetAgentMeasurementPeriod for error codes
    ///    returned from this TAPI 2.1 function. </td> </tr> </table>
    ///    
    HRESULT put_MeasurementPeriod(int lPeriod);
    ///The <b>get_MeasurementPeriod</b> method gets the measurement period (in seconds) for which the switch and/or
    ///implementation stores and calculates information. For example, get_NumberOfACDCalls returns the number of calls
    ///the agent handled; <b>get_MeasurementPeriod</b> indicates if this value referenced the calls handled in the last
    ///hour, day, month, etc.
    ///Params:
    ///    plPeriod = Measurement period.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plPeriod</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_MeasurementPeriod(int* plPeriod);
    ///The <b>get_OverallCallRate</b> method gets an agent's call rate across all sessions. 10 *Calls per agent hour
    ///(where agent hour represents the time that an agent was active in one or more agent sessions). The measurement
    ///period over which this information is calculated is switch- and/or implementation-specific. (See
    ///get_MeasurementPeriod.)
    ///Params:
    ///    pcyCallrate = Call rate.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pcyCallrate</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_OverallCallRate(CY* pcyCallrate);
    ///The <b>get_NumberOfACDCalls</b> method gets the number of ACD calls handled by this agent across all sessions.
    ///The measurement period over which this information is calculated is switch- and/or implementation-specific. (See
    ///get_MeasurementPeriod.)
    ///Params:
    ///    plCalls = Total number of calls.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCalls</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_NumberOfACDCalls(int* plCalls);
    ///The <b>get_NumberOfIncomingCalls</b> method gets the number of incoming non-ACD calls handled by this agent. The
    ///measurement period over which this information is calculated is switch- and/or implementation-specific. (See
    ///get_MeasurementPeriod.)
    ///Params:
    ///    plCalls = Total number of incoming calls.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCalls</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_NumberOfIncomingCalls(int* plCalls);
    ///The <b>get_NumberOfOutgoingCalls</b> method gets the number of outgoing non-ACD calls handled during by this
    ///agent. The measurement period over which this information is calculated is switch- and/or
    ///implementation-specific. (See get_MeasurementPeriod.)
    ///Params:
    ///    plCalls = Total number of outgoing calls.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCalls</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_NumberOfOutgoingCalls(int* plCalls);
    ///The <b>get_TotalACDTalkTime</b> gets the number of seconds spent talking in ACD calls by this agent (across all
    ///sessions). The measurement period over which this information is calculated is switch- and/or
    ///implementation-specific. (See get_MeasurementPeriod.)
    ///Params:
    ///    plTalkTime = Total talk time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plTalkTime</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_TotalACDTalkTime(int* plTalkTime);
    ///The <b>get_TotalACDCallTime</b> gets the number of seconds spent on ACD calls by this agent (across all
    ///sessions). This value includes the time spent on the phone plus wrap-up time. The measurement period over which
    ///this information is calculated is switch- and/or implementation-specific. (See get_MeasurementPeriod.)
    ///Params:
    ///    plCallTime = Total call time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCallTime</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_TotalACDCallTime(int* plCallTime);
    ///The <b>get_TotalWrapUpTime</b> method gets the number of seconds spent on ACD call wrap-up (after-call work) by
    ///this agent (across all sessions). The measurement period over which this information is calculated is switch
    ///and/or implementation-specific. (See get_MeasurementPeriod.)
    ///Params:
    ///    plWrapUpTime = Total wrap-up time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plWrapUpTime</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL
    ///    timed it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_TotalWrapUpTime(int* plWrapUpTime);
    ///The <b>get_AgentSessions</b> method creates a collection of current agent sessions. This method is provided for
    ///Automation client applications, such as those written in Visual Basic. C and C++ applications must use the
    ///EnumerateAgentSessions method.
    ///Params:
    ///    pVariant = Pointer to <b>VARIANT</b> containing an ITCollection of ITAgentSession interface pointers (agent session
    ///               objects).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter is not
    ///    a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_AgentSessions(VARIANT* pVariant);
}

///An agent session represents an association between an agent, group, and address. The methods of <b>ITAgentSession</b>
///allow an application to retrieve a variety of statistics. The following methods create the <b>ITAgentSession</b>
///interface: IEnumAgentSession::Next ITAgent::get_AgentSessions ITAgent::CreateSession See About Call Center Controls
///for additional information. Note to TAPI 2.1 programmers: Many of the methods in this interface are COM wrappers for
///lineGetAgentSessionInfo.
@GUID("5AFC3147-4BCC-11D1-BF80-00805FC147D3")
interface ITAgentSession : IDispatch
{
    ///The <b>get_Agent</b> method gets a pointer to the ITAgent interface associated with this session.
    ///Params:
    ///    ppAgent = pointer to ITAgent interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppAgent</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Agent(ITAgent* ppAgent);
    ///The <b>get_Address</b> method gets a pointer to the ITAddress interface associated with this session.
    ///Params:
    ///    ppAddress = Pointer for ITAddress.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppAddress</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Address(ITAddress* ppAddress);
    ///The <b>get_ACDGroup</b> method gets the ACD group associated with this session.
    ///Params:
    ///    ppACDGroup = Pointer to ITACDGroup interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppACDGroup</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>LINEERR_</b></dt> </dl> </td> <td width="60%"> See lineGetAgentSessionInfo for error codes returned
    ///    from this TAPI 2.1 function. </td> </tr> </table>
    ///    
    HRESULT get_ACDGroup(ITACDGroup* ppACDGroup);
    ///The <b>put_State</b> method sets the state of the agent session.
    ///Params:
    ///    SessionState = AGENT_SESSION_STATE.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>SessionState</i> parameter is not a valid session state. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>LINEERR_</b></dt> </dl> </td> <td width="60%"> See lineSetAgentSessionState for
    ///    error codes returned from this TAPI 2.1 function. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT put_State(AGENT_SESSION_STATE SessionState);
    ///The <b>get_State</b> method gets the current state of this session.
    ///Params:
    ///    pSessionState = Pointer to an AGENT_SESSION_STATE.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pSessionState</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_State(AGENT_SESSION_STATE* pSessionState);
    ///The <b>get_SessionStartTime</b> method gets the time that the session was created.
    ///Params:
    ///    pdateSessionStart = Pointer to session start time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pdateSessionStart</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>LINEERR_</b></dt> </dl> </td> <td width="60%"> See lineGetAgentSessionInfo for error codes
    ///    returned from this TAPI 2.1 function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt>
    ///    </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval
    ///    is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_SessionStartTime(double* pdateSessionStart);
    ///The <b>get_SessionDuration</b> method gets the duration of the Agent session in seconds. This duration is for the
    ///active period only; timing stops when a session enters the ASST_SESSION_ENDED state of AGENT_SESSION_STATE.
    ///Params:
    ///    plDuration = Pointer to session duration.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plDuration</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>LINEERR_</b></dt> </dl> </td> <td width="60%"> See lineGetAgentSessionInfo for error codes returned
    ///    from this TAPI 2.1 function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl>
    ///    </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> </table>
    ///    
    HRESULT get_SessionDuration(int* plDuration);
    ///The <b>get_NumberOfCalls</b> method gets the number of ACD calls handled by this agent during this session.
    ///Params:
    ///    plCalls = Pointer to total number of calls.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plCalls</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>LINEERR_</b></dt> </dl> </td> <td width="60%"> See lineGetAgentSessionInfo for error codes returned
    ///    from this TAPI 2.1 function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl>
    ///    </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> </table>
    ///    
    HRESULT get_NumberOfCalls(int* plCalls);
    ///The <b>get_TotalTalkTime</b> method gets the number of seconds spent by this agent talking in ACD calls during
    ///this session.
    ///Params:
    ///    plTalkTime = Total talk time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plTalkTime</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>LINEERR_</b></dt> </dl> </td> <td width="60%"> See lineGetAgentSessionInfo for error codes returned
    ///    from this TAPI 2.1 function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl>
    ///    </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> </table>
    ///    
    HRESULT get_TotalTalkTime(int* plTalkTime);
    ///The <b>get_AverageTalkTime</b> method gets the average time (in seconds) spent talking per ACD call, during this
    ///agent session (by this agent).
    ///Params:
    ///    plTalkTime = Average talk time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plTalkTime</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>LINEERR_</b></dt> </dl> </td> <td width="60%"> See lineGetAgentSessionInfo for error codes returned
    ///    from this TAPI 2.1 function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl>
    ///    </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> </table>
    ///    
    HRESULT get_AverageTalkTime(int* plTalkTime);
    ///The <b>get_TotalCallTime</b> method gets the number of seconds spent on ACD calls during this agent session (by
    ///this agent). This value includes the time spent on the phone plus wrap-up time.
    ///Params:
    ///    plCallTime = Pointer to total call time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plCallTime</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>LINEERR_</b></dt> </dl> </td> <td width="60%"> See lineGetAgentSessionInfo for error codes returned
    ///    from this TAPI 2.1 function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl>
    ///    </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> </table>
    ///    
    HRESULT get_TotalCallTime(int* plCallTime);
    ///The <b>get_AverageCallTime</b> method gets the average time (in seconds) spent per ACD call during this agent
    ///session. This value includes the time spent on the phone plus wrap-up time.
    ///Params:
    ///    plCallTime = Pointer to the average call time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plCallTime</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>LINEERR_</b></dt> </dl> </td> <td width="60%"> See lineGetAgentSessionInfo for error codes returned
    ///    from this TAPI 2.1 function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl>
    ///    </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> </table>
    ///    
    HRESULT get_AverageCallTime(int* plCallTime);
    ///The <b>get_TotalWrapUpTime</b> method gets the number of seconds spent on ACD call wrap-up (after-call work)
    ///during this agent session (by this agent).
    ///Params:
    ///    plWrapUpTime = Pointer to total wrap-up time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plWrapUpTime</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>LINEERR_</b></dt> </dl> </td> <td width="60%"> See lineGetAgentSessionInfo for error codes returned
    ///    from this TAPI 2.1 function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl>
    ///    </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> </table>
    ///    
    HRESULT get_TotalWrapUpTime(int* plWrapUpTime);
    ///The <b>get_AverageWrapUpTime</b> method gets the average time (in seconds) per ACD call spent in wrap-up
    ///(after-call work) during this agent session.
    ///Params:
    ///    plWrapUpTime = Pointer to average wrap-up time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plWrapUpTime</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>LINEERR_</b></dt> </dl> </td> <td width="60%"> See lineGetAgentSessionInfo for error codes returned
    ///    from this TAPI 2.1 function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl>
    ///    </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> </table>
    ///    
    HRESULT get_AverageWrapUpTime(int* plWrapUpTime);
    ///The <b>get_ACDCallRate</b> method gets the all rate per agent session, in calls per hour.
    ///Params:
    ///    pcyCallrate = Pointer to call rate.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pcyCallrate</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>LINEERR_</b></dt> </dl> </td> <td width="60%"> See lineGetAgentSessionInfo for error codes returned
    ///    from this TAPI 2.1 function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl>
    ///    </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> </table>
    ///    
    HRESULT get_ACDCallRate(CY* pcyCallrate);
    ///The <b>get_LongestTimeToAnswer</b> method gets the longest time (in seconds) a call was waiting to be answered.
    ///Params:
    ///    plAnswerTime = Pointer to longest time to answer a call.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plAnswerTime</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>LINEERR_</b></dt> </dl> </td> <td width="60%"> See lineGetAgentSessionInfo for error codes returned
    ///    from this TAPI 2.1 function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl>
    ///    </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> </table>
    ///    
    HRESULT get_LongestTimeToAnswer(int* plAnswerTime);
    ///The <b>get_AverageTimeToAnswer</b> method gets the average time (in seconds) that calls waited to be answered.
    ///Params:
    ///    plAnswerTime = Pointer to average time to answer a call.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>plAnswerTime</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>LINEERR_</b></dt> </dl> </td> <td width="60%"> See lineGetAgentSessionInfo for error codes returned
    ///    from this TAPI 2.1 function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl>
    ///    </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two
    ///    minutes. </td> </tr> </table>
    ///    
    HRESULT get_AverageTimeToAnswer(int* plAnswerTime);
}

///Automatic Call Distribution (ACD) is a mechanism that queues and distributes calls within a switching system. The
///ACDGroup object reflects an ACD pilot, split, or group. For example, one ACDGroup might handle calls for new accounts
///while another handles queries on existing accounts. The following methods create the <b>ITACDGroup</b> interface:
///IEnumACDGroup::Next ITAgentHandler::get_ACDGroups ITAgent::CreateSession See About Call Center Controls for
///additional information.
@GUID("5AFC3148-4BCC-11D1-BF80-00805FC147D3")
interface ITACDGroup : IDispatch
{
    ///The <b>get_Name</b> method gets the ACD group name. This string can be a displayable name for the group.
    ///Params:
    ///    ppName = Pointer to <b>BSTR</b> representation of group name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppName</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Name(BSTR* ppName);
    ///The <b>EnumerateQueues</b> method enumerates queues currently on the ACD group. This method is provided for C and
    ///C++ applications. Automation client applications, such as those written in Visual Basic, must use the get_Queues
    ///method.
    ///Params:
    ///    ppEnumQueue = Pointer to IEnumQueue interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppEnumQueue</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT EnumerateQueues(IEnumQueue* ppEnumQueue);
    ///The <b>get_Queues</b> method creates a collection of queues associated with the current ACD group. This method is
    ///provided for Automation client applications, such as those written in Visual Basic. C and C++ applications must
    ///use the EnumerateQueues method.
    ///Params:
    ///    pVariant = Pointer to <b>VARIANT</b> containing an ITCollection of ITQueue interface pointers (queue objects).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pVariant</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_Queues(VARIANT* pVariant);
}

///Gets and sets information concerning a queue. The IEnumQueue::Next and ITACDGroup::get_Queues methods create the
///<b>ITQueue</b> interface. See About Call Center Controls for additional information.
@GUID("5AFC3149-4BCC-11D1-BF80-00805FC147D3")
interface ITQueue : IDispatch
{
    ///The <b>put_MeasurementPeriod</b> method sets the period (in seconds) for which the switch and/or implementation
    ///stores and calculates information.
    ///Params:
    ///    lPeriod = Measurement period (in seconds).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Value of <i>lPeriod</i> is
    ///    zero. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>LINEERR_</b></dt>
    ///    </dl> </td> <td width="60%"> See lineSetQueueMeasurementPeriod for error codes returned from this TAPI 2.1
    ///    function. </td> </tr> </table>
    ///    
    HRESULT put_MeasurementPeriod(int lPeriod);
    ///The <b>get_MeasurementPeriod</b> method gets the measurement period (in seconds) for which the switch and/or
    ///implementation stores and calculates information. For example, the get_TotalCallsQueued method returns the number
    ///of calls queued; <b>get_MeasurementPeriod</b> indicates if this value referenced the calls queued in an hour, a
    ///day, a month, etc.
    ///Params:
    ///    plPeriod = Pointer to the measurement period.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plPeriod</i> is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_MeasurementPeriod(int* plPeriod);
    ///The <b>get_TotalCallsQueued</b> method gets the total number of incoming calls for this queue during the current
    ///measurement period. The measurement period is switch or implementation specific. (See get_MeasurementPeriod.)
    ///Params:
    ///    plCalls = Pointer to the total number of incoming calls.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCalls</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_TotalCallsQueued(int* plCalls);
    ///The <b>get_CurrentCallsQueued</b> method gets the number of incoming calls currently waiting.
    ///Params:
    ///    plCalls = Pointer to the number of incoming calls in the queue.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCalls</i> is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_CurrentCallsQueued(int* plCalls);
    ///The <b>get_TotalCallsAbandoned</b> method gets the number of abandoned calls during the current measurement
    ///period. The measurement period is switch or implementation specific. (See get_MeasurementPeriod.)
    ///Params:
    ///    plCalls = Pointer to the number of calls abandoned.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCalls</i> is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_TotalCallsAbandoned(int* plCalls);
    ///The <b>get_TotalCallsFlowedIn</b> method gets the total number of calls that flowed into this queue (passed down
    ///from another queue or ACD group) during the current measurement period. The measurement period is switch or
    ///implementation specific. (See get_MeasurementPeriod.)
    ///Params:
    ///    plCalls = Pointer to the number of calls.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCalls</i> is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_TotalCallsFlowedIn(int* plCalls);
    ///The <b>get_TotalCallsFlowedOut</b> method gets the total number of calls that flowed out of this queue (passed
    ///down to another queue or ACD group) during the current measurement period. The measurement period is switch or
    ///implementation specific. (See get_MeasurementPeriod.)
    ///Params:
    ///    plCalls = Pointer to number of calls.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCalls</i> is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_TotalCallsFlowedOut(int* plCalls);
    ///The <b>get_LongestEverWaitTime</b> method gets the longest time any call waited in the queue (in seconds) during
    ///the current measurement period. The measurement period is switch or implementation specific. (See
    ///get_MeasurementPeriod.)
    ///Params:
    ///    plWaitTime = Pointer to the wait time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plWaitTime</i> is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_LongestEverWaitTime(int* plWaitTime);
    ///The <b>get_CurrentLongestWaitTime</b> method gets the longest time a current call (still in the queue) has been
    ///waiting (in seconds) during the current measurement period. The measurement period is switch or implementation
    ///specific. (See get_MeasurementPeriod.).
    ///Params:
    ///    plWaitTime = Pointer to wait time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plWaitTime</i> is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_CurrentLongestWaitTime(int* plWaitTime);
    ///The <b>get_AverageWaitTime</b> method gets the average time in the queue (in seconds) for a call during the
    ///current measurement period. The measurement period is switch or implementation specific. (See
    ///get_MeasurementPeriod.)
    ///Params:
    ///    plWaitTime = Pointer to the average wait time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plWaitTime</i> is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_AverageWaitTime(int* plWaitTime);
    ///The <b>get_FinalDisposition</b> method gets the total number of calls reaching the bottom of a call guide during
    ///the current measurement period. This indicates that a call has passed through an ACD system, moving from queue to
    ///queue, without being answered, which indicates a problem with the queue design or response times. The measurement
    ///period is switch- or implementation-specific. (See get_MeasurementPeriod.)
    ///Params:
    ///    plCalls = Pointer to number of calls.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>plCalls</i> is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_FinalDisposition(int* plCalls);
    ///The <b>get_Name</b> method gets the queue name.
    ///Params:
    ///    ppName = Pointer to <b>BSTR</b> representation of queue name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppName</i> is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Name(BSTR* ppName);
}

///The <b>ITAgentEvent</b> interface contains methods that retrieve the description of agent events. When the
///application's implementation of the ITTAPIEventNotification::Event method indicates a TAPI_EVENT equal to
///<b>TE_AGENT</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b> pointer for the <b>ITAgentEvent</b>
///interface. The methods of this interface can be used to retrieve information concerning the agent event that has
///occurred. See About Call Center Controls for additional information on agents. <div class="alert"><b>Note</b> You
///must call the ITTAPI::put_EventFilter method and set an event filter mask that includes the <b>TE_AGENT</b> event to
///enable reception of agent events. If you do not call <b>ITTAPI::put_EventFilter</b>, your application will not
///receive any events. For more information, see the Events overview.</div><div> </div>
@GUID("5AFC314A-4BCC-11D1-BF80-00805FC147D3")
interface ITAgentEvent : IDispatch
{
    ///The <b>get_Agent</b> method gets the interface for the agent on which the event occurred.
    ///Params:
    ///    ppAgent = Pointer to ITAgent interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppAgent</i> parameter is not
    ///    a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Agent(ITAgent* ppAgent);
    ///Gets an AGENT_EVENT descriptor of the event that occurred.
    ///Params:
    ///    pEvent = Pointer to AGENT_EVENT descriptor of event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pEvent</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Event(AGENT_EVENT* pEvent);
}

///The <b>ITAgentSessionEvent</b> interface contains methods that retrieve the description of agent session events. When
///the application's implementation of the ITTAPIEventNotification::Event method indicates a TAPI_EVENT equal to
///<b>TE_AGENTSESSION</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b> pointer for the
///<b>ITAgentSessionEvent</b> interface. The methods of this interface can be used to retrieve information concerning
///the agent session change that has occurred. See About Call Center Controls for additional information. <div
///class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter method and set an event filter mask that includes
///the <b>TE_AGENTSESSION</b> event to enable reception of agent session events. If you do not call
///<b>ITTAPI::put_EventFilter</b>, your application will not receive any events. For more information, see the Events
///overview.</div><div> </div>
@GUID("5AFC314B-4BCC-11D1-BF80-00805FC147D3")
interface ITAgentSessionEvent : IDispatch
{
    ///The <b>get_Session</b> method gets a pointer to the ITAgentSession on which the event occurred.
    ///Params:
    ///    ppSession = Pointer to the ITAgentSession interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppSession</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Session(ITAgentSession* ppSession);
    ///The <b>get_Event</b> method gets an AGENT_SESSION_EVENT descriptor of the event that occurred.
    ///Params:
    ///    pEvent = Pointer to the AGENT_SESSION_EVENT descriptor of the event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pEvent</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Event(AGENT_SESSION_EVENT* pEvent);
}

///The <b>ITACDGroupEvent</b> interface contains methods that retrieve the description of Automatic Call Distribution
///(ACD) group events. When the application's implementation of the ITTAPIEventNotification::Event method indicates a
///TAPI_EVENT equal to <b>TE_ACDGROUP</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b> pointer for the
///<b>ITACDGroupEvent</b> interface. The methods of this interface can be used to retrieve information concerning the
///ACD group change that has occurred. See About Call Center Controls for additional information concerning ACD groups.
///<div class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter method and set an event filter mask that
///includes the <b>TE_ACDGROUP</b> event to enable reception of ACD group events. If you do not call
///ITTAPI::put_EventFilter, your application will not receive any events. For more information, see the Events
///overview.</div><div> </div>
@GUID("297F3032-BD11-11D1-A0A7-00805FC147D3")
interface ITACDGroupEvent : IDispatch
{
    ///The <b>get_Group</b> method gets the ITACDGroup interface pointer for the group on which the event occurred.
    ///Params:
    ///    ppGroup = Pointer to ITACDGroup interface on which the event occurred.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppGroup</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Group(ITACDGroup* ppGroup);
    ///The <b>get_Event</b> method gets the descriptor of an event which indicates that a new ACD group has been added.
    ///Params:
    ///    pEvent = Pointer to ACDGROUP_EVENT descriptor of event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pEvent</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Event(ACDGROUP_EVENT* pEvent);
}

///The <b>ITQueueEvent</b> interface contains methods that retrieve the description of Automatic Call Distribution (ACD)
///queue events. When the application's implementation of the ITTAPIEventNotification::Event method indicates a
///TAPI_EVENT equal to <b>TE_QUEUE</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b> pointer for the
///<b>ITQueueEvent</b> interface. The methods of this interface can be used to retrieve information concerning a queue
///event that has occurred. <div class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter method and set an
///event filter mask that includes the <b>TE_QUEUE</b> event to enable reception of ACD queue events. If you do not call
///<b>ITTAPI::put_EventFilter</b>, your application will not receive any events. For more information, see the Events
///overview.</div><div> </div>
@GUID("297F3033-BD11-11D1-A0A7-00805FC147D3")
interface ITQueueEvent : IDispatch
{
    ///The <b>get_Queue</b> method gets a pointer to the queue on which the event occurred.
    ///Params:
    ///    ppQueue = Pointer to ITQueue interface on which event occurred.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppQueue</i> is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Queue(ITQueue* ppQueue);
    ///The <b>get_Event</b> method gets the descriptor of the event that occurred.
    ///Params:
    ///    pEvent = Pointer to ACDQUEUE_EVENT descriptor of event.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pEvent</i> is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Event(ACDQUEUE_EVENT* pEvent);
}

///The <b>ITAgentHandlerEvent</b> interface contains methods that retrieve the description of agent handler events. When
///the application's implementation of the ITTAPIEventNotification::Event method indicates a TAPI_EVENT equal to
///<b>TE_AGENTHANDLER</b>, the method's <i>pEvent</i> parameter is an <b>IDispatch</b> pointer for the
///<b>ITAgentHandlerEvent</b> interface. The methods of this interface can be used to retrieve information concerning
///the agent handler change that has occurred. See About Call Center Controls for additional information. <div
///class="alert"><b>Note</b> You must call the ITTAPI::put_EventFilter method and set an event filter mask that includes
///the <b>TE_AGENTHANDLER</b> event to enable reception of agent handler events. If you do not call
///<b>ITTAPI::put_EventFilter</b>, your application will not receive any events. For more information, see the Events
///overview.</div><div> </div>
@GUID("297F3034-BD11-11D1-A0A7-00805FC147D3")
interface ITAgentHandlerEvent : IDispatch
{
    ///The <b>get_AgentHandler</b> method gets the ITAgentHandler interface pointer.
    ///Params:
    ///    ppAgentHandler = Pointer to the ITAgentHandler interface on which the event occurred.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppAgentHandler</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_AgentHandler(ITAgentHandler* ppAgentHandler);
    ///The <b>get_Event</b> method gets the description for the event that has occurred.
    ///Params:
    ///    pEvent = Pointer to the AGENTHANDLER_EVENT descriptor.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pEvent</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Event(AGENTHANDLER_EVENT* pEvent);
}

///The <b>ITTAPICallCenter</b> interface provides an entry point into call center controls. It exposes methods that
///allow an application to discover available agent handlers. The agent handler interface can then be used to access the
///other elements of a call center, such as ACD groups, agents, and queues. The <b>ITTAPICallCenter</b> interface is
///created by calling <b>QueryInterface</b> on ITTAPI. Please see About Call Center Controls for additional information.
@GUID("5AFC3154-4BCC-11D1-BF80-00805FC147D3")
interface ITTAPICallCenter : IDispatch
{
    ///The <b>EnumerateAgentHandlers</b> method enumerates agent handlers that are currently associated with the call
    ///center. Provided for C and C++ applications. Automation client applications, such as those written in Visual
    ///Basic, must use the get_AgentHandlers method.
    ///Params:
    ///    ppEnumHandler = Pointer to IEnumAgentHandler enumerator.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnumHandler</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The TAPI object has not been initialized. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT EnumerateAgentHandlers(IEnumAgentHandler* ppEnumHandler);
    ///The <b>get_AgentHandlers</b> method creates a collection of agent handlers that are currently associated with the
    ///call center. Provided for Automation client applications, such as those written in Visual Basic. C and C++
    ///applications must use the EnumerateAgentHandlers method.
    ///Params:
    ///    pVariant = Pointer to a <b>VARIANT</b> containing an ITCollection of ITAgentHandler interface pointers.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVariant</i> parameter is not a valid pointer.
    ///    </td> </tr> </table>
    ///    
    HRESULT get_AgentHandlers(VARIANT* pVariant);
}

///The <b>ITAgentHandler</b> interface provides methods to create Agent objects and enumerate Automatic Call
///Distribution (ACD) groups. The IEnumAgentHandler::Next and ITTapiCallCenter::get_AgentHandlers methods create the
///<b>ITAgentHandler</b> interface.
@GUID("587E8C22-9802-11D1-A0A4-00805FC147D3")
interface ITAgentHandler : IDispatch
{
    ///The <b>get_Name</b> method gets the agent handler name.
    ///Params:
    ///    ppName = Pointer to <b>BSTR</b> representation of the agent handler name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppName</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_Name(BSTR* ppName);
    ///The <b>CreateAgent</b> method creates an Agent object.
    ///Params:
    ///    ppAgent = Pointer to the ITAgent interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppAgent</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT CreateAgent(ITAgent* ppAgent);
    ///The <b>CreateAgentWithID</b> method creates an Agent object based on an agent identifier. This identifier is a
    ///string identifying the agent on a legacy ACD system. If the system also requires a PIN or password for logging
    ///into groups, you use this method to set the PIN or password.
    ///Params:
    ///    pID = Pointer to <b>BSTR</b> containing the agent identifier.
    ///    pPIN = Pointer to <b>BSTR</b> containing the agent PIN.
    ///    ppAgent = Pointer to ITAgent interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pPIN</i> parameter is
    ///    <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%">
    ///    The <i>ppAgent</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%">
    ///    The operation failed because the TAPI 3 DLL timed it out. The timeout interval is two minutes. </td> </tr>
    ///    </table>
    ///    
    HRESULT CreateAgentWithID(BSTR pID, BSTR pPIN, ITAgent* ppAgent);
    ///The <b>EnumerateACDGroups</b> method enumerates ACD groups currently associated with the agent handler. This
    ///method is provided for C and C++ applications. Automation client applications, such as those written in Visual
    ///Basic, must use the get_ACDGroups method. The number of groups returned is based upon replies from the ACD proxy
    ///application. Each proxy application will return a list of groups according to its own internal privilege/security
    ///decisions.
    ///Params:
    ///    ppEnumACDGroup = Pointer to IEnumACDGroup interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppEnumACDGroup</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL
    ///    timed it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT EnumerateACDGroups(IEnumACDGroup* ppEnumACDGroup);
    ///The <b>EnumerateUsableAddresses</b> method enumerates addresses available for receiving ACD calls on this agent
    ///handler. This method is provided for C and C++ applications. Automation client applications, such as those
    ///written in Visual Basic, must use the get_UsableAddresses method.
    ///Params:
    ///    ppEnumAddress = Pointer to IEnumAddress interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>ppEnumAddress</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT EnumerateUsableAddresses(IEnumAddress* ppEnumAddress);
    ///The <b>get_ACDGroups</b> method creates a collection of ACD groups currently associated with the agent handler.
    ///This method is provided for Automation client applications, such as those written in Visual Basic. C and C++
    ///applications must use the EnumerateACDGroups method.
    ///Params:
    ///    pVariant = Pointer to <b>VARIANT</b> containing an ITCollection of ITACDGroup interface pointers (ACD group objects).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pVariant</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The operation failed because the TAPI 3 DLL timed
    ///    it out. The timeout interval is two minutes. </td> </tr> </table>
    ///    
    HRESULT get_ACDGroups(VARIANT* pVariant);
    ///The <b>get_UsableAddresses</b> method creates a collection of addresses available for receiving ACD calls on this
    ///agent handler. This method is provided for Automation client applications, such as those written in Visual Basic.
    ///C and C++ applications must use the EnumerateUsableAddresses method.
    ///Params:
    ///    pVariant = Pointer to <b>VARIANT</b> containing an ITCollection of ITAddress interface pointers (address objects).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pVariant</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_UsableAddresses(VARIANT* pVariant);
}

///Enumerator interface for ITAgent.
@GUID("5AFC314D-4BCC-11D1-BF80-00805FC147D3")
interface IEnumAgent : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITAgent pointer.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppElements</i> parameter is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, ITAgent* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets the enumeration sequence to the beginning.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///Params:
    ///    ppEnum = Pointer to new IEnumAgent interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumAgent* ppEnum);
}

///The <b>IEnumAgentSession</b> interface provides COM-standard enumeration methods for the ITAgentSession interface.
///The ITAgent::EnumerateAgentSessions method returns a pointer to <b>IEnumAgentSession</b>.
@GUID("5AFC314E-4BCC-11D1-BF80-00805FC147D3")
interface IEnumAgentSession : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITAgentSession interface.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppElements</i> parameter is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, ITAgentSession* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets the enumeration sequence to the beginning.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///Params:
    ///    ppEnum = Pointer to new IEnumAgentSession interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumAgentSession* ppEnum);
}

///The <b>IEnumQueue</b> interface provides COM-standard enumeration methods for the ITQueue interface. The
///ITACDGroup::EnumerateQueues method returns a pointer to <b>IEnumQueue</b>.
@GUID("5AFC3158-4BCC-11D1-BF80-00805FC147D3")
interface IEnumQueue : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITQueue list of interface pointers returned.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppElements</i> parameter is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, ITQueue* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets the enumeration sequence to the beginning.
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence.
    ///Params:
    ///    celt = Number of elements to skip.
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///Params:
    ///    ppEnum = Pointer to new IEnumQueue interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumQueue* ppEnum);
}

///The <b>IEnumACDGroup</b> interface provides COM-standard enumeration methods for the ITACDGroup interface. The
///ITAgentHandler::EnumerateACDGroups method returns a pointer to <b>IEnumACDGroup</b>.
@GUID("5AFC3157-4BCC-11D1-BF80-00805FC147D3")
interface IEnumACDGroup : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITACDGroup list of pointers returned.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>ppElements</i> parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, ITACDGroup* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets the enumeration sequence to the beginning.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///Params:
    ///    ppEnum = Pointer to new IEnumACDGroup interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumACDGroup* ppEnum);
}

///The <b>IEnumAgentHandler</b> interface provides COM-standard enumeration methods for the ITAgentHandler interface.
///The ITTAPICallCenter::EnumerateAgentHandlers method returns a pointer to <b>IEnumAgentHandler</b>.
@GUID("587E8C28-9802-11D1-A0A4-00805FC147D3")
interface IEnumAgentHandler : IUnknown
{
    ///The <b>Next</b> method gets the next specified number of elements in the enumeration sequence.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to ITAgentHandler interfaces.
    ///    pceltFetched = Pointer to number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppElements</i> parameter is not a valid
    ///    pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, ITAgentHandler* ppElements, uint* pceltFetched);
    ///The <b>Reset</b> method resets the enumeration sequence to the beginning.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Skip</b> method skips over the next specified number of elements in the enumeration sequence.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Clone</b> method creates another enumerator that contains the same enumeration state as the current one.
    ///Params:
    ///    ppEnum = Pointer to new IEnumAgentHandler interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumAgentHandler* ppEnum);
}

///The <b>ITAMMediaFormat</b> interface sets and gets DirectShow media format. The format is described using the
///<b>AM_MEDIA_TYPE</b> structure. For more information on <b>AM_MEDIA_TYPE</b>, see the DirectX documentation. This
///interface is exposed on a Terminal Object only if an MSP is involved in terminal creation and implements this
///interface. The <b>ITAMMediaFormat</b> interface is created by calling <b>QueryInterface</b> on ITTerminal. On
///addresses where a variety of formats are supported (such as Wave MSP addresses, which are used on most modems and
///voice boards), this media format must be set or the terminal will not be able to connect. For other addresses, such
///as those implemented over IP, the format may be fixed/predetermined. In that case, a call to set format will fail if
///the format is not the same as the predetermined format.
@GUID("0364EB00-4A77-11D1-A671-006097C9A2E8")
interface ITAMMediaFormat : IUnknown
{
    ///The <b>get_MediaFormat</b> method gets the media format.
    ///Params:
    ///    ppmt = Pointer to an array of <b>AM_MEDIA_TYPE</b> structures. For more information on <b>AM_MEDIA_TYPE</b>, see the
    ///           DirectX documentation.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_MediaFormat(AM_MEDIA_TYPE** ppmt);
    ///The <b>put_MediaFormat</b> method sets the media format.
    ///Params:
    ///    pmt = Pointer to <b>AM_MEDIA_TYPE</b> structure. For more information on <b>AM_MEDIA_TYPE</b>, see the DirectX
    ///          documentation.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists
    ///    to perform the operation. </td> </tr> </table>
    ///    
    HRESULT put_MediaFormat(const(AM_MEDIA_TYPE)* pmt);
}

///The <b>ITAllocatorProperties</b> interface exposes the buffer allocator properties of the Media Streaming Terminal
///(MST) to an end-user or server application. An application needs to tune the sample size for a particular protocol.
///The decision concerning appropriate properties is highly implementation dependent. This interface is exposed on the
///Terminal Object by the associated Media Service Provider. If it exists, a <b>QueryInterface</b> on any Terminal
///interface, such as ITTerminal, can be used to obtain an <b>ITAllocatorProperties</b> pointer.
@GUID("C1BC3C90-BCFE-11D1-9745-00C04FD91AC0")
interface ITAllocatorProperties : IUnknown
{
    ///The <b>SetAllocatorProperties</b> method must be called before connection and will force the MSP to use these
    ///values during filter negotiation. If the connecting filter doesn't accept these values, the connection is not
    ///established.
    ///Params:
    ///    pAllocProperties = Pointer to the allocator buffer.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT SetAllocatorProperties(ALLOCATOR_PROPERTIES* pAllocProperties);
    ///The <b>GetAllocatorProperties</b> method gets the current values for the allocator properties after connection
    ///and provides the negotiated values. This method is invalid before connection. The MST will accept any values
    ///suggested by the connected filters.
    ///Params:
    ///    pAllocProperties = Pointer to current allocator values.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT GetAllocatorProperties(ALLOCATOR_PROPERTIES* pAllocProperties);
    ///The <b>SetAllocateBuffers</b> method determines whether the current allocator buffers must be set. This property
    ///is <b>TRUE</b> by default. If set <b>FALSE</b>, the sample that the MST allocated doesn't have any buffers and
    ///they must be supplied before Update is called on the samples.
    ///Params:
    ///    bAllocBuffers = Boolean indicator of whether allocator buffers must be set.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT SetAllocateBuffers(BOOL bAllocBuffers);
    ///The <b>GetAllocateBuffers</b> method determines whether the current allocator buffers can be retrieved. If it
    ///returns <b>FALSE</b>, the sample that the MST allocated doesn't have any buffers and they must be supplied before
    ///<b>Update</b> is called on the samples.
    ///Params:
    ///    pbAllocBuffers = Indicates whether allocator buffers have been set.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT GetAllocateBuffers(int* pbAllocBuffers);
    ///The <b>SetBufferSize</b> method sets the size of the allocator buffer.
    ///Params:
    ///    BufferSize = Size of the allocator buffer.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT SetBufferSize(uint BufferSize);
    ///The <b>GetBufferSize</b> method gets the size of the allocator buffer.
    ///Params:
    ///    pBufferSize = Size of current allocator buffer.
    ///Returns:
    ///    If the method succeeds, it returns S_OK. Otherwise, it returns an error value.
    ///    
    HRESULT GetBufferSize(uint* pBufferSize);
}

///The <b>ITPluggableTerminalEventSink</b> interface provides a method that fires a message to notify client
///applications about a change in a pluggable terminal.
@GUID("6E0887BE-BA1A-492E-BD10-4020EC5E33E0")
interface ITPluggableTerminalEventSink : IUnknown
{
    ///The <b>FireEvent</b> method results in a message that notifies the client application of a change in the
    ///pluggable terminal. For example, if the terminal is no longer available, the <b>event</b> member of the
    ///MSP_EVENT_INFO structure is set to <b>ME_ADDRESS_EVENT</b> and the <b>type</b> member is set to
    ///<b>ADDRESS_TERMINAL_UNAVAILABLE</b>.
    ///Params:
    ///    pMspEventInfo = Pointer to a const cast of the MSP_EVENT_INFO structure.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT FireEvent(const(MSP_EVENT_INFO)* pMspEventInfo);
}

///The <b>ITPluggableTerminalEventSinkRegistration</b> interface registers and unregisters a client application for
///pluggable terminal events. The <b>ITPluggableTerminalEventSinkRegistration</b> interface is created by calling
///<b>QueryInterface</b> on ITTerminal.
@GUID("F7115709-A216-4957-A759-060AB32A90D1")
interface ITPluggableTerminalEventSinkRegistration : IUnknown
{
    ///The <b>RegisterSink</b> method registers the application for pluggable terminal event notification.
    ///Params:
    ///    pEventSink = Pointer to the ITPluggableTerminalEventSink interface.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT RegisterSink(ITPluggableTerminalEventSink pEventSink);
    ///The <b>UnregisterSink</b> method clears event registration for pluggable terminal events.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT UnregisterSink();
}

///The <b>ITMSPAddress</b> interface is implemented by the MSP and represents a media service provider to the TAPI DLL.
///It is not exposed to end-user or server applications. TAPI 3 will call CoCreateInstance on this interface to create
///the MSP object.
@GUID("EE3BD600-3868-11D2-A045-00C04FB6809F")
interface ITMSPAddress : IUnknown
{
    ///The <b>Initialize</b> method is called when the MSP is loaded.
    ///Params:
    ///    hEvent = TAPI 3's handle for this MSP.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform operation. </td> </tr> </table>
    ///    
    HRESULT Initialize(int* hEvent);
    ///The <b>Shutdown</b> method is called when the MSP is unloaded. <b>Shutdown</b> will be called once per address
    ///object.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method not implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT Shutdown();
    ///The <b>CreateMSPCall</b> method creates an MSP Call object. TAPI aggregates this onto the main Call object and
    ///exposes the ITStreamControl interface.
    ///Params:
    ///    hCall = Handle for this MSP.
    ///    dwReserved = Reserved value  will be 0.
    ///    dwMediaType = Indicates media types required for the call.
    ///    pOuterUnknown = The pointer to the IUnknown interface on the TAPI 3 call object. Since the MSP Call object is aggregated in
    ///                    the TAPI 3 call object, it needs to know the outer <b>IUnknown</b>.
    ///    ppStreamControl = Pointer to IUnknown interface pointer of ITStreamControl interface for newly created call.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The MSP failed to initialize. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> <i>pMSPCallback</i>
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>TAPI_E_INVALIDMEDIATYPE</b></dt> </dl> </td> <td width="60%"> <i>dwMediaType</i> is not a valid media
    ///    type. </td> </tr> </table>
    ///    
    HRESULT CreateMSPCall(int* hCall, uint dwReserved, uint dwMediaType, IUnknown pOuterUnknown, 
                          IUnknown* ppStreamControl);
    ///The <b>ShutdownMSPCall</b> method is called when the call object is being destroyed.
    ///Params:
    ///    pStreamControl = Pointer to IUnknown interface for the call's ITStreamControl.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pStreamControl</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pStreamControl</i> parameter does not point to a valid ITStreamControl interface. </td>
    ///    </tr> </table>
    ///    
    HRESULT ShutdownMSPCall(IUnknown pStreamControl);
    ///The <b>ReceiveTSPData</b> method is called by TAPI 3 when the TSP sends asynchronous data to the MSP. If the TSP
    ///sends the LINE_SENDMSPDATA message with the <b>htCall</b> set to <b>NULL</b>, <i>pMSPCall</i> will be
    ///<b>NULL</b>. If the TSP does specify the <b>htCall</b>, <i>pMSPCall</i> will correspond to the call created in
    ///CreateMSPCall.
    ///Params:
    ///    pMSPCall = Pointer to IUnknown interface of the MSP Call object.
    ///    pBuffer = [in, size_is(<i>dwSize</i>)] Pointer to opaque buffer from the TSP.
    ///    dwSize = Size, in bytes, of <i>pBuffer</i>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pMSPCall</i> or
    ///    <i>pBuffer</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>pMSPCall</i> parameter is <b>NULL</b>. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> The <i>pMSPCall</i>
    ///    parameter does not point to a valid interface. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT ReceiveTSPData(IUnknown pMSPCall, char* pBuffer, uint dwSize);
    ///The <b>GetEvent</b> method retrieves event information.
    ///Params:
    ///    pdwSize = A pointer to a DWORD that contains the size, in bytes, of <i>pEventBuffer</i>. On success, <i>pdwSize</i>
    ///              returns the actual number of bytes in <i>pEventBuffer</i>. If <i>pEventBuffer</i> is not large enough, the
    ///              method returns <b>TAPI_E_NOTENOUGHMEMORY</b> and this parameter returns the number, in bytes, required.
    ///    pEventBuffer = [in, out, size_is(*<i>pdwSize</i>)] A pointer to buffer that contains MSP event_info information.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> Method not implemented. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pdwSize</i> or
    ///    <i>pEventBuffer</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>TAPI_E_NOTENOUGHMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pdwSize</i> parameter was not large enough for the buffer. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>TAPI_E_NOEVENT</b></dt> </dl> </td> <td width="60%"> No event has occurred. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetEvent(uint* pdwSize, char* pEventBuffer);
}

@GUID("9F34325B-7E62-11D2-9457-00C04F8EC888")
interface ITTAPIDispatchEventNotification : IDispatch
{
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] The <b>ITDirectoryObjectConference</b> interface provides methods that allow an application
///to set and get conference details. The <b>ITDirectoryObjectConference</b> interface is created by calling
///<b>QueryInterface</b> on ITDirectoryObject.
@GUID("F1029E5D-CB5B-11D0-8D59-00C04FD91AC0")
interface ITDirectoryObjectConference : IDispatch
{
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_Protocol</b> method gets protocol identification.
    ///Params:
    ///    ppProtocol = Pointer to a <b>BSTR</b> containing the protocol identifier.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppProtocol</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_Protocol(BSTR* ppProtocol);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_Originator</b> method gets the originator's user name.
    ///Params:
    ///    ppOriginator = Pointer to a <b>BSTR</b> containing the originator's user name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppOriginator</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_Originator(BSTR* ppOriginator);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>put_Originator</b> method sets the originator's user name.
    ///Params:
    ///    pOriginator = Pointer to a <b>BSTR</b> containing the originator's user name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pOriginator</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_Originator(BSTR pOriginator);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_AdvertisingScope</b> method gets the advertising scope.
    ///Params:
    ///    pAdvertisingScope = Pointer to RND_ADVERTISING_SCOPE enumeration.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pAdvertisingScope</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_AdvertisingScope(RND_ADVERTISING_SCOPE* pAdvertisingScope);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>put_AdvertisingScope</b> method sets the advertising scope.
    ///Params:
    ///    AdvertisingScope = Pointer to RND_ADVERTISING_SCOPE enumeration.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>AdvertisingScope</i>
    ///    parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_AdvertisingScope(RND_ADVERTISING_SCOPE AdvertisingScope);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_Url</b> method gets a URL.
    ///Params:
    ///    ppUrl = Pointer to a <b>BSTR</b> containing the URL.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppUrl</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_Url(BSTR* ppUrl);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>put_Url</b> method sets a URL.
    ///Params:
    ///    pUrl = Pointer to a <b>BSTR</b> containing the URL.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pUrl</i> parameter is not
    ///    a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_Url(BSTR pUrl);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_Description</b> method gets the description of the conference.
    ///Params:
    ///    ppDescription = Pointer to a <b>BSTR</b> containing the description of the conference.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppDescription</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_Description(BSTR* ppDescription);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>put_Description</b> method sets the description of the conference.
    ///Params:
    ///    pDescription = Pointer to a <b>BSTR</b> containing the description of the conference.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDescription</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_Description(BSTR pDescription);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_IsEncrypted</b> method gets whether the conference is encrypted.
    ///Params:
    ///    pfEncrypted = Pointer to whether the conference is encrypted.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pfEncrypted</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_IsEncrypted(short* pfEncrypted);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>put_IsEncrypted</b> method sets whether the conference is encrypted.
    ///Params:
    ///    fEncrypted = Indicator of whether the conference is encrypted.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>fEncrypted</i>
    ///    parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_IsEncrypted(short fEncrypted);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_StartTime</b> method gets the start time of the conference.
    ///Params:
    ///    pDate = Pointer to the conference start time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDate</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_StartTime(double* pDate);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>put_StartTime</b> method sets the start time of the conference.
    ///Params:
    ///    Date = Conference start time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>Date</i> parameter is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_StartTime(double Date);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_StopTime</b> method gets the stop time of the conference. If the end time is
    ///zero, the session is not bounded.
    ///Params:
    ///    pDate = Pointer to the conference stop time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDate</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_StopTime(double* pDate);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>put_StopTime</b> method sets the stop time of the conference. If the end time is
    ///zero, the session is not bounded.
    ///Params:
    ///    Date = Conference stop time.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>Date</i> parameter is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_StopTime(double Date);
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] The <b>ITDirectoryObjectUser</b> interface is the common interface supported by the User
///object. This interface is created by calling <b>QueryInterface</b> on ITDirectoryObject.
@GUID("34621D6F-6CFF-11D1-AFF7-00C04FC31FEE")
interface ITDirectoryObjectUser : IDispatch
{
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_IPPhonePrimary</b> method gets the name of a computer that is the primary IP
    ///phone for the user.
    ///Params:
    ///    ppName = Pointer to the <b>BSTR</b> representation of the user's IP primary phone.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid pointer. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_IPPhonePrimary(BSTR* ppName);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>put_IPPhonePrimary</b> method sets the name of a machine as the primary IP phone
    ///for a user.
    ///Params:
    ///    pName = Pointer to the <b>BSTR</b> representation of the user's IP primary phone.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid pointer. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_IPPhonePrimary(BSTR pName);
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] The <b>IEnumDialableAddrs</b> interface provides COM-standard enumeration methods to discover
///and use the available dialable addresses in a directory. The ITDirectoryObject::EnumerateDialableAddrs method returns
///a pointer to this interface.
@GUID("34621D70-6CFF-11D1-AFF7-00C04FC31FEE")
interface IEnumDialableAddrs : IUnknown
{
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Next</b> method gets the next specified number of elements in the enumeration
    ///sequence.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to a <b>BSTR</b> representation of the address list.
    ///    pcFetched = Pointer to the number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppElements</i> parameter is not a valid
    ///    pointer. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, char* ppElements, uint* pcFetched);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Reset</b> method resets to the beginning of the enumeration sequence.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT Reset();
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Skip</b> method skips over the next specified number of elements in the
    ///enumeration sequence.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Clone</b> method creates another enumerator that contains the same enumeration
    ///state as the current one.
    ///Params:
    ///    ppEnum = Pointer to the new IEnumDialableAddrs object.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumDialableAddrs* ppEnum);
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] The <b>ITDirectoryObject</b> interface is the common interface supported by all objects that
///can be added and deleted by using the ITDirectory interface. Changes made to this object will not take effect on the
///server until the ITDirectory::ModifyDirectoryObject method is called. The following methods create the
///<b>ITDirectoryObject</b> interface: IEnumDirectoryObject::Next ITDirectory::get_DirectoryObjects
///ITRendezvous::CreateDirectoryObject
@GUID("34621D6E-6CFF-11D1-AFF7-00C04FC31FEE")
interface ITDirectoryObject : IDispatch
{
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_ObjectType</b> method gets a DIRECTORY_OBJECT_TYPE descriptor of the object.
    ///Params:
    ///    pObjectType = Pointer to descriptor of directory object type.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid pointer. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_ObjectType(DIRECTORY_OBJECT_TYPE* pObjectType);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_Name</b> method gets the name of the directory object.
    ///Params:
    ///    ppName = Pointer to <b>BSTR</b> representation of directory name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid pointer. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory
    ///    exists to perform the operation. </td> </tr> </table>
    ///    
    HRESULT get_Name(BSTR* ppName);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>put_Name</b> method sets the name of the directory object.
    ///Params:
    ///    pName = Pointer to <b>BSTR</b> representation of directory name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pName</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_Name(BSTR pName);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_DialableAddrs</b> method gets all dialable addresses of a given type from the
    ///directory. This method performs the same function as EnumerateDialableAddrs but is used by scripting languages
    ///such as Visual Basic.
    ///Params:
    ///    dwAddressType = Indicator of address type.
    ///    pVariant = Pointer to a <b>VARIANT</b> containing an ITCollection of <b>BSTR</b> strings, each containing a dialable
    ///               address.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid pointer. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>ERROR</b></dt> </dl> </td> <td width="60%"> Method failed. </td> </tr> </table>
    ///    
    HRESULT get_DialableAddrs(int dwAddressType, VARIANT* pVariant);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>EnumerateDialableAddrs</b> method creates an enumerator of all dialable addresses
    ///of a given type from the directory.
    ///Params:
    ///    dwAddressType = Indicator of the address type.
    ///    ppEnumDialableAddrs = Pointer to the IEnumDialableAddrs interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid pointer. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>ERROR</b></dt> </dl> </td> <td width="60%"> Method failed. </td> </tr> </table>
    ///    
    HRESULT EnumerateDialableAddrs(uint dwAddressType, IEnumDialableAddrs* ppEnumDialableAddrs);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_SecurityDescriptor</b> method gets an <b>IDispatch</b> pointer on a directory
    ///service security descriptor object describing current security permissions. For additional information on
    ///security descriptors, please search the Platform Software Development Kit (SDK) under "IADsSecurityDescriptor".
    ///Params:
    ///    ppSecDes = <b>IDispatch</b> pointer on a directory service security descriptor object.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppSecDes</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td
    ///    width="60%"> Initialization of security descriptor failed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to perform the
    ///    operation. </td> </tr> </table>
    ///    
    HRESULT get_SecurityDescriptor(IDispatch* ppSecDes);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>put_SecurityDescriptor</b> method sets an <b>IDispatch</b> pointer on a directory
    ///service security descriptor object describing current security permissions. For additional information on
    ///security descriptors, please search the Platform Software Development Kit (SDK) under "IADsSecurityDescriptor".
    ///Params:
    ///    pSecDes = <b>IDispatch</b> pointer on a directory service security descriptor object.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pSecDes</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_SecurityDescriptor(IDispatch pSecDes);
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] The <b>IEnumDirectoryObject</b> interface provides COM-standard enumeration methods for the
///ITDirectoryObject interface. The ITDirectory::EnumerateDirectoryObjects method returns a pointer to
///<b>IEnumDirectoryObject</b>.
@GUID("06C9B64A-306D-11D1-9774-00C04FD91AC0")
interface IEnumDirectoryObject : IUnknown
{
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Next</b> method gets the next specified number of elements in the enumeration
    ///sequence.
    ///Params:
    ///    celt = Number of elements requested.
    ///    pVal = Pointer to the ITDirectoryObject interface.
    ///    pcFetched = Pointer to the number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pVal</i> parameter is not a valid pointer.
    ///    </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, char* pVal, uint* pcFetched);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Reset</b> method resets to the beginning of enumeration sequence.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT Reset();
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Skip</b> method skips over the next specified number of elements in the
    ///enumeration sequence.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Clone</b> method creates another enumerator that contains the same enumeration
    ///state as the current one.
    ///Params:
    ///    ppEnum = Pointer to the new IEnumDirectoryObject object.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumDirectoryObject* ppEnum);
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] The <b>ITILSConfig</b> interface allows configuration of the ILS directory. This interface is
///available only on Directory objects that return DT_ILS from ITDirectory::get_DirectoryType. The <b>ITILSConfig</b>
///interface is created by calling <b>QueryInterface</b> on ITDirectory.
@GUID("34621D72-6CFF-11D1-AFF7-00C04FC31FEE")
interface ITILSConfig : IDispatch
{
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_Port</b> method gets the port number used to connect to the server of a given
    ///ILS directory.
    ///Params:
    ///    pPort = Pointer to receive the port number used in the connection.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Invalid pointer. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_Port(int* pPort);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>put_Port</b> method sets the port number used to connect to the server of a
    ///specified ILS directory.
    ///Params:
    ///    Port = The port number that will be used to connect to the server. This can be any port number in the range of
    ///           16-bit unsigned integers.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>Port</i> parameter is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>RND_ALREADY_CONNECTED</b></dt> </dl> </td> <td
    ///    width="60%"> A successful connection has been made. Port cannot be reset. </td> </tr> </table>
    ///    
    HRESULT put_Port(int Port);
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] The <b>ITDirectory</b> interface is exposed by the Directory object, which corresponds to a
///particular directory. This interface provides methods that get and set directory information, and provide access to a
///particular directory object, such a conference or user. The ITRendezvous::CreateDirectory and IEnumDirectory::Next
///methods create the <b>ITDirectory</b> interface.
@GUID("34621D6C-6CFF-11D1-AFF7-00C04FC31FEE")
interface ITDirectory : IDispatch
{
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_DirectoryType</b> method gets DIRECTORY_TYPE indicator of the type of the
    ///directory.
    ///Params:
    ///    pDirectoryType = Pointer to type of the directory.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDirectoryType</i>
    ///    parameter is not a valid pointer. </td> </tr> </table>
    ///    
    HRESULT get_DirectoryType(DIRECTORY_TYPE* pDirectoryType);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_DisplayName</b> method gets displayable name for directory.
    ///Params:
    ///    pName = Pointer to a <b>BSTR</b> representation of the directory name.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pName</i> parameter is
    ///    not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_DisplayName(BSTR* pName);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_IsDynamic</b> method gets an indicator of whether the object on the server
    ///needs to be refreshed.
    ///Params:
    ///    pfDynamic = Pointer to a Boolean <b>VARIANT</b>; VARIANT_TRUE if server needs to be refreshed and VARIANT_FALSE if it
    ///                does not.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pfDynamic</i> parameter
    ///    is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_IsDynamic(short* pfDynamic);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_DefaultObjectTTL</b> method gets the default time to live (TTL) value, in
    ///seconds, for objects created. Only applies to dynamic servers.
    ///Params:
    ///    pTTL = Pointer to TTL value, in seconds.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pTTL</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT get_DefaultObjectTTL(int* pTTL);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>put_DefaultObjectTTL</b> method sets the default time to live (TTL) value, in
    ///seconds, for objects created. Only applies to dynamic servers. The minimum value is 300 seconds.
    ///Params:
    ///    TTL = TTL value, in seconds.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>TTL</i> parameter is not
    ///    valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT put_DefaultObjectTTL(int TTL);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>EnableAutoRefresh</b> method enables auto refresh for directory objects created
    ///after it is called. Only applies to dynamic servers.
    ///Params:
    ///    fEnable = Set to VARIANT_TRUE if auto refresh is to be enabled.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>fEnable</i> parameter
    ///    is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> Unspecified error. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not yet implemented. </td> </tr>
    ///    </table>
    ///    
    HRESULT EnableAutoRefresh(short fEnable);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Connect</b> method establishes a connection to the directory server.
    ///Params:
    ///    fSecure = Boolean indicator of whether to use SSL connection.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>RND_ALREADY_CONNECTED</b></dt> </dl> </td> <td width="60%"> A successful
    ///    connection has already been made. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>RND_NULL_SERVER_NAME</b></dt>
    ///    </dl> </td> <td width="60%"> The server name is <b>NULL</b>, probably because ITConferenceBlob::Init has not
    ///    been run or did not succeed. </td> </tr> </table>
    ///    
    HRESULT Connect(short fSecure);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Bind</b> method binds to the server.
    ///Params:
    ///    pDomainName = Pointer to a <b>BSTR</b> containing the user's domain name.
    ///    pUserName = Pointer to a <b>BSTR</b> containing the user's name.
    ///    pPassword = Pointer to a <b>BSTR</b> containing the user's password.
    ///    lFlags = RENDBIND flags indicator of whether all parameters must be validated or can take a default.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDomainName</i>,
    ///    <i>pUserName</i>, or <i>pPassword</i> parameter is not a valid pointer. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> A password is required but was not supplied,
    ///    the domain and user are not supplied, or the domain was supplied but the user was not. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>RND_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The ITDirectory::Connect
    ///    method has not been invoked or did not succeed. </td> </tr> </table>
    ///    
    HRESULT Bind(BSTR pDomainName, BSTR pUserName, BSTR pPassword, int lFlags);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>AddDirectoryObject</b> method adds an ITDirectoryObject object to the server. This
    ///may be a directory or a user machine mapping.
    ///Params:
    ///    pDirectoryObject = The object that will be added into the directory.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDirectoryObject</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>RND_NOT_CONNECTED</b></dt>
    ///    </dl> </td> <td width="60%"> The ITDirectory::Connect method has not been invoked or did not succeed. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not
    ///    implemented. </td> </tr> </table>
    ///    
    HRESULT AddDirectoryObject(ITDirectoryObject pDirectoryObject);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>ModifyDirectoryObject</b> method commits directory modifications to the server.
    ///Params:
    ///    pDirectoryObject = Pointer to ITDirectoryObject modified.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDirectoryObject</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>RND_NOT_CONNECTED</b></dt>
    ///    </dl> </td> <td width="60%"> The ITDirectory::Connect method has not been invoked or did not succeed. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not
    ///    implemented. </td> </tr> </table>
    ///    
    HRESULT ModifyDirectoryObject(ITDirectoryObject pDirectoryObject);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>RefreshDirectoryObject</b> method refreshes the time to live (TTL) for an object
    ///on the server. Only applies to dynamic servers.
    ///Params:
    ///    pDirectoryObject = Pointer to ITDirectoryObject to be refreshed.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDirectoryObject</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>RND_NOT_CONNECTED</b></dt>
    ///    </dl> </td> <td width="60%"> The ITDirectory::Connect method has not been invoked or did not succeed. </td>
    ///    </tr> </table>
    ///    
    HRESULT RefreshDirectoryObject(ITDirectoryObject pDirectoryObject);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>DeleteDirectoryObject</b> method deletes an object from the server.
    ///Params:
    ///    pDirectoryObject = Pointer to ITDirectoryObject that will be deleted from the directory.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>pDirectoryObject</i>
    ///    parameter is not a valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>RND_NOT_CONNECTED</b></dt>
    ///    </dl> </td> <td width="60%"> The ITDirectory::Connect method has not been invoked or did not succeed. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not
    ///    implemented. </td> </tr> </table>
    ///    
    HRESULT DeleteDirectoryObject(ITDirectoryObject pDirectoryObject);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_DirectoryObjects</b> method gets the collection of objects in a given
    ///directory that matches certain criteria. This method performs the same function as EnumerateDirectoryObjects but
    ///is used by Visual Basic and other scripting languages.
    ///Params:
    ///    DirectoryObjectType = The DIRECTORY_OBJECT_TYPE criteria for object desired.
    ///    pName = Pointer to a <b>BSTR</b> containing the full or partial name of the object. The "*" wildcard is supported.
    ///    pVariant = Pointer to a <b>VARIANT</b> that receives an ITCollection of ITDirectoryObject objects in the server that
    ///               match the description.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>RND_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The ITDirectory::Connect
    ///    method has not been invoked or did not succeed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not implemented. </td> </tr> </table>
    ///    
    HRESULT get_DirectoryObjects(DIRECTORY_OBJECT_TYPE DirectoryObjectType, BSTR pName, VARIANT* pVariant);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>EnumerateDirectoryObjects</b> method creates an enumeration of directory objects
    ///of a given type and name.
    ///Params:
    ///    DirectoryObjectType = The DIRECTORY_OBJECT_TYPE criteria for object desired.
    ///    pName = Pointer to a <b>BSTR</b> containing the full or partial name of the object. The "*" wildcard is supported.
    ///    ppEnumObject = Pointer to receive IEnumDirectoryObject interface pointer for the enumerator of matching objects.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>RND_NOT_CONNECTED</b></dt> </dl> </td> <td width="60%"> The ITDirectory::Connect
    ///    method has not been invoked or did not succeed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_NOTIMPL</b></dt> </dl> </td> <td width="60%"> This method is not implemented. </td> </tr> </table>
    ///    
    HRESULT EnumerateDirectoryObjects(DIRECTORY_OBJECT_TYPE DirectoryObjectType, BSTR pName, 
                                      IEnumDirectoryObject* ppEnumObject);
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] The <b>IEnumDirectory</b> interface provides COM-standard enumeration methods for the
///ITDirectory interface. The ITRendezvous::EnumerateDefaultDirectories method returns a pointer to
///<b>IEnumDirectory</b>.
@GUID("34621D6D-6CFF-11D1-AFF7-00C04FC31FEE")
interface IEnumDirectory : IUnknown
{
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Next</b> method gets the next specified number of elements in the enumeration
    ///sequence.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppElements = Pointer to the ITDirectory interface.
    ///    pcFetched = Pointer to the number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppElements</i> parameter is not a valid
    ///    pointer. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, char* ppElements, uint* pcFetched);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Reset</b> method resets to the beginning of the enumeration sequence.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT Reset();
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Skip</b> method skips over the next specified number of elements in the
    ///enumeration sequence.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Clone</b> method creates another enumerator that contains the same enumeration
    ///state as the current one.
    ///Params:
    ///    ppEnum = Pointer to the new IEnumDirectory object.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumDirectory* ppEnum);
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] The <b>ITRendezvous</b> interface is the main interface for the Rendezvous control. An
///application calls the COM CoCreateInstance function on this interface to create the Rendezvous object.
@GUID("34621D6B-6CFF-11D1-AFF7-00C04FC31FEE")
interface ITRendezvous : IDispatch
{
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_DefaultDirectories</b> method enumerates all configured default directories.
    ///This method is similar to EnumerateDefaultDirectories but is provided for use by Visual Basic and other scripting
    ///languages.
    ///Params:
    ///    pVariant = Pointer to a <b>VARIANT</b> that will receive an ITCollection of ITDirectory interface pointers.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    create a collection. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> Pointer is invalid. </td> </tr> </table>
    ///    
    HRESULT get_DefaultDirectories(VARIANT* pVariant);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>EnumerateDefaultDirectories</b> method enumerates all configured default
    ///directories. This method is similar to get_DefaultDirectories but is designed for C/C++.
    ///Params:
    ///    ppEnumDirectory = Pointer to receive IEnumDirectory enumerator listing default directories.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Insufficient memory exists to
    ///    perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td
    ///    width="60%"> Pointer is invalid. </td> </tr> </table>
    ///    
    HRESULT EnumerateDefaultDirectories(IEnumDirectory* ppEnumDirectory);
    HRESULT CreateDirectoryA(DIRECTORY_TYPE DirectoryType, BSTR pName, ITDirectory* ppDir);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>CreateDirectoryObject</b> method creates a new ITDirectoryObject object.
    ///Params:
    ///    DirectoryObjectType = The type of the object. See DIRECTORY_OBJECT_TYPE.
    ///    pName = Pointer to a <b>BSTR</b> containing the name of the object.
    ///    ppDirectoryObject = Pointer to receive the interface pointer for the newly created ITDirectoryObject object.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The <i>DirectoryObjectType</i>
    ///    parameter is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> Pointer is invalid. </td> </tr> </table>
    ///    
    HRESULT CreateDirectoryObject(DIRECTORY_OBJECT_TYPE DirectoryObjectType, BSTR pName, 
                                  ITDirectoryObject* ppDirectoryObject);
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] The <b>IMcastScope</b> interface is obtained by calling
///IMcastAddressAllocation::EnumerateScopes or IMcastAddressAllocation::get_Scopes. It encapsulates all the properties
///of a multicast scope and provides methods to get information about the scope. This is a "read-only" interface in that
///it has "get" methods but no "put" methods.
@GUID("DF0DAEF4-A289-11D1-8697-006008B0E5D2")
interface IMcastScope : IDispatch
{
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_ScopeID</b> method obtains an identifier for the scope of multicast addresses.
    ///The scope ID and server ID are needed to select this scope in subsequent calls to
    ///IMcastAddressAllocation::RequestAddress, IMcastAddressAllocation::RenewAddress, or
    ///IMcastAddressAllocation::ReleaseAddress.
    ///Params:
    ///    pID = Pointer to a <b>LONG</b> that will receive the scope ID of this scope, which is the ID that was assigned to
    ///          this scope when it was configured on the multicast server.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_ScopeID(int* pID);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_ServerID</b> method obtains the server ID associated with this scope. The
    ///scope ID and server ID are needed to select this scope in subsequent calls to
    ///IMcastAddressAllocation::RequestAddress, IMcastAddressAllocation::RenewAddress, or
    ///IMcastAddressAllocation::ReleaseAddress.
    ///Params:
    ///    pID = Pointer to a <b>LONG</b> that will receive the server ID of this scope, which is the ID that was assigned to
    ///          the multicast address allocation server that published this scope at the time that the server was configured.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_ServerID(int* pID);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_InterfaceID</b> method obtains an interface identifier of this scope, which
    ///identifies the interface on which the server that published this scope resides. This is normally the network
    ///address of the interface.
    ///Params:
    ///    pID = Pointer to a <b>LONG</b> that will receive the server ID of this scope, which is the ID that was assigned to
    ///          the multicast address allocation server that published this scope at the time that the server was configured.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_InterfaceID(int* pID);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_ScopeDescription</b> method obtains a textual description associated with this
    ///scope. The description is used only for clarifying the purpose or meaning of a scope and is not needed for any
    ///subsequent calls.
    ///Params:
    ///    ppDescription = Pointer to a <b>BSTR</b> that will receive a description of this scope. The description was established when
    ///                    this scope was configured on the multicast server.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Not enough memory exists to allocate the string. </td> </tr> </table>
    ///    
    HRESULT get_ScopeDescription(BSTR* ppDescription);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_TTL</b> method obtains the time to live value for the multicast scope.
    ///Params:
    ///    pTTL = Pointer to a time to live value for multicast scope.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_TTL(int* pTTL);
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] The <b>IMcastLeaseInfo</b> interface exposes methods that can get or set information
///concerning a multicast address allocation. The IMcastLease object is created by calling
///IMcastAddressAllocation::CreateLeaseInfo.
@GUID("DF0DAEFD-A289-11D1-8697-006008B0E5D2")
interface IMcastLeaseInfo : IDispatch
{
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_RequestID</b> method obtains the request ID for a lease. The primary purpose
    ///of this method is to allow you to save the request ID after your application exits, so that you can call
    ///IMcastAddressAllocation::CreateLeaseInfo to re-create the lease information object during a subsequent run. This
    ///allows you to renew or release a lease after the instance of your program that originally requested the lease has
    ///exited.
    ///Params:
    ///    ppRequestID = Pointer to a <b>BSTR</b> that will receive the request ID for this lease. The request ID uniquely identifies
    ///                  this lease request to the server.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_FAIL</b></dt> </dl> </td> <td width="60%"> The lease information object
    ///    contains an invalid request ID. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td>
    ///    <td width="60%"> The caller passed in an invalid pointer argument. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory to allocate the <b>BSTR</b>.
    ///    </td> </tr> </table>
    ///    
    HRESULT get_RequestID(BSTR* ppRequestID);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_LeaseStartTime</b> method obtains the start time of the lease.
    ///Params:
    ///    pTime = Pointer to a <b>DATE</b> that will receive the start time of the lease.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Format conversion failed for the start time or stop time. </td> </tr> </table>
    ///    
    HRESULT get_LeaseStartTime(double* pTime);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>put_LeaseStartTime</b> method sets the start time of the lease. This method, along
    ///with put_LeaseStopTime, allows renewal of a lease without calling IMcastAddressAllocation::CreateLeaseInfo.
    ///Params:
    ///    time = A <b>DATE</b> specifying the start time of the lease.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Format conversion failed for
    ///    the start time or stop time. </td> </tr> </table>
    ///    
    HRESULT put_LeaseStartTime(double time);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_LeaseStopTime</b> method obtains the stop time of the lease.
    ///Params:
    ///    pTime = Pointer to a <b>DATE</b> that will receive the stop time of the lease.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Format conversion failed for the start time or stop time. </td> </tr> </table>
    ///    
    HRESULT get_LeaseStopTime(double* pTime);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>put_LeaseStopTime</b> method sets the stop time of the lease. This method, along
    ///with put_LeaseStartTime, allows you to renew a lease without calling IMcastAddressAllocation::CreateLeaseInfo.
    ///Params:
    ///    time = A <b>DATE</b> specifying the stop time of the lease.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Format conversion failed for
    ///    the start time or stop time. </td> </tr> </table>
    ///    
    HRESULT put_LeaseStopTime(double time);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_AddressCount</b> method obtains the number of addresses requested or granted
    ///in this lease.
    ///Params:
    ///    pCount = Pointer to a <b>LONG</b> that will receive the number of addresses requested or granted in this lease.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> </table>
    ///    
    HRESULT get_AddressCount(int* pCount);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_ServerAddress</b> method obtains a string representing the address of the
    ///multicast server granting this lease.
    ///Params:
    ///    ppAddress = Pointer to a <b>BSTR</b> that will receive a string representation of the address of the server granting this
    ///                request or renewal.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Server address unspecified. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in
    ///    an invalid pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td>
    ///    <td width="60%"> Not enough memory exists to allocate the string. </td> </tr> </table>
    ///    
    HRESULT get_ServerAddress(BSTR* ppAddress);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_TTL</b> method obtains the time to live (TTL) value associated with this
    ///lease.
    ///Params:
    ///    pTTL = Pointer to a <b>LONG</b> that will receive the TTL value associated with this lease.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    There is no TTL associated with this lease. </td> </tr> </table>
    ///    
    HRESULT get_TTL(int* pTTL);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_Addresses</b> method obtains the collection of multicast addresses that are
    ///the subject of this lease or lease request. This method is primarily for Visual Basic and other scripting
    ///languages; C++ programmers use EnumerateAddresses instead.
    ///Params:
    ///    pVariant = Pointer to a <b>VARIANT</b> receiving an ITCollection of <b>BSTR</b> strings. Each string is an IP version 4
    ///               address in dotted quad notation (for example, 10.111.222.111).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Not enough memory to allocate the collection. </td> </tr> </table>
    ///    
    HRESULT get_Addresses(VARIANT* pVariant);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>EnumerateAddresses</b> method obtains the collection of multicast addresses that
    ///are the subject of this lease or lease request. This method is primarily for C++ programmers. Visual Basic and
    ///other scripting languages use get_Addresses instead.
    ///Params:
    ///    ppEnumAddresses = Returns a pointer to a new IEnumBstr object. <b>IEnumBstr</b> is a standard enumerator interface that
    ///                      enumerates BSTR strings. Each string is an IP version 4 address in dotted quad notation (for example,
    ///                      10.111.222.111).
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Not enough memory to allocate the enumerator. </td> </tr> </table>
    ///    
    HRESULT EnumerateAddresses(IEnumBstr* ppEnumAddresses);
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] The <b>IEnumMcastScope</b> interface provides COM-standard enumeration methods for the
///IMcastScope interface. The IMcastAddressAllocation::EnumerateScopes method returns a pointer to
///<b>IEnumMcastScope</b>.
@GUID("DF0DAF09-A289-11D1-8697-006008B0E5D2")
interface IEnumMcastScope : IUnknown
{
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Next</b> method gets the next specified number of elements in the enumeration
    ///sequence.
    ///Params:
    ///    celt = Number of elements requested.
    ///    ppScopes = Pointer to the IMcastScope interface.
    ///    pceltFetched = Pointer to the number of elements actually supplied. May be <b>NULL</b> if <i>celt</i> is one.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method returned <i>celt</i> number of
    ///    elements. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> Number
    ///    of elements remaining was less than <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppScopes</i> parameter is not a valid pointer.
    ///    </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, IMcastScope* ppScopes, uint* pceltFetched);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Reset</b> method resets to the beginning of enumeration sequence.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr>
    ///    </table>
    ///    
    HRESULT Reset();
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Skip</b> method skips over the next specified number of elements in the
    ///enumeration sequence.
    ///Params:
    ///    celt = Number of elements to skip.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Number of elements skipped was
    ///    <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    Number of elements skipped was not <i>celt</i>. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>Clone</b> method creates another enumerator that contains the same enumeration
    ///state as the current one.
    ///Params:
    ///    ppEnum = Pointer to the new IEnumMcastScope object.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The <i>ppEnum</i> parameter is not a
    ///    valid pointer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Insufficient memory exists to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Failed for unknown reasons. </td> </tr> </table>
    ///    
    HRESULT Clone(IEnumMcastScope* ppEnum);
}

///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
///similar functionality.] <b>IMcastAddressAllocation</b> is the main interface for multicast address allocation. An
///application calls the COM CoCreateInstance function on this interface to create the multicast client interface
///object.
@GUID("DF0DAEF1-A289-11D1-8697-006008B0E5D2")
interface IMcastAddressAllocation : IDispatch
{
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>get_Scopes</b> method creates a collection of IMcast scopes available. This method
    ///is similar to EnumerateScopes, but is used by scripting languages such as Visual Basic.
    ///Params:
    ///    pVariant = Pointer to a <b>VARIANT</b> receiving an ITCollection of IMcastScope interface pointers.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    There are no scopes available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Not enough memory exists to create the required objects. </td> </tr> </table>
    ///    
    HRESULT get_Scopes(VARIANT* pVariant);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>EnumerateScopes</b> method creates an enumeration of multicast scopes available.
    ///This method is primarily for C++ programmers. Visual Basic and other scripting languages use get_Scopes instead.
    ///Params:
    ///    ppEnumMcastScope = Returns a pointer to a new IEnumMcastScope object.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%">
    ///    There are no scopes available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> Not enough memory exists to create the required objects. </td> </tr> </table>
    ///    
    HRESULT EnumerateScopes(IEnumMcastScope* ppEnumMcastScope);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>RequestAddress</b> method obtains a new lease for one or more multicast addresses.
    ///The EnumerateScopes or get_Scopes method must be called first.
    ///Params:
    ///    pScope = Identifies the multicast scope from which the application needs an address. The application first calls
    ///             get_Scopes or EnumerateScopes to obtain a list of available scopes.
    ///    LeaseStartTime = Requested time for the lease on these addresses to start. The start time that is actually granted may be
    ///                     different.
    ///    LeaseStopTime = Requested time for the lease on these addresses to stop. The stop time that is actually granted may be
    ///                    different.
    ///    NumAddresses = The number of addresses requested. Fewer addresses may actually be granted.
    ///    ppLeaseResponse = Pointer to an interface pointer that will be set to point to a new IMcastLeaseInfo object. This interface can
    ///                      then be used to discover the actual attributes of the granted lease. See IMcastScope for more information.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Not enough memory exists to create the required objects. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> Requested stop time is prior to requested stop
    ///    time. </td> </tr> </table>
    ///    
    HRESULT RequestAddress(IMcastScope pScope, double LeaseStartTime, double LeaseStopTime, int NumAddresses, 
                           IMcastLeaseInfo* ppLeaseResponse);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>RenewAddress</b> method renews an address lease. Call CreateLeaseInfo to specify
    ///the parameters of the renewal request, and then call this method to make the request.
    ///Params:
    ///    lReserved = Reserved parameter. An application should pass in a value of 0.
    ///    pRenewRequest = Pointer to an IMcastLeaseInfo object specifying the attributes of the requested renewal, such as which
    ///                    address(es) to renew. This is obtained by calling CreateLeaseInfo.
    ///    ppRenewResponse = Pointer to an interface pointer that will be set to point to a new IMcastLeaseInfo object. This interface can
    ///                      then be used to discover the attributes of the renewed lease. See IMcastScope for more information.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> Requested stop time is prior to the requested stop time. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory to create the required objects.
    ///    </td> </tr> </table>
    ///    
    HRESULT RenewAddress(int lReserved, IMcastLeaseInfo pRenewRequest, IMcastLeaseInfo* ppRenewResponse);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>ReleaseAddress</b> method releases a lease that was obtained previously.
    ///Params:
    ///    pReleaseRequest = Pointer to the lease information interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Not enough memory exists to make the request. </td> </tr> </table>
    ///    
    HRESULT ReleaseAddress(IMcastLeaseInfo pReleaseRequest);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>CreateLeaseInfo</b> method creates a lease information object for a subsequent
    ///call to RenewAddress or ReleaseAddress.
    ///Params:
    ///    LeaseStartTime = The start time of the lease.
    ///    LeaseStopTime = The stop time of the lease.
    ///    dwNumAddresses = The number of addresses associated with the lease.
    ///    ppAddresses = An array of <b>LPWSTR</b> pointers of size <i>dwNumAddresses</i>. Each <b>LPWSTR</b> is an IP version 4
    ///                  address in dotted quad notation (for example, 10.111.222.111).
    ///    pRequestID = An <b>LPWSTR</b> specifying the request ID for the original request. This is obtained by calling
    ///                 IMcastLeaseInfo::get_RequestID on the lease information object corresponding to the original request. The
    ///                 request ID should be saved in persistent storage between executions of the application program. If you are
    ///                 renewing or releasing a lease that was requested during the same run of the application, you have no reason
    ///                 to use <b>CreateLeaseInfo</b>; just pass the existing IMcastLeaseInfo pointer to RenewAddress or
    ///                 ReleaseAddress.
    ///    pServerAddress = Specifies server address.
    ///    ppReleaseRequest = Pointer to the IMcastLeaseInfo interface created.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Not enough memory exists to create the required objects. </td> </tr> </table>
    ///    
    HRESULT CreateLeaseInfo(double LeaseStartTime, double LeaseStopTime, uint dwNumAddresses, ushort** ppAddresses, 
                            const(wchar)* pRequestID, const(wchar)* pServerAddress, 
                            IMcastLeaseInfo* ppReleaseRequest);
    ///<p class="CCE_Message">[Rendezvous IP Telephony Conferencing controls and interfaces are not available for use in
    ///Windows Vista, Windows Server 2008, and subsequent versions of the operating system. The RTC Client API provides
    ///similar functionality.] The <b>CreateLeaseInfoFromVariant</b> method creates a lease information object for a
    ///subsequent call to RenewAddress or ReleaseAddress. This method is similar to CreateLeaseInfo but is used by
    ///Automation client languages such as Visual Basic.
    ///Params:
    ///    LeaseStartTime = The start time of the lease.
    ///    LeaseStopTime = The stop time of the lease.
    ///    vAddresses = A <b>VARIANT</b> containing a SAFEARRAY of <b>BSTR</b> strings. Each <b>BSTR</b> is an IP version 4 address
    ///                 in dotted quad notation (for example, 10.111.222.111).
    ///    pRequestID = Pointer to a <b>BSTR</b> specifying the request ID for the original request. This is obtained by calling
    ///                 IMcastLeaseInfo::get_RequestID on the lease information object corresponding to the original request. The
    ///                 request ID should be saved in persistent storage between executions of the application program. If you are
    ///                 renewing or releasing a lease that was requested during the same run of the application, you have no reason
    ///                 to use CreateLeaseInfo; just pass the existing IMcastLeaseInfo pointer to RenewAddress or ReleaseAddress.
    ///    pServerAddress = Pointer to a <b>BSTR</b> specifying the server address.
    ///    ppReleaseRequest = Pointer to the IMcastLeaseInfo interface created.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Method succeeded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> The caller passed in an invalid
    ///    pointer argument. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> Not enough memory exists to create the required objects. </td> </tr> </table>
    ///    
    HRESULT CreateLeaseInfoFromVariant(double LeaseStartTime, double LeaseStopTime, VARIANT vAddresses, 
                                       BSTR pRequestID, BSTR pServerAddress, IMcastLeaseInfo* ppReleaseRequest);
}


// GUIDs

const GUID CLSID_DispatchMapper         = GUIDOF!DispatchMapper;
const GUID CLSID_McastAddressAllocation = GUIDOF!McastAddressAllocation;
const GUID CLSID_Rendezvous             = GUIDOF!Rendezvous;
const GUID CLSID_RequestMakeCall        = GUIDOF!RequestMakeCall;
const GUID CLSID_TAPI                   = GUIDOF!TAPI;

const GUID IID_IEnumACDGroup                            = GUIDOF!IEnumACDGroup;
const GUID IID_IEnumAddress                             = GUIDOF!IEnumAddress;
const GUID IID_IEnumAgent                               = GUIDOF!IEnumAgent;
const GUID IID_IEnumAgentHandler                        = GUIDOF!IEnumAgentHandler;
const GUID IID_IEnumAgentSession                        = GUIDOF!IEnumAgentSession;
const GUID IID_IEnumBstr                                = GUIDOF!IEnumBstr;
const GUID IID_IEnumCall                                = GUIDOF!IEnumCall;
const GUID IID_IEnumCallHub                             = GUIDOF!IEnumCallHub;
const GUID IID_IEnumCallingCard                         = GUIDOF!IEnumCallingCard;
const GUID IID_IEnumDialableAddrs                       = GUIDOF!IEnumDialableAddrs;
const GUID IID_IEnumDirectory                           = GUIDOF!IEnumDirectory;
const GUID IID_IEnumDirectoryObject                     = GUIDOF!IEnumDirectoryObject;
const GUID IID_IEnumLocation                            = GUIDOF!IEnumLocation;
const GUID IID_IEnumMcastScope                          = GUIDOF!IEnumMcastScope;
const GUID IID_IEnumPhone                               = GUIDOF!IEnumPhone;
const GUID IID_IEnumPluggableSuperclassInfo             = GUIDOF!IEnumPluggableSuperclassInfo;
const GUID IID_IEnumPluggableTerminalClassInfo          = GUIDOF!IEnumPluggableTerminalClassInfo;
const GUID IID_IEnumQueue                               = GUIDOF!IEnumQueue;
const GUID IID_IEnumStream                              = GUIDOF!IEnumStream;
const GUID IID_IEnumSubStream                           = GUIDOF!IEnumSubStream;
const GUID IID_IEnumTerminal                            = GUIDOF!IEnumTerminal;
const GUID IID_IEnumTerminalClass                       = GUIDOF!IEnumTerminalClass;
const GUID IID_IMcastAddressAllocation                  = GUIDOF!IMcastAddressAllocation;
const GUID IID_IMcastLeaseInfo                          = GUIDOF!IMcastLeaseInfo;
const GUID IID_IMcastScope                              = GUIDOF!IMcastScope;
const GUID IID_ITACDGroup                               = GUIDOF!ITACDGroup;
const GUID IID_ITACDGroupEvent                          = GUIDOF!ITACDGroupEvent;
const GUID IID_ITAMMediaFormat                          = GUIDOF!ITAMMediaFormat;
const GUID IID_ITASRTerminalEvent                       = GUIDOF!ITASRTerminalEvent;
const GUID IID_ITAddress                                = GUIDOF!ITAddress;
const GUID IID_ITAddress2                               = GUIDOF!ITAddress2;
const GUID IID_ITAddressCapabilities                    = GUIDOF!ITAddressCapabilities;
const GUID IID_ITAddressDeviceSpecificEvent             = GUIDOF!ITAddressDeviceSpecificEvent;
const GUID IID_ITAddressEvent                           = GUIDOF!ITAddressEvent;
const GUID IID_ITAddressTranslation                     = GUIDOF!ITAddressTranslation;
const GUID IID_ITAddressTranslationInfo                 = GUIDOF!ITAddressTranslationInfo;
const GUID IID_ITAgent                                  = GUIDOF!ITAgent;
const GUID IID_ITAgentEvent                             = GUIDOF!ITAgentEvent;
const GUID IID_ITAgentHandler                           = GUIDOF!ITAgentHandler;
const GUID IID_ITAgentHandlerEvent                      = GUIDOF!ITAgentHandlerEvent;
const GUID IID_ITAgentSession                           = GUIDOF!ITAgentSession;
const GUID IID_ITAgentSessionEvent                      = GUIDOF!ITAgentSessionEvent;
const GUID IID_ITAllocatorProperties                    = GUIDOF!ITAllocatorProperties;
const GUID IID_ITAutomatedPhoneControl                  = GUIDOF!ITAutomatedPhoneControl;
const GUID IID_ITBasicAudioTerminal                     = GUIDOF!ITBasicAudioTerminal;
const GUID IID_ITBasicCallControl                       = GUIDOF!ITBasicCallControl;
const GUID IID_ITBasicCallControl2                      = GUIDOF!ITBasicCallControl2;
const GUID IID_ITCallHub                                = GUIDOF!ITCallHub;
const GUID IID_ITCallHubEvent                           = GUIDOF!ITCallHubEvent;
const GUID IID_ITCallInfo                               = GUIDOF!ITCallInfo;
const GUID IID_ITCallInfo2                              = GUIDOF!ITCallInfo2;
const GUID IID_ITCallInfoChangeEvent                    = GUIDOF!ITCallInfoChangeEvent;
const GUID IID_ITCallMediaEvent                         = GUIDOF!ITCallMediaEvent;
const GUID IID_ITCallNotificationEvent                  = GUIDOF!ITCallNotificationEvent;
const GUID IID_ITCallStateEvent                         = GUIDOF!ITCallStateEvent;
const GUID IID_ITCallingCard                            = GUIDOF!ITCallingCard;
const GUID IID_ITCollection                             = GUIDOF!ITCollection;
const GUID IID_ITCollection2                            = GUIDOF!ITCollection2;
const GUID IID_ITCustomTone                             = GUIDOF!ITCustomTone;
const GUID IID_ITDetectTone                             = GUIDOF!ITDetectTone;
const GUID IID_ITDigitDetectionEvent                    = GUIDOF!ITDigitDetectionEvent;
const GUID IID_ITDigitGenerationEvent                   = GUIDOF!ITDigitGenerationEvent;
const GUID IID_ITDigitsGatheredEvent                    = GUIDOF!ITDigitsGatheredEvent;
const GUID IID_ITDirectory                              = GUIDOF!ITDirectory;
const GUID IID_ITDirectoryObject                        = GUIDOF!ITDirectoryObject;
const GUID IID_ITDirectoryObjectConference              = GUIDOF!ITDirectoryObjectConference;
const GUID IID_ITDirectoryObjectUser                    = GUIDOF!ITDirectoryObjectUser;
const GUID IID_ITDispatchMapper                         = GUIDOF!ITDispatchMapper;
const GUID IID_ITFileTerminalEvent                      = GUIDOF!ITFileTerminalEvent;
const GUID IID_ITFileTrack                              = GUIDOF!ITFileTrack;
const GUID IID_ITForwardInformation                     = GUIDOF!ITForwardInformation;
const GUID IID_ITForwardInformation2                    = GUIDOF!ITForwardInformation2;
const GUID IID_ITILSConfig                              = GUIDOF!ITILSConfig;
const GUID IID_ITLegacyAddressMediaControl              = GUIDOF!ITLegacyAddressMediaControl;
const GUID IID_ITLegacyAddressMediaControl2             = GUIDOF!ITLegacyAddressMediaControl2;
const GUID IID_ITLegacyCallMediaControl                 = GUIDOF!ITLegacyCallMediaControl;
const GUID IID_ITLegacyCallMediaControl2                = GUIDOF!ITLegacyCallMediaControl2;
const GUID IID_ITLegacyWaveSupport                      = GUIDOF!ITLegacyWaveSupport;
const GUID IID_ITLocationInfo                           = GUIDOF!ITLocationInfo;
const GUID IID_ITMSPAddress                             = GUIDOF!ITMSPAddress;
const GUID IID_ITMediaControl                           = GUIDOF!ITMediaControl;
const GUID IID_ITMediaPlayback                          = GUIDOF!ITMediaPlayback;
const GUID IID_ITMediaRecord                            = GUIDOF!ITMediaRecord;
const GUID IID_ITMediaSupport                           = GUIDOF!ITMediaSupport;
const GUID IID_ITMultiTrackTerminal                     = GUIDOF!ITMultiTrackTerminal;
const GUID IID_ITPhone                                  = GUIDOF!ITPhone;
const GUID IID_ITPhoneDeviceSpecificEvent               = GUIDOF!ITPhoneDeviceSpecificEvent;
const GUID IID_ITPhoneEvent                             = GUIDOF!ITPhoneEvent;
const GUID IID_ITPluggableTerminalClassInfo             = GUIDOF!ITPluggableTerminalClassInfo;
const GUID IID_ITPluggableTerminalEventSink             = GUIDOF!ITPluggableTerminalEventSink;
const GUID IID_ITPluggableTerminalEventSinkRegistration = GUIDOF!ITPluggableTerminalEventSinkRegistration;
const GUID IID_ITPluggableTerminalSuperclassInfo        = GUIDOF!ITPluggableTerminalSuperclassInfo;
const GUID IID_ITPrivateEvent                           = GUIDOF!ITPrivateEvent;
const GUID IID_ITQOSEvent                               = GUIDOF!ITQOSEvent;
const GUID IID_ITQueue                                  = GUIDOF!ITQueue;
const GUID IID_ITQueueEvent                             = GUIDOF!ITQueueEvent;
const GUID IID_ITRendezvous                             = GUIDOF!ITRendezvous;
const GUID IID_ITRequest                                = GUIDOF!ITRequest;
const GUID IID_ITRequestEvent                           = GUIDOF!ITRequestEvent;
const GUID IID_ITScriptableAudioFormat                  = GUIDOF!ITScriptableAudioFormat;
const GUID IID_ITStaticAudioTerminal                    = GUIDOF!ITStaticAudioTerminal;
const GUID IID_ITStream                                 = GUIDOF!ITStream;
const GUID IID_ITStreamControl                          = GUIDOF!ITStreamControl;
const GUID IID_ITSubStream                              = GUIDOF!ITSubStream;
const GUID IID_ITSubStreamControl                       = GUIDOF!ITSubStreamControl;
const GUID IID_ITTAPI                                   = GUIDOF!ITTAPI;
const GUID IID_ITTAPI2                                  = GUIDOF!ITTAPI2;
const GUID IID_ITTAPICallCenter                         = GUIDOF!ITTAPICallCenter;
const GUID IID_ITTAPIDispatchEventNotification          = GUIDOF!ITTAPIDispatchEventNotification;
const GUID IID_ITTAPIEventNotification                  = GUIDOF!ITTAPIEventNotification;
const GUID IID_ITTAPIObjectEvent                        = GUIDOF!ITTAPIObjectEvent;
const GUID IID_ITTAPIObjectEvent2                       = GUIDOF!ITTAPIObjectEvent2;
const GUID IID_ITTTSTerminalEvent                       = GUIDOF!ITTTSTerminalEvent;
const GUID IID_ITTerminal                               = GUIDOF!ITTerminal;
const GUID IID_ITTerminalSupport                        = GUIDOF!ITTerminalSupport;
const GUID IID_ITTerminalSupport2                       = GUIDOF!ITTerminalSupport2;
const GUID IID_ITToneDetectionEvent                     = GUIDOF!ITToneDetectionEvent;
const GUID IID_ITToneTerminalEvent                      = GUIDOF!ITToneTerminalEvent;
